ersProperty::OnChangeUser()
{
    //
    // If you can not access remote WBEM, you can not modify RunAs info,
    // changing the user name is not allowed.
    //
    if (m_bCanAccessRemoteWbem) {
        // When the user hits OK in the password dialog,
        // the user name might not have changed.
        UpdateData ( TRUE );

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        if ( 0 != m_strUserSaved.Compare ( m_strUserDisplay ) ) {
            m_pTraceLogQuery->m_fDirtyPassword = PASSWORD_DIRTY;
            SetModifiedPage(TRUE);
        }
        else {
            m_pTraceLogQuery->m_fDirtyPassword &= ~PASSWORD_DIRTY;
        }
        //
        // If default user is typed, never need to set password
        //
        if (m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {
            if (m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
                m_bPwdButtonEnabled = FALSE;
            }
        }
        else {
            if (!m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(TRUE);
                m_bPwdButtonEnabled = TRUE;
            }
        }
    }
    else {
        //
        // We can not modify the RunAs info, then display
        // an error message and retore the original user name in RunAs
        //
        UpdateData(TRUE);
        if (ConnectRemoteWbemFail(m_pTraceLogQuery, FALSE)) {
            GetDlgItem(IDC_RUNAS_EDIT)->SetWindowText(m_strUserSaved);
        }
    }
}

void CProvidersProperty::OnPwdBtn()
{
    CString strTempUser;

    UpdateData();

    if (!m_bCanAccessRemoteWbem) {
        ConnectRemoteWbemFail(m_pTraceLogQuery, TRUE);
        return;
    }
    MFC_TRY
        strTempUser = m_strUserDisplay;

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        m_pTraceLogQuery->m_strUser = m_strUserDisplay;

        SetRunAs(m_pTraceLogQuery);

        m_strUserDisplay = m_pTraceLogQuery->m_strUser;

        if ( 0 != strTempUser.CompareNoCase ( m_strUserDisplay ) ) {
            SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
        }
    MFC_CATCH_MINIMUM;
}

void CProvidersProperty::OnProvAddBtn() 
{
    ImplementAdd();
}


void CProvidersProperty::OnProvRemoveBtn() 
{
    CListBox    *plbProviderList;
    LONG        lThisItem;
    BOOL        bDone;
    LONG        lOrigCaret;
    LONG        lItemStatus;
    LONG        lItemCount;
    BOOL        bChanged = FALSE;
    DWORD       dwItemExtent;
    CString     strItemText;

    plbProviderList = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
    // delete all selected items in the list box and
    // set the cursor to the item above the original caret position
    // or the first or last if that is out of the new range
    lOrigCaret = plbProviderList->GetCaretIndex();
    lThisItem = 0;
    bDone = FALSE;
    // clear the max extent
    m_dwMaxHorizListExtent = 0;
    // clear the value 
    do {
        lItemStatus = plbProviderList->GetSel(lThisItem);
        if (lItemStatus > 0) {
            // then it's selected so delete it
            INT iProvIndex = (INT)plbProviderList->GetItemData ( lThisItem );
            m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eNotInQuery;
            plbProviderList->DeleteString ( lThisItem );
            bChanged = TRUE;
        } else if (lItemStatus == 0) {
            // get the text length of this item since it will stay
            plbProviderList->GetText(lThisItem, strItemText);
            dwItemExtent = (DWORD)((plbProviderList->GetDC())->GetTextExtent(strItemText)).cx;
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
            // then it's not selected so go to the next one
            lThisItem++;
        } else {
            // we've run out so exit
            bDone = TRUE;
        }
    } while (!bDone);

    // update the text extent of the list box
    plbProviderList->SetHorizontalExtent(m_dwMaxHorizListExtent);

    // see how many entries are left and update the
    // caret position and the remove button state
    lItemCount = plbProviderList->GetCount();
    if (lItemCount > 0) {
        // the update the caret
        if (lOrigCaret >= lItemCount) {
            lOrigCaret = lItemCount-1;
        } else {
            // caret should be within the list
        }
        plbProviderList->SetSel(lOrigCaret);
        plbProviderList->SetCaretIndex(lOrigCaret);
    } else {
        // the list is empty so remove caret, selection
        plbProviderList->SetSel(-1);
        if ( eTraceModeApplication == m_dwTraceMode )
            GetDlgItem(IDC_PROV_ADD_BTN)->SetFocus();
    }

    SetTraceModeState();
    
    SetModifiedPage(bChanged);
}

void CProvidersProperty::OnDblclkProvProviderList() 
{
    ImplementAdd();
}

void CProvidersProperty::OnSelcancelProvProviderList() 
{
    SetAddRemoveBtnState();    
}

void CProvidersProperty::OnSelchangeProvProviderList() 
{
    SetAddRemoveBtnState();    
}

void 
CProvidersProperty::DoProvidersDataExchange ( CDataExchange* pDX) 
{
    CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
    long    lNumProviders;

    if ( m_bNonsystemProvidersExist ) {
    
        if ( TRUE == pDX->m_bSaveAndValidate ) {

            // update the provider array based on list box contents.

            lNumProviders = plbInQueryProviders->GetCount();
            if (lNumProviders != LB_ERR) {
                long    lThisProvider;
                INT     iProvIndex;

                // Reset InQuery array, retaining state for eInactive providers.
                m_pTraceLogQuery->GetInQueryProviders ( m_arrGenProviders );
        
                // Reset eInQuery to eNotInQuery, in case some were removed from the query.
                for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
                    if ( CSmTraceLogQuery::eInQuery == m_arrGenProviders[iProvIndex] )
                       m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eNotInQuery;
                }

                lThisProvider = 0;
                while (lThisProvider < lNumProviders) {
                    iProvIndex = (INT)plbInQueryProviders->GetItemData( lThisProvider );
                    m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eInQuery;
                    lThisProvider++; 
                }
            }
        } else {

            // Reset the list box.
            CString  strProviderName;
            INT iProvIndex;
            DWORD dwItemExtent;

            ASSERT( NULL != m_pTraceLogQuery );

            //load nonsystem provider list box from string in provider list
            plbInQueryProviders->ResetContent();

            for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
                if ( CSmTraceLogQuery::eInQuery == m_arrGenProviders[iProvIndex] ) {
                    INT iAddIndex;
                    GetProviderDescription( iProvIndex, strProviderName );
                    iAddIndex = plbInQueryProviders->AddString ( strProviderName );
                    plbInQueryProviders->SetItemData ( iAddIndex, ( DWORD ) iProvIndex );
                    // update list box extent
                    dwItemExtent = (DWORD)((plbInQueryProviders->GetDC())->GetTextExtent (strProviderName)).cx;
                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                        plbInQueryProviders->SetHorizontalExtent(dwItemExtent);
                    }

                }
            }
        }
    }
}

BOOL 
CProvidersProperty::IsValidLocalData( ) 
{
    BOOL bIsValid = TRUE;
    ResourceStateManager    rsm;

    if ( eTraceModeKernel == m_dwTraceMode ) {
        DWORD dwKernelFlags = 0;

        // Ensure that the user has enabled at least one of the 4 basic Kernel traces.
        if ( m_bEnableProcessTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_PROCESS_TRACE;
        }

        if ( m_bEnableThreadTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_THREAD_TRACE;
        }

        if ( m_bEnableDiskIoTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_DISKIO_TRACE;
        }

        if ( m_bEnableNetworkTcpipTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE;
        }

        if ( 0 == dwKernelFlags ) {
            CString strMsg;

            strMsg.LoadString ( IDS_KERNEL_PROVIDERS_REQUIRED );
    
            MessageBox ( strMsg, m_pTraceLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            GetDlgItem ( IDC_PROV_KERNEL_BTN )->SetFocus();
            bIsValid = FALSE;
        }
    } else {
        CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
    
        if ( !m_bNonsystemProvidersExist || 0 == plbInQueryProviders->GetCount() ) {
            CString strMsg;

            strMsg.LoadString ( IDS_APP_PROVIDERS_REQUIRED );
    
            MessageBox ( strMsg, m_pTraceLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            GetDlgItem ( IDC_PROV_ADD_BTN )->SetFocus();
            bIsValid = FALSE;
        }
    }

    return bIsValid;
}    

void 
CProvidersProperty::OnProvTraceModeRdo() 
{
    UpdateData ( TRUE );
    SetModifiedPage ( TRUE );
}

void
CProvidersProperty::OnCancel()
{
    m_pTraceLogQuery->SyncPropPageSharedData();  // clear memory shared between property pages.
}

BOOL 
CProvidersProperty::OnApply() 
{   
    BOOL bContinue = TRUE;

    bContinue = UpdateData ( TRUE );

    if ( bContinue ) {
        bContinue = IsValidData(m_pTraceLogQuery, VALIDATE_APPLY );
    }

    // Write the data to the query.
    if ( bContinue ) {
        if ( eTraceModeKernel == m_dwTraceMode ) {
            DWORD dwKernelFlags = 0;
            INT     iProvIndex;

            if ( m_bEnableProcessTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_PROCESS_TRACE;
            }

            if ( m_bEnableThreadTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_THREAD_TRACE;
            }

            if ( m_bEnableDiskIoTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_DISKIO_TRACE;
            }

            if ( m_bEnableNetworkTcpipTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE;
            }

            // Ensure that the user has enabled at least one of the 4 basic Kernel traces.
            ASSERT ( 0 != dwKernelFlags );
            
            if ( m_bEnableMemMgmtTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_MEMMAN_TRACE;
            }

            if ( m_bEnableFileIoTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_FILEIO_TRACE;
            }

            m_pTraceLogQuery->SetKernelFlags (dwKernelFlags);
            
            // Erase all InQuery providers.
            for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
                if ( CSmTraceLogQuery::eInQuery == m_arrGenProviders[iProvIndex] )
                   m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eNotInQuery;
            }
        
            m_pTraceLogQuery->SetInQueryProviders ( m_arrGenProviders );

        } else {
            CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
       
            ASSERT ( 0 < plbInQueryProviders->GetCount() );
            m_pTraceLogQuery->SetInQueryProviders ( m_arrGenProviders );
            // Reset kernel flags 
            m_pTraceLogQuery->SetKernelFlags (0);
        }
    }

    if ( bContinue ) {
        bContinue = Apply(m_pTraceLogQuery); 
    }

    if ( bContinue ){
        bContinue = CPropertyPage::OnApply();
    }

    if ( bContinue ) {

        // Save property page shared data.
        m_pTraceLogQuery->UpdatePropPageSharedData();

        bContinue = UpdateService ( m_pTraceLogQuery, TRUE );
    }

    return bContinue;
}

BOOL CProvidersProperty::OnInitDialog() 
{
    DWORD dwStatus;
    DWORD dwKernelFlags;
    CListBox * plbInQueryProviders;
    BOOL    bDeleteInactiveProviders = FALSE;
    INT     iIndex;
    ResourceStateManager    rsm;

    //
    // Here m_pTraceLogQuery should not be NULL, if it is,
    // There must be something wrong.
    //
    if ( NULL == m_pTraceLogQuery ) {
        return TRUE;
    }

    m_bCanAccessRemoteWbem = m_pTraceLogQuery->GetLogService()->CanAccessWbemRemote();
    m_pTraceLogQuery->SetActivePropertyPage( this );

    dwStatus = m_pTraceLogQuery->InitGenProvidersArray();    

    if ( SMCFG_INACTIVE_PROVIDER == dwStatus ) {
        CString strMessage;
        CString strSysMessage;
        INT_PTR iResult;

        FormatSmLogCfgMessage ( 
            strMessage,
            m_hModule, 
            SMCFG_INACTIVE_PROVIDER, 
            m_pTraceLogQuery->GetLogName() );

        iIndex = m_pTraceLogQuery->GetFirstInactiveIndex();

        while ( -1 != iIndex ) {
            CString strNextName;
       
            GetProviderDescription( iIndex, strNextName );

            strMessage += _T("\n    ");
            strMessage += strNextName;
            iIndex = m_pTraceLogQuery->GetNextInactiveIndex();
        }

        iResult = MessageBox( 
            (LPCWSTR)strMessage,
            m_pTraceLogQuery->GetLogName(),
            MB_YESNO | MB_ICONWARNING
            );

        if ( IDYES == iResult ) {
            bDeleteInactiveProviders = TRUE;
        }
    }

    // Continue even if no active providers exist.
    plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);

    // Initialize from model.
    dwStatus = m_pTraceLogQuery->GetInQueryProviders ( m_arrGenProviders );

    if ( bDeleteInactiveProviders ) {
        // Delete all inactive providers
        iIndex = m_pTraceLogQuery->GetFirstInactiveIndex();
        while ( -1 != iIndex ) {
            m_arrGenProviders[iIndex] = CSmTraceLogQuery::eNotInQuery;

            iIndex = m_pTraceLogQuery->GetNextInactiveIndex();
        }
    }

    m_bNonsystemProvidersExist = FALSE;
    for ( iIndex = 0; iIndex < m_arrGenProviders.GetSize(); iIndex++ ) {
        if ( m_pTraceLogQuery->IsActiveProvider ( iIndex ) ) {
            m_bNonsystemProvidersExist = TRUE;
            break;
        }
    }

    m_pTraceLogQuery->GetKernelFlags (dwKernelFlags);

    if ( (dwKernelFlags & SLQ_TLI_ENABLE_KERNEL_TRACE) != 0) {
        // NT5 Beta2 Kernel trace flag in use to cover all four basic trace.
        m_bEnableProcessTrace = TRUE;
        m_bEnableThreadTrace = TRUE;
        m_bEnableDiskIoTrace = TRUE;
        m_bEnableNetworkTcpipTrace = TRUE;
    } else {
        m_bEnableProcessTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_PROCESS_TRACE) != 0);
        m_bEnableThreadTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_THREAD_TRACE) != 0);
        m_bEnableDiskIoTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_DISKIO_TRACE) != 0);
        m_bEnableNetworkTcpipTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE) != 0);
    }
    m_bEnableMemMgmtTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_MEMMAN_TRACE) != 0);
    m_bEnableFileIoTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_FILEIO_TRACE) != 0);

    m_dwTraceMode = ( 0 != dwKernelFlags ) ? eTraceModeKernel : eTraceModeApplication;

    if ( eTraceModeApplication == m_dwTraceMode ) {
        // If initial mode is set to Application, initialize the Kernel
        // trace events to the default.
        m_bEnableProcessTrace = TRUE;
        m_bEnableThreadTrace = TRUE;
        m_bEnableDiskIoTrace = TRUE;
        m_bEnableNetworkTcpipTrace = TRUE;
    }

    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );
    Initialize( m_pTraceLogQuery );
    m_strUserDisplay = m_pTraceLogQuery->m_strUser;
    m_strUserSaved = m_strUserDisplay;

    SetDetailsGroupBoxMode();

    SetTraceModeState();

    if ( m_bNonsystemProvidersExist ) {
        if ( 0 < plbInQueryProviders->GetCount() ) {
            // select first entry
            plbInQueryProviders->SetSel (0, TRUE);
            plbInQueryProviders->SetCaretIndex (0, TRUE);
        } else {
            plbInQueryProviders->SetSel (-1, TRUE);
            GetDlgItem(IDC_PROV_ADD_BTN)->SetFocus();
        }
    } else {
        CString strNoProviders;

        strNoProviders.LoadString( IDS_PROV_NO_PROVIDERS );
        plbInQueryProviders->AddString( strNoProviders );
        plbInQueryProviders->EnableWindow(FALSE);

        GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(FALSE);
        GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(FALSE);
    }
    if (m_pTraceLogQuery->GetLogService()->IsWindows2000Server()) {
        CWnd* pRunAsStatic;

        //
        // Get the static "Run As" window, you can only call this function
        // when "Run As" really exists
        //
        pRunAsStatic = GetRunAsWindow();
        if (pRunAsStatic) {
            pRunAsStatic->EnableWindow(FALSE);
        }
        GetDlgItem(IDC_RUNAS_EDIT)->EnableWindow(FALSE);
    }

    if (m_pTraceLogQuery->GetLogService()->IsWindows2000Server() ||
        m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {

        GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
        m_bPwdButtonEnabled = FALSE;
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProvidersProperty::PostNcDestroy() 
{
//  delete this;      

    if ( NULL != m_pTraceLogQuery ) {
        m_pTraceLogQuery->SetActivePropertyPage( NULL );
    }

    CPropertyPage::PostNcDestroy();
}

//
// Helper functions.
//
void 
CProvidersProperty::SetAddRemoveBtnState ( void )
{
    if ( m_bNonsystemProvidersExist ) {
        
        if ( eTraceModeKernel == m_dwTraceMode ) {
            GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(FALSE);
            GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(FALSE);
        } else { 
            CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
            INT iTotalCount;

            iTotalCount = plbInQueryProviders->GetCount();

            if ( 0 < plbInQueryProviders->GetSelCount() ) {
                GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(TRUE);
            } else {
                GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(FALSE);
            }

            if ( iTotalCount < m_arrGenProviders.GetSize() ) {
                GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(TRUE);
            } else {
                GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(FALSE);
            }

            if ( 0 == iTotalCount ) {
                plbInQueryProviders->SetSel(-1);
            }
        }     
    }
}


//
//  Return the description for the trace provider specified by
//  InQuery array index.
//  
DWORD   
CProvidersProperty::GetProviderDescription ( INT iProvIndex, CString& rstrDesc )
{
    ASSERT ( NULL != m_pTraceLogQuery );

    rstrDesc = m_pTraceLogQuery->GetProviderDescription ( iProvIndex );

    // If the description is empty, build name from guid.
    if ( rstrDesc.IsEmpty() ) {
        CString strGuid;
        ASSERT( !m_pTraceLogQuery->IsActiveProvider( iProvIndex) );
        strGuid = m_pTraceLogQuery->GetProviderGuid( iProvIndex );
        rstrDesc.Format ( IDS_PROV_UNKNOWN, strGuid );
    }

    return ERROR_SUCCESS;
}

BOOL 
CProvidersProperty::IsEnabledProvider( INT iIndex )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->IsEnabledProvider ( iIndex ) );
}

BOOL 
CProvidersProperty::IsActiveProvider( INT iIndex )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->IsActiveProvider ( iIndex ) );
}

LPCTSTR 
CProvidersProperty::GetKernelProviderDescription( void )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->GetKernelProviderDescription ( ) );
}

BOOL 
CProvidersProperty::GetKernelProviderEnabled( void )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->GetKernelProviderEnabled ( ) );
}

//
//  Update the provided InQuery array to match the stored version.
//  
DWORD 
CProvidersProperty::GetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& rarrOut )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iIndex;

    rarrOut.RemoveAll();

    rarrOut.SetSize( m_arrGenProviders.GetSize() );

    for ( iIndex = 0; iIndex < rarrOut.GetSize(); iIndex++ ) {
        rarrOut[iIndex] = m_arrGenProviders[iIndex];
    }

    return dwStatus;
}

//
//  Load the stored InQuery providers array 
//  based on the provided version.
//  
DWORD 
CProvidersProperty::SetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& rarrIn )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iProvIndex;

    m_arrGenProviders.RemoveAll();

    m_arrGenProviders.SetSize( rarrIn.GetSize() );

    for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
        m_arrGenProviders[iProvIndex] = rarrIn[iProvIndex];
    }

    return dwStatus;
}

void 
CProvidersProperty::ImplementAdd( void ) 
{
    INT_PTR iReturn = IDCANCEL;
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        CProviderListDlg dlgAddProviders(this);

        // Workaround for popup to store pointer to this page.
        dlgAddProviders.SetProvidersPage( this );
        
        iReturn = dlgAddProviders.DoModal();
    }

    if ( IDOK == iReturn ) {
        LONG    lBeforeCount;
        LONG    lAfterCount;
        CListBox    *plbProviderList;

        plbProviderList = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);

        // Providers array is modified by the add dialog OnOK procedure.
        lBeforeCount = plbProviderList->GetCount();
        UpdateData ( FALSE );
        lAfterCount = plbProviderList->GetCount();

        SetAddRemoveBtnState();

        if ( lAfterCount > lBeforeCount ) {
            SetModifiedPage ( TRUE );
        }
    }
}

void 
CProvidersProperty::UpdateLogStartString ()
{
    eStartType  eCurrentStartType;
    int     nResId = 0;
    ResourceStateManager    rsm;

    eCurrentStartType = DetermineCurrentStartType();

    if ( eStartManually == eCurrentStartType ) {
        nResId = IDS_LOG_START_MANUALLY;
    } else if ( eStartImmediately == eCurrentStartType ) {
        nResId = IDS_LOG_START_IMMED;
    } else if ( eStartSched == eCurrentStartType ) {
        nResId = IDS_LOG_START_SCHED;
    }

    if ( 0 != nResId ) {
        m_strStartText.LoadString(nResId);
    } else {
        m_strStartText.Empty();
    }

    return;
}

void 
CProvidersProperty::UpdateFileNameString ()
{
    m_strFileNameDisplay.Empty();

    CreateSampleFileName (
        m_pTraceLogQuery->GetLogName(),
        m_pTraceLogQuery->GetLogService()->GetMachineName(),
        m_SharedData.strFolderName, 
        m_SharedData.strFileBaseName,
        m_SharedData.strSqlName,
        m_SharedData.dwSuffix, 
        m_SharedData.dwLogFileType,
        m_SharedData.dwSerialNumber,
        m_strFileNameDisplay);

    SetDlgItemText( IDC_PROV_FILENAME_DISPLAY, m_strFileNameDisplay );
    
    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_PROV_FILENAME_DISPLAY ))->SetSel ( -1, 0 );

    return;
}

BOOL 
CProvidersProperty::OnSetActive()
{

    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if (!bReturn) return FALSE;

    ResourceStateManager    rsm;

    m_pTraceLogQuery->GetPropPageSharedData ( &m_SharedData );

    UpdateFileNameString();

    UpdateLogStartString();
    m_strUserDisplay = m_pTraceLogQuery->m_strUser;

    UpdateData(FALSE); //to load the edit & combo box

    return TRUE;
}

BOOL 
CProvidersProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;
        
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        m_pTraceLogQuery->m_strUser = m_strUserDisplay;
        bContinue = IsValidData(m_pTraceLogQuery, VALIDATE_FOCUS );
    }

    // The providers page does not modify shared data, so no reason to update it.

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

void 
CProvidersProperty::OnProvKernelEnableCheck() 
{
    BOOL bMemFlag = m_bEnableMemMgmtTrace;
    BOOL bFileFlag = m_bEnableFileIoTrace;

    UpdateData(TRUE);
    SetModifiedPage(TRUE);

    bMemFlag  = (!bMemFlag && m_bEnableMemMgmtTrace);
    bFileFlag = (!bFileFlag && m_bEnableFileIoTrace);

    if (bMemFlag || bFileFlag) {
        long nErr;
        HKEY hKey;
        DWORD dwWarnFlag;
        DWORD dwDataType;
        DWORD dwDataSize;
        DWORD dwDisposition;

        // User has checked expensive file io flag
        // check registry setting to see if we need to pop up warning dialog
        nErr = RegOpenKey( HKEY_CURRENT_USER,
                           _T("Software\\Microsoft\\PerformanceLogsandAlerts"),
                           &hKey
                         );
        dwWarnFlag = 0;
        if( nErr == ERROR_SUCCESS ) {

            dwDataSize = sizeof(DWORD);
            nErr = RegQueryValueExW(
                        hKey,
                        (bMemFlag ? _T("NoWarnPageFault") : _T("NoWarnFileIo")),
                        NULL,
                        &dwDataType,
                        (LPBYTE) &dwWarnFlag,
                        (LPDWORD) &dwDataSize
                        );
            if ( (dwDataType != REG_DWORD) || (dwDataSize != sizeof(DWORD)))
                dwWarnFlag = 0;

            nErr = RegCloseKey( hKey );
            if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(), _T("Close PerfLog user Key Failed")  );
        }
        if (!dwWarnFlag || nErr != ERROR_SUCCESS) {
            // Pop a dialog here. Need to do a RegQuerySetValue dialog is checked to keep quiet
            // bMemFlag & bFileFlag gives a clue about what it is doing

            CWarnDlg    WarnDlg;
            
            AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
            WarnDlg.SetProvidersPage( this );

            if (IDOK == WarnDlg.DoModal()){
                if (WarnDlg.m_CheckNoMore){
                    dwWarnFlag = WarnDlg.m_CheckNoMore;

                    nErr = RegCreateKeyEx( HKEY_CURRENT_USER,
                                       _T("Software\\Microsoft\\PerformanceLogsAndAlerts"),
                                       0,
                                       _T("REG_DWORD"),
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_ALL_ACCESS,
                                       NULL,
                                       &hKey,
                                       &dwDisposition);
                    if(ERROR_SUCCESS == nErr){
                        if (dwDisposition == REG_CREATED_NEW_KEY){
                            //just in case I need this
                        }else if (dwDisposition  == REG_OPENED_EXISTING_KEY){
                            //Just in case I need this 
                        }
                    }

                    if( nErr == ERROR_SUCCESS ) {
                        dwDataSize = sizeof(DWORD);
                        nErr = RegSetValueEx(hKey,
                                    (bMemFlag ? _T("NoWarnPageFault") : _T("NoWarnFileIo") ),
                                    NULL,
                                    REG_DWORD,
                                    (LPBYTE) &dwWarnFlag,
                                    dwDataSize
                                    );
                    if( ERROR_SUCCESS != nErr )
                        DisplayError( GetLastError(), _T("Close PerfLog User Key failed")  );

                    }

                    
                }

            }
            
        }
    }
}

void
CProvidersProperty::OnProvShowProvBtn() 
{
    CActiveProviderDlg ProvLstDlg;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ProvLstDlg.SetProvidersPage( this );

    ProvLstDlg.DoModal();

}
/*
void 
CProvidersProperty::OnProvDetailsBtn() 
{
    SetDetailsGroupBoxMode();
}
*/
BOOL    
CProvidersProperty::SetDetailsGroupBoxMode()
{

    UINT    nWindowState;

    ResourceStateManager    rsm;

    nWindowState = SW_SHOW;

    GetDlgItem(IDC_PROV_K_PROCESS_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_THREAD_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_DISK_IO_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_NETWORK_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_SOFT_PF_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_FILE_IO_CHK)->ShowWindow(nWindowState);

    return TRUE;
}

void 
CProvidersProperty::TraceModeRadioExchange(CDataExchange* pDX)
{
    if ( !pDX->m_bSaveAndValidate ) {
        // Load control value from data

        switch ( m_dwTraceMode ) {
            case eTraceModeKernel:
                m_nTraceModeRdo = 0;
                break;
            case eTraceModeApplication:
                m_nTraceModeRdo = 1;
                break;
            default:
                ;
                break;
        }
    }

    DDX_Radio(pDX, IDC_PROV_KERNEL_BTN, m_nTraceModeRdo);

    if ( pDX->m_bSaveAndValidate ) {

        switch ( m_nTraceModeRdo ) {
            case 0:
                m_dwTraceMode = eTraceModeKernel;
                break;
            case 1:
                m_dwTraceMode = eTraceModeApplication;
                break;
            default:
                ;
                break;
        }
        SetTraceModeState();
    }

}

void 
CProvidersProperty::SetTraceModeState ( void )
{
    BOOL bEnable;

    bEnable = (eTraceModeKernel == m_dwTraceMode) ? TRUE : FALSE; 
    // Kernel trace controls    
//    GetDlgItem(IDC_PROV_SHOW_ADV_BTN)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_PROCESS_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_THREAD_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_DISK_IO_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_NETWORK_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_SOFT_PF_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_FILE_IO_CHK)->EnableWindow(bEnable);

    if ( m_bNonsystemProvidersExist ) {
        bEnable = !bEnable;
        // Application trace controls
        GetDlgItem(IDC_PROV_PROVIDER_LIST)->EnableWindow(bEnable);
        SetAddRemoveBtnState();
    }

}

DWORD 
CProvidersProperty::GetGenProviderCount ( INT& iCount )
{
    return m_pTraceLogQuery->GetGenProviderCount( iCount );

}

void CProvidersProperty::GetMachineDisplayName ( CString& rstrMachineName )
{
    m_pTraceLogQuery->GetMachineDisplayName( rstrMachineName );
    return;
}

CSmTraceLogQuery* 
CProvidersProperty::GetTraceQuery ( void )
{
    return m_pTraceLogQuery;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\provprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provprop.h

Abstract:

    Header file for the trace providers general property page.

--*/

#ifndef _PROVPROP_H_
#define _PROVPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smproppg.h"   // Base class
#include "smtraceq.h"   // For provider states
#include "smcfghlp.h"

// Dialog controls
#define IDD_PROVIDERS_PROP              1000

#define IDC_PROV_FILENAME_CAPTION       1001
#define IDC_PROV_LOG_SCHED_TEXT         1002
#define IDC_PROV_FIRST_HELP_CTRL_ID     1003
#define IDC_PROV_FILENAME_DISPLAY       1003
#define IDC_PROV_PROVIDER_LIST          1004
#define IDC_PROV_ADD_BTN                1005
#define IDC_PROV_REMOVE_BTN             1006
#define IDC_PROV_KERNEL_BTN             1007
#define IDC_PROV_OTHER_BTN              1008
#define IDC_PROV_K_PROCESS_CHK          1009
#define IDC_PROV_K_THREAD_CHK           1010
#define IDC_PROV_K_DISK_IO_CHK          1011
#define IDC_PROV_K_NETWORK_CHK          1012
#define IDC_PROV_K_SOFT_PF_CHK          1013
#define IDC_PROV_K_FILE_IO_CHK          1014
#define IDC_PROV_SHOW_PROVIDERS_BTN     1015


/////////////////////////////////////////////////////////////////////////////
// CProvidersProperty dialog

class CProvidersProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CProvidersProperty)

// Construction
public:
            CProvidersProperty();
            CProvidersProperty(MMC_COOKIE   lCookie, LONG_PTR hConsole);
    virtual ~CProvidersProperty();

// Dialog Data
    //{{AFX_DATA(CProvidersProperty)
    enum { IDD = IDD_PROVIDERS_PROP };
    INT     m_nTraceModeRdo;
    BOOL    m_bEnableProcessTrace;
    BOOL    m_bEnableThreadTrace;
    BOOL    m_bEnableDiskIoTrace;
    BOOL    m_bEnableNetworkTcpipTrace;
    BOOL    m_bEnableMemMgmtTrace;
    BOOL    m_bEnableFileIoTrace;
    BOOL    m_bNonsystemProvidersExist;
    //}}AFX_DATA

public: 
            DWORD   GetGenProviderCount ( INT& iCount );
            DWORD   GetProviderDescription ( INT iUnusedIndex, CString& rstrDesc );
            BOOL    IsEnabledProvider ( INT iIndex );
            BOOL    IsActiveProvider ( INT iIndex );
            LPCTSTR GetKernelProviderDescription ( void );
            BOOL    GetKernelProviderEnabled ( void );

            DWORD   GetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& );
            DWORD   SetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& );

            void    GetMachineDisplayName( CString& );
            CSmTraceLogQuery*    GetTraceQuery( void );


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CProvidersProperty)
    public:
    protected:
    virtual void OnFinalRelease();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_PROV_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData();

    // Generated message map functions
    //{{AFX_MSG(CProvidersProperty)
//    afx_msg void OnProvDetailsBtn();
    afx_msg void OnProvShowProvBtn();
    afx_msg void OnProvAddBtn();
    afx_msg void OnProvExplainBtn();
    afx_msg void OnProvRemoveBtn();
    afx_msg void OnDblclkProvProviderList();
    afx_msg void OnSelcancelProvProviderList();
    afx_msg void OnSelchangeProvProviderList();
    afx_msg void OnProvKernelEnableCheck();
    afx_msg void OnProvTraceModeRdo();
   	afx_msg void OnPwdBtn();
    afx_msg void OnChangeUser();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:

    enum eTraceMode {
        eTraceModeKernel = 1,
        eTraceModeApplication = 2
    };
    
    void    DoProvidersDataExchange ( CDataExchange* pDX );
    void    SetAddRemoveBtnState ( void );
    void    SetTraceModeState ( void );
    void    ImplementAdd ( void );

    void    UpdateFileNameString ( void );
    void    UpdateLogStartString ( void );
    BOOL    SetDetailsGroupBoxMode ( void );
    void    TraceModeRadioExchange ( CDataExchange* ); 

    CSmTraceLogQuery    *m_pTraceLogQuery;
    CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&> m_arrGenProviders;
    CString             m_strFileNameDisplay;
    CString             m_strStartText;
    DWORD               m_dwTraceMode;

    DWORD           m_dwMaxHorizListExtent;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _PROVPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\schdprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    schdprop.h

Abstract:

	Implementation of the schedule property page.

--*/

#ifndef _SCHDPROP_H_
#define _SCHDPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smlogqry.h"   // For shared property page data structure
#include "smproppg.h"
#include "smcfghlp.h"

// Dialog controls

#define IDD_SCHEDULE_PROP               600

#define IDC_SCHED_START_GROUP           601
#define IDC_SCHED_STOP_GROUP            602
#define IDC_SCHED_START_AT_ON_CAPTION   603
#define IDC_SCHED_STOP_AT_ON_CAPTION    604
#define IDC_SCHED_STOP_AFTER_STATIC     605
#define IDC_SCHED_STOP_WHEN_STATIC      606
#define IDC_SCHED_FIRST_HELP_CTRL_ID    607
#define IDC_SCHED_START_MANUAL_RDO      607
#define IDC_SCHED_START_AT_RDO          608
#define IDC_SCHED_START_AT_TIME_DT      609    
#define IDC_SCHED_START_AT_DATE_DT      610
#define IDC_SCHED_STOP_MANUAL_RDO       611
#define IDC_SCHED_STOP_AT_RDO           612
#define IDC_SCHED_STOP_AFTER_RDO        613
#define IDC_SCHED_STOP_SIZE_RDO         614
#define IDC_SCHED_STOP_AT_TIME_DT       615
#define IDC_SCHED_STOP_AT_DATE_DT       616
#define IDC_SCHED_STOP_AFTER_EDIT       617
#define IDC_SCHED_STOP_AFTER_SPIN       618
#define IDC_SCHED_STOP_AFTER_UNITS_COMBO 619

#define IDC_SCHED_RESTART_CHECK         620
#define IDC_SCHED_EXEC_CHECK            621
#define IDC_SCHED_CMD_EDIT              622
#define IDC_SCHED_CMD_BROWSE_BTN        623


/////////////////////////////////////////////////////////////////////////////
// CScheduleProperty dialog

class CScheduleProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CScheduleProperty)

// Construction
public:
            CScheduleProperty(
                MMC_COOKIE lCookie, 
                LONG_PTR hConsole,
                LPDATAOBJECT pDataObject);
            CScheduleProperty();
    virtual ~CScheduleProperty();

// Dialog Data
    //{{AFX_DATA(CScheduleProperty)
    enum { IDD = IDD_SCHEDULE_PROP };
    INT     m_nStopModeRdo;
    INT     m_nStartModeRdo;
    SYSTEMTIME  m_stStartAt;
    SYSTEMTIME  m_stStopAt;
    DWORD   m_dwStopAfterCount;
    INT     m_nStopAfterUnits;
    BOOL    m_bAutoRestart;
    CString m_strEofCommand;
    BOOL    m_bExecEofCommand;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CScheduleProperty)
    public:
    protected:
    virtual void OnFinalRelease();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_SCHED_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL IsValidLocalData ();

    // Generated message map functions
    //{{AFX_MSG(CScheduleProperty)
    afx_msg void OnSchedCmdBrowseBtn();
    afx_msg void OnSchedRestartCheck();
    afx_msg void OnSchedExecCheck();
    afx_msg void OnSchedStartRdo();
    afx_msg void OnSchedStopRdo();
    afx_msg void OnKillfocusSchedStartAtDt(NMHDR*, LRESULT*);
    afx_msg void OnKillfocusSchedCmdEdit();
    afx_msg void OnKillfocusSchedStopAfterEdit();
    afx_msg void OnKillfocusSchedStopAtDt(NMHDR*, LRESULT*);
    afx_msg void OnDeltaposSchedStopAfterSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelendokSchedStopAfterUnitsCombo();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CScheduleProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

// private methods
private:
    void SetStartBtnState ( void );
    void SetStopBtnState ( void );
    void SetCmdBtnState ( void );
    void StartModeRadioExchange ( CDataExchange* ); 
    void StopModeRadioExchange ( CDataExchange* ); 
    
    void StartAtExchange ( CDataExchange* ); 
    void StopAtExchange ( CDataExchange* ); 

    void FillStartTimeStruct ( PSLQ_TIME_INFO );
    void UpdateSharedStopTimeStruct ( void );
    void SetStopDefaultValues ( PSLQ_TIME_INFO );

    BOOL SaveDataToModel ( void );

// public methods
public:

// private member variables
private:
    CSmLogQuery         *m_pLogQuery;
    LONGLONG            m_llManualStartTime;
    LONGLONG            m_llManualStopTime;
    DWORD               m_dwStopAfterUnitsValue;
    DWORD               m_dwCurrentStartMode;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _SCHDPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smabout.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smabout.cpp

Abstract:

    Implementation of the ISnapinAbout MMC interface.

--*/

#include "stdafx.h"
#include "smabout.h" 
#include <ntverp.h>

CSmLogAbout::CSmLogAbout()
:   m_uIdStrDescription ( IDS_SNAPINABOUT_DESCRIPTION ),
    m_uIdStrProvider ( IDS_SNAPINABOUT_PROVIDER ),
	m_uIdIconImage ( IDI_SMLOGCFG ),
	m_uIdBitmapSmallImage ( IDB_SMLOGCFG_16x16 ),
	m_uIdBitmapSmallImageOpen ( IDB_SMLOGCFG_16x16 ),
	m_uIdBitmapLargeImage ( IDB_SMLOGCFG_32x32 ),
	m_crImageMask ( RGB(255, 0, 255) ),
    refcount(1)    // implicit AddRef
{
    // Initialize Resource IDs.
}

CSmLogAbout::~CSmLogAbout()
{
}


ULONG __stdcall
CSmLogAbout::AddRef()
{
   return InterlockedIncrement(&refcount);
}



ULONG __stdcall
CSmLogAbout::Release()
{
   if (InterlockedDecrement(&refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
CSmLogAbout::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired =
         static_cast<IUnknown*>(static_cast<ISnapinAbout*>(this));
   }
   else if (interfaceID == IID_ISnapinAbout)
   {
      *interfaceDesired = static_cast<ISnapinAbout*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      return hr;
   }

   AddRef();
   return S_OK;
}


HRESULT __stdcall  
CSmLogAbout::GetSnapinDescription (
    OUT LPOLESTR __RPC_FAR *lpDescription ) 
{
    return HrLoadOleString(m_uIdStrDescription, OUT lpDescription);
}

HRESULT __stdcall  
CSmLogAbout::GetProvider ( 
    OUT LPOLESTR __RPC_FAR *lpName ) 
{
    return HrLoadOleString(m_uIdStrProvider, OUT lpName);
}

HRESULT __stdcall  
CSmLogAbout::GetSnapinVersion ( 
    OUT LPOLESTR __RPC_FAR *lpVersion ) 
{
    return TranslateString(VER_PRODUCTVERSION_STR, lpVersion);
}

HRESULT
CSmLogAbout::TranslateString(
    IN  LPSTR lpSrc,
    OUT LPOLESTR __RPC_FAR *lpDst)
{
    int nWChar;

    if ( lpDst == NULL ) {
        return E_POINTER;
    }

    nWChar = MultiByteToWideChar(CP_ACP,
                                 0,
                                 lpSrc,
                                 strlen(lpSrc),
                                 NULL,
                                 0);
    *lpDst = reinterpret_cast<LPOLESTR>
               (CoTaskMemAlloc((nWChar + 1) * sizeof(wchar_t)));

    if (*lpDst == NULL) {
        return E_OUTOFMEMORY;
    }

    MultiByteToWideChar(CP_ACP,
                        0,
                        lpSrc,
                        strlen(lpSrc),
                        *lpDst,
                        nWChar);
    (*lpDst)[nWChar] = L'\0';
    return S_OK;
}

HRESULT __stdcall  
CSmLogAbout::GetSnapinImage (
    OUT HICON __RPC_FAR *hAppIcon )
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // Required for AfxGetInstanceHandle()
    
    *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
    
    if (*hAppIcon == NULL)
        {
        ASSERT(FALSE && "Unable to load icon");
        return E_FAIL;
        }
    return S_OK;
}

HRESULT __stdcall  
CSmLogAbout::GetStaticFolderImage (
    OUT HBITMAP __RPC_FAR *hSmallImage,
    OUT HBITMAP __RPC_FAR *hSmallImageOpen,
    OUT HBITMAP __RPC_FAR *hLargeImage,
    OUT COLORREF __RPC_FAR *crMask )
{   
    ASSERT(hSmallImage != NULL);
    ASSERT(hSmallImageOpen != NULL);
    ASSERT(hLargeImage != NULL);
    ASSERT(crMask != NULL);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // Required for AfxGetInstanceHandle()
    HINSTANCE hInstance = AfxGetInstanceHandle();
    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
    *hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
    *hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));
    *crMask = m_crImageMask;
    #ifdef _DEBUG
    if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
        {
        TRACE0("WRN: CSmLogAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
        return E_FAIL;
        }
    #endif
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//  HrLoadOleString()
//
//  Load a string from the resource and return pointer to allocated
//  OLE string.
//
//  HISTORY
//  16-Nov-98   a-kathse    Creation from framewrk\stdutils.cpp
//
HRESULT
CSmLogAbout::HrLoadOleString(
    UINT uStringId,                 // IN: String Id to load from the resource
    OUT LPOLESTR * ppaszOleString)  // OUT: Pointer to pointer to allocated OLE string
{
    CString strT;       // Temporary string
    USES_CONVERSION;

    if ( ppaszOleString == NULL ) {
        TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
        return E_POINTER;
    }
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // Needed for LoadString()
    VERIFY( strT.LoadString(uStringId) );

    *ppaszOleString = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
    
    if (*ppaszOleString == NULL)
        return E_OUTOFMEMORY;

    wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
    
    return S_OK;
} // HrLoadOleString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\provdlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provdlg.h

Abstract:

    Header file for the add trace provider dialog

--*/

#ifndef _PROVDLG_H_
#define _PROVDLG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smtraceq.h"   // For provider states

// Dialog controls
#define IDD_PROVIDERS_ADD_DLG          1100

#define IDC_PADD_PROVIDER_CAPTION      1011
#define IDC_PADD_FIRST_HELP_CTRL_ID    1012
#define IDC_PADD_PROVIDER_LIST         1012

class CProvidersProperty;

/////////////////////////////////////////////////////////////////////////////
// CProviderListDlg dialog

class CProviderListDlg : public CDialog
{
// Construction
public:
            CProviderListDlg(CWnd* pParent=NULL);
    virtual ~CProviderListDlg();

    void    SetProvidersPage( CProvidersProperty* pPage );
    // Dialog Data
    //{{AFX_DATA(CProvidersProperty)
    enum { IDD = IDD_PROVIDERS_ADD_DLG };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CProvidersProperty)
	public:
	virtual void OnFinalRelease();
    protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CProvidersProperty)
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH

private:

    DWORD               InitProviderListBox ( void );

    CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&> m_arrProviders;

    CProvidersProperty* m_pProvidersPage;
    DWORD               m_dwMaxHorizListExtent;
    
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _PROVDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\schdprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    schdprop.cpp

Abstract:

    Implementation of the schedule property page.

--*/

#include "stdafx.h"
#include <pdh.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include "smcfgmsg.h"
#include "globals.h"
#include "smlogs.h"
#include "schdprop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static ULONG
s_aulHelpIds[] =
{
    IDC_SCHED_START_MANUAL_RDO, IDH_SCHED_START_MANUAL_RDO,
    IDC_SCHED_START_AT_RDO,     IDH_SCHED_START_AT_RDO,
    IDC_SCHED_START_AT_TIME_DT, IDH_SCHED_START_AT_TIME_DT,
    IDC_SCHED_START_AT_DATE_DT, IDH_SCHED_START_AT_DATE_DT,
    IDC_SCHED_STOP_MANUAL_RDO,  IDH_SCHED_STOP_MANUAL_RDO,
    IDC_SCHED_STOP_AT_RDO,      IDH_SCHED_STOP_AT_RDO,
    IDC_SCHED_STOP_AFTER_RDO,   IDH_SCHED_STOP_AFTER_RDO,
    IDC_SCHED_STOP_SIZE_RDO,    IDH_SCHED_STOP_SIZE_RDO,
    IDC_SCHED_STOP_AT_TIME_DT,  IDH_SCHED_STOP_AT_TIME_DT,
    IDC_SCHED_STOP_AT_DATE_DT,  IDH_SCHED_STOP_AT_DATE_DT,
    IDC_SCHED_STOP_AFTER_SPIN,  IDH_SCHED_STOP_AFTER_EDIT,
    IDC_SCHED_STOP_AFTER_EDIT,  IDH_SCHED_STOP_AFTER_EDIT,
    IDC_SCHED_STOP_AFTER_UNITS_COMBO,   IDH_SCHED_STOP_AFTER_UNITS_COMBO,
    IDC_SCHED_RESTART_CHECK,    IDH_SCHED_RESTART_CHECK,
    IDC_SCHED_EXEC_CHECK,       IDH_SCHED_EXEC_CHECK,
    IDC_SCHED_CMD_EDIT,         IDH_SCHED_CMD_EDIT,
    IDC_SCHED_CMD_BROWSE_BTN,   IDH_SCHED_CMD_BROWSE_BTN,
    0,0 
};

/////////////////////////////////////////////////////////////////////////////
// CScheduleProperty property page

IMPLEMENT_DYNCREATE(CScheduleProperty, CSmPropertyPage)

CScheduleProperty::CScheduleProperty(
    MMC_COOKIE lCookie, 
    LONG_PTR hConsole,
    LPDATAOBJECT pDataObject ) 
:   CSmPropertyPage ( CScheduleProperty::IDD, hConsole, pDataObject ),
    m_llManualStartTime ( MAX_TIME_VALUE ),
    m_llManualStopTime ( MIN_TIME_VALUE )
{
    // save pointers from arg list
    m_pLogQuery = reinterpret_cast <CSmLogQuery *>(lCookie);

//  EnableAutomation();
    //{{AFX_DATA_INIT(CScheduleProperty)
    m_dwStopAfterCount = 0;
    m_nStopAfterUnits = -1;
    m_bAutoRestart = FALSE;
    m_strEofCommand = _T("");
    m_bExecEofCommand = FALSE;
    //}}AFX_DATA_INIT
    ZeroMemory (&m_stStartAt, sizeof ( m_stStartAt ) );
    ZeroMemory (&m_stStopAt, sizeof ( m_stStopAt ) );
}

CScheduleProperty::CScheduleProperty() : CSmPropertyPage(CScheduleProperty::IDD)
{
    ASSERT (FALSE); // only the constructor w/ args should be called

    EnableAutomation();
//  //{{AFX_DATA_INIT(CScheduleProperty)
    m_dwStopAfterCount = 0;
    m_nStopAfterUnits = -1;
    m_bAutoRestart = FALSE;
    m_strEofCommand = _T("");
    m_bExecEofCommand = FALSE;
//  //}}AFX_DATA_INIT
}

CScheduleProperty::~CScheduleProperty()
{
}

void 
CScheduleProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

BOOL
CScheduleProperty::IsValidLocalData()
{
    LONGLONG    llStopTime;
    INT         iPrevLength = 0;
    BOOL        bContinue = TRUE;

    ResourceStateManager    rsm;

    // Trim text fields before validation
    iPrevLength = m_strEofCommand.GetLength();
    m_strEofCommand.TrimLeft();
    m_strEofCommand.TrimRight();
    
    if ( iPrevLength != m_strEofCommand.GetLength() ) {
        SetDlgItemText ( IDC_SCHED_CMD_EDIT, m_strEofCommand );  
    }

    
    
    if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode ) {

        SystemTimeToFileTime ( &m_stStopAt, (FILETIME *)&llStopTime );

        if ( SLQ_AUTO_MODE_AT == m_dwCurrentStartMode ) {

            LONGLONG llStartTime;

            SystemTimeToFileTime ( &m_stStartAt, (FILETIME *)&llStartTime );

            if ( llStartTime >= llStopTime ) {
                CString strMessage;

                strMessage.LoadString ( IDS_SCHED_START_PAST_STOP );

                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR );
                GetDlgItem ( IDC_SCHED_STOP_AT_TIME_DT )->SetFocus();
                bContinue = FALSE;
            }
        } else {
            // Start mode is manual.
            // get local time
            SYSTEMTIME  stLocalTime;
            FILETIME    ftLocalTime;
            
            // Milliseconds set to 0 for Schedule times
            GetLocalTime (&stLocalTime);
            stLocalTime.wMilliseconds = 0;
            SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

            if ( *(LONGLONG*)&ftLocalTime >= llStopTime ) {            
                CString strMessage;

                strMessage.LoadString ( IDS_SCHED_NOW_PAST_STOP );                
                
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR );
                GetDlgItem ( IDC_SCHED_STOP_AT_TIME_DT )->SetFocus();                
                bContinue = FALSE;
            }
        }
    } else if ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ) { 

        bContinue = ValidateDWordInterval(IDC_SCHED_STOP_AFTER_EDIT,
                                          m_pLogQuery->GetLogName(),
                                          (long) m_dwStopAfterCount,
                                          1,
                                          100000);
    }

    // Validate command file path if logging to local machine.
    if ( bContinue 
            && m_pLogQuery->GetLogService()->IsLocalMachine()
            && m_bExecEofCommand ) {
        DWORD dwStatus;

        dwStatus = IsCommandFilePathValid ( m_strEofCommand );

        if ( ERROR_SUCCESS != dwStatus ) {
            CString strMessage;

            FormatSmLogCfgMessage ( 
                strMessage,
                m_hModule, 
                dwStatus );
                    
            MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            GetDlgItem ( IDC_SCHED_CMD_EDIT )->SetFocus();                
            bContinue = FALSE;
        }
    }

    return bContinue;
}

void 
CScheduleProperty::StartModeRadioExchange(CDataExchange* pDX)
{
    if ( !pDX->m_bSaveAndValidate ) {
        // Load control value from data

        switch ( m_dwCurrentStartMode ) {
            case SLQ_AUTO_MODE_NONE:
                m_nStartModeRdo = 0;
                break;
            case SLQ_AUTO_MODE_AT:
                m_nStartModeRdo = 1;
                break;
            default:
                ;
                break;
        }
    }

    DDX_Radio(pDX, IDC_SCHED_START_MANUAL_RDO, m_nStartModeRdo);

    if ( pDX->m_bSaveAndValidate ) {

        switch ( m_nStartModeRdo ) {
            case 0:
                m_dwCurrentStartMode = SLQ_AUTO_MODE_NONE;
                break;
            case 1:
                m_dwCurrentStartMode = SLQ_AUTO_MODE_AT;
                break;
            default:
                ;
                break;
        }
    }
}

void 
CScheduleProperty::StartAtExchange(CDataExchange* pDX)
{
    CWnd* pWndTime = NULL;
    CWnd* pWndDate = NULL;

    pWndTime = GetDlgItem(IDC_SCHED_START_AT_TIME_DT);
    pWndDate = GetDlgItem(IDC_SCHED_START_AT_DATE_DT);
    
    if ( pDX->m_bSaveAndValidate ) {
        DWORD dwStatus;
        SYSTEMTIME stTemp;
        
        dwStatus = DateTime_GetSystemtime ( pWndTime->m_hWnd, &stTemp );

        m_stStartAt.wHour = stTemp.wHour;
        m_stStartAt.wMinute = stTemp.wMinute;
        m_stStartAt.wSecond = stTemp.wSecond;
        m_stStartAt.wMilliseconds = 0;

        dwStatus = DateTime_GetSystemtime ( pWndDate->m_hWnd, &stTemp );

        m_stStartAt.wYear = stTemp.wYear;
        m_stStartAt.wMonth = stTemp.wMonth;
        m_stStartAt.wDayOfWeek = stTemp.wDayOfWeek;
        m_stStartAt.wDay = stTemp.wDay;

        if ( SLQ_AUTO_MODE_AT == m_dwCurrentStartMode 
             && IsModifiedPage() ) {
            // Set manual stop time to MAX so that automatic start will occur.
            // Do this only if the user has modified something on the page.
            m_llManualStopTime = MAX_TIME_VALUE;
        }
    } else {
        BOOL bStatus;
        bStatus = DateTime_SetSystemtime ( pWndTime->m_hWnd, GDT_VALID, &m_stStartAt );
        bStatus = DateTime_SetSystemtime ( pWndDate->m_hWnd, GDT_VALID, &m_stStartAt );
    }
}

void 
CScheduleProperty::StopAtExchange(CDataExchange* pDX)
{
    CWnd* pWndTime = NULL;
    CWnd* pWndDate = NULL;

    pWndTime = GetDlgItem(IDC_SCHED_STOP_AT_TIME_DT);
    pWndDate = GetDlgItem(IDC_SCHED_STOP_AT_DATE_DT);
    
    if ( pDX->m_bSaveAndValidate ) {
        DWORD dwStatus;
        SYSTEMTIME stTemp;
        
        dwStatus = DateTime_GetSystemtime ( pWndTime->m_hWnd, &stTemp );

        m_stStopAt.wHour = stTemp.wHour;
        m_stStopAt.wMinute = stTemp.wMinute;
        m_stStopAt.wSecond = stTemp.wSecond;
        m_stStopAt.wMilliseconds = 0;

        dwStatus = DateTime_GetSystemtime ( pWndDate->m_hWnd, &stTemp );

        m_stStopAt.wYear = stTemp.wYear;
        m_stStopAt.wMonth = stTemp.wMonth;
        m_stStopAt.wDayOfWeek = stTemp.wDayOfWeek;
        m_stStopAt.wDay = stTemp.wDay;

    } else {
        BOOL bStatus;
        bStatus = DateTime_SetSystemtime ( pWndTime->m_hWnd, GDT_VALID, &m_stStopAt );
        bStatus = DateTime_SetSystemtime ( pWndDate->m_hWnd, GDT_VALID, &m_stStopAt );
    }
}

void 
CScheduleProperty::StopModeRadioExchange(CDataExchange* pDX)
{
    // Note:  Load is handled in OnInitDialog, OnSetActive.
    // That handling should be moved here.

    if ( !pDX->m_bSaveAndValidate ) {
        // Load control value from data

        switch ( m_SharedData.stiStopTime.dwAutoMode ) {
            case SLQ_AUTO_MODE_NONE:
                m_nStopModeRdo = 0;
                break;
            case SLQ_AUTO_MODE_AFTER:
                m_nStopModeRdo = 1;
                break;
            case SLQ_AUTO_MODE_AT:
                m_nStopModeRdo = 2;
                break;
            case SLQ_AUTO_MODE_SIZE:
                m_nStopModeRdo = 3;
                break;
            default:
                ;
                break;
        }
    }

    DDX_Radio(pDX, IDC_SCHED_STOP_MANUAL_RDO, m_nStopModeRdo);

    if ( pDX->m_bSaveAndValidate ) {

        switch ( m_nStopModeRdo ) {
            case 0:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                break;
            case 1:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                break;
            case 2:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_AT;
                break;
            case 3:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_SIZE;
                break;
            default:
                ;
                break;
        }
    }
}

void 
CScheduleProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CScheduleProperty)
    DDX_Text(pDX, IDC_SCHED_CMD_EDIT, m_strEofCommand);
    DDX_Check(pDX, IDC_SCHED_EXEC_CHECK, m_bExecEofCommand);
    ValidateTextEdit(pDX, IDC_SCHED_STOP_AFTER_EDIT, 6, & m_dwStopAfterCount, 1, 100000);
    DDX_CBIndex(pDX, IDC_SCHED_STOP_AFTER_UNITS_COMBO, m_nStopAfterUnits);
    DDX_Check(pDX, IDC_SCHED_RESTART_CHECK, m_bAutoRestart);
    //}}AFX_DATA_MAP

    StartAtExchange ( pDX );
    StopAtExchange ( pDX );
    StopModeRadioExchange ( pDX );
    StartModeRadioExchange ( pDX );

    if ( pDX->m_bSaveAndValidate ) {
        m_dwStopAfterUnitsValue = 
            (DWORD)((CComboBox *)GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO))->
                    GetItemData(m_nStopAfterUnits);        
    }
}


BEGIN_MESSAGE_MAP(CScheduleProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CScheduleProperty)
    ON_BN_CLICKED(IDC_SCHED_CMD_BROWSE_BTN, OnSchedCmdBrowseBtn)
    ON_BN_CLICKED(IDC_SCHED_RESTART_CHECK, OnSchedRestartCheck)
    ON_BN_CLICKED(IDC_SCHED_EXEC_CHECK, OnSchedExecCheck)
    ON_BN_CLICKED(IDC_SCHED_START_MANUAL_RDO, OnSchedStartRdo)
    ON_BN_CLICKED(IDC_SCHED_START_AT_RDO, OnSchedStartRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_MANUAL_RDO, OnSchedStopRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_AFTER_RDO, OnSchedStopRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_AT_RDO, OnSchedStopRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_SIZE_RDO, OnSchedStopRdo)
    ON_WM_DESTROY()
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_START_AT_TIME_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_START_AT_TIME_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_START_AT_DATE_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_START_AT_DATE_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_STOP_AT_TIME_DT, OnKillfocusSchedStopAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_STOP_AT_TIME_DT, OnKillfocusSchedStopAtDt)
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_STOP_AT_DATE_DT, OnKillfocusSchedStopAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_STOP_AT_DATE_DT, OnKillfocusSchedStopAtDt)
    ON_CBN_SELENDOK(IDC_SCHED_STOP_AFTER_UNITS_COMBO, OnSelendokSchedStopAfterUnitsCombo)
    ON_EN_CHANGE(IDC_SCHED_STOP_AFTER_EDIT, OnKillfocusSchedStopAfterEdit)
    ON_EN_KILLFOCUS(IDC_SCHED_STOP_AFTER_EDIT, OnKillfocusSchedStopAfterEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SCHED_STOP_AFTER_SPIN, OnDeltaposSchedStopAfterSpin)
    ON_EN_CHANGE(IDC_SCHED_CMD_EDIT, OnKillfocusSchedCmdEdit)
    ON_EN_KILLFOCUS(IDC_SCHED_CMD_EDIT, OnKillfocusSchedCmdEdit)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CScheduleProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CScheduleProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IScheduleProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EAD-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_IScheduleProperty =
{ 0x65154ead, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CScheduleProperty, CSmPropertyPage)
    INTERFACE_PART(CScheduleProperty, IID_IScheduleProperty, Dispatch)
END_INTERFACE_MAP()

void 
CScheduleProperty::SetStopDefaultValues ( PSLQ_TIME_INFO pslqStartTime )
{
    SLQ_TIME_INFO slqLocalTime;

    // Default Stop After values.
    m_dwStopAfterCount = 1;
    m_dwStopAfterUnitsValue = SLQ_TT_UTYPE_DAYS;
    
    // Get default time fields for Stop At mode. 
    // Set default stop time for start time + 24 hrs
    slqLocalTime.llDateTime = 86400; // sec/day
    slqLocalTime.llDateTime *= 10000000; // 100ns /sec
    slqLocalTime.llDateTime += pslqStartTime->llDateTime;

    FileTimeToSystemTime( (CONST FILETIME *)&slqLocalTime.llDateTime, &m_stStopAt );
}

void 
CScheduleProperty::SetCmdBtnState ()
{
    if ( SLQ_ALERT != m_pLogQuery->GetLogType() ) {

        if ( !m_bExecEofCommand ) {
            m_strEofCommand.Empty();
        }

        GetDlgItem(IDC_SCHED_CMD_EDIT)->EnableWindow (m_bExecEofCommand);
        GetDlgItem(IDC_SCHED_CMD_BROWSE_BTN)->EnableWindow (m_bExecEofCommand);
    }
}

void CScheduleProperty::SetStopBtnState ()
{
    BOOL    bSizeRdo;
    BOOL    bAtRdo;
    BOOL    bAfterRdo;
    BOOL    bManualRdo;

    bAtRdo = bAfterRdo = bSizeRdo = FALSE;

    bManualRdo = ( SLQ_AUTO_MODE_NONE == m_SharedData.stiStopTime.dwAutoMode );

    if (!bManualRdo) {
        // check which button is checked and
        // enable/disable the appropriate edit/combo box
        bSizeRdo = ( SLQ_AUTO_MODE_SIZE == m_SharedData.stiStopTime.dwAutoMode ); 
        bAfterRdo = ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ); 
        bAtRdo = ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode );
    }

    GetDlgItem(IDC_SCHED_STOP_AFTER_EDIT)->EnableWindow(bAfterRdo);
    GetDlgItem(IDC_SCHED_STOP_AFTER_SPIN)->EnableWindow(bAfterRdo);
    GetDlgItem(IDC_SCHED_STOP_AFTER_STATIC)->EnableWindow(bAfterRdo);
    GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO)->EnableWindow(bAfterRdo);

    GetDlgItem(IDC_SCHED_STOP_AT_TIME_DT)->EnableWindow(bAtRdo);
    GetDlgItem(IDC_SCHED_STOP_AT_ON_CAPTION)->EnableWindow(bAtRdo);
    GetDlgItem(IDC_SCHED_STOP_AT_DATE_DT)->EnableWindow(bAtRdo);

    if ( !(bSizeRdo || bAfterRdo) ) {
        m_bAutoRestart = FALSE;
    }

    GetDlgItem(IDC_SCHED_RESTART_CHECK)->EnableWindow(bSizeRdo || bAfterRdo);
    
    if ( SLQ_ALERT != m_pLogQuery->GetLogType() ) {
//        GetDlgItem(IDC_SCHED_EXEC_CHECK)->EnableWindow( TRUE );
        SetCmdBtnState();
    }

    // UpdateData updates Eof command and Restart UI.
    UpdateData ( FALSE ); 
}

void CScheduleProperty::SetStartBtnState ()
{
    BOOL    bManualRdo;
    BOOL    bAutoFields;

    bManualRdo = ( SLQ_AUTO_MODE_NONE == m_dwCurrentStartMode );

    bAutoFields = !bManualRdo;
    GetDlgItem(IDC_SCHED_START_AT_TIME_DT)->EnableWindow(bAutoFields);
    GetDlgItem(IDC_SCHED_START_AT_ON_CAPTION)->EnableWindow(bAutoFields);
    GetDlgItem(IDC_SCHED_START_AT_DATE_DT)->EnableWindow(bAutoFields);
}

void
CScheduleProperty::FillStartTimeStruct ( PSLQ_TIME_INFO pslqStartTime )
{
    memset (pslqStartTime, 0, sizeof(SLQ_TIME_INFO));
    pslqStartTime->wTimeType = SLQ_TT_TTYPE_START;
    pslqStartTime->wDataType = SLQ_TT_DTYPE_DATETIME;
    pslqStartTime->dwAutoMode = m_dwCurrentStartMode;

    // Start mode and time 

    if ( SLQ_AUTO_MODE_NONE == m_dwCurrentStartMode ) {
        // Manual start mode
        pslqStartTime->llDateTime = m_llManualStartTime;
    } else {
        SystemTimeToFileTime ( &m_stStartAt, (FILETIME *)&pslqStartTime->llDateTime );
    }
}

void
CScheduleProperty::UpdateSharedStopTimeStruct ( void )
{   
    PSLQ_TIME_INFO pTime;

    // Save changes that this page might have made to the shared stop time structure.

    pTime = &m_SharedData.stiStopTime;

    ASSERT ( SLQ_TT_TTYPE_STOP == pTime->wTimeType ) ;

    // Stop mode and time

    if ( SLQ_AUTO_MODE_NONE == pTime->dwAutoMode ) {
        // The only change that the file page ever makes is to change the stop
        // mode from Size to Manual (SLQ_AUTO_MODE_NONE).  In this case, set 
        // the stop time to a value consistent with the start mode.
        pTime->dwAutoMode = SLQ_AUTO_MODE_NONE; 
        pTime->wDataType = SLQ_TT_DTYPE_DATETIME;
        pTime->llDateTime = m_llManualStopTime;
    } else if ( SLQ_AUTO_MODE_AFTER == pTime->dwAutoMode ) {
        pTime->wDataType = SLQ_TT_DTYPE_UNITS;
        pTime->dwValue = m_dwStopAfterCount;
        pTime->dwUnitType = m_dwStopAfterUnitsValue;
    } else if ( SLQ_AUTO_MODE_AT == pTime->dwAutoMode ) {
        pTime->wDataType = SLQ_TT_DTYPE_DATETIME;

        SystemTimeToFileTime ( &m_stStopAt, (FILETIME *)&pTime->llDateTime );

    } // else SLQ_AUTO_MODE_SIZE, all other slqTime fields are ignored, so no change.
}

BOOL 
CScheduleProperty::SaveDataToModel ( )
{
    SLQ_TIME_INFO   slqTime;
    BOOL bContinue = TRUE;

    ResourceStateManager    rsm;
    
    // Validate StopAt time before saving 

    if ( bContinue ) { 
        bContinue = SampleTimeIsLessThanSessionTime ( m_pLogQuery );
        if ( !bContinue ) {
            if ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ) {
                GetDlgItem ( IDC_SCHED_STOP_AFTER_EDIT )->SetFocus();    
            } else if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode ) {
                GetDlgItem ( IDC_SCHED_STOP_AT_TIME_DT )->SetFocus();    
            }
        }
    }

    if ( bContinue ) {

        FillStartTimeStruct ( &slqTime );

        bContinue = m_pLogQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);
        ASSERT (bContinue);

        UpdateSharedStopTimeStruct();

        bContinue = m_pLogQuery->SetLogTime (&m_SharedData.stiStopTime, (DWORD)m_SharedData.stiStopTime.wTimeType);
        ASSERT (bContinue);

        // Restart mode 
        // Currently only support After 0 minutes.
        memset (&slqTime, 0, sizeof(slqTime));
        slqTime.wTimeType = SLQ_TT_TTYPE_RESTART;
        slqTime.dwAutoMode = (m_bAutoRestart ? SLQ_AUTO_MODE_AFTER : SLQ_AUTO_MODE_NONE );
        slqTime.wDataType = SLQ_TT_DTYPE_UNITS;
        slqTime.dwUnitType = SLQ_TT_UTYPE_MINUTES;
        slqTime.dwValue = 0;

        bContinue = m_pLogQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);
        ASSERT (bContinue);

        // For Counter and trace log queries, set command file from page
        if ( SLQ_COUNTER_LOG == m_pLogQuery->GetLogType()
             || SLQ_TRACE_LOG == m_pLogQuery->GetLogType() ) {
            if (m_bExecEofCommand) {
                // then send filename
                bContinue = ( ERROR_SUCCESS == m_pLogQuery->SetEofCommand ( m_strEofCommand ) );
            } else {
                // Empty string
                bContinue = ( ERROR_SUCCESS == m_pLogQuery->SetEofCommand ( m_pLogQuery->cstrEmpty ) );
            }
            ASSERT (bContinue);
        } 

        // Save property page shared data.
        m_pLogQuery->UpdatePropPageSharedData();

        // Sync the service with changes.
        // Must sync changes made by service to properties not modified by this page.
 
        bContinue = UpdateService ( m_pLogQuery, TRUE );
        
        if ( bContinue ) {
            SetModifiedPage ( FALSE );
        }
    }

    return bContinue;

}

/////////////////////////////////////////////////////////////////////////////
// CScheduleProperty message handlers


void CScheduleProperty::OnSchedCmdBrowseBtn() 
{
    CString strCmdPath;
    
    UpdateData (TRUE);  // to get the current filename
    
    strCmdPath = m_strEofCommand;

    if ( IDOK == BrowseCommandFilename ( this, strCmdPath )) {
        // Update the fields with the new information
        if ( strCmdPath != m_strEofCommand ) {
            m_strEofCommand = strCmdPath;
            SetModifiedPage ( TRUE );
            UpdateData ( FALSE );
        }
    } // else ignore if they canceled out
}

void CScheduleProperty::OnSchedExecCheck() 
{
    UpdateData(TRUE);
    SetCmdBtnState();
    UpdateData ( FALSE );
    SetModifiedPage(TRUE);
}

void CScheduleProperty::OnSchedRestartCheck() 
{
    UpdateData(TRUE);
    SetModifiedPage(TRUE);
}

void CScheduleProperty::OnSchedStartRdo() 
{
    BOOL bNewStateIsManualStart;

    bNewStateIsManualStart = ( 1 == ((CButton *)(GetDlgItem(IDC_SCHED_START_MANUAL_RDO)))->GetCheck() );

    if ( bNewStateIsManualStart && ( SLQ_AUTO_MODE_AT == m_dwCurrentStartMode ) ) {

        // Switching to Manual start.  Set start time to MAX so that original state 
        // will be stopped.
        m_llManualStartTime = MAX_TIME_VALUE;

        // Set stop time to MIN so that original state will be stopped.
        // This variable is only used/saved if the stop time is set to manual.
        // Always set it here, in case the stop mode is changed on the file property
        // page.
        m_llManualStopTime = MIN_TIME_VALUE;

    } else if ( !bNewStateIsManualStart && ( SLQ_AUTO_MODE_NONE == m_dwCurrentStartMode ) ) {
        // Switching to Start At mode.
        // Set manual stop time to MAX so that automatic start will occur.
        m_llManualStopTime = MAX_TIME_VALUE;
    }

    UpdateData( TRUE );
    SetStartBtnState();
    SetStopBtnState();
    SetModifiedPage( TRUE );
}

void 
CScheduleProperty::OnSchedStopRdo() 
{
    UpdateData(TRUE);
    SetStopBtnState();  
    SetModifiedPage(TRUE);
}

void 
CScheduleProperty::OnCancel() 
{
    m_pLogQuery->SyncPropPageSharedData(); // Clear the memory shared between property pages.
}

BOOL 
CScheduleProperty::OnApply() 
{
    BOOL    bContinue;

    bContinue = UpdateData (TRUE); // get data from page

    if ( bContinue ) {
        bContinue = IsValidData( m_pLogQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SaveDataToModel();
    }

    if ( bContinue ) {
        bContinue = Apply( m_pLogQuery ); 
    }

    if ( bContinue ){
        bContinue = CPropertyPage::OnApply();
    }

    return bContinue;
}

BOOL 
CScheduleProperty::OnInitDialog() 
{
    SLQ_TIME_INFO   slqTime;
    CComboBox *     pCombo;
    int             nIndex;
    CString         strComboBoxString;
    int             nResult;
    SYSTEMTIME      stLocalTime;
    FILETIME        ftLocalTime;

    ResourceStateManager    rsm;
    
    // get local time
    // Milliseconds set to 0 for Schedule times
    GetLocalTime (&stLocalTime);
    stLocalTime.wMilliseconds = 0;
    SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

    // get log start state
    m_pLogQuery->GetLogTime (&slqTime, SLQ_TT_TTYPE_START);
    m_dwCurrentStartMode = slqTime.dwAutoMode;

    if (slqTime.dwAutoMode == SLQ_AUTO_MODE_NONE) {
        m_llManualStartTime = slqTime.llDateTime;
        // get default value for start At time to load local member variables
        slqTime.llDateTime = *(LONGLONG *)(&ftLocalTime);
    } 

    // get time fields for Start At controls
    // *** Check status
    FileTimeToSystemTime( (CONST FILETIME *)&slqTime.llDateTime, &m_stStartAt );

    // Stop default values are based on Start At time.
    SetStopDefaultValues( &slqTime );

    // Override default values for the selected stop mode.
    
    m_pLogQuery->GetLogTime (&slqTime, SLQ_TT_TTYPE_STOP);
    m_SharedData.stiStopTime.dwAutoMode = slqTime.dwAutoMode;

    switch (slqTime.dwAutoMode) {

        case SLQ_AUTO_MODE_AFTER:
            // set edit control & dialog box values
            m_dwStopAfterCount = slqTime.dwValue;
            m_dwStopAfterUnitsValue = slqTime.dwUnitType;

            break;

        case SLQ_AUTO_MODE_AT:

            FileTimeToSystemTime( (CONST FILETIME *)&slqTime.llDateTime, &m_stStopAt );
            
            break;

        default:
        case SLQ_AUTO_MODE_NONE:
            // this is the default case if none is specified
            m_llManualStopTime = slqTime.llDateTime;
            break;
    }

    // Init the Stop After time units combo, and select based on
    // either default values or stop after override.
    pCombo = (CComboBox *)GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO);
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < (int)dwTimeUnitComboEntries; nIndex++) {
        strComboBoxString.LoadString ( TimeUnitCombo[nIndex].nResId );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set selected in combo box here
        if (m_dwStopAfterUnitsValue == (DWORD)(TimeUnitCombo[nIndex].nData)) {
            m_nStopAfterUnits = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
        }
    }

    // Get restart mode
    m_pLogQuery->GetLogTime (&slqTime, SLQ_TT_TTYPE_RESTART);

    ASSERT (slqTime.wDataType == SLQ_TT_DTYPE_UNITS);
    ASSERT (slqTime.wTimeType == SLQ_TT_TTYPE_RESTART);

    m_bAutoRestart = ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode ? FALSE : TRUE );
    
    // Get EOF command, if not Alert query.

    if ( SLQ_ALERT != m_pLogQuery->GetLogType() ) {
        CString strLogText;
        
        m_pLogQuery->GetEofCommand ( m_strEofCommand );

        m_bExecEofCommand = !m_strEofCommand.IsEmpty();


        // Static text
        strLogText.LoadString ( IDS_SCHED_START_LOG_GROUP );
        SetDlgItemText( IDC_SCHED_START_GROUP, strLogText );
        strLogText.LoadString ( IDS_SCHED_STOP_LOG_GROUP );
        SetDlgItemText( IDC_SCHED_STOP_GROUP, strLogText );
        strLogText.LoadString ( IDS_SCHED_RESTART_LOG );
        SetDlgItemText( IDC_SCHED_RESTART_CHECK, strLogText );
        strLogText.LoadString ( IDS_SCHED_STOP_LOG_WHEN );
        SetDlgItemText( IDC_SCHED_STOP_WHEN_STATIC, strLogText );
    } else {
        // Hide the EOF command UI if Alert query.
        GetDlgItem(IDC_SCHED_EXEC_CHECK)->ShowWindow(FALSE);
        GetDlgItem(IDC_SCHED_CMD_EDIT)->ShowWindow(FALSE);
        GetDlgItem(IDC_SCHED_CMD_BROWSE_BTN)->ShowWindow(FALSE);
        m_strEofCommand.Empty();
        m_bExecEofCommand = FALSE;
    }

    // Modify or hide other Dialog elements based on query type.
    if ( SLQ_ALERT == m_pLogQuery->GetLogType() ) {
        GetDlgItem(IDC_SCHED_STOP_SIZE_RDO)->ShowWindow(FALSE);
    }

    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    SetStartBtnState ();
    SetStopBtnState();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CScheduleProperty::OnKillfocusSchedCmdEdit() 
{   
    CString strOldText;
    strOldText = m_strEofCommand;
    UpdateData ( TRUE );
    if( !m_pLogQuery->m_strUser.IsEmpty() ){
        if( !( m_pLogQuery->m_strUser.GetAt(0) == _T('<') ) ){
            m_pLogQuery->m_fDirtyPassword |= PASSWORD_DIRTY;
        }
    }

    if ( 0 != strOldText.Compare ( m_strEofCommand ) ) {
        SetModifiedPage(TRUE);
    }
}

void CScheduleProperty::OnKillfocusSchedStopAfterEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_dwStopAfterCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwStopAfterCount) {
        SetModifiedPage(TRUE);
    }
}

void
CScheduleProperty::OnKillfocusSchedStartAtDt(NMHDR* /* pNMHDR */, LRESULT* /*pResult */) 
{
    SYSTEMTIME stOldTime;
    stOldTime = m_stStartAt;
    UpdateData ( TRUE );
    if ( stOldTime.wHour != m_stStartAt.wHour 
            || stOldTime.wDay != m_stStartAt.wDay 
            || stOldTime.wMinute != m_stStartAt.wMinute 
            || stOldTime.wSecond != m_stStartAt.wSecond 
            || stOldTime.wMonth != m_stStartAt.wMonth 
            || stOldTime.wYear != m_stStartAt.wYear ) {
        SetModifiedPage(TRUE);
    }
}

void 
CScheduleProperty::OnKillfocusSchedStopAtDt(NMHDR* /* pNMHDR */, LRESULT* /*pResult */) 
{
    SYSTEMTIME stOldTime;
    stOldTime = m_stStopAt;
    UpdateData ( TRUE );
    if ( stOldTime.wHour != m_stStopAt.wHour 
            || stOldTime.wDay != m_stStopAt.wDay 
            || stOldTime.wMinute != m_stStopAt.wMinute 
            || stOldTime.wSecond != m_stStopAt.wSecond 
            || stOldTime.wMonth != m_stStopAt.wMonth 
            || stOldTime.wYear != m_stStopAt.wYear ) {
        SetModifiedPage(TRUE);
    }
}


void CScheduleProperty::OnDeltaposSchedStopAfterSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwStopAfterCount, 1, 100000);
}

void 
CScheduleProperty::OnSelendokSchedStopAfterUnitsCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO))->GetCurSel();
    
    if ((nSel != LB_ERR) && (nSel != m_nStopAfterUnits)) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

BOOL 
CScheduleProperty::OnSetActive() 
{
    CString     strTemp;
    BOOL        bEnableSizeRdo;
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if ( bReturn ) {
        ResourceStateManager    rsm;
        m_pLogQuery->GetPropPageSharedData ( &m_SharedData );

        UpdateData ( FALSE );

        // Set size radio button string and state
        strTemp.Empty();
        if ( SLQ_DISK_MAX_SIZE == m_SharedData.dwMaxFileSize ) {
            strTemp.Format ( IDS_SCHED_FILE_MAX_SIZE_DISPLAY );
        } else {
            strTemp.Format ( IDS_SCHED_FILE_SIZE_DISPLAY, m_SharedData.dwMaxFileSize );
        }
        SetDlgItemText( IDC_SCHED_STOP_SIZE_RDO, strTemp );

        bEnableSizeRdo = ( SLF_BIN_CIRC_FILE != m_SharedData.dwLogFileType )
                      && ( SLF_CIRC_TRACE_FILE != m_SharedData.dwLogFileType )
                      && ( SLQ_DISK_MAX_SIZE != m_SharedData.dwMaxFileSize );
        
        GetDlgItem(IDC_SCHED_STOP_SIZE_RDO)->EnableWindow(bEnableSizeRdo);

        SetStartBtnState();
        SetStopBtnState();
    }

    return bReturn;
}

BOOL CScheduleProperty::OnKillActive() 
{
    BOOL bContinue;

    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        bContinue = IsValidData(m_pLogQuery, VALIDATE_FOCUS );
    }

    if ( bContinue ) {
        FillStartTimeStruct ( &m_SharedData.stiStartTime );

        UpdateSharedStopTimeStruct();

        m_pLogQuery->SetPropPageSharedData ( &m_SharedData );
    }

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

void 
CScheduleProperty::PostNcDestroy() 
{
//  delete this;      
    
    CPropertyPage::PostNcDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smabout.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smabout.h

Abstract:

    Implementation of the ISnapinAbout interface.

--*/

#ifndef __SMABOUT_H_INCLUDED__
#define __SMABOUT_H_INCLUDED__

#include "smlogcfg.h"

class ATL_NO_VTABLE CSmLogAbout :
//	public CComObjectRoot,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSmLogAbout, &CLSID_PerformanceAbout>,
	public ISnapinAbout
{
BEGIN_COM_MAP(CSmLogAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
        	CSmLogAbout();
    virtual ~CSmLogAbout();

DECLARE_REGISTRY_RESOURCEID(IDR_PERFORMANCEABOUT)
DECLARE_NOT_AGGREGATABLE(CSmLogAbout)

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

// ISnapinAbout
/*
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);

*/  
	virtual HRESULT __stdcall GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription);
	virtual HRESULT __stdcall GetProvider(OUT LPOLESTR __RPC_FAR *lpName);
	virtual HRESULT __stdcall GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion);
	virtual HRESULT __stdcall GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon);
	virtual HRESULT __stdcall GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);

private:
	// The following data members MUST be initialized by the constructor
	// of the derived class.
	UINT m_uIdStrDescription;		// Resource Id of the description
	UINT m_uIdStrProvider;		    // Resource Id of the provider (ie, Microsoft Corporation)
	UINT m_uIdStrVersion;			// Resource Id of the version of the snapin
	UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
	UINT m_uIdBitmapSmallImage;
	UINT m_uIdBitmapSmallImageOpen;
	UINT m_uIdBitmapLargeImage;
	COLORREF m_crImageMask;

   long           refcount;

private:
    HRESULT HrLoadOleString(UINT uStringId, OUT LPOLESTR * ppaszOleString);
    HRESULT TranslateString( IN  LPSTR lpSrc, OUT LPOLESTR __RPC_FAR *lpDst);

}; // CSmLogAbout()

#endif // __SMABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smalrtsv.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtsv.h

Abstract:

	This object is used to represent the alert query components of the
	sysmon log service

--*/

#ifndef _CLASS_SMALERTSERVICE_
#define _CLASS_SMALERTSERVICE_

#include "smlogs.h"

class CSmAlertService : public CSmLogService
{
    // constructor/destructor
    public:

                CSmAlertService();
        virtual ~CSmAlertService();

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry();

        virtual PSLQUERY    CreateQuery ( const CString& rstrName );
        virtual DWORD       DeleteQuery ( PSLQUERY plQuery );

        virtual CSmAlertService* CastToAlertService( void ) { return this; };

    protected:

        virtual DWORD       LoadQueries( void );
};

#endif //_CLASS_SMALERTSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smalrtsv.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtsv.cpp

Abstract:

	This object is used to represent the alert query components of the
	sysmon log service


--*/

#include "Stdafx.h"
#include "smalrtsv.h"

//
//  Constructor
CSmAlertService::CSmAlertService()
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    strTemp.LoadString ( IDS_SERVICE_NAME_ALERT );
    SetBaseName ( strTemp ); 
    strTemp.LoadString ( IDS_ALERT_NODE_DESCRIPTION );
    SetDescription( strTemp ); 
}

//
//  Destructor
CSmAlertService::~CSmAlertService()
{
    // Make sure Close method was called first!
    ASSERT ( NULL == m_QueryList.GetHeadPosition() );
    return;
}

PSLQUERY    
CSmAlertService::CreateQuery ( const CString& rstrName )
{
    return ( CSmLogService::CreateTypedQuery( rstrName, SLQ_ALERT ) );
}

DWORD   
CSmAlertService::DeleteQuery (PSLQUERY  pQuery)
{
    ASSERT ( SLQ_ALERT == pQuery->GetLogType () );
    return ( CSmLogService::DeleteQuery( pQuery ) );
}

DWORD   
CSmAlertService::LoadQueries ( void )
{
    return ( CSmLogService::LoadQueries( SLQ_ALERT ) );
}

//  
//  Open function. Opens all existing alert entries.
//
DWORD   
CSmAlertService::Open ( const CString& rstrMachineName )
{
    return ( CSmLogService::Open ( rstrMachineName ) );
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmAlertService::Close ()
{
    return ( CSmLogService::Close() );
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match.
//
//  
DWORD   
CSmAlertService::SyncWithRegistry()
{
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = CSmLogService::SyncWithRegistry();

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smalrtq.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtq.cpp

Abstract:

    Implementation of the alert query class

--*/

#include "Stdafx.h"
#include <pdhp.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhmsg.h>
#include "smlogs.h"
#include "common.h"
#include "smalrtq.h"

USE_HANDLE_MACROS("SMLOGCFG(smalrtq.cpp)");

#define  ALRT_DEFAULT_COMMAND_FILE          L""
#define  ALRT_DEFAULT_NETWORK_NAME          L""
#define  ALRT_DEFAULT_USER_TEXT             L""
#define  ALRT_DEFAULT_PERF_LOG_NAME         L""

//
//  Constructor
CSmAlertQuery::CSmAlertQuery( CSmLogService* pLogService )
:   CSmLogQuery( pLogService ),
    m_dwCounterListLength ( 0 ),
    m_szNextCounter ( NULL ),
    mr_szCounterList ( NULL ),
    mr_dwActionFlags ( ALRT_DEFAULT_ACTION )
{
    memset (&mr_stiSampleInterval, 0, sizeof(mr_stiSampleInterval));
    return;
}

//
//  Destructor
CSmAlertQuery::~CSmAlertQuery()
{
    return;
}

//
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD
CSmAlertQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT ( SLQ_ALERT == GetLogType() );
    dwStatus = CSmLogQuery::Open ( rstrName, hKeyQuery, bReadOnly );

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//
DWORD
CSmAlertQuery::Close ()
{
    DWORD dwStatus;
    LOCALTRACE (L"Closing Query\n");

    if (mr_szCounterList != NULL) {
        delete (mr_szCounterList);
        mr_szCounterList = NULL;
    }

    mr_strNetName.Empty();
	mr_strCmdFileName.Empty();
	mr_strCmdUserText.Empty();
	mr_strCmdUserTextIndirect.Empty();
	mr_strPerfLogName.Empty();

    dwStatus = CSmLogQuery::Close();

    return dwStatus;
}

//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD
CSmAlertQuery::UpdateRegistry() 
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize = 0;
    LPTSTR  szNewCounterList = NULL;


    if ( IsModifiable() ) {

        dwBufferSize = 0;
        //
        // Translate the counter list into English
        //
        dwStatus = TranslateMSZAlertCounterList(mr_szCounterList,
                            NULL,
                            &dwBufferSize,
                            FALSE);
        if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {
            szNewCounterList = (LPTSTR) new char [dwBufferSize];
            if (szNewCounterList != NULL) {
                dwStatus = TranslateMSZAlertCounterList(mr_szCounterList,
                                szNewCounterList,
                                &dwBufferSize,
                                FALSE);
            }
        }

        if (dwStatus == ERROR_SUCCESS && szNewCounterList != NULL) {

            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                szNewCounterList,
                                &dwBufferSize);
        }
        else {
            dwBufferSize = m_dwCounterListLength * sizeof(TCHAR); 
            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                mr_szCounterList,
                                &dwBufferSize);
        }

        // Schedule

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistrySlqTime (
                            m_hKeyQuery,
                            IDS_REG_SAMPLE_INTERVAL,
                            &mr_stiSampleInterval);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strCmdFileName.IsEmpty() ) {
                dwBufferSize = mr_strCmdFileName.GetLength() + 1;
                dwBufferSize *= sizeof(TCHAR);
            } else {
                dwBufferSize = 0;
            }

            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_COMMAND_FILE,
                REG_SZ,
                mr_strCmdFileName,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strNetName.IsEmpty() ) {
                dwBufferSize = mr_strNetName.GetLength() + 1;
                dwBufferSize *= sizeof(TCHAR);
            } else {
                dwBufferSize = 0;
            }
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_NETWORK_NAME,
                REG_SZ,
                mr_strNetName,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strCmdUserText.IsEmpty() ) {
                dwBufferSize = mr_strCmdUserText.GetLength() + 1;
                dwBufferSize *= sizeof(TCHAR);
            } else {
                dwBufferSize = 0;
            }
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_USER_TEXT,
                REG_SZ,
                mr_strCmdUserText,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus && !mr_strCmdUserTextIndirect.IsEmpty() ) {
            dwBufferSize = mr_strCmdUserTextIndirect.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_USER_TEXT,
                REG_SZ,
                mr_strCmdUserTextIndirect,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strPerfLogName.IsEmpty() ) {
                dwBufferSize = mr_strPerfLogName.GetLength() + 1;
                dwBufferSize *= sizeof(TCHAR);
            } else {
                dwBufferSize = 0;
            }
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_PERF_LOG_NAME,
                REG_SZ,
                mr_strPerfLogName,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
           dwStatus  = WriteRegistryDwordValue(
                m_hKeyQuery,
                IDS_REG_ACTION_FLAGS,
                &mr_dwActionFlags,
                REG_DWORD);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = CSmLogQuery::UpdateRegistry ();
        }

    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and reloads the internal values to match
//
DWORD
CSmAlertQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiDefault;
    LPTSTR  pszTemp = NULL;
    LPWSTR  szIndTemp = NULL;
    UINT    uiBufferLen = 0;
    CString strValueName;
    LPTSTR  szNewCounterList = NULL;

    ASSERT (m_hKeyQuery != NULL);

    // load counter string list

    // Get Counter List
    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_COUNTER_LIST,
        NULL,
        &mr_szCounterList,
        &dwBufferSize);
    if (dwStatus != ERROR_SUCCESS) {
        m_szNextCounter = NULL; //re-initialize
        m_dwCounterListLength = 0;
    } else {
        // convert  buffersize to chars from bytes
        m_dwCounterListLength = dwBufferSize / sizeof(TCHAR);

        //
        // Translate the counter list into Locale
        //
        dwBufferSize = 0;
        dwStatus = TranslateMSZAlertCounterList(
                                mr_szCounterList,
                                NULL,
                                &dwBufferSize,
                                TRUE);

        if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {

            szNewCounterList = (LPTSTR) new char [dwBufferSize];

            if (szNewCounterList != NULL) {
                //
                // Translate the counter list into Locale
                //
                dwStatus = TranslateMSZAlertCounterList(
                                mr_szCounterList,
                                szNewCounterList,
                                &dwBufferSize,
                                TRUE);

                if (dwStatus == ERROR_SUCCESS) {
                    m_dwCounterListLength = dwBufferSize / sizeof(TCHAR);
                    //
                    // Remove the old
                    //
                    delete (mr_szCounterList);
                    m_szNextCounter = NULL;
                    mr_szCounterList = szNewCounterList;
                }
            }
        }
    }

    // Schedule

    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.dwValue = 5;                         // default interval;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;

    dwStatus = ReadRegistrySlqTime (
        m_hKeyQuery,
        IDS_REG_SAMPLE_INTERVAL,
        &stiDefault,
        &mr_stiSampleInterval);
    ASSERT (dwStatus == ERROR_SUCCESS);

    dwBufferSize = 0;
    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_COMMAND_FILE,
        ALRT_DEFAULT_COMMAND_FILE,
        &pszTemp,
        &dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);
    mr_strCmdFileName.Empty();
    if ( dwBufferSize > sizeof(TCHAR) ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strCmdFileName = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;
    dwBufferSize = 0;

    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_NETWORK_NAME,
        ALRT_DEFAULT_NETWORK_NAME,
        &pszTemp,
        &dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);
    mr_strNetName.Empty();
    if ( dwBufferSize > sizeof(TCHAR) ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strNetName = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;
    dwBufferSize = 0;

    // User text field can be indirect
    MFC_TRY
        strValueName.LoadString ( IDS_REG_USER_TEXT );
    MFC_CATCH_DWSTATUS;

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = SmReadRegistryIndirectStringValue (
            m_hKeyQuery,
            strValueName,
            ALRT_DEFAULT_USER_TEXT,
            &szIndTemp,
            &uiBufferLen );
    }
    mr_strCmdUserText.Empty();

    if ( NULL != szIndTemp ) {
        if ( _T('\0') != *szIndTemp ) {
            mr_strCmdUserText = szIndTemp;
        }
    }
    if ( NULL != szIndTemp ) {
        G_FREE ( szIndTemp );
        szIndTemp = NULL;
    }
    uiBufferLen = 0;

    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_PERF_LOG_NAME,
        ALRT_DEFAULT_PERF_LOG_NAME,
        &pszTemp,
        &dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);
    mr_strPerfLogName.Empty();
    if ( dwBufferSize > sizeof(TCHAR) ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strPerfLogName = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;
    dwBufferSize = 0;

    dwStatus = ReadRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_ACTION_FLAGS,
                ALRT_DEFAULT_ACTION,
                &mr_dwActionFlags);
    ASSERT ( ERROR_SUCCESS == dwStatus );

    // Call parent class last to update shared values.

    dwStatus = CSmLogQuery::SyncWithRegistry();
    ASSERT (dwStatus == ERROR_SUCCESS);

    return dwStatus;
}

BOOL
CSmAlertQuery::GetLogTime ( PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags )
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::GetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmAlertQuery::SetLogTime ( PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags )
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::SetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmAlertQuery::GetDefaultLogTime(SLQ_TIME_INFO&  rTimeInfo,  DWORD dwFlags )
{
    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags ) );

    rTimeInfo.wTimeType = (WORD)dwFlags;
    rTimeInfo.wDataType = SLQ_TT_DTYPE_DATETIME;

    if ( SLQ_TT_TTYPE_START == dwFlags ) {
        SYSTEMTIME  stLocalTime;
        FILETIME    ftLocalTime;

        // Milliseconds set to 0 for Schedule times
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_AT;
        rTimeInfo.llDateTime = *(LONGLONG *)&ftLocalTime;
    } else {
        // Default stop values
        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_NONE;
        rTimeInfo.llDateTime = MAX_TIME_VALUE;
    }

    return TRUE;
}

BOOL
CSmAlertQuery::GetActionInfo( PALERT_ACTION_INFO pInfo, LPDWORD pdwInfoBufSize)
{
    DWORD   dwSizeRequired = sizeof (ALERT_ACTION_INFO);
    BOOL    bReturn = FALSE;
    LPWSTR  szNextString;
    // compute required size

    if (pdwInfoBufSize == NULL) {
        return FALSE;
    }

    if ( !mr_strNetName.IsEmpty() ) {
        dwSizeRequired += ( mr_strNetName.GetLength() + 1 ) * sizeof(TCHAR);
    }

    if ( !mr_strCmdFileName.IsEmpty() ) {
        dwSizeRequired += ( mr_strCmdFileName.GetLength() + 1 ) * sizeof(TCHAR);
    }
    if ( !mr_strCmdUserText.IsEmpty() ) {
        dwSizeRequired += ( mr_strCmdUserText.GetLength() + 1 ) * sizeof(TCHAR);
    }
    if ( !mr_strPerfLogName.IsEmpty() ) {
        dwSizeRequired += ( mr_strPerfLogName.GetLength() + 1 ) * sizeof(TCHAR);
    }

    if (dwSizeRequired <= *pdwInfoBufSize) {
        // clear the caller's buffer before we start filling it
        if (pInfo != NULL) {
            memset (pInfo, 0, *pdwInfoBufSize);
            pInfo->dwSize = dwSizeRequired;
            pInfo->dwActionFlags = mr_dwActionFlags;
            szNextString = (LPWSTR)&pInfo[1];
            if ( !mr_strNetName.IsEmpty() ) {
                pInfo->szNetName = szNextString;
                lstrcpyW(szNextString, mr_strNetName);
                szNextString += lstrlen(szNextString) + 1;
            }
            if ( !mr_strCmdFileName.IsEmpty() ) {
                pInfo->szCmdFilePath = szNextString;
                lstrcpyW(szNextString, mr_strCmdFileName);
                szNextString += lstrlen(szNextString) + 1;
            }
            if ( !mr_strCmdUserText.IsEmpty() ) {
                pInfo->szUserText = szNextString;
                lstrcpyW(szNextString, mr_strCmdUserText);
                szNextString += lstrlen(szNextString) + 1;
            }
            if ( !mr_strPerfLogName.IsEmpty() ) {
                pInfo->szLogName = szNextString;
                lstrcpyW(szNextString, mr_strPerfLogName);
                szNextString += lstrlen(szNextString) + 1;
            }
            bReturn = TRUE;
        }
    } 

    *pdwInfoBufSize = dwSizeRequired;

    return bReturn;
}

DWORD
CSmAlertQuery::SetActionInfo( PALERT_ACTION_INFO pInfo )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if (pInfo != NULL) {
        // Update action values with those from the structure
        MFC_TRY
            mr_dwActionFlags = pInfo->dwActionFlags;

            mr_strNetName.Empty();
            if ( NULL != pInfo->szNetName ) {
                mr_strNetName = pInfo->szNetName;
            }

            mr_strCmdFileName.Empty();
            if ( NULL != pInfo->szCmdFilePath ) {
                mr_strCmdFileName = pInfo->szCmdFilePath;
            }

            mr_strCmdUserText.Empty();
            if ( NULL != pInfo->szUserText ) {
                mr_strCmdUserText = pInfo->szUserText;
            }

            mr_strPerfLogName.Empty();
            if ( NULL != pInfo->szLogName ) {
                mr_strPerfLogName = pInfo->szLogName;
            }
        MFC_CATCH_DWSTATUS
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    // Todo:  Handle return status
    return dwStatus;
}


//
//  Get first counter in counter list
//
LPCWSTR
CSmAlertQuery::GetFirstCounter()
{
    LPWSTR  szReturn;
    szReturn = mr_szCounterList;
    if (szReturn != NULL) {
        if (*szReturn == 0) {
            // then it's an empty string
            szReturn = NULL;
            m_szNextCounter = NULL;
        } else {
            m_szNextCounter = szReturn + lstrlen(szReturn) + 1;
            if (*m_szNextCounter == 0) {
                // end of list reached so set pointer to NULL
                m_szNextCounter = NULL;
            }
        }
    } else {
        // no buffer allocated yet
        m_szNextCounter = NULL;
    }
    return (LPCWSTR)szReturn;
}

//
//  Get next counter in counter list
//  NULL pointer means no more counters in list
//
LPCWSTR
CSmAlertQuery::GetNextCounter()
{
    LPWSTR  szReturn;
    szReturn = m_szNextCounter;

    if (m_szNextCounter != NULL) {
        m_szNextCounter += lstrlen(szReturn) + 1;
        if (*m_szNextCounter == 0) {
            // end of list reached so set pointer to NULL
            m_szNextCounter = NULL;
        }
    } else {
        // already at the end of the list so nothing to do
    }

    return (LPCWSTR)szReturn;
}

//
//  clear out the counter list
//
VOID
CSmAlertQuery::ResetCounterList()
{
    if (mr_szCounterList != NULL) {
        delete (mr_szCounterList);
        m_szNextCounter = NULL;
        mr_szCounterList = NULL;
    }

    m_dwCounterListLength = sizeof(WCHAR);  // sizeof MSZ Null
    try {
        mr_szCounterList = new WCHAR [m_dwCounterListLength];
        mr_szCounterList[0] = 0;
    } catch ( ... ) {
        m_dwCounterListLength = 0;
    }
}

//
//  Add this counter string to the internal list
//
BOOL
CSmAlertQuery::AddCounter(LPCWSTR szCounterPath)
{
    DWORD   dwNewSize;
    LPWSTR  szNewString;
    LPWSTR  szNextString;

    ASSERT (szCounterPath != NULL);

    if (szCounterPath == NULL) return FALSE;

    dwNewSize = lstrlen(szCounterPath) + 1;

    if (m_dwCounterListLength <= 2) {
        dwNewSize += 1; // add room for the MSZ null
        // then this is the first string to go in the list
        try {
            szNewString = new TCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        szNextString = szNewString;
    } else {
        dwNewSize += m_dwCounterListLength;
        // this is the nth string to go in the list
        try {
            szNewString = new TCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        memcpy (szNewString, mr_szCounterList,
            (m_dwCounterListLength * sizeof(TCHAR)));
        szNextString = szNewString;
        szNextString += m_dwCounterListLength - 1;
    }
    lstrcpyW (szNextString, szCounterPath);
    szNextString = szNewString;
    szNextString += dwNewSize - 1;
    *szNextString = 0;  // MSZ Null

    if (mr_szCounterList != NULL) delete (mr_szCounterList);
    mr_szCounterList = szNewString;
    m_szNextCounter = szNewString;
    m_dwCounterListLength = dwNewSize;

    return TRUE;
}

DWORD
CSmAlertQuery::GetLogType()
{
    return ( SLQ_ALERT );
}

BOOL
CSmAlertQuery::SetLogFileType ( const DWORD /* dwType */)
{
    // No alert log file type
    return FALSE;
}

//
//  Get log file type and return as a string
//
//
const CString&
CSmAlertQuery::GetLogFileType ( )
{
    return cstrEmpty;
}

void
CSmAlertQuery::GetLogFileType ( DWORD& rdwFileType )
{
    // Log file type should default in property bags.
    ASSERT ( FALSE );
    rdwFileType = ((DWORD)0xFFFFFFFF);
    return;
}

LPCWSTR
CSmAlertQuery::GetCounterList( LPDWORD  pcchListSize)
{
    if (pcchListSize != NULL) *pcchListSize = m_dwCounterListLength;
    return mr_szCounterList;
}

BOOL    CSmAlertQuery::SetCounterList( LPCWSTR mszCounterList, DWORD cchListSize)
{
    BOOL bReturn = TRUE;

    if (mr_szCounterList != NULL) {
        delete (mr_szCounterList);
        mr_szCounterList = NULL;
        m_dwCounterListLength = 0;
    }

    try {

        mr_szCounterList = new TCHAR [cchListSize];
        memcpy (mr_szCounterList, mszCounterList, (cchListSize * sizeof(TCHAR)));
        m_dwCounterListLength = cchListSize;
    } catch ( ... ) {
        bReturn = FALSE;
    }

    return bReturn;
}

const CString&
CSmAlertQuery::GetLogFileName( BOOL )
{
    // 2000.1 return empty string so that empty string is written to HTML file for alerts.
    return cstrEmpty;
}

HRESULT
CSmAlertQuery::LoadCountersFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    PDH_STATUS  pdhStatus;
    DWORD       dwCount;
    DWORD       dwIndex;
    CString     strParamName;
    LPTSTR      szLocaleBuf = NULL;
    DWORD       dwLocaleBufSize = 0;
    LPTSTR      pszPath;
    PALERT_INFO_BLOCK   paibInfo = NULL;

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_SYSMON_COUNTERCOUNT,
            0,
            dwCount);

    for ( dwIndex = 1; dwIndex <= dwCount; dwIndex++ ) {
        LPTSTR  szCounterPath = NULL;
        DWORD   dwBufSize = 0;
        DWORD   dwByteCount = 0;
        DWORD   dwOverUnder;
        DOUBLE  dThreshold;
        LPTSTR  pNewBuf;

        strParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, dwIndex );
        hr = StringFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strParamName,
                L"",
                &szCounterPath,
                &dwBufSize );

        pszPath = szCounterPath;

        if (dwBufSize > sizeof(TCHAR)) {
            //
            // Initialize the locale path buffer
            //
            if (dwLocaleBufSize == 0) {
                dwLocaleBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                szLocaleBuf = (LPTSTR) G_ALLOC(dwLocaleBufSize);
                if (szLocaleBuf == NULL) {
                    dwLocaleBufSize = 0;
                }
            }

            if (szLocaleBuf != NULL) {
                //
                // Translate counter name from English to Localization
                //
                dwBufSize = dwLocaleBufSize;

                pdhStatus = PdhTranslateLocaleCounter(
                                szCounterPath,
                                szLocaleBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR) G_REALLOC(szLocaleBuf, dwBufSize);
                    if (pNewBuf != NULL) {
                        szLocaleBuf = pNewBuf;
                        dwLocaleBufSize = dwBufSize;

                        pdhStatus = PdhTranslateLocaleCounter(
                                        szCounterPath,
                                        szLocaleBuf,
                                        &dwBufSize);                    
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szLocaleBuf;
                }
            }
        }

        strParamName.Format ( IDS_HTML_ALERT_OVER_UNDER, dwIndex );
        hr = DwordFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strParamName,
                AIBF_UNDER,
                dwOverUnder);

        strParamName.Format ( IDS_HTML_ALERT_THRESHOLD, dwIndex );
        hr = DoubleFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strParamName,
                ((DOUBLE)0.0),
                dThreshold);

        dwByteCount = sizeof (ALERT_INFO_BLOCK) + ((lstrlen(pszPath) + 3 + 20 + 1) * sizeof(TCHAR));

        MFC_TRY
            LPTSTR szString = NULL;
            paibInfo = (PALERT_INFO_BLOCK) new CHAR[dwByteCount];
            ZeroMemory ( paibInfo, dwByteCount );
            // 1 = size of "<"
            // 20 = size of threshold value
            // 1 = size of null terminator
            szString = new TCHAR[lstrlen(pszPath) + 3 + 20 + 1];
            paibInfo->dwSize = dwByteCount;
            paibInfo->szCounterPath = pszPath;
            paibInfo->dwFlags = dwOverUnder;
            paibInfo->dLimit = dThreshold;

            if ( MakeStringFromInfo( paibInfo, szString, &dwByteCount ) ) {
                AddCounter ( szString );
            }
            delete szString;
        MFC_CATCH_HR
        delete szCounterPath;
        delete paibInfo;
    }

    if (szLocaleBuf != NULL) {
        G_FREE(szLocaleBuf);
    }

    // Return good status regardless.
    return S_OK;
}

HRESULT
CSmAlertQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;

    SLQ_TIME_INFO   stiDefault;
    LPTSTR      pszTemp = NULL;
    DWORD       dwBufSize;

    // Continue even if error, using defaults for missing values.

    hr = LoadCountersFromPropertyBag ( pPropBag, pIErrorLog );

    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
    stiDefault.dwValue = 5;

    hr = SlqTimeFromPropertyBag (
            pPropBag,
            pIErrorLog,
            SLQ_TT_TTYPE_SAMPLE,
            &stiDefault,
            &mr_stiSampleInterval );

    mr_strCmdFileName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_COMMAND_FILE,
            ALRT_DEFAULT_COMMAND_FILE,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strCmdFileName = pszTemp;
    }
    delete (pszTemp);
    pszTemp = NULL;

    mr_strNetName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_NETWORK_NAME,
            ALRT_DEFAULT_NETWORK_NAME,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strNetName = pszTemp;
    }
    delete (pszTemp);
    pszTemp = NULL;

    mr_strCmdUserText.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_USER_TEXT,
            ALRT_DEFAULT_USER_TEXT,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strCmdUserText = pszTemp;
    }
    delete (pszTemp);
    pszTemp = NULL;

    mr_strPerfLogName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_PERF_LOG_NAME,
            ALRT_DEFAULT_PERF_LOG_NAME,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strPerfLogName = pszTemp;
    }
    delete (pszTemp);
    pszTemp = NULL;

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_ACTION_FLAGS,
            ALRT_DEFAULT_ACTION,
            mr_dwActionFlags);

    hr = CSmLogQuery::LoadFromPropertyBag( pPropBag, pIErrorLog );

    return hr;
}


HRESULT
CSmAlertQuery::SaveCountersToPropertyBag (
    IPropertyBag* pPropBag )
{
    HRESULT    hr = NOERROR;
    LPCTSTR    szString;
    CString    strParamName;
    DWORD      dwIndex = 0;
    LPTSTR     szEnglishBuf = NULL;
    DWORD      dwEnglishBufSize = 0;
    LPTSTR     pszPath = NULL;
    PDH_STATUS pdhStatus;
    PALERT_INFO_BLOCK paibInfo = NULL;

    szString = GetFirstCounter();

    // Todo:  Stop processing on failure?
    while ( NULL != szString ) {
        LPTSTR  pNewBuf;
        DWORD   dwBufSize;

        dwBufSize = sizeof (ALERT_INFO_BLOCK) + (lstrlen(szString) + 1) * sizeof(TCHAR);
        MFC_TRY
            paibInfo = (PALERT_INFO_BLOCK) new CHAR[dwBufSize];
            if ( MakeInfoFromString( szString, paibInfo, &dwBufSize ) ) {
                dwIndex++;
                strParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, dwIndex );

                pszPath = paibInfo->szCounterPath;

                //
                // Initialize the locale path buffer
                //
                if (dwEnglishBufSize == 0) {
                    dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                    szEnglishBuf = (LPTSTR) G_ALLOC(dwEnglishBufSize);
                    if (szEnglishBuf == NULL) {
                        dwEnglishBufSize = 0;
                    }
                }

                if (szEnglishBuf != NULL) {
                    //
                    // Translate counter name from Localization into English
                    //
                    dwBufSize = dwEnglishBufSize;

                    pdhStatus = PdhTranslate009Counter(
                                    paibInfo->szCounterPath,
                                    szEnglishBuf,
                                    &dwBufSize);
    
                    if (pdhStatus == PDH_MORE_DATA) {
                        pNewBuf = (LPTSTR)G_REALLOC(szEnglishBuf, dwBufSize);
                        if (pNewBuf != NULL) {
                            szEnglishBuf = pNewBuf;
                            dwEnglishBufSize = dwBufSize;
    
                            pdhStatus = PdhTranslate009Counter(
                                            paibInfo->szCounterPath,
                                            szEnglishBuf,
                                            &dwBufSize);
                        }
                    }

                    if (pdhStatus == ERROR_SUCCESS) {
                        pszPath = szEnglishBuf;
                    }
                }

                //
                // Passing sz. ( TCHAR[n] ) causes memory alloc, which might throw an exception
                //
                hr = StringToPropertyBag ( pPropBag, strParamName, pszPath);

                strParamName.Format ( IDS_HTML_ALERT_OVER_UNDER, dwIndex );
                hr = DwordToPropertyBag ( pPropBag, strParamName, paibInfo->dwFlags );

                strParamName.Format ( IDS_HTML_ALERT_THRESHOLD, dwIndex );
                hr = DoubleToPropertyBag ( pPropBag, strParamName, paibInfo->dLimit );
            }
        MFC_CATCH_HR
        if ( NULL != paibInfo ) {
            delete paibInfo;
            paibInfo = NULL;
        }
        szString = GetNextCounter();
    }
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SYSMON_COUNTERCOUNT, dwIndex );

    if (szEnglishBuf != NULL) {
        G_FREE(szEnglishBuf);
    }

//  Todo:  Caller handle error
    return hr;
}

HRESULT
CSmAlertQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL fSaveAllProps )
{
    HRESULT hr = NOERROR;

    hr = SaveCountersToPropertyBag ( pPropBag );
    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_SAMPLE, &mr_stiSampleInterval );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_COMMAND_FILE, mr_strCmdFileName );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_NETWORK_NAME, mr_strNetName );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_USER_TEXT, mr_strCmdUserText );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_PERF_LOG_NAME, mr_strPerfLogName );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_ACTION_FLAGS, mr_dwActionFlags );

    hr = CSmLogQuery::SaveToPropertyBag( pPropBag, fSaveAllProps );

    return hr;
}


HRESULT
CSmAlertQuery::TranslateMSZAlertCounterList(
    LPTSTR   pszCounterList,
    LPTSTR   pBuffer,
    LPDWORD  pdwBufferSize,
    BOOL     bFlag
    )
{
    LPTSTR  pTmpBuf = NULL;
    DWORD   dwTmpBufSize = 0;
    DWORD   dwSize = 0;
    LPTSTR  pNewBuf = NULL;
    LPTSTR  pOriginPath = NULL;
    LPTSTR  pszCounterPathToAdd = NULL;
    LPTSTR  pNextStringPosition = NULL;
    BOOL    bNotEnoughBuffer = FALSE;
    DWORD   dwNewCounterListLen = 0;
    DWORD   dwCounterPathLen = 0;
    PDH_STATUS Status  = ERROR_SUCCESS;
    LPTSTR  pData = NULL;
    LPTSTR  pszBackupPath = NULL;
    int     nBackupLen = 0;


    if (pszCounterList == NULL || pdwBufferSize == NULL) {

        Status = ERROR_INVALID_PARAMETER;
        goto ErrorOut;
    }

    if (pBuffer == NULL || *pdwBufferSize == 0) {
        bNotEnoughBuffer = TRUE;
    }

    //
    // Probe parameters
    //
    __try {
        if (* pdwBufferSize != 0 && pBuffer != NULL) {
            *pBuffer = 0;

            * (LPTSTR) (  ((LPBYTE) pBuffer)
                        + ((* pdwBufferSize) - sizeof(*pBuffer)) ) = 0;
        }
    
        pOriginPath = pszCounterList;

        while (*pOriginPath) {
            //
            // Locate the position where the data description begins
            //
            pData = pOriginPath;
            while (*pData != _T('\0') && *pData != _T('<') && *pData != _T('>'))  {
                pData++;
            }

            //
            // Backup the counter path
            //
            //
            if (pszBackupPath == NULL) {
                nBackupLen = MAX_PATH + 1;
                pszBackupPath = (LPTSTR) G_ALLOC(nBackupLen * sizeof(TCHAR));

                if (pszBackupPath == NULL) {
                    Status = ERROR_OUTOFMEMORY;
                    goto ErrorOut;
                }
            }

            if (lstrlen(pOriginPath) + 1 > nBackupLen) {
                nBackupLen = lstrlen(pOriginPath) + 1;
                pNewBuf = (LPTSTR) G_REALLOC(pszBackupPath, nBackupLen * sizeof(TCHAR) );
                if (pNewBuf == NULL) {
                    Status = ERROR_OUTOFMEMORY;
                    goto ErrorOut;
                }
                pszBackupPath = pNewBuf;
            }

            lstrcpyn(pszBackupPath, pOriginPath, (int)(pData - pOriginPath + 1));

            pszCounterPathToAdd = pszBackupPath;
    
            //
            // Initialize the buffer used for translating counter path
            // called only once
            //
            if (pTmpBuf == NULL) {
                dwTmpBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                pTmpBuf = (LPTSTR) G_ALLOC(dwTmpBufSize);
                if (pTmpBuf == NULL) {
                    dwTmpBufSize = 0;
                }
            }

            if (pTmpBuf != NULL) {
                dwSize = dwTmpBufSize;
     
                if (bFlag) {
                    Status = PdhTranslateLocaleCounter(
                                    pszBackupPath,
                                    pTmpBuf,
                                    &dwSize);
                }
                else {
                   Status = PdhTranslate009Counter(
                                   pszBackupPath,
                                   pTmpBuf,
                                   &dwSize);
                }

                if (Status == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR) G_REALLOC(pTmpBuf, dwSize);
                    if (pNewBuf == NULL) {
                        Status = ERROR_OUTOFMEMORY;
                        goto ErrorOut;
                    }

                    pTmpBuf = pNewBuf;
                    dwTmpBufSize = dwSize;
    
                    //
                    // Try second time
                    //
                    if (bFlag) {
                        Status = PdhTranslateLocaleCounter(
                                        pszBackupPath,
                                        pTmpBuf,
                                        &dwSize);
                    }
                    else {
                        Status = PdhTranslate009Counter(
                                        pszBackupPath,
                                        pTmpBuf,
                                        &dwSize);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pszCounterPathToAdd = pTmpBuf;
                }
            }

            //
            // Add the translated counter path(it is the original 
            // counter path if translation failed) to the new counter
            // path list
            //

            dwCounterPathLen = lstrlen(pszCounterPathToAdd) + 1;

            dwNewCounterListLen += dwCounterPathLen;

            if (! bNotEnoughBuffer) {
                if ( (dwNewCounterListLen + lstrlen(pData) + 1) * sizeof(TCHAR) <= *pdwBufferSize) {
                    //
                    // Set up the copy position
                    //
                    pNextStringPosition = pBuffer + dwNewCounterListLen - dwCounterPathLen;
                    lstrcpy(pNextStringPosition, pszCounterPathToAdd);
                    lstrcat(pNextStringPosition, pData);
                }
                else {
                   bNotEnoughBuffer = TRUE;
                }
            }
            dwNewCounterListLen += lstrlen(pData);

            //
            // Continue processing next counter path
            //
            pOriginPath += lstrlen(pOriginPath) + 1;
        }

        dwNewCounterListLen ++;
        if (! bNotEnoughBuffer) {
            //
            // Append the terminating 0
            //
            pBuffer[dwNewCounterListLen - 1] = _T('\0');
        }
        else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    
        *pdwBufferSize = dwNewCounterListLen * sizeof(TCHAR);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

ErrorOut:
    if (pszBackupPath != NULL) {
        G_FREE(pszBackupPath);
    }
    if (pTmpBuf != NULL) {
        G_FREE(pTmpBuf);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smalrtq.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtq.h

Abstract:

    This object is used to represent performance alert queries (a.k.a.
    sysmon alert queries).

--*/

#ifndef _CLASS_SMALRTQ_
#define _CLASS_SMALRTQ_

#include "smlogqry.h"

typedef struct _ALERT_ACTION_INFO {
    DWORD   dwSize;
    DWORD   dwActionFlags;
    LPWSTR  szNetName;
    LPWSTR  szCmdFilePath;
    LPWSTR  szUserText;
    LPWSTR  szLogName;
} ALERT_ACTION_INFO, *PALERT_ACTION_INFO;

class CSmLogService;

class CSmAlertQuery : public CSmLogQuery
{
    // constructor/destructor
    public:
        CSmAlertQuery( CSmLogService* );
        virtual ~CSmAlertQuery( void );

    // public methods
    public:

        virtual         DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly);
        virtual         DWORD   Close ( void );

        virtual         DWORD   UpdateRegistry( void );   // load reg. w/ internal values
        virtual         DWORD   SyncWithRegistry( void );

        virtual         BOOL    GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags);
        virtual         BOOL    SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags);
        virtual         BOOL    GetDefaultLogTime(SLQ_TIME_INFO&  rTimeInfo,  DWORD dwFlags);

        virtual         DWORD   GetLogType( void );

        virtual const   CString& GetLogFileType ( void );
        virtual         void    GetLogFileType ( DWORD& );
        virtual         BOOL    SetLogFileType ( const DWORD );

        virtual const   CString&  GetLogFileName( BOOL bLatestRunning = FALSE );

                        // Methods specific to this query type

                        LPCWSTR GetCounterList( LPDWORD pcchListSize );
                        BOOL    SetCounterList( LPCWSTR mszCounterList, DWORD cchListSize );

                        LPCWSTR GetFirstCounter( void );
                        LPCWSTR GetNextCounter( void );
                        VOID    ResetCounterList( void );
                        BOOL    AddCounter(LPCWSTR szCounterPath);

                        BOOL    GetActionInfo( PALERT_ACTION_INFO pInfo, LPDWORD pdwInfoBufSize);
                        DWORD   SetActionInfo( PALERT_ACTION_INFO pInfo );

        virtual         HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual         HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );

        virtual         HRESULT LoadCountersFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual         HRESULT SaveCountersToPropertyBag   ( IPropertyBag* );

        virtual         HRESULT TranslateMSZAlertCounterList( LPTSTR  pszCounterList,
                                                         LPTSTR  pBuffer,
                                                         LPDWORD pdwBufferSize,
                                                         BOOL    bFlag);

        virtual CSmAlertQuery*      CastToAlertQuery( void ) { return this; };
        // protected methods
    protected:

    // private member variables
    private:

        LPWSTR  m_szNextCounter;
        DWORD   m_dwCounterListLength;  // in chars including MSZ null

        // Registry Values
        LPWSTR  mr_szCounterList;
        DWORD   mr_dwActionFlags;
        CString mr_strNetName;
        CString mr_strCmdFileName;
        CString mr_strCmdUserText;
        CString mr_strCmdUserTextIndirect;
        CString mr_strPerfLogName;
};


typedef CSmAlertQuery   SLALERTQUERY;
typedef CSmAlertQuery*  PSLALERTQUERY;


#endif //_CLASS_SMALRTQ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smcfghlp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smcfghlp.h

Abstract:

    Help ID definitions for the Performance Logs and Alerts
    MMC snap-in.

--*/

#ifndef _SMCFGHLP_H_
#define _SMCFGHLP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Property pages

#define IDH_PG_SMCFG_FILES      1000200
#define IDH_PG_SMCFG_SCHEDULE   1000201
#define IDH_PG_SMCFG_CTRS_GEN   1000202
#define IDH_PG_SMCFG_TRACE_GEN  1000203
#define IDH_PG_SMCFG_TRACE_BUF  1000204
#define IDH_PG_SMCFG_ALERT_GEN  1000205
#define IDH_PG_SMCFG_ALERT_ACT  1000206

// Dialogs
// New query
#define IDH_NEWQ_NAME_EDIT          1000220

//Expensive Warning
#define IDH_CHECK_NO_MORE           1000230

// Prov status
#define IDH_PACT_PROVIDERS_LIST     1000240
#define IDH_PACT_CHECK_SHOW_ENABLED 1000241

// Prov add
#define IDH_PADD_PROVIDER_LIST      1000250

// Property pages

// Schedule

#define IDH_SCHED_START_MANUAL_RDO          1000300
#define IDH_SCHED_START_AT_RDO              1000301
#define IDH_SCHED_START_AT_TIME_DT          1000302
#define IDH_SCHED_START_AT_DATE_DT          1000303
#define IDH_SCHED_STOP_MANUAL_RDO           1000304
#define IDH_SCHED_STOP_SIZE_RDO             1000305
#define IDH_SCHED_STOP_AFTER_RDO            1000306
#define IDH_SCHED_STOP_AFTER_EDIT           1000307
#define IDH_SCHED_STOP_AFTER_UNITS_COMBO    1000308
#define IDH_SCHED_STOP_AT_RDO               1000309
#define IDH_SCHED_STOP_AT_TIME_DT           1000310
#define IDH_SCHED_STOP_AT_DATE_DT           1000311
#define IDH_SCHED_RESTART_CHECK             1000312
#define IDH_SCHED_EXEC_CHECK                1000313
#define IDH_SCHED_CMD_EDIT                  1000314
#define IDH_SCHED_CMD_BROWSE_BTN            1000315

//Trace buffers
#define IDH_TRACE_BUFFER_SIZE_EDIT      1000330
#define IDH_TRACE_MIN_BUF_EDIT          1000331
#define IDH_TRACE_MAX_BUF_EDIT          1000332
#define IDH_TRACE_BUF_FLUSH_CHECK       1000333
#define IDH_TRACE_FLUSH_INT_EDIT        1000334

// Alert Action
#define  IDH_ACTION_APPLOG_CHK          1000350
#define  IDH_ACTION_NETMSG_CHK          1000351
#define  IDH_ACTION_NETMSG_NAME_EDIT    1000352
#define  IDH_ACTION_START_LOG_CHK       1000353
#define  IDH_ACTION_START_LOG_COMBO     1000354
#define  IDH_ACTION_EXECUTE_CHK         1000355
#define  IDH_ACTION_EXECUTE_EDIT        1000356
#define  IDH_ACTION_EXECUTE_BROWSE_BTN  1000357
#define  IDH_ACTION_CMD_ARGS_DISPLAY    1000358
#define  IDH_ACTION_CMD_ARGS_BTN        1000359
//#define  IDH_ACTION_CAPTION             1000360

// Alert Command Arg
#define  IDH_CMD_ARG_SINGLE_CHK     1000380
#define  IDH_CMD_ARG_DATE_CHK       1000381
#define  IDH_CMD_ARG_VALUE_CHK      1000382
#define  IDH_CMD_ARG_ALERT_CHK      1000383
#define  IDH_CMD_ARG_NAME_CHK       1000384
#define  IDH_CMD_ARG_LIMIT_CHK      1000385
#define  IDH_CMD_USER_TEXT_CHK      1000386
#define  IDH_CMD_USER_TEXT_EDIT     1000387
#define  IDH_CMD_ARG_SAMPLE_DISPLAY 1000388
//#define  IDH_CMD_ARG_SAMPLE_CAPTION 1000389

// Alert General 
#define  IDH_ALRTS_COMMENT_EDIT         1000400
#define  IDH_ALRTS_COUNTER_LIST         1000401
#define  IDH_ALRTS_OVER_UNDER           1000402
#define  IDH_ALRTS_VALUE_EDIT           1000403
#define  IDH_ALRTS_ADD_BTN              1000404
#define  IDH_ALRTS_REMOVE_BTN           1000405
#define  IDH_ALRTS_SAMPLE_EDIT          1000406
#define  IDH_ALRTS_SAMPLE_UNITS_COMBO   1000407

// Counters
#define IDH_CTRS_COUNTER_LIST           1000420
#define IDH_CTRS_FILENAME_DISPLAY       1000421
#define IDH_CTRS_ADD_BTN                1000422
#define IDH_CTRS_ADD_OBJ_BTN            2000100    // added for Whistler
#define IDH_CTRS_REMOVE_BTN             1000423
#define IDH_CTRS_SAMPLE_EDIT            1000424
#define IDH_CTRS_SAMPLE_UNITS_COMBO     1000425

//Prov Prop
#define IDH_PROV_FILENAME_DISPLAY   1000440
#define IDH_PROV_SHOW_PROVIDERS_BTN 1000441
#define IDH_PROV_KERNEL_BTN         1000442
#define IDH_PROV_K_PROCESS_CHK      1000443
#define IDH_PROV_K_NETWORK_CHK      1000444
#define IDH_PROV_K_THREAD_CHK       1000445
#define IDH_PROV_K_SOFT_PF_CHK      1000446
#define IDH_PROV_K_DISK_IO_CHK      1000447
#define IDH_PROV_K_FILE_IO_CHK      1000448
#define IDH_PROV_OTHER_BTN          1000449
#define IDH_PROV_PROVIDER_LIST      1000450
#define IDH_PROV_ADD_BTN            1000451
#define IDH_PROV_REMOVE_BTN         1000452

// Files            called Logs in Whistler
#define IDH_FILES_COMMENT_EDIT          1000460
#define IDH_FILES_LOG_TYPE_COMBO        1000461
#define IDH_FILES_SIZE_LIMIT_UNITS      1000465
#define IDH_FILES_FOLDER_EDIT           1000466
#define IDH_FILES_FILENAME_EDIT         1000467
#define IDH_FILES_AUTO_SUFFIX_CHK       1000468
#define IDH_FILES_FIRST_SERIAL_EDIT     1000469
#define IDH_FILES_SUFFIX_COMBO          1000471
#define IDH_FILES_SAMPLE_DISPLAY        1000472
#define IDH_CFG_BTN                     2000101    // added for Whistler
#define IDH_FILES_OVERWRITE_CHK         2000102    // added for Whistler
#define IDH_RUNAS_EDIT                  2000115    // added for Whistler
#define IDH_SETPWD_BTN                  2000116    // added for Whistler
#define IDH_CTRS_ENTER_PWD              2000117    // added for Whistler
#define IDH_CTRS_REENTER_PWD            2000118    // added for Whistler
#define IDH_USERNAME                    2000119    // added for Whistler

// Log Files Tab  added for Whistler
#define IDH_FILES_FOLDER_CAPTION        2000103 // added for Whistler
#define IDH_FILES_FOLDER_BTN            2000104 // added for Whistler
#define IDH_FILES_FILENAME_CAPTION      2000105 // added for Whistler
#define IDH_FILES_SIZE_MAX_BTN          2000106 // added for Whistler
#define IDH_FILES_SIZE_LIMIT_BTN        2000107 // added for Whistler
#define IDH_FILES_SIZE_LIMIT_EDIT       2000108 // added for Whistler

// SQL Logs Tab added for Whistler
#define IDH_SQL_DSN_COMBO              2000109 // added for Whistler
#define IDH_SQL_FILENAME_EDIT          2000110 // added for Whistler
#define IDH_SQL_SIZE_MAX_BTN           2000111 // added for Whistler
#define IDH_SQL_SIZE_LIMIT_BTN         2000112 // added for Whistler
#define IDH_SQL_SIZE_LIMIT_EDIT        2000113  // added for Whistler
#define IDH_SQL_SIZE_LIMIT_SPIN        2000114  // added for Whistler

////////////////////////////
///
/// LAST ID USED     2000119
///
////////////////////////////

#endif // _SMCFGHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smctrqry.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrqry.h

Abstract:

    Class definitions for the counter log query.

--*/

#ifndef _CLASS_SMCTRQRY_
#define _CLASS_SMCTRQRY_

#include "smlogqry.h"

class CSmCounterLogQuery : public CSmLogQuery
{
    // constructor/destructor
    public:
                CSmCounterLogQuery( CSmLogService* );
        virtual ~CSmCounterLogQuery( void );

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly);
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry( void );

        virtual BOOL    GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags);
        virtual BOOL    SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags);
        virtual BOOL    GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags);

        virtual DWORD   GetLogType( void );

                LPCWSTR GetFirstCounter( void );
                LPCWSTR GetNextCounter( void );
                VOID    ResetCounterList( void );
                BOOL    AddCounter(LPCWSTR szCounterPath);

        virtual HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );
        virtual HRESULT LoadCountersFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual HRESULT SaveCountersToPropertyBag   ( IPropertyBag* );
        virtual HRESULT TranslateMSZCounterList( LPTSTR  pszCounterList,
                                                 LPTSTR  pBuffer,
                                                 LPDWORD pdwBufferSize,
                                                 BOOL    bFlag);

        virtual CSmCounterLogQuery* CastToCounterLogQuery ( void ) { return this; };
        // protected methods
    protected:
        virtual DWORD   UpdateRegistry();


    // private member variables
    private:

        LPTSTR  m_szNextCounter;
        DWORD   m_dwCounterListLength;  // in chars including MSZ null

        // Registry Values
        LPTSTR  mr_szCounterList;
};


typedef CSmCounterLogQuery   SLCTRQUERY;
typedef CSmCounterLogQuery*  PSLCTRQUERY;


#endif //_CLASS_SMCTRQRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smctrqry.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrqry.cpp

Abstract:

    Implementation of the counter log query class.

--*/

#include "Stdafx.h"
#include <pdhp.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhmsg.h>
#include "smctrqry.h"

USE_HANDLE_MACROS("SMLOGCFG(smctrqry.cpp)");

//
//  Constructor
CSmCounterLogQuery::CSmCounterLogQuery( CSmLogService* pLogService )
:   CSmLogQuery( pLogService ),
    m_dwCounterListLength ( 0 ),
    m_szNextCounter ( NULL ),
    mr_szCounterList ( NULL )
{
    // initialize member variables
    memset (&mr_stiSampleInterval, 0, sizeof(mr_stiSampleInterval));
    return;
}

//
//  Destructor
CSmCounterLogQuery::~CSmCounterLogQuery()
{
    return;
}

//
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD
CSmCounterLogQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT ( SLQ_COUNTER_LOG == GetLogType() );

    dwStatus = CSmLogQuery::Open ( rstrName, hKeyQuery, bReadOnly );

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//
DWORD
CSmCounterLogQuery::Close ()
{
    DWORD dwStatus;
    LOCALTRACE (L"Closing Query\n");

    if (mr_szCounterList != NULL) {
        delete (mr_szCounterList);
        mr_szCounterList = NULL;
    }

    dwStatus = CSmLogQuery::Close();

    return dwStatus;
}


//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD
CSmCounterLogQuery::UpdateRegistry() 
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize;
    LPTSTR  szNewCounterList = NULL;

    if ( IsModifiable() ) {

        dwBufferSize = 0;
        //
        // Translate the counter list into English
        //
        dwStatus = TranslateMSZCounterList(mr_szCounterList,
                            NULL,
                            &dwBufferSize,
                            FALSE);
        if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {
            szNewCounterList = (LPTSTR) new char [dwBufferSize];
            if (szNewCounterList != NULL) {
                dwStatus = TranslateMSZCounterList(mr_szCounterList,
                                szNewCounterList,
                                &dwBufferSize,
                                FALSE);
            }
        }

        if (dwStatus == ERROR_SUCCESS && szNewCounterList != NULL) {
            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                szNewCounterList,
                                &dwBufferSize);
        }
        else {
            dwBufferSize = m_dwCounterListLength * sizeof(TCHAR);
            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                mr_szCounterList,
                                &dwBufferSize);
        }

        // Schedule

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistrySlqTime (
                m_hKeyQuery,
                IDS_REG_SAMPLE_INTERVAL,
                &mr_stiSampleInterval);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = CSmLogQuery::UpdateRegistry ();
        }

    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and reloads the internal values to match
//
//
DWORD
CSmCounterLogQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiDefault;
    LPTSTR  szNewCounterList;

    ASSERT (m_hKeyQuery != NULL);

    // load counter string list

    // Get Counter List
    dwStatus = ReadRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_COUNTER_LIST,
                    NULL,
                    &mr_szCounterList,
                    &dwBufferSize);

    if (dwStatus != ERROR_SUCCESS) {
        m_szNextCounter = NULL; //re-initialize
        m_dwCounterListLength = 0;
    } else {
        m_dwCounterListLength = dwBufferSize / sizeof(TCHAR);
        //
        // Translate the counter list into Locale
        //
        dwBufferSize = 0;
        dwStatus = TranslateMSZCounterList(
                                mr_szCounterList,
                                NULL,
                                &dwBufferSize,
                                TRUE);

        if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {
            
            szNewCounterList = (LPTSTR) new char [dwBufferSize];

            if (szNewCounterList != NULL) {
                //
                // Translate the counter list into Locale
                //
                dwStatus = TranslateMSZCounterList(
                                mr_szCounterList,
                                szNewCounterList,
                                &dwBufferSize,
                                TRUE);
           
                if (dwStatus == ERROR_SUCCESS) {
                    m_dwCounterListLength = dwBufferSize / sizeof(TCHAR);
                    //
                    // Remove the old
                    //
                    delete (mr_szCounterList);
                    m_szNextCounter = NULL;
                    mr_szCounterList = szNewCounterList;
                }
            }
        }
    }


    // Schedule

    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
    stiDefault.dwValue = 15;

    dwStatus = ReadRegistrySlqTime (
                m_hKeyQuery,
                IDS_REG_SAMPLE_INTERVAL,
                &stiDefault,
                &mr_stiSampleInterval);
    ASSERT (dwStatus == ERROR_SUCCESS);

    // Call parent class last to update shared values.

    dwStatus = CSmLogQuery::SyncWithRegistry();
    ASSERT (dwStatus == ERROR_SUCCESS);

    return dwStatus;
}

//
//  Get first counter in counter list
//
LPCWSTR
CSmCounterLogQuery::GetFirstCounter()
{
    LPTSTR  szReturn;

    szReturn = mr_szCounterList;
    if (szReturn != NULL) {
        if (*szReturn == 0) {
            // then it's an empty string
            szReturn = NULL;
            m_szNextCounter = NULL;
        } else {
            m_szNextCounter = szReturn + lstrlen(szReturn) + 1;
            if (*m_szNextCounter == 0) {
                // end of list reached so set pointer to NULL
                m_szNextCounter = NULL;
            }
        }
    } else {
        // no buffer allocated yet
        m_szNextCounter = NULL;
    }
    return (LPCWSTR)szReturn;
}

//
//  Get next counter in counter list
//  NULL pointer means no more counters in list
//
LPCWSTR
CSmCounterLogQuery::GetNextCounter()
{
    LPTSTR  szReturn;
    szReturn = m_szNextCounter;

    if (m_szNextCounter != NULL) {
        m_szNextCounter += lstrlen(szReturn) + 1;
        if (*m_szNextCounter == 0) {
            // end of list reached so set pointer to NULL
            m_szNextCounter = NULL;
        }
    } else {
        // already at the end of the list so nothing to do
    }

    return (LPCWSTR)szReturn;
}

//
//  clear out the counter list
//
VOID
CSmCounterLogQuery::ResetCounterList()
{
    if (mr_szCounterList != NULL) {
        delete (mr_szCounterList);
        m_szNextCounter = NULL;
        mr_szCounterList = NULL;
    }

    m_dwCounterListLength = sizeof(WCHAR);  // sizeof MSZ Null
    try {
        mr_szCounterList = new WCHAR [m_dwCounterListLength];
        mr_szCounterList[0] = 0;
    } catch ( ... ) {
        m_dwCounterListLength = 0;
    }
}

//
//  Add this counter string to the internal list
//
BOOL
CSmCounterLogQuery::AddCounter(LPCWSTR szCounterPath)
{
    DWORD   dwNewSize;
    LPTSTR  szNewString;
    LPTSTR  szNextString;

    ASSERT (szCounterPath != NULL);

    if (szCounterPath == NULL) {
        return FALSE;
    }

    dwNewSize = lstrlen(szCounterPath) + 1;

    if (m_dwCounterListLength <= 2) {
        dwNewSize += 1; // add room for the MSZ null
        // then this is the first string to go in the list
        try {
            szNewString = new TCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        szNextString = szNewString;
    } else {
        dwNewSize += m_dwCounterListLength;
        // this is the nth string to go in the list
        try {
            szNewString = new TCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        memcpy (szNewString, mr_szCounterList,
            (m_dwCounterListLength * sizeof(TCHAR)));
        szNextString = szNewString;
        szNextString += m_dwCounterListLength - 1;
    }
    lstrcpyW (szNextString, szCounterPath);
    szNextString = szNewString;
    szNextString += dwNewSize - 1;
    *szNextString = 0;  // MSZ Null

    if (mr_szCounterList != NULL) {
        delete (mr_szCounterList);
    }
    mr_szCounterList = szNewString;
    m_szNextCounter = szNewString;
    m_dwCounterListLength = dwNewSize;

    return TRUE;
}

BOOL
CSmCounterLogQuery::GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::GetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmCounterLogQuery::SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::SetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmCounterLogQuery::GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags)
{
    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags ) );

    rTimeInfo.wTimeType = (WORD)dwFlags;
    rTimeInfo.wDataType = SLQ_TT_DTYPE_DATETIME;

    if ( SLQ_TT_TTYPE_START == dwFlags ) {
        SYSTEMTIME  stLocalTime;
        FILETIME    ftLocalTime;

        // Milliseconds set to 0 for Schedule times
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_AT;
        rTimeInfo.llDateTime = *(LONGLONG *)&ftLocalTime;
    } else {
        // Default stop values
        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_NONE;
        rTimeInfo.llDateTime = MAX_TIME_VALUE;
    }

    return TRUE;
}

DWORD
CSmCounterLogQuery::GetLogType()
{
    return ( SLQ_COUNTER_LOG );
}

HRESULT
CSmCounterLogQuery::LoadCountersFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT hr = S_OK;
    PDH_STATUS pdhStatus;
    CString strParamName;
    DWORD   dwCount = 0;
    DWORD   dwIndex;
    LPTSTR  szLocaleBuf = NULL;
    DWORD   dwLocaleBufSize = 0;

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_SYSMON_COUNTERCOUNT,
            0,
            dwCount);

    for ( dwIndex = 1; dwIndex <= dwCount; dwIndex++ ) {
        LPTSTR szCounterPath = NULL;
        LPTSTR pszPath = NULL;
        DWORD  dwBufSize = 0;
        LPTSTR pNewBuf;

        strParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, dwIndex );
        hr = StringFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strParamName,
                L"",
                &szCounterPath,
                &dwBufSize );

        pszPath = szCounterPath;

        if (dwBufSize > sizeof(TCHAR)) {
            //
            // Initialize the locale path buffer
            //
            if (dwLocaleBufSize == 0) {
                dwLocaleBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                szLocaleBuf = (LPTSTR) G_ALLOC(dwLocaleBufSize);
                if (szLocaleBuf == NULL) {
                    dwLocaleBufSize = 0;
                }
            }

            if (szLocaleBuf != NULL) {
                //
                // Translate counter name from English to Localization
                //
                dwBufSize = dwLocaleBufSize;

                pdhStatus = PdhTranslateLocaleCounter(
                                szCounterPath,
                                szLocaleBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR)G_REALLOC(szLocaleBuf, dwBufSize);
                    if (pNewBuf != NULL) {
                        szLocaleBuf = pNewBuf;
                        dwLocaleBufSize = dwBufSize;

                        pdhStatus = PdhTranslateLocaleCounter(
                                        szCounterPath,
                                        szLocaleBuf,
                                        &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szLocaleBuf;
                }
            }

            AddCounter ( pszPath );
        }

        delete (szCounterPath);
    }

    if (szLocaleBuf != NULL) {
        G_FREE(szLocaleBuf);
    }

    return hr;
}


HRESULT
CSmCounterLogQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    SLQ_TIME_INFO   stiDefault;

    // Continue even if error, using defaults for missing values.
    hr = LoadCountersFromPropertyBag( pPropBag, pIErrorLog );

    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
    stiDefault.dwValue = 15;

    hr = SlqTimeFromPropertyBag (
            pPropBag,
            pIErrorLog,
            SLQ_TT_TTYPE_SAMPLE,
            &stiDefault,
            &mr_stiSampleInterval );

    hr = CSmLogQuery::LoadFromPropertyBag( pPropBag, pIErrorLog );
	
	return hr;
}

HRESULT
CSmCounterLogQuery::SaveCountersToPropertyBag (
    IPropertyBag* pPropBag )
{
    HRESULT    hr = NOERROR;
    CString    strParamName;
    LPCTSTR    pszCounterPath;
    LPTSTR     szEnglishBuf = NULL;
    DWORD      dwEnglishBufSize = 0;
    LPCTSTR    pszPath = NULL;
    PDH_STATUS pdhStatus;

    DWORD dwIndex = 0;

    pszCounterPath = GetFirstCounter();

    MFC_TRY
        // Passing sz ( TCHAR[n] ) causes memory alloc, which might throw an exception
        while ( NULL != pszCounterPath ) {
            LPTSTR pNewBuf;
            DWORD  dwBufSize;

            pszPath = pszCounterPath;

            //
            // Initialize the locale path buffer
            //
            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                szEnglishBuf = (LPTSTR) G_ALLOC(dwEnglishBufSize);
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from Localization into English
                //
                dwBufSize = dwEnglishBufSize;

                pdhStatus = PdhTranslate009Counter(
                                (LPTSTR)pszCounterPath,
                                szEnglishBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR)G_REALLOC(szEnglishBuf, dwBufSize);
                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;

                        pdhStatus = PdhTranslate009Counter(
                                        (LPTSTR)pszCounterPath,
                                        szEnglishBuf,
                                        &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szEnglishBuf;
                }
            }

            // Counter path count starts with 1.
            strParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, ++dwIndex );
            hr = StringToPropertyBag ( pPropBag, strParamName, pszPath );

            pszCounterPath = GetNextCounter();
        }

        hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SYSMON_COUNTERCOUNT, dwIndex );
    MFC_CATCH_HR

    if (szEnglishBuf != NULL) {
        G_FREE(szEnglishBuf);
    }

    return hr;
}

HRESULT
CSmCounterLogQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL fSaveAllProps )
{
    HRESULT hr = NOERROR;

    hr = CSmLogQuery::SaveToPropertyBag( pPropBag, fSaveAllProps );

    hr = SaveCountersToPropertyBag ( pPropBag );

    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_SAMPLE, &mr_stiSampleInterval );

    return hr;
}


HRESULT
CSmCounterLogQuery::TranslateMSZCounterList(
    LPTSTR   pszCounterList,
    LPTSTR   pBuffer,
    LPDWORD  pdwBufferSize,
    BOOL     bFlag
    )
{
    LPTSTR  pTmpBuf = NULL;
    DWORD   dwTmpBufSize = 0;
    DWORD   dwSize = 0;
    LPTSTR  pNewBuf = NULL;
    LPTSTR  pszCounterPath = NULL;
    LPTSTR  pszCounterPathToAdd = NULL;
    LPTSTR  pNextStringPosition = NULL;
    BOOL    bNotEnoughBuffer = FALSE;
    DWORD   dwNewCounterListLen = 0;
    DWORD   dwCounterPathLen = 0;
    PDH_STATUS Status  = ERROR_SUCCESS;

    if (pszCounterList == NULL || pdwBufferSize == NULL) {

        Status = ERROR_INVALID_PARAMETER;
        goto ErrorOut;
    }

    if (pBuffer == NULL || *pdwBufferSize == 0) {
        bNotEnoughBuffer = TRUE;
    }

    //
    // Probe parameters
    //
    __try {
        if (* pdwBufferSize != 0 && pBuffer != NULL) {
            *pBuffer = 0;

            * (LPTSTR) (  ((LPBYTE) pBuffer)
                        + ((* pdwBufferSize) - sizeof(*pBuffer)) ) = 0;
        }
    
        pszCounterPath = pszCounterList;

        while (*pszCounterPath) {
            pszCounterPathToAdd = pszCounterPath;
    
            //
            // Initialize the buffer used for translating counter path
            // called only once
            //
            if (pTmpBuf == NULL) {
                dwTmpBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                pTmpBuf = (LPTSTR) G_ALLOC(dwTmpBufSize);
                if (pTmpBuf == NULL) {
                    Status = ERROR_OUTOFMEMORY;
                    goto ErrorOut;
                }
            }

            if (pTmpBuf != NULL) {
                dwSize = dwTmpBufSize;
     
                if (bFlag) {
                    Status = PdhTranslateLocaleCounter(
                                    pszCounterPath,
                                    pTmpBuf,
                                    &dwSize);
                }
                else {
                   Status = PdhTranslate009Counter(
                                   pszCounterPath,
                                   pTmpBuf,
                                   &dwSize);
                }

                if (Status == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR) G_REALLOC(pTmpBuf, dwSize);
                    if (pNewBuf == NULL) {
                        Status = ERROR_OUTOFMEMORY;
                        goto ErrorOut;
                    }
                    pTmpBuf = pNewBuf;
                    dwTmpBufSize = dwSize;
    
                    //
                    // Try second time
                    //
                    if (bFlag) {
                        Status = PdhTranslateLocaleCounter(
                                        pszCounterPath,
                                        pTmpBuf,
                                        &dwSize);
                    }
                    else {
                        Status = PdhTranslate009Counter(
                                        pszCounterPath,
                                        pTmpBuf,
                                        &dwSize);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pszCounterPathToAdd = pTmpBuf;
                }
            }

            //
            // Add the translated counter path(it is the original 
            // counter path if translation failed) to the new counter
            // path list
            //

            dwCounterPathLen = lstrlen(pszCounterPathToAdd) + 1;

            dwNewCounterListLen += dwCounterPathLen;

            if (! bNotEnoughBuffer) {
                if ( (dwNewCounterListLen + 1) * sizeof(TCHAR) <= *pdwBufferSize) {
                    //
                    // Set up the copy position
                    //
                    pNextStringPosition = pBuffer + dwNewCounterListLen - dwCounterPathLen;
                    lstrcpy(pNextStringPosition, pszCounterPathToAdd);
                }
                else {
                   bNotEnoughBuffer = TRUE;
                }
            }

            //
            // Continue processing next counter path
            //
            pszCounterPath += lstrlen(pszCounterPath) + 1;
        }

        dwNewCounterListLen ++;
        if (! bNotEnoughBuffer) {
            //
            // Append the terminating 0
            //
            pBuffer[dwNewCounterListLen-1] = 0;
        }
        else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    
        *pdwBufferSize = dwNewCounterListLen * sizeof(TCHAR);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
    }

ErrorOut:
    if (pTmpBuf != NULL) {
        G_FREE(pTmpBuf);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smctrsv.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrsv.h

Abstract:

    This object is used to represent the counter log query components of the
    sysmon log service

--*/

#ifndef _CLASS_SMCOUNTERLOGSERVICE_
#define _CLASS_SMCOUNTERLOGSERVICE_

#include "smlogs.h"


class CSmCounterLogService : public CSmLogService
{
    // constructor/destructor
    public:

                CSmCounterLogService();        
        virtual ~CSmCounterLogService();

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry();

        virtual PSLQUERY    CreateQuery ( const CString& rstrName );
        virtual DWORD       DeleteQuery ( PSLQUERY pQuery );

        virtual CSmCounterLogService* CastToCounterLogService( void ) { return this; };

    protected:

        virtual DWORD       LoadQueries( void );

};

#endif //_CLASS_SMCOUNTERLOGSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smlogcfg.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    smlogcfg.cpp

Abstract:

    Implementation of DLL exports.

--*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Smlogcfgps.mk in the project directory.

#include "StdAfx.h"
#include "InitGuid.h"
#include "compdata.h"
#include "smabout.h"
#include "smlogcfg.h"       // For CLSID_ComponentData
#include "Smlogcfg_i.c"     // For CLSID_ComponentData
#include <ntverp.h>

USE_HANDLE_MACROS("SMLOGCFG(smlogcfg.cpp)")

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ComponentData, CSmLogSnapin)
    OBJECT_ENTRY(CLSID_ExtensionSnapin, CSmLogExtension)
    OBJECT_ENTRY(CLSID_PerformanceAbout, CSmLogAbout)
END_OBJECT_MAP()


LPCTSTR g_cszBasePath   = _T("Software\\Microsoft\\MMC\\SnapIns");
LPCTSTR g_cszBaseNodeTypes  = _T("Software\\Microsoft\\MMC\\NodeTypes");
LPCTSTR g_cszNameString = _T("NameString");
LPCTSTR g_cszNameStringIndirect = _T("NameStringIndirect");
LPCTSTR g_cszProvider   = _T("Provider");
LPCTSTR g_cszVersion    = _T("Version");
LPCTSTR g_cszAbout      = _T("About");
LPCTSTR g_cszStandAlone = _T("StandAlone");
LPCTSTR g_cszNodeType   = _T("NodeType");
LPCTSTR g_cszNodeTypes  = _T("NodeTypes");
LPCTSTR g_cszExtensions = _T("Extensions");
LPCTSTR g_cszNameSpace  = _T("NameSpace");

LPCTSTR g_cszRootNode   = _T("Root Node");
LPCTSTR g_cszCounterLogsChild   = _T("Performance Data Logs Child Under Root Node");
LPCTSTR g_cszTraceLogsChild = _T("System Trace Logs Child Under Root Node");
LPCTSTR g_cszAlertsChild    = _T("Alerts Child Under Root Node");

class CSmLogCfgApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CSmLogCfgApp theApp;

BOOL CSmLogCfgApp::InitInstance()
{
    g_hinst = m_hInstance;               // Store global instance handle
    _Module.Init(ObjectMap, m_hInstance);

    SHFusionInitializeFromModuleID (m_hInstance, 2);
    
    InitializeCriticalSection ( &g_critsectInstallDefaultQueries );
    
    return CWinApp::InitInstance();
}

int CSmLogCfgApp::ExitInstance()
{
    DeleteCriticalSection ( &g_critsectInstallDefaultQueries );
    
    SHFusionUninitialize();
    
    _Module.Term();
    
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // test for snap-in or extension snap-in guid and differentiate the 
    // returned object here before returning (not implemented yet...)
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
STDAPI DllRegisterServer(void)
{
    HKEY hMmcSnapinsKey  = NULL;
    HKEY hMmcNodeTypesKey = NULL;
    HKEY hSmLogMgrParentKey = NULL;
    HKEY hStandAloneKey = NULL;
    HKEY hNodeTypesKey  = NULL;
    HKEY hTempNodeKey   = NULL;
    HKEY hNameSpaceKey  = NULL;
    LONG nErr           = 0;
    TCHAR pBuffer[_MAX_PATH+1];           // NOTE: Use for Provider, Version and module name strings
    size_t nLen;
    CString strName;

    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    //DebugBreak();                  // Uncomment this to step through registration

    // Open the MMC Parent keys
    nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                       g_cszBasePath,
                       &hMmcSnapinsKey
                       );
    if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Open MMC Snapins Key Failed" );
  
    // Create the ID for our ICompnentData Interface
    // The ID was generated for us, because we used a Wizard to create the app.
    // Take the ID for CComponentData in the IDL file.
    //
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // Make sure you change this if you use this code as a starting point!
    // Change other IDs as well below!
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (hMmcSnapinsKey) {
        nErr = RegCreateKey(  
                        hMmcSnapinsKey,
                        GUIDSTR_ComponentData,
                        &hSmLogMgrParentKey
                        );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"CComponentData Key Failed" );
      if (hSmLogMgrParentKey) {

        STANDARD_TRY
            strName.LoadString ( IDS_MMC_DEFAULT_NAME );
        MFC_CATCH_MINIMUM

        if ( strName.IsEmpty() ) {
            DisplayError ( ERROR_OUTOFMEMORY,
                _T("Unable to load snap-in name string.") );
        }

        // This is the name we see when we add the Snap-In to the console
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameString,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(TCHAR)
                          );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set NameString Failed" );

        // This is the indirect name we see when we add the Snap-In to the console.  
        // Added for MUI support.  Use the same name string as for NameString.
        STANDARD_TRY
            ::GetModuleFileName(AfxGetInstanceHandle(), pBuffer, _MAX_PATH);
            strName.Format (_T("@%s,-%d"), pBuffer, IDS_MMC_DEFAULT_NAME );
        MFC_CATCH_MINIMUM

        if ( strName.IsEmpty() ) {
            DisplayError ( ERROR_OUTOFMEMORY,
                _T("Unable to load snap-in indirect name string.") );
        }

        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameStringIndirect,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(TCHAR)
                          );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set NameStringIndirect Failed" );

        // This is the primary node, or class which implements CComponentData
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNodeType,
                          0,
                          REG_SZ,
                          (LPBYTE)GUIDSTR_RootNode,
                          ((lstrlen(GUIDSTR_RootNode)+1) * (DWORD)sizeof(TCHAR))
                          );
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set NodeType Failed" );

        // This is the About box information
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszAbout,
                          0,
                          REG_SZ,
                          (LPBYTE)GUIDSTR_PerformanceAbout,
                          ((lstrlen(GUIDSTR_PerformanceAbout)+1) * (DWORD)sizeof(TCHAR))
                          );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set About Failed" );

        nLen = strlen(VER_COMPANYNAME_STR);
    #ifdef UNICODE
        nLen = mbstowcs(pBuffer, VER_COMPANYNAME_STR, nLen);
        pBuffer[nLen] = UNICODE_NULL;
    #else
        strcpy(pBuffer, VER_COMPANYNAME_STR);
        pBuffer[nLen] = ANSI_NULL;
    #endif
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszProvider,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(TCHAR))
                        );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set Provider Failed" );

        nLen = strlen(VER_PRODUCTVERSION_STR);
    #ifdef UNICODE
        nLen = mbstowcs(pBuffer, VER_PRODUCTVERSION_STR, nLen);
        pBuffer[nLen] = UNICODE_NULL;
    #else
        strcpy(pBuffer, VER_PRODUCTVERSION_STR);
        pBuffer[nLen] = ANSI_NULL;
    #endif
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszVersion,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(TCHAR))
                        );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set Version Failed" );

        // We are a stand alone snapin, so set the key for this
        nErr = RegCreateKey( 
                hSmLogMgrParentKey, 
                g_cszStandAlone, 
                &hStandAloneKey);
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Create StandAlone Key Failed" );

        if (hStandAloneKey) {
          // StandAlone has no children, so close it
          nErr = RegCloseKey( hStandAloneKey );              
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Close StandAlone Failed" );
        }

        // Set the node types that appear in our snapin
        nErr = RegCreateKey ( 
                hSmLogMgrParentKey, 
                g_cszNodeTypes, 
                &hNodeTypesKey );
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Create NodeTypes Key Failed" );

        if (hNodeTypesKey) {
          // Here is our root node.  Used uuidgen to get it
          nErr = RegCreateKey( hNodeTypesKey,
                       GUIDSTR_RootNode,
                       &hTempNodeKey
                       );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Create RootNode Key Failed" );

          if (hTempNodeKey) {
            nErr = RegSetValueEx(   hTempNodeKey,
                        NULL,
                        0,
                        REG_SZ,
                        (LPBYTE)g_cszRootNode,
                        (DWORD)sizeof(g_cszRootNode)
                            );
            if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(), L"Set Root Node String Failed" );

            nErr = RegCloseKey( hTempNodeKey ); // Close it for handle reuse

            if( ERROR_SUCCESS != nErr )
               DisplayError( GetLastError(), L"Close RootNode Failed" );
          }

          // Here are our child nodes under the root node. Used uuidgen
          // to get them for Counter Logs
          hTempNodeKey = NULL;
          nErr = RegCreateKey(  hNodeTypesKey,
                        GUIDSTR_CounterMainNode,
                        &hTempNodeKey
                        );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(),
                L"Create Child Performance Data Logs Node Key Failed" );

            if (hTempNodeKey) {
              nErr = RegSetValueEx( hTempNodeKey,
                          NULL,
                          0,
                          REG_SZ,
                          (LPBYTE)g_cszCounterLogsChild,
                          (DWORD)sizeof(g_cszCounterLogsChild)
                          );
              if( ERROR_SUCCESS != nErr )
                 DisplayError( GetLastError(),
                    L"Set Performance Data Logs Child Node String Failed" );

              nErr = RegCloseKey( hTempNodeKey );  // Close it for handle reuse
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close Performance Data Logs Child Node Key Failed" );
            }

            // System Trace Logs
            hTempNodeKey = NULL;
            nErr = RegCreateKey(    hNodeTypesKey,
                        GUIDSTR_TraceMainNode,
                        &hTempNodeKey
                        );
            if( ERROR_SUCCESS != nErr )
              DisplayError( GetLastError(),
                L"Create Child System Trace Logs Node Key Failed" );

            if (hTempNodeKey) {
              nErr = RegSetValueEx( hTempNodeKey,
                          NULL,
                          0,
                          REG_SZ,
                          (LPBYTE)g_cszTraceLogsChild,
                          (DWORD)sizeof(g_cszTraceLogsChild)
                          );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Set System Trace Logs Child Node String Failed" );

              nErr = RegCloseKey( hTempNodeKey );  // Close it for handle reuse
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close System Trace Logs Child Node Key Failed" );
            }

            // Alerts
            hTempNodeKey = NULL;
            nErr = RegCreateKey(hNodeTypesKey,
                        GUIDSTR_AlertMainNode,
                        &hTempNodeKey
                        );
            if( ERROR_SUCCESS != nErr )
              DisplayError( GetLastError(),
                L"Create Child Alerts Node Key Failed" );

            if (hTempNodeKey) {
              nErr = RegSetValueEx( hTempNodeKey,
                          NULL,
                          0,
                          REG_SZ,
                          (LPBYTE)g_cszAlertsChild,
                          (DWORD)sizeof(g_cszAlertsChild)
                          );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Set Alerts Child Node String Failed" );

              nErr = RegCloseKey( hTempNodeKey );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close Alerts Child Node Key Failed" );
            }

            nErr = RegCloseKey( hNodeTypesKey  );
            if( ERROR_SUCCESS != nErr )
              DisplayError( GetLastError(), L"Close Node Types Key Failed" );
        }

        // close the standalone snapin GUID key
        nErr = RegCloseKey( hSmLogMgrParentKey );
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Close SmLogManager GUID Key Failed" );
      }

      // register the extension snap-in with the MMC
      hSmLogMgrParentKey = NULL;
      nErr = RegCreateKey(  hMmcSnapinsKey,
                        GUIDSTR_SnapInExt,
                        &hSmLogMgrParentKey
                        );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Snapin Extension Key creation Failed" );

      STANDARD_TRY
          strName.LoadString ( IDS_MMC_DEFAULT_EXT_NAME );
      MFC_CATCH_MINIMUM

      if ( strName.IsEmpty() ) {
          DisplayError ( ERROR_OUTOFMEMORY,
            _T("Unable to load snap-in extension name string.") );
      }

      if (hSmLogMgrParentKey) {
          // This is the name we see when we add the snap-in extension
          nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameString,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(TCHAR)
                          );
          strName.ReleaseBuffer();
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Extension NameString Failed" );

          // This is the name we see when we add the snap-in extension.  MUI support.
          // Use the same name string as for NameString;
            STANDARD_TRY
                ::GetModuleFileName(AfxGetInstanceHandle(), pBuffer, _MAX_PATH);
                strName.Format (_T("@%s,-%d"), pBuffer, IDS_MMC_DEFAULT_EXT_NAME );
            MFC_CATCH_MINIMUM

            if ( strName.IsEmpty() ) {
                DisplayError ( ERROR_OUTOFMEMORY,
                    _T("Unable to load extension indirect name string.") );
            }

            nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameStringIndirect,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(TCHAR)
                          );
            strName.ReleaseBuffer();
            if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(), L"Set Extension NameStringIndirect Failed" );

            // This is the Extension About box information

            nErr = RegSetValueEx( 
                    hSmLogMgrParentKey,
                    g_cszAbout,
                    0,
                    REG_SZ,
                    (LPBYTE)GUIDSTR_PerformanceAbout,
                    ((lstrlen(GUIDSTR_PerformanceAbout)+1) * (DWORD)sizeof(TCHAR))
                    );

          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Extension About Failed" );

          nLen = strlen(VER_COMPANYNAME_STR);
    #ifdef UNICODE
          nLen = mbstowcs(pBuffer, VER_COMPANYNAME_STR, nLen);
          pBuffer[nLen] = UNICODE_NULL;
    #else
          strcpy(pBuffer, VER_COMPANYNAME_STR);
          pBuffer[nLen] = ANSI_NULL;
    #endif
          nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszProvider,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(TCHAR))
                        );

          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Provider Failed" );

          nLen = strlen(VER_PRODUCTVERSION_STR);
    #ifdef UNICODE
          nLen = mbstowcs(pBuffer, VER_PRODUCTVERSION_STR, nLen);
          pBuffer[nLen] = UNICODE_NULL;
    #else
          strcpy(pBuffer, VER_PRODUCTVERSION_STR);
          pBuffer[nLen] = ANSI_NULL;
    #endif
          nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszVersion,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(TCHAR))
                        );

          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Version Failed" );

    // close the main keys
          nErr = RegCloseKey( hSmLogMgrParentKey );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Close Snapin Extension Key Failed");
      }

      // register this as a "My Computer"-"System Tools" snapin extension

      nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                       g_cszBaseNodeTypes,
                       &hMmcNodeTypesKey
                       );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Open MMC NodeTypes Key Failed" );

      // create/open the GUID of the System Tools Node of the My Computer snap-in

      if (hMmcNodeTypesKey) {
          nErr = RegCreateKey ( hMmcNodeTypesKey,
                       lstruuidNodetypeSystemTools,
                       &hNodeTypesKey
                       );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(),
                L"Create/open System Tools GUID Key Failed" );

          if (hNodeTypesKey) {
              hTempNodeKey = NULL;
              nErr = RegCreateKey ( hNodeTypesKey,
                       g_cszExtensions,
                       &hTempNodeKey
                       );

              if( ERROR_SUCCESS != nErr )
                    DisplayError( 
                        GetLastError(),
                        L"Create/open System Tools Extensions Key Failed" );

              if (hTempNodeKey) {
                    nErr = RegCreateKey ( 
                        hTempNodeKey,
                        g_cszNameSpace,
                        &hNameSpaceKey
                        );

                if( ERROR_SUCCESS != nErr )
                  DisplayError( GetLastError(),
                      L"Create/open System Tools NameSpace Key Failed" );

                if (hNameSpaceKey) {
                    nErr = RegSetValueEx( hNameSpaceKey,
                          GUIDSTR_SnapInExt,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(TCHAR)
                          );
                    strName.ReleaseBuffer();
                    if( ERROR_SUCCESS != nErr ) {
                      DisplayError( GetLastError(),
                        L"Set Extension NameString Failed" );
                      DisplayError( GetLastError(),
                        L"Set Snapin Extension NameString Failed" );
                    }

                    nErr = RegCloseKey( hNameSpaceKey  );
                    if( ERROR_SUCCESS != nErr )
                      DisplayError( GetLastError(),
                          L"Close NameSpace Key Failed" );
                }

                nErr = RegCloseKey( hTempNodeKey  );
                if( ERROR_SUCCESS != nErr )
                  DisplayError( GetLastError(), L"Close Extension Key Failed" );
              }

              nErr = RegCloseKey( hNodeTypesKey  );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close My Computer System GUID Key Failed" );
          }

          nErr = RegCloseKey( hMmcNodeTypesKey );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Close MMC NodeTypes Key Failed" );
      }
      nErr = RegCloseKey( hMmcSnapinsKey );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close MMC Snapins Key Failed" );
    }

    // Register extension Snap in
    nErr = _Module.UpdateRegistryFromResource(IDR_EXTENSION, TRUE);
    // Registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
    }

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
  HKEY hMmcSnapinsKey  = NULL;          // MMC parent key
  HKEY hSmLogMgrParentKey = NULL;          // Our Snap-In key  - has children
  HKEY hNodeTypesKey  = NULL;          // Our NodeType key - has children
  HKEY hSysToolsNode = NULL;
  HKEY hExtension = NULL;
  HKEY hNameSpace = NULL;
  LONG nErr           = 0;

  // DebugBreak();                       // Uncomment this to step through UnRegister

  // Open the MMC parent key
  nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                     g_cszBasePath,
                     &hMmcSnapinsKey
                   );
  if( ERROR_SUCCESS != nErr )
    DisplayError( GetLastError(), L"Open MMC Parent Key Failed"  ); 

  // Open our Parent key
  nErr = RegOpenKey( hMmcSnapinsKey,
                     GUIDSTR_ComponentData,
                     &hSmLogMgrParentKey
                   );
  if( ERROR_SUCCESS != nErr )
    DisplayError( GetLastError(), L"Open Disk Parent Key Failed" );
  
  // Now open the NodeTypes key
  nErr = RegOpenKey( hSmLogMgrParentKey,       // Handle of parent key
                     g_cszNodeTypes,         // Name of key to open
                     &hNodeTypesKey        // Handle to newly opened key
                   );
  if( ERROR_SUCCESS != nErr )
     DisplayError( GetLastError(), L"Open NodeTypes Key Failed"  );

  if (hNodeTypesKey) {
      // Delete the root node key 
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_RootNode );  
      if( ERROR_SUCCESS != nErr )
         DisplayError( GetLastError(), L"Delete Root Node Key Failed"  );

      // Delete the child node key
      // *** From Beta 2
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_MainNode );  

      // Delete the child node keys
      // Counter logs
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_CounterMainNode );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Performance Logs and Alerts Child Node Key Failed"  );
  
      // System Trace Logs
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_TraceMainNode );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete System Trace Logs Child Node Key Failed"  );
  
      // Alerts
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_AlertMainNode );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Alerts Child Node Key Failed"  );
  
      // Close the node type key so we can delete it
      nErr = RegCloseKey( hNodeTypesKey ); 
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close NodeTypes Key failed"  );
  }

  // Delete the NodeTypes key
  if (hSmLogMgrParentKey) {
      nErr = RegDeleteKey( hSmLogMgrParentKey, L"NodeTypes" );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete NodeTypes Key failed"  );
  
      // StandAlone key has no children so we can delete it now
      nErr = RegDeleteKey( 
                hSmLogMgrParentKey, 
                g_cszStandAlone );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete StandAlone Key Failed"  ); 
  
      // Close our Parent Key
      nErr = RegCloseKey( hSmLogMgrParentKey );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close Disk Parent Key Failed"  ); 
  }

  if (hMmcSnapinsKey) {
      // Now we can delete our Snap-In key since the children are gone
      nErr = RegDeleteKey( hMmcSnapinsKey, GUIDSTR_ComponentData );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Performance Logs and Alerts GUID Key Failed"  ); 

      // Now we can delete our Snap-In Extension key 
      nErr = RegDeleteKey( hMmcSnapinsKey, GUIDSTR_SnapInExt);  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Performance Logs and Alerts GUID Key Failed"  ); 

      nErr = RegCloseKey( hMmcSnapinsKey );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close MMC Parent Key Failed"  ); 
  }

  // delete snap-in extension entry

  hNodeTypesKey = NULL;
  // Open the MMC parent key
  nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                     g_cszBaseNodeTypes,
                     &hNodeTypesKey
                   );
  if( ERROR_SUCCESS != nErr )
    DisplayError( GetLastError(), L"Open of MMC NodeTypes Key Failed"  ); 

  if (hNodeTypesKey) {
      hSysToolsNode = NULL;
      nErr = RegOpenKey (hNodeTypesKey,
                    lstruuidNodetypeSystemTools,
                    &hSysToolsNode
                    );

      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(),
            L"Open of My Computer System Tools Key Failed"  ); 

      if (hSysToolsNode) {
          hExtension = NULL;
          nErr = RegOpenKey (hSysToolsNode,
                    g_cszExtensions,
                    &hExtension
                    );

         if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Open of Extensions Key Failed"  ); 

         if (hExtension) {
              hNameSpace = NULL;
              nErr = RegOpenKey (hExtension,
                    g_cszNameSpace,
                    &hNameSpace
                    );

              if( ERROR_SUCCESS != nErr )
                  DisplayError( GetLastError(),
                    L"Open of Name Space Key Failed"  ); 

              if (hNameSpace) {
                  nErr = RegDeleteValue (hNameSpace, GUIDSTR_SnapInExt);

                  if( ERROR_SUCCESS != nErr )
                      DisplayError( GetLastError(),
                            L"Unable to remove the Snap-in Ext. GUID"  ); 

                  // close keys
                  nErr = RegCloseKey( hNameSpace );
                  if( ERROR_SUCCESS != nErr )
                      DisplayError( GetLastError(),
                        L"Close NameSpace Key Failed"  ); 
              }

              nErr = RegCloseKey( hExtension);
              if( ERROR_SUCCESS != nErr )
                  DisplayError(GetLastError(), L"Close Extension Key Failed"); 
        }

        nErr = RegCloseKey( hSysToolsNode );
        if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(),
                L"Close My Computer System Tools Key Failed"  ); 
      }

      nErr = RegCloseKey( hNodeTypesKey);
      if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Close MMC Node Types Key Failed"  ); 
  }

  _Module.UnregisterServer();
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smlogqry.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogqry.cpp

Abstract:

    Implementation of the CSmLogQuery base class. This object 
    is used to represent performance data log queries (a.k.a.
    sysmon log queries).

--*/

#include "Stdafx.h"
#include <pdh.h>            // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhmsg.h>         // for PDH status values
#include <pdhp.h>           // for PLA methods
#include "ipropbag.h"
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smproppg.h"
#include "smlogqry.h"

USE_HANDLE_MACROS("SMLOGCFG(smlogqry.cpp)");

#define  DEFAULT_LOG_FILE_SERIAL_NUMBER ((DWORD)0x00000001)
#define  DEFAULT_LOG_FILE_MAX_SIZE      ((DWORD)-1)
#define  DEFAULT_CTR_LOG_FILE_TYPE      (SLF_BIN_FILE)
#define  DEFAULT_TRACE_LOG_FILE_TYPE    (SLF_SEQ_TRACE_FILE)
#define  DEFAULT_LOG_FILE_AUTO_FORMAT   SLF_NAME_NNNNNN
#define  DEFAULT_CURRENT_STATE          SLQ_QUERY_STOPPED
#define  DEFAULT_EXECUTE_ONLY           0
#define  DEFAULT_EOF_COMMAND_FILE       L""
#define  DEFAULT_RESTART_VALUE         ((DWORD)0)

#define  DEFAULT_COMMENT            L""
#define  DEFAULT_SQL_LOG_BASE_NAME  L""

#pragma warning ( disable : 4201)

typedef union {                        
    struct {
        SHORT      iMajor;     
        SHORT      iMinor;     
    }; 
    DWORD          dwVersion;      
} SMONCTRL_VERSION_DATA;

#pragma warning ( default : 4201 )


#define SMONCTRL_MAJ_VERSION    3
#define SMONCTRL_MIN_VERSION    3

DWORD   g_dwRealTimeQuery = DATA_SOURCE_REGISTRY;
const   CString CSmLogQuery::cstrEmpty;

//
//  Constructor
CSmLogQuery::CSmLogQuery( CSmLogService* pLogService )
:   m_pLogService ( pLogService ),
    m_bReadOnly ( FALSE ),
    m_bIsModified ( FALSE ),
    m_bIsNew ( FALSE ),
    m_bExecuteOnly ( FALSE ),
    m_pActivePropPage ( NULL ),
    mr_dwCurrentState ( SLQ_QUERY_STOPPED ),
    mr_dwMaxSize ( 0 ),
    mr_dwFileSizeUnits ( 0 ),
    mr_dwAppendMode ( 0 ),
    mr_dwLogAutoFormat ( 0 ),
    mr_dwLogFileType ( 0 )
{
    // initialize member variables
    memset (&mr_stiStart, 0, sizeof(mr_stiStart));
    memset (&mr_stiStop, 0, sizeof(mr_stiStop));
    memset (&m_PropData.stiSampleTime, 0, sizeof(m_PropData.stiSampleTime));
    m_PropData.dwMaxFileSize = 0;
    m_PropData.dwLogFileType = 0;
    m_PropData.dwSuffix = 0;
    m_PropData.dwSerialNumber = 0;
    mr_dwRealTimeQuery = g_dwRealTimeQuery;
    m_fDirtyPassword = PASSWORD_CLEAN;

    // All CString variables are empty on construction

    return;
}

//
//  Destructor
CSmLogQuery::~CSmLogQuery()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_hKeyQuery );
    ASSERT ( m_strName.IsEmpty() );
    ASSERT ( mr_strComment.IsEmpty() );
    ASSERT ( mr_strCommentIndirect.IsEmpty() );
    ASSERT ( mr_strBaseFileName.IsEmpty() );
    ASSERT ( mr_strBaseFileNameIndirect.IsEmpty() );
    ASSERT ( mr_strSqlName.IsEmpty() );
    ASSERT ( mr_strDefaultDirectory.IsEmpty() );
    return;
}
//
//  helper functions
//
LONG
CSmLogQuery::WriteRegistryStringValue (
    HKEY    hKey,
    UINT    uiValueName,
    DWORD   dwType,
    LPCTSTR pszBuffer,
    LPDWORD pdwBufSize
)
//  writes the contents of pszBuffer to szValue under hKey
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwLclSize;
    CONST BYTE *pLclBuffer = NULL;
    CString strValueName;

    ResourceStateManager   rsm;

    if ( NULL != hKey ) {

        MFC_TRY
            strValueName.LoadString ( uiValueName );
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {

            ASSERT ((dwType == REG_SZ) || 
                    (dwType == REG_MULTI_SZ) ||
                    (dwType == REG_EXPAND_SZ));

            if ( NULL == pszBuffer ) {
                // substitute an empty string
                pLclBuffer = (CONST BYTE *)L"\0";
                dwLclSize = sizeof(WCHAR);
            } else {
                // use args passed in
                pLclBuffer = (CONST BYTE *)pszBuffer;

                if ( NULL != pdwBufSize ) {
                    if( 0 == *pdwBufSize ){
                        dwLclSize = lstrlen( pszBuffer );
                        if ( 0 < dwLclSize ) {
                            dwLclSize *= sizeof(WCHAR);
                        } else {
                            dwLclSize = sizeof(WCHAR);
                        }
                    } else {
                        dwLclSize = *pdwBufSize;
                    }
                } else {
                    dwLclSize = lstrlen( pszBuffer );
                    dwLclSize *= sizeof(WCHAR);
                }
            }

            dwStatus = RegSetValueEx (hKey, 
                strValueName, 
                0L,
                dwType,
                (CONST BYTE *)pLclBuffer,
                dwLclSize); 
        } 
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

LONG
CSmLogQuery::WriteRegistryDwordValue (
    HKEY     hKey,
    UINT     uiValueName,
    LPDWORD  pdwValue,
    DWORD    dwType   
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwSize = sizeof(DWORD);
    CString strValueName;
    ResourceStateManager   rsm;

    if ( NULL != pdwValue && NULL != hKey ) {

        MFC_TRY
            strValueName.LoadString ( uiValueName );
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {

            ASSERT ((dwType == REG_DWORD) || 
                    (dwType == REG_BINARY));
    
            dwStatus = RegSetValueEx (
                hKey, strValueName, 0L,
                dwType,
                (CONST BYTE *)pdwValue,
                dwSize);
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

LONG
CSmLogQuery::WriteRegistrySlqTime (
    HKEY     hKey,
    UINT     uiValueName,
    PSLQ_TIME_INFO  pSlqTime
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(SLQ_TIME_INFO);
    CString strValueName;

    ResourceStateManager   rsm;

    if ( NULL != pSlqTime && NULL != hKey ) {
        
        MFC_TRY
            strValueName.LoadString ( uiValueName );
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {

            dwStatus = RegSetValueEx (
                hKey, strValueName, 0L,
                REG_BINARY,
                (CONST BYTE *)pSlqTime,
                dwValue);
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}


LONG
CSmLogQuery::ReadRegistryStringValue (
    HKEY     hKey,
    UINT     uiValueName,
    LPCTSTR  szDefault,
    LPTSTR   *pszBuffer,
    LPDWORD  pdwBufferSize
)
//
//  reads the string value from key (name based on resource 
//  uiValueName) under hKey and
//  frees any existing buffer referenced by szInBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer (in bytes) 
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    TCHAR*  szNewStringBuffer = NULL;
    CString strValueName;

    ResourceStateManager   rsm;

    if ( NULL != hKey ) {

        MFC_TRY
            strValueName.LoadString ( uiValueName );
        MFC_CATCH_DWSTATUS;

        ASSERT (!strValueName.IsEmpty());

        if ( ERROR_SUCCESS == dwStatus && hKey != NULL) {
            // then there should be something to read
            // find out the size of the required buffer
            dwStatus = RegQueryValueExW (
                hKey,
                strValueName,
                NULL,
                &dwType,
                NULL,
                &dwBufferSize);
            if (dwStatus == ERROR_SUCCESS) {
                // NULL character size is 2 bytes
                if (dwBufferSize > 2) {
                    // then there's something to read
                    MFC_TRY
                        szNewStringBuffer = new TCHAR[dwBufferSize/sizeof(TCHAR)];
                        dwType = 0;
                        dwStatus = RegQueryValueExW (
                            hKey,
                            strValueName,
                            NULL,
                            &dwType,
                            (LPBYTE)szNewStringBuffer,
                            &dwBufferSize);
                    MFC_CATCH_DWSTATUS
                } else {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
            } else {
                // unable to read buffer
                // dwStatus has error
            }
        } else {
            // null key
            dwStatus = ERROR_BADKEY;
        }

        if (dwStatus != ERROR_SUCCESS) {
            if (szNewStringBuffer != NULL) {
                delete (szNewStringBuffer);
                szNewStringBuffer = NULL;
            }
            // apply default
            if (szDefault != NULL) {
                dwBufferSize = lstrlen(szDefault) + 1;
                dwBufferSize *= sizeof (TCHAR);
                MFC_TRY
                    szNewStringBuffer = new TCHAR[dwBufferSize];
                    lstrcpy (
                        szNewStringBuffer,
                        szDefault);
                    dwStatus = ERROR_SUCCESS;
                MFC_CATCH_DWSTATUS
            } else {
                // no default so no data returned
            }
        }

        if (dwStatus == ERROR_SUCCESS) {
            // then delete the old buffer and replace it with 
            // the new one
            if ( NULL != *pszBuffer ) {
                delete (*pszBuffer );
            }
            *pszBuffer = szNewStringBuffer;
            if ( NULL != pdwBufferSize ) {
                *pdwBufferSize = dwBufferSize;
            }
        } else {
            // if error then delete the buffer
            if (szNewStringBuffer != NULL) {
                delete (szNewStringBuffer);
            }
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}   

LONG
CSmLogQuery::ReadRegistrySlqTime (
    HKEY     hKey,
    UINT     uiValueName,
    PSLQ_TIME_INFO pstiDefault,
    PSLQ_TIME_INFO pSlqValue
)
//
//  reads the time value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;

    SLQ_TIME_INFO   slqLocal;
    CString strValueName;

    ResourceStateManager   rsm;

    if ( NULL != pSlqValue && NULL != hKey ) {

        MFC_TRY
            strValueName.LoadString ( uiValueName );
        MFC_CATCH_DWSTATUS;

        ASSERT (!strValueName.IsEmpty());

        if ( ERROR_SUCCESS == dwStatus ) {

            memset (&slqLocal, 0, sizeof(SLQ_TIME_INFO));
    
            if (hKey != NULL) {
                // then there should be something to read
                // find out the size of the required buffer
                dwStatus = RegQueryValueExW (
                    hKey,
                    strValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwBufferSize);
                if (dwStatus == ERROR_SUCCESS) {
                    if ((dwBufferSize == sizeof(SLQ_TIME_INFO)) && (dwType == REG_BINARY)) {
                        // then there's something to read
                        dwType = 0;
                        dwStatus = RegQueryValueExW (
                            hKey,
                            strValueName,
                            NULL,
                            &dwType,
                            (LPBYTE)&slqLocal,
                            &dwBufferSize);
                    } else {
                        // nothing to read                
                        dwStatus = ERROR_NO_DATA;
                    }
                } else {
                    // unable to read buffer
                    // dwStatus has error
                }
            } else {
                // null key
                dwStatus = ERROR_BADKEY;
            }

            if (dwStatus == ERROR_SUCCESS) {
                *pSlqValue = slqLocal;
            } else {
                // apply default if it exists
                if (pstiDefault != NULL) {
                    *pSlqValue = *pstiDefault;
                    dwStatus = ERROR_SUCCESS;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

LONG
CSmLogQuery::ReadRegistryDwordValue (
    HKEY    hKey,
    UINT    uiValueName,
    DWORD   dwDefault,
    LPDWORD pdwValue
)
//
//  reads the DWORD value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    DWORD   dwRegValue = 0;
    CString strValueName;

    ResourceStateManager   rsm;

    if ( NULL != pdwValue && NULL != hKey ) {

        MFC_TRY
            strValueName.LoadString ( uiValueName );
        MFC_CATCH_DWSTATUS;

        ASSERT (!strValueName.IsEmpty());

        if ( ERROR_SUCCESS == dwStatus ) {
            if (hKey != NULL) {
                // then there should be something to read
                // find out the size of the required buffer
                dwStatus = RegQueryValueExW (
                    hKey,
                    strValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwBufferSize);
                if (dwStatus == ERROR_SUCCESS) {
                    if ( (dwBufferSize == sizeof(DWORD)) 
                        && ( (REG_DWORD == dwType) || ( REG_BINARY == dwType) ) ) {
                        // then there's something to read
                        dwType = 0;
                        dwStatus = RegQueryValueExW (
                            hKey,
                            strValueName,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwRegValue,
                            &dwBufferSize);
                    } else {
                        // nothing to read                
                        dwStatus = ERROR_NO_DATA;
                    }
                } else {
                    // unable to read buffer
                    // dwStatus has error
                }
            } else {
                // null key
                dwStatus = ERROR_BADKEY;
            }

            if (dwStatus == ERROR_SUCCESS) {
                *pdwValue = dwRegValue;
            } else {
                *pdwValue = dwDefault;
                dwStatus = ERROR_SUCCESS;
            }
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}


HRESULT 
CSmLogQuery::StringToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    const CString& rstrData )
{
    HRESULT hr = NOERROR;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );
        hr = StringToPropertyBag ( pPropBag, strPropName, rstrData );
    MFC_CATCH_HR
    
    return hr;
}

typedef struct _HTML_ENTITIES {
    LPTSTR szHTML;
    LPTSTR szEntity;
} HTML_ENTITIES;

HTML_ENTITIES g_htmlentities[] = {
    _T("&"),    _T("&amp;"),
    _T("\""),   _T("&quot;"),
    _T("<"),    _T("&lt;"),
    _T(">"),    _T("&gt;"),
    NULL, NULL
};

HRESULT 
CSmLogQuery::StringToPropertyBag (
    IPropertyBag* pIPropBag, 
    const CString& rstrPropName, 
    const CString& rstrData )
{
    VARIANT vValue;
    HRESULT hr = NOERROR;
    LPTSTR  szTrans = NULL;
    BOOL    bAllocated = FALSE;
    int     i;
    ULONG   lSize = 0;
    LPTSTR  szScan = NULL;


    if ( NULL != pIPropBag ) {
        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        vValue.bstrVal = NULL;

        if ( !rstrData.IsEmpty() ) {
            MFC_TRY
                for( i=0 ;g_htmlentities[i].szHTML != NULL; i++ ){
                    // rstrData is const
                    szScan = ((CString)rstrData).GetBuffer ( rstrData.GetLength() );
                    while( *szScan != _T('\0') ){
                        if( *szScan == *g_htmlentities[i].szHTML ){
                            lSize += (6*sizeof(TCHAR));
                        }
                        szScan++;
                    }
                    ((CString)rstrData).ReleaseBuffer();
                }
                if( lSize > 0 ){
                    szTrans = (LPTSTR)malloc(lSize);
                    if( szTrans != NULL ){
                        bAllocated = TRUE;
                        ZeroMemory( szTrans, lSize );
                        szScan = ((CString)rstrData).GetBuffer ( rstrData.GetLength() );
                        while( *szScan != _T('\0') ){
                            BOOL bEntity = FALSE;
                            for( i=0; g_htmlentities[i].szHTML != NULL; i++ ){
                                if( *szScan == *g_htmlentities[i].szHTML ){
                                    bEntity = TRUE;
                                    _tcscat( szTrans, g_htmlentities[i].szEntity );
                                    break;
                                }
                            }
                            if( !bEntity ){
                                _tcsncat( szTrans, szScan, 1 );
                            }
                            szScan++;
                        }
                    }
                }else{
                    szTrans = ((CString)rstrData).GetBuffer ( rstrData.GetLength() );
                }

                vValue.bstrVal = ::SysAllocString ( T2W( szTrans ) );
                hr = pIPropBag->Write ( rstrPropName, &vValue );    
                VariantClear ( &vValue );
                ((CString)rstrData).ReleaseBuffer();
            MFC_CATCH_HR
        } else {
            hr = pIPropBag->Write(rstrPropName, &vValue );    
        }
    }
    if( NULL != szTrans && bAllocated ){
        free( szTrans );
    }
    return hr;
}

HRESULT 
CSmLogQuery::DwordToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    DWORD dwData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    strPropName.LoadString ( uiPropName );

    hr = DwordToPropertyBag (
            pPropBag,
            strPropName,
            dwData );

    return hr;
}
    
HRESULT 
CSmLogQuery::DwordToPropertyBag (
    IPropertyBag* pPropBag, 
    const CString& rstrPropName, 
    DWORD dwData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_I4;
    vValue.lVal = (INT)dwData;

    hr = pPropBag->Write(rstrPropName, &vValue );

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
CSmLogQuery::DoubleToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    DOUBLE dData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );

        hr = DoubleToPropertyBag (
                pPropBag,
                strPropName,
                dData );
    MFC_CATCH_HR

    return hr;
}

HRESULT 
CSmLogQuery::DoubleToPropertyBag (
    IPropertyBag* pPropBag, 
    const CString& rstrPropName, 
    DOUBLE dData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_R8;
    vValue.dblVal = dData;

    hr = pPropBag->Write(rstrPropName, &vValue );

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
CSmLogQuery::FloatToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    FLOAT fData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );

        hr = FloatToPropertyBag (
                pPropBag,
                strPropName,
                fData );
    MFC_CATCH_HR

    return hr;
}

HRESULT 
CSmLogQuery::FloatToPropertyBag (
    IPropertyBag* pPropBag, 
    const CString& rstrPropName, 
    FLOAT fData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_R4;
    vValue.fltVal = fData;

    hr = pPropBag->Write(rstrPropName, &vValue );

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
CSmLogQuery::LLTimeToPropertyBag (
    IPropertyBag* pIPropBag, 
    UINT uiPropName,
    LONGLONG& rllData )
{
    HRESULT hr;
    VARIANT vValue;
    CString strPropName;

    ResourceStateManager rsm;
    
    MFC_TRY
        strPropName.LoadString ( uiPropName );

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        if ( LLTimeToVariantDate ( rllData, &vValue.date ) ) {

            hr = pIPropBag->Write(strPropName, &vValue );

            VariantClear ( &vValue );
    
        } else { 
            hr = E_FAIL;
        }
    MFC_CATCH_HR

    return hr;
}

HRESULT 
CSmLogQuery::SlqTimeToPropertyBag (
    IPropertyBag* pPropBag, 
    DWORD dwFlags, 
    PSLQ_TIME_INFO pSlqData )
{
    HRESULT hr = NOERROR;

    ASSERT ( NULL != pSlqData );

    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:
            ASSERT ( SLQ_TT_TTYPE_START == pSlqData->wTimeType );

            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_START_MODE, pSlqData->dwAutoMode );
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                ASSERT ( SLQ_TT_DTYPE_DATETIME == pSlqData->wDataType );
                hr = LLTimeToPropertyBag ( pPropBag, IDS_HTML_START_AT_TIME, pSlqData->llDateTime );
            }
            
            break;

        case SLQ_TT_TTYPE_STOP:
            ASSERT ( SLQ_TT_TTYPE_STOP == pSlqData->wTimeType );

            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_STOP_MODE, pSlqData->dwAutoMode );
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                ASSERT ( SLQ_TT_DTYPE_DATETIME == pSlqData->wDataType );
                hr = LLTimeToPropertyBag ( pPropBag, IDS_HTML_STOP_AT_TIME, pSlqData->llDateTime );
            } else if ( SLQ_AUTO_MODE_AFTER == pSlqData->dwAutoMode ) {
                ASSERT ( SLQ_TT_DTYPE_UNITS == pSlqData->wDataType );
                hr = DwordToPropertyBag ( 
                        pPropBag, 
                        IDS_HTML_STOP_AFTER_UNIT_TYPE, 
                        pSlqData->dwUnitType );
                hr = DwordToPropertyBag ( 
                        pPropBag, 
                        IDS_HTML_STOP_AFTER_VALUE, 
                        pSlqData->dwValue );
            }
            
            break;
            
        case SLQ_TT_TTYPE_SAMPLE:
        {
            LONGLONG    llMillisecondSampleInt;
            FLOAT fSampleIntSeconds;
            
            ASSERT ( SLQ_TT_TTYPE_SAMPLE == pSlqData->wTimeType );
            ASSERT ( SLQ_TT_DTYPE_UNITS == pSlqData->wDataType );
//            ASSERT ( SLQ_AUTO_MODE_AFTER == pSlqData->dwAutoMode );

            // Write best approximation of sample time to Sysmon property.
            TimeInfoToMilliseconds ( pSlqData, &llMillisecondSampleInt );
                
            // Ensure that the millisecond sample interval fits in a DWORD.
            ASSERT ( llMillisecondSampleInt < ULONG_MAX );

            fSampleIntSeconds = (FLOAT)(llMillisecondSampleInt / 1000);
            hr = FloatToPropertyBag ( 
                    pPropBag, 
                    IDS_HTML_SYSMON_UPDATEINTERVAL, 
                    fSampleIntSeconds );

            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SAMPLE_INT_UNIT_TYPE, pSlqData->dwUnitType );
            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SAMPLE_INT_VALUE, pSlqData->dwValue );
            break;
        }
        // Restart mode stored as a single DWORD
        case SLQ_TT_TTYPE_RESTART:
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

HRESULT 
CSmLogQuery::StringFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    const CString& rstrDefault,
    LPTSTR   *pszBuffer,
    LPDWORD  pdwLength )
{
    HRESULT hr;
    CString strPropName;
    ResourceStateManager rsm;

//
//  reads the string value from property bag and
//  frees any existing buffer referenced by szData, 
//  then allocates a new buffer returning it with the 
//  string value read from the property bag and the size of the
//  buffer (in bytes) 
//

    MFC_TRY
        strPropName.LoadString ( uiPropName );

        hr = StringFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strPropName,
                rstrDefault,
                pszBuffer,
                pdwLength );
    MFC_CATCH_HR
    return hr;
}

HRESULT 
CSmLogQuery::StringFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    const CString& rstrDefault,
    LPTSTR   *pszBuffer,
    LPDWORD  pdwLength )
{
    VARIANT vValue;
    HRESULT hr;
    DWORD   dwNewBufSize = 0;
    LPTSTR  szNewStringBuffer = NULL;
    LPTSTR  szTrans = NULL;
    LPTSTR  szScan = NULL;

//
//  Reads the string value from property bag and
//  frees any existing buffer referenced by szData, 
//  then allocates a new buffer returning it with the 
//  string value read from the property bag and the size of the
//  buffer (in bytes) 
//

    ASSERT (pdwLength!= NULL);
    ASSERT (pszBuffer != NULL);

    *pdwLength = 0;

    VariantInit( &vValue );
    vValue.vt = VT_BSTR;
    vValue.bstrVal = NULL;

    MFC_TRY
        hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED(hr) && NULL != vValue.bstrVal ) {
            dwNewBufSize = SysStringLen(vValue.bstrVal) + sizeof(TCHAR);
            if ( dwNewBufSize > sizeof(TCHAR) ) {
                // then there's something to read
                szTrans = new TCHAR[dwNewBufSize];
                szNewStringBuffer = new TCHAR[dwNewBufSize];
                lstrcpy ( szNewStringBuffer, W2T( vValue.bstrVal) );
                for( int i=0;g_htmlentities[i].szHTML != NULL;i++ ){
                    LPTSTR szScan = NULL;
                    while( szScan = _tcsstr( szNewStringBuffer, g_htmlentities[i].szEntity ) ){
                        *szScan = _T('\0');
                        _tcscpy( szTrans, szNewStringBuffer );
                        _tcscat( szTrans, g_htmlentities[i].szHTML );
                        szScan += _tcslen( g_htmlentities[i].szEntity);
                        _tcscat( szTrans, szScan );
                        _tcscpy( szNewStringBuffer, szTrans );
                    }
                }
                delete szTrans;
                szTrans = NULL;
            } else if ( 0 != rstrDefault.GetLength() ) {
                // Missing data in the property bag, so apply the default.
                dwNewBufSize = rstrDefault.GetLength() + sizeof(TCHAR);

                szNewStringBuffer = new TCHAR[dwNewBufSize];
                lstrcpy ( szNewStringBuffer, rstrDefault );
                hr = S_OK;
            } else {
                // Property not found, no default provided.
                hr = E_INVALIDARG;
            }
        } else if ( 0 != rstrDefault.GetLength() ) {
            // Missing data in the property bag, so apply the default.
            dwNewBufSize = rstrDefault.GetLength() + sizeof(TCHAR);
        
            szNewStringBuffer = new TCHAR[dwNewBufSize];
            lstrcpy ( szNewStringBuffer, rstrDefault );                    
            hr = S_OK;
        } 
    MFC_CATCH_HR

    if ( SUCCEEDED(hr)) {
        // then delete the old buffer and replace it with 
        // the new one
        if (*pszBuffer != NULL) {
            delete (*pszBuffer );
        }
        *pszBuffer = (LPTSTR)szNewStringBuffer;
        *pdwLength = dwNewBufSize;
    } else {
        // if error then delete the buffer
        if ( NULL != szNewStringBuffer ) {
            delete szNewStringBuffer;
        }
    }
    if ( NULL != szTrans ) {
        delete szTrans;
    }
    return hr;
}

HRESULT 
CSmLogQuery::DwordFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    DWORD  dwDefault,
    DWORD& rdwData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );

        hr = DwordFromPropertyBag ( 
                pPropBag,
                pIErrorLog,
                strPropName,
                dwDefault, 
                rdwData );
    MFC_CATCH_HR
    return hr;
}
        
HRESULT 
CSmLogQuery::DwordFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    DWORD  dwDefault,
    DWORD& rdwData )
{
    VARIANT vValue;
    HRESULT hr;

    rdwData = dwDefault;

    VariantInit( &vValue );
    vValue.vt = VT_I4;
    vValue.lVal = 0;

    hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );

    if ( E_INVALIDARG != hr ) {
        rdwData = (DWORD)vValue.lVal;
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT 
CSmLogQuery::DoubleFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    DOUBLE  dDefault,
    DOUBLE& rdData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );
    
        hr = DoubleFromPropertyBag ( 
                pPropBag,
                pIErrorLog,
                strPropName,
                dDefault, 
                rdData );
    MFC_CATCH_HR

    return hr;
}
    
HRESULT 
CSmLogQuery::DoubleFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    DOUBLE  dDefault,
    DOUBLE& rdData )
{
    VARIANT vValue;
    HRESULT hr;

    rdData = dDefault;

    VariantInit( &vValue );
    vValue.vt = VT_R8;
    vValue.dblVal = 0;

    hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );

    if ( E_INVALIDARG != hr ) {
        rdData = vValue.dblVal;
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT 
CSmLogQuery::FloatFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    FLOAT  fDefault,
    FLOAT& rfData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    strPropName.LoadString ( uiPropName );
    
    hr = FloatFromPropertyBag ( 
            pPropBag,
            pIErrorLog,
            strPropName,
            fDefault, 
            rfData );

    return hr;
}
    
HRESULT 
CSmLogQuery::FloatFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    FLOAT  fDefault,
    FLOAT& rfData )
{
    VARIANT vValue;
    HRESULT hr;

    rfData = fDefault;

    VariantInit( &vValue );
    vValue.vt = VT_R4;
    vValue.fltVal = 0;

    hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );

    if ( E_INVALIDARG != hr ) {
        rfData = vValue.fltVal;
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT
CSmLogQuery::LLTimeFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName,
    LONGLONG&  rllDefault,
    LONGLONG& rllData )
{
    HRESULT hr = NOERROR;
    CString strPropName;
    VARIANT vValue;
    ResourceStateManager rsm;

    strPropName.LoadString ( uiPropName );

    rllData = rllDefault;

    VariantInit( &vValue );
    vValue.vt = VT_DATE;

    hr = pIPropBag->Read(strPropName, &vValue, pIErrorLog );

    // If parameter not missing, translate and return.  Otherwise,
    // return the default.
    if ( E_INVALIDARG != hr ) {
        if ( !VariantDateToLLTime ( vValue.date, &rllData ) ) {
            hr = E_FAIL;
        }
        VariantClear( &vValue );
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT
CSmLogQuery::SlqTimeFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    DWORD dwFlags, 
    PSLQ_TIME_INFO pSlqDefault,
    PSLQ_TIME_INFO pSlqData )
{
    HRESULT hr = NOERROR;

    ASSERT ( NULL != pSlqData );

    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:

            pSlqData->wTimeType = SLQ_TT_TTYPE_START;
            pSlqData->wDataType = SLQ_TT_DTYPE_DATETIME;

            hr = DwordFromPropertyBag ( 
                    pPropBag, 
                    pIErrorLog, 
                    IDS_HTML_START_MODE, 
                    pSlqDefault->dwAutoMode, 
                    pSlqData->dwAutoMode );
            
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                hr = LLTimeFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_START_AT_TIME, 
                        pSlqDefault->llDateTime, 
                        pSlqData->llDateTime );

            } else {
                // Original state is stopped.
                ASSERT ( SLQ_AUTO_MODE_NONE == pSlqData->dwAutoMode );
                pSlqData->llDateTime = MAX_TIME_VALUE;
            }
            
            break;

        case SLQ_TT_TTYPE_STOP:
            pSlqData->wTimeType = SLQ_TT_TTYPE_STOP;

            hr = DwordFromPropertyBag ( 
                    pPropBag, 
                    pIErrorLog, 
                    IDS_HTML_STOP_MODE, 
                    pSlqDefault->dwAutoMode, 
                    pSlqData->dwAutoMode );
            
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                pSlqData->wDataType = SLQ_TT_DTYPE_DATETIME;
                hr = LLTimeFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_STOP_AT_TIME, 
                        pSlqDefault->llDateTime, 
                        pSlqData->llDateTime );

            } else if ( SLQ_AUTO_MODE_AFTER == pSlqData->dwAutoMode ) {
                pSlqData->wDataType = SLQ_TT_DTYPE_UNITS;

                hr = DwordFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_STOP_AFTER_UNIT_TYPE, 
                        pSlqDefault->dwUnitType, 
                        pSlqData->dwUnitType );

                hr = DwordFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_STOP_AFTER_VALUE, 
                        pSlqDefault->dwValue, 
                        pSlqData->dwValue );
            } else {
                // Original state is stopped.
                ASSERT ( SLQ_AUTO_MODE_NONE == pSlqData->dwAutoMode );
                pSlqData->wDataType = SLQ_TT_DTYPE_DATETIME;
                pSlqData->llDateTime = MIN_TIME_VALUE;
            }
            
            break;
            
        case SLQ_TT_TTYPE_SAMPLE:
        {
            DWORD dwNullDefault = (DWORD)(-1);
            BOOL bUnitTypeMissing = FALSE;
            BOOL bUnitValueMissing = FALSE;

            hr = DwordFromPropertyBag ( 
                            pPropBag, 
                            pIErrorLog, 
                            IDS_HTML_SAMPLE_INT_UNIT_TYPE, 
                            dwNullDefault, 
                            pSlqData->dwUnitType );

            if ( (DWORD)(-1) == pSlqData->dwUnitType ) {
                pSlqData->dwUnitType = pSlqDefault->dwUnitType;
                bUnitTypeMissing = TRUE;
            }

            hr = DwordFromPropertyBag ( 
                            pPropBag, 
                            pIErrorLog, 
                            IDS_HTML_SAMPLE_INT_VALUE, 
                            dwNullDefault, 
                            pSlqData->dwValue );

            if ( (DWORD)(-1) == pSlqData->dwValue ) {
                pSlqData->dwValue = pSlqDefault->dwValue;
                bUnitValueMissing = TRUE;
            }

            if ( bUnitTypeMissing || bUnitValueMissing ) {
                FLOAT fDefaultUpdateInterval;
                FLOAT fUpdateInterval;

                // If unit type or unit count missing from the property bag,
                // look for "UpdateInterval" value, from the Sysmon control object,
                // and use it to approximate the sample time.
                fDefaultUpdateInterval = (FLOAT)(pSlqDefault->dwValue);

                hr = FloatFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_SYSMON_UPDATEINTERVAL, 
                        fDefaultUpdateInterval, 
                        fUpdateInterval );

                if ( SUCCEEDED ( hr ) ) {
                    pSlqData->dwValue = (DWORD)(fUpdateInterval);
                    pSlqData->dwUnitType = SLQ_TT_UTYPE_SECONDS;
                }
            }
            break;
        }
        
        // Restart mode stored as a single DWORD
        case SLQ_TT_TTYPE_RESTART:
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}




//  
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD   
CSmLogQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    //open the subkey for this log query
    m_hKeyQuery = hKeyQuery;
    m_bReadOnly = bReadOnly;
    m_bIsModified = FALSE;

    MFC_TRY
        m_strName = rstrName;
        dwStatus = SyncWithRegistry();
    
    MFC_CATCH_DWSTATUS
    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmLogQuery::Close ()
{
    LOCALTRACE (L"Closing Query\n");

    m_strName.Empty();
    mr_strComment.Empty();
    mr_strCommentIndirect.Empty();
    mr_strBaseFileName.Empty();
    mr_strBaseFileNameIndirect.Empty();
    mr_strDefaultDirectory.Empty();
    mr_strSqlName.Empty();
    
    // close any open registry keys
    if (m_hKeyQuery != NULL) {
        RegCloseKey (m_hKeyQuery);
        m_hKeyQuery = NULL;
    }

    return ERROR_SUCCESS;
}

//  
//  ManualStart function. 
//      Sets the start mode to manual and starts the query.
//
DWORD   
CSmLogQuery::ManualStart ()
{
    DWORD           dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   slqTime;
    BOOL            bSetStopToMax;
    BOOL            bStarted = FALSE;
    DWORD           dwTimeout = 10;
    BOOL            bRegistryUpdated;

    memset (&slqTime, 0, sizeof(slqTime));
    slqTime.wTimeType = SLQ_TT_TTYPE_START;
    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
    slqTime.llDateTime = MIN_TIME_VALUE;

    SetLogTime ( &slqTime, SLQ_TT_TTYPE_START );

    // If stop time mode set to manual, or StopAt with time before Now,
    // set the mode to Manual, value to MAX_TIME_VALUE
    bSetStopToMax = FALSE;
    GetLogTime ( &slqTime, SLQ_TT_TTYPE_STOP );
    if ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode ) {
        bSetStopToMax = TRUE;
    } else if ( SLQ_AUTO_MODE_AT == slqTime.dwAutoMode ) {
        SYSTEMTIME      stLocalTime;
        FILETIME        ftLocalTime;
        LONGLONG        llLocalTime;

        // get local time
        // Milliseconds set to 0 for Schedule times
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        
        llLocalTime = *(LONGLONG*)&ftLocalTime;

        if ( llLocalTime >= slqTime.llDateTime ) {
            bSetStopToMax = TRUE;
        }    
    }

    if ( bSetStopToMax ) {    
        ASSERT( SLQ_TT_DTYPE_DATETIME == slqTime.wDataType );
        slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
        slqTime.llDateTime = MAX_TIME_VALUE;
        SetLogTime ( &slqTime, SLQ_TT_TTYPE_STOP );
    }

    // Service needs to distinguish between Running and Start Pending
    // at service startup, so always set state to start pending.
    SetState ( SLQ_QUERY_START_PENDING );
    
    dwStatus = UpdateServiceSchedule( bRegistryUpdated );
    
    if ( bRegistryUpdated ) { 

        while (--dwTimeout && !bStarted ) {    
            bStarted = IsRunning();
        }
    
        if ( !bStarted ) {
            dwStatus = SMCFG_START_TIMED_OUT;
        }
    }

    SyncPropPageSharedData();   // Sync the start time and stop auto mode

    return dwStatus;
}

//  
//  ManualStop function. 
//      
//      Clears the restart bit, sets the stop mode to manual and stops the query.
//
DWORD   
CSmLogQuery::ManualStop ( )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   slqTime;
    BOOL            bRegistryUpdated;

    if ( IsAutoRestart() ) {
        mr_dwAutoRestartMode = SLQ_AUTO_MODE_NONE;
    }

    memset (&slqTime, 0, sizeof(slqTime));
    slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
    slqTime.llDateTime = MIN_TIME_VALUE;

    SetLogTime ( &slqTime, SLQ_TT_TTYPE_STOP );

    // If start time mode set to manual, set the value to MAX_TIME_VALUE
    GetLogTime ( &slqTime, SLQ_TT_TTYPE_START );
    if ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode ) {
        ASSERT( SLQ_TT_DTYPE_DATETIME == slqTime.wDataType );
        slqTime.llDateTime = MAX_TIME_VALUE;
        SetLogTime ( &slqTime, SLQ_TT_TTYPE_START );
    }
    
    dwStatus = UpdateServiceSchedule ( bRegistryUpdated );
    
    if ( bRegistryUpdated ) { 
        DWORD   dwTimeout = 25;
        BOOL    bStopped = FALSE;
        
        while ( dwTimeout-- && !bStopped ) {
            // IsRunning implements no delay if the current state is not
            // SLQ_QUERY_START_PENDING, so add a delay for the registry
            // change to be written.
            bStopped = !IsRunning();
            Sleep ( 200 );
        }
    
        if ( !bStopped ) {
            dwStatus = SMCFG_STOP_TIMED_OUT;
        }
    }

    SyncPropPageSharedData();   // Sync the start time and stop auto mode

    return dwStatus;
}

//  
//  SaveAs function. 
//      Saves the query properties as a System Monitor ActiveX object
//      in an HTML file.
//
DWORD   
CSmLogQuery::SaveAs ( const CString& rstrPathName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    CString strNonConstPathName = rstrPathName;
    ResourceStateManager rsm;

    // Create a file.
    HANDLE hFile;
    hFile =  CreateFile (
                strNonConstPathName, 
                GENERIC_READ | GENERIC_WRITE,
                0,              // Not shared
                NULL,           // Security attributes
                CREATE_ALWAYS,  // The user has already decided to override any existing file.
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( INVALID_HANDLE_VALUE != hFile ) {
        // Save the current configuration to the file.
        CString strTemp;
        DWORD   dwTempLength;
        BOOL    bStatus;
        WCHAR   szByteOrderMark[2];

        szByteOrderMark[0] = 0xFEFF;
        szByteOrderMark[1] = 0;
        bStatus = FileWrite ( hFile, szByteOrderMark, sizeof(WCHAR) );
        
        if ( bStatus ) {
            strTemp.LoadString( IDS_HTML_FILE_HEADER1 );
            dwTempLength = strTemp.GetLength() * sizeof(TCHAR);
            bStatus = FileWrite ( hFile, (void *)(LPCTSTR)strTemp, dwTempLength );
        }

        if ( bStatus ) {
            strTemp.LoadString( IDS_HTML_FILE_HEADER2 );
            dwTempLength = strTemp.GetLength() * sizeof(TCHAR);
            bStatus = FileWrite ( hFile, (void *)(LPCTSTR)strTemp, dwTempLength );
        }

        if ( bStatus ) {
            DWORD dwByteCount;
            LPTSTR  pszData = NULL;

            HRESULT hr = CopyToBuffer ( pszData, dwByteCount );
            
            if ( SUCCEEDED ( hr ) ) {
                ASSERT ( NULL != pszData );
                ASSERT ( 0 != dwByteCount );
                bStatus = FileWrite ( hFile, pszData, dwByteCount );
                delete pszData;
            } else {
                bStatus = FALSE;
            }
        }

        if ( bStatus ) {
            strTemp.LoadString( IDS_HTML_FILE_FOOTER );
            dwTempLength = strTemp.GetLength() * sizeof(TCHAR);
            bStatus = FileWrite ( hFile, (void *)(LPCTSTR)strTemp, dwTempLength );
        }

        bStatus = CloseHandle ( hFile );

    }
    
    return dwStatus;
}

DWORD
CSmLogQuery::UpdateService( BOOL& rbRegistryUpdated ) {

    DWORD dwStatus;

    rbRegistryUpdated = FALSE;

    dwStatus = UpdateRegistry();

    if ( ERROR_SUCCESS == dwStatus ) {
        rbRegistryUpdated = TRUE;
        dwStatus = m_pLogService->Synchronize();    
    }
    
    if ( ERROR_SUCCESS == dwStatus ) {
        m_bIsModified = TRUE;
    }

    return dwStatus;
}

//
//  UpdateServiceSchedule function.
//      copies the current schedule settings to the registry
//      and synchs the log service
//
DWORD
CSmLogQuery::UpdateServiceSchedule( BOOL& rbRegistryUpdated ) {

    LONG    dwStatus = ERROR_SUCCESS;
    
    rbRegistryUpdated = FALSE;

    if (!m_bReadOnly) {

        dwStatus = UpdateRegistryScheduleValues();

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = UpdateRegistryLastModified();
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            rbRegistryUpdated = TRUE;
            dwStatus = m_pLogService->Synchronize();    
        }
    
        if ( ERROR_SUCCESS == dwStatus ) {
            m_bIsModified = TRUE;
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }
    return dwStatus;
}

//
//  UpdateRegistryLastModified function.
//      Copies the current "last modified date" to the registry where 
//      it is read by the log service
//
DWORD   
CSmLogQuery::UpdateRegistryLastModified() 
{
    LONG    dwStatus = ERROR_SUCCESS;

    if (!m_bReadOnly) {
        SLQ_TIME_INFO   plqLastModified;
        FILETIME        ftModified;
        SYSTEMTIME      stLocalTime;

        RegFlushKey( m_hKeyQuery );

        dwStatus = RegQueryInfoKey ( 
                    m_hKeyQuery,
                    NULL,           // Class buffer
                    NULL,           // Size of class buffer
                    NULL,           // Reserved
                    NULL,           // Subkey count
                    NULL,           // Length of longest subkey name
                    NULL,           // Longest subkey class
                    NULL,           // Value count
                    NULL,           // Length of longest value name
                    NULL,           // Length of longest value 
                    NULL,           // Security descriptor
                    &ftModified );
        if (ERROR_SUCCESS != dwStatus ) {
            // Get local time for last modified value, if the
            // registry doesn't return the last written time.
            GetLocalTime (&stLocalTime);
            SystemTimeToFileTime (&stLocalTime, &ftModified);
        }

        plqLastModified.wDataType = SLQ_TT_DTYPE_DATETIME;
        plqLastModified.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
        plqLastModified.dwAutoMode = SLQ_AUTO_MODE_NONE;    // not used.
        plqLastModified.llDateTime = *(LONGLONG *)&ftModified;

        dwStatus = WriteRegistrySlqTime (
            m_hKeyQuery, 
            IDS_REG_LAST_MODIFIED,
            &plqLastModified);
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  UpdateRegistryScheduleValues function.
//      copies the current schedule settings to the registry where they
//      are read by the log service
//
DWORD   
CSmLogQuery::UpdateRegistryScheduleValues() 
{
    LONG    dwStatus = ERROR_SUCCESS;
    
    if (!m_bReadOnly) {

        // Stop and start times
    
        if ( ERROR_SUCCESS == dwStatus ) {
            ASSERT (mr_stiStart.wTimeType == SLQ_TT_TTYPE_START);
            dwStatus = WriteRegistrySlqTime (
                m_hKeyQuery, 
                IDS_REG_START_TIME,
                &mr_stiStart);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            ASSERT (mr_stiStop.wTimeType == SLQ_TT_TTYPE_STOP);
            dwStatus = WriteRegistrySlqTime (
                m_hKeyQuery, 
                IDS_REG_STOP_TIME,
                &mr_stiStop);
        }

        // Auto restart value is "immediately on log file close" only.
        // Use binary for future enhancements.
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_RESTART,
                &mr_dwAutoRestartMode,
                REG_BINARY);
        }

        // Only write the state when requesting the service to
        // start a query.
        if ( SLQ_QUERY_START_PENDING == mr_dwCurrentState ) {

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_CURRENT_STATE,
                &mr_dwCurrentState);
        }

    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}
//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD   
CSmLogQuery::UpdateRegistry() 
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize = 0;
    DWORD   dwLogType;
	DWORD	dwLogFileType = 0;
    DWORD   dwTempFileSizeUnits;
    DWORD   dwTempDataStoreAttributes = 0;
    DWORD   dwTempMaxFileSize;
    DWORD   dwTempAppendMode;

    if ( IsModifiable() ) {
                
        if ( !mr_strComment.IsEmpty() ) {
            dwBufferSize = mr_strComment.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);
        } else {
            dwBufferSize = 0;
        }

        dwStatus = WriteRegistryStringValue (
            m_hKeyQuery,
            IDS_REG_COMMENT,
            REG_SZ,
            (LPCTSTR)mr_strComment,
            &dwBufferSize);

        if ( ERROR_SUCCESS == dwStatus && !mr_strCommentIndirect.IsEmpty() ) {
            dwBufferSize = mr_strCommentIndirect.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);

            dwStatus = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_COMMENT_INDIRECT,
                REG_SZ,
                (LPCTSTR)mr_strCommentIndirect,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwLogType = GetLogType();
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_TYPE,
                &dwLogType);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_REALTIME_DATASOURCE,
                & mr_dwRealTimeQuery);
        }
        
        // Files

        if ( ERROR_SUCCESS == dwStatus ) {
            // Within the app, counter data store size units are in MB.
            // Translate to back to KB when write to registry
            dwTempFileSizeUnits = GetDataStoreSizeUnits();
            dwTempMaxFileSize = mr_dwMaxSize;
			GetLogFileType ( dwLogFileType );
            if ( SLQ_COUNTER_LOG == GetLogType()
                && SLF_SQL_LOG != dwLogFileType ) 
            {
                if ( ONE_MB == dwTempFileSizeUnits ) { 
                    dwTempFileSizeUnits = ONE_KB;
                    // Round up to next MB
                    if ( SLQ_DISK_MAX_SIZE != mr_dwMaxSize ) {
                        dwTempMaxFileSize *= dwTempFileSizeUnits;
                    }
                }
            }

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_MAX_SIZE,
                &dwTempMaxFileSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            // Data store size units
            if ( ONE_MB == dwTempFileSizeUnits ) {
                dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_MB;
            } else if ( ONE_KB == dwTempFileSizeUnits ) {
                dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_KB;
            } else if ( ONE_RECORD == dwTempFileSizeUnits ) {
                dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_RECORD;
            }

            // Data store append mode
            GetDataStoreAppendMode( dwTempAppendMode );
            dwTempDataStoreAttributes |= dwTempAppendMode;

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_DATA_STORE_ATTRIBUTES,
                &dwTempDataStoreAttributes);
        }

        if ( !mr_strBaseFileName.IsEmpty() ) {
            dwBufferSize = mr_strBaseFileName.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);
        } else {
            dwBufferSize = 0;
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_BASE_NAME,
                REG_SZ,
                (LPCTSTR)mr_strBaseFileName, 
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus && !mr_strBaseFileNameIndirect.IsEmpty() ) {
            dwBufferSize = mr_strBaseFileNameIndirect.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);

            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_BASE_NAME_IND,
                REG_SZ,
                (LPCTSTR)mr_strBaseFileNameIndirect, 
                &dwBufferSize);
        }

        if ( !mr_strSqlName.IsEmpty() ) {
            dwBufferSize = mr_strSqlName.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);
        } else {
            dwBufferSize = 0;
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery, 
                IDS_REG_SQL_LOG_BASE_NAME,
                REG_SZ,
                (LPCTSTR)mr_strSqlName, 
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                        m_hKeyQuery, 
                        IDS_REG_LOG_FILE_SERIAL_NUMBER,
                        &mr_dwCurrentSerialNumber );
        }

        if ( !mr_strDefaultDirectory.IsEmpty() ) {
            dwBufferSize = mr_strDefaultDirectory.GetLength() + 1;
            dwBufferSize *= sizeof(TCHAR);
        } else {
            dwBufferSize = 0;
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_LOG_FILE_FOLDER,
                REG_SZ,
                (LPCTSTR)mr_strDefaultDirectory,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_AUTO_FORMAT,
                &mr_dwLogAutoFormat);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_TYPE,
                &mr_dwLogFileType);
        }

        // Schedule

        // Eof command is used for counter and trace logs only.
        if ( ERROR_SUCCESS == dwStatus ) {
            if ( SLQ_COUNTER_LOG == GetLogType()
                 || SLQ_TRACE_LOG == GetLogType() ) {
                dwBufferSize = mr_strEofCmdFile.GetLength() + 1;
                dwBufferSize *= sizeof(TCHAR);
                dwStatus  = WriteRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_EOF_COMMAND_FILE,
                    REG_SZ,
                    (LPCWSTR)mr_strEofCmdFile,
                    &dwBufferSize);
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = UpdateRegistryScheduleValues();
        }

        // This must be the last registry value updated.
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = UpdateRegistryLastModified();
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  SyncSerialNumberWithRegistry()
//      reads the current value for the serial number 
//      from the registry and reloads the internal value 
//      to match
//  
DWORD   
CSmLogQuery::SyncSerialNumberWithRegistry()
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT (m_hKeyQuery != NULL);

    // Get starting serial number for serial suffix.

    dwStatus = ReadRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_SERIAL_NUMBER,
                DEFAULT_LOG_FILE_SERIAL_NUMBER, 
                &mr_dwCurrentSerialNumber );
    ASSERT (dwStatus == ERROR_SUCCESS);

    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and reloads the internal values to match
//  
DWORD   
CSmLogQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiDefault;
    WCHAR   szDefault[MAX_PATH + 1];
    LPTSTR  szTemp = NULL;
    DWORD   dwDefault;
    DWORD   dwTemp;
    LPWSTR  szIndTemp = NULL;
    UINT    uiBufferLen = 0;
    CString strValueName;
    LPTSTR  szEofCmd = NULL;

    ResourceStateManager   rsm;

    ASSERT (m_hKeyQuery != NULL);
    
    MFC_TRY
        // Modify bit
        dwTemp = DEFAULT_EXECUTE_ONLY;
        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_EXECUTE_ONLY,
                    DEFAULT_EXECUTE_ONLY, 
                    &dwTemp);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        if ( 0 == dwTemp ) {
            m_bExecuteOnly = FALSE;
        } else {
            m_bExecuteOnly = TRUE;
        }

        // File attributes
    
        // Comment field can be indirect
        strValueName.LoadString ( IDS_REG_COMMENT );

        dwStatus = SmReadRegistryIndirectStringValue (
            m_hKeyQuery,
            strValueName, 
            DEFAULT_COMMENT,
            &szIndTemp,
            &uiBufferLen );

        mr_strComment.Empty();

        if ( NULL != szIndTemp ) {
            if ( _T('\0') != *szIndTemp ) {
                mr_strComment = szIndTemp;
            }
        }

        if ( NULL != szIndTemp ) {
            G_FREE ( szIndTemp );
            szIndTemp = NULL;
        }
        uiBufferLen = 0;

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_LOG_FILE_MAX_SIZE,
                    DEFAULT_LOG_FILE_MAX_SIZE, 
                    &mr_dwMaxSize );

        ASSERT ( ERROR_SUCCESS == dwStatus );

        if ( SLQ_TRACE_LOG == GetLogType() ) {

            dwStatus = ReadRegistryDwordValue (
                        m_hKeyQuery, 
                        IDS_REG_LOG_FILE_TYPE,
                        DEFAULT_TRACE_LOG_FILE_TYPE, 
                        &mr_dwLogFileType);
            ASSERT ( ERROR_SUCCESS == dwStatus );

        } else {

            dwStatus = ReadRegistryDwordValue (
                        m_hKeyQuery, 
                        IDS_REG_LOG_FILE_TYPE,
                        DEFAULT_CTR_LOG_FILE_TYPE, 
                        &mr_dwLogFileType);
            ASSERT ( ERROR_SUCCESS == dwStatus );

        }

        // Data store attributes must be read after log file type and log file max size.

        dwDefault = 0;  // Eliminate PREFIX warning
        InitDataStoreAttributesDefault ( mr_dwLogFileType, dwDefault );

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery,
                    IDS_REG_DATA_STORE_ATTRIBUTES,
                    dwDefault, 
                    &dwTemp );
        
        ProcessLoadedDataStoreAttributes ( dwTemp );

        //
        // Default to query name.
        // Log file base name field can be indirect.
        //
        lstrcpynW ( szDefault, m_strName , min ( MAX_PATH + 1, m_strName.GetLength() + 1 ) );
        szDefault[MAX_PATH] = L'\0';

        strValueName.LoadString ( IDS_REG_LOG_FILE_BASE_NAME );
        dwStatus = SmReadRegistryIndirectStringValue (
            m_hKeyQuery,
            strValueName, 
            szDefault,              
            &szIndTemp,
            &uiBufferLen );

        ASSERT ( ERROR_SUCCESS == dwStatus );

        mr_strBaseFileName.Empty();
        
        if ( NULL != szIndTemp ) {
            if ( _T('\0') != *szIndTemp ) {
                ReplaceBlanksWithUnderscores ( szIndTemp );
                mr_strBaseFileName = szIndTemp;
            }
        }

        if ( NULL != szIndTemp ) {
            G_FREE ( szIndTemp );
            szIndTemp = NULL;
        }
        uiBufferLen = 0;

        dwStatus = ReadRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_LOG_FILE_FOLDER,
                    m_pLogService->GetDefaultLogFileFolder(),
                    &szTemp,
                    &dwBufferSize);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        mr_strDefaultDirectory.Empty();
        if ( dwBufferSize > sizeof(TCHAR) ) {
            ASSERT ( NULL != szTemp );
            ASSERT ( 0 != *szTemp );
            mr_strDefaultDirectory = szTemp;
        }

        delete ( szTemp );
        szTemp = NULL;
        dwBufferSize = 0;

        // Default log set name to log name
        if ( MAX_PATH + 1 > m_strName.GetLength() + 5 ) {
            swprintf ( szDefault, L"SQL:!%s", m_strName );
        } else {
            lstrcpyW ( szDefault, L"SQL:!" );
        }

        dwStatus = ReadRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_SQL_LOG_BASE_NAME,
                    szDefault,             
                    &szTemp,
                    &dwBufferSize);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        mr_strSqlName.Empty();
        if ( dwBufferSize > sizeof(TCHAR) ) {
            ASSERT ( NULL != szTemp );
            ASSERT ( 0 != *szTemp );
            mr_strSqlName = szTemp;
        }

        delete ( szTemp );
        szTemp = NULL;
        dwBufferSize = 0;

        dwStatus = ReadRegistryDwordValue(
                    m_hKeyQuery, 
                    IDS_REG_REALTIME_DATASOURCE,
                    g_dwRealTimeQuery, 
                    & mr_dwRealTimeQuery);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_LOG_FILE_AUTO_FORMAT,
                    DEFAULT_LOG_FILE_AUTO_FORMAT, 
                    &mr_dwLogAutoFormat);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        // Get starting serial number for serial suffix.
        dwStatus = SyncSerialNumberWithRegistry ();
        ASSERT ( ERROR_SUCCESS == dwStatus );

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_CURRENT_STATE,
                    DEFAULT_CURRENT_STATE, 
                    &mr_dwCurrentState);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        //  Start, stop and restart values

        VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_START ) );

        dwStatus = ReadRegistrySlqTime (
            m_hKeyQuery, IDS_REG_START_TIME,
            &stiDefault, &mr_stiStart);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        ASSERT (mr_stiStart.wTimeType == SLQ_TT_TTYPE_START);

        VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_STOP ) );

        dwStatus = ReadRegistrySlqTime (
            m_hKeyQuery, IDS_REG_STOP_TIME,
            &stiDefault, &mr_stiStop);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        ASSERT (mr_stiStop.wTimeType == SLQ_TT_TTYPE_STOP);

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_RESTART,
                    DEFAULT_RESTART_VALUE, 
                    &mr_dwAutoRestartMode);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        // Eof command is used by Counter and Trace logs only.
        if ( SLQ_COUNTER_LOG == GetLogType()
             || SLQ_TRACE_LOG == GetLogType() ) {

            dwStatus = ReadRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_EOF_COMMAND_FILE,
                DEFAULT_EOF_COMMAND_FILE,
                &szEofCmd,
                &dwBufferSize);
            ASSERT ( ERROR_SUCCESS == dwStatus );
            if (dwBufferSize > sizeof(TCHAR)) {
                mr_strEofCmdFile = szEofCmd;
            } else {
                mr_strEofCmdFile.Empty();
            }
        }

    MFC_CATCH_DWSTATUS;
    if ( NULL != szTemp ) {
        delete szTemp;
    }

    if ( NULL != szIndTemp ) {
        G_FREE ( szIndTemp );
    }

    if ( NULL != szEofCmd ) {
        delete szEofCmd;
    }
    SyncPropPageSharedData();

    return dwStatus;
}
    
CSmLogService*    
CSmLogQuery::GetLogService ( void )
{
    return m_pLogService;
}

DWORD
CSmLogQuery::GetMachineDisplayName ( CString& rstrMachineName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    // rstrMachineName is writable.  CString copy-on-write 
    // semantics will support a writable string created from read-only.
    // A new string data buffer is allocated the first time that
    // it is modified.

    MFC_TRY
        rstrMachineName = m_pLogService->GetMachineDisplayName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

//
//  Get log file type and return as a string
//
//
const CString&
CSmLogQuery::GetLogFileType( void )
{
    int     nStringIdx;

    ResourceStateManager    rsm;

    m_strLogFileType.Empty();

    switch (LOWORD(mr_dwLogFileType)) {
        case SLF_CSV_FILE:
            nStringIdx = IDS_FT_CSV;
            break;
            
        case SLF_TSV_FILE:
            nStringIdx = IDS_FT_TSV;
            break;
            
        case SLF_BIN_FILE:
            nStringIdx = IDS_FT_BINARY;
            break;

        case SLF_BIN_CIRC_FILE:
            nStringIdx = IDS_FT_BINARY_CIRCULAR;
            break;

        case SLF_SEQ_TRACE_FILE:
            nStringIdx = IDS_FT_SEQUENTIAL_TRACE;
            break;

        case SLF_CIRC_TRACE_FILE:
            nStringIdx = IDS_FT_CIRCULAR_TRACE;
            break;

        case SLF_SQL_LOG:
            nStringIdx = IDS_FT_SQL;
            break;

        default:
            nStringIdx = IDS_FT_UNKNOWN;
            break;
    }

    MFC_TRY
        m_strLogFileType.LoadString ( nStringIdx );
    MFC_CATCH_MINIMUM
    
    return m_strLogFileType;
}

void
CSmLogQuery::GetLogFileType ( DWORD& rdwFileType )
{
    rdwFileType = LOWORD(mr_dwLogFileType);
    return;
}

void
CSmLogQuery::GetDataStoreAppendMode(DWORD &rdwAppend)
{
    rdwAppend = mr_dwAppendMode;

    return;
}

void
CSmLogQuery::SetDataStoreAppendMode(DWORD dwAppend)
{
    mr_dwAppendMode = dwAppend;

    return;
}
//
//  Get log file name currently in use
//
//
const CString&
CSmLogQuery::GetLogFileName ( BOOL bLatestRunning )
{
    HRESULT hr = NOERROR;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwStrBufLen = 0;
    DWORD dwFlags = 0;
    CString strMachineName;

    m_strFileName.Empty();

    MFC_TRY
        strMachineName = m_pLogService->GetMachineName();
    MFC_CATCH_HR;

    // Todo:  dwStatus or hr?

    if ( SUCCEEDED ( hr ) ) {
        if ( bLatestRunning ) {
            dwFlags = PLA_FILENAME_CURRENTLOG;  // Latest running log
        }

        hr = PdhPlaGetLogFileName (
                (LPTSTR)(LPCTSTR)GetLogName(),
                (LPTSTR)(LPCTSTR)strMachineName,
                NULL,  
                dwFlags,
                &dwStrBufLen,
                NULL );

        if ( SUCCEEDED ( hr ) || PDH_INSUFFICIENT_BUFFER == hr ) {
            if ( bLatestRunning ) {
                dwFlags = PLA_FILENAME_CURRENTLOG;  // Latest running log
            }
            hr = PdhPlaGetLogFileName (
                    (LPTSTR)(LPCTSTR)GetLogName(),
                    (LPTSTR)(LPCTSTR)strMachineName,
                    NULL,
                    dwFlags,
                    &dwStrBufLen,
                    m_strFileName.GetBufferSetLength ( dwStrBufLen ) );
            m_strFileName.ReleaseBuffer();
        }
    }

    SetLastError ( hr );

    return m_strFileName;
}

//
//  Get log file name currently in use
//
//
DWORD
CSmLogQuery::GetLogFileName ( CString& rstrLogFileName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogFileName = GetLogFileName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD 
CSmLogQuery::GetLogType ( void )
{
    // Subclass must override
    ASSERT ( FALSE ); 

    return ((DWORD)-1);
}

BOOL    
CSmLogQuery::SetLogFileType ( const DWORD dwType )
{
    DWORD dwLogFileType = LOWORD(dwType);
    if (dwLogFileType < (SLF_FIRST_FILE_TYPE + SLF_NUM_FILE_TYPES)) {
        mr_dwLogFileType = dwLogFileType;
        return TRUE;
    } else {
        return FALSE;
    }
}

const CString&
CSmLogQuery::GetLogName()
{
    return m_strName;
}

DWORD
CSmLogQuery::GetLogName ( CString& rstrLogName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogName = GetLogName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogName ( const CString& rstrLogName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        m_strName = rstrLogName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

const CString&
CSmLogQuery::GetLogKeyName()
{
    return mr_strLogKeyName;
}

DWORD
CSmLogQuery::GetLogKeyName ( CString& rstrLogKeyName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogKeyName = GetLogKeyName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogKeyName ( const CString& rstrLogKeyName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strLogKeyName = rstrLogKeyName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::GetEofCommand ( CString& rstrCmdString)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrCmdString = mr_strEofCmdFile;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
                
DWORD  
CSmLogQuery::SetEofCommand ( const CString& rstrCmdString )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strEofCmdFile = rstrCmdString;
    MFC_CATCH_DWSTATUS
    
    return dwStatus;
}

const CString& 
CSmLogQuery::GetLogComment()
{
    return mr_strComment;
}

DWORD
CSmLogQuery::GetLogComment ( CString& rstrLogComment )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogComment = GetLogComment();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogComment ( const CString& rstrComment )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strComment = rstrComment;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogCommentIndirect ( const CString& rstrComment )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strCommentIndirect = rstrComment;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::SetLogFileName ( const CString& rstrFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strBaseFileName = rstrFileName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::SetLogFileNameIndirect ( const CString& rstrFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strBaseFileNameIndirect = rstrFileName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::SetFileNameParts ( const CString& rstrFolder, const CString& rstrName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strBaseFileName = rstrFolder;
        mr_strDefaultDirectory = rstrName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::GetMaxSize()
{
    return mr_dwMaxSize;
}

BOOL    
CSmLogQuery::SetMaxSize ( const DWORD dwMaxSize )
{
    mr_dwMaxSize = dwMaxSize;
    return TRUE;
}

HKEY   
CSmLogQuery::GetQueryKey ( void )
{
    return m_hKeyQuery;
}

const CString&
CSmLogQuery::GetSqlName()
{
    return mr_strSqlName;
}

DWORD
CSmLogQuery::GetSqlName ( CString& rstrSqlName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrSqlName = GetSqlName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetSqlName ( const CString& rstrSqlName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strSqlName = rstrSqlName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

//
//  return: 1 if the log is currently active or
//          0 if the log is not running
//
BOOL    
CSmLogQuery::IsRunning()
{
    DWORD   dwCurrentState = SLQ_QUERY_START_PENDING;
    DWORD   dwTimeout = 20;
    
    while (--dwTimeout) {
        dwCurrentState = GetState();
        if ( SLQ_QUERY_START_PENDING == dwCurrentState ) {
            Sleep(100);
        } else {
            break;
        }
    }
        
    return ( SLQ_QUERY_RUNNING == dwCurrentState );
}

BOOL    
CSmLogQuery::IsAutoStart()
{
    return ( SLQ_AUTO_MODE_NONE != mr_stiStart.dwAutoMode );
}

BOOL    
CSmLogQuery::IsAutoRestart()
{
    return ( SLQ_AUTO_MODE_AFTER == mr_dwAutoRestartMode );
}

DWORD   
CSmLogQuery::GetFileNameParts( CString& rstrFolder, CString& rstrName)
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrFolder = mr_strDefaultDirectory;
        rstrName = mr_strBaseFileName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::GetFileNameAutoFormat()
{
    return mr_dwLogAutoFormat;
}

BOOL    
CSmLogQuery::SetFileNameAutoFormat ( const DWORD dwFileSuffix )
{
    if ((dwFileSuffix < ( SLF_NAME_FIRST_AUTO + SLF_NUM_AUTO_NAME_TYPES)) ||
        (dwFileSuffix == SLF_NAME_NONE)) {
        mr_dwLogAutoFormat = dwFileSuffix;
        return TRUE;
    }

    return FALSE;
}

DWORD   
CSmLogQuery::GetFileSerialNumber( void )
{
    SyncSerialNumberWithRegistry();
    return mr_dwCurrentSerialNumber;
}

BOOL    
CSmLogQuery::SetFileSerialNumber ( const DWORD dwSerial )
{
    mr_dwCurrentSerialNumber = dwSerial;
    return TRUE;
}


DWORD   
CSmLogQuery::GetState()
{
    DWORD dwCurrentState = SLQ_QUERY_STOPPED;

    // If the service is running, get the value from the registry.
    if ( m_pLogService->IsRunning() ) {

        DWORD dwStatus;
        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_CURRENT_STATE,
                    SLQ_QUERY_STOPPED, 
                    &mr_dwCurrentState);
        ASSERT (dwStatus == ERROR_SUCCESS);
        dwCurrentState = mr_dwCurrentState;

    }

    return dwCurrentState;
}
  
      
BOOL    
CSmLogQuery::SetState ( const DWORD dwNewState )
{
    // Only use this to set the start state.  This is necessary
    // so that the service, at service startup, can differentiate
    // between previously running queries and newly requested query starts.
    ASSERT ( SLQ_QUERY_START_PENDING == dwNewState );

    // Set the local variable if it is different.
    if ( mr_dwCurrentState != dwNewState ) {
        mr_dwCurrentState = dwNewState;
    }
    return TRUE;
}


BOOL    
CSmLogQuery::GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags)
{
    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:
            *pTimeInfo = mr_stiStart;
            return TRUE;

        case SLQ_TT_TTYPE_STOP:
            *pTimeInfo = mr_stiStop;
            return TRUE;

        case SLQ_TT_TTYPE_RESTART:
            pTimeInfo->wTimeType = SLQ_TT_TTYPE_RESTART;
            pTimeInfo->dwAutoMode = mr_dwAutoRestartMode;
            pTimeInfo->wDataType = SLQ_TT_DTYPE_UNITS;      // not used
            pTimeInfo->dwUnitType = SLQ_TT_UTYPE_MINUTES;   // not used
            pTimeInfo->dwValue = 0;                         // not used
            return TRUE;
            
        case SLQ_TT_TTYPE_SAMPLE:
            *pTimeInfo = mr_stiSampleInterval;
            return TRUE;

        default:
            return FALSE;
    }
}
        
BOOL    
CSmLogQuery::SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags)
{
    ASSERT (pTimeInfo->wTimeType == dwFlags);

    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:
            mr_stiStart = *pTimeInfo ;
            return TRUE;

        case SLQ_TT_TTYPE_STOP:
            mr_stiStop = *pTimeInfo;
            return TRUE;

        case SLQ_TT_TTYPE_RESTART:
            mr_dwAutoRestartMode = pTimeInfo->dwAutoMode;
            return TRUE;

        case SLQ_TT_TTYPE_SAMPLE:
            mr_stiSampleInterval = *pTimeInfo;
            return TRUE;
            
        default:
            return FALSE;
    }
}

BOOL    
CSmLogQuery::GetDefaultLogTime(SLQ_TIME_INFO& /*rTimeInfo*/, DWORD /*dwFlags*/)
{
    // Subclass must override
    ASSERT( FALSE );
    return FALSE;
}

void    
CSmLogQuery::SyncPropPageSharedData ( void )
{
    // Sync the data shared between property pages
    // from registry values.
    MFC_TRY
        m_PropData.dwMaxFileSize = mr_dwMaxSize;
        m_PropData.dwLogFileType = LOWORD(mr_dwLogFileType);
        m_PropData.strFolderName = mr_strDefaultDirectory;

        m_PropData.strFileBaseName  = mr_strBaseFileName;
        m_PropData.strSqlName       = mr_strSqlName;
        m_PropData.dwSuffix         = mr_dwLogAutoFormat;
        SyncSerialNumberWithRegistry();
        m_PropData.dwSerialNumber   = mr_dwCurrentSerialNumber;
        m_PropData.stiStartTime     = mr_stiStart;
        m_PropData.stiStopTime      = mr_stiStop;
        m_PropData.stiSampleTime    = mr_stiSampleInterval;
    MFC_CATCH_MINIMUM
    // Todo:  Return and use status
}

void    
CSmLogQuery::UpdatePropPageSharedData ( void )
{
    // Update the registry values for data shared between property pages.
    // Note: This is called by the property page OnApply code.  It is assumed
    // that OnApply is called for all property pages, so the shared data is valid.

    // This method handles the problem where default Start mode and time was
    // written to the registry by the counter page OnApply before the 
    // schedule page OnApply modified the value.
    MFC_TRY
        mr_dwMaxSize                = m_PropData.dwMaxFileSize;   
        mr_dwLogFileType            = m_PropData.dwLogFileType; 

        mr_dwLogAutoFormat          = m_PropData.dwSuffix;       
        mr_dwCurrentSerialNumber    = m_PropData.dwSerialNumber; 
        mr_stiStart                 = m_PropData.stiStartTime;   
        mr_stiStop                  = m_PropData.stiStopTime;   
        mr_stiSampleInterval        = m_PropData.stiSampleTime;   

        mr_strBaseFileName          = m_PropData.strFileBaseName;
        mr_strDefaultDirectory      = m_PropData.strFolderName;
        mr_strSqlName               = m_PropData.strSqlName;
    MFC_CATCH_MINIMUM
    // Todo:  Return and use status
}

BOOL    
CSmLogQuery::GetPropPageSharedData (PSLQ_PROP_PAGE_SHARED pData)
{
    BOOL bReturn = FALSE;

    if ( NULL != pData ) {
        MFC_TRY
            pData->dwLogFileType    = m_PropData.dwLogFileType;
            pData->dwMaxFileSize    = m_PropData.dwMaxFileSize;
            pData->strFileBaseName  = m_PropData.strFileBaseName;
            pData->strFolderName    = m_PropData.strFolderName;
            pData->strSqlName       = m_PropData.strSqlName;
            pData->dwLogFileType    = m_PropData.dwLogFileType;
            pData->dwSuffix         = m_PropData.dwSuffix;
            pData->dwSerialNumber   = m_PropData.dwSerialNumber;
            pData->stiStartTime     = m_PropData.stiStartTime;
            pData->stiStopTime      = m_PropData.stiStopTime;
            pData->stiSampleTime    = m_PropData.stiSampleTime;
            bReturn = TRUE;
        MFC_CATCH_MINIMUM
    } 
    // Todo:  Return and use status
    return bReturn;
}

BOOL    
CSmLogQuery::SetPropPageSharedData (PSLQ_PROP_PAGE_SHARED pData)
{
    BOOL bReturn = FALSE;

    if ( NULL != pData ) {
        MFC_TRY
            m_PropData.dwLogFileType    = pData->dwLogFileType;
            m_PropData.dwMaxFileSize    = pData->dwMaxFileSize;
            m_PropData.strFileBaseName  = pData->strFileBaseName;
            m_PropData.strFolderName    = pData->strFolderName;
            m_PropData.strSqlName       = pData->strSqlName;
            m_PropData.dwLogFileType    = pData->dwLogFileType;
            m_PropData.dwSuffix         = pData->dwSuffix;
            m_PropData.dwSerialNumber   = pData->dwSerialNumber;
            m_PropData.stiStartTime     = pData->stiStartTime;
            m_PropData.stiStopTime      = pData->stiStopTime;
            m_PropData.stiSampleTime    = pData->stiSampleTime;
        MFC_CATCH_MINIMUM
    } 
    // Todo:  Return and use status
    return bReturn;
}

void
CSmLogQuery::InitDataStoreAttributesDefault (
    const	DWORD   dwRegLogFileType,
			DWORD&  rdwDefault )
{
    DWORD   dwBeta1AppendFlags;
	DWORD   dwLogFileType;

    // Append vs. Overwrite
    // Win2000 files defaulted to OVERWRITE. 
    // The Append mode flags did not exist.
    // Convert the settings to use new flags.
    // Whistler Beta 1 append mode was stored in high word of log file type

    dwBeta1AppendFlags = dwRegLogFileType & 0x00FF0000;
    rdwDefault = 0;

	GetLogFileType ( dwLogFileType );

    if ( SLF_FILE_APPEND == dwBeta1AppendFlags ) {
        mr_dwAppendMode = SLF_DATA_STORE_APPEND;
        rdwDefault = SLF_DATA_STORE_APPEND;
    } else if ( SLF_FILE_OVERWRITE == dwBeta1AppendFlags ) {
        mr_dwAppendMode = SLF_DATA_STORE_OVERWRITE;
        rdwDefault = SLF_DATA_STORE_OVERWRITE;
    } else if ( 0 == dwBeta1AppendFlags ) {
        if ( SLF_SQL_LOG == dwLogFileType ) {
            mr_dwAppendMode = SLF_DATA_STORE_APPEND;
        } else {
            // Default for Win2K is overwrite.
            // For Whistler, mode is stored in Data Store Attributes
            mr_dwAppendMode = SLF_DATA_STORE_OVERWRITE;
        }
    }

    // Append vs. overwrite flag

    if ( 0 == rdwDefault ) {
        if ( SLF_BIN_FILE == dwLogFileType
                || SLF_SEQ_TRACE_FILE == dwLogFileType
                || SLF_SQL_LOG == dwLogFileType )
        {
            rdwDefault = SLF_DATA_STORE_APPEND;
        } else {
            rdwDefault = SLF_DATA_STORE_OVERWRITE;
        }
    }

    // File size units flag

    if ( SLQ_COUNTER_LOG == GetLogType() ) {
        if ( SLF_SQL_LOG != dwLogFileType ) {
            rdwDefault |= SLF_DATA_STORE_SIZE_ONE_KB;
        } else {
            rdwDefault |= SLF_DATA_STORE_SIZE_ONE_RECORD;
        }
    } else if ( SLQ_TRACE_LOG == GetLogType() ){
        rdwDefault |= SLF_DATA_STORE_SIZE_ONE_MB;
    }
}

void
CSmLogQuery::ProcessLoadedDataStoreAttributes (
    DWORD   dwDataStoreAttributes )
{
	DWORD	dwLogFileType = 0;
    
    if ( dwDataStoreAttributes & SLF_DATA_STORE_SIZE_ONE_MB ) {
        mr_dwFileSizeUnits = ONE_MB;
    } else if ( dwDataStoreAttributes & SLF_DATA_STORE_SIZE_ONE_KB ) {
        mr_dwFileSizeUnits = ONE_KB;
    } else if ( dwDataStoreAttributes & SLF_DATA_STORE_SIZE_ONE_RECORD ) {
        mr_dwFileSizeUnits = ONE_RECORD;
    }
    // Within the app, counter data store size units are in MB.
    // Translate to MB here, back to KB when write to registry.
	GetLogFileType( dwLogFileType );

    if ( SLQ_COUNTER_LOG == GetLogType()
        && SLF_SQL_LOG != dwLogFileType ) 
    {
        ASSERT ( ONE_KB == GetDataStoreSizeUnits() );
        if ( ONE_KB == GetDataStoreSizeUnits() ) { 
            mr_dwFileSizeUnits = ONE_MB;
            if ( SLQ_DISK_MAX_SIZE != mr_dwMaxSize ) {
                // Round up to next MB
                mr_dwMaxSize = ( mr_dwMaxSize + (ONE_KB - 1) ) / ONE_KB;
            }
        }
    }

    // Data store append mode

    ASSERT ( dwDataStoreAttributes & SLF_DATA_STORE_APPEND_MASK );
    // Todo:  Does defalt value setting overwrite the Whistler Beta 1 setting?

    if ( dwDataStoreAttributes & SLF_DATA_STORE_APPEND ) {
        mr_dwAppendMode = SLF_DATA_STORE_APPEND;
    } else if ( dwDataStoreAttributes & SLF_DATA_STORE_OVERWRITE ) {
        mr_dwAppendMode = SLF_DATA_STORE_OVERWRITE;
    }
}

HRESULT 
CSmLogQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT hr = S_OK;
    DWORD   dwBufSize;    
    SLQ_TIME_INFO   stiDefault;
    LPTSTR  pszTemp = NULL;
    DWORD   dwTemp;
    DWORD   dwDefault;
    TCHAR   szDefault[MAX_PATH + 1];
    LPTSTR  szEofCmd = NULL;

    // Subclass must call this method at the end of their override, to sync the 
    // property page shared data.

    // Continue even if error, using defaults for missing values.
    mr_strComment.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_COMMENT, DEFAULT_COMMENT, &pszTemp, &dwBufSize );
    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strComment = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;

    lstrcpynW ( szDefault, m_strName , min ( MAX_PATH + 1, m_strName.GetLength() + 1 ) );
    szDefault[MAX_PATH] = L'\0';
    ReplaceBlanksWithUnderscores ( szDefault );
    
    mr_strBaseFileName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag ( 
        pPropBag, 
        pIErrorLog, 
        IDS_HTML_LOG_FILE_BASE_NAME, 
        szDefault, 
        &pszTemp, 
        &dwBufSize );
    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strBaseFileName = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;

    mr_strDefaultDirectory.Empty();
    dwBufSize = 0;    
    hr = StringFromPropertyBag ( 
            pPropBag, 
            pIErrorLog, 
            IDS_HTML_LOG_FILE_FOLDER, 
            m_pLogService->GetDefaultLogFileFolder(), 
            &pszTemp, 
            &dwBufSize );

    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strDefaultDirectory = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;    

    mr_strSqlName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag ( 
            pPropBag, 
            pIErrorLog, 
            IDS_HTML_SQL_LOG_BASE_NAME, 
            DEFAULT_SQL_LOG_BASE_NAME, 
            &pszTemp, 
            &dwBufSize );
    if ( sizeof(TCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strSqlName = pszTemp;
    }
    delete ( pszTemp );
    pszTemp = NULL;


    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_REALTIME_DATASOURCE, g_dwRealTimeQuery, mr_dwRealTimeQuery );
    
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_MAX_SIZE, DEFAULT_LOG_FILE_MAX_SIZE, mr_dwMaxSize );

    if ( SLQ_COUNTER_LOG == GetLogType() ) {
        hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_TYPE, DEFAULT_CTR_LOG_FILE_TYPE, dwTemp );
    } else {
        // Read only for counter and trace logs, not for alerts?
        hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_TYPE, DEFAULT_TRACE_LOG_FILE_TYPE, dwTemp );
    }

    SetLogFileType ( dwTemp );

    // Data store attributes must be read after log file type and log file max size.
    InitDataStoreAttributesDefault ( dwTemp, dwDefault );

    // If file size unit value is missing, default to Win2000 values
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_DATA_STORE_ATTRIBUTES, dwDefault, dwTemp );

    ProcessLoadedDataStoreAttributes ( dwTemp );

    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_AUTO_FORMAT, DEFAULT_LOG_FILE_AUTO_FORMAT, mr_dwLogAutoFormat );
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_SERIAL_NUMBER, DEFAULT_LOG_FILE_SERIAL_NUMBER, mr_dwCurrentSerialNumber );
    
    // Do not load "Current State", since a new query is always stopped when created.
    
    // Start and Stop values.
    VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_START ) );
    hr = SlqTimeFromPropertyBag ( pPropBag, pIErrorLog, SLQ_TT_TTYPE_START, &stiDefault, &mr_stiStart );
    VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_STOP ) );
    hr = SlqTimeFromPropertyBag ( pPropBag, pIErrorLog, SLQ_TT_TTYPE_STOP, &stiDefault, &mr_stiStop );
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_RESTART_MODE,  DEFAULT_RESTART_VALUE, mr_dwAutoRestartMode);
        
    // Eof command file for counter and trace logs only.
    if ( SLQ_COUNTER_LOG == GetLogType()
         || SLQ_TRACE_LOG == GetLogType() ) {
        
        mr_strEofCmdFile.Empty();
        dwBufSize = 0;

        hr = StringFromPropertyBag ( 
                pPropBag, 
                pIErrorLog, 
                IDS_HTML_EOF_COMMAND_FILE, 
                DEFAULT_EOF_COMMAND_FILE, 
                &szEofCmd, 
                &dwBufSize );

        if ( sizeof(TCHAR) < dwBufSize ) {
            ASSERT ( NULL != szEofCmd );
            MFC_TRY
                mr_strEofCmdFile = szEofCmd;
            MFC_CATCH_MINIMUM
        }
        
        if ( NULL != szEofCmd ) {
            delete (szEofCmd);
        }
    }

    SyncPropPageSharedData();

    return hr;
}

HRESULT
CSmLogQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL /* fSaveAllProps */ )
{
    HRESULT hr = NOERROR;
    SMONCTRL_VERSION_DATA VersData;
    DWORD   dwTemp;
    DWORD   dwTempFileSizeUnits;
    DWORD   dwTempDataStoreAttributes = 0;
    DWORD   dwTempMaxFileSize;
    DWORD   dwTempAppendMode;
	DWORD	dwLogFileType = 0;

    VersData.iMajor = SMONCTRL_MAJ_VERSION;
    VersData.iMinor = SMONCTRL_MIN_VERSION;

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SYSMON_VERSION, VersData.dwVersion );
    
    if ( SLQ_ALERT == GetLogType() ) {
        hr = StringToPropertyBag ( pPropBag, IDS_HTML_ALERT_NAME, m_strName );
    } else {
        hr = StringToPropertyBag ( pPropBag, IDS_HTML_LOG_NAME, m_strName );
    }
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_COMMENT, mr_strComment );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_TYPE, GetLogType() );
    // Save current state. It can be used to determine the validity of the logfilename.
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_CURRENT_STATE, mr_dwCurrentState );

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_REALTIME_DATASOURCE, mr_dwRealTimeQuery );
    
    // Within the app, counter data store size units are in MB.
    // Translate to back to KB when write to registry
    dwTempFileSizeUnits = GetDataStoreSizeUnits();
    dwTempMaxFileSize = mr_dwMaxSize;
	GetLogFileType ( dwLogFileType );
    if ( SLQ_COUNTER_LOG == GetLogType()
        && SLF_SQL_LOG != dwLogFileType ) 
    {
        if ( ONE_MB == dwTempFileSizeUnits ) { 
            dwTempFileSizeUnits = ONE_KB;
            // Round up to next MB
            if ( SLQ_DISK_MAX_SIZE != mr_dwMaxSize ) {
                dwTempMaxFileSize *= dwTempFileSizeUnits;
            }
        }
    }

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_MAX_SIZE, dwTempMaxFileSize );

    // Data store size units
    if ( ONE_MB == dwTempFileSizeUnits ) {
        dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_MB;
    } else if ( ONE_KB == dwTempFileSizeUnits ) {
        dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_KB;
    } else if ( ONE_RECORD == dwTempFileSizeUnits ) {
        dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_RECORD;
    }

    // Data store append mode
    GetDataStoreAppendMode( dwTempAppendMode );
    dwTempDataStoreAttributes |= dwTempAppendMode;

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_DATA_STORE_ATTRIBUTES, dwTempDataStoreAttributes );

    hr = StringToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_BASE_NAME, mr_strBaseFileName );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_SERIAL_NUMBER, mr_dwCurrentSerialNumber );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_FOLDER, mr_strDefaultDirectory );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_SQL_LOG_BASE_NAME, mr_strSqlName );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_AUTO_FORMAT, mr_dwLogAutoFormat );

    // Write only for counter and trace logs, not for alerts?
    // Log file type for Alerts is -1, so the new query will keep its default value.
    GetLogFileType ( dwTemp );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_TYPE, dwTemp );
    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_START, &mr_stiStart );
    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_STOP, &mr_stiStop );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_RESTART_MODE, mr_dwAutoRestartMode );

    hr = StringToPropertyBag ( pPropBag, IDS_HTML_SYSMON_LOGFILENAME, GetLogFileName(TRUE) );

    // Eof command file for counter and trace logs only.
    if ( SLQ_COUNTER_LOG == GetLogType()
         || SLQ_TRACE_LOG == GetLogType() ) {
        hr = StringToPropertyBag ( pPropBag, IDS_HTML_EOF_COMMAND_FILE, mr_strEofCmdFile );
    }
    return hr;
}

HRESULT
CSmLogQuery::CopyToBuffer ( LPTSTR& rpszData, DWORD& rdwBufferSize )
{
    HRESULT hr;
    CString strHeader;
    CString strFooter;
    CImpIPropertyBag    IPropBag;
    DWORD   dwBufferLength = 0;
    LPTSTR  pszConfig = NULL;

    ResourceStateManager rsm;

    ASSERT ( NULL == rpszData );
    rdwBufferSize = 0;

    hr = SaveToPropertyBag (&IPropBag, TRUE );
   
    if ( SUCCEEDED ( hr ) ) {
        MFC_TRY
            pszConfig = IPropBag.GetData();        
            if ( NULL != pszConfig ) {
                strHeader.LoadString ( IDS_HTML_OBJECT_HEADER );
                strFooter.LoadString ( IDS_HTML_OBJECT_FOOTER );

                dwBufferLength = strHeader.GetLength() + strFooter.GetLength() + lstrlen ( pszConfig ) + 1;

                rpszData = new TCHAR[dwBufferLength];
            } else {
                hr = E_UNEXPECTED;
            }
        MFC_CATCH_HR

        if ( SUCCEEDED ( hr ) ) {
            rdwBufferSize = dwBufferLength * sizeof(TCHAR);

            lstrcpy ( rpszData, strHeader );
            lstrcat ( rpszData, pszConfig );
            lstrcat ( rpszData, strFooter );
        }
    }

    return hr;
}

BOOL
CSmLogQuery::LLTimeToVariantDate (
    IN  LONGLONG llTime,
    OUT DATE *pdate
    )
{
    SYSTEMTIME SystemTime;

    if (!FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime))
        return FALSE;

    if (FAILED(SystemTimeToVariantTime(&SystemTime, pdate)))
        return FALSE;

    return TRUE;
}

    
BOOL
CSmLogQuery::VariantDateToLLTime (
    IN  DATE date,
    OUT LONGLONG *pllTime
    )
{
    SYSTEMTIME SystemTime;

    if (FAILED(VariantTimeToSystemTime(date, &SystemTime)))
        return FALSE;

    if (!SystemTimeToFileTime(&SystemTime,(FILETIME*)pllTime))
        return FALSE;

    return TRUE;
}

DWORD 
CSmLogQuery::UpdateExecuteOnly( void )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if (!m_bReadOnly) {
    
        DWORD dwExecuteOnly;

        dwExecuteOnly = 1;        // TRUE

        dwStatus = WriteRegistryDwordValue (
            m_hKeyQuery, 
            IDS_REG_EXECUTE_ONLY,
            &dwExecuteOnly);

        ASSERT ( ERROR_SUCCESS == dwStatus );

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = m_pLogService->Synchronize();    
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

CWnd* 
CSmLogQuery::GetActivePropertySheet( void )
{
    CWnd* pwndReturn = NULL;

    if ( NULL != m_pActivePropPage ) {
        pwndReturn = m_pActivePropPage->GetParentOwner();
    }
    return pwndReturn;
}

void
CSmLogQuery::SetActivePropertyPage( CSmPropertyPage* pPage)
{
    // The first property page of each property sheet sets 
    // and clears this member variable.
    // It is assumed that the first page is always created.
    m_pActivePropPage = pPage;

    return;
}

BOOL   
CSmLogQuery::IsFirstModification( void ) 
{
    BOOL    bIsFirstModification = FALSE;
    bIsFirstModification = ( m_bIsModified && m_bIsNew );

    if ( bIsFirstModification ) {
        m_bIsNew = FALSE;
    }

    return bIsFirstModification;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smlogs.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogs.h

Abstract:

    Base class representing the Performance Logs and Alerts
    service.

--*/

#ifndef _CLASS_SMLOGSERVICE_
#define _CLASS_SMLOGSERVICE_

#include "smnode.h"
#include "smlogqry.h"   // for query objects in the service
#include <pdhp.h>

class CSmLogService : public CSmNode
{    
    // constructor/destructor
    public:
                CSmLogService();
        virtual ~CSmLogService();

    // public methods
    public:
        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );
                
                DWORD   Synchronize( void );
                BOOL    IsRunning( void );
                BOOL    IsOpen( void ){return m_bIsOpen; };
                INT     GetQueryCount( void );
        
                const CString&  GetDefaultLogFileFolder( void );
                DWORD   CreateDefaultLogQueries( void );
                BOOL    IsWindows2000Server ( void );
                BOOL    CanAccessWbemRemote();
                
        virtual DWORD   SyncWithRegistry();

        virtual PSLQUERY    CreateQuery ( const CString& rstrName ) = 0;
        virtual DWORD       DeleteQuery ( PSLQUERY  plQuery );
        virtual DWORD       DeleteQuery ( const CString& rstrName );        // Unused method

        virtual CSmLogService* CastToLogService( void ) { return this; };

    // public member variables
    public:
        // list of queries 
        CTypedPtrList<CPtrList, PSLQUERY> m_QueryList;     
        HRESULT       m_hWbemAccessStatus;

    protected:

                void        SetBaseName( const CString& ); // Exception thrown on error
                PSLQUERY    CreateTypedQuery ( const CString& rstrName, DWORD dwLogType );
        virtual DWORD       LoadQueries( void ) = 0;
                DWORD       LoadQueries( DWORD dwLogType );
                HKEY        GetMachineRegistryKey ( void ) 
                                { ASSERT ( m_hKeyMachine ); return m_hKeyMachine; };
                
                void        SetOpen ( BOOL bOpen ) { m_bIsOpen = bOpen; };

    private:

        enum ePrivateValue {
            eResetDelaySeconds = 60,
            eRestartDelayMilliseconds = 0
        };

        DWORD   GetState( void );
        DWORD   UpdateConfig();
        DWORD   Install( const CString& rstrMachineName );
        DWORD   UnloadQueries ( void );
        DWORD   LoadDefaultLogFileFolder( void );
        DWORD   UnloadSingleQuery ( PSLQUERY  pQuery );
        DWORD   LoadSingleQuery ( 
                    PSLQUERY*   ppQuery,
                    DWORD       dwLogType, 
                    const CString& rstrName,
                    const CString& rstrLogKeyName,
                    HKEY        hKeyQuery,
                    BOOL        bNew );

        DWORD   FindDuplicateQuery ( 
                    const CString cstrName,
                    BOOL& rbFound );

        CString m_strBaseName;
        HKEY    m_hKeyMachine;
        HKEY    m_hKeyLogService;
        BOOL    m_bReadOnly;
        BOOL    m_bIsOpen;

        HKEY    m_hKeyLogServiceRoot;
        CString m_strDefaultLogFileFolder;
        PLA_VERSION m_OSVersion;
};

typedef CSmLogService   SLSVC;
typedef CSmLogService*  PSLSVC;


#endif //_CLASS_SMLOGSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smlogs.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogs.cpp

Abstract:

    Implementation of the base class representing the 
    Performance Logs and Alerts service.

--*/

#include "Stdafx.h"
// Define the following to use the minimum of shlwapip.h 

#ifndef NO_SHLWAPI_PATH
#define NO_SHLWAPI_PATH
#endif  

#ifndef NO_SHLWAPI_REG
#define NO_SHLWAPI_REG
#endif  

#ifndef NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_UALSTR
#endif  

#ifndef NO_SHLWAPI_STREAM
#define NO_SHLWAPI_STREAM
#endif  

#ifndef NO_SHLWAPI_HTTP
#define NO_SHLWAPI_HTTP
#endif  

#ifndef NO_SHLWAPI_INTERNAL
#define NO_SHLWAPI_INTERNAL
#endif  

#ifndef NO_SHLWAPI_GDI
#define NO_SHLWAPI_GDI
#endif  

#ifndef NO_SHLWAPI_UNITHUNK
#define NO_SHLWAPI_UNITHUNK
#endif  

#ifndef NO_SHLWAPI_TPS
#define NO_SHLWAPI_TPS
#endif  

#ifndef NO_SHLWAPI_MLUI
#define NO_SHLWAPI_MLUI
#endif  

#include <shlwapi.h>            // For SHLoadIndirectString
#include <shlwapip.h>           // For SHLoadIndirectString

#include <pdh.h>        // For MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhp.h>       // For pdhi methods
#include <wbemidl.h>
#include "smlogres.h"
#include "smcfgmsg.h"
#include "smalrtq.h"
#include "smctrqry.h"
#include "smtraceq.h"
#include "smlogs.h"
#include "strnoloc.h"

USE_HANDLE_MACROS("SMLOGCFG(smlogs.cpp)");

#define  DEFAULT_LOG_FILE_FOLDER    L"%SystemDrive%\\PerfLogs"

//
//  Constructor
CSmLogService::CSmLogService()
:   m_hKeyMachine ( NULL ),
    m_hKeyLogService ( NULL ),
    m_hKeyLogServiceRoot ( NULL ),
    m_bIsOpen ( FALSE ),
    m_bReadOnly ( FALSE )
{
    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    m_QueryList.RemoveAll();    // initialize the list
    ZeroMemory(&m_OSVersion, sizeof(m_OSVersion));
    return;
}

//
//  Destructor
CSmLogService::~CSmLogService()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_QueryList.GetHeadPosition() );
    ASSERT ( NULL == m_hKeyMachine );
    ASSERT ( NULL == m_hKeyLogService );
    ASSERT ( NULL == m_hKeyLogServiceRoot );
    return;
}

PSLQUERY    
CSmLogService::CreateTypedQuery ( 
    const CString& rstrName,
    DWORD   dwLogType )
{
    HKEY    hKeyQuery;
    PSLQUERY pNewLogQuery = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDisposition;
    DWORD   dwRegValue;
    UUID    uuidNew;
    RPC_STATUS  rpcStat = RPC_S_OK;
    LPTSTR  pszUuid = NULL;
    INT iBufLen = rstrName.GetLength()+1;
    LPTSTR  pszName = NULL;
    LPTSTR  pStat = NULL;
    BOOL    bDupFound = FALSE;
    CString strNewQueryName;
    CString strCollectionName;

    if (m_bReadOnly) {
        SetLastError (SMCFG_NO_MODIFY_ACCESS);
        return NULL; // unable to create without WRITE access
    } else {
        // Initialize to success status.
        SetLastError( dwStatus );
    }

    if ( !IsWindows2000Server() ) {
        // For servers later than Windows2000, use a GUID as the key name for a query.
        rpcStat = UuidCreate( &uuidNew );

        if ( RPC_S_OK != rpcStat && RPC_S_UUID_LOCAL_ONLY != rpcStat ) {
            rpcStat = UuidCreateSequential ( &uuidNew );
        }

        if ( RPC_S_OK == rpcStat || RPC_S_UUID_LOCAL_ONLY == rpcStat ) {            
   
            rpcStat = UuidToString ( &uuidNew, &pszUuid );

            if ( RPC_S_OK == rpcStat ) {

                ASSERT ( NULL != pszUuid );

                MFC_TRY
                    strNewQueryName.Format ( L"{%s}", pszUuid );
                MFC_CATCH_DWSTATUS

                RpcStringFree ( &pszUuid );
            } else {
                dwStatus = rpcStat; 
            }
        }
        // RPC_STATUS values in rpcnterr.h correspond to appropriate values.
        dwStatus = rpcStat;
    } else {
        // For Windows 2000, use query name as registry key name.

        MFC_TRY
            strNewQueryName = rstrName;
        MFC_CATCH_DWSTATUS

    }

    if ( ERROR_SUCCESS == dwStatus ) {

        // Query key name created
        // Create the query specified, checking for duplicate query by key name.

        dwStatus = RegCreateKeyExW (
            m_hKeyLogService,
            strNewQueryName,
            0,
            NULL, 0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hKeyQuery,
            &dwDisposition);

        if ( REG_OPENED_EXISTING_KEY == dwDisposition ) {
            dwStatus = SMCFG_DUP_QUERY_NAME;
        } 
    } 

    if ( ERROR_SUCCESS == dwStatus ) {

        // Initialize the current state value.  After it is 
        // initialized, it is only modified when:
        //      1) Set to Stopped or Started by the service
        //      2) Set to Start Pending by the config snapin.
        
        dwRegValue = SLQ_QUERY_STOPPED;

        dwStatus = RegSetValueEx (
            hKeyQuery, 
            L"Current State",
            0L,
            REG_DWORD,
            (CONST BYTE *)&dwRegValue,
            sizeof(DWORD));

        if ( ERROR_SUCCESS == dwStatus ) {
            // Initialize the log type to "new" to indicate partially created logs
            dwRegValue = SLQ_NEW_LOG;

            dwStatus = RegSetValueEx (
                hKeyQuery, 
                L"Log Type",
                0L,
                REG_DWORD,
                (CONST BYTE *)&dwRegValue,
                sizeof(DWORD));
        }

        if ( ERROR_SUCCESS == dwStatus && !IsWindows2000Server() ) {
            // Initialize the collection name for post Windows 2000 systems
    
            MFC_TRY
                strCollectionName = rstrName;
            MFC_CATCH_DWSTATUS

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = RegSetValueEx (
                    hKeyQuery, 
                    L"Collection Name",
                    0L,
                    REG_SZ,
                    (CONST BYTE *)strCollectionName.GetBufferSetLength( strCollectionName.GetLength() ),
                    strCollectionName.GetLength()*sizeof(TCHAR) );

                strCollectionName.ReleaseBuffer();
            }

            // For post Windows 2000 counters, search for duplicate by collection name.
            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = FindDuplicateQuery ( rstrName, bDupFound );
            }
        }
        if ( ERROR_SUCCESS == dwStatus && !bDupFound ) {
            // create a new object and add it to the query list
             dwStatus = LoadSingleQuery (
                            &pNewLogQuery,
                            dwLogType,
                            rstrName,
                            strNewQueryName,
                            hKeyQuery,
                            TRUE );
        } else {
            if ( bDupFound ) {
                dwStatus = SMCFG_DUP_QUERY_NAME;
            }
        }
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        // Delete also closes the registry key hKeyQuery.
        if ( !strNewQueryName.IsEmpty() ) {
            RegDeleteKeyW ( m_hKeyLogService, strNewQueryName );
            SetLastError ( dwStatus );
        }
    }

    return pNewLogQuery;
}

DWORD   
CSmLogService::UnloadSingleQuery (PSLQUERY pQuery)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pLogQuery = NULL;
    POSITION    listPos = NULL;
    BOOL        bFoundEntry = FALSE;

    // find matching entry
    if (!m_QueryList.IsEmpty()) {
        listPos = m_QueryList.Find (pQuery, NULL);
        if ( NULL != listPos ) {
            pLogQuery = m_QueryList.GetAt(listPos);
            bFoundEntry = TRUE;
        }
    }

    if (bFoundEntry) {
        ASSERT ( NULL != listPos );

        // remove from list
        m_QueryList.RemoveAt (listPos);
        pLogQuery->Close();
        delete pLogQuery;
    } else {
        // not found
        dwStatus = ERROR_FILE_NOT_FOUND;
    }

    return dwStatus;    
}

DWORD   
CSmLogService::DeleteQuery ( PSLQUERY pQuery )
{
    PSLQUERY    pLogQuery = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    POSITION    listPos = NULL;
    BOOL        bFoundEntry = FALSE;
    CString     strLogKeyName;

    if (m_bReadOnly) {
        dwStatus = ERROR_ACCESS_DENIED;
    } else {
        // find matching entry
        if (!m_QueryList.IsEmpty()) {
            listPos = m_QueryList.Find (pQuery, NULL);
            if (listPos != NULL) {
                pLogQuery = m_QueryList.GetAt(listPos);
                bFoundEntry = TRUE;
            }
        }
        
        if (bFoundEntry) {
            ASSERT (listPos != NULL);
        
            MFC_TRY
                pLogQuery->GetLogKeyName( strLogKeyName );
            MFC_CATCH_DWSTATUS;

            if ( ERROR_SUCCESS == dwStatus ) {
                // remove from list
                m_QueryList.RemoveAt (listPos);
                pLogQuery->Close();

                // Delete in the registry
                RegDeleteKeyW ( m_hKeyLogService, strLogKeyName );
            
                delete pLogQuery;
            }
        } else {
            // not found
            dwStatus = ERROR_FILE_NOT_FOUND;
        }
    }
    return dwStatus;
}

DWORD   
CSmLogService::DeleteQuery ( const CString& rstrName )
{
    PSLQUERY    pLogQuery = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    POSITION    listPos;
    BOOL        bFoundEntry = FALSE;


    if (m_bReadOnly) {
        dwStatus = ERROR_ACCESS_DENIED;
    } else {
        // find matching entry
        if (!m_QueryList.IsEmpty()) {
            listPos = m_QueryList.GetHeadPosition();
            while (listPos != NULL) {
                pLogQuery = m_QueryList.GetNext(listPos);
                if ( 0 == rstrName.CompareNoCase ( pLogQuery->GetLogName() ) ) {
                    // match found so bail here
                    bFoundEntry = TRUE;
                    break;
                }
            }
        }
        
        if (bFoundEntry) {
            dwStatus = DeleteQuery ( pLogQuery );
        } else {
            // not found
            dwStatus = ERROR_FILE_NOT_FOUND;
        }
    }
    return dwStatus;
}

DWORD   
CSmLogService::LoadDefaultLogFileFolder ( void )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szLocalPath = NULL; 
    LPWSTR  szExpanded = NULL;
    INT     cchLen;
    INT     cchExpandedLen;
    DWORD   dwBufferSize = MAX_PATH + 1;

    m_strDefaultLogFileFolder.Empty();

    MFC_TRY
        szLocalPath = new WCHAR [ dwBufferSize ];

        dwBufferSize *= sizeof(WCHAR);

        if ( NULL != m_hKeyLogServiceRoot ) {

            dwStatus = RegQueryValueExW (
                            m_hKeyLogServiceRoot,
                            (LPCTSTR)L"DefaultLogFileFolder",
                            NULL,
                            0L,
                            (LPBYTE)szLocalPath,
                            &dwBufferSize);

            //
            // No message on error.  If error, just load the default.        
            //    
           
            if ( sizeof(WCHAR) < dwBufferSize ) {
                if ( IsLocalMachine() ) {
                    cchLen = 0;
                    cchExpandedLen = 0;

                    cchLen = ExpandEnvironmentStrings ( szLocalPath, NULL, 0 );

                    if ( 0 < cchLen ) {
                        szExpanded = new WCHAR[cchLen];
        
                        cchExpandedLen = ExpandEnvironmentStrings (
                            szLocalPath, 
                            szExpanded,
                            cchLen );

                        if ( 0 < cchExpandedLen && MAX_PATH > cchExpandedLen ) {
                            m_strDefaultLogFileFolder = szExpanded;
                        } else {
                            dwStatus = GetLastError();
                            m_strDefaultLogFileFolder.Empty();
                        }
                    } else {
                        dwStatus = GetLastError();
                    }
                } else {
                    m_strDefaultLogFileFolder = szLocalPath;
                }
            }

            if ( sizeof(WCHAR) >= dwBufferSize || m_strDefaultLogFileFolder.IsEmpty() ) {
                ResourceStateManager    rsm;
                CString strFolderName;
                strFolderName.LoadString ( IDS_DEFAULT_LOG_FILE_FOLDER );

                if ( dwBufferSize > (MAX_PATH + 1)*sizeof(WCHAR) ) {
                    if ( NULL != szLocalPath ) {
                        delete [] szLocalPath;
                        szLocalPath = NULL;
                    }
                    szLocalPath = new WCHAR [strFolderName.GetLength() + 1];
                }

                lstrcpy ( szLocalPath, strFolderName );

                //
                // Exact copy of code for processing the registry setting.
                //
                if ( IsLocalMachine() ) {
                    cchLen = 0;
                    cchExpandedLen = 0;

                    cchLen = ExpandEnvironmentStrings ( szLocalPath, NULL, 0 );

                    if ( 0 < cchLen ) {
                        szExpanded = new WCHAR[cchLen];
        
                        cchExpandedLen = ExpandEnvironmentStrings (
                            szLocalPath, 
                            szExpanded,
                            cchLen );

                        if ( 0 < cchExpandedLen && MAX_PATH > cchExpandedLen ) {
                            m_strDefaultLogFileFolder = szExpanded;
                        } else {
                            dwStatus = GetLastError();
                            m_strDefaultLogFileFolder.Empty();
                        }
                    } else {
                        dwStatus = GetLastError();
                    }
                } else {
                    m_strDefaultLogFileFolder = szLocalPath;
                }
            }
            
        }
    
    MFC_CATCH_DWSTATUS

    if ( NULL != szLocalPath ) {
        delete [] szLocalPath;
    }

    if ( NULL != szExpanded ) {
        delete [] szExpanded;
    }

    return dwStatus;
}

DWORD   
CSmLogService::LoadSingleQuery ( 
    PSLQUERY*   ppQuery,
    DWORD       dwLogType, 
    const CString& rstrName,
    const CString& rstrLogKeyName,
    HKEY        hKeyQuery,
    BOOL        bNew )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PSLQUERY    pNewQuery = NULL;

    if ( NULL != ppQuery ) {
        *ppQuery = NULL;

        // create a new query object and add it to the query list
        MFC_TRY
            if ( SLQ_COUNTER_LOG == dwLogType ) {
                pNewQuery = new SLCTRQUERY ( this );
            } else if ( SLQ_TRACE_LOG == dwLogType ) {
                pNewQuery = new SLTRACEQUERY ( this );
            } else if ( SLQ_ALERT == dwLogType ) {
                pNewQuery = new SLALERTQUERY ( this );
            }
        MFC_CATCH_DWSTATUS

        if ( ERROR_SUCCESS == dwStatus && NULL != pNewQuery ) {
        
            pNewQuery->SetNew ( bNew );

            dwStatus = pNewQuery->Open(
                                    rstrName, 
                                    hKeyQuery, 
                                    m_bReadOnly );

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = pNewQuery->SetLogKeyName ( rstrLogKeyName );
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                // then add it to the list
                MFC_TRY
                    m_QueryList.AddHead ( pNewQuery );
                MFC_CATCH_DWSTATUS
            
                if ( ERROR_SUCCESS != dwStatus ) {
                    // close this query object
                    pNewQuery->Close();
                }            
            }

            if ( ERROR_SUCCESS != dwStatus ) {
                // delete this query object
                delete pNewQuery;
            }               
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            *ppQuery = pNewQuery;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}

DWORD   
CSmLogService::LoadQueries ( DWORD dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwQueryIndex = 0;
    LONG    lEnumStatus = ERROR_SUCCESS;
    WCHAR   szQueryKeyName[MAX_PATH + 1];
    DWORD   dwQueryKeyNameLen;
    LPWSTR  szCollectionName = NULL;
    UINT    uiCollectionNameLen = 0;
    FILETIME    ftLastWritten;
    HKEY        hKeyQuery;
    PSLQUERY    pNewLogQuery = NULL;
    DWORD       dwType = 0;
    DWORD       dwBufferSize = sizeof(DWORD);
    DWORD       dwRegValue;
    CString     strQueryName;

    
    // Load all queries for the specified registry key.
    // Enumerate the log names and create a new log object
    // for each one found.

    dwQueryKeyNameLen = sizeof ( szQueryKeyName ) / sizeof ( WCHAR );
    memset (szQueryKeyName, 0, sizeof (szQueryKeyName));

    while ( ERROR_SUCCESS == ( lEnumStatus = RegEnumKeyExW (
                                                m_hKeyLogService,
                                                dwQueryIndex, 
                                                szQueryKeyName, 
                                                &dwQueryKeyNameLen,
                                                NULL, 
                                                NULL, 
                                                NULL, 
                                                &ftLastWritten ) ) ) {

        // open the query specified
        dwStatus = RegOpenKeyExW (
            m_hKeyLogService,
            szQueryKeyName,
            0,
            (m_bReadOnly ? KEY_READ : KEY_READ | KEY_WRITE),
            &hKeyQuery);
        if ( ERROR_SUCCESS == dwStatus ) {
            // create a new object and add it to the query list
            
            // Determine the log type.                
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKeyQuery,
                L"Log Type",
                NULL,
                &dwType,
                (LPBYTE)&dwRegValue,
                &dwBufferSize );
            
            if ( ( ERROR_SUCCESS == dwStatus ) 
                && ( dwLogType == dwRegValue ) ) {

                dwStatus = SmReadRegistryIndirectStringValue (
                            hKeyQuery,
                            L"Collection Name",
                            NULL,
                            &szCollectionName,
                            &uiCollectionNameLen );
                MFC_TRY
                    if ( ERROR_SUCCESS == dwStatus 
                            && NULL != szCollectionName ) {
                        if (  0 < lstrlen ( szCollectionName ) ) {
                            strQueryName = szCollectionName;
                        } else {
                            strQueryName = szQueryKeyName;
                            dwStatus = ERROR_SUCCESS;
                        }
                    } else {
                        strQueryName = szQueryKeyName;
                        dwStatus = ERROR_SUCCESS;
                    }
                MFC_CATCH_DWSTATUS;

                if ( NULL != szCollectionName ) {
                    G_FREE ( szCollectionName );
                    szCollectionName = NULL;
                    uiCollectionNameLen = 0;
                }

                if ( ERROR_SUCCESS == dwStatus ) {
                    dwStatus = LoadSingleQuery (
                                    &pNewLogQuery,
                                    dwRegValue,
                                    strQueryName,
                                    szQueryKeyName,
                                    hKeyQuery,
                                    FALSE );

                    if ( ERROR_SUCCESS != dwStatus ) {
                        // Todo:  Error message
                        dwStatus = ERROR_SUCCESS;
                    }
                }

            } else {
                // Try the next item in the list
		        RegCloseKey (hKeyQuery);
                dwStatus = ERROR_SUCCESS;
            }
        }
        // set up for the next item in the list
        dwQueryKeyNameLen = sizeof (szQueryKeyName) / sizeof (szQueryKeyName[0]);
        memset (szQueryKeyName, 0, sizeof (szQueryKeyName));
        dwQueryIndex++;
    }
    
    return dwStatus;
}

//  
//  Open function. Opens all existing log query entries.
//
DWORD   
CSmLogService::Open ( const CString& rstrMachineName)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    // Initialize strings
    SetMachineName ( rstrMachineName );
    SetDisplayName ( m_strBaseName );

    if ( rstrMachineName.IsEmpty() ) {
        m_hKeyMachine = HKEY_LOCAL_MACHINE;
    } else {
        dwStatus = RegConnectRegistryW (
            rstrMachineName,
            HKEY_LOCAL_MACHINE,
            &m_hKeyMachine);
    }

    if (dwStatus == ERROR_SUCCESS) {

        // open a read-only key to the registry root key for this service, to obtain
        // root-level values.
        dwStatus = RegOpenKeyExW (
            m_hKeyMachine,
            (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog",
            0,
            KEY_READ,
            &m_hKeyLogServiceRoot);
        // No message on failure.  Currently only affects default log file folder name.
        
        // open a key to the registry log queries key for this service
        dwStatus = RegOpenKeyExW (
            m_hKeyMachine,
            (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
            0,
            KEY_READ | KEY_WRITE,
            &m_hKeyLogService);

        if (dwStatus != ERROR_SUCCESS) {
            // unable to access the key for write access, so try read only
            dwStatus = RegOpenKeyExW (
                m_hKeyMachine,
                (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                0,
                KEY_READ,
                &m_hKeyLogService);
            if (dwStatus != ERROR_SUCCESS) {
                // unable to open the key for read access so bail out
                // assume the service has not been installed 
                // (though we should probably check first to make sure)
                m_hKeyLogService = NULL;
                if ( ERROR_ACCESS_DENIED == dwStatus ) {
                    dwStatus = SMCFG_NO_READ_ACCESS;
                }
            } else {
                // opened for read access so set the flag
                m_bReadOnly = TRUE;
            }
        }
    }

    // Install the service if necessary.
    if ( ( dwStatus != SMCFG_NO_READ_ACCESS ) ) {
        dwStatus = Install( rstrMachineName );
    }
    
    // Load all queries
    if ( ( dwStatus == ERROR_SUCCESS ) && ( NULL != m_hKeyLogService ) ) {
        dwStatus = LoadQueries();
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        SetOpen ( TRUE );
    }

    return dwStatus;
}

DWORD   
CSmLogService::UnloadQueries ()
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pQuery = NULL;
    POSITION    Pos = m_QueryList.GetHeadPosition();

    // Ensure that all property dialogs are closed before unloading queries.
    while ( Pos != NULL) {
        pQuery = m_QueryList.GetNext( Pos );
        if ( NULL != pQuery->GetActivePropertySheet() ) {
            // Todo:  Server Beta 3 - Need specific error code
            dwStatus = IDS_ERRMSG_DELETE_OPEN_QUERY;
            break;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        Pos = m_QueryList.GetHeadPosition();

        // Update each query in this service by walking down the list.
        while ( Pos != NULL) {
            pQuery = m_QueryList.GetNext( Pos );
            pQuery->Close();
            delete (pQuery);
        }
        // Empty the list now that everything has been closed;
        m_QueryList.RemoveAll();    
    }
    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmLogService::Close ()
{

    LOCALTRACE (L"Closing SysmonLog Service Object\n");

    UnloadQueries();

    // close any open registry keys
    if (m_hKeyMachine != NULL) {
        RegCloseKey (m_hKeyMachine);
        m_hKeyMachine = NULL;
    }

    if (m_hKeyLogService != NULL) {
        RegCloseKey (m_hKeyLogService);
        m_hKeyLogService = NULL;
    }

    if (m_hKeyLogServiceRoot!= NULL) {
        RegCloseKey (m_hKeyLogServiceRoot);
        m_hKeyLogServiceRoot = NULL;
    }

    SetOpen ( FALSE );

    return ERROR_SUCCESS;
}

DWORD   
CSmLogService::UpdateConfig()
{
    // If any queries are (newly) set to auto start, then set the
    // service to auto start.  Otherwise, set to manual start.
    // When setting to auto start, also set failure mode to restart
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL  bStatus = 0;
    POSITION    listPos;
    PSLQUERY    pLogQuery = NULL;
    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    BOOL        bAutoStart = FALSE;
    DWORD       pqsConfigBuff[128];
    QUERY_SERVICE_CONFIG*    pqsConfig;
    SC_ACTION*  parrSingleFailAction = NULL;
    SERVICE_FAILURE_ACTIONS  structFailActions;
    DWORD       dwMoreBytes = 0;
    BOOL        bUpdate = FALSE;

    // check for duplicate entry
    if (!m_QueryList.IsEmpty()) {

        listPos = m_QueryList.GetHeadPosition();
        while (listPos != NULL) {
            pLogQuery = m_QueryList.GetNext(listPos);
            if ( pLogQuery->IsAutoStart() ) {
                bAutoStart = TRUE;
                break;
            }
        }
    } 

    // open SC database
    hSC = OpenSCManager ( GetMachineName(), NULL, GENERIC_READ );

    if (hSC != NULL) {
        // open service
        hService = OpenService (
                        hSC, 
                        TEXT("SysmonLog"),
                        SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG | SERVICE_START );

        if (hService != NULL) {    
            
            // get current config
            memset (pqsConfigBuff, 0, sizeof(pqsConfigBuff));
            pqsConfig = (QUERY_SERVICE_CONFIG*)pqsConfigBuff;

            if ( QueryServiceConfig (
                    hService, 
                    pqsConfig,
                    sizeof(pqsConfigBuff), 
                    &dwMoreBytes)) {
                // See if the current status is different
                // from the selection. If it is, then change
                // the current mode.
                if ( bAutoStart ) {
                    if ( SERVICE_DEMAND_START == pqsConfig->dwStartType ) {
                        bUpdate = TRUE;
                    }
                } else {
                    // Manual start selected
                    if ( SERVICE_AUTO_START == pqsConfig->dwStartType ) {
                        bUpdate = TRUE;
                    }
                }
            } else {
                // else unable to read the current status so update anyway
                bUpdate = TRUE;
            }

            if ( bUpdate ) {
                MFC_TRY
                    parrSingleFailAction = new SC_ACTION[3];
                MFC_CATCH_DWSTATUS;

                if ( NULL != parrSingleFailAction ) {
                    parrSingleFailAction[0].Delay = eRestartDelayMilliseconds;
                    parrSingleFailAction[1].Delay = eRestartDelayMilliseconds;
                    parrSingleFailAction[2].Delay = eRestartDelayMilliseconds;

                    if ( bAutoStart ) {
                        parrSingleFailAction[0].Type = SC_ACTION_RESTART;
                        parrSingleFailAction[1].Type = SC_ACTION_RESTART;
                        parrSingleFailAction[2].Type = SC_ACTION_RESTART;
                    } else {
                        parrSingleFailAction[0].Type = SC_ACTION_NONE;
                        parrSingleFailAction[1].Type = SC_ACTION_NONE;
                        parrSingleFailAction[2].Type = SC_ACTION_NONE;
                    }

                    structFailActions.dwResetPeriod = eResetDelaySeconds;
                    structFailActions.lpRebootMsg = NULL;
                    structFailActions.lpCommand = NULL;
                    structFailActions.cActions = 3;
                    structFailActions.lpsaActions = parrSingleFailAction;

                    bStatus = ChangeServiceConfig (
                        hService,
                        SERVICE_NO_CHANGE,
                        (bAutoStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START),
                        SERVICE_NO_CHANGE,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL );

                    if ( 0 == bStatus ) {
                        dwStatus = GetLastError();
                    } else {
                        bStatus = ChangeServiceConfig2 (
                            hService,
                            SERVICE_CONFIG_FAILURE_ACTIONS,
                            &structFailActions );
                        if ( 0 == bStatus ) {
                            dwStatus = GetLastError();
                        }
                    }
                    delete parrSingleFailAction;

                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }

            CloseServiceHandle (hService);

        } else {
            dwStatus = GetLastError();
            ASSERT (dwStatus != 0);
        }

        CloseServiceHandle (hSC);

    } else {
         dwStatus = GetLastError();
    } // OpenSCManager

    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match
//  
DWORD   CSmLogService::SyncWithRegistry ( void )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    CString     strDesc;
    ResourceStateManager    rsm;

    // Unload queries and reload, to capture new queries.
    // This is necessary for monitoring remote systems,
    // and if multiple users are active on the same system.

    dwStatus = UnloadQueries ();

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = LoadQueries ();
    }
    return dwStatus;
}

DWORD
CSmLogService::GetState( void )
{
    // Check the status of the log service via the service controller.
    // 0 returned in case of error.
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwState = 0;        // Error by default.
    SERVICE_STATUS  ssData;
    SC_HANDLE   hSC;
    SC_HANDLE   hLogService;

    // open SC database
    hSC = OpenSCManager ( GetMachineName(), NULL, SC_MANAGER_CONNECT);

    if (hSC != NULL) {
    
        // open service
        hLogService = OpenService (
                        hSC, 
                        TEXT("SysmonLog"),
                        SERVICE_INTERROGATE );
    
        if (hLogService != NULL) {
            if ( ControlService (
                    hLogService, 
                    SERVICE_CONTROL_INTERROGATE,
                    &ssData)) {

                dwState = ssData.dwCurrentState;
            } else {
                dwStatus = GetLastError();
                dwState = SERVICE_STOPPED;
            }

            CloseServiceHandle (hLogService);
        
        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);
    } else {
        dwStatus = GetLastError();
    } // OpenSCManager

    return dwState;
}

BOOL
CSmLogService::IsRunning( void )
{
    DWORD dwState = GetState();
    BOOL bRunning = FALSE;

    if ( 0 != dwState
            && SERVICE_STOPPED != dwState
            && SERVICE_STOP_PENDING != dwState ) {
        bRunning = TRUE;
    }
    return bRunning;
}

DWORD
CSmLogService::CreateDefaultLogQueries( void )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pQuery = NULL;
    CString     strTemp;
    CString     strModuleName;
    BOOL        bRegistryUpdated;
    BOOL        bDupFound = FALSE;

    ResourceStateManager    rsm;

    // Creates default "System Overview" counter log query

    MFC_TRY
        strTemp.LoadString ( IDS_DEFAULT_CTRLOG_QUERY_NAME );
    MFC_CATCH_DWSTATUS;


    if ( ERROR_SUCCESS == dwStatus ) {    
        pQuery = CreateTypedQuery ( strTemp, SLQ_COUNTER_LOG );

        if ( NULL != pQuery && !IsWindows2000Server() ) {
            // Default query collection name is stored as MUI indirect string after Windows 2000    
            MFC_TRY
                ::GetModuleFileName(
                    AfxGetInstanceHandle(), 
                    strModuleName.GetBufferSetLength(MAX_PATH), 
                    MAX_PATH );

                strTemp.Format (_T("@%s,-%d"), strModuleName, IDS_DEFAULT_CTRLOG_QUERY_NAME );
                strModuleName.ReleaseBuffer();

            MFC_CATCH_DWSTATUS;

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = RegSetValueEx (
                    pQuery->GetQueryKey(),
                    L"Collection Name Indirect",
                    0L,
                    REG_SZ,
                    (CONST BYTE *)strTemp.GetBufferSetLength( strTemp.GetLength() ),
                    strTemp.GetLength()*sizeof(WCHAR) );

                strTemp.ReleaseBuffer();
            }
                    
            // CreateTypedQuery checks for the existence of the default query
            // using the the query name.
            // Check for the existence of the default query under the MUI indirect 
            // name as well.  
    
            if ( NULL != pQuery ) {
                if ( ERROR_SUCCESS == dwStatus ) {
                    FindDuplicateQuery ( strTemp, bDupFound );
                    if ( bDupFound ) {
                        DeleteQuery ( pQuery );
                        pQuery = NULL;
                        dwStatus = ERROR_SUCCESS;
                    }
                }
            }
        }

        if ( NULL != pQuery ) {
            SLQ_TIME_INFO slqTime;
            PSLCTRQUERY pCtrQuery = NULL;

            MFC_TRY
                pCtrQuery = pQuery->CastToCounterLogQuery();
        
                pCtrQuery->SetFileNameAutoFormat ( SLF_NAME_NONE );
                pCtrQuery->SetLogFileType ( SLF_BIN_FILE );
                pCtrQuery->SetDataStoreAppendMode ( SLF_DATA_STORE_OVERWRITE );

                strTemp.LoadString ( IDS_DEFAULT_CTRLOG_COMMENT );
                pCtrQuery->SetLogComment ( strTemp );
                
                if ( !IsWindows2000Server() ) {
                    strTemp.Format (_T("@%s,-%d"), strModuleName, IDS_DEFAULT_CTRLOG_COMMENT );
                    pCtrQuery->SetLogCommentIndirect ( strTemp );
                }

                strTemp.LoadString ( IDS_DEFAULT_CTRLOG_FILE_NAME );
                pCtrQuery->SetLogFileName ( strTemp );

                if ( !IsWindows2000Server() ) {
                    strTemp.Format (_T("@%s,-%d"), strModuleName, IDS_DEFAULT_CTRLOG_FILE_NAME );
                    pCtrQuery->SetLogFileNameIndirect ( strTemp );
                }

                pCtrQuery->AddCounter ( CGlobalString::m_cszDefaultCtrLogCpuPath );
                pCtrQuery->AddCounter ( CGlobalString::m_cszDefaultCtrLogMemoryPath );
                pCtrQuery->AddCounter ( CGlobalString::m_cszDefaultCtrLogDiskPath );

                // Start mode and time 

                memset (&slqTime, 0, sizeof(slqTime));
                slqTime.wTimeType = SLQ_TT_TTYPE_START;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                slqTime.llDateTime = MAX_TIME_VALUE;

                pCtrQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);

                // Stop mode and time
    
                slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                slqTime.llDateTime = MIN_TIME_VALUE;

                pCtrQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);

                pCtrQuery->UpdateService( bRegistryUpdated );

                // Set the default log to Execute Only.

                dwStatus = pCtrQuery->UpdateExecuteOnly ();

            MFC_CATCH_DWSTATUS
            
            if ( ERROR_SUCCESS == dwStatus && NULL != pCtrQuery ) {
                VERIFY ( ERROR_SUCCESS == UnloadSingleQuery ( pCtrQuery ) );
            } else if ( NULL != pCtrQuery ) {
                DeleteQuery ( pCtrQuery );
            }
        } else {
            dwStatus = GetLastError();

            if ( SMCFG_DUP_QUERY_NAME == dwStatus ) {
                dwStatus = ERROR_SUCCESS;
            }
        }
    }
    return dwStatus;
}


DWORD
CSmLogService::Install ( 
    const   CString&  rstrMachineName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDisposition = 0;
    HKEY    hKeyPerfLog = NULL;
    CString strValueName;
    DWORD   dwType;
    DWORD   dwRegValue;
    DWORD   dwBufferSize;
    BOOL    bReadOnlyPerfLogKey = FALSE;
    BOOL    bReadOnlyLogQueriesKey = FALSE;

    ResourceStateManager   rsm;

    //
    // Get machine OS version
    //
    PdhiPlaGetVersion( rstrMachineName, &m_OSVersion );

    if ( NULL == m_hKeyMachine ) {
        if ( rstrMachineName.IsEmpty() ) {
            m_hKeyMachine = HKEY_LOCAL_MACHINE;
        } else {
            dwStatus = RegConnectRegistryW (
                rstrMachineName,
                HKEY_LOCAL_MACHINE,
                &m_hKeyMachine);
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {    
        dwStatus = RegOpenKeyEx (
                        m_hKeyMachine,
                        TEXT("System\\CurrentControlSet\\Services\\SysmonLog"),
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKeyPerfLog);
        if (dwStatus != ERROR_SUCCESS) {
            // unable to access the key for write access, so try read only
            dwStatus = RegOpenKeyEx (
                            m_hKeyMachine,
                            TEXT("System\\CurrentControlSet\\Services\\SysmonLog"),
                            0,
                            KEY_READ,
                            &hKeyPerfLog);
            if ( ERROR_SUCCESS == dwStatus ) {
                bReadOnlyPerfLogKey = TRUE;
            }
        }
    }

    EnterCriticalSection ( &g_critsectInstallDefaultQueries );

    // In Windows 2000, the Log Queries key is created by the snapin.
    // After Windows 2000, the Log Queries key is created by system setup,
    // along with a "Default Installed" registry flag.
    if ( ERROR_SUCCESS == dwStatus && NULL == m_hKeyLogService ) {

        if ( !bReadOnlyPerfLogKey ) {
            // add registry subkey for Log Queries
            dwStatus = RegCreateKeyEx (
                            hKeyPerfLog,
                            TEXT("Log Queries"),
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &m_hKeyLogService,
                            &dwDisposition);
        } else {
            // ReadOnly SysmonLog key.  Still possible to succeed if Log Queries 
            // exists with read/write access.
            dwStatus = RegOpenKeyEx (
                            m_hKeyMachine,
                            TEXT("System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries"),
                            0,
                            KEY_READ | KEY_WRITE,
                            &m_hKeyLogService);
            
            if (dwStatus == ERROR_SUCCESS) {
                bReadOnlyLogQueriesKey = FALSE;
            } else {
                // unable to access the key for write access, so try read only
                dwStatus = RegOpenKeyExW (
                    m_hKeyMachine,
                    (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                    0,
                    KEY_READ,
                    &m_hKeyLogService);

                if ( ERROR_SUCCESS == dwStatus ) {
                    bReadOnlyLogQueriesKey = TRUE;
                }
            }
        }
    } else if ( m_bReadOnly ) {
        bReadOnlyLogQueriesKey = TRUE;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // Log queries key now exists.

        strValueName = CGlobalString::m_cszDefaultsInstalled;
        dwType = REG_DWORD;
        dwRegValue = 0;        
        dwBufferSize = sizeof(DWORD);

        dwStatus = RegQueryValueExW (
                    m_hKeyLogService, 
                    strValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwRegValue,
                    &dwBufferSize );

        if ( ERROR_SUCCESS != dwStatus 
                || 0 == dwRegValue ) 
        { 
            if ( !bReadOnlyLogQueriesKey ) {
                // Create default counter log query.
                // Todo:  Message on error.
                dwStatus = CreateDefaultLogQueries();
            
                if ( ERROR_SUCCESS == dwStatus ) {
    
                   dwRegValue = SLQ_DEFAULT_SYS_QUERY;
                   dwStatus = RegSetValueEx (
                        m_hKeyLogService, 
                        strValueName, 
                        0L,
                        REG_DWORD,
                        (CONST BYTE *)&dwRegValue,
                        dwBufferSize);
                }
            } else {
                dwStatus = SMCFG_NO_INSTALL_ACCESS;
            }
        }
    }
  
    if ( ERROR_SUCCESS == dwStatus ) {    
        RegFlushKey ( m_hKeyLogService );
        // Ignore status.
    }
    
    LeaveCriticalSection ( &g_critsectInstallDefaultQueries );

    if (NULL != hKeyPerfLog ) {
        RegCloseKey (hKeyPerfLog);
    }

    if ( ERROR_ACCESS_DENIED == dwStatus ) {
        dwStatus = SMCFG_NO_INSTALL_ACCESS;
    }
    return dwStatus;
}

DWORD
CSmLogService::Synchronize( void )
{
    // If the service is running, tell it to synchronize itself,
    // Check the state afterwards to see if it got the message.
    // If stop pending or stopped, wait until the service is
    // stopped and then attempt to start it.  The service 
    // synchronizes itself from the registry when it is started.

    // Return 0 for success, other for failure.

    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    SERVICE_STATUS  ssData;
    DWORD       dwCurrentState;
    DWORD       dwTimeout = 50;
    LONG        dwStatus = ERROR_SUCCESS;
    BOOL        bServiceStarted = FALSE;
    
    dwCurrentState = GetState();

    if ( 0 == dwCurrentState ) {
        dwStatus = 1;
    } else {
        // open SC database
        hSC = OpenSCManager ( GetMachineName(), NULL, GENERIC_READ);
        if ( NULL != hSC ) {
            // open service
            hService = OpenService (
                            hSC, 
                            TEXT("SysmonLog"),
                            SERVICE_USER_DEFINED_CONTROL 
                            | SERVICE_START );

            if ( NULL != hService ) {
                if ( ( SERVICE_STOPPED != dwCurrentState ) 
                    && ( SERVICE_STOP_PENDING != dwCurrentState ) ) {
                            
                    // Wait 100 milliseconds before synchronizing service,
                    // to ensure that registry values are written.
                    Sleep ( 100 );

                    ControlService ( 
                        hService, 
                        SERVICE_CONTROL_SYNCHRONIZE, 
                        &ssData);
                    
                    dwCurrentState = ssData.dwCurrentState;
                }

                // Make sure that the ControlService call reached the service
                // while it was in run state.
                if ( ( SERVICE_STOPPED == dwCurrentState ) 
                    || ( SERVICE_STOP_PENDING == dwCurrentState ) ) {
                    
                    if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                        // wait for the service to stop before starting it.
                        while (--dwTimeout) {
                            dwCurrentState = GetState();
                            if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                                Sleep(200);
                            } else {
                                break;
                            }
                        }
                    }

                    dwTimeout = 50;
                    if ( SERVICE_STOPPED == dwCurrentState ) {
                        bServiceStarted = StartService (hService, 0, NULL);
                        if ( !bServiceStarted ) {
                            dwStatus = GetLastError();
                            if ( ERROR_SERVICE_ALREADY_RUNNING == dwStatus ) {
                                // Okay if started during the time window since
                                // the last GetState() call.
                                dwStatus = ERROR_SUCCESS;
                                bServiceStarted = TRUE;
                            } // else error
                        }

                        if ( bServiceStarted ) {
                            // wait for the service to start or stop 
                            // before returning
                            while (--dwTimeout) {
                                dwCurrentState = GetState();
                                if ( SERVICE_START_PENDING == dwCurrentState ) {
                                    Sleep(200);
                                } else {
                                    break;
                                }
                            }
                        }
                    } 
                }
                CloseServiceHandle (hService);
            } else {                
                dwStatus = GetLastError();
            }
            CloseServiceHandle (hSC);

        } else {
            dwStatus = GetLastError();
        }
    }    
    
    // Update the Auto Start service config.
    if ( ERROR_SUCCESS == dwStatus ) {
        // Ignore errors
        UpdateConfig();
    }
    return dwStatus;
}

void
CSmLogService::SetBaseName( const CString& rstrName )
{
    // This method is only called within the service constructor,
    // so throw any errors
    m_strBaseName = rstrName;
    return;
}


const CString&
CSmLogService::GetDefaultLogFileFolder()
{
    if ( m_strDefaultLogFileFolder.IsEmpty() ) {
        LoadDefaultLogFileFolder();
    }
    return m_strDefaultLogFileFolder;
}


INT
CSmLogService::GetQueryCount()
{
    INT iQueryCount = -1;
    
    // The query count is only valid if the service is open.
    if ( IsOpen() ) {
        iQueryCount = (int) m_QueryList.GetCount();
    } else {
        ASSERT ( FALSE );
    }
    return iQueryCount;
}

DWORD
CSmLogService::FindDuplicateQuery (
                    const CString cstrName,
                    BOOL& rbFound )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hrLocal = NOERROR;
    DWORD   dwQueryIndex = 0;
    LONG    lEnumStatus = ERROR_SUCCESS;
    WCHAR   szQueryKeyName[MAX_PATH + 1];
    DWORD   dwQueryKeyNameLen;
    LPTSTR  szCollectionName = NULL;
    UINT    uiCollectionNameLen = 0;
    FILETIME    ftLastWritten;
    HKEY    hKeyQuery = NULL;
    BOOL    bFoundFirst = FALSE;
    CString strDirectName;
    CString strLocalName;

    ASSERT ( !cstrName.IsEmpty() );

    rbFound = FALSE;
    if ( !cstrName.IsEmpty() ) {

        MFC_TRY
            strLocalName = cstrName;
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {

            // Translate new query name if necessary
            hrLocal = SHLoadIndirectString( 
                strLocalName.GetBufferSetLength ( strLocalName.GetLength() ), 
                strDirectName.GetBufferSetLength ( MAX_PATH ), 
                MAX_PATH, 
                NULL );

            strLocalName.ReleaseBuffer();
            strDirectName.ReleaseBuffer();

            if ( FAILED ( hrLocal ) ) {
                // Query name is not an indirect string
                dwStatus = ERROR_SUCCESS;
                MFC_TRY
                    strDirectName = strLocalName;
                MFC_CATCH_DWSTATUS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        // Search all queries for the specified query.

        dwQueryKeyNameLen = sizeof ( szQueryKeyName ) / sizeof ( WCHAR );
        memset (szQueryKeyName, 0, sizeof (szQueryKeyName));

        while ( ERROR_SUCCESS == ( lEnumStatus = RegEnumKeyExW (
                                                    m_hKeyLogService,
                                                    dwQueryIndex, 
                                                    szQueryKeyName, 
                                                    &dwQueryKeyNameLen,
                                                    NULL, 
                                                    NULL, 
                                                    NULL, 
                                                    &ftLastWritten ) ) ) {

            // open the query specified
            dwStatus = RegOpenKeyExW (
                m_hKeyLogService,
                szQueryKeyName,
                0,
                KEY_READ,
                &hKeyQuery);

            if ( ERROR_SUCCESS == dwStatus ) {

                // Query key is Guid if written by post Win2000 snapin.
                // Query key is name if written by Win2000 snapin.
                if ( 0 == strDirectName.CompareNoCase ( szQueryKeyName ) ) {
                    if ( TRUE == bFoundFirst ) {
                        rbFound = TRUE;
                        break;
                    } else {
                        bFoundFirst = TRUE;
                    }
                } else { 

                    dwStatus = SmReadRegistryIndirectStringValue (
                                hKeyQuery,
                                L"Collection Name",
                                NULL,
                                &szCollectionName,
                                &uiCollectionNameLen );

                    ASSERT ( MAX_PATH >= uiCollectionNameLen );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( MAX_PATH >= uiCollectionNameLen ) {
                            if ( NULL != szCollectionName ) {
                                if ( L'\0' == *szCollectionName ) {
                                    G_FREE ( szCollectionName );
                                    szCollectionName = NULL;
                                }
                            }

                            if ( NULL == szCollectionName ) {
                                MFC_TRY
                                    szCollectionName = (LPWSTR)G_ALLOC ( (lstrlen(szQueryKeyName)+1)*sizeof(WCHAR));
                                MFC_CATCH_DWSTATUS;
                                if ( ERROR_SUCCESS == dwStatus ) {
                                    lstrcpyn ( szCollectionName, szQueryKeyName, lstrlen(szQueryKeyName)+1 );
                                }
                            } 

                            if ( NULL != szCollectionName ) {

                                // Compare found name to input name.
                                if ( 0 == strDirectName.CompareNoCase ( szCollectionName ) ) {
                                    if ( TRUE == bFoundFirst ) {
                                        rbFound = TRUE;
                                        break;
                                    } else {
                                        bFoundFirst = TRUE;
                                    }
                                }
                            } // Todo:  else report message?
                        }
                    } // Todo:  else report message?
                } // Todo:  else report message?
            }

            // set up for the next item in the list
            dwQueryKeyNameLen = sizeof (szQueryKeyName) / sizeof (szQueryKeyName[0]);
            memset (szQueryKeyName, 0, sizeof (szQueryKeyName));
            if ( NULL != hKeyQuery ) {
                RegCloseKey( hKeyQuery );
                hKeyQuery = NULL;
            }

            if ( NULL != szCollectionName ) {
                G_FREE ( szCollectionName );
                szCollectionName = NULL;
                uiCollectionNameLen = 0;
            }
            dwQueryIndex++;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( NULL != szCollectionName ) {
        G_FREE ( szCollectionName );
        szCollectionName = NULL;
        uiCollectionNameLen = 0;
    }

    if ( NULL != hKeyQuery ) {
        RegCloseKey( hKeyQuery );
        hKeyQuery = NULL;
    }

    return dwStatus;
}

BOOL    
CSmLogService::IsWindows2000Server ( void )
{
    if ( 5 == m_OSVersion.dwMajorVersion && 2195 == m_OSVersion.dwBuild ) {
        return TRUE;
    }

    return FALSE;
}
BOOL
CSmLogService::CanAccessWbemRemote()
{
    HRESULT hr;
    IWbemLocator *pLocator = NULL;
    IWbemServices* pWbemServices = NULL;
    LPCWSTR szRoot[2] = { L"root\\perfmon",
                          L"root\\wmi"
                        };
    LPCWSTR szMask = L"\\\\%s\\%s";
    BSTR bszClass = SysAllocString(L"SysmonLog");
    BSTR bszNamespace = NULL;
    LPWSTR buffer = NULL;
    DWORD  dwBufLen;

    hr = CoCreateInstance(
                CLSID_WbemLocator,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator,
                (LPVOID*)&pLocator );

    if (!SUCCEEDED(hr)) {
        goto Cleanup;
    }

    if ( !GetMachineName().IsEmpty()) {

        dwBufLen = max(wcslen(szRoot[0]), wcslen(szRoot[1])) +
                   GetMachineName().GetLength() +
                   wcslen( szMask );

        buffer = new WCHAR[dwBufLen];

        if ( buffer == NULL ){
            hr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    for (int i = 0; i < 2; i++) {
        if (bszNamespace) {
            SysFreeString(bszNamespace);
            bszNamespace = NULL;
        }
        
        if (buffer) {
            swprintf( buffer, szMask, GetMachineName(), szRoot[i] );
            bszNamespace = SysAllocString( buffer );
        }
        else {
            bszNamespace = SysAllocString(szRoot[i]);
        }

        hr = pLocator->ConnectServer(
                    bszNamespace,
                    NULL,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    &pWbemServices);
        if (SUCCEEDED(hr)) {
            break;
        }
    }

Cleanup:
    if (buffer) {
        delete [] buffer;
    }

    if (bszNamespace) {
        SysFreeString(bszNamespace);
    }

    if (pLocator) {
        pLocator->Release();
    }

    if (pWbemServices) {
        pWbemServices->Release();
    }

    m_hWbemAccessStatus = hr;
    if (SUCCEEDED(hr)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smlogres.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogres.h

Abstract:

    Resource identifiers for the Performance Logs and Alerts
    MMC snap-in.

--*/

#define IDC_RUNAS_EDIT                  3001
#define IDC_SETPWD_BTN                  3002
// Use IDC_STATIC for RunAs caption, to eliminate 
// "No help topic" context help message.

#define IDB_NODES_16x16                 201
#define IDB_NODES_32x32                 202
#define IDB_TOOLBAR_RES                 203
#define IDB_SMLOGCFG_16x16              204
#define IDB_SMLOGCFG_32x32              205
#define IDB_TOOLBAR_RES_RTL             206

#define IDI_SMLOGCFG                    220
#define IDR_COMPONENTDATA               501
#define IDR_COMPONENT                   502
#define IDR_EXTENSION                   503
#define IDR_PERFORMANCEABOUT            504

#define IDS_PROJNAME                    500
#define IDS_ERRMSG_OUTOFMEMORY          501
#define IDS_ERRMSG_UNABLEALLOCDATAOBJECT 502
#define IDS_MMC_DEFAULT_NAME            503
#define IDS_ERRMSG_UNKDATAOBJ           504
#define IDS_MMC_SERVNOTINST             505
#define IDS_FT_TSV                      506
#define IDS_FT_CSV                      507
#define IDS_FT_SQL                      508 
#define IDS_FT_BINARY                   509
#define IDS_FT_BINARY_CIRCULAR          510
#define IDS_FT_CIRCULAR_TRACE           511
#define IDS_FT_SEQUENTIAL_TRACE         512
#define IDS_FT_UNKNOWN                  513
#define IDS_FS_MMDDHH                   514
#define IDS_FS_NNNNNN                   515
#define IDS_FS_YYYYDDD                  516
#define IDS_FS_YYYYMM                   517
#define IDS_FS_YYYYMMDD                 518
#define IDS_FS_YYYYMMDDHH               519
#define IDS_FS_MMDDHHMM                 520
#define IDS_SECONDS                     521
#define IDS_HOURS                       522
#define IDS_MINUTES                     523
#define IDS_DAYS                        524
#define IDS_BROWSE_CMD_FILE_CAPTION     525
#define IDS_BROWSE_CMD_FILE_FILTER1     526
#define IDS_BROWSE_CMD_FILE_FILTER2     527
#define IDS_BROWSE_CMD_FILE_FILTER3     528
#define IDS_BROWSE_CMD_FILE_FILTER4     529
#define IDS_SCHED_FILE_SIZE_DISPLAY     530
#define IDS_SCHED_FILE_MAX_SIZE_DISPLAY 531
#define IDS_SCHED_START_LOG_GROUP       534   
#define IDS_SCHED_STOP_LOG_GROUP        535
#define IDS_SCHED_RESTART_LOG           536
#define IDS_SCHED_STOP_LOG_WHEN         537
#define IDS_FILE_CIRC_SET_MANUAL_STOP   538
#define IDS_FILE_MAX_SET_MANUAL_STOP    539
#define IDS_FILE_DIR_NOT_FOUND          540
#define IDS_FILE_DIR_NOT_MADE           541
#define IDS_DIR_NOT_MADE                542
#define IDS_FILE_DIR_CREATE_CANCEL      543
#define IDS_DIR_CREATE_CANCEL           544
#define IDS_FT_EXT_CSV                  545
#define IDS_FT_EXT_TSV                  547
#define IDS_FT_EXT_BLG                  548
#define IDS_FT_EXT_ETL                  549
#define IDS_LOCAL                       550
#define IDS_ON                          551
#define IDS_SCHED_SESSION_TOO_SHORT     552
#define IDS_ERRMSG_GENERAL              553

#define IDS_MMC_MENU_NEW_PERF_LOG       560
#define IDS_MMC_STATUS_NEW_PERF_LOG     561
#define IDS_MMC_MENU_PERF_LOG_FROM      562
#define IDS_MMC_STATUS_PERF_LOG_FROM    563
#define IDS_MMC_MENU_NEW_TRACE_LOG      564
#define IDS_MMC_STATUS_NEW_TRACE_LOG    565
#define IDS_MMC_MENU_TRACE_LOG_FROM     566
#define IDS_MMC_STATUS_TRACE_LOG_FROM   567
#define IDS_MMC_MENU_NEW_ALERT          568
#define IDS_MMC_STATUS_NEW_ALERT        569
#define IDS_MMC_MENU_ALERT_FROM         570
#define IDS_MMC_STATUS_ALERT_FROM       571
#define IDS_MMC_MENU_START              572
#define IDS_MMC_STATUS_START            573
#define IDS_MMC_MENU_STOP               574
#define IDS_MMC_STATUS_STOP             575
#define IDS_MMC_MENU_SAVE_AS            576
#define IDS_MMC_STATUS_SAVE_AS          577
#define IDS_BUTTON_NEW_LOG              578
#define IDS_BUTTON_START_LOG            579
#define IDS_BUTTON_STOP_LOG             580
#define IDS_BUTTON_NEW_ALERT            581
#define IDS_BUTTON_START_ALERT          582
#define IDS_BUTTON_STOP_ALERT           583
#define IDS_TOOLTIP_NEW_LOG             584
#define IDS_TOOLTIP_START_LOG           585
#define IDS_TOOLTIP_STOP_LOG            586
#define IDS_TOOLTIP_NEW_ALERT           587
#define IDS_TOOLTIP_START_ALERT         588
#define IDS_TOOLTIP_STOP_ALERT          589
#define IDS_SCHED_RESTART_ALERT         590
#define IDS_COUNTER_FILETYPE_FILTER     591
#define IDS_TRACE_FILETYPE_FILTER       592
#define IDS_SELECT_FILE_FOLDER          593

#define IDS_CTRS_REQUIRED               600
#define IDS_ERRMSG_DELETE_RUNNING_QUERY 601
#define IDS_ERRMSG_DELETE_TEMPLATE_QRY  602
#define IDS_ERRMSG_DELETE_OPEN_QUERY    603
#define IDS_ERRMSG_QUERY_DELETED        604
#define IDS_ERRMSG_START_OPEN_QUERY     605
#define IDS_ERRMSG_STOP_OPEN_QUERY      606
#define IDS_TRACE_MAX_BUFF              607
#define IDS_ERRMSG_WBEMERROR            608
#define IDS_CANCEL_AUTO_RESTART         610 // Skip 609
#define IDS_SCHED_NOW_PAST_STOP         611
#define IDS_SCHED_START_PAST_STOP       612
#define IDS_CTRS_DUPL_PATH_NOT_ADDED    613
#define IDS_CTRS_DUPL_PATH_DELETED      614
#define IDS_CTRS_PDH_ERROR              615
#define IDS_PROV_NAME                   616
#define IDS_PROV_STATUS                 617
#define IDS_PROV_ENABLED                618
#define IDS_PROV_UNKNOWN                619
#define IDS_PROV_NO_PROVIDERS           620
#define IDS_SAMPLE_CMD_PATH             621
#define IDS_SAMPLE_CMD_MEAS_VAL         622
#define IDS_SAMPLE_CMD_LIMIT_VAL        623
#define IDS_DEFAULT_PATH_OBJ_CTR        624
#define IDS_SELECT_COUNTERS             625
#define IDS_FILE_ERR_NAMETOOLONG        626
#define IDS_FILE_ERR_NOFOLDERNAME       627
#define IDS_FILE_ERR_NOFILENAME         628
#define IDS_FILENAMETOOLONG             629
#define IDS_ERRMSG_SERVICE_ERROR        630
#define IDS_ERRMSG_INVALIDDWORD         631
#define IDS_ERRMSG_INVALIDDOUBLE        632
#define IDS_ERRMSG_SAMPLEINTTOOLARGE    633
#define IDS_ADD_COUNTERS                634
#define IDS_ADD_OBJECTS                 635
#define IDS_BAD_PASSWORD_MATCH          636
#define IDS_PASSWORD_TITLE              637
#define IDS_PASSWORD_SET                638
#define IDS_SQL_ERR_NOLOGSETNAME        639
#define IDS_SQL_ERR_NODSN               640
#define IDS_ALERT_DUPL_PATH             641

#define IDS_ALERT_CHECK_LIMITS          701
#define IDS_ACTION_ERR_NOLOGNAME        702
#define IDS_ACTION_ERR_NOCMDFILE        703
#define IDS_ACTION_ERR_NONETNAME        704
#define IDS_OVER                        705
#define IDS_UNDER                       706
#define IDS_ACTION_ERR_NOACTION         707
#define IDS_CREATE_NEW_ALERT            708
#define IDS_ALERT_LOG_TYPE              709
#define IDS_NO_COUNTERS                 710
#define IDS_LOG_START_MANUALLY          711
#define IDS_LOG_START_IMMED             712
#define IDS_LOG_START_SCHED             713
#define IDS_KERNEL_PROVIDERS_REQUIRED   714
#define IDS_APP_PROVIDERS_REQUIRED      715
#define IDS_ALERT_START_MANUALLY        716
#define IDS_ALERT_START_IMMED           717
#define IDS_ALERT_START_SCHED           718
#define IDS_SERVICE_NAME_ALERT          719
#define IDS_SERVICE_NAME_COUNTER        720
#define IDS_SERVICE_NAME_TRACE          721
#define IDS_SNAPINABOUT_PROVIDER        722
#define IDS_SNAPINABOUT_VERSION         723
#define IDS_SNAPINABOUT_DESCRIPTION     724
#define IDS_ROOT_NODE_DESCRIPTION       725
#define IDS_COUNTER_NODE_DESCRIPTION    726
#define IDS_TRACE_NODE_DESCRIPTION      727
#define IDS_ALERT_NODE_DESCRIPTION      728
#define IDS_ALERT_CHECK_LIMIT_VALUE     729

#define IDS_DEFAULT_CTRLOG_QUERY_NAME   731
#define IDS_DEFAULT_CTRLOG_CPU_PATH     732
#define IDS_DEFAULT_CTRLOG_MEMORY_PATH  733
#define IDS_DEFAULT_CTRLOG_DISK_PATH    734
#define IDS_DEFAULT_CTRLOG_COMMENT      735
#define IDS_MMC_DEFAULT_EXT_NAME        736
#define IDS_ROOT_COL_QUERY_NAME         737
#define IDS_ROOT_COL_COMMENT            738
#define IDS_ROOT_COL_LOG_TYPE           739
#define IDS_ROOT_COL_LOG_FILE_NAME      740
#define IDS_MAIN_COL_NODE_NAME          741
#define IDS_MAIN_COL_NODE_DESCRIPTION   742
#define IDS_EXTENSION_COL_TYPE          743
#define IDS_DEFAULT_CTRLOG_FILE_NAME    744
// Copy/Paste
#define IDS_HTML_OBJECT_CLASSID         800
#define IDS_HTML_OBJECT_HEADER          801
#define IDS_HTML_OBJECT_FOOTER          802
#define IDS_HTML_PARAM_TAG              803
#define IDS_HTML_VALUE_TAG              804
#define IDS_HTML_VALUE_EOL_TAG          805
#define IDS_HTML_PARAM_SEARCH_TAG       806
#define IDS_HTML_VALUE_SEARCH_TAG       807
#define IDS_HTML_BOL_SEARCH_TAG         808
#define IDS_HTML_EOL_SEARCH_TAG         809

// Save As
#define IDS_HTML_FILE                   810
#define IDS_HTML_EXTENSION              811
#define IDS_HTML_FILE_HEADER1           812
#define IDS_HTML_FILE_HEADER2           813
#define IDS_HTML_FILE_FOOTER            814
#define IDS_HTML_FILE_OVERWRITE         815

// Property/Parameter names for HTML files and registry
#define IDS_REG_COMMENT                 816
#define IDS_REG_LOG_TYPE                817
#define IDS_REG_CURRENT_STATE           818
#define IDS_REG_LOG_FILE_MAX_SIZE       819
#define IDS_REG_LOG_FILE_BASE_NAME      820
#define IDS_REG_LOG_FILE_FOLDER         821
#define IDS_REG_LOG_FILE_SERIAL_NUMBER  822
#define IDS_REG_LOG_FILE_AUTO_FORMAT    823
#define IDS_REG_LOG_FILE_TYPE           824
#define IDS_REG_START_TIME              825
#define IDS_REG_STOP_TIME               826
#define IDS_REG_RESTART                 827
#define IDS_REG_LAST_MODIFIED           828
#define IDS_REG_COUNTER_LIST            829
#define IDS_REG_SAMPLE_INTERVAL         830
#define IDS_REG_EOF_COMMAND_FILE        831
#define IDS_REG_COMMAND_FILE            832
#define IDS_REG_NETWORK_NAME            833
#define IDS_REG_USER_TEXT               834
#define IDS_REG_PERF_LOG_NAME           835
#define IDS_REG_ACTION_FLAGS            836
#define IDS_REG_TRACE_BUFFER_SIZE       837
#define IDS_REG_TRACE_BUFFER_MIN_COUNT  838
#define IDS_REG_TRACE_BUFFER_MAX_COUNT  839
#define IDS_REG_TRACE_BUFFER_FLUSH_INT  840
#define IDS_REG_TRACE_FLAGS             841
#define IDS_REG_TRACE_PROVIDER_LIST     842
#define IDS_REG_ALERT_THRESHOLD         843
#define IDS_REG_ALERT_OVER_UNDER        844
#define IDS_REG_TRACE_PROVIDER_COUNT    845
#define IDS_REG_TRACE_PROVIDER_GUID     846
#define IDS_DEFAULT_LOG_FILE_FOLDER     847
#define IDS_REG_COLLECTION_NAME         848
#define IDS_REG_DATA_STORE_ATTRIBUTES   849
#define IDS_REG_REALTIME_DATASOURCE     850
#define IDS_REG_SQL_LOG_BASE_NAME       851
#define IDS_REG_COMMENT_INDIRECT        852
#define IDS_REG_LOG_FILE_BASE_NAME_IND  853
#define IDS_REG_USER_TEXT_INDIRECT      854

// Values stored in registry but not in HTML
#define IDS_REG_EXECUTE_ONLY            890

#define IDS_HTML_COMMENT                900
#define IDS_HTML_LOG_TYPE               901
#define IDS_HTML_CURRENT_STATE          902
#define IDS_HTML_LOG_FILE_MAX_SIZE      903
#define IDS_HTML_LOG_FILE_BASE_NAME     904
#define IDS_HTML_LOG_FILE_FOLDER        905
#define IDS_HTML_LOG_FILE_SERIAL_NUMBER 906
#define IDS_HTML_LOG_FILE_AUTO_FORMAT   907
#define IDS_HTML_LOG_FILE_TYPE          908
#define IDS_HTML_EOF_COMMAND_FILE       909
#define IDS_HTML_COMMAND_FILE           910
#define IDS_HTML_NETWORK_NAME           911
#define IDS_HTML_USER_TEXT              912
#define IDS_HTML_PERF_LOG_NAME          913
#define IDS_HTML_ACTION_FLAGS           914
#define IDS_HTML_RESTART                915
#define IDS_HTML_TRACE_BUFFER_SIZE      916
#define IDS_HTML_TRACE_BUFFER_MIN_COUNT 917
#define IDS_HTML_TRACE_BUFFER_MAX_COUNT 918
#define IDS_HTML_TRACE_BUFFER_FLUSH_INT 919
#define IDS_HTML_TRACE_FLAGS            920
#define IDS_HTML_SYSMON_LOGFILENAME     921               
#define IDS_HTML_SYSMON_COUNTERCOUNT    922
#define IDS_HTML_SYSMON_SAMPLECOUNT     923
#define IDS_HTML_SYSMON_UPDATEINTERVAL  924
#define IDS_HTML_SYSMON_COUNTERPATH     925
#define IDS_HTML_RESTART_MODE           926                 
#define IDS_HTML_SAMPLE_INT_UNIT_TYPE   927                   
#define IDS_HTML_SAMPLE_INT_VALUE       928                   
#define IDS_HTML_START_MODE             929                   
#define IDS_HTML_START_AT_TIME          930                  
#define IDS_HTML_STOP_MODE              931                   
#define IDS_HTML_STOP_AT_TIME           932                   
#define IDS_HTML_STOP_AFTER_UNIT_TYPE   933                   
#define IDS_HTML_STOP_AFTER_VALUE       934                   
#define IDS_HTML_ALERT_THRESHOLD        935
#define IDS_HTML_ALERT_OVER_UNDER       936
#define IDS_HTML_TRACE_PROVIDER_COUNT   937
#define IDS_HTML_TRACE_PROVIDER_GUID    938
#define IDS_HTML_LOG_NAME               939
#define IDS_HTML_ALERT_NAME             940
#define IDS_HTML_SYSMON_VERSION         941
#define IDS_HTML_DATA_STORE_ATTRIBUTES  942
#define IDS_HTML_REALTIME_DATASOURCE    943
#define IDS_HTML_SQL_LOG_BASE_NAME      944

#define IDS_ERRMSG_COUNTER_LOG          1042
#define IDS_ERRMSG_ALERT_LOG            1043
#define IDS_ERRMSG_TRACE_LOG            1044
#define IDS_ERRMSG_SMCTRL_LOG           1045
#define IDS_COUNTER_LOG                 1046
#define IDS_ALERT_LOG			        1047
#define IDS_SMCTRL_LOG                  1048
#define IDS_ERRMSG_INVALIDCHAR          1049

// Command line arguments
#define IDS_CMDARG_SYSMONLOG_SETTINGS   990
#define IDS_CMDARG_SYSMONLOG_WMI        991

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2001
#define _APS_NEXT_COMMAND_VALUE         40010
#define _APS_NEXT_CONTROL_VALUE         2016
#define _APS_NEXT_SYMED_VALUE           2000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smctrsv.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrsv.cpp

Abstract:

    Implementation of the counter log service class, representing
    counter logs within the Performance Logs and Alerts service.

--*/

#include "Stdafx.h"
#include "smctrqry.h"
#include "smctrsv.h"

//
//  Constructor
CSmCounterLogService::CSmCounterLogService()
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    strTemp.LoadString ( IDS_SERVICE_NAME_COUNTER );
    SetBaseName ( strTemp ); 
    strTemp.LoadString ( IDS_COUNTER_NODE_DESCRIPTION );
    SetDescription( strTemp ); 
}

//
//  Destructor
CSmCounterLogService::~CSmCounterLogService()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_QueryList.GetHeadPosition() );
    return;
}

PSLQUERY    
CSmCounterLogService::CreateQuery ( const CString& rstrName )
{
    return ( CreateTypedQuery( rstrName, SLQ_COUNTER_LOG ) );
}

DWORD   
CSmCounterLogService::DeleteQuery ( PSLQUERY pQuery )
{
    ASSERT ( SLQ_COUNTER_LOG == pQuery->GetLogType() );
    return ( CSmLogService::DeleteQuery ( pQuery ) );
}

DWORD   
CSmCounterLogService::LoadQueries ( void )
{
    return ( CSmLogService::LoadQueries( SLQ_COUNTER_LOG ) );
}

//  
//  Open function. Opens all existing log query entries.
//
DWORD   
CSmCounterLogService::Open ( const CString& rstrMachineName)
{
    return ( CSmLogService::Open ( rstrMachineName ) );
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmCounterLogService::Close ()
{
    return ( CSmLogService::Close() );
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match.
//
//  
DWORD   
CSmCounterLogService::SyncWithRegistry()
{
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = CSmLogService::SyncWithRegistry();

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smlogqry.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogqry.h

Abstract:

    Class definitions for the CSmLogQuery base class. This object 
    is used to represent performance data log queries (a.k.a.
    sysmon log queries).

--*/

#ifndef _CLASS_SMLOGQRY_
#define _CLASS_SMLOGQRY_

#include "common.h"

// Data shared between property pages before OnApply is executed.
#define PASSWORD_CLEAN      0
#define PASSWORD_SET        1
#define PASSWORD_DIRTY      2

typedef struct _SLQ_PROP_PAGE_SHARED {
    DWORD   dwMaxFileSize;  // in units determined by dwFileSizeUnits - Set by files page
    DWORD   dwLogFileType;  // Set by files page
    SLQ_TIME_INFO   stiStartTime;   // Set by schedule page
    SLQ_TIME_INFO   stiStopTime;    // Set by schedule page.  Auto mode set by schedule and file pages.
    SLQ_TIME_INFO   stiSampleTime;  // Set by counters and alerts general page.  
    CString strFileBaseName;// Set by files page
    CString strFolderName;  // Set by files page
    CString strSqlName;     // Set by files page
    int     dwSuffix;       // Set by files page
    DWORD   dwSerialNumber; // Set by files page
} SLQ_PROP_PAGE_SHARED, *PSLQ_PROP_PAGE_SHARED;

class CSmLogService;
class CSmCounterLogQuery;
class CSmTraceLogQuery;
class CSmAlertQuery;
class CSmPropertyPage;

class CSmLogQuery
{
    // constructor/destructor
    public:
                CSmLogQuery( CSmLogService* );
        virtual ~CSmLogQuery( void );

    // public methods
    public:
        virtual DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly );
        virtual DWORD   Close ( void );

                DWORD   UpdateService( BOOL& rbRegistryUpdated );
                DWORD   UpdateServiceSchedule( BOOL& rbRegistryUpdated );
        
                DWORD   ManualStart( void );
                DWORD   ManualStop( void );
                DWORD   SaveAs( const CString& );

        virtual DWORD   SyncSerialNumberWithRegistry( void );
        virtual DWORD   SyncWithRegistry( void );

                HKEY    GetQueryKey( void );
                CSmLogService* GetLogService ( void );
                DWORD   GetMachineDisplayName ( CString& );

        virtual BOOL    GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags);
        virtual BOOL    SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags);
        virtual BOOL    GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags);

        virtual DWORD   GetLogType( void );

        virtual const   CString&    GetLogFileType ( void );
        virtual         void        GetLogFileType ( DWORD& rdwFileType );
        virtual         BOOL        SetLogFileType ( const DWORD dwType );
                        void  GetDataStoreAppendMode(DWORD &rdwAppend);
                        void  SetDataStoreAppendMode(DWORD dwAppend);

        virtual const   CString&    GetLogFileName ( BOOL bLatestRunning = FALSE );    // 2000.1 GetFileName->GetLogFileName
        virtual         DWORD       GetLogFileName ( CString& );         
                        DWORD       SetLogFileName ( const CString& rstrFileName );
                        DWORD       SetLogFileNameIndirect ( const CString& rstrFileName );

        virtual const   CString&    GetSqlName ( void );    
        virtual         DWORD       GetSqlName ( CString& );         
                        DWORD       SetSqlName ( const CString& rstrSqlName );

                        DWORD       GetFileNameParts ( CString& rstrFolder, CString& rstrName );
                        DWORD       SetFileNameParts (
                                        const CString& rstrFolder, 
                                        const CString& rstrName );

                        DWORD       GetFileNameAutoFormat ( void );
                        BOOL        SetFileNameAutoFormat ( const DWORD );

                        DWORD       GetFileSerialNumber( void );
                        BOOL        SetFileSerialNumber ( const DWORD );

                const   CString&    GetLogName ( void );
                        DWORD       GetLogName ( CString& );
                        DWORD       SetLogName ( const CString& rstrLogName );

                const   CString&    GetLogKeyName ( void );
                        DWORD       GetLogKeyName ( CString& );
                        DWORD       SetLogKeyName ( const CString& rstrLogName );

                const   CString&    GetLogComment ( void );
                        DWORD       GetLogComment ( CString& );
                        DWORD       SetLogComment (const CString& rstrComment);
                        DWORD       SetLogCommentIndirect (const CString& rstrComment);

                        DWORD       GetMaxSize ( void );
                        BOOL        SetMaxSize ( const DWORD dwMaxSize );

                        DWORD       GetDataStoreSizeUnits ( void ){ return mr_dwFileSizeUnits; };

                        DWORD       GetEofCommand ( CString& );
                        DWORD       SetEofCommand ( const CString& rstrCmdString);
        
                        DWORD       GetState ( void );
                        BOOL        SetState ( const DWORD dwNewState );
                
                        void        SetNew ( const BOOL bNew ) { m_bIsNew = bNew; };

                        BOOL    IsRunning( void );
                        BOOL    IsAutoStart( void );
                        BOOL    IsAutoRestart( void );
                        BOOL    IsFirstModification ( void );
                        BOOL    IsReadOnly ( void ) { return m_bReadOnly; };
                        BOOL    IsExecuteOnly( void ) { return m_bExecuteOnly; };
                        BOOL    IsModifiable( void ) { return ( !IsExecuteOnly() && !IsReadOnly() ); };
                        DWORD   UpdateExecuteOnly ( void );

                        BOOL    GetPropPageSharedData ( PSLQ_PROP_PAGE_SHARED );
                        BOOL    SetPropPageSharedData ( PSLQ_PROP_PAGE_SHARED );
                        void    SyncPropPageSharedData ( void );
                        void    UpdatePropPageSharedData ( void );

                        CWnd*   GetActivePropertySheet ();
                        void    SetActivePropertyPage ( CSmPropertyPage* );
                
        virtual CSmCounterLogQuery* CastToCounterLogQuery( void ) { return NULL; };
        virtual CSmTraceLogQuery*   CastToTraceLogQuery( void ) { return NULL; };
        virtual CSmAlertQuery*      CastToAlertQuery( void ) { return NULL; };

        // Property bag persistence

        static HRESULT StringFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    const CString& rstrDefault,
                    LPTSTR *pszBuffer, 
                    LPDWORD pdwLength );

        static HRESULT DwordFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    DWORD  dwDefault,
                    DWORD& rdwData );

        virtual HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );

        // Public members

        static const    CString cstrEmpty;

        DWORD   m_fDirtyPassword;
        CString m_strUser;
        CString m_strPassword;

    // protected methods
    protected:
        virtual DWORD   UpdateRegistry();

		virtual HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );

        // Registry persistence
        LONG    ReadRegistryStringValue (
                    HKEY hKey, 
                    UINT uiValueName,
                    LPCTSTR szDefault, 
                    LPTSTR *pszBuffer, 
                    LPDWORD pdwLength );
        
        LONG    WriteRegistryStringValue (
                    HKEY    hKey, 
                    UINT    uiValueName,
                    DWORD   dwType,     
                    LPCTSTR pszBuffer,
                    LPDWORD pdwLength );

        LONG    ReadRegistryDwordValue (
                    HKEY hKey, 
                    UINT uiValueName,
                    DWORD dwDefault, 
                    LPDWORD  pdwValue ); 

        LONG    WriteRegistryDwordValue (
                    HKEY     hKey,
                    UINT uiValueName,
                    LPDWORD  pdwValue,
                    DWORD    dwType=REG_DWORD);     // Also supports REG_BINARY

        LONG    ReadRegistrySlqTime (
                    HKEY    hKey,
                    UINT    uiValueName,
                    PSLQ_TIME_INFO pSlqDefault,
                    PSLQ_TIME_INFO pSlqValue );

        LONG    WriteRegistrySlqTime (
                    HKEY    hKey,
                    UINT    uiValueName,
                    PSLQ_TIME_INFO    pSlqTime );

        // Property bag persistence

        static HRESULT StringFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    const CString& rstrDefault,
                    LPTSTR *pszBuffer, 
                    LPDWORD pdwLength );

        HRESULT StringToPropertyBag (
                    IPropertyBag* pIPropBag, 
                    UINT uiPropName,
                    const CString& rstrData );

        HRESULT StringToPropertyBag (
                    IPropertyBag* pIPropBag, 
                    const CString& rstrPropName,
                    const CString& rstrData );

        static HRESULT DwordFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    DWORD  dwDefault,
                    DWORD& rdwData );

        HRESULT DwordToPropertyBag (
                    IPropertyBag* pPropBag, 
                    UINT uiPropName,
                    DWORD dwData );

        HRESULT DwordToPropertyBag (
                    IPropertyBag* pPropBag, 
                    const CString& rstrPropName,
                    DWORD dwData );

        HRESULT DoubleFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    DOUBLE  dDefault,
                    DOUBLE& rdData );

        HRESULT DoubleFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    DOUBLE  dDefault,
                    DOUBLE& rdData );

        HRESULT DoubleToPropertyBag (
                    IPropertyBag* pPropBag, 
                    UINT uiPropName,
                    DOUBLE dData );

        HRESULT DoubleToPropertyBag (
                    IPropertyBag* pPropBag, 
                    const CString& rstrPropName,
                    DOUBLE dData );

        HRESULT FloatFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    FLOAT  fDefault,
                    FLOAT& rfData );

        HRESULT FloatFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    FLOAT   fDefault,
                    FLOAT& rfData );

        HRESULT FloatToPropertyBag (
                    IPropertyBag* pPropBag, 
                    UINT uiPropName,
                    FLOAT fData );

        HRESULT FloatToPropertyBag (
                    IPropertyBag* pPropBag, 
                    const CString& rstrPropName,
                    FLOAT fData );

        HRESULT LLTimeFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    LONGLONG&  rllDefault,
                    LONGLONG& rllData );

        HRESULT LLTimeToPropertyBag (
                    IPropertyBag* pIPropBag, 
                    UINT uiPropName,
                    LONGLONG& rllData );

        HRESULT SlqTimeFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    DWORD       dwFlags,
                    PSLQ_TIME_INFO pSlqDefault,
                    PSLQ_TIME_INFO pSlqData );

        HRESULT SlqTimeToPropertyBag (
                    IPropertyBag* pPropBag, 
                    DWORD dwFlags,
                    PSLQ_TIME_INFO pSlqData );



    // protected member variables
    protected:
        CString         m_strName;
        CSmLogService*  m_pLogService;        
        
        HKEY    m_hKeyQuery;
        BOOL    m_bReadOnly;
        BOOL    m_bExecuteOnly;
        CString m_strFileName;

        // Registry Values
        // Current state is private to avoid extra service query
        DWORD   mr_dwCurrentState;
        // *** make time protected members private, access via Get, SetLogTime
        DWORD           mr_dwAutoRestartMode;
        SLQ_TIME_INFO   mr_stiSampleInterval;

    private:
        
        HRESULT CopyToBuffer ( LPTSTR& rpszData, DWORD& rdwBufferSize );
        DWORD   UpdateRegistryScheduleValues ( void );
        DWORD   UpdateRegistryLastModified ( void );

        BOOL LLTimeToVariantDate (LONGLONG llTime, DATE *pDate);
        BOOL VariantDateToLLTime (DATE Date, LONGLONG *pllTime);        

        void InitDataStoreAttributesDefault ( const DWORD dwRegLogFileType, DWORD&  rdwDefault );
        void ProcessLoadedDataStoreAttributes ( DWORD dwDataStoreAttributes );

        BOOL    m_bIsModified;
        BOOL    m_bIsNew;
        DWORD   mr_dwRealTimeQuery;

        CString m_strLogFileType;
        // Registry Values
        CString mr_strLogKeyName;
        CString mr_strComment;
        CString mr_strCommentIndirect;
        DWORD   mr_dwMaxSize; // in size determined by mr_dwFileSizeUnits, -1 = grow to disk full
        DWORD   mr_dwFileSizeUnits; 
        DWORD   mr_dwAppendMode; 
        CString mr_strBaseFileName;
        CString mr_strBaseFileNameIndirect;
        CString mr_strSqlName;
        CString mr_strDefaultDirectory;
        DWORD   mr_dwLogAutoFormat;
        DWORD   mr_dwCurrentSerialNumber;
        DWORD   mr_dwLogFileType;
        CString mr_strEofCmdFile;
        SLQ_TIME_INFO   mr_stiStart;
        SLQ_TIME_INFO   mr_stiStop;

        SLQ_PROP_PAGE_SHARED  m_PropData;
        CSmPropertyPage* m_pActivePropPage;
};

typedef CSmLogQuery   SLQUERY;
typedef CSmLogQuery*  PSLQUERY;


#endif //_CLASS_SMLOGQRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smnode.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smnode.h

Abstract:

    Base class representing a node in the MMC user interface.

--*/

#ifndef _CLASS_SMNODE_
#define _CLASS_SMNODE_

class CSmNode;
class CSmRootNode;
class CSmLogService;
class CSmCounterLogService;
class CSmTraceLogService;
class CSmAlertService;

class CSmNode
{
    // constructor/destructor
    public:
                CSmNode();
        virtual ~CSmNode();

    // public methods
    public:

                const CString& GetDisplayName( void );
                const CString& GetMachineName( void );
                const CString& GetMachineDisplayName( void );
                const CString& GetDescription( void );
                const CString& GetType( void );

                DWORD   SetMachineName( const CString& );

                BOOL    IsLocalMachine ( void );

        virtual CSmRootNode* CastToRootNode( void ) { return NULL; };
        virtual CSmLogService* CastToLogService( void ) { return NULL; };
        virtual CSmCounterLogService* CastToCounterLogService( void ) { return NULL; };
        virtual CSmTraceLogService* CastToTraceLogService( void ) { return NULL; };
        virtual CSmAlertService* CastToAlertService( void ) { return NULL; };

    protected:

        DWORD    SetDisplayName( const CString& );
        void     SetDescription( const CString& );  // Throws exception on error
        DWORD    SetType( const CString& );

    private:
        CString     m_strName;
        CString     m_strMachineName;
        CString     m_strMachineDisplayName;
        CString     m_strDesc;
        CString     m_strType;
        CSmNode*    m_pParentNode;
};

typedef CSmNode   SMNODE;
typedef CSmNode*  PSMNODE;


#endif //_CLASS_SMNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smtprov.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtprov.h

Abstract:

    This object is used to store the list of all current 
    trace providers in the system.

--*/

#ifndef _CLASS_SMTPROV_
#define _CLASS_SMTPROV_

typedef struct _SLQ_TRACE_PROVIDER {
    CString strDescription;
    CString strGuid;
    INT     iIsEnabled;
    INT     iIsActive;
} SLQ_TRACE_PROVIDER, *PSLQ_TRACE_PROVIDER;

class CSmTraceLogService;
struct IWbemServices;

class CSmTraceProviders : public CObject
{
    public:
                CSmTraceProviders( CSmTraceLogService* );
        virtual ~CSmTraceProviders( void );

                DWORD   Open ( const CString& rstrMachineName );
                DWORD   Close ( void );
        
                HRESULT SyncWithConfiguration( void );
                HRESULT ConnectToServer( void );
                HRESULT GetBootState( INT& );

                SLQ_TRACE_PROVIDER* GetProviderInfo( INT );
                SLQ_TRACE_PROVIDER* GetKernelProviderInfo( void );

                INT     GetGenProvCount ( void );

                INT     IndexFromGuid ( const CString& rstrGuid );

                DWORD   AddProvider ( 
                            const CString& rstrDescription,
                            const CString& rstrGuid,
                            INT iIsEnabled,
                            INT iIsActive);
    private:
        
        // Helper class
        class CRegisteredGuidData 
        {
            public:
                CRegisteredGuidData( void ){};

                CString m_strGuid;
                INT     m_iIsEnabled;
        };
    
        typedef CRegisteredGuidData* PREGISTERED_GUID_DATA;

        static LPCWSTR  m_cszBackslash;
        static LPCWSTR  m_cszDefaultNamespace;
        static LPCWSTR  m_cszTraceProviderClass;
        static LPCWSTR  m_cszRegisteredGuidsClass;
        static LPCWSTR  m_cszDescription;
        static LPCWSTR  m_cszGuid;
        static LPCWSTR  m_cszKernelLogger;

        CString             m_strMachineName;
        IWbemServices*      m_pWbemServices;
        INT                 m_iBootState;
        CArray<SLQ_TRACE_PROVIDER, SLQ_TRACE_PROVIDER&> m_arrGenTraceProvider;
        SLQ_TRACE_PROVIDER  m_KernelTraceProvider;
        CSmTraceLogService* m_pTraceLogService;
};


#endif //_CLASS_SMTPROV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smrootnd.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smrootnd.cpp

Abstract:

    This object is used to represent the Performance Logs and Alerts root node

--*/

#include "Stdafx.h"
#include "smrootnd.h"

//
//  Constructor
CSmRootNode::CSmRootNode()
:   m_bIsExpanded ( FALSE ),
    m_hRootNode ( NULL ),
    m_hParentNode ( NULL ),
    m_bIsExtension ( FALSE )
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler

    strTemp.LoadString ( IDS_MMC_DEFAULT_NAME );
    SetDisplayName ( strTemp ); 
    strTemp.LoadString ( IDS_ROOT_NODE_DESCRIPTION );
    SetDescription ( strTemp ); 
    strTemp.LoadString ( IDS_EXTENSION_COL_TYPE );
    SetType ( strTemp ); 
    return;
}

//
//  Destructor
CSmRootNode::~CSmRootNode()
{
    ASSERT (m_CounterLogService.m_QueryList.GetHeadPosition() == NULL);
    ASSERT (m_TraceLogService.m_QueryList.GetHeadPosition() == NULL);
    ASSERT (m_AlertService.m_QueryList.GetHeadPosition() == NULL);

    return;
}

void
CSmRootNode::Destroy()
{    
    m_CounterLogService.Close();
    m_TraceLogService.Close();
    m_AlertService.Close();

    return;
}

BOOL
CSmRootNode::IsLogService (
	MMC_COOKIE mmcCookie )
{
    BOOL bReturn = FALSE;

    if (mmcCookie == (MMC_COOKIE)&m_CounterLogService) {
        bReturn = TRUE;
    } else if (mmcCookie == (MMC_COOKIE)&m_TraceLogService) {
        bReturn = TRUE;
    } else if (mmcCookie == (MMC_COOKIE)&m_AlertService) {
        bReturn = TRUE;
    } 

    return bReturn;
}

BOOL
CSmRootNode::IsAlertService ( 
    MMC_COOKIE mmcCookie )
{
    BOOL bReturn = FALSE;

    if (mmcCookie == (MMC_COOKIE)&m_AlertService) {
        bReturn = TRUE;
    } 
    return bReturn;
}

BOOL
CSmRootNode::IsLogQuery ( 
    MMC_COOKIE	mmcCookie )
{
    PSLQUERY   pPlQuery = NULL;

    POSITION    Pos;
    
    // Handle multiple query types
    Pos = m_CounterLogService.m_QueryList.GetHeadPosition();
    
    while ( Pos != NULL) {
        pPlQuery = m_CounterLogService.m_QueryList.GetNext( Pos );
        if ((MMC_COOKIE)pPlQuery ==  mmcCookie) return TRUE;
    }

    Pos = m_TraceLogService.m_QueryList.GetHeadPosition();
    
    while ( Pos != NULL) {
        pPlQuery = m_TraceLogService.m_QueryList.GetNext( Pos );
        if ((MMC_COOKIE)pPlQuery == mmcCookie) return TRUE;
    }
    
    Pos = m_AlertService.m_QueryList.GetHeadPosition();
    
    while ( Pos != NULL) {
        pPlQuery = m_AlertService.m_QueryList.GetNext( Pos );
        if ((MMC_COOKIE)pPlQuery == mmcCookie) return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smrootnd.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smrootnd.h

Abstract:

    This object is used to represent the Performance Logs and Alerts root node

--*/

#ifndef _CLASS_SMROOTNODE_
#define _CLASS_SMROOTNODE_

#include "smnode.h"
#include "smctrsv.h"
#include "smtracsv.h"
#include "smalrtsv.h"


class CSmRootNode : public CSmNode
{
    // constructor/destructor
    public:
                CSmRootNode ();
        virtual ~CSmRootNode();

    // public methods
    public:

        virtual CSmRootNode*    CastToRootNode( void ) { return this; };
                void            Destroy( void );

                HSCOPEITEM      GetScopeItemHandle ( void ) { return m_hRootNode; }; 
                void            SetScopeItemHandle ( HSCOPEITEM hRootNode ) 
                                        { m_hRootNode = hRootNode; }; 
            
                HSCOPEITEM      GetParentScopeItemHandle ( void ) { return m_hParentNode; }; 
                void            SetParentScopeItemHandle ( HSCOPEITEM hParentNode ) 
                                        { m_hParentNode = hParentNode; }; 

                BOOL    IsExpanded(){ return m_bIsExpanded; };
                void    SetExpanded( BOOL bExp){ m_bIsExpanded = bExp; };

                BOOL    IsExtension(){ return m_bIsExtension; };
                void    SetExtension( BOOL bExtension){ m_bIsExtension = bExtension; };

                BOOL    IsLogService ( MMC_COOKIE mmcCookie );
                BOOL    IsAlertService ( MMC_COOKIE mmcCookie );
                
                BOOL    IsLogQuery ( MMC_COOKIE mmcCookie );

                CSmCounterLogService*   GetCounterLogService ( void )
                                            { return &m_CounterLogService; };
                CSmTraceLogService*   GetTraceLogService ( void )
                                            { return &m_TraceLogService; };
                CSmAlertService*   GetAlertService ( void )
                                            { return &m_AlertService; };
    private:
        HSCOPEITEM          m_hRootNode;            // Root node handle
        HSCOPEITEM          m_hParentNode;          // Parent node is NULL for standalone
        BOOL                m_bIsExpanded;
        BOOL                m_bIsExtension;

        CSmCounterLogService    m_CounterLogService;    // service object: 1 per component per node type
        CSmTraceLogService      m_TraceLogService;      // service object: 1 per component per node type
        CSmAlertService         m_AlertService;         // service object: 1 per component per node type
};

typedef CSmRootNode   SLROOT;
typedef CSmRootNode*  PSROOT;


#endif //_CLASS_SMROOTNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smtprov.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtprov.cpp

Abstract:

    This object is used to store the list of all current 
    trace providers in the system.

--*/

#include "Stdafx.h"
#include <wbemidl.h>
#include <initguid.h>
#include <wmistr.h>
#include <evntrace.h>
#include "smtracsv.h"
#include "smtprov.h"

USE_HANDLE_MACROS("SMLOGCFG(smtprov.cpp)");

#define WIN32_FROM_HRESULT(x)((x) & 0x0000FFFF)

LPCWSTR CSmTraceProviders::m_cszBackslash = TEXT ( "\\" );
LPCWSTR CSmTraceProviders::m_cszKernelLogger = TEXT ( "NT Kernel Logger" );
LPCWSTR CSmTraceProviders::m_cszDefaultNamespace = TEXT ( "root\\wmi" );
LPCWSTR CSmTraceProviders::m_cszTraceProviderClass = TEXT ( "EventTrace" );
LPCWSTR CSmTraceProviders::m_cszRegisteredGuidsClass = TEXT ( "RegisteredGuids" );
LPCWSTR CSmTraceProviders::m_cszDescription = TEXT ( "Description" );
LPCWSTR CSmTraceProviders::m_cszGuid = TEXT ( "Guid" );

//
//  Constructor
CSmTraceProviders::CSmTraceProviders ( CSmTraceLogService* pSvc )
:   m_pWbemServices ( NULL ),
    m_pTraceLogService ( pSvc ),
    m_iBootState ( -1 )
{
    m_KernelTraceProvider.strDescription = _T("");
    m_KernelTraceProvider.strGuid = _T("");
    return;
}

//
//  Destructor
CSmTraceProviders::~CSmTraceProviders ( )
{
    ASSERT ( 0 == (INT)m_arrGenTraceProvider.GetSize ( ) );
    m_arrGenTraceProvider.RemoveAll ( );

    return;
}

//
//  Open function. Initialize provider array from Wbem.
//
DWORD
CSmTraceProviders::Open ( const CString& rstrMachineName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD dwLength;
    CString strTemp;

    MFC_TRY
        if ( !rstrMachineName.IsEmpty ( ) ) {
            m_strMachineName = rstrMachineName;
            if ( 0 != lstrcmpi ( m_cszBackslash, m_strMachineName.Left(1) ) ) {
                strTemp = m_cszBackslash;
                strTemp += m_cszBackslash;
                m_strMachineName = strTemp + m_strMachineName;
            }
        } else {

            // get the local machine name & default name space if the caller
            // has passed in a NULL machine name

            dwLength = MAX_COMPUTERNAME_LENGTH + 1;

            if ( GetComputerName (
					m_strMachineName.GetBufferSetLength( dwLength ),
					&dwLength ) ) {
                m_strMachineName.ReleaseBuffer();
                strTemp = m_cszBackslash;
                strTemp += m_cszBackslash;
                m_strMachineName = strTemp + m_strMachineName;
			} else {
				dwStatus = GetLastError();
				m_strMachineName.ReleaseBuffer();
			}
        }
    MFC_CATCH_DWSTATUS

    if ( ERROR_SUCCESS != dwStatus ) {
        m_strMachineName.Empty();
    }

    return dwStatus;
}

//
//  Close Function
//      Frees allocated memory
//
DWORD
CSmTraceProviders::Close ( )
{
    DWORD dwStatus = ERROR_SUCCESS;

    m_arrGenTraceProvider.RemoveAll ( );
    
    if ( NULL != m_pWbemServices ) {
        m_pWbemServices->Release ( );
        m_pWbemServices = NULL;
    }

    return dwStatus;
}

//
//  AddProvider
//      Add the specified provider strings to the array     
//  
DWORD
CSmTraceProviders::AddProvider (
    const CString& rstrDescription,
    const CString& rstrGuid,
    INT iIsEnabled,
    INT iIsActive )
{
    DWORD dwStatus = ERROR_SUCCESS;

    SLQ_TRACE_PROVIDER slqTProv;

    // If inactive, cannot be enabled.
    ASSERT ( ( 0 == iIsActive ) ? ( 0 == iIsEnabled ) : TRUE );

    MFC_TRY
        slqTProv.strDescription = rstrDescription;
        slqTProv.strGuid = rstrGuid;
        slqTProv.iIsEnabled = iIsEnabled;
        slqTProv.iIsActive = iIsActive;

        m_arrGenTraceProvider.Add( slqTProv );
    MFC_CATCH_DWSTATUS

    return dwStatus;
}


//
//  ConnectToServer
//      Connects to the Wbem server.
//  
HRESULT   
CSmTraceProviders::ConnectToServer ( void )
{
    HRESULT hr = NOERROR;

    if ( NULL == m_pWbemServices ) {
        IWbemLocator    *pWbemLocator = NULL;
        IWbemServices   *pWbemServices = NULL;

        // connect to locator
        hr = CoCreateInstance ( 
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                ( LPVOID * )&pWbemLocator );

        if ( SUCCEEDED (hr) ) {
            BSTR    bstrTemp = NULL;
            CString strNamespace; 

            MFC_TRY
                strNamespace = m_strMachineName;
                strNamespace += m_cszBackslash; 
                strNamespace += m_cszDefaultNamespace;
                bstrTemp = strNamespace.AllocSysString();
            MFC_CATCH_HR  
                
            if ( SUCCEEDED ( hr ) ) {
                // try to connect to the service
                hr = pWbemLocator->ConnectServer ( 
                    bstrTemp,
                    NULL, 
                    NULL, 
                    0, 
                    0L,
                    0,
                    0,
                    &pWbemServices );
        
                ::SysFreeString ( bstrTemp );
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = CoSetProxyBlanket((IUnknown*)pWbemServices,
                            RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            NULL,
                            RPC_C_AUTHN_LEVEL_PKT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,
                            EOAC_NONE);
            }
            // free the locator
            pWbemLocator->Release ( );
        }

        if ( SUCCEEDED ( hr ) ) {
            m_pWbemServices = pWbemServices;
        }
    }

    return hr;
}

//
//  GetBootState
//      Connects to the registry.
//  
HRESULT   
CSmTraceProviders::GetBootState ( INT& riBootState )
{
    HRESULT hr = NOERROR;

    if ( -1  == m_iBootState ) {
        HKEY    hKeyMachine;

        ASSERT ( NULL != m_pTraceLogService );

        hKeyMachine = m_pTraceLogService->GetMachineKey ( );

        if ( NULL != hKeyMachine ) {
            HKEY    hKeyOption;
            DWORD   dwStatus = ERROR_SUCCESS;

            dwStatus = RegOpenKeyEx ( 
                            hKeyMachine,
                            (LPCWSTR)L"System\\CurrentControlSet\\Control\\Safeboot\\Option",
                            0,
                            KEY_READ,
                            &hKeyOption );

            // The Option key and OptionValue value only exist if booting in 
            // safe mode, so failure indicates Normal mode (0).
            // Safe mode = 1, Safe mode with network = 2.
            if ( ERROR_SUCCESS ) {
                DWORD dwType = 0;
                DWORD dwBufSize = sizeof (INT );

                dwStatus = RegQueryValueExW (
                    hKeyOption,
                    L"OptionValue",
                    NULL,
                    &dwType,
                    (LPBYTE)&m_iBootState,
                    &dwBufSize);

                if ( ERROR_SUCCESS != dwStatus ) {
                    // Normal mode
                    m_iBootState = 0;
                }
            } else {
                // Normal mode
                m_iBootState = 0;
            }

        } else {
            // Unable to access registry
            hr = E_FAIL;
        }
    
    }

    riBootState = m_iBootState;

    return hr;
}

//
//  SyncWithConfiguration
//      Reads the current list of providers from Wbem
//      and reloads the internal values to match
//
HRESULT
CSmTraceProviders::SyncWithConfiguration ( void )
{
    IEnumWbemClassObject    *pEnumProviders = NULL;
    IEnumWbemClassObject    *pEnumRegGuids = NULL;
    CString strDescription;
    CString strGuid;
    CString strBracketedGuid;
    IWbemClassObject*   pRegisteredGuid = NULL;
    BSTR    bstrTemp;
    INT     iIndex;
    CArray<PREGISTERED_GUID_DATA, PREGISTERED_GUID_DATA&>   arrRegisteredGuids;
    INT iIsEnabled =0;
    HRESULT hr;

    m_arrGenTraceProvider.RemoveAll ( );

    hr = ConnectToServer( );

    //If Connection Succeeded
    if ( SUCCEEDED ( hr ) ) {
        //Get the Registered Guids (Up to date Data) from Wbem.
        MFC_TRY
            bstrTemp = SysAllocString(m_cszRegisteredGuidsClass);

            hr = m_pWbemServices->CreateInstanceEnum ( 
                    bstrTemp,
                    WBEM_FLAG_SHALLOW|WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    &pEnumRegGuids );
                ::SysFreeString ( bstrTemp );
        MFC_CATCH_HR

        if ( SUCCEEDED ( hr ) ) {
            ULONG                   uReturned = 1;
            
            while(uReturned == 1)
            {
                pRegisteredGuid = NULL;
                //---------------------------
                // enumerate through the resultset.
                hr = pEnumRegGuids->Next(
                    2000,               // timeout in two seconds
                    1,                  // return just one instance
                    &pRegisteredGuid,  // pointer to Registered Guid
                    &uReturned);        // number obtained: one or zero

                if ( SUCCEEDED(hr) && ( 1 == uReturned ))
                {
                    VARIANT     vValue ;

                    // Get the "GuidType" system property.
					MFC_TRY
                        bstrTemp = SysAllocString(L"GuidType");
                        VariantInit ( &vValue );
                        vValue.vt = VT_I4;

                        hr = pRegisteredGuid->Get(
                            bstrTemp,   // property name 
                            0L, 
                            &vValue,     // output to this variant 
                            NULL, 
                            NULL);

                        ::SysFreeString ( bstrTemp );
                    MFC_CATCH_HR            
                    // Filter on GuidType == 0
                    if (SUCCEEDED(hr) && (0 == vValue.iVal)){    
                        CString strProvider;
                        
                        // Get the "InstanceName" system property.
                        MFC_TRY
                            bstrTemp = SysAllocString(L"InstanceName");
                            VariantClear ( &vValue );
                            vValue.vt = VT_BSTR;

                            hr = pRegisteredGuid->Get(
                                bstrTemp,   // property name
                                0L,
                                &vValue,     // output to this variant
                                NULL,
                                NULL);

                            ::SysFreeString ( bstrTemp );
                        MFC_CATCH_HR            

                        if (SUCCEEDED(hr)){    

                            MFC_TRY
                                strProvider = ( LPWSTR )V_BSTR  (&vValue);

                                bstrTemp = SysAllocString(L"IsEnabled");
                                VariantInit(&vValue);
                                vValue.vt = VT_BOOL;
                                hr = pRegisteredGuid->Get(
                                    bstrTemp,       // property name 
                                    0L, 
                                    &vValue,        // output to this variant 
                                    NULL, 
                                    NULL);
                    
                                ::SysFreeString ( bstrTemp );
                            MFC_CATCH_HR
                        }
                                            
                        if ( SUCCEEDED(hr) ) {
                            PREGISTERED_GUID_DATA   pRegGuidData = NULL;

                            iIsEnabled = vValue.boolVal ? 1 : 0; 

                            MFC_TRY
                                pRegGuidData = new ( CRegisteredGuidData );
                                pRegGuidData->m_strGuid = strProvider;
                                pRegGuidData->m_iIsEnabled = iIsEnabled;
                                arrRegisteredGuids.Add(pRegGuidData);
                            MFC_CATCH_HR
                            
                        } 
                    } 

                    VariantClear(&vValue);
                    pRegisteredGuid->Release();

                }
            } // end while
        }
    }

    //If Connection succeeded and registered Guids gathered.
    if ( SUCCEEDED ( hr ) ) {

        // Create an enumerator of the Trace Provider class
        MFC_TRY
            bstrTemp = SysAllocString(m_cszTraceProviderClass);
            hr = m_pWbemServices->CreateClassEnum ( 
                bstrTemp,
                WBEM_FLAG_SHALLOW|WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumProviders );
            ::SysFreeString ( bstrTemp );
        MFC_CATCH_HR    

        if ( SUCCEEDED ( hr ) ) {
            BSTR    bsDescription = NULL;
            BSTR    bsGuid = NULL;
            VARIANT vValue;
            DWORD   dwRtnCount;
            IWbemQualifierSet   *pQualSet = NULL;
            IWbemClassObject    *pThisClass = NULL;
            WCHAR   szSystemTraceControlGuid[39];
            ULONG   Status;

            VariantInit ( &vValue );
            ZeroMemory ( szSystemTraceControlGuid, sizeof ( szSystemTraceControlGuid ) );

            ::StringFromGUID2( SystemTraceControlGuid, szSystemTraceControlGuid, 39);

            MFC_TRY
                bsDescription = SysAllocString(m_cszDescription);
                bsGuid = SysAllocString(m_cszGuid);
            MFC_CATCH_HR   
                
            if ( SUCCEEDED ( hr ) ) {

                iIsEnabled = 0; 

                while ( SUCCEEDED ( hr ) ) {
                    hr = pEnumProviders->Next ( 
                        0,      // timeout
                        1,      // return only 1 object
                        &pThisClass,
                        &dwRtnCount );

                    if ( SUCCEEDED ( hr ) ) {
                            // no more classes
                        if ( dwRtnCount == 0 ) break;

                        pThisClass->GetQualifierSet ( &pQualSet );
                        if ( pQualSet != NULL ) {

                            hr = pQualSet->Get ( bsGuid, 0, &vValue, 0 );
                            if ( SUCCEEDED ( hr ) ) {
                                strGuid = ( LPWSTR )V_BSTR ( &vValue );
                                VariantClear ( &vValue );

                                hr = pQualSet->Get ( bsDescription, 0, &vValue, 0 );
                                if ( SUCCEEDED ( hr ) ) {
                                        strDescription = ( LPWSTR )V_BSTR ( &vValue );
                                        VariantClear ( &vValue );
                                }else{
                                    hr = ERROR_SUCCESS;
                                    strDescription = strGuid;
                                }
                            }


                            pQualSet->Release();
                        }

                        // The Win2000 Kernel trace provider is handled separately.
                        if ( SUCCEEDED ( hr ) ) {
			                MFC_TRY
                                if ( L'{' != strGuid[0] ) {
                                    strBracketedGuid.Format ( L"{%s}", strGuid );
                                } else {
                                    strBracketedGuid = strGuid;
                                }
                            MFC_CATCH_HR

                            if ( 0 == strBracketedGuid.CompareNoCase( szSystemTraceControlGuid ) ) {
                                EVENT_TRACE_PROPERTIES  LoggerInfo;

                                TRACEHANDLE             LoggerHandle = 0;
                                TCHAR                   szLoggerName[MAX_PATH];
                                TCHAR                   szLogFileName[MAX_PATH];
                                // Kernel trace provider.  Need to pass GUID as name.
				                MFC_TRY
                                    ZeroMemory ( &LoggerInfo, sizeof ( LoggerInfo ) );
                                    LoggerInfo.Wnode.BufferSize = sizeof( LoggerInfo );
                                    LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
                                    szLoggerName[0] = 0;
                                    szLogFileName[0] = 0;
  
                                    LoggerInfo.Wnode.Guid = SystemTraceControlGuid;

                                    Status = QueryTrace(LoggerHandle, m_cszKernelLogger, &LoggerInfo);
                                    iIsEnabled = (Status == 0) ? 1 : 0;
                                    m_KernelTraceProvider.strDescription = strDescription;
                                    m_KernelTraceProvider.strGuid = strBracketedGuid;
                                    m_KernelTraceProvider.iIsEnabled = iIsEnabled;
                                    m_KernelTraceProvider.iIsActive = 1;
                                MFC_CATCH_HR
                            } else {
                                //loop on all the registered guids
                                INT iIsActive = 0;
                                for (iIndex = 0 ; iIndex < (INT)arrRegisteredGuids.GetSize(); iIndex ++){
                                    if (0 == strGuid.CompareNoCase((LPCTSTR)(arrRegisteredGuids[iIndex]->m_strGuid))){
                                        DWORD dwStatus;

                                        iIsActive = 1;

                                        dwStatus = AddProvider ( 
                                                    strDescription,
                                                    strBracketedGuid,
                                                    arrRegisteredGuids[iIndex]->m_iIsEnabled,                                          
                                                    iIsActive );

                                        if ( ERROR_OUTOFMEMORY == dwStatus ) {
                                            hr = E_OUTOFMEMORY;
                                        } else if ( ERROR_SUCCESS != dwStatus ) {
                                            hr = E_FAIL;
                                        }

                                        break;
                                    }
                                }

                                if ( 0 == iIsActive ) {
                                    DWORD dwStatus;

                                    dwStatus = AddProvider ( 
                                                strDescription,
                                                strBracketedGuid,
                                                0,                                          
                                                iIsActive );
                                
                                    if ( ERROR_OUTOFMEMORY == dwStatus ) {
                                        hr = E_OUTOFMEMORY;
                                    } else if ( ERROR_SUCCESS != dwStatus ) {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                        }

                        pThisClass->Release ( );

                    }
                }
                ::SysFreeString ( bsGuid );
                ::SysFreeString ( bsDescription );
            }
        }
    }

    for (iIndex = 0 ; iIndex < (INT)arrRegisteredGuids.GetSize(); iIndex ++){
        delete arrRegisteredGuids[iIndex];
    }

    arrRegisteredGuids.RemoveAll ( );

    // Done with these objects.
    if ( NULL != pEnumProviders ) {
        pEnumProviders->Release ( );
    }

    if ( NULL != pEnumRegGuids ) {
        pEnumRegGuids->Release ( );
    }

    return hr;
}

//
//  Get specified provider in provider list
//
SLQ_TRACE_PROVIDER*
CSmTraceProviders::GetProviderInfo ( INT iIndex )
{
    return &m_arrGenTraceProvider[iIndex];
}

//
//  Return a pointer to the Kernel provider.
//
SLQ_TRACE_PROVIDER*
CSmTraceProviders::GetKernelProviderInfo ( void )
{
    return &m_KernelTraceProvider;
}

//
//  Return the index of the provider specified by Guid
//
INT
CSmTraceProviders::IndexFromGuid ( const CString& rstrGuid )
{
    int iIndex;
    int iCount = (INT)m_arrGenTraceProvider.GetSize ( );

    for ( iIndex = 0; iIndex < iCount; iIndex++ ) {
        if ( 0 == m_arrGenTraceProvider[iIndex].strGuid.CompareNoCase( rstrGuid ) ) {
            break;
        }
    }

    // Signal not found with -1.
    if ( iIndex == iCount ) {
        iIndex = -1;
    }
    return iIndex;
}

//
//  Get provider list count
//
INT
CSmTraceProviders::GetGenProvCount ( )
{
    return (INT)m_arrGenTraceProvider.GetSize ( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smproppg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smproppg.h

Abstract:

    Class definitions for the property page base class.

--*/

#ifndef _SMPROPPG_H_
#define _SMPROPPG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smlogqry.h"   // For shared data

#define MAXSTR         32
#define INVALID_DWORD  -2       // SLQ_DISK_MAX_SIZE = -1
#define INVALID_DOUBLE -1.00

/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage dialog

#define VALIDATE_FOCUS      1
#define VALIDATE_APPLY      2

class CSmPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSmPropertyPage)

// Construction
public:

            CSmPropertyPage();

            CSmPropertyPage ( 
                UINT nIDTemplate, 
                LONG_PTR hConsole = NULL,
                LPDATAOBJECT pDataObject = NULL );

    virtual ~CSmPropertyPage();

public:

    static  UINT CALLBACK   PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
            DWORD           SetContextHelpFilePath ( const CString& rstrPath );
            const CString&  GetContextHelpFilePath ( void ) { return m_strContextHelpFilePath; };
            void            SetModifiedPage ( const BOOL bModified = TRUE );

            DWORD   AllocInitCounterPath( 
                        const LPTSTR szCounterPath,
                        PPDH_COUNTER_PATH_ELEMENTS* ppCounter );


            
// Dialog Data
    //{{AFX_DATA(CSmPropertyPage)
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSmPropertyPage)
public:
protected:
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    //}}AFX_VIRTUAL

public:
    LPFNPSPCALLBACK     m_pfnOriginalCallback;

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSmPropertyPage)
    virtual BOOL OnHelpInfo( HELPINFO* );
    virtual void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CCountersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
//    DECLARE_DISPATCH_MAP()
//    DECLARE_INTERFACE_MAP()

protected:

    enum eStartType {
        eStartManually,
        eStartImmediately,
        eStartSched 
    };
    
            void    SetRunAs( CSmLogQuery* pQuery );
            BOOL    Initialize(CSmLogQuery* pQuery);
            eStartType  DetermineCurrentStartType ( void );

   virtual  INT     GetFirstHelpCtrlId ( void ) { ASSERT ( FALSE ); return 0; };  // Subclass must override.
    
            BOOL    IsValidData ( CSmLogQuery* pQuery, DWORD fReason );
   virtual  BOOL    IsValidLocalData() { return TRUE; }

            BOOL    Apply( CSmLogQuery* pQuery );
    
            BOOL    IsActive( void ) { return m_bIsActive; };
            void    SetIsActive( BOOL bIsActive ) { m_bIsActive = bIsActive; };
            BOOL    UpdateService( CSmLogQuery* pQuery, BOOL bSyncSerial = FALSE );
            void    SetHelpIds ( DWORD* pdwHelpIds ) { m_pdwHelpIds = pdwHelpIds; };

            BOOL    IsModifiedPage( void ) { return m_bIsModifiedPage; };

            void    ValidateTextEdit(CDataExchange * pDX,
                                     int             nIDC,
                                     int             nMaxChars,
                                     DWORD         * value,
                                     DWORD           minValue,
                                     DWORD           maxValue);
            BOOL    ValidateDWordInterval(int     nIDC,
                                          LPCWSTR strLogName,
                                          long    lValue,
                                          DWORD   minValue,
                                          DWORD   maxValue);
            void    OnDeltaposSpin(NMHDR   * pNMHDR,
                                   LRESULT * pResult,
                                   DWORD   * pValue,
                                   DWORD     dMinValue,
                                   DWORD     dMaxValue);
            
            BOOL    SampleTimeIsLessThanSessionTime( CSmLogQuery* pQuery );
            BOOL    SampleIntervalIsInRange( SLQ_TIME_INFO&, const CString& );
            BOOL    IsWritableQuery( CSmLogQuery* pQuery );
            BOOL    ConnectRemoteWbemFail(CSmLogQuery* pQuery, BOOL bNotTouchRunAs);
            CWnd*   GetRunAsWindow();
            
    SLQ_PROP_PAGE_SHARED    m_SharedData;
    HINSTANCE               m_hModule;
    LPDATAOBJECT            m_pDataObject;
    CString                 m_strUserDisplay;   // For RunAs
    CString                 m_strUserSaved;
    BOOL                    m_bCanAccessRemoteWbem;
    BOOL                    m_bPwdButtonEnabled;
private:    
    
    LONG_PTR                m_hConsole;
    BOOL                    m_bIsActive;
    CString                 m_strContextHelpFilePath;
    DWORD*                  m_pdwHelpIds;    
    BOOL                    m_bIsModifiedPage;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _SMPROPPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smnode.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smnode.cpp

Abstract:

    Implements the MMC user interface node base class.

--*/

#include "Stdafx.h"
#include "smnode.h"

USE_HANDLE_MACROS("SMLOGCFG(smnode.cpp)");
//
//  Constructor
CSmNode::CSmNode()
: m_pParentNode ( NULL )
{
    return;
}

//
//  Destructor
CSmNode::~CSmNode()
{
    return;
}

const CString&
CSmNode::GetDisplayName()
{
    return m_strName;
}

const CString&
CSmNode::GetMachineName()
{
    return m_strMachineName;
}

const CString&
CSmNode::GetMachineDisplayName()
{
    return m_strMachineDisplayName;
}

const CString&
CSmNode::GetDescription()
{
    return m_strDesc;
}

const CString&
CSmNode::GetType()
{
    return m_strType;
}

DWORD
CSmNode::SetDisplayName( const CString& rstrName )
{
	DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strName = rstrName;
	MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD
CSmNode::SetMachineName( const CString& rstrMachineName )
{
	DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        m_strMachineName = rstrMachineName;

        if ( !rstrMachineName.IsEmpty() ) {
            m_strMachineDisplayName = rstrMachineName;
        } else {
            m_strMachineDisplayName.LoadString ( IDS_LOCAL );
        }
	MFC_CATCH_DWSTATUS

    return dwStatus;
}

void
CSmNode::SetDescription( const CString& rstrDesc )
{
    // This method is only called within the node constructor,
    // so throw any errors
    m_strDesc = rstrDesc;
    
    return;
}

DWORD
CSmNode::SetType( const CString& rstrType )
{
	DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        m_strType = rstrType;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

BOOL
CSmNode::IsLocalMachine( void )
{
    BOOL bLocal = m_strMachineName.IsEmpty();

    return bLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smproppg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smproppg.cpp

Abstract:

    Implementation of the property page base class.

--*/

#include "stdafx.h"
#include <wbemidl.h>
#include "smcfgmsg.h"
#include "smlogs.h"
#include "smproppg.h"
#include "dialogs.h"
#include <pdhp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(smproppg.cpp)");

/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage property page

IMPLEMENT_DYNCREATE ( CSmPropertyPage, CPropertyPage )

CSmPropertyPage::CSmPropertyPage ( 
    UINT nIDTemplate, 
    LONG_PTR hConsole,
    LPDATAOBJECT pDataObject )  
:   CPropertyPage ( nIDTemplate ),
    m_bIsActive ( FALSE ),
    m_bIsModifiedPage ( FALSE ),
    m_pdwHelpIds ( NULL ),
    m_hConsole (hConsole ),
    m_pDataObject ( pDataObject ),
    m_bCanAccessRemoteWbem ( FALSE ),
    m_bPwdButtonEnabled ( TRUE )
{
    //::OutputDebugStringA("\nCSmProperty::CSmPropertyPage");

    // Need to save the original callback pointer because we are replacing
    // it with our own 
    m_pfnOriginalCallback = m_psp.pfnCallback;

    // This makes sure the MFC module states will work correctly 
    MMCPropPageCallback( &m_psp );

//  EnableAutomation();
    //{{AFX_DATA_INIT(CSmPropertyPage)
    //}}AFX_DATA_INIT

    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);  
}

CSmPropertyPage::CSmPropertyPage() : CPropertyPage(0xfff)  // Unused template IDD
{
    ASSERT (FALSE); // the constructor w/ args should be used instead
//  //{{AFX_DATA_INIT(CSmPropertyPage)
//  //}}AFX_DATA_INIT
}

CSmPropertyPage::~CSmPropertyPage()
{
}

BEGIN_MESSAGE_MAP(CSmPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CSmPropertyPage)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage message handlers


UINT CALLBACK  CSmPropertyPage::PropSheetPageProc
(
  HWND hWnd,                     // [in] Window handle - always null
  UINT uMsg,                 // [in,out] Either the create or delete message        
  LPPROPSHEETPAGE pPsp         // [in,out] Pointer to the property sheet struct
)
{
  ASSERT( NULL != pPsp );

  // We need to recover a pointer to the current instance.  We can't just use
  // "this" because we are in a static function
  CSmPropertyPage* pMe   = reinterpret_cast<CSmPropertyPage*>(pPsp->lParam);           
  ASSERT( NULL != pMe );
  
  if (!pMe) return 0;

  switch( uMsg )
  {
    case PSPCB_CREATE:                  
      break;

    case PSPCB_RELEASE:  
      // Since we are deleting ourselves, save a callback on the stack
      // so we can callback the base class
      //LPFNPSPCALLBACK pfnOrig = pMe->m_pfnOriginalCallback;
      delete pMe;      
      return 1; //(pfnOrig)(hWnd, uMsg, pPsp);
  }
  // Must call the base class callback function or none of the MFC
  // message map stuff will work
  return (pMe->m_pfnOriginalCallback)(hWnd, uMsg, pPsp); 

} // end PropSheetPageProc()

BOOL 
CSmPropertyPage::Initialize(CSmLogQuery* pQuery) 
{
    HRESULT hr;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwInfoSize = 0;
    CString strMachineName;
    LPCWSTR pszMachineName = NULL;

    if ( NULL != pQuery ) {
        if (!pQuery->GetLogService()->IsLocalMachine()) {
            pszMachineName = pQuery->GetLogService()->GetMachineName();
        }

        hr = PdhPlaGetInfoW( (LPWSTR)(LPCWSTR)pQuery->GetLogName(),
                             (LPWSTR)pszMachineName,
                             &dwInfoSize,
                             pInfo );
        if( ERROR_SUCCESS == hr && 0 != dwInfoSize ){
            pInfo = (PPDH_PLA_INFO)malloc(dwInfoSize);
            if( NULL != pInfo ) {
                if ( sizeof(PDH_PLA_INFO) <= dwInfoSize ) {
                    pInfo->dwMask = PLA_INFO_FLAG_USER;
                    hr = PdhPlaGetInfoW( (LPWSTR)(LPCWSTR)pQuery->GetLogName(),
                                          (LPWSTR)pszMachineName,
                                          &dwInfoSize,
                                          pInfo );
                    if( ERROR_SUCCESS == hr ){
                        pQuery->m_strUser = pInfo->strUser;
                    }
                }
                free( pInfo );
            }
            pQuery->m_fDirtyPassword = PASSWORD_CLEAN;
        }
    }
    return TRUE;
}

BOOL 
CSmPropertyPage::OnInitDialog() 
{
    DWORD dwExStyle = 0;
    CWnd* pwndPropSheet;

    pwndPropSheet = GetParentOwner();

    if ( NULL != pwndPropSheet ) {
        dwExStyle = pwndPropSheet->GetExStyle();
        pwndPropSheet->ModifyStyleEx ( NULL, WS_EX_CONTEXTHELP );
    }
    return CPropertyPage::OnInitDialog();
}
    
BOOL
CSmPropertyPage::OnSetActive() 
{
    m_bIsActive = TRUE;
    return CPropertyPage::OnSetActive();
}

BOOL 
CSmPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT ( NULL != m_pdwHelpIds );

    if ( NULL != pHelpInfo ) {
        if ( pHelpInfo->iCtrlId >= GetFirstHelpCtrlId() ) {
            InvokeWinHelp(
                WM_HELP, 
                NULL, 
                (LPARAM)pHelpInfo, 
                GetContextHelpFilePath(), 
                m_pdwHelpIds ); //s_aulHelpIds);
        }
    } else {
        ASSERT ( FALSE );
    }
    
    return TRUE;
}

void 
CSmPropertyPage::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT ( NULL != m_pdwHelpIds );

    if ( NULL != pWnd ) {    
        InvokeWinHelp (
            WM_CONTEXTMENU, 
            (WPARAM)(pWnd->m_hWnd), 
            NULL, 
            GetContextHelpFilePath(), 
            m_pdwHelpIds ); 
    }
    return;
}
/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage helper methods

BOOL
CSmPropertyPage::UpdateService( CSmLogQuery* pQuery, BOOL bSyncSerial )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bIsValid = FALSE;
    BOOL    bRegistryUpdated;
    CString strMessage;
    CString strMachineName;
    CString strSysMessage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState()); 

    if ( NULL != pQuery ) {
        { 
            CWaitCursor WaitCursor;
            // Update the service with changes.
            // Sync changes made by service to properties not modified by this page.
            if ( bSyncSerial ) {
                dwStatus = pQuery->SyncSerialNumberWithRegistry();
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = pQuery->UpdateService ( bRegistryUpdated );
            }    
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            bIsValid = TRUE;
        } else {

            bIsValid = FALSE;

            if ( ERROR_KEY_DELETED == dwStatus ) {
                strMessage.LoadString( IDS_ERRMSG_QUERY_DELETED );        
            } else if ( ERROR_ACCESS_DENIED == dwStatus ) {
            
                pQuery->GetMachineDisplayName( strMachineName );

                FormatSmLogCfgMessage ( 
                    strMessage,
                    m_hModule, 
                    SMCFG_NO_MODIFY_ACCESS, 
                    (LPCTSTR)strMachineName);
            } else {

                FormatMessage ( 
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, 
                    dwStatus,
                    0,
                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                    MAX_PATH,
                    NULL );

                strSysMessage.ReleaseBuffer();

                if ( strSysMessage.IsEmpty() ) {
                    strSysMessage.Format ( _T("0x%08lX"), dwStatus );
                }

                strMessage.Format( IDS_ERRMSG_SERVICE_ERROR, pQuery->GetLogName() );
                strMessage += strSysMessage;
            }
            
            MessageBox ( strMessage, pQuery->GetLogName(), MB_OK  | MB_ICONERROR );                
        }
    } else {
        ASSERT ( FALSE );
    }
    return bIsValid;
}


void
CSmPropertyPage::ValidateTextEdit (
    CDataExchange*  pDX,
    int             nIDC,
    int             nMaxChars,
    DWORD*          pValue,
    DWORD           /* minValue */,
    DWORD           /* maxValue */)
{
    HWND    hWndCtrl       = pDX->PrepareEditCtrl(nIDC);
    LONG    currentValue   = INVALID_DWORD;
    TCHAR   szT[MAXSTR];
    CString strTemp;

    if ( NULL != pDX && NULL != pValue ) {
        if (pDX->m_bSaveAndValidate) {

            *pValue = (DWORD) currentValue;

            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, nMaxChars);

            if (szT[0] >= _T('0') && szT[0] <= _T('9'))
            {
                currentValue = _wtol(szT);
                *pValue      = (DWORD) currentValue;
            }
        } else {
            if ( INVALID_DWORD != *pValue ) {
                wsprintf(szT, _T("%lu"), *pValue);
            } else {
                szT[0] = _T('\0');
            }
            GetDlgItem(nIDC)->SetWindowText(szT);
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CSmPropertyPage::ValidateDWordInterval(
    int     nIDC,
    LPCWSTR strLogName,
    long    lValue,
    DWORD   minValue,
    DWORD   maxValue )
{
    CString strMsg;
    BOOL    bResult =  (lValue >= (long) minValue)
                    && (lValue <= (long) maxValue);

    if (! bResult)
    {
        strMsg.Format ( IDS_ERRMSG_INVALIDDWORD, minValue, maxValue );
        MessageBox(strMsg, strLogName, MB_OK  | MB_ICONERROR);
        GetDlgItem(nIDC)->SetFocus();
        strMsg.Empty();
    }
    return (bResult);
}

void
CSmPropertyPage::OnDeltaposSpin(
    NMHDR   *pNMHDR,
    LRESULT *pResult,
    DWORD   *pValue,
    DWORD     dMinValue,
    DWORD     dMaxValue)
{
    NM_UPDOWN* pNMUpDown;
    LONG       lValue;
    BOOL       bResult   = TRUE;

    UpdateData(TRUE);

    ASSERT(dMinValue <= dMaxValue);

    if ( NULL != pNMHDR
        && NULL != pResult
        && NULL != pValue ) 
    {
        pNMUpDown = (NM_UPDOWN *) pNMHDR;
        lValue    = (LONG) (*pValue);

        if (lValue == INVALID_DWORD) {
            lValue = (DWORD) dMinValue;
        }

        if ( ((lValue >= (LONG) dMinValue + 1) && (pNMUpDown->iDelta > 0))
            || ((lValue <= (LONG) dMaxValue - 1) && (pNMUpDown->iDelta < 0)))
        {
            lValue += (pNMUpDown->iDelta * -1);

            if (lValue > (LONG) dMaxValue) {
                lValue = (DWORD) dMaxValue;
            } else if (lValue < (LONG) dMinValue) {
                lValue = (DWORD) dMinValue;
            }
        } else if (lValue > (LONG) dMaxValue) {        
            lValue = (DWORD) dMaxValue;
        } else if (lValue < (LONG) dMinValue) {
            lValue = (DWORD) dMinValue;
        } else {
            bResult = FALSE;
        }

        if (bResult) {
            *pValue = lValue;
            UpdateData(FALSE);
            SetModifiedPage(TRUE);
        }
        *pResult = 0;
    } else {
        ASSERT ( FALSE );
    }

    return;
}

BOOL
CSmPropertyPage::SampleTimeIsLessThanSessionTime( CSmLogQuery* pQuery )
{
    BOOL        bIsValid = TRUE;
    SYSTEMTIME  stLocalTime;
    LONGLONG    llMaxStartTime;
    LONGLONG    llSessionMilliseconds = 0;
    LONGLONG    llSampleMilliseconds = 0;
    CString     strMsg;

    ResourceStateManager    rsm;
    
    if ( NULL != pQuery ) {
        if ( SLQ_TRACE_LOG != pQuery->GetLogType() ) {
            if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode ) {
    
                GetLocalTime (&stLocalTime);
                SystemTimeToFileTime (&stLocalTime, (FILETIME *)&llMaxStartTime);

                // For Manual Start mode, Now is used to determine session length.
                // For Start At mode, the later of Now vs. schedule start time
                // is used to determine session length.
                if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStartTime.dwAutoMode ) {
                    if ( m_SharedData.stiStartTime.llDateTime > llMaxStartTime ) {
                        llMaxStartTime = m_SharedData.stiStartTime.llDateTime;
                    }
                }
                // Calc and compare session seconds vs. sample seconds
                TimeInfoToMilliseconds ( &m_SharedData.stiSampleTime, &llSampleMilliseconds );

                llSessionMilliseconds = m_SharedData.stiStopTime.llDateTime - llMaxStartTime;
                llSessionMilliseconds /= FILETIME_TICS_PER_MILLISECOND;

                if ( llSessionMilliseconds < llSampleMilliseconds ) {
                    strMsg.LoadString ( IDS_SCHED_SESSION_TOO_SHORT );
                    MessageBox(strMsg, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    strMsg.Empty();
                    bIsValid = FALSE;
                }
            } else if ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ) { 
                TimeInfoToMilliseconds ( &m_SharedData.stiStopTime, &llSessionMilliseconds );
                TimeInfoToMilliseconds ( &m_SharedData.stiSampleTime, &llSampleMilliseconds );
        
                if ( llSessionMilliseconds < llSampleMilliseconds ) {
                    strMsg.LoadString ( IDS_SCHED_SESSION_TOO_SHORT );
                    MessageBox(strMsg, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    strMsg.Empty();
                    bIsValid = FALSE;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        bIsValid = FALSE;
    }
    return bIsValid;
}

BOOL
CSmPropertyPage::Apply( CSmLogQuery* pQuery )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    TCHAR   strComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    CString strComputer;
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bReturn = TRUE;
    HRESULT hr = NOERROR; 
    
    if ( NULL != pQuery ) {

        if( pQuery->m_fDirtyPassword & (PASSWORD_DIRTY|PASSWORD_SET) ){
            pQuery->m_fDirtyPassword = PASSWORD_CLEAN;
            strComputer =  pQuery->GetLogService()->GetMachineName();
            if( strComputer.IsEmpty() ){

                bReturn = GetComputerName( strComputerName, &dwSize );

                if ( !bReturn ) {
                    dwStatus = GetLastError();
                } else {
                    strComputer = strComputerName; 
                }
            }
            
            pQuery->m_strUser.TrimLeft();
            pQuery->m_strUser.TrimRight();

            if( pQuery->m_strUser.GetLength() ) {
                dwStatus = PdhPlaSetRunAs( 
                            (LPTSTR)(LPCTSTR)pQuery->GetLogName(), 
                            (LPTSTR)(LPCTSTR)strComputer, 
                            (LPTSTR)(LPCTSTR)pQuery->m_strUser, 
                            (LPTSTR)(LPCTSTR)pQuery->m_strPassword 
                        );
            } else {
                dwStatus = PdhPlaSetRunAs( 
                            (LPTSTR)(LPCTSTR)pQuery->GetLogName(), 
                            (LPTSTR)(LPCTSTR)strComputer, 
                            _T(""), 
                            _T("")
                        );
            }
        }
        if ( ERROR_SUCCESS == dwStatus 
                && bReturn
                && NULL != m_hConsole 
                && NULL != m_pDataObject) {

            // Only changes on the schedule page cause notification,
            // because only schedule changes cause a state change that is
            // visible in the result pane.
            hr = MMCPropertyChangeNotify (
                    m_hConsole,  // handle to a notification
                    (LPARAM) m_pDataObject);          // unique identifier
        }

        if ( ERROR_SUCCESS != dwStatus ) {
            bReturn = FALSE;
        }
    } else {
        ASSERT ( FALSE );
        bReturn = FALSE;
    }
    return bReturn;
}

void
CSmPropertyPage::SetRunAs( CSmLogQuery* pQuery )
{
    CPasswordDlg dlg;

    if ( NULL != pQuery ) {
        dlg.SetContextHelpFilePath( GetContextHelpFilePath() );

        pQuery->m_strUser.TrimLeft();
        pQuery->m_strUser.TrimRight();

        dlg.m_strUserName = pQuery->m_strUser;
        //
        // If we want to reset the RunAs information
        //
        if (pQuery->m_strUser.IsEmpty() || pQuery->m_strUser.GetAt(0) == L'<' ) {
            pQuery->m_strPassword = L"";
            pQuery->m_strUser = L"";
            pQuery->m_fDirtyPassword |= PASSWORD_SET;
        } else {
            if( dlg.DoModal() != IDCANCEL ){
                pQuery->m_strPassword = dlg.m_strPassword1;

                pQuery->m_strUser = dlg.m_strUserName;
                SetModifiedPage(TRUE);
                pQuery->m_fDirtyPassword |= PASSWORD_SET;
            }
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CSmPropertyPage::IsValidData( CSmLogQuery* pQuery, DWORD fReason )
{
    BOOL bIsValid = TRUE;
    CString strTestFileName;
    INT iPrevLength = 0;

    if ( NULL != pQuery ) {

        if ( bIsValid ) {
            if ( !IsActive() ) {
                pQuery->GetPropPageSharedData ( &m_SharedData );
            }
        }
    
        if( bIsValid && (fReason & VALIDATE_APPLY ) ){
            bIsValid = IsWritableQuery( pQuery );
        }

        if( bIsValid ){
            bIsValid = IsValidLocalData();
        }
    
        if( bIsValid ){
            if( (pQuery->m_fDirtyPassword & PASSWORD_DIRTY) && !(pQuery->m_fDirtyPassword & PASSWORD_SET) ){

                // Note: Trimming can be moved to SetRunAs.  Left outside
                // for clarity.
                iPrevLength = m_strUserDisplay.GetLength();

                m_strUserDisplay.TrimLeft();
                m_strUserDisplay.TrimRight();

                SetRunAs( pQuery );

                if ( iPrevLength != m_strUserDisplay.GetLength() ) {
                    SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
                }

                if( !(pQuery->m_fDirtyPassword & PASSWORD_SET) ){
                    bIsValid = FALSE;
                }
            }
        }

        // Validate log file name and folder for filetypes
        if ( bIsValid 
                && SLQ_ALERT != pQuery->GetLogType() 
                && (fReason & VALIDATE_APPLY ) ) {
            if ( pQuery->GetLogService()->IsLocalMachine() ) {
                if ( SLF_SQL_LOG != m_SharedData.dwLogFileType ) {
                    //  bIsValid is returned as FALSE if the user cancels directory creation.
                    ProcessDirPath (
                        m_SharedData.strFolderName, 
                        pQuery->GetLogName(), 
                        this, 
                        bIsValid, 
                        FALSE );
                }
            }

            if ( bIsValid ) {

                CreateSampleFileName (
                    pQuery->GetLogName(),
                    pQuery->GetLogService()->GetMachineName(),
                    m_SharedData.strFolderName, 
                    m_SharedData.strFileBaseName,
                    m_SharedData.strSqlName,
                    m_SharedData.dwSuffix, 
                    m_SharedData.dwLogFileType, 
                    m_SharedData.dwSerialNumber,
                    strTestFileName);

                if ( MAX_PATH <= strTestFileName.GetLength() ) {
                    CString strMessage;
                    strMessage.LoadString ( IDS_FILENAMETOOLONG );
                    MessageBox ( strMessage, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);            
                    bIsValid = FALSE;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        bIsValid = FALSE;
    }

    return bIsValid;
}

BOOL
CSmPropertyPage::IsWritableQuery( CSmLogQuery* pQuery )
{
    BOOL bIsValid = FALSE;

    if ( NULL != pQuery ) {

        bIsValid = !pQuery->IsExecuteOnly() && !pQuery->IsReadOnly();
        if ( !bIsValid ) {
            CString strMessage;
            CString strMachineName;
            DWORD   dwMessageId;

            pQuery->GetMachineDisplayName( strMachineName );
    
            dwMessageId = pQuery->IsExecuteOnly() ? SMCFG_NO_MODIFY_DEFAULT_LOG : SMCFG_NO_MODIFY_ACCESS;

            FormatSmLogCfgMessage ( 
                strMessage,
                m_hModule, 
                dwMessageId, 
                (LPCTSTR)strMachineName );
                
            MessageBox ( strMessage, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        }
    } else {
        ASSERT ( FALSE );
    }
    return bIsValid;
}

BOOL
CSmPropertyPage::SampleIntervalIsInRange(
    SLQ_TIME_INFO& rstiSample,
    const CString&  rstrQueryName )
{
    LONGLONG    llMillisecondSampleInt;
    BOOL bIsValid = TRUE;
// 45 days in milliseconds = 1000*60*60*24*45
#define FORTYFIVE_DAYS (0xE7BE2C00)

    TimeInfoToMilliseconds (&rstiSample, &llMillisecondSampleInt );

    bIsValid = ( FORTYFIVE_DAYS >= llMillisecondSampleInt );

    if ( !bIsValid ) {
        CString strMessage;

        strMessage.LoadString ( IDS_ERRMSG_SAMPLEINTTOOLARGE );
        MessageBox ( strMessage, rstrQueryName, MB_OK  | MB_ICONERROR);            
    }

    return bIsValid;
}

DWORD 
CSmPropertyPage::SetContextHelpFilePath( const CString& rstrPath )
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strContextHelpFilePath = rstrPath; 
    MFC_CATCH_DWSTATUS

    return dwStatus;
}    

void
CSmPropertyPage::SetModifiedPage( const BOOL bModified )
{
    m_bIsModifiedPage = bModified;
    SetModified ( bModified );
    return;
}    

CSmPropertyPage::eStartType
CSmPropertyPage::DetermineCurrentStartType( void )
{
    eStartType eCurrentStartType;
    SLQ_TIME_INFO*  pstiStart;
    SLQ_TIME_INFO*  pstiStop;
    SYSTEMTIME  stLocalTime;
    FILETIME    ftLocalTime;
    LONGLONG    llLocalTime;
    ResourceStateManager    rsm;

    pstiStart = &m_SharedData.stiStartTime;

    ASSERT ( SLQ_TT_TTYPE_START == pstiStart->wTimeType );

    if ( SLQ_AUTO_MODE_NONE == pstiStart->dwAutoMode ) {
        if ( pstiStart->llDateTime != MIN_TIME_VALUE ) {
            eCurrentStartType = eStartManually;
        } else {
            eCurrentStartType = eStartImmediately;
        }
    } else {
 
        GetLocalTime (&stLocalTime);
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        llLocalTime = *((LONGLONG *)(&ftLocalTime));

        // Test current time to determine most appropriate text
        if (llLocalTime < pstiStart->llDateTime) {
            // then the start time is in the future
            eCurrentStartType = eStartSched;
        } else {
            // Start immediately, unless manual or scheduled stop time is already past.
            pstiStop = &m_SharedData.stiStopTime;

            if ( SLQ_AUTO_MODE_NONE == pstiStop->dwAutoMode 
                    && llLocalTime > pstiStop->llDateTime ) {
                eCurrentStartType = eStartManually;
            } else {
                eCurrentStartType = eStartImmediately;
            }
        }
    }

    return eCurrentStartType;
} 
   
DWORD 
CSmPropertyPage::AllocInitCounterPath( 
    const LPTSTR szCounterPath,
    PPDH_COUNTER_PATH_ELEMENTS* ppCounter )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDH_COUNTER_PATH_ELEMENTS pLocalCounter = NULL;
    ULONG       ulBufSize = 0;

    if ( NULL != szCounterPath && NULL != ppCounter ) {
        *ppCounter = NULL;

        pdhStatus = PdhParseCounterPath(
                        szCounterPath, 
                        pLocalCounter, 
                        &ulBufSize, 
                        0 );

        if ( 0 < ulBufSize ) {
            pLocalCounter = (PPDH_COUNTER_PATH_ELEMENTS) G_ALLOC( ulBufSize);
            ZeroMemory ( pLocalCounter, ulBufSize );

            if ( NULL != pLocalCounter ) {
                dwStatus = pdhStatus = PdhParseCounterPath( 
                                        szCounterPath, 
                                        pLocalCounter, 
                                        &ulBufSize, 
                                        0);

                if ( ERROR_SUCCESS != pdhStatus ) {
                    delete pLocalCounter;
                    pLocalCounter = NULL;
                }

            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
        if ( ERROR_SUCCESS == dwStatus && NULL != pLocalCounter ) {
            *ppCounter = pLocalCounter;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        ASSERT ( FALSE );
    }
    return dwStatus;
}
BOOL
CSmPropertyPage::ConnectRemoteWbemFail(CSmLogQuery* pQuery, BOOL bNotTouchRunAs)
/*++

Routine Description:

    The function display an error message telling users they can not
    modify the RunAs information.

Arguments:

    pQuery - Query structure

    bNotTouchRunAs - Don't check/restore RunAs after displaying dialog


Return Value:

    Return TRUE if the RunAs need to be restored to its original one,
    otherwise return FALSE

--*/
{
    CString strMessage;
    CString strSysMessage;
    IWbemStatusCodeText * pStatus = NULL;
    HRESULT hr;

    //
    // If bNotTouchRunAs is TRUE,  don't try to restore the RunAs info.
    //
    if (!bNotTouchRunAs) {
        if (m_strUserDisplay == m_strUserSaved) {
            return FALSE;
        }
    }

    FormatSmLogCfgMessage (
        strMessage,
        m_hModule,
        SMCFG_SYSTEM_MESSAGE,
        (LPCWSTR)pQuery->GetLogName());

    hr = CoCreateInstance(CLSID_WbemStatusCodeText,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemStatusCodeText,
                          (LPVOID *) &pStatus);

    if (hr == S_OK) {
        BSTR bstr = 0;
        hr = pStatus->GetErrorCodeText(pQuery->GetLogService()->m_hWbemAccessStatus, 0, 0, &bstr);

        if (hr == S_OK){
            strSysMessage = bstr;
            SysFreeString(bstr);
            bstr = 0;
        }

        pStatus->Release();
    }

    if ( strSysMessage.IsEmpty() ) {
        strSysMessage.Format ( L"0x%08lX", pQuery->GetLogService()->m_hWbemAccessStatus);
    }
    strMessage += strSysMessage;

    MessageBox( strMessage, pQuery->GetLogName(), MB_OK );
    return TRUE;
}

CWnd* CSmPropertyPage::GetRunAsWindow()
{
    CWnd* pWnd;
    CWnd* pRunAs;

    pWnd = GetDlgItem(IDC_RUNAS_EDIT);
    if (pWnd) {
        pRunAs = pWnd->GetNextWindow(GW_HWNDPREV);
        return pRunAs;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\stdafx.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    StdAfx.cpp

Abstract:

    stdafx.cpp : source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smtraceq.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtraceq.h

Abstract:

    Class definitions for the trace log query class.

--*/

#ifndef _CLASS_SMTRACEQ_
#define _CLASS_SMTRACEQ_

#include "smlogqry.h"

// open method flags
// only open an existing entry
#define SLQ_OPEN_EXISTING   0
// always create a new and uninitialized entry
#define SLQ_CREATE_NEW      1
// open an existing entry if it exists or create an empty one if not
#define SLQ_OPEN_ALWAYS     2

typedef struct _SLQ_TRACE_LOG_INFO {
    DWORD   dwBufferSize;   // in K bytes
    DWORD   dwMinimumBuffers;
    DWORD   dwMaximumBuffers;
    DWORD   dwBufferFlushInterval; // in seconds
    DWORD   dwBufferFlags; // defined in common.h
} SLQ_TRACE_LOG_INFO, *PSLQ_TRACE_LOG_INFO;

//
//  This object is used to represent trace log queries
//
//

class CSmTraceLogQuery : public CSmLogQuery
{
    // constructor/destructor
    public:
                CSmTraceLogQuery( CSmLogService* );
        virtual ~CSmTraceLogQuery( void );

    // public methods
    public:

        enum eProviderState {
            eNotInQuery = 0,
            eInQuery = 1
        };

        virtual DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly);
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry ( void );
                HRESULT SyncGenProviders ( void );

        virtual BOOL    GetLogTime ( PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags );
        virtual BOOL    SetLogTime ( PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags );
        virtual BOOL    GetDefaultLogTime ( SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags );

        virtual DWORD   GetLogType ( void );

                BOOL    GetTraceLogInfo ( PSLQ_TRACE_LOG_INFO pptlInfo );
                BOOL    SetTraceLogInfo ( PSLQ_TRACE_LOG_INFO pptlInfo );

                BOOL    GetKernelFlags ( DWORD& rdwFlags );
                BOOL    SetKernelFlags ( DWORD dwFlags );

                DWORD   InitGenProvidersArray ( void );

                LPCTSTR GetProviderDescription ( INT iProvIndex );
                LPCTSTR GetProviderGuid ( INT iProvIndex );
                BOOL    IsEnabledProvider ( INT iProvIndex );
                BOOL    IsActiveProvider ( INT iProvIndex );
                DWORD   GetGenProviderCount ( INT& iCount );

                LPCTSTR GetKernelProviderDescription ( void );
                BOOL    GetKernelProviderEnabled ( void );

                INT     GetFirstInactiveIndex ( void );
                INT     GetNextInactiveIndex ( void );
                BOOL    ActiveProviderExists ( void );

                DWORD   GetInQueryProviders ( CArray<eProviderState, eProviderState&>& );
                DWORD   SetInQueryProviders ( CArray<eProviderState, eProviderState&>& );

        virtual HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
		virtual HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );

        virtual CSmTraceLogQuery* CastToTraceLogQuery ( void ) { return this; };
    // protected methods
    protected:
        virtual DWORD   UpdateRegistry();

    // private member variables
    private:

                VOID    ResetInQueryProviderList ( void );
                BOOL    AddInQueryProvider ( LPCTSTR szProviderPath);
                LPCTSTR GetFirstInQueryProvider ( void );
                LPCTSTR GetNextInQueryProvider ( void );

        LPTSTR  m_szNextInQueryProvider;
        DWORD   m_dwInQueryProviderListLength;  // in chars including MSZ null

        CArray<eProviderState, eProviderState&> m_arrGenProviders;

        INT     m_iNextInactiveIndex;

        // Registry Values
        LPTSTR  mr_szInQueryProviderList;
        SLQ_TRACE_LOG_INFO  mr_stlInfo;
        DWORD               m_dwKernelFlags; // defined in common.h

};


typedef CSmTraceLogQuery   SLTRACEQUERY;
typedef CSmTraceLogQuery*  PSLTRACEQUERY;


#endif //_CLASS_SMTRACEQ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\sqlprop.cpp ===
// SqlProp.cpp : implementation file
//

#include "stdafx.h"
#include "smlogcfg.h"
#include "smcfgmsg.h"
#include "fileprop.h"
#include "sql.h"
#include "sqlext.h"
#include "odbcinst.h"
#include "smlogqry.h"
#include "Fileprop.h"
#include "SqlProp.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(sqlprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_SQL_DSN_COMBO,      IDH_SQL_DSN_COMBO,
    IDC_SQL_LOG_SET_EDIT,   IDH_SQL_FILENAME_EDIT,
    IDC_SQL_SIZE_MAX_BTN,   IDH_SQL_SIZE_MAX_BTN,
    IDC_SQL_SIZE_LIMIT_EDIT,IDH_SQL_SIZE_LIMIT_EDIT,
    IDC_SQL_SIZE_LIMIT_BTN, IDH_SQL_SIZE_LIMIT_BTN,
    IDC_SQL_SIZE_LIMIT_SPIN,IDH_SQL_SIZE_LIMIT_SPIN,
    0,0
};
/////////////////////////////////////////////////////////////////////////////
// CSqlProp dialog

CSqlProp::CSqlProp(CWnd* pParent /*=NULL*/)
	: CDialog(CSqlProp::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSqlProp)
    m_dwMaxSize = 0;
	m_nSqlSizeRdo = -1;
    m_dwFocusControl = 0;
	//}}AFX_DATA_INIT
    m_bAutoNameSuffix = FALSE;
    m_dwMaxSizeInternal = 0;
}

void CSqlProp::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);  
	//{{AFX_DATA_MAP(CSqlProp)
	DDX_Control(pDX, IDC_SQL_DSN_COMBO, m_comboDSN);
	DDX_Text(pDX, IDC_SQL_LOG_SET_EDIT, m_strLogSetName);
    DDV_MaxChars(pDX, m_strLogSetName, SLQ_MAX_LOG_SET_NAME_LEN);
	DDX_Radio(pDX, IDC_SQL_SIZE_MAX_BTN, m_nSqlSizeRdo);
    ValidateTextEdit(pDX, IDC_SQL_SIZE_LIMIT_EDIT, 9, 
        &m_dwMaxSize, (DWORD)CFilesProperty::eMinSqlRecordsLimit, (DWORD)CFilesProperty::eMaxSqlRecordsLimit);
	//}}AFX_DATA_MAP
    
    
    if ( pDX->m_bSaveAndValidate ) {
        
        if (((CButton *)GetDlgItem(IDC_SQL_SIZE_MAX_BTN))->GetCheck() == 1) {
            m_dwMaxSizeInternal = SLQ_DISK_MAX_SIZE;
        } else {
            m_dwMaxSizeInternal = m_dwMaxSize;
        }    

    }
}

BEGIN_MESSAGE_MAP(CSqlProp, CDialog)
	//{{AFX_MSG_MAP(CSqlProp)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
	ON_EN_KILLFOCUS(IDC_SQL_LOG_SET_EDIT, OnKillfocusSqlLogSetEdit)
	ON_EN_CHANGE(IDC_SQL_LOG_SET_EDIT, OnChangeSqlLogSetEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SQL_SIZE_LIMIT_SPIN, OnDeltaposSqlSizeLimitSpin)
    ON_BN_CLICKED(IDC_SQL_SIZE_MAX_BTN, OnSqlSizeMaxBtn)
	ON_BN_CLICKED(IDC_SQL_SIZE_LIMIT_BTN, OnSqlSizeLimitBtn)
	ON_EN_CHANGE(IDC_SQL_SIZE_LIMIT_EDIT, OnChangeSqlSizeLimitEdit)
    ON_EN_KILLFOCUS(IDC_SQL_SIZE_LIMIT_EDIT, OnKillfocusSqlSizeLimitEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSqlProp message handlers

BOOL CSqlProp::OnInitDialog() 
{
	BOOL bLimitBtnSet;
    BOOL bReturn = TRUE;

    // set the buttons 
    m_nSqlSizeRdo = 1;
    if (m_dwMaxSizeInternal == SLQ_DISK_MAX_SIZE) {
        m_nSqlSizeRdo = 0;
        m_dwMaxSize = 1000; // default
    } else {
        m_nSqlSizeRdo = 1;
        m_dwMaxSize = m_dwMaxSizeInternal;
    }	

    CDialog::OnInitDialog();

    ASSERT ( NULL != m_pLogQuery );

    InitDSNCombo();

    bLimitBtnSet = (m_nSqlSizeRdo == 1);
    ((CButton *) GetDlgItem(IDC_SQL_SIZE_LIMIT_BTN))->SetCheck(bLimitBtnSet);
    ((CButton *) GetDlgItem(IDC_SQL_SIZE_MAX_BTN))->SetCheck(! bLimitBtnSet);
    GetDlgItem(IDC_SQL_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);
    GetDlgItem(IDC_SQL_SIZE_LIMIT_SPIN)->EnableWindow(bLimitBtnSet);
    GetDlgItem(IDC_SQL_SIZE_LIMIT_UNITS)->EnableWindow(bLimitBtnSet);

    if ( 0 != m_dwFocusControl ) {
        GetDlgItem ( m_dwFocusControl )->SetFocus();  
        bReturn = FALSE;
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LPWSTR  CSqlProp::InitDSNCombo(){
	HENV    henv;
	RETCODE retcode;
	WCHAR    szDSNName[SQL_MAX_DSN_LENGTH + 1];
    int      nIndex = 0;
    INT      iCurSel = 0;

    if(SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_ENV, NULL, &henv)))
	{
		// set the ODBC behavior version.
		(void) SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION,
					(SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER);

		// Enumerate the user data sources.
        m_comboDSN.ResetContent();
		
        retcode = SQLDataSources (
                                  henv,
                                  SQL_FETCH_FIRST_SYSTEM,
                                  szDSNName,
                                  sizeof(szDSNName),
                                  NULL,
                                  NULL,
                                  0,
                                  NULL
                                  );
        while(SQL_SUCCEEDED(retcode))
		{
            m_comboDSN.AddString(szDSNName);

            if ( 0 == m_strDSN.CompareNoCase ( szDSNName ) ) {
                iCurSel = nIndex;
            }

            nIndex++;

			// Do the next one, if it exists.
			retcode = SQLDataSources (
                                      henv,
                                      SQL_FETCH_NEXT,
                                      szDSNName,
                                      sizeof(szDSNName),
                                      NULL,
                                      NULL,
                                      0,
                                      NULL
                                      );		
		}

		SQLFreeHandle(SQL_HANDLE_ENV, henv);
	}

    m_comboDSN.SetCurSel(iCurSel);

    return 0;
}

BOOL CSqlProp::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    INT  iPrevLength = 0;

    ResourceStateManager    rsm;

    // assumes UpdateData has been called

    // Trim log set name before validation
    iPrevLength = m_strLogSetName.GetLength();
    m_strLogSetName.TrimLeft();
    m_strLogSetName.TrimRight();
    
    if ( iPrevLength != m_strLogSetName.GetLength() ) {
        SetDlgItemText ( IDC_SQL_LOG_SET_EDIT, m_strLogSetName );  
    }

    m_comboDSN.GetLBText(m_comboDSN.GetCurSel(),m_strDSN.GetBuffer(m_comboDSN.GetLBTextLen(m_comboDSN.GetCurSel())));
    m_strDSN.ReleaseBuffer();
    if ( m_strDSN.IsEmpty() ) {
        CString strMessage;
        strMessage.LoadString ( IDS_SQL_ERR_NODSN );
        MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        m_comboDSN.SetFocus();
        bIsValid = FALSE;
    }

    if (bIsValid) {
        if ( m_strLogSetName.IsEmpty() ) {
            if ( !m_bAutoNameSuffix ) {
                CString strMessage;
                strMessage.LoadString ( IDS_SQL_ERR_NOLOGSETNAME );
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                (GetDlgItem(IDC_SQL_LOG_SET_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
       } else {
            if ( !FileNameIsValid ( &m_strLogSetName ) ){
                CString strMessage;
                strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                MessageBox( strMessage, m_pLogQuery->GetLogName(), MB_OK| MB_ICONERROR );
                (GetDlgItem(IDC_SQL_LOG_SET_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
        }
    }

    if (bIsValid)
    {
        if ( SLQ_DISK_MAX_SIZE != m_dwMaxSizeInternal ) {
            bIsValid = ValidateDWordInterval(IDC_SQL_SIZE_LIMIT_EDIT,
                                             m_pLogQuery->GetLogName(),
                                             m_dwMaxSizeInternal,
                                             (DWORD)CFilesProperty::eMinSqlRecordsLimit,
                                             (DWORD)CFilesProperty::eMaxSqlRecordsLimit);
        }
    }

    return bIsValid;
}

void
CSqlProp::ValidateTextEdit (
    CDataExchange*  pDX,
    int             nIDC,
    int             nMaxChars,
    DWORD*          pValue,
    DWORD           /* minValue */,
    DWORD           /* maxValue */)
{
    HWND    hWndCtrl       = pDX->PrepareEditCtrl(nIDC);
    LONG    currentValue   = INVALID_DWORD;
    TCHAR   szT[MAXSTR];
    CString strTemp;

    if ( NULL != pDX && NULL != pValue ) {
        if (pDX->m_bSaveAndValidate)
        {
            * pValue = (DWORD) currentValue;

            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, nMaxChars);

            if (szT[0] >= _T('0') && szT[0] <= _T('9'))
            {
                currentValue = _wtol(szT);
                * pValue      = (DWORD) currentValue;
            }
        } else {
            if ( INVALID_DWORD != *pValue ) {
                wsprintf(szT, _T("%lu"), *pValue);
            } else {
                szT[0] = _T('\0');
            }
            GetDlgItem(nIDC)->SetWindowText(szT);
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CSqlProp::ValidateDWordInterval ( 
    int     nIDC,
    LPCWSTR strLogName,
    DWORD   dwValue,
    DWORD   minValue,
    DWORD   maxValue)
{
    CString strMsg;
    BOOL    bResult =  (dwValue >= minValue)
                    && (dwValue <= maxValue);

    if (! bResult)
    {
        strMsg.Format ( IDS_ERRMSG_INVALIDDWORD, minValue, maxValue );
        MessageBox(strMsg, strLogName, MB_OK  | MB_ICONERROR);
        GetDlgItem(nIDC)->SetFocus();
        strMsg.Empty();
    }
    return (bResult);
}

CString 
CSqlProp::ComposeSQLLogName()
{
    CString     strDSNName;
    CString     strSQLLogName;
    
    m_comboDSN.GetLBText(m_comboDSN.GetCurSel(),m_strDSN.GetBuffer(m_comboDSN.GetLBTextLen(m_comboDSN.GetCurSel())));
    
    strSQLLogName.Format(L"SQL:%s!%s",m_strDSN,m_strLogSetName);

    m_strDSN.ReleaseBuffer();
    
    return strSQLLogName;

}

void CSqlProp::OnOK() 
{
    // load data from dialog        
    if ( UpdateData (TRUE) ) {
        if ( IsValidLocalData() ) {
            m_SqlFormattedLogName = ComposeSQLLogName();
            CDialog::OnOK();
        }
    }
}

void CSqlProp::OnKillfocusSqlLogSetEdit() 
{
    UpdateData( TRUE );
}

void CSqlProp::OnChangeSqlLogSetEdit() 
{
    UpdateData( TRUE );
}

void CSqlProp::OnSqlSizeLimitBtn() 
{
    FileSizeBtn(FALSE);	
}

void CSqlProp::OnChangeSqlSizeLimitEdit()
{
    UpdateData( TRUE );
}

void CSqlProp::OnKillfocusSqlSizeLimitEdit() 
{
    UpdateData ( TRUE );
}

void CSqlProp::OnDeltaposSqlSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin( 
        pNMHDR, 
        pResult, 
        &m_dwMaxSize, 
        (DWORD)CFilesProperty::eMinSqlRecordsLimit, 
        (DWORD)CFilesProperty::eMaxSqlRecordsLimit);
}

void CSqlProp::OnSqlSizeMaxBtn() 
{
    FileSizeBtn(FALSE);
}

void CSqlProp::FileSizeBtnEnable()
{
    GetDlgItem(IDC_SQL_SIZE_MAX_BTN)->EnableWindow ( TRUE );
}

void CSqlProp::FileSizeBtn(BOOL bInit)
{
    INT     m_nRecordSizeOld;
    
    m_nRecordSizeOld = m_nSqlSizeRdo;

    UpdateData ( TRUE );
    
    if (bInit || (m_nRecordSizeOld != m_nSqlSizeRdo)) {
        BOOL    bMaxBtnSet, bLimitBtnSet;
        
        // *** This can be replaced since DDX_Radio implemented.
        // get btn state    
        bMaxBtnSet = ((CButton *)GetDlgItem(IDC_SQL_SIZE_MAX_BTN))->GetCheck() == 1;
        bLimitBtnSet = ((CButton *)GetDlgItem(IDC_SQL_SIZE_LIMIT_BTN))->GetCheck() == 1;
    
        ASSERT (bLimitBtnSet != bMaxBtnSet);

        GetDlgItem(IDC_SQL_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_SQL_SIZE_LIMIT_SPIN)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_SQL_SIZE_LIMIT_UNITS)->EnableWindow(bLimitBtnSet);
    }
}

void 
CSqlProp::OnDeltaposSpin(
    NMHDR   *pNMHDR, 
    LRESULT *pResult, 
    DWORD   *pValue, 
    DWORD   dMinValue, 
    DWORD   dMaxValue)
{
    NM_UPDOWN* pNMUpDown;
    LONG       lValue;
    BOOL       bResult   = TRUE;

    UpdateData(TRUE);

    ASSERT(dMinValue <= dMaxValue);

    if ( NULL != pNMHDR
        && NULL != pResult
        && NULL != pValue ) 
    {
        pNMUpDown = (NM_UPDOWN *) pNMHDR;
        lValue    = (LONG) (*pValue);

        if (lValue == INVALID_DWORD) {
            lValue = (DWORD) dMinValue;
        } else {

            if ( ((lValue >= (LONG) dMinValue + 1) && (pNMUpDown->iDelta > 0))
                || ((lValue <= (LONG) dMaxValue - 1) && (pNMUpDown->iDelta < 0)))
            {
                lValue += (pNMUpDown->iDelta * -1);

                if (lValue > (LONG) dMaxValue) {
                    lValue = (DWORD) dMaxValue;
                } else if (lValue < (LONG) dMinValue) {
                    lValue = (DWORD) dMinValue;
                }
            } else if (lValue > (LONG) dMaxValue) {        
                lValue = (DWORD) dMaxValue;
            } else if (lValue < (LONG) dMinValue) {
                lValue = (DWORD) dMinValue;
            } else {
                bResult = FALSE;
            }
        }

        if (bResult) {
            *pValue = lValue;
            UpdateData(FALSE);
        }
        *pResult = 0;
    } else {
        ASSERT ( FALSE );
    }

    return;
}

BOOL
CSqlProp::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if ( pHelpInfo->iCtrlId >= IDC_SQL_FIRST_HELP_CTRL_ID ||
        pHelpInfo->iCtrlId == IDOK ||
        pHelpInfo->iCtrlId == IDCANCEL ) {

        InvokeWinHelp(WM_HELP,
                      NULL,
                      (LPARAM) pHelpInfo,
                      m_strHelpFilePath,
                      s_aulHelpIds);
    }
    return TRUE;
}

void 
CSqlProp::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strHelpFilePath, s_aulHelpIds);

    return;
}

DWORD
CSqlProp::SetContextHelpFilePath(const CString& rstrPath)
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strHelpFilePath = rstrPath;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smtracsv.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtracsv.cpp

Abstract:

    This object is used to represent the trace log query components of the
    sysmon log service


--*/

#include "Stdafx.h"
#include "smtprov.h"
#include "smtraceq.h"
#include "smtracsv.h"

USE_HANDLE_MACROS("SMLOGCFG(smalrtq.cpp)");

//
//  Constructor
CSmTraceLogService::CSmTraceLogService()
:   m_pProviders ( NULL )
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    strTemp.LoadString ( IDS_SERVICE_NAME_TRACE );
    SetBaseName ( strTemp ); 
    strTemp.LoadString ( IDS_TRACE_NODE_DESCRIPTION );
    SetDescription( strTemp ); 
}

//
//  Destructor
CSmTraceLogService::~CSmTraceLogService()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_pProviders );
    return;
}

PSLQUERY    
CSmTraceLogService::CreateQuery ( const CString& rstrName )
{
    return ( CSmLogService::CreateTypedQuery( rstrName, SLQ_TRACE_LOG ) );
}

DWORD   
CSmTraceLogService::DeleteQuery ( PSLQUERY pQuery ) 
{
    ASSERT ( SLQ_TRACE_LOG == pQuery->GetLogType ( ) );
    return ( CSmLogService::DeleteQuery ( pQuery ) );
}

DWORD   
CSmTraceLogService::LoadQueries ( void )
{
    return ( CSmLogService::LoadQueries( SLQ_TRACE_LOG ) );
}

//  
//  Open function. Opens all existing log query entries.
//
DWORD   
CSmTraceLogService::Open ( const CString& rstrMachineName )
{
    DWORD dwStatus = ERROR_SUCCESS;

    // Initialize trace provider list.
    
    MFC_TRY
        m_pProviders = new CSmTraceProviders ( this );
    MFC_CATCH_DWSTATUS

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = m_pProviders->Open( rstrMachineName );
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = CSmLogService::Open ( rstrMachineName );
    }

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmTraceLogService::Close ()
{
    // Close and delete the list of trace providers
    if ( NULL != m_pProviders ) {
        m_pProviders->Close();
        delete m_pProviders;
        m_pProviders = NULL;
    }

    return ( CSmLogService::Close() );
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match.
//
//      Updates the trace provider list.
//  
DWORD   
CSmTraceLogService::SyncWithRegistry()
{
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = CSmLogService::SyncWithRegistry();

    return dwStatus;
}

CSmTraceProviders* 
CSmTraceLogService::GetProviders()
{
    return m_pProviders;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smtracsv.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtracsv.h

Abstract:

	This object is used to represent the trace log query components of the
	sysmon log service

--*/

#ifndef _CLASS_SMTRACELOGSERVICE_
#define _CLASS_SMTRACELOGSERVICE_

#include "smlogs.h"

class CSmTraceProviders;

class CSmTraceLogService : public CSmLogService
{

friend class CSmTraceProviders;

    // constructor/destructor
    public:
        CSmTraceLogService();
        
        virtual ~CSmTraceLogService();

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry();

        virtual PSLQUERY    CreateQuery ( const CString& rstrName );
        virtual DWORD       DeleteQuery ( PSLQUERY pQuery );

        virtual CSmTraceLogService* CastToTraceLogService( void ) { return this; };

        CSmTraceProviders*  GetProviders( void );

    protected:
        
        virtual DWORD       LoadQueries( void );

    private:

        HKEY        GetMachineKey ( void ) 
                        { return GetMachineRegistryKey(); };
        
        CSmTraceProviders* m_pProviders;
};



#endif //_CLASS_SMTRACELOGSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\sqlprop.h ===
#if !defined(AFX_SQLPROP_H__INCLUDED_)
#define AFX_SQLPROP_H__INCLUDED_



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SqlProp.h : header file
//

#define IDD_SQL_PROP                    2100

#define IDC_SQL_FIRST_HELP_CTRL_ID      2101
#define IDC_SQL_DSN_COMBO               2102
#define IDC_SQL_LOG_SET_EDIT            2103
#define IDC_SQL_SIZE_MAX_BTN            2104
#define IDC_SQL_SIZE_LIMIT_EDIT         2105
#define IDC_SQL_SIZE_LIMIT_BTN          2106
#define IDC_SQL_SIZE_LIMIT_SPIN         2107
#define IDC_SQL_SIZE_LIMIT_UNITS        2108


/////////////////////////////////////////////////////////////////////////////
// CSqlProp dialog

class CSqlProp : public CDialog
{
public:
    // Construction
	        CSqlProp(CWnd* pParent = NULL);   // standard constructor
    virtual ~CSqlProp(){};  

    DWORD SetContextHelpFilePath(const CString & rstrPath);

	//{{AFX_DATA(CSqlProp)
	enum { IDD = IDD_SQL_PROP };
	CComboBox	m_comboDSN;
	CString	    m_strDSN;
	CString	    m_strLogSetName;
    DWORD   m_dwSerialNumber;
    DWORD   m_dwMaxSize;
    int		m_nSqlSizeRdo;
	//}}AFX_DATA

    UINT    m_dwMaxSizeInternal;
    CString m_SqlFormattedLogName;
    BOOL    m_bAutoNameSuffix;

    DWORD   m_dwLogFileTypeValue;
	HINSTANCE m_hModule;
    DWORD   m_dwFocusControl;
    CSmLogQuery* m_pLogQuery;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSqlProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSqlProp)
	virtual void OnOK();
	afx_msg void OnKillfocusSqlLogSetEdit();
	afx_msg void OnChangeSqlLogSetEdit();
	afx_msg void OnChangeSqlSizeLimitEdit();
	afx_msg void OnDeltaposSqlSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSqlSizeMaxBtn();
	afx_msg void OnSqlSizeLimitBtn();
    afx_msg void OnKillfocusSqlSizeLimitEdit();
    afx_msg BOOL OnHelpInfo(HELPINFO *);
    afx_msg void OnContextMenu( CWnd*, CPoint );
    virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    BOOL IsValidLocalData();
	void FileSizeBtn(BOOL bInit);
	void FileSizeBtnEnable();
	void OnDeltaposSpin(NMHDR *pNMHDR, LRESULT *pResult, DWORD *pValue, DWORD dMinValue, DWORD dMaxValue);
    
    LPWSTR  InitDSNCombo();
    CString ComposeSQLLogName();
        
    void    ValidateTextEdit(CDataExchange * pDX,
                             int             nIDC,
                             int             nMaxChars,
                             DWORD         * value,
                             DWORD           minValue,
                             DWORD           maxValue);
    
    BOOL    ValidateDWordInterval(int     nIDC,
                                  LPCWSTR strLogName,
                                  DWORD   dwValue,
                                  DWORD   minValue,
                                  DWORD   maxValue);

    CString m_strHelpFilePath;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SQLPROP_H__BADE97DF_A969_435A_A348_C9A18F9CE035__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\smtraceq.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtraceq.cpp

Abstract:

    Implementation of the trace log query class.

--*/

#include "Stdafx.h"
#include <pdh.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include "smcfgmsg.h"
#include "smtprov.h"
#include "smtracsv.h"
#include "smtraceq.h"

USE_HANDLE_MACROS("SMLOGCFG(smtraceq.cpp)");

#define  TRACE_DEFAULT_BUFFER_SIZE      ((DWORD)0x00000004)
#define  TRACE_DEFAULT_MIN_COUNT        ((DWORD)0x00000003)
#define  TRACE_DEFAULT_MAX_COUNT        ((DWORD)0x00000019)
#define  TRACE_DEFAULT_BUFFER_FLUSH_INT ((DWORD)0)
#define  TRACE_DEFAULT_FLAGS            ((DWORD)0)

//
//  Constructor
CSmTraceLogQuery::CSmTraceLogQuery( CSmLogService* pLogService )
:   CSmLogQuery( pLogService ),
    m_dwInQueryProviderListLength ( 0 ),
    m_szNextInQueryProvider ( NULL ),
    mr_szInQueryProviderList ( NULL ),
    m_iNextInactiveIndex ( -1 ),
    m_dwKernelFlags (0)
{
    // initialize member variables
    memset (&mr_stlInfo, 0, sizeof(mr_stlInfo));
    return;
}

//
//  Destructor
CSmTraceLogQuery::~CSmTraceLogQuery()
{
    return;
}

//
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD
CSmTraceLogQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT ( SLQ_TRACE_LOG == GetLogType() );

    dwStatus = CSmLogQuery::Open ( rstrName, hKeyQuery, bReadOnly );

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//
DWORD
CSmTraceLogQuery::Close ()
{
    DWORD dwStatus;
    LOCALTRACE (L"Closing Query\n");

    if (mr_szInQueryProviderList != NULL) {
        delete (mr_szInQueryProviderList);
        mr_szInQueryProviderList = NULL;
    }

    dwStatus = CSmLogQuery::Close();

    return dwStatus;
}

//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD
CSmTraceLogQuery::UpdateRegistry() {
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize = 0;
    DWORD   dwTraceFlags = 0;

    if ( IsModifiable() ) {

        // get trace log values
        dwStatus = WriteRegistryDwordValue (
            m_hKeyQuery,
            IDS_REG_TRACE_BUFFER_SIZE,
            &mr_stlInfo.dwBufferSize);

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_BUFFER_MIN_COUNT,
                &mr_stlInfo.dwMinimumBuffers);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_BUFFER_MAX_COUNT,
                &mr_stlInfo.dwMaximumBuffers);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_BUFFER_FLUSH_INT,
                &mr_stlInfo.dwBufferFlushInterval);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwTraceFlags = m_dwKernelFlags | mr_stlInfo.dwBufferFlags;

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_FLAGS,
                &dwTraceFlags);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            LPTSTR pszStringBuffer = NULL;

            pszStringBuffer = mr_szInQueryProviderList;

            dwBufferSize = m_dwInQueryProviderListLength * sizeof (TCHAR);

            if ( NULL != pszStringBuffer ) {
                dwStatus  = WriteRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_TRACE_PROVIDER_LIST,
                    REG_MULTI_SZ,
                    pszStringBuffer,
                    &dwBufferSize);
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = CSmLogQuery::UpdateRegistry ();
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  InitGenProvidersArray()
//      reads the current values for this query from the registry
//      and WMI configuration and reloads the internal values to match
//
DWORD
CSmTraceLogQuery::InitGenProvidersArray( void )
{
    DWORD dwStatus = ERROR_SUCCESS;
    CSmTraceProviders* pProvList = NULL;
    int iIndex;
    int iCount;
    LPCTSTR pstrGuid;

    ASSERT ( m_pLogService->CastToTraceLogService() );
    pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();

    ASSERT ( NULL != pProvList );

    iCount = pProvList->GetGenProvCount();

    m_arrGenProviders.SetSize ( iCount );

    for ( iIndex = 0; iIndex < iCount; iIndex++ ) {
        m_arrGenProviders[iIndex] = eNotInQuery;
    }

    for ( pstrGuid = GetFirstInQueryProvider ( );
            NULL != pstrGuid;
            pstrGuid = GetNextInQueryProvider ( ) ) {

        iIndex = pProvList->IndexFromGuid ( pstrGuid );
        if ( -1 == iIndex ) {
            CString strEmptyDesc;
            CString strNonConstGuid;
            eProviderState eAddInQuery = eInQuery;

            MFC_TRY
                strNonConstGuid = pstrGuid;
            MFC_CATCH_DWSTATUS

            // Todo: handle string alloc error

            // The Guid is probably from another system.
            // Add the unknown Guid to the session-wide provider list.

            dwStatus = pProvList->AddProvider (
                                    strEmptyDesc,
                                    strNonConstGuid,
                                    FALSE,
                                    FALSE );

            // Update the local array to match the session-wide list.
            m_arrGenProviders.SetAtGrow( iCount, eAddInQuery );
            iIndex = iCount;

            VERIFY( ++iCount == pProvList->GetGenProvCount() );
        } else {

            ASSERT ( iIndex < iCount );
            m_arrGenProviders[iIndex] = eInQuery;
        }

        if ( !IsActiveProvider ( iIndex ) ) {
            dwStatus = SMCFG_INACTIVE_PROVIDER;
        }
    }

    // dwStatus is not ERROR_SUCCESS if at least one provider is not currently active on the system.
    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and WMI and reloads the internal values to match
//
DWORD
CSmTraceLogQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwTraceFlags;
    DWORD   dwKernelTraceFlagMask;

    ASSERT (m_hKeyQuery != NULL);

    // load Provider string list

    // Get Provider List
    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_TRACE_PROVIDER_LIST,
        NULL,
        &mr_szInQueryProviderList,
        &dwBufferSize);
    if (dwStatus != ERROR_SUCCESS) {
        m_szNextInQueryProvider = NULL; //re-initialize
        m_dwInQueryProviderListLength = 0;
    } else {
        // convert  buffersize to chars from bytes
        m_dwInQueryProviderListLength = dwBufferSize / sizeof(TCHAR);
    }

    // get trace log values
    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_SIZE,
        TRACE_DEFAULT_BUFFER_SIZE,
        &mr_stlInfo.dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);

    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_MIN_COUNT,
        TRACE_DEFAULT_MIN_COUNT,
        &mr_stlInfo.dwMinimumBuffers);
    ASSERT (dwStatus == ERROR_SUCCESS);

    // Windows XP the minimum buffer count has changed from 2 to 3.
    if ( TRACE_DEFAULT_MIN_COUNT > mr_stlInfo.dwMinimumBuffers ) {
       mr_stlInfo.dwMinimumBuffers = TRACE_DEFAULT_MIN_COUNT;
    }

    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_MAX_COUNT,
        TRACE_DEFAULT_MAX_COUNT,
        &mr_stlInfo.dwMaximumBuffers);
    ASSERT (dwStatus == ERROR_SUCCESS);

    // Windows XP the minimum buffer count has changed from 2 to 3.
    if ( TRACE_DEFAULT_MIN_COUNT > mr_stlInfo.dwMaximumBuffers ) {
       mr_stlInfo.dwMaximumBuffers = TRACE_DEFAULT_MIN_COUNT;
    }

    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_FLUSH_INT,
        TRACE_DEFAULT_BUFFER_FLUSH_INT,
        &mr_stlInfo.dwBufferFlushInterval);
    ASSERT (dwStatus == ERROR_SUCCESS);

    dwTraceFlags = TRACE_DEFAULT_FLAGS; // Eliminate Prefix warning.
    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_FLAGS,
        TRACE_DEFAULT_FLAGS,
        &dwTraceFlags);
    ASSERT (dwStatus == ERROR_SUCCESS);

    if ( 0 != (dwTraceFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH) ) {
        mr_stlInfo.dwBufferFlags = SLQ_TLI_ENABLE_BUFFER_FLUSH;
    }

    dwKernelTraceFlagMask = SLQ_TLI_ENABLE_KERNEL_TRACE
                            | SLQ_TLI_ENABLE_PROCESS_TRACE
                            | SLQ_TLI_ENABLE_THREAD_TRACE
                            | SLQ_TLI_ENABLE_DISKIO_TRACE
                            | SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE
                            | SLQ_TLI_ENABLE_MEMMAN_TRACE
                            | SLQ_TLI_ENABLE_FILEIO_TRACE;

    m_dwKernelFlags = dwKernelTraceFlagMask & dwTraceFlags;

    // Call parent class last, to set shared data.
    dwStatus = CSmLogQuery::SyncWithRegistry();

    return dwStatus;
}

//
//  Get first Provider in list of providers in use
//
LPCTSTR
CSmTraceLogQuery::GetFirstInQueryProvider()
{
    LPTSTR  szReturn;
    szReturn = mr_szInQueryProviderList;
    if (szReturn != NULL) {
        if (*szReturn == 0) {
            // then it's an empty string
            szReturn = NULL;
            m_szNextInQueryProvider = NULL;
        } else {
            m_szNextInQueryProvider = szReturn + lstrlen(szReturn) + 1;
            if (*m_szNextInQueryProvider == 0) {
                // end of list reached so set pointer to NULL
                m_szNextInQueryProvider = NULL;
            }
        }
    } else {
        // no buffer allocated yet
        m_szNextInQueryProvider = NULL;
    }
    return (LPCTSTR)szReturn;
}

//
//  Get next Provider in list of providers in use.
//  NULL pointer means no more Providers in list.
//
LPCTSTR
CSmTraceLogQuery::GetNextInQueryProvider()
{
    LPTSTR  szReturn;
    szReturn = m_szNextInQueryProvider;

    if (m_szNextInQueryProvider != NULL) {
        m_szNextInQueryProvider += lstrlen(szReturn) + 1;
        if (*m_szNextInQueryProvider == 0) {
            // end of list reached so set pointer to NULL
            m_szNextInQueryProvider = NULL;
        }
    } else {
        // already at the end of the list so nothing to do
    }

    return (LPCTSTR)szReturn;
}

//
//  clear out the Provider list
//
VOID
CSmTraceLogQuery::ResetInQueryProviderList()
{
    if (mr_szInQueryProviderList != NULL) {
        delete (mr_szInQueryProviderList);
        m_szNextInQueryProvider = NULL;
        mr_szInQueryProviderList = NULL;
    }

    m_dwInQueryProviderListLength = sizeof(TCHAR);  // sizeof MSZ Null
    try {
        mr_szInQueryProviderList = new TCHAR [m_dwInQueryProviderListLength];
        mr_szInQueryProviderList[0] = 0;
    } catch ( ... ) {
        m_dwInQueryProviderListLength = 0;
    }
}

//
//  Sync the stored provider list with WMI database.
//
HRESULT
CSmTraceLogQuery::SyncGenProviders( void )
{
    HRESULT hr;
    CSmTraceProviders* pProvList;

    ASSERT ( m_pLogService->CastToTraceLogService() );
    pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();

    hr = pProvList->SyncWithConfiguration();

    return hr;
}



//
//  Update the provided InQuery array to match the stored version.
//
DWORD
CSmTraceLogQuery::GetInQueryProviders( CArray<eProviderState, eProviderState&>& rarrOut )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iIndex;

    rarrOut.RemoveAll();

    rarrOut.SetSize( m_arrGenProviders.GetSize() );

    for ( iIndex = 0; iIndex < (INT)rarrOut.GetSize(); iIndex++ ) {
        rarrOut[iIndex] = m_arrGenProviders[iIndex];
    }

    return dwStatus;
}

//
//  Return the description for the trace provider specified by
//  InQuery array index.
//
LPCTSTR
CSmTraceLogQuery::GetProviderDescription( INT iProvIndex )
{
    LPCTSTR pReturn = NULL;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iProvIndex );
            pReturn = pslqProvider->strDescription;
        }
    }

    return pReturn;
}

LPCTSTR
CSmTraceLogQuery::GetProviderGuid( INT iProvIndex )
{
    LPCTSTR pReturn = NULL;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iProvIndex );
            pReturn = pslqProvider->strGuid;
        }
    }

    return pReturn;
}

BOOL
CSmTraceLogQuery::IsEnabledProvider( INT iIndex )
{
    BOOL bReturn = FALSE;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iIndex );
            bReturn = ( 1 == pslqProvider->iIsEnabled );
        }
    }

    return bReturn;
}

BOOL
CSmTraceLogQuery::IsActiveProvider( INT iIndex )
{
    BOOL bReturn = FALSE;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iIndex );
            bReturn = ( 1 == pslqProvider->iIsActive );
        }
    }

    return bReturn;
}

LPCTSTR
CSmTraceLogQuery::GetKernelProviderDescription( void )
{
    LPCTSTR pReturn = NULL;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetKernelProviderInfo( );
            pReturn = pslqProvider->strDescription;
        }
    }

    return pReturn;
}

BOOL
CSmTraceLogQuery::GetKernelProviderEnabled( void )
{
    BOOL bReturn = FALSE;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetKernelProviderInfo();
            bReturn = ( 1 == pslqProvider->iIsEnabled );
        }
    }

    return bReturn;
}

DWORD
CSmTraceLogQuery::GetGenProviderCount( INT& iCount )
{
    DWORD dwStatus = ERROR_SUCCESS;
    ASSERT ( NULL != m_pLogService );

    iCount = 0;

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            iCount = pProvList->GetGenProvCount();
        }
    }

    return dwStatus;
}
//
//  Update the stored InQuery providers list and array
//  to match the provided version.
//
DWORD
CSmTraceLogQuery::SetInQueryProviders( CArray<eProviderState, eProviderState&>& rarrIn )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iProvIndex;
    CSmTraceProviders* pProvList;

    m_arrGenProviders.RemoveAll();

    m_arrGenProviders.SetSize( rarrIn.GetSize() );

    for ( iProvIndex = 0; iProvIndex < (INT)m_arrGenProviders.GetSize(); iProvIndex++ ) {
        m_arrGenProviders[iProvIndex] = rarrIn[iProvIndex];
    }

    ResetInQueryProviderList();

    ASSERT ( NULL != m_pLogService );

    ASSERT ( m_pLogService->CastToTraceLogService() );
    pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
    ASSERT ( NULL != pProvList );

    for ( iProvIndex = 0; iProvIndex < (INT)m_arrGenProviders.GetSize(); iProvIndex++ ) {
        if ( eInQuery == m_arrGenProviders[iProvIndex] ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iProvIndex );

            AddInQueryProvider ( pslqProvider->strGuid );

        }
    }
    return dwStatus;
}

//
//  Add this Provider string to the internal list
//
BOOL
CSmTraceLogQuery::AddInQueryProvider(LPCTSTR szProviderPath)
{
    DWORD   dwNewSize;
    LPTSTR  szNewString;
    LPTSTR  szNextString;

    ASSERT (szProviderPath != NULL);

    if (szProviderPath == NULL) return FALSE;

    dwNewSize = lstrlen(szProviderPath) + 1;

    if (m_dwInQueryProviderListLength <= 2) {
        dwNewSize += 1; // add room for the MSZ null
        // then this is the first string to go in the list
        try {
            szNewString = new TCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        szNextString = szNewString;
    } else {
        dwNewSize += m_dwInQueryProviderListLength;
        // this is the nth string to go in the list
        try {
            szNewString = new TCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        memcpy (szNewString, mr_szInQueryProviderList,
            (m_dwInQueryProviderListLength * sizeof(TCHAR)));
        szNextString = szNewString;
        szNextString += m_dwInQueryProviderListLength - 1;
    }
    lstrcpyW (szNextString, szProviderPath);
    szNextString = szNewString;
    szNextString += dwNewSize - 1;
    *szNextString = 0;  // MSZ Null

    if (mr_szInQueryProviderList != NULL) delete (mr_szInQueryProviderList);
    mr_szInQueryProviderList = szNewString;
    m_szNextInQueryProvider = szNewString;
    m_dwInQueryProviderListLength = dwNewSize;

    return TRUE;
}

//
//  Get index of first inactive provider in list of providers for this query.
//  -1 indicates no inactive providers in the list.
INT
CSmTraceLogQuery::GetFirstInactiveIndex( void )
{
    INT     iIndex;
    INT     iCount;

    iCount = (INT)m_arrGenProviders.GetSize();

    if ( 0 < iCount ) {
        m_iNextInactiveIndex = 0;

        iIndex = GetNextInactiveIndex();

    } else {
        m_iNextInactiveIndex = -1;
        iIndex = -1;
    }

    // szReturn is -1 if no inactive providers.
    return iIndex;
}

//
//  Get next inactive provider in list of providers for this query.
//  -1 indicates no more inactive providers in the list.
//
INT
CSmTraceLogQuery::GetNextInactiveIndex()
{
    INT     iIndex;

    iIndex = m_iNextInactiveIndex;

    if ( -1 != iIndex ) {
        INT     iCount;

        iCount = (INT)m_arrGenProviders.GetSize();

        for ( ; iIndex < iCount; iIndex++ ) {
            if ( !IsActiveProvider ( iIndex ) ) {
                break;
            }
        }

        if ( iIndex >= iCount ) {
            iIndex = -1;
            m_iNextInactiveIndex = -1;
        } else {
            m_iNextInactiveIndex = iIndex + 1;
            ( m_iNextInactiveIndex < iCount ) ? TRUE : m_iNextInactiveIndex = -1;
        }
    } // else already at the end of the list so nothing to do

    return iIndex;
}

//
//  Return TRUE if at least one active provider exists on the system.
//
BOOL
CSmTraceLogQuery::ActiveProviderExists()
{
    BOOL    bActiveExists = FALSE;
    INT     iCount;
    INT     iIndex;

    iCount = (INT)m_arrGenProviders.GetSize();

    for ( iIndex = 0; iIndex < iCount; iIndex++ ) {
        if ( IsActiveProvider ( iIndex ) ) {
            bActiveExists = TRUE;
            break;
        }
    }

    return bActiveExists;
}

BOOL
CSmTraceLogQuery::GetTraceLogInfo (PSLQ_TRACE_LOG_INFO pptlInfo)
{
    if (pptlInfo != NULL) {
        *pptlInfo = mr_stlInfo;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CSmTraceLogQuery::SetTraceLogInfo (PSLQ_TRACE_LOG_INFO pptlInfo )
{

    if (pptlInfo != NULL) {
        mr_stlInfo = *pptlInfo;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CSmTraceLogQuery::GetKernelFlags ( DWORD& rdwFlags )
{
    rdwFlags = m_dwKernelFlags;
    return TRUE;
}

BOOL
CSmTraceLogQuery::SetKernelFlags ( DWORD dwFlags )
{
    m_dwKernelFlags = dwFlags;
    return TRUE;
}

BOOL
CSmTraceLogQuery::GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags ));

    bStatus = CSmLogQuery::GetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmTraceLogQuery::SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags ));

    bStatus = CSmLogQuery::SetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmTraceLogQuery::GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags)
{
    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags ) );

    rTimeInfo.wTimeType = (WORD)dwFlags;
    rTimeInfo.wDataType = SLQ_TT_DTYPE_DATETIME;

    if ( SLQ_TT_TTYPE_START == dwFlags ) {
        SYSTEMTIME  stLocalTime;
        FILETIME    ftLocalTime;

        // Milliseconds set to 0 for Schedule times
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_AT;
        rTimeInfo.llDateTime = *(LONGLONG *)&ftLocalTime;
    } else {
        // Default stop values
        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_NONE;
        rTimeInfo.llDateTime = MAX_TIME_VALUE;
    }

    return TRUE;
}

DWORD
CSmTraceLogQuery::GetLogType()
{
    return ( SLQ_TRACE_LOG );
}


HRESULT
CSmTraceLogQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    CString     strParamName;
    DWORD       dwCount = 0;
    DWORD       dwIndex;
    DWORD       dwTraceFlags;
    DWORD       dwKernelTraceFlagMask;

    // Continue even if error, using defaults for missing values.

    // Load trace providers
    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_PROVIDER_COUNT,
            0,
            dwCount);

    for ( dwIndex = 1; dwIndex <= dwCount; dwIndex++ ) {
        LPTSTR  szProviderGuid = NULL;
        DWORD   dwBufSize = 0;

        strParamName.Format ( IDS_HTML_TRACE_PROVIDER_GUID, dwIndex );
        hr = StringFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strParamName,
                L"",
                &szProviderGuid,
                &dwBufSize );

        if (dwBufSize > sizeof(TCHAR)) {
            AddInQueryProvider ( szProviderGuid );
        }
        delete (szProviderGuid);
    }

    // Load trace buffer properties
    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_SIZE,
            TRACE_DEFAULT_BUFFER_SIZE,
            mr_stlInfo.dwBufferSize);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_MIN_COUNT,
            TRACE_DEFAULT_MIN_COUNT,
            mr_stlInfo.dwMinimumBuffers);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_MAX_COUNT,
            TRACE_DEFAULT_MAX_COUNT,
            mr_stlInfo.dwMaximumBuffers);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_FLUSH_INT,
            TRACE_DEFAULT_BUFFER_FLUSH_INT,
            mr_stlInfo.dwBufferFlushInterval);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_FLAGS,
            TRACE_DEFAULT_FLAGS,
            dwTraceFlags);

    if ( 0 != (dwTraceFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH) ) {
        mr_stlInfo.dwBufferFlags = SLQ_TLI_ENABLE_BUFFER_FLUSH;
    }

    dwKernelTraceFlagMask = SLQ_TLI_ENABLE_KERNEL_TRACE
                            | SLQ_TLI_ENABLE_PROCESS_TRACE
                            | SLQ_TLI_ENABLE_THREAD_TRACE
                            | SLQ_TLI_ENABLE_DISKIO_TRACE
                            | SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE
                            | SLQ_TLI_ENABLE_MEMMAN_TRACE
                            | SLQ_TLI_ENABLE_FILEIO_TRACE;

    m_dwKernelFlags = dwKernelTraceFlagMask & dwTraceFlags;

    hr = CSmLogQuery::LoadFromPropertyBag( pPropBag, pIErrorLog );

    // The GenProviders array is synched with the registry when a properties dialog is opened.
    // If no dialog is opened, there is no reason to synchronize it.

    return hr;
}

HRESULT
CSmTraceLogQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL fSaveAllProps )
{
    HRESULT hr = NOERROR;
    CString strParamName;
    LPCTSTR pszProviderGuid;
    DWORD   dwTraceFlags;
    DWORD   dwIndex = 0;

    // Save provider Guids
    pszProviderGuid = GetFirstInQueryProvider();

    MFC_TRY
        // Passing sz ( TCHAR[n] ) causes memory alloc, which might throw an exception
        while ( NULL != pszProviderGuid ) {
            // Provider count starts at 1.
            strParamName.Format ( IDS_HTML_TRACE_PROVIDER_GUID, ++dwIndex );
            hr = StringToPropertyBag ( pPropBag, strParamName, pszProviderGuid );
            pszProviderGuid = GetNextInQueryProvider();
        }
        hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_PROVIDER_COUNT, dwIndex );
    MFC_CATCH_HR
    // Todo: Handle error

    // Save trace buffer properties
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_SIZE, mr_stlInfo.dwBufferSize );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_MIN_COUNT, mr_stlInfo.dwMinimumBuffers );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_MAX_COUNT, mr_stlInfo.dwMaximumBuffers );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_FLUSH_INT, mr_stlInfo.dwBufferFlushInterval );

    dwTraceFlags = m_dwKernelFlags | mr_stlInfo.dwBufferFlags;

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_FLAGS, dwTraceFlags );

    hr = CSmLogQuery::SaveToPropertyBag( pPropBag, fSaveAllProps );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\strnoloc.cpp ===
#include "stdafx.h"
#include "strnoloc.h"

//const WCHAR CGlobalString::m_chBackslash    = L'\\';

LPCWSTR CGlobalString::m_cszDefaultsInstalled = L"Defaults Installed";

LPCWSTR CGlobalString::m_cszConceptsHTMLHelpFileName = L"\\help\\mpconcepts.chm";
LPCWSTR CGlobalString::m_cszSnapinHTMLHelpFileName = L"\\help\\smlogcfg.chm";
LPCWSTR CGlobalString::m_cszHTMLHelpTopic = L"nt_smlogcfg_top.htm";
LPCWSTR CGlobalString::m_cszContextHelpFileName = L"\\help\\sysmon.hlp";

LPCWSTR CGlobalString::m_cszDefaultCtrLogCpuPath = L"\\Processor(_Total)\\% Processor Time";
LPCWSTR CGlobalString::m_cszDefaultCtrLogMemoryPath = L"\\Memory\\Pages/sec";
LPCWSTR CGlobalString::m_cszDefaultCtrLogDiskPath = L"\\PhysicalDisk(_Total)\\Avg. Disk Queue Length";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\strnoloc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Global resource strings which should not be localized

--*/

#include <windows.h>

class CGlobalString {
public:
    CGlobalString() {};
    ~CGlobalString() {};

//    static const    WCHAR   m_chBackslash;

    static          LPCWSTR m_cszDefaultsInstalled;

    static          LPCWSTR m_cszConceptsHTMLHelpFileName;
    static          LPCWSTR m_cszSnapinHTMLHelpFileName;
    static          LPCWSTR m_cszHTMLHelpTopic;
    static          LPCWSTR m_cszContextHelpFileName;

    static          LPCWSTR m_cszDefaultCtrLogCpuPath;
    static          LPCWSTR m_cszDefaultCtrLogMemoryPath;
    static          LPCWSTR m_cszDefaultCtrLogDiskPath;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\stdafx.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


--*/

#if !defined(AFX_STDAFX_H__698CEE8C_5F56_11D1_97BB_00C04FB9DA75__INCLUDED_)
#define AFX_STDAFX_H__698CEE8C_5F56_11D1_97BB_00C04FB9DA75__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h>
#include <afxdlgs.h>
#include <afxcmn.h>

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#if __RPCNDR_H_VERSION__ < 440             // This may be needed when building
#define __RPCNDR_H_VERSION__ 440           // on NT5 (1671) to prevent MIDL errors
#define MIDL_INTERFACE(x) interface
#endif

#include <stdio.h>
#include <commctrl.h>       // Needed for button styles...
#include <mmc.h>
#include "smlogres.h"       // Resources other than dialogs
#include "globals.h"
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__698CEE8C_5F56_11D1_97BB_00C04FB9DA75__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\tracprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    tracprop.cpp

Abstract:

    Implementation of the advanced trace buffer property page.

--*/

#include "stdafx.h"
#include <pdh.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include "smcfgmsg.h"
#include "smlogs.h"
#include "smtraceq.h"
#include "tracprop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
    IDC_TRACE_BUF_FLUSH_CHECK,  IDH_TRACE_BUF_FLUSH_CHECK,
    IDC_TRACE_BUFFER_SIZE_EDIT, IDH_TRACE_BUFFER_SIZE_EDIT,
    IDC_TRACE_BUFFER_SIZE_SPIN, IDH_TRACE_BUFFER_SIZE_EDIT,
    IDC_TRACE_MIN_BUF_EDIT,     IDH_TRACE_MIN_BUF_EDIT,
    IDC_TRACE_MIN_BUF_SPIN,     IDH_TRACE_MIN_BUF_EDIT,
    IDC_TRACE_MAX_BUF_EDIT,     IDH_TRACE_MAX_BUF_EDIT,
    IDC_TRACE_MAX_BUF_SPIN,     IDH_TRACE_MAX_BUF_EDIT,
    IDC_TRACE_FLUSH_INT_EDIT,   IDH_TRACE_FLUSH_INT_EDIT,
    IDC_TRACE_FLUSH_INT_SPIN,   IDH_TRACE_FLUSH_INT_EDIT,
    0,0
};



/////////////////////////////////////////////////////////////////////////////
// CTraceProperty property page

IMPLEMENT_DYNCREATE(CTraceProperty, CSmPropertyPage)

CTraceProperty::CTraceProperty(MMC_COOKIE   lCookie, LONG_PTR hConsole) 
:   CSmPropertyPage ( CTraceProperty::IDD, hConsole )
{
    // save pointers from arg list
    m_pTraceLogQuery = reinterpret_cast <CSmTraceLogQuery *>(lCookie);

//  EnableAutomation();
    //{{AFX_DATA_INIT(CTraceProperty)
    m_dwBufferSize = 0;
    m_dwFlushInterval = 0;
    m_dwMaxBufCount = 0;
    m_dwMinBufCount = 0;
    m_bEnableBufferFlush = FALSE;
    //}}AFX_DATA_INIT
}

CTraceProperty::CTraceProperty() : CSmPropertyPage(CTraceProperty::IDD)
{
    ASSERT (FALSE); // only the constructor w/args should be called

    EnableAutomation();
//  //{{AFX_DATA_INIT(CTraceProperty)
    m_dwBufferSize = 0;
    m_dwFlushInterval = 0;
    m_dwMaxBufCount = 0;
    m_dwMinBufCount = 0;
    m_bEnableBufferFlush = FALSE;
//  //}}AFX_DATA_INIT
}

CTraceProperty::~CTraceProperty()
{
}

void CTraceProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CTraceProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTraceProperty)
    ValidateTextEdit(pDX, IDC_TRACE_BUFFER_SIZE_EDIT, 4, & m_dwBufferSize, eMinBufSize, eMaxBufSize);
    ValidateTextEdit(pDX, IDC_TRACE_FLUSH_INT_EDIT, 3, & m_dwFlushInterval, eMinFlushInt, eMaxFlushInt);
    ValidateTextEdit(pDX, IDC_TRACE_MAX_BUF_EDIT, 3, & m_dwMaxBufCount, eMinBufCount, eMaxBufCount);
    ValidateTextEdit(pDX, IDC_TRACE_MIN_BUF_EDIT, 3, & m_dwMinBufCount, eMinBufCount, eMaxBufCount);
    DDX_Check(pDX, IDC_TRACE_BUF_FLUSH_CHECK, m_bEnableBufferFlush);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTraceProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CTraceProperty)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_TRACE_BUF_FLUSH_CHECK, OnTraceBufFlushCheck)
    ON_EN_CHANGE(IDC_TRACE_BUFFER_SIZE_EDIT, OnChangeTraceBufferSizeEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_BUFFER_SIZE_EDIT, OnKillfocusTraceBufferSizeEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_BUFFER_SIZE_SPIN, OnDeltaposTraceBufferSizeSpin)
    ON_EN_CHANGE(IDC_TRACE_FLUSH_INT_EDIT, OnChangeTraceFlushIntEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_FLUSH_INT_EDIT, OnKillfocusTraceFlushIntEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_FLUSH_INT_SPIN, OnDeltaposTraceFlushIntSpin)
    ON_EN_CHANGE(IDC_TRACE_MAX_BUF_EDIT, OnChangeTraceMaxBufEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_MAX_BUF_EDIT, OnKillfocusTraceMaxBufEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_MAX_BUF_SPIN, OnDeltaposTraceMaxBufSpin)
    ON_EN_CHANGE(IDC_TRACE_MIN_BUF_EDIT, OnChangeTraceMinBufEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_MIN_BUF_EDIT, OnKillfocusTraceMinBufEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_MIN_BUF_SPIN, OnDeltaposTraceMinBufSpin)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CTraceProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CTraceProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ITraceProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EAF-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_ITraceProperty =
{ 0x65154eaf, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CTraceProperty, CSmPropertyPage)
    INTERFACE_PART(CTraceProperty, IID_ITraceProperty, Dispatch)
END_INTERFACE_MAP()

BOOL    
CTraceProperty::SetFlushIntervalMode()
{
    BOOL    bShow;
    bShow = ((CButton *)(GetDlgItem(IDC_TRACE_BUF_FLUSH_CHECK)))->GetCheck();
    GetDlgItem(IDC_TRACE_FLUSH_INT_EDIT)->EnableWindow(bShow);
    GetDlgItem(IDC_TRACE_FLUSH_INT_SPIN)->EnableWindow(bShow);
    GetDlgItem(IDC_TRACE_INTERVAL_SECONDS_CAPTION)->EnableWindow(bShow);

    return TRUE;
}

BOOL
CTraceProperty::IsValidLocalData ()
{
    BOOL bIsValid = TRUE;

    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_BUFFER_SIZE_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwBufferSize,
                                         eMinBufSize,
                                         eMaxBufSize);
    }
    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_FLUSH_INT_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwFlushInterval,
                                         eMinFlushInt,
                                         eMaxFlushInt);
    }
    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_MIN_BUF_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwMinBufCount,
                                         eMinBufCount,
                                         eMaxBufCount);
    }
    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_MAX_BUF_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwMaxBufCount,
                                         eMinBufCount,
                                         eMaxBufCount);
    }

    // Extra data validation
    if (bIsValid && m_dwMaxBufCount < m_dwMinBufCount) {
        CString csMessage;

        csMessage.LoadString ( IDS_TRACE_MAX_BUFF );

        MessageBox ( csMessage, m_pTraceLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        
        GetDlgItem (IDC_TRACE_MAX_BUF_EDIT)->SetFocus();

        bIsValid = FALSE;

    }

    return bIsValid;
}


BOOL
CTraceProperty::SaveDataToModel ( )
{
    SLQ_TRACE_LOG_INFO  stlInfo;
    BOOL bContinue = TRUE;

    ResourceStateManager    rsm;

    // Write the data to the query.
    if ( bContinue ) {   
        memset (&stlInfo, 0, sizeof(stlInfo));
        stlInfo.dwBufferSize = m_dwBufferSize;
        stlInfo.dwMinimumBuffers = m_dwMinBufCount;
        stlInfo.dwMaximumBuffers = m_dwMaxBufCount;
        stlInfo.dwBufferFlushInterval = m_dwFlushInterval;
        if ( m_bEnableBufferFlush )
            stlInfo.dwBufferFlags |= SLQ_TLI_ENABLE_BUFFER_FLUSH;

        m_pTraceLogQuery->SetTraceLogInfo ( &stlInfo );

        // Save property page shared data.
        m_pTraceLogQuery->UpdatePropPageSharedData();

        bContinue = UpdateService ( m_pTraceLogQuery, TRUE );
    }

    if ( bContinue ) {
       SetModifiedPage ( FALSE );
    } 
    return bContinue;
}

/////////////////////////////////////////////////////////////////////////////
// CTraceProperty message handlers

BOOL 
CTraceProperty::OnSetActive()
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();

    if (bReturn) {
        m_pTraceLogQuery->GetPropPageSharedData ( &m_SharedData );
    }
    
    return bReturn;
}

BOOL 
CTraceProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;
        
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        bContinue = IsValidData(m_pTraceLogQuery, VALIDATE_FOCUS );
    }

    // The trace advanced page does not modify shared data, so no reason to update it.

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }
    return bContinue;
}

void 
CTraceProperty::OnCancel() 
{
    m_pTraceLogQuery->SyncPropPageSharedData(); // Clear the memory shared between property pages.
}

BOOL 
CTraceProperty::OnApply() 
{
    BOOL bContinue = TRUE;

    bContinue = UpdateData(TRUE);

    if ( bContinue ) {
        bContinue = IsValidData( m_pTraceLogQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SaveDataToModel();
    }

    if ( bContinue ) {
        bContinue = Apply( m_pTraceLogQuery );
    }

    if ( bContinue )
        bContinue = CPropertyPage::OnApply();

    return bContinue;
}

BOOL CTraceProperty::OnInitDialog() 
{
    SLQ_TRACE_LOG_INFO  tlInfo;
    ResourceStateManager rsm;

    memset(&tlInfo, 0, sizeof(tlInfo));
    m_pTraceLogQuery->GetTraceLogInfo (&tlInfo);

    m_dwBufferSize = tlInfo.dwBufferSize;
    m_dwFlushInterval = tlInfo.dwBufferFlushInterval;
    m_dwMaxBufCount = tlInfo.dwMaximumBuffers;
    m_dwMinBufCount = tlInfo.dwMinimumBuffers;

    m_bEnableBufferFlush = (BOOL)((tlInfo.dwBufferFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH) != 0);

    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    SetFlushIntervalMode();
        
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CTraceProperty::OnTraceBufFlushCheck() 
{
    UpdateData( TRUE);
    SetFlushIntervalMode();
    SetModifiedPage(TRUE);  
}

void CTraceProperty::OnChangeTraceBufferSizeEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwBufferSize;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwBufferSize) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceBufferSizeEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwBufferSize;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwBufferSize) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceBufferSizeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwBufferSize, eMinBufSize, eMaxBufSize);
}

void CTraceProperty::OnChangeTraceFlushIntEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwFlushInterval;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwFlushInterval) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceFlushIntEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwFlushInterval;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwFlushInterval) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceFlushIntSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwFlushInterval, eMinFlushInt, eMaxFlushInt);
}

void CTraceProperty::OnChangeTraceMaxBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMaxBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMaxBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceMaxBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMaxBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMaxBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceMaxBufSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwMaxBufCount, eMinBufCount, eMaxBufCount);
}

void CTraceProperty::OnChangeTraceMinBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMinBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMinBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceMinBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMinBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMinBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceMinBufSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwMinBufCount, eMinBufCount, eMaxBufCount);
}

void CTraceProperty::PostNcDestroy() 
{
//  delete this;      
    
    CPropertyPage::PostNcDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\warndlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    warndlg.cpp

Abstract:

    Implementation of the expensive trace data warning dialog.

--*/

#include "stdafx.h"
#include "smlogcfg.h"
#include "smtraceq.h"
#include "provprop.h"
#include "warndlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
    IDC_CHECK_NO_MORE,  IDH_CHECK_NO_MORE,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CWarnDlg dialog


CWarnDlg::CWarnDlg(CWnd* pParent /*=NULL*/)
:   CDialog(CWarnDlg::IDD, pParent),
    m_pProvidersPage ( NULL )
{
    //{{AFX_DATA_INIT(CWarnDlg)
    m_CheckNoMore = FALSE;
    //}}AFX_DATA_INIT
}


void CWarnDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWarnDlg)
    DDX_Check(pDX, IDC_CHECK_NO_MORE, m_CheckNoMore);
    //}}AFX_DATA_MAP
}

void    
CWarnDlg::SetProvidersPage( CProvidersProperty* pPage ) 
{ 
    // The providers page is not always the parent, so store a separate pointer
    m_pProvidersPage = pPage; 
}

BEGIN_MESSAGE_MAP(CWarnDlg, CDialog)
    //{{AFX_MSG_MAP(CWarnDlg)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWarnDlg message handlers

BOOL 
CWarnDlg::OnInitDialog() 
{
    CSmTraceLogQuery* pQuery;
    CString strTitle;

    ASSERT ( NULL != m_pProvidersPage );
    pQuery = m_pProvidersPage->GetTraceQuery();

    if ( NULL != pQuery ) {
        pQuery->GetLogName ( strTitle );
        SetWindowText ( strTitle );
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
BOOL 
CWarnDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pProvidersPage );

    if ( pHelpInfo->iCtrlId >= IDC_WARN_FIRST_HELP_CTRL_ID ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);
    }

    return TRUE;
}

void 
CWarnDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pProvidersPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\tracprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    tracprop.h

Abstract:

    Class definitions for the advanced trace buffer property page.

--*/

#ifndef _TRACPROP_H_
#define _TRACPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smproppg.h"
#include "smcfghlp.h"

// Dialog controls
#define IDD_TRACE_PROP                      700

#define IDC_TRACE_BUF_SIZE_UNITS_CAPTION    701
#define IDC_TRACE_INTERVAL_SECONDS_CAPTION  702
#define IDC_TRAC_FIRST_HELP_CTRL_ID         703
#define IDC_TRACE_BUF_FLUSH_CHECK           703
#define IDC_TRACE_BUFFER_SIZE_EDIT          704
#define IDC_TRACE_MIN_BUF_EDIT              705
#define IDC_TRACE_MAX_BUF_EDIT              706
#define IDC_TRACE_FLUSH_INT_EDIT            707
#define IDC_TRACE_BUFFER_SIZE_SPIN          708
#define IDC_TRACE_MIN_BUF_SPIN              709
#define IDC_TRACE_MAX_BUF_SPIN              710
#define IDC_TRACE_FLUSH_INT_SPIN            711

class CSmTraceLogQuery;

/////////////////////////////////////////////////////////////////////////////
// CTraceProperty dialog

class CTraceProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CTraceProperty)
        
        // Construction
public:
            CTraceProperty(MMC_COOKIE   Cookie, LONG_PTR hConsole);
            CTraceProperty();
    virtual ~CTraceProperty();
    
    // Dialog Data
    //{{AFX_DATA(CTraceProperty)
    enum { IDD = IDD_TRACE_PROP };
    DWORD   m_dwBufferSize;
    DWORD   m_dwFlushInterval;
    DWORD   m_dwMaxBufCount;
    DWORD   m_dwMinBufCount;
    BOOL    m_bEnableBufferFlush;
    //}}AFX_DATA
    
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CTraceProperty)
public:
protected:
    virtual void OnFinalRelease();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    
    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_TRAC_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData ();
    
    // Generated message map functions
    //{{AFX_MSG(CTraceProperty)
    afx_msg void OnTraceBufFlushCheck();
    afx_msg void OnChangeTraceBufferSizeEdit();
    afx_msg void OnKillfocusTraceBufferSizeEdit();
    afx_msg void OnDeltaposTraceBufferSizeSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeTraceFlushIntEdit();
    afx_msg void OnKillfocusTraceFlushIntEdit();
    afx_msg void OnDeltaposTraceFlushIntSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeTraceMaxBufEdit();
    afx_msg void OnKillfocusTraceMaxBufEdit();
    afx_msg void OnDeltaposTraceMaxBufSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeTraceMinBufEdit();
    afx_msg void OnKillfocusTraceMinBufEdit();
    afx_msg void OnDeltaposTraceMinBufSpin(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        // Generated OLE dispatch map functions
        //{{AFX_DISPATCH(CTraceProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
        //}}AFX_DISPATCH
        DECLARE_DISPATCH_MAP()
        DECLARE_INTERFACE_MAP()
        
private:

    enum eValueRange {
        eMinBufCount = 3,
        eMaxBufCount = 400,
        eMinBufSize = 1,
        eMaxBufSize = 1024,
        eMinFlushInt = 0,
        eMaxFlushInt = 300
    };
    
    // local functions
    BOOL    SetFlushIntervalMode ( void );
    BOOL    SaveDataToModel ( void );
    
private:
    CSmTraceLogQuery    *m_pTraceLogQuery;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //_TRACPROP_H__65154EB0_BDBE_11D1_BF99_00C04F94A83A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogsvc\logthred.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    logthred.c

Abstract:

    Performance Logs and Alerts log/scan thread functions.

--*/

#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif

#ifndef _IMPLEMENT_WMI 
#define _IMPLEMENT_WMI 1
#endif

#ifndef _DEBUG_OUTPUT 
#define _DEBUG_OUTPUT 0
#endif

//
//  Windows Include files
//
#pragma warning ( disable : 4201)

#include <assert.h>
// For Trace *** - these are only necessary because of union query data struct.

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include <float.h>
#include <limits.h>

#if _IMPLEMENT_WMI
#include <wmistr.h>
#include <evntrace.h>
#endif

#include <lmcons.h>
#include <lmmsg.h>  // for net message function

#include <stdio.h>
#include <tchar.h>
#include <pdh.h>
#include <pdhp.h>

#include <pdhmsg.h>
#include "smlogsvc.h"
#include "smlogmsg.h"

#define SECONDS_IN_DAY      ((LONGLONG)(86400))

#define LOG_EVENT_ON_ERROR  ((BOOL)(1))

DWORD
ValidateCommandFilePath ( 
    IN    PLOG_QUERY_DATA pArg )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if ( 0 != lstrlen ( pArg->szCmdFileName ) ) {
    
        HANDLE hOpenFile;
        LONG    lErrorMode;

        lErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

        hOpenFile =  CreateFile (
                        pArg->szCmdFileName,
                        GENERIC_READ,
                        0,              // Not shared
                        NULL,           // Security attributes
                        OPEN_EXISTING,  //
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( ( NULL == hOpenFile ) 
                || INVALID_HANDLE_VALUE == hOpenFile ) {

            LPWSTR  szStringArray[3];
            DWORD dwStatus = GetLastError();

            szStringArray[0] = pArg->szCmdFileName;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = FormatEventLogMessage(dwStatus);

            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_CMD_FILE_INVALID,
                NULL,
                3,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&dwStatus );

            pArg->dwCmdFileFailure = dwStatus;

        } else {
            CloseHandle(hOpenFile);
        }

        SetErrorMode ( lErrorMode );
    }
    return dwStatus;
}


DWORD 
AddCounterToCounterLog (                        
    IN      PLOG_QUERY_DATA pArg, 
    IN      LPWSTR  pszThisPath,
    IN      HANDLE  hQuery,
    IN      BOOL    bLogErrorEvent,
    IN OUT  DWORD*  pdwCounterCount )
{
    LPWSTR              szStringArray[3];
    DWORD               dwStatus = ERROR_SUCCESS;
    HCOUNTER            hThisCounter = NULL;
    PDH_STATUS          pdhStatus;                
    PLOG_COUNTER_INFO   pCtrInfo = NULL;
                
    dwStatus = pdhStatus = PdhAdd009Counter (
                    hQuery,
                    pszThisPath, 
                    (* pdwCounterCount), 
                    &hThisCounter);
    if (dwStatus != ERROR_SUCCESS) {
        dwStatus = pdhStatus = PdhAddCounter (
                        hQuery,
                        pszThisPath, 
                        (* pdwCounterCount), 
                        &hThisCounter);
    }

    if ( !IsErrorSeverity(pdhStatus) ) {
        if ( IsWarningSeverity(pdhStatus) ) {
            // Write event log warning message
            szStringArray[0] = pszThisPath;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = FormatEventLogMessage(pdhStatus);
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_ADD_COUNTER_WARNING,
                NULL,
                3,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&pdhStatus);
        }

        // then add this handle to the list
        
        (*pdwCounterCount)++; 
        
        pCtrInfo = G_ALLOC (sizeof (LOG_COUNTER_INFO));
        if (pCtrInfo != NULL) {
            // insert at front of list since the order isn't
            // important and this is simpler than walking the
            // list each time.
            pCtrInfo->hCounter = hThisCounter;
            pCtrInfo->next = pArg->pFirstCounter;
            pArg->pFirstCounter = pCtrInfo;
            pCtrInfo = NULL;
        } else {
            dwStatus = ERROR_OUTOFMEMORY;
        }
    } else {
        // For LogByObject, the call is retried with expanded counter if
        // the first try fails, so don't log error event the first time.
        if ( bLogErrorEvent ) {
            // unable to add the current counter so write event log message
            szStringArray[0] = pszThisPath;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = FormatEventLogMessage(pdhStatus);

            if ( PDH_ACCESS_DENIED == pdhStatus ) {
                ReportEvent (
                    hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_ACCESS_COUNTER,
                    NULL,
                    2,
                    0,
                    szStringArray,
                    NULL);
            } else {

                ReportEvent (
                    hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_ADD_COUNTER,
                    NULL,
                    3,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);
            }
        }
    }
    return dwStatus;
}
    

BOOL
IsPdhDataCollectSuccess ( PDH_STATUS pdhStatus ) 
{
    BOOL bSuccess = FALSE;

    if ( ERROR_SUCCESS == pdhStatus 
            || PDH_INVALID_DATA == pdhStatus ) {
        bSuccess = TRUE;
    } else if ( 0 < iPdhDataCollectSuccessCount ) {
        INT iIndex;

        for ( iIndex = 0; iIndex < iPdhDataCollectSuccessCount; iIndex++ ) {
            if ( pdhStatus == (PDH_STATUS)arrPdhDataCollectSuccess[iIndex] ) {
                bSuccess = TRUE;
                break;
            }
        }
    }

    return bSuccess;
}

void
ComputeSessionTics(
    IN      PLOG_QUERY_DATA pArg,
    IN OUT  LONGLONG*   pllWaitTics
)
{
    LONGLONG    llLocalTime;
    // Compute total session time based on Stop modes
    // and values.  

    // -1 (NULL_INTERVAL_TICS) signals no session time limit.  This is true for
    // Stop mode SLQ_AUTO_MODE_NONE and SLQ_AUTO_MODE_SIZE.
    //
    // 0 signals that the Stop time is past, so exit immediately.
    //
    // Assume that session is starting, so Start mode isn't relevant.

    if ( NULL != pArg && NULL != pllWaitTics ) {

        *pllWaitTics = NULL_INTERVAL_TICS;

        if ( SLQ_AUTO_MODE_AFTER == pArg->stiCurrentStop.dwAutoMode 
                || SLQ_AUTO_MODE_AT == pArg->stiCurrentStop.dwAutoMode ) {       

            GetLocalFileTime (&llLocalTime);

            if ( SLQ_AUTO_MODE_AT == pArg->stiCurrentStop.dwAutoMode ) {
        
                if ( pArg->stiCurrentStop.llDateTime > llLocalTime ) {

                    *pllWaitTics = pArg->stiCurrentStop.llDateTime - llLocalTime;

                } else {
                    // Session length = 0.  Exit immediately.
                    *pllWaitTics = ((LONGLONG)(0)); 
                }

            } else if ( SLQ_AUTO_MODE_AFTER == pArg->stiCurrentStop.dwAutoMode ) {
            
                TimeInfoToTics( &pArg->stiCurrentStop, pllWaitTics );
            }
        }
    } else {
        assert ( FALSE );
    }

    // Todo:  Report errors
    return;
}

void
ComputeNewFileTics(
    IN      PLOG_QUERY_DATA pArg,
    IN OUT  LONGLONG*   pllWaitTics
)
{

    LONGLONG    llLocalTime;    
    // Compute time until next file creation based on Create New File modes
    // and values.  

    // -1 (NULL_INTERVAL_TICS) signals no time limit.  This is true for
    // mode SLQ_AUTO_MODE_NONE and SLQ_AUTO_MODE_SIZE.
    //
    // 0 signals that the time is past, so exit immediately.
    //
    // Assume that session is starting, so Start mode isn't relevant.

    if ( NULL != pArg && NULL != pllWaitTics ) {

        *pllWaitTics = NULL_INTERVAL_TICS;

        if ( SLQ_AUTO_MODE_AFTER == pArg->stiCreateNewFile.dwAutoMode ) {       

            GetLocalFileTime (&llLocalTime);

            if ( SLQ_AUTO_MODE_AFTER == pArg->stiCreateNewFile.dwAutoMode ) {
                TimeInfoToTics( &pArg->stiCreateNewFile, pllWaitTics );
                assert ( (LONGLONG)(0) != *pllWaitTics );
            } else if ( SLQ_AUTO_MODE_AT == pArg->stiCreateNewFile.dwAutoMode ) {
                assert ( FALSE );
                *pllWaitTics = (LONGLONG)(0);
            }
        }
    } else {
        assert ( FALSE );
    }

    // Todo:  Report errors

    return;
}


void 
ComputeSampleCount(
    IN  PLOG_QUERY_DATA pArg,
    IN  BOOL    bSessionCount,
    OUT LONGLONG*   pllSampleCount
)
{
    // Compute sample count based on Stop or CreateNewFile modes
    // and values.  Account for the first sample in the log.
    //
    // 0 signals no sample limit in the file.  This is true for
    // Stop modes SLQ_AUTO_MODE_NONE and SLQ_AUTO_MODE_SIZE.
    //
    // -1 signals that the Stop time is past.

    // Assume that sampling is starting, so Start mode isn't relevant.

    LONGLONG    llLocalSampleCount = NULL_INTERVAL_TICS;
    
    assert ( NULL != pllSampleCount );
    if ( NULL != pllSampleCount ) {

        *pllSampleCount = (LONGLONG)(-1);
    
        if ( bSessionCount ) {
            ComputeSessionTics ( pArg, &llLocalSampleCount );
        } else {
            ComputeNewFileTics ( pArg, &llLocalSampleCount );
        }

        if ( NULL_INTERVAL_TICS == llLocalSampleCount ) {
            // No session/sample limit
            *pllSampleCount = (LONGLONG)(0);
        } else if ( (LONGLONG)(0) == llLocalSampleCount ){
            // Stop time is past
            *pllSampleCount = INFINITE_TICS;
        } else {
            *pllSampleCount = llLocalSampleCount 
                                / (pArg->dwMillisecondSampleInterval * FILETIME_TICS_PER_MILLISECOND);
            *pllSampleCount += 1;   // add in the "zero-th" sample
        }
    }
    
    return;
}


BOOL
ProcessRepeatOption ( 
    IN OUT PLOG_QUERY_DATA pArg,
    OUT LARGE_INTEGER* pliStartDelayTics )
{
    BOOL            bRepeat = TRUE;

    if ( NULL != pliStartDelayTics ) {
        // If restart not enabled, then exit.
        if ( SLQ_AUTO_MODE_NONE == pArg->stiRepeat.dwAutoMode ) {
            pliStartDelayTics->QuadPart = NULL_INTERVAL_TICS;
            bRepeat = FALSE;
        } else {
            // For SLQ_AUTO_MODE_AFTER, the only value currently supported is 0.
            pliStartDelayTics->QuadPart = (LONGLONG)0;
            // For SLQ_AUTO_MODE_CALENDAR, add n*24 hours to the original start time.
            //    If Stop mode is SLQ_AUTO_MODE_AT, add n*24 hours to stop time.
            if ( SLQ_AUTO_MODE_CALENDAR == pArg->stiRepeat.dwAutoMode ) {
                // Delay of NULL_INTERVAL signals exit immediately.
                // Todo:  This should not occur.  Report Event, assert.
                pliStartDelayTics->QuadPart = ComputeStartWaitTics ( pArg, TRUE );

                if ( NULL_INTERVAL_TICS == pliStartDelayTics->QuadPart ) {
                    bRepeat = FALSE;
                } else {
                    pArg->dwCurrentState = SLQ_QUERY_START_PENDING;
                    WriteRegistryDwordValue (
                        pArg->hKeyQuery, 
                        (LPCWSTR)L"Current State",
                        &pArg->dwCurrentState,
                        REG_DWORD );

                    // Todo:  Warning event on failure.
                } 
            } // else for SLQ_AUTO_MODE_AFTER, repeat immediately
        }
    } else {
        bRepeat = FALSE;
        assert ( FALSE );
    }
    return bRepeat;
}

void
SetPdhOpenOptions ( 
    IN  PLOG_QUERY_DATA   pArg,
    OUT DWORD*  pdwAccess,
    OUT DWORD*  pdwLogFileType )
{

    // get file type
    switch ( pArg->dwLogFileType ) {
        case SLF_TSV_FILE:
            *pdwLogFileType = PDH_LOG_TYPE_TSV;
            break;

        case SLF_BIN_FILE:
        case SLF_BIN_CIRC_FILE:
            *pdwLogFileType = PDH_LOG_TYPE_BINARY;
            break;

        case SLF_SQL_LOG:
            *pdwLogFileType = PDH_LOG_TYPE_SQL;
            break;

        case SLF_CSV_FILE:
        default:
            *pdwLogFileType = PDH_LOG_TYPE_CSV;
            break;
    }

    *pdwAccess = PDH_LOG_WRITE_ACCESS |
                    PDH_LOG_CREATE_ALWAYS;

    if (SLF_BIN_CIRC_FILE == pArg->dwLogFileType)
        *pdwAccess |= PDH_LOG_OPT_CIRCULAR;

    if ( ( PDH_LOG_TYPE_BINARY != *pdwLogFileType ) 
         && (NULL != pArg->szLogFileComment ) )
        *pdwAccess |= PDH_LOG_OPT_USER_STRING;

    // NOTE:  For all types except sequential binary,
    // the append mode is determined by the file type.
    // All Sql logs are APPEND
    // All text logs are OVERWRITE
    if (   (pArg->dwAppendMode)
        && (* pdwLogFileType == PDH_LOG_TYPE_BINARY) ) {
        * pdwAccess |= PDH_LOG_OPT_APPEND;
    }

}


DWORD
StartLogQuery (
    IN  PLOG_QUERY_DATA pArg
)
{
    HKEY            hKeyLogQuery;
    SLQ_TIME_INFO   slqTime;
    DWORD           dwStatus;
    SC_HANDLE       hSC = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ssData;
    WCHAR           szQueryKeyNameBuf[MAX_PATH];
    WCHAR           szLogPath[2*MAX_PATH];
    DWORD           dwCurrentState;
    DWORD           dwValue;
    DWORD           dwDefault;
    SYSTEMTIME      st;
    LONGLONG        llTime;
    LONGLONG        llModifiedTime;


    // open registry key to the desired service

    dwStatus = GetQueryKeyName ( 
                pArg->szPerfLogName,
                szQueryKeyNameBuf,
                MAX_PATH );

    if ( ERROR_SUCCESS == dwStatus && 0 < lstrlen (szQueryKeyNameBuf) ) {

        lstrcpyW (szLogPath, (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries");
        lstrcatW (szLogPath, (LPCWSTR)L"\\");
        lstrcatW (szLogPath, szQueryKeyNameBuf);

        dwStatus = RegOpenKeyEx (
            (HKEY)HKEY_LOCAL_MACHINE,
            szLogPath,
            0L,
            KEY_READ | KEY_WRITE,
            (PHKEY)&hKeyLogQuery);

        if (dwStatus == ERROR_SUCCESS) {
            // if current state is running, then skip the rest
            dwDefault = SLQ_QUERY_STOPPED;
            dwStatus = ReadRegistryDwordValue (
                hKeyLogQuery,
                pArg->szPerfLogName,
                (LPCWSTR)L"Current State",
                &dwDefault,
                &dwCurrentState);

            if (dwCurrentState == SLQ_QUERY_STOPPED) {
                // update the start time to MIN_TIME_VALUE
                GetLocalTime(&st);
                SystemTimeToFileTime (&st, (FILETIME *)&llTime);

                memset (&slqTime, 0, sizeof(slqTime));
                slqTime.wTimeType = SLQ_TT_TTYPE_START;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                slqTime.llDateTime = MIN_TIME_VALUE;

                dwStatus = WriteRegistrySlqTime (
                    hKeyLogQuery,
                    (LPCWSTR)L"Start",
                    &slqTime);

                // If stop time mode set to manual, or StopAt with time before Now,
                // set the mode to Manual, value to MAX_TIME_VALUE
                memset (&slqTime, 0, sizeof(slqTime));
                slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                slqTime.llDateTime = MAX_TIME_VALUE;

                dwStatus = ReadRegistrySlqTime (
                            hKeyLogQuery, 
                            pArg->szPerfLogName,
                            (LPCWSTR)L"Stop",
                            &slqTime,
                            &slqTime);

                if ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode 
                    || ( SLQ_AUTO_MODE_AT == slqTime.dwAutoMode 
                        && llTime >= slqTime.llDateTime ) ) {

                    slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                    slqTime.llDateTime = MAX_TIME_VALUE;
                
                    dwStatus = WriteRegistrySlqTime (
                                    hKeyLogQuery, 
                                    (LPCWSTR)L"Stop",
                                    &slqTime);
                }

                // Set state to start pending.
                if (dwStatus == ERROR_SUCCESS) {
                    dwValue = SLQ_QUERY_START_PENDING;
                    dwStatus = WriteRegistryDwordValue (
                        hKeyLogQuery,
                        (LPCWSTR)L"Current State",
                        &dwValue,
                        REG_DWORD);
                }
            
                // update the modified time to indicate a change has occurred
                memset (&slqTime, 0, sizeof(slqTime));

                // LastModified and LastConfigured values are stored as GMT
                GetSystemTimeAsFileTime ( (LPFILETIME)(&llModifiedTime) );
                
                slqTime.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                slqTime.llDateTime = llModifiedTime;

                dwStatus = WriteRegistrySlqTime (
                    hKeyLogQuery,
                    (LPCWSTR)L"Last Modified",
                    &slqTime);


                if (dwStatus == ERROR_SUCCESS) {
                    hSC = OpenSCManager ( NULL, NULL, SC_MANAGER_ALL_ACCESS);

                    if (hSC != NULL) {
                        // ping the service controller to rescan the entries
                        hService = OpenServiceW (
                                        hSC, 
                                        (LPCWSTR)L"SysmonLog",
                                        SERVICE_USER_DEFINED_CONTROL | SERVICE_START );

                        if (hService != NULL) {
                            ControlService ( 
                                hService, 
                                SERVICE_CONTROL_SYNCHRONIZE, 
                                &ssData);
                            CloseServiceHandle (hService);
                        } else {
                            // unable to open log service
                            dwStatus = GetLastError();
                        }
                        CloseServiceHandle (hSC);
                    } else {                
                        // unable to open service controller
                        dwStatus = GetLastError();
                    }
                } else {
                    // unable to set the time
                }
                RegCloseKey (hKeyLogQuery);

                if ( ( ERROR_SUCCESS != dwStatus )
                        && ( 1 != pArg->dwAlertLogFailureReported ) ) {
                    LPWSTR  szStringArray[2];

                    szStringArray[0] = pArg->szPerfLogName;
                    szStringArray[1] = pArg->szQueryName;

                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_START_ALERT_LOG,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&dwStatus );
                
                    pArg->dwAlertLogFailureReported = 1;
                }
            } else {
                // it's probably already running so don't bother with it
                dwStatus = ERROR_SUCCESS;
            }
        } else { 
            dwStatus = SMLOG_UNABLE_READ_ALERT_LOG;
        
            if ( 1 != pArg->dwAlertLogFailureReported ) {
                LPWSTR  szStringArray[2];

                szStringArray[0] = pArg->szPerfLogName;
                szStringArray[1] = pArg->szQueryName;

                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_READ_ALERT_LOG,
                    NULL,
                    2,
                    0,
                    szStringArray,
                    NULL );
        
                pArg->dwAlertLogFailureReported = 1;
            }
        }
    } else {

        dwStatus = SMLOG_UNABLE_READ_ALERT_LOG;
        
        if ( 1 != pArg->dwAlertLogFailureReported ) {
            LPWSTR  szStringArray[2];

            szStringArray[0] = pArg->szPerfLogName;
            szStringArray[1] = pArg->szQueryName;

            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_ALERT_LOG,
                NULL,
                2,
                0,
                szStringArray,
                NULL );
        
            pArg->dwAlertLogFailureReported = 1;
        }
    }
    return dwStatus;
}

DWORD
DoAlertCommandFile (
    IN  PLOG_QUERY_DATA     pArg,
    IN  PALERT_COUNTER_INFO pAlertCI,
    IN  LPCWSTR             szTimeStamp,
    IN  LPCWSTR             szMeasuredValue,
    IN  LPCWSTR             szOverUnder,
    IN  LPCWSTR             szLimitValue
)
{
    const   INT ciMaxDelimPerArg = 3;
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bStatus = FALSE;
    LPTSTR  szCommandString = NULL;
    INT     iBufLen = 0;
    LPTSTR  szTempBuffer = NULL;
    LONG    lErrorMode;
    DWORD   iStrLen;
    DWORD   dwCmdFlags;
    BOOL    bSingleArg = FALSE;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD   dwCreationFlags = NORMAL_PRIORITY_CLASS;
    LPWSTR  szDelim1;
    LPWSTR  szDelim2;
    BOOL    bFirstArgDone = FALSE;

    if ( NULL != pArg 
            && NULL != pAlertCI ) {

        if ( NULL != pArg->szCmdFileName ) {

            dwStatus = pArg->dwCmdFileFailure;

            if ( ERROR_SUCCESS == dwStatus ) { 

                // See if any of the argument flags are set.
                dwCmdFlags = pArg->dwAlertActionFlags & ALRT_CMD_LINE_MASK;

                if ( 0 != dwCmdFlags ) {
                    // Allocate space for all arguments

                    if ( NULL != pArg->szQueryName ) {
                        iBufLen += lstrlen ( pArg->szQueryName ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szTimeStamp ) {
                        iBufLen += lstrlen ( szTimeStamp ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != pAlertCI->pAlertInfo->szCounterPath) {
                        iBufLen += lstrlen ( pAlertCI->pAlertInfo->szCounterPath ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szMeasuredValue ) {
                        iBufLen += lstrlen ( szMeasuredValue ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szOverUnder ) {
                        iBufLen += lstrlen ( szOverUnder ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szLimitValue ) {
                        iBufLen += lstrlen ( szLimitValue ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != pArg->szUserText ) {
                        iBufLen += lstrlen ( pArg->szUserText ) + ciMaxDelimPerArg;
                    }
                    iBufLen+= 2;    // 1 for possible leading ", 1 for NULL.

                    szCommandString = (LPWSTR)G_ALLOC(iBufLen * sizeof(TCHAR));

                    if ( NULL != szCommandString ) { 

                        szCommandString[0] = _T('\0');

                        // build command line arguments
                        if ((pArg->dwAlertActionFlags  & ALRT_CMD_LINE_SINGLE) != 0) {
                            bSingleArg = TRUE;
                            szDelim1 = (LPWSTR)L",";
                            szDelim2 = (LPWSTR)L"\0";
                        } else {
                            // multiple arguments enclosed by double quotes and 
                            // separated by a space
                            szDelim1 = (LPWSTR)L" \"";
                            szDelim2 = (LPWSTR)L"\"";
                        }

                        if (pArg->dwAlertActionFlags & ALRT_CMD_LINE_A_NAME ) {
                            if ( NULL != pArg->szQueryName ) {
                                if (bFirstArgDone) {
                                    lstrcatW(szCommandString, szDelim1); // add leading delimiter
                                } else {
                                    lstrcatW(szCommandString, (LPCWSTR)L"\""); // add leading quote
                                    bFirstArgDone = TRUE;
                                }
                                lstrcatW(szCommandString, pArg->szQueryName);
                                lstrcatW(szCommandString, szDelim2);
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_D_TIME ) ) 
                        {
                            if ( NULL != szTimeStamp ) {
                                if (bFirstArgDone) {
                                    lstrcatW(szCommandString, szDelim1); // add leading delimiter
                                } else {
                                    lstrcatW(szCommandString, (LPCWSTR)L"\""); // add leading quote
                                    bFirstArgDone = TRUE;
                                }
                                lstrcatW(szCommandString, szTimeStamp);
                                lstrcatW(szCommandString, szDelim2);
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_C_NAME ) ) 
                        {
                            if ( NULL != pAlertCI->pAlertInfo->szCounterPath ) {
                                if (bFirstArgDone) {
                                    lstrcatW(szCommandString, szDelim1); // add leading delimiter
                                } else {
                                    lstrcatW(szCommandString, (LPCWSTR)L"\""); // add leading quote
                                    bFirstArgDone = TRUE;
                                }
                                lstrcatW(szCommandString, pAlertCI->pAlertInfo->szCounterPath);
                                lstrcatW(szCommandString, szDelim2);
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_M_VAL ) ) 
                        {
                            if ( NULL != szMeasuredValue ) {
                                if (bFirstArgDone) {
                                    lstrcatW(szCommandString, szDelim1); // add leading delimiter
                                } else {
                                    lstrcatW(szCommandString, (LPCWSTR)L"\""); // add leading quote
                                    bFirstArgDone = TRUE;
                                }
                                lstrcatW(szCommandString, szMeasuredValue);
                                lstrcatW(szCommandString, szDelim2);
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_L_VAL ) ) 
                        {
                            if ( NULL != szOverUnder && NULL != szLimitValue ) {
                                if (bFirstArgDone) {
                                    lstrcatW(szCommandString, szDelim1); // add leading delimiter
                                } else {
                                    lstrcatW(szCommandString, (LPCWSTR)L"\""); // add leading quote
                                    bFirstArgDone = TRUE;
                                }
                                lstrcatW(szCommandString, szOverUnder);
                                lstrcatW(szCommandString, (LPCWSTR)L" ");
                                lstrcatW(szCommandString, szLimitValue);
                                lstrcatW(szCommandString, szDelim2);
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_U_TEXT ) ) 
                        {
                            if ( NULL != pArg->szUserText ) {
                                if (bFirstArgDone) {
                                    lstrcatW(szCommandString, szDelim1); // add leading delimiter
                                } else {
                                    lstrcatW(szCommandString, (LPCWSTR)L"\""); // add leading quote
                                    bFirstArgDone = TRUE;
                                }
                                lstrcatW(szCommandString, pArg->szUserText);
                                lstrcatW(szCommandString, szDelim2);
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if (bFirstArgDone && bSingleArg) {
                            // add closing quote if there's at least 1 arg in the command line
                            lstrcatW(szCommandString, (LPCWSTR)L"\""); 
                        }
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }

                    if ( ERROR_SUCCESS == dwStatus )
                    {

                        iBufLen = lstrlen( pArg->szCmdFileName ) + 1;  // 1 for NULL
                        if ( NULL != szCommandString ) {
                            iBufLen += lstrlen ( szCommandString ) + 1;  // 1 for space char
                        }
                        szTempBuffer = (LPWSTR)G_ALLOC(iBufLen * sizeof(TCHAR));
                    }

                    if ( NULL != szTempBuffer ) {

                        // build command line arguments
                        lstrcpy (szTempBuffer, pArg->szCmdFileName) ;

                        // see if this is a CMD or a BAT file
                        // if it is then create a process with a console window, otherwise
                        // assume it's an executable file that will create it's own window
                        // or console if necessary
                        //
                        _tcslwr (szTempBuffer);
                        if ((_tcsstr(szTempBuffer, (LPCTSTR)TEXT(".bat")) != NULL) ||
                            (_tcsstr(szTempBuffer, (LPCTSTR)TEXT(".cmd")) != NULL)){
                                dwCreationFlags |= CREATE_NEW_CONSOLE;
                        } else {
                                dwCreationFlags |= DETACHED_PROCESS;
                        }
                        // recopy the image name to the temp buffer since it was modified
                        // (i.e. lowercased) for the previous comparison.

                        lstrcpy (szTempBuffer, pArg->szCmdFileName) ;

                        if ( NULL != szCommandString ) {
                            // now add on the alert text preceded with a space char
                            iStrLen = lstrlen (szTempBuffer) ;
                            szTempBuffer [iStrLen] = TEXT(' ') ;
                            iStrLen++ ;
                            lstrcpy (&szTempBuffer[iStrLen], szCommandString) ;
                        }
                    
                        // initialize Startup Info block
                        memset (&si, 0, sizeof(si));
                        si.cb = sizeof(si);
                        si.dwFlags = STARTF_USESHOWWINDOW ;
                        si.wShowWindow = SW_SHOWNOACTIVATE ;
                        //si.lpDesktop = L"WinSta0\\Default";

                        memset (&pi, 0, sizeof(pi));

                        // supress pop-ups inf the detached process
                        lErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

                        if( pArg->hUserToken != NULL ){
                            bStatus = CreateProcessAsUser (
                                        pArg->hUserToken,
                                        NULL,
                                        szTempBuffer,
                                        NULL, NULL, FALSE,
                                        dwCreationFlags,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi);
                        } else {
                            bStatus = CreateProcess (
                                        NULL,
                                        szTempBuffer,
                                        NULL, NULL, FALSE,
                                        dwCreationFlags,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi);
                        }

                        SetErrorMode(lErrorMode);

                        if (bStatus) {
                            dwStatus = ERROR_SUCCESS;
                            if ( NULL != pi.hThread && INVALID_HANDLE_VALUE != pi.hThread ) {
                                CloseHandle(pi.hThread);
                                pi.hThread = NULL;
                            }
                            if ( NULL != pi.hProcess && INVALID_HANDLE_VALUE != pi.hProcess ) {
                                CloseHandle(pi.hProcess);
                                pi.hProcess = NULL;
                            }
                        } else {
                            dwStatus = GetLastError();
                        }
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                    if (szCommandString != NULL) G_FREE(szCommandString);
                    if (szTempBuffer != NULL) G_FREE(szTempBuffer);
                }
            }

            if ( ERROR_SUCCESS != dwStatus ) { 

                LPWSTR  szStringArray[2];

                szStringArray[0] = szTempBuffer;
                szStringArray[1] = pArg->szQueryName;

                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_ALERT_CMD_FAIL,
                    NULL,
                    2,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&dwStatus );

                pArg->dwCmdFileFailure = dwStatus;
            }
        } else {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}

BOOL
ExamineAlertValues (
    IN    PLOG_QUERY_DATA pArg
)
{
    PALERT_COUNTER_INFO pAlertCI;
    PDH_STATUS          pdhStatus;
    DWORD               dwType;
    PDH_FMT_COUNTERVALUE   pdhCurrentValue;
    BOOL                bDoAlertAction;

    // for each counter in query, compare it's formatted
    // value against the alert value and do the desired operation
    // if the alert condition is exceeded.

    for (pAlertCI = (PALERT_COUNTER_INFO)pArg->pFirstCounter;
         pAlertCI != NULL;
         pAlertCI = pAlertCI->next) {

        bDoAlertAction = FALSE;

        // get formatted counter value
        pdhStatus = PdhGetFormattedCounterValue (
            pAlertCI->hCounter,
            PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
            &dwType,
            &pdhCurrentValue);

        if ((pdhStatus == ERROR_SUCCESS) && 
            ((pdhCurrentValue.CStatus == PDH_CSTATUS_VALID_DATA) || 
             (pdhCurrentValue.CStatus == PDH_CSTATUS_NEW_DATA))) {
            // then the value was good so compare it
            if ((pAlertCI->pAlertInfo->dwFlags & AIBF_OVER) == AIBF_OVER) {
                // test for value > limit
                if (pdhCurrentValue.doubleValue > pAlertCI->pAlertInfo->dLimit) {
                    bDoAlertAction = TRUE;
                }
            } else {
                // test for value < limit
                if (pdhCurrentValue.doubleValue < pAlertCI->pAlertInfo->dLimit) {
                    bDoAlertAction = TRUE;
                }
            }
        }

        if (bDoAlertAction) {
            WCHAR   szValueString[32];
            WCHAR   szLimitString[32];
            WCHAR   szOverUnderString[64];
            WCHAR   szTimeStampFmt[64];
            WCHAR   szTimeStamp[48];
            DWORD   dwFmtStringFlags;
            DWORD   dwBufLen;
            SYSTEMTIME  st;

            // build arguments used by event log and net messsage if either 

            // option is enabled
            dwFmtStringFlags = ALRT_ACTION_LOG_EVENT | ALRT_ACTION_SEND_MSG | ALRT_ACTION_EXEC_CMD;

            if ((pArg->dwAlertActionFlags & dwFmtStringFlags) != 0) {
                INT     nResId;
 
                // report event to event log
                // format message string elements

                _stprintf (szValueString, (LPCWSTR)L"%.*g", DBL_DIG, pdhCurrentValue.doubleValue);
                _stprintf (szLimitString, (LPCWSTR)L"%.*g", DBL_DIG, pAlertCI->pAlertInfo->dLimit);
                nResId = pAlertCI->pAlertInfo->dwFlags & AIBF_OVER ? IDS_OVER : IDS_UNDER;
                LoadString (hModule,
                    nResId,
                    szOverUnderString, 
                    (sizeof(szOverUnderString) / sizeof(szOverUnderString[0])));
                // get timestampformat string
                LoadString (hModule,
                    IDS_ALERT_TIMESTAMP_FMT,
                    szTimeStampFmt, 
                    (sizeof(szTimeStampFmt) / sizeof(szTimeStampFmt[0])));

                // message format string expects the following args:
                //  Timestamp
                //  Counter path string
                //  measured value
                //  over/under
                //  limit value
                GetLocalTime (&st);
                dwBufLen = swprintf (
                            szTimeStamp, 
                            szTimeStampFmt, 
                            st.wYear, st.wMonth, st.wDay,
                            st.wHour, st.wMinute, st.wSecond);
                assert (dwBufLen < (sizeof(szTimeStamp) / sizeof(szTimeStamp[0])));
            }

            // do action(s) as defined in flags
            if ((pArg->dwAlertActionFlags & ALRT_ACTION_LOG_EVENT) == ALRT_ACTION_LOG_EVENT) {
                LPWSTR  szStringArray[4];

                szStringArray[0] = pAlertCI->pAlertInfo->szCounterPath;
                szStringArray[1] = szValueString;
                szStringArray[2] = szOverUnderString;
                szStringArray[3] = szLimitString;

                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SMLOG_ALERT_LIMIT_CROSSED,
                    NULL,
                    4,
                    0,
                    szStringArray,
                    NULL);
            }

            if ((pArg->dwAlertActionFlags & ALRT_ACTION_SEND_MSG) == ALRT_ACTION_SEND_MSG) {
               if (pArg->szNetName != NULL) {
                    DWORD   dwStatus = ERROR_SUCCESS;
                    WCHAR   szMessageFormat[MAX_PATH];
                    WCHAR   szMessageText[MAX_PATH * 2];
                    DWORD   dwBufLen;
                    // get message format string
                    LoadString (hModule,
                        IDS_ALERT_MSG_FMT,
                        szMessageFormat, 
                        (sizeof(szMessageFormat) / sizeof(szMessageFormat[0])));

                    // message format string expects the following args:
                    //  Timestamp
                    //  Counter path string
                    //  measured value
                    //  over/under
                    //  limit value
                    dwBufLen = swprintf (szMessageText, szMessageFormat, 
                           szTimeStamp,
                           pAlertCI->pAlertInfo->szCounterPath,
                           szValueString,
                           szOverUnderString,
                           szLimitString);
                    assert (dwBufLen < (sizeof(szMessageText) / sizeof(szMessageText[0])));
                    dwBufLen += 1;
                    dwBufLen *= sizeof(WCHAR);

                    // send network message to specified computer
                    dwStatus = NetMessageBufferSend(  
                                    NULL,
                                    pArg->szNetName,    
                                    NULL,      
                                    (LPBYTE)szMessageText,           
                                    dwBufLen);
                    if ( ( ERROR_SUCCESS != dwStatus )
                            && ( 1 != pArg->dwNetMsgFailureReported ) ) {
                        LPWSTR  szStringArray[3];

                        // Write event log warning message
                        szStringArray[0] = pArg->szQueryName;
                        szStringArray[1] = pArg->szNetName;
                        szStringArray[2] = FormatEventLogMessage(dwStatus);
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_NET_MESSAGE_WARNING,
                            NULL,
                            3,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&dwStatus);
                        
                        pArg->dwNetMsgFailureReported = 1;
                    }
               } else {
                    // there's something flaky in the configuration
                    // in that the flag is set, but there's no name
                    // in any case, it's not worth worrying about so skip
               }
            }

            if ((pArg->dwAlertActionFlags & ALRT_ACTION_EXEC_CMD) == ALRT_ACTION_EXEC_CMD) {
                DWORD   dwStatus = ERROR_SUCCESS;

                dwStatus = DoAlertCommandFile (
                    pArg,
                    pAlertCI,
                    szTimeStamp,
                    szValueString,
                    szOverUnderString,
                    szLimitString);
            }

            if ((pArg->dwAlertActionFlags & ALRT_ACTION_START_LOG) == ALRT_ACTION_START_LOG) {
                DWORD   dwStatus;
                // start specified perf data log 
                dwStatus = StartLogQuery ( pArg );
                
            }
        }
    }  // end of for each counter in alert loop
    return TRUE;
}

BOOL
AlertProc (
    IN    PLOG_QUERY_DATA pArg
)
{
    DWORD           dwStatus = ERROR_SUCCESS;
    HQUERY          hQuery = NULL;
    LARGE_INTEGER   liStartDelayTics;
    LARGE_INTEGER   liSampleDelayTics;
    LONGLONG        llSampleCollectionTics;
    LONGLONG        llSampleIntervalTics;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    DWORD           dwCounterCount;

    LPTSTR          szThisPath;
    BOOL            bRun = FALSE;
    LPTSTR          szStringArray[4];
    LONGLONG        llSessionSampleCount=(LONGLONG)-1;
    PALERT_COUNTER_INFO   pCtrInfo = NULL;
    PALERT_INFO_BLOCK   pAlertInfo = NULL;
    DWORD           dwBufSize;

    LONGLONG        llStartTime = 0;
    LONGLONG        llFinishTime = 0;

    __try {

#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread created\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif

        liStartDelayTics.QuadPart = ((LONGLONG)(0));
        liSampleDelayTics.QuadPart = ((LONGLONG)(0));
        llSampleCollectionTics = ((LONGLONG)(0));


        // Read registry values.
        if ( ERROR_SUCCESS == LoadQueryConfig ( pArg ) ) {
            bRun = TRUE;
        }
     
        if ( TRUE == bRun ) {
            // Delay of -1 signals exit immediately.
            liStartDelayTics.QuadPart = ComputeStartWaitTics ( pArg, TRUE );

            if ( NULL_INTERVAL_TICS == liStartDelayTics.QuadPart ) {
                bRun = FALSE;
            }
        }

        if ( TRUE == bRun ) {
        
            ValidateCommandFilePath ( pArg );

            // open query and add counters from info file

            if (pArg->dwRealTimeQuery == DATA_SOURCE_WBEM) {
                pdhStatus = PdhOpenQueryH(
                        H_WBEM_DATASOURCE, 0, & hQuery); // from current activity
            } else {
                pdhStatus = PdhOpenQueryH(
                        H_REALTIME_DATASOURCE, 0, & hQuery);
            }

            if (pdhStatus != ERROR_SUCCESS) {
                // unable to open query so write event log message and exit
                szStringArray[0] = pArg->szQueryName;
                szStringArray[1] = FormatEventLogMessage(pdhStatus);
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_OPEN_PDH_QUERY,
                    NULL,
                    2,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);
                bRun = FALSE;
            } 
        }

        // Add each counter and associated alert limits
        if ( TRUE == bRun ) {
            dwCounterCount = 0;
            for (szThisPath = pArg->mszCounterList;
                    *szThisPath != 0;
                    szThisPath += lstrlen(szThisPath) + 1) {
            
                HCOUNTER        hThisCounter;

                // allocate information block
                dwBufSize = (lstrlenW(szThisPath) + 1) * sizeof(WCHAR);
                dwBufSize += sizeof(ALERT_INFO_BLOCK);
                pAlertInfo = (PALERT_INFO_BLOCK)G_ALLOC(dwBufSize);

                if (pAlertInfo == NULL) {
                    dwStatus = SMLOG_UNABLE_ALLOC_ALERT_MEMORY;
                    break;
                } else {                
                    if (MakeInfoFromString (szThisPath, pAlertInfo, &dwBufSize)) {
                        // get alert info from string

                        
                        pdhStatus = PdhAdd009Counter (hQuery,
                                               (LPTSTR)pAlertInfo->szCounterPath, 
                                               dwCounterCount, 
                                               &hThisCounter);

                        if (pdhStatus != ERROR_SUCCESS) {
                            pdhStatus = PdhAddCounter (hQuery,
                                                   (LPTSTR)pAlertInfo->szCounterPath, 
                                                   dwCounterCount, 
                                                   &hThisCounter);
                        }

                        if ( !IsErrorSeverity(pdhStatus) ) {

                            dwCounterCount++;

                            if ( ERROR_SUCCESS != pdhStatus ) {
                                // Write event log warning message
                                szStringArray[0] = szThisPath;
                                szStringArray[1] = pArg->szQueryName;
                                szStringArray[2] = FormatEventLogMessage(pdhStatus);
                                ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_ADD_COUNTER_WARNING,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);
                            }

                            // then add this handle to the list
                            pCtrInfo = G_ALLOC (sizeof (ALERT_COUNTER_INFO));
                    
                            if (pCtrInfo != NULL) {
                                // insert at front of list since the order isn't
                                // important and this is simpler than walking the
                                // list each time.
                                pCtrInfo->hCounter = hThisCounter;
                                pCtrInfo->pAlertInfo = pAlertInfo;
                                pCtrInfo->next = (PALERT_COUNTER_INFO)pArg->pFirstCounter;
                                pArg->pFirstCounter = (PLOG_COUNTER_INFO)pCtrInfo;
                                pAlertInfo = NULL;
                                pCtrInfo = NULL;
                            } else {
                                dwStatus = SMLOG_UNABLE_ALLOC_ALERT_MEMORY;
                                G_FREE (pAlertInfo); // toss unused alert buffer
                                pAlertInfo = NULL;
                                break;
                            }
                        } else {
                            // unable to add the current counter so write event log message
                            szStringArray[0] = pAlertInfo->szCounterPath;
                            szStringArray[1] = pArg->szQueryName;
                            szStringArray[2] = FormatEventLogMessage(pdhStatus);

                            if ( PDH_ACCESS_DENIED == pdhStatus ) {
                                ReportEvent (
                                    hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_UNABLE_ACCESS_COUNTER,
                                    NULL,
                                    2,
                                    0,
                                    szStringArray,
                                    NULL);
                            } else {

                                ReportEvent (
                                    hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_UNABLE_ADD_COUNTER,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);
                            }
                            if ( NULL != pAlertInfo ) {
                                G_FREE (pAlertInfo); // toss unused alert buffer
                                pAlertInfo = NULL;
                            }
                        }
                    } else {
                        // unable to parse alert info so log an error
                        // unable to add the current counter so write event log message
                        szStringArray[0] = szThisPath;
                        szStringArray[1] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_PARSE_ALERT_INFO,
                            NULL,
                            2,
                            0,
                            szStringArray,
                            NULL);

                        if ( NULL != pAlertInfo ) {
                            G_FREE (pAlertInfo); // toss unused alert buffer
                            pAlertInfo = NULL;
                        }
                    }
                }
            }

            if ( ERROR_SUCCESS == dwStatus ) {
            
                if ( 0 < dwCounterCount ) {
                    // to make sure we get to log the data
                    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
                } else {
                    bRun = FALSE;
            
                    // unable to add any counters so write event log message and exit.
                    szStringArray[0] = pArg->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_ADD_ANY_COUNTERS,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);
                }
            } else {

                assert ( ERROR_OUTOFMEMORY == dwStatus );
        
                // Memory allocation error so write event log message and exit.
                szStringArray[0] = pArg->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_ALLOC_ALERT_MEMORY,
                    NULL,
                    1,
                    0,
                    szStringArray,
                    NULL);

                bRun = FALSE;
            }

            while (bRun) {
                HANDLE  arrEventHandle[2];

                arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
                arrEventHandle[1] = pArg->hReconfigEvent;

                if ( 0 < liStartDelayTics.QuadPart ) {

                    // NtWaitForMultipleObjects requires negative Tic value
                    liStartDelayTics.QuadPart = ((LONGLONG)(0)) - liStartDelayTics.QuadPart;

                    // Wait until specified start time, or until exit or reconfigure event.
                    if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                                2, 
                                                &arrEventHandle[0], 
                                                WaitAny,
                                                FALSE, 
                                                &liStartDelayTics )) {
#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received exit or reconfig event\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif
                        bRun = FALSE;
                        break;  // if we're not supposed to be running then bail out
                    }
                }

                pArg->dwCurrentState = SLQ_QUERY_RUNNING;
                dwStatus = WriteRegistryDwordValue (
                            pArg->hKeyQuery, 
                            (LPCWSTR)L"Current State",
                            &pArg->dwCurrentState,
                            REG_DWORD );
                assert (dwStatus == ERROR_SUCCESS);
                    
                szStringArray[0] = pArg->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SMLOG_ALERT_SCANNING,
                    NULL,
                    1,
                    0,
                    szStringArray,
                    NULL);

                // Compute session sample count.
                // 0 samples signals no limit.
                // -1 samples signals exit immediately
                ComputeSampleCount( pArg, TRUE, &llSessionSampleCount );
            
                if ( -1 == llSessionSampleCount ) {
                    goto ProcessAlertRepeat;
                }

                // Start sampling immediately. liSampleDelayTics is initialized to 0.

                // Wait until specified sample time, or until exit or reconfigure event.
                while ( STATUS_TIMEOUT == NtWaitForMultipleObjects ( 
                                            2, 
                                            &arrEventHandle[0], 
                                            WaitAny, 
                                            FALSE, 
                                            &liSampleDelayTics)) {
                    // An event flag will be set when the sampling should exit or reconfigure. if
                    // the wait times out, then that means it's time to collect and
                    // log another sample of data.
                
                    GetLocalFileTime (&llStartTime);

                    // Check for reconfig event.
                    if ( pArg->bLoadNewConfig ) {
                        bRun = FALSE;
                        break;
                    }

                    pdhStatus = PdhCollectQueryData (hQuery);

                    if ( IsPdhDataCollectSuccess ( pdhStatus )
                            || IsWarningSeverity ( pdhStatus ) ) {
                    
                        if (pdhStatus == ERROR_SUCCESS) {
                            // process alert counters here
                            ExamineAlertValues (pArg);
                        }
                        // see if it's time to restart or end the alert scan.
                        // 0 samples signals no sample limit.
                        if ( 0 != llSessionSampleCount ) {
                            if ( !--llSessionSampleCount ) 
                                break;
                        }
                    } else {
                        // unable to collect the query data so log event and exit
                        szStringArray[0] = pArg->szQueryName;
                        szStringArray[1] = FormatEventLogMessage(pdhStatus);

                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_COLLECT_DATA,
                            NULL,
                            2,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&pdhStatus);

                        bRun = FALSE;
                        break;
                    }

                    // compute new timeout value
                    GetLocalFileTime (&llFinishTime);
                    // compute difference in tics
                    llSampleCollectionTics = llFinishTime - llStartTime;

                    llSampleIntervalTics = 
                        (LONGLONG)pArg->dwMillisecondSampleInterval*FILETIME_TICS_PER_MILLISECOND;
                    if ( llSampleCollectionTics < llSampleIntervalTics ) {
                        liSampleDelayTics.QuadPart = llSampleIntervalTics - llSampleCollectionTics;
                    } else {
                        liSampleDelayTics.QuadPart = ((LONGLONG)(0));                       
                    }
                    // NtWaitForMultipleObjects requires negative Tic value
                    liSampleDelayTics.QuadPart = ((LONGLONG)(0)) - liSampleDelayTics.QuadPart;

                } // end while wait keeps timing out
                
                // Use 0 SampleDelayTics value to check for ExitEvent.
                liSampleDelayTics.QuadPart = ((LONGLONG)(0));

                if ( pArg->bLoadNewConfig ) {
                    bRun = FALSE;
                } else if ( STATUS_TIMEOUT != NtWaitForSingleObject (
                                                pArg->hExitEvent, 
                                                FALSE, 
                                                &liSampleDelayTics ) ) {
                    // then the loop was terminated by the Exit event
                    // so clear the "run" flag to exit the loop & thread
                    bRun = FALSE;
#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received exit event\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif
                }

                // If restart not enabled, then exit.
ProcessAlertRepeat:
                if ( bRun ) {
                    bRun = ProcessRepeatOption ( pArg, &liStartDelayTics );
                }

            } // end while (bRun)
            PdhCloseQuery (hQuery);
            hQuery = NULL;        

#if _DEBUG_OUTPUT
            szStringArray[0] = pArg->szQueryName;
            szStringArray[1] = szCurrentLogFile;
            ReportEvent (hEventLog,
                EVENTLOG_INFORMATION_TYPE,
                0,
                SMLOG_QUERY_STOPPED,
                NULL,
                2,
                0,
                szStringArray,
                NULL);
#endif
        }

        SetLastError ( ERROR_SUCCESS );
    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        bRun = FALSE;
        
        if ( NULL != hQuery ) {
            PdhCloseQuery ( hQuery );
            hQuery = NULL;
        }

        SetLastError ( SMLOG_THREAD_FAILED );  
    }
        
    DeallocateQueryBuffers ( pArg );

    while ( NULL != pArg->pFirstCounter ) {
        PALERT_COUNTER_INFO pDelCI = (PALERT_COUNTER_INFO)pArg->pFirstCounter;
        if (pDelCI->pAlertInfo != NULL) G_FREE(pDelCI->pAlertInfo);

        pArg->pFirstCounter = (PLOG_COUNTER_INFO)pDelCI->next;

        G_FREE( pDelCI );
    }

    return bRun;
}

BOOL
CounterLogProc (
    IN    PLOG_QUERY_DATA pArg )
{
#define INSTBUFLEN  4096

    HQUERY          hQuery = NULL;
    HLOG            hLog = NULL;
    LARGE_INTEGER   liStartDelayTics;
    LARGE_INTEGER   liSampleDelayTics;
    LONGLONG        llSampleCollectionTics;
    LONGLONG        llSampleIntervalTics;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    DWORD           dwCounterCount;
    DWORD           dwStatus = ERROR_SUCCESS;
    INT             iCnfSerial;
    DWORD           dwSessionSerial;

    LPTSTR          szThisPath;
    DWORD           dwPdhLogFileType;
    DWORD           dwPdhAccessFlags;
    BOOL            bRun = FALSE;
    LONGLONG        llSessionSampleCount=(LONGLONG)-1;
    LONGLONG        llCnfSampleCount=(LONGLONG)-1;
    LONGLONG        llLoopSampleCount=(LONGLONG)-1;
    TCHAR           szCurrentLogFile[MAX_PATH+1];
    LPTSTR          szStringArray[4];
    DWORD           dwFileSizeLimit;
    ULONGLONG       ullFileSizeLimit;
    LONGLONG        llFileSize;

    LONGLONG        llStartTime = 0;
    LONGLONG        llFinishTime = 0;
    HANDLE          arrEventHandle[2];
    PLOG_COUNTER_INFO pDelCI;

    // Wildcard processing
    ULONG   ulBufLen;
    INT     nCounterBufRetry;
    LPWSTR  pszCounterBuf = NULL;
    LPTSTR  pszCounter;
    DWORD   dwPdhExpandFlags;
    TCHAR   achInfoBuf[sizeof(PDH_COUNTER_PATH_ELEMENTS) + MAX_PATH + 5];
    ULONG   ulBufSize;
    PPDH_COUNTER_PATH_ELEMENTS pPathInfo = (PPDH_COUNTER_PATH_ELEMENTS)achInfoBuf;

    __try {

#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread created\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif

        liStartDelayTics.QuadPart = ((LONGLONG)(0));
        liSampleDelayTics.QuadPart = ((LONGLONG)(0));
        llSampleCollectionTics = ((LONGLONG)(0));

        // Read registry values.
        if ( ERROR_SUCCESS == LoadQueryConfig ( pArg ) ) {
            bRun = TRUE;
        }
    
        if ( TRUE == bRun ) {
            // Delay of -1 signals exit immediately.
            liStartDelayTics.QuadPart = ComputeStartWaitTics ( pArg, TRUE );

            if ( NULL_INTERVAL_TICS == liStartDelayTics.QuadPart ) {
                bRun = FALSE;
            }
        }

        if ( TRUE == bRun ) {
       
            ValidateCommandFilePath ( pArg );

            // open query and add counters from info file

            if (pArg->dwRealTimeQuery == DATA_SOURCE_WBEM) {
                pdhStatus = PdhOpenQueryH(
                        H_WBEM_DATASOURCE, 0, & hQuery); // from current activity
            }
            else {
                pdhStatus = PdhOpenQueryH(
                        H_REALTIME_DATASOURCE, 0, & hQuery);
            }

            if (pdhStatus != ERROR_SUCCESS) {
                // unable to open query so write event log message and exit
                szStringArray[0] = pArg->szQueryName;
                szStringArray[1] = FormatEventLogMessage(pdhStatus);
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_OPEN_PDH_QUERY,
                    NULL,
                    2,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);
                bRun = FALSE;
            }
        }
        // Add each counter to the open query.
        if ( TRUE == bRun ) {
    
            dwStatus = ERROR_SUCCESS;
            dwCounterCount = 0;
            for (szThisPath = pArg->mszCounterList;
                *szThisPath != 0;
                szThisPath += lstrlen(szThisPath) + 1) {

                if (_tcschr(szThisPath, TEXT('*')) == NULL) {
                    // No wildcards
                    dwStatus = AddCounterToCounterLog( pArg, szThisPath, hQuery, LOG_EVENT_ON_ERROR, &dwCounterCount );
                } else {
            
                    // At least one wildcard

                    dwPdhExpandFlags = 0;
                    pszCounterBuf = NULL;

                    // Only expand wildcard instances for text log files
                    //
                    if (pArg->dwLogFileType == SLF_SQL_LOG) {
                        // No need to expand wildcard instances for SQL log.
                        // SQL log now has the capability to catch dynamic
                        // instances, so we can pass in wildcard-instance
                        // counter names here.
                        //
                        dwPdhExpandFlags |= PDH_NOEXPANDINSTANCES;
                    }
                    else if (   SLF_CSV_FILE != pArg->dwLogFileType
                             && SLF_TSV_FILE != pArg->dwLogFileType) {
                        // This is binary counter logfile case.
                        // No need for expand wildcard instances, also if
                        // default real-time datasource is from registry (not
                        // WMI), we can handle add-by-object.
                        //
                        dwPdhExpandFlags |= PDH_NOEXPANDINSTANCES;

                        if ( DATA_SOURCE_REGISTRY == pArg->dwRealTimeQuery) {
                            // If both instance and counter are wildcards, then log by object
                            // rather than expanding the counter path.
                            // This is only true when the actual data source is the registry.
                            // Parse pathname
                            ZeroMemory ( achInfoBuf, sizeof(achInfoBuf) );
                            ulBufSize = sizeof(achInfoBuf);
                            pdhStatus = PdhParseCounterPath(szThisPath, pPathInfo, &ulBufSize, 0);
                            if (pdhStatus == ERROR_SUCCESS) {
                                if ( 0 == lstrcmpi ( pPathInfo->szCounterName, _T("*") ) ) {
                                    if ( NULL != pPathInfo->szInstanceName ) {
                                        if ( 0 == lstrcmpi ( pPathInfo->szInstanceName, _T("*") ) ) {
                                            // If PdhAddCounter failed,the realtime data source is actually WBEM.
                                            // In this case, expand the counter paths.
                                            dwStatus = AddCounterToCounterLog( pArg, szThisPath, hQuery, !LOG_EVENT_ON_ERROR, &dwCounterCount );
                                            if ( ERROR_SUCCESS == dwStatus ) {
                                                continue;
                                            } else {
                                                // enumerate counter paths below and retry
                                                dwStatus = ERROR_SUCCESS;
                                            }
                                        }
                                    } else {
                                        dwStatus = AddCounterToCounterLog( pArg, szThisPath, hQuery, !LOG_EVENT_ON_ERROR, &dwCounterCount );
                                        // If PdhAddCounter failed,the realtime data source is actually WBEM.
                                        // In this case, expand the counter paths.
                                        if ( ERROR_SUCCESS == dwStatus ) {
                                            continue;
                                        } else {
                                            // enumerate counter paths below and retry
                                            dwStatus = ERROR_SUCCESS;
                                        }
                                    }
                                }
                            } else {
                                // Report event and continue to next counter
                                szStringArray[0] = szThisPath;
                                szStringArray[1] = pArg->szQueryName;
                                szStringArray[2] = FormatEventLogMessage(pdhStatus);
                                ReportEvent (
                                    hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_UNABLE_PARSE_COUNTER,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);
                                continue;
                            }
                        }
                    }

                    // Log by object paths are already processed.  For other paths with at least 
                    // one wildcard, expand the path before adding counters.

                    ulBufLen          = INSTBUFLEN;
                    nCounterBufRetry  = 10;   // the retry counter

                    do {
                        if ( NULL != pszCounterBuf ) {
                            G_FREE(pszCounterBuf);
                            pszCounterBuf = NULL;
                            ulBufLen *= 2;
                        }

                        pszCounterBuf = (WCHAR*) G_ALLOC(ulBufLen * sizeof(TCHAR));
                        if (pszCounterBuf == NULL) {
                            dwStatus = ERROR_OUTOFMEMORY;
                            break;
                        }
            
                        pdhStatus = PdhExpandWildCardPath (
                            NULL,
                            (LPWSTR)szThisPath,
                            (LPWSTR)pszCounterBuf,
                            &ulBufLen,
                            dwPdhExpandFlags);
                        nCounterBufRetry--;
                    } while ((pdhStatus == PDH_MORE_DATA) && (nCounterBufRetry));

                    if (ERROR_SUCCESS == pdhStatus && ERROR_SUCCESS == dwStatus ) {
                        // Add path 
                        for (pszCounter = pszCounterBuf;
                            *pszCounter != 0;
                            pszCounter += lstrlen(pszCounter) + 1) {

                            dwStatus = AddCounterToCounterLog ( pArg, pszCounter, hQuery, LOG_EVENT_ON_ERROR, &dwCounterCount );
                            if ( ERROR_OUTOFMEMORY == dwStatus ) {
                                break;
                            }
                        }
                    }
                    if ( NULL != pszCounterBuf ) {
                        G_FREE(pszCounterBuf);
                        pszCounterBuf = NULL;
                    }
                }
                if ( ERROR_OUTOFMEMORY == dwStatus ) {

                    szStringArray[0] = pArg->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_ALLOC_LOG_MEMORY,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);
                    bRun = FALSE;
                } // Other errors reported within the loop
            }

            if ( bRun ) {

                if ( 0 < dwCounterCount ) {
                    // to make sure we get to log the data
                    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
                } else {
                    bRun = FALSE;
            
                    // unable to add any counters so write event log message and exit.
                    szStringArray[0] = pArg->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_ADD_ANY_COUNTERS,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);

                }
            }

            while (bRun) {

                arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
                arrEventHandle[1] = pArg->hReconfigEvent;

                // Wait until specified start time, or until exit or reconfig event.
                if ( 0 < liStartDelayTics.QuadPart ) {
                    // NtWaitForMultipleObjects requires negative Tic value
                    liStartDelayTics.QuadPart = ((LONGLONG)(0)) - liStartDelayTics.QuadPart;

                    if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                                2, 
                                                &arrEventHandle[0], 
                                                WaitAny,
                                                FALSE, 
                                                &liStartDelayTics)) {
#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received reconfig or exit event\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif
                        bRun = FALSE;
                        break;  // if we're not supposed to be running then bail out
                    }
                }

                // Compute session sample count.
                // 0 samples signals no limit.
                // -1 samples signals exit immediately, because stop time is past.
                ComputeSampleCount( pArg, TRUE, &llSessionSampleCount );

                if ( (LONGLONG)(-1) == llSessionSampleCount ) {
                    goto ProcessCounterRepeat;
                }
            
                // Set session or cnf file size limit.
                if ( SLQ_DISK_MAX_SIZE != pArg->dwMaxFileSize )
                    dwFileSizeLimit = pArg->dwMaxFileSize * pArg->dwLogFileSizeUnit;    
                else
                    dwFileSizeLimit = 0;

                // 0 file size signals no limit.
                // Translate from DWORD to ULONGLONG instead of LONGLONG to preserve 
                // positive value, even if high bit of dword is used.
                ullFileSizeLimit = ((ULONGLONG)(dwFileSizeLimit));

                ComputeSampleCount( pArg, FALSE, &llCnfSampleCount );
                if ( (LONGLONG)(-1) == llCnfSampleCount ) {
                    // Todo cnf:  Internal program error, report error and exit.
                    bRun = FALSE;
                    break;
                }

                if ( SLQ_AUTO_MODE_AFTER == pArg->stiCreateNewFile.dwAutoMode 
                    || SLQ_AUTO_MODE_SIZE == pArg->stiCreateNewFile.dwAutoMode ) {
                    iCnfSerial = 1;
                } else {
                    assert ( SLQ_AUTO_MODE_NONE == pArg->stiCreateNewFile.dwAutoMode );
                    iCnfSerial = 0;
                }

                dwSessionSerial = pArg->dwCurrentSerialNumber;

                BuildCurrentLogFileName (
                    pArg->szQueryName,
                    pArg->szBaseFileName,
                    pArg->szLogFileFolder,
                    pArg->szSqlLogName,
                    szCurrentLogFile,
                    &dwSessionSerial,
                    pArg->dwAutoNameFormat,
                    pArg->dwLogFileType,
                    iCnfSerial++ );

                // update log serial number if modified.
                if (pArg->dwAutoNameFormat == SLF_NAME_NNNNNN) {
                
                    pArg->dwCurrentSerialNumber++;
                    // Todo:  Info event on number wrap - Server Beta 3.
                    if ( MAXIMUM_SERIAL_NUMBER < pArg->dwCurrentSerialNumber ) {
                        pArg->dwCurrentSerialNumber = MINIMUM_SERIAL_NUMBER;
                    }

                    dwStatus = RegSetValueEx (
                        pArg->hKeyQuery,
                        (LPCTSTR)TEXT("Log File Serial Number"),
                        0L,
                        REG_DWORD,
                        (LPBYTE)&pArg->dwCurrentSerialNumber,
                        sizeof(DWORD));

                    assert ( ERROR_SUCCESS == dwStatus );
                }

                SetPdhOpenOptions ( pArg, &dwPdhAccessFlags, &dwPdhLogFileType );

                // Create new file loop
                while ( bRun && (LONGLONG)(-1) != llSessionSampleCount ) {
                    assert ( (LONGLONG)(-1) != llCnfSampleCount );

                    // Compute cnf or session loop interval
                    if ( (LONGLONG)(0) == llCnfSampleCount 
                            || ( (LONGLONG)(0) != llSessionSampleCount
                                    && llCnfSampleCount > llSessionSampleCount ) ) 
                    {
                        // No need to create new file within session
                        llLoopSampleCount = llSessionSampleCount;
                        // Specify exit after first loop if not cnf by size
                        if ( SLQ_AUTO_MODE_SIZE != pArg->stiCreateNewFile.dwAutoMode ) {
                            llSessionSampleCount = (LONGLONG)(-1);
                        }
                    } else {    
                        // Create new file by time before session ends.
                        llLoopSampleCount = llCnfSampleCount;
                        if ( (LONGLONG)(0) != llSessionSampleCount ) {
                            llSessionSampleCount -= llCnfSampleCount;
                            // todo cnf:  The following should be logically impossible,
                            // because session > newfile wait.
                            if ( llSessionSampleCount <= (LONGLONG)(0) ) {
                                llSessionSampleCount = (LONGLONG)(-1);
                            }
                        }
                    }

                    __try {
                        // Open log file using this query
                        // For text files, max size is checked after each data collection
                        pdhStatus = PdhOpenLog (
                            szCurrentLogFile,
                            dwPdhAccessFlags,
                            &dwPdhLogFileType,
                            hQuery,
                            (   SLF_BIN_CIRC_FILE == pArg->dwLogFileType
                             || SLF_BIN_FILE == pArg->dwLogFileType
                             || SLF_SQL_LOG == pArg->dwLogFileType )
                                    ? dwFileSizeLimit
                                    : 0,                                  
                            ( ( PDH_LOG_TYPE_BINARY != dwPdhLogFileType ) ? pArg->szLogFileComment : NULL ),
                            &hLog);
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }

                    if ( ERROR_SUCCESS != pdhStatus ) {                
                        // unable to open log file so log event log message
                        szStringArray[0] = szCurrentLogFile;
                        szStringArray[1] = pArg->szQueryName;
                        szStringArray[2] = FormatEventLogMessage(pdhStatus);
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_OPEN_LOG_FILE,
                            NULL,
                            3,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&pdhStatus);

                        bRun = FALSE; // exit now
                        break;
                    } else {

                        RegisterCurrentFile( pArg->hKeyQuery, szCurrentLogFile, 0 );

                        pArg->dwCurrentState = SLQ_QUERY_RUNNING;
                        dwStatus = WriteRegistryDwordValue (
                                    pArg->hKeyQuery, 
                                    (LPCWSTR)L"Current State",
                                    &pArg->dwCurrentState,
                                    REG_DWORD );
                        assert (dwStatus == ERROR_SUCCESS);
                
                        szStringArray[0] = pArg->szQueryName;
                        szStringArray[1] = szCurrentLogFile;
                        ReportEvent (hEventLog,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            SMLOG_LOGGING_QUERY,
                            NULL,
                            2,
                            0,
                            szStringArray,
                            NULL);
                    } 

                    // Start sampling immediately. liSampleDelayTics is initialized to 0.
                    while ( STATUS_TIMEOUT == NtWaitForMultipleObjects ( 
                                                2, 
                                                &arrEventHandle[0], 
                                                WaitAny,
                                                FALSE, 
                                                &liSampleDelayTics)) {

                        // An event flag will be set when the sampling should exit or reconfigure. if
                        // the wait times out, then that means it's time to collect and
                        // log another sample of data.
            
                        GetLocalFileTime (&llStartTime);

                        // Check for reconfig event.
                        if ( pArg->bLoadNewConfig ) {
                            bRun = FALSE;
                            break;
                        }

                        pdhStatus = PdhUpdateLog (hLog, pArg->szLogFileComment );
                        if ( IsPdhDataCollectSuccess ( pdhStatus ) 
                            || IsWarningSeverity ( pdhStatus ) ) {

                            // see if it's time to restart or end the log.
                            // 0 samples signals no sample limit.
                            if ( ((LONGLONG)0) != llLoopSampleCount ) {
                                if ( !--llLoopSampleCount ) 
                                    break;
                            }

                            if ( ( ((ULONGLONG)0) != ullFileSizeLimit ) 
                                && ( SLF_BIN_CIRC_FILE != pArg->dwLogFileType ) ) {
                                // see if the file is too big
                                pdhStatus = PdhGetLogFileSize (hLog, &llFileSize);
                                if (pdhStatus == ERROR_SUCCESS) {
                                    if (ullFileSizeLimit <= (ULONGLONG)llFileSize) 
                                        break;
                                }
                            }
            
                        
                        } else {
                            // unable to update the log so log event and exit
                            szStringArray[0] = pArg->szQueryName;
                            szStringArray[1] = FormatEventLogMessage(pdhStatus);
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_UPDATE_LOG,
                                NULL,
                                2,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&pdhStatus);

                            bRun = FALSE;
                            break;
                        }

                        // compute new timeout value
                        GetLocalFileTime (&llFinishTime);
                        // compute difference in tics
                        llSampleCollectionTics = llFinishTime - llStartTime;

                        llSampleIntervalTics = 
                            (LONGLONG)pArg->dwMillisecondSampleInterval*FILETIME_TICS_PER_MILLISECOND;

                        if ( llSampleCollectionTics < llSampleIntervalTics ) {
                            liSampleDelayTics.QuadPart = llSampleIntervalTics - llSampleCollectionTics;
                        } else {
                            liSampleDelayTics.QuadPart = ((LONGLONG)(0));                       
                        }
                        // NtWaitForMultipleObjects requires negative Tic value
                        liSampleDelayTics.QuadPart = ((LONGLONG)(0)) - liSampleDelayTics.QuadPart;
                    } // end while wait keeps timing out
                
                    // Use 0 SampleDelayTics value to check for ExitEvent.
                    liSampleDelayTics.QuadPart = ((LONGLONG)(0));

                    if ( pArg->bLoadNewConfig ) {
                        bRun = FALSE;
                    } else if ( STATUS_TIMEOUT != NtWaitForSingleObject (
                                                    pArg->hExitEvent, 
                                                    FALSE, 
                                                    &liSampleDelayTics ) ) {
                        // then the loop was terminated by the Exit event
                        // so clear the "run" flag to exit the loop & thread
                        bRun = FALSE;
#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received exit event\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif
                    }

                    // close log file, but keep query open
                    PdhCloseLog (hLog, 0);
                    hLog = NULL;
                
                    if ( pArg->bLoadNewConfig )
                        break;

                    if ( pArg->szCmdFileName != NULL )
                        DoLogCommandFile (pArg, szCurrentLogFile, bRun);
            
                    if ( (LONGLONG)(-1) != llSessionSampleCount ) {
                        // Create new log name
                        BuildCurrentLogFileName (
                            pArg->szQueryName,
                            pArg->szBaseFileName,
                            pArg->szLogFileFolder,
                            pArg->szSqlLogName,
                            szCurrentLogFile,
                            &dwSessionSerial,
                            pArg->dwAutoNameFormat,
                            pArg->dwLogFileType,
                            iCnfSerial++ );

                        // Todo cnf:  report event on error;
                    }

                } // End of log file creation while loop

                // cnf Todo:  Handle break from sample loop. ?

                // If restart not enabled, then exit.
ProcessCounterRepeat:
                if ( bRun ) {
                    bRun = ProcessRepeatOption ( pArg, &liStartDelayTics );
                }

            } // end while (bRun)

            PdhCloseQuery (hQuery);
            hQuery = NULL;

#if _DEBUG_OUTPUT
            szStringArray[0] = pArg->szQueryName;
            szStringArray[1] = szCurrentLogFile;
            ReportEvent (hEventLog,
                EVENTLOG_INFORMATION_TYPE,
                0,
                SMLOG_QUERY_STOPPED,
                NULL,
                2,
                0,
                szStringArray,
                NULL);
#endif
        }
        SetLastError ( ERROR_SUCCESS );

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        bRun = FALSE;
        
        if ( NULL != pszCounterBuf ) {
            G_FREE(pszCounterBuf);
            pszCounterBuf = NULL;
        }

        if ( NULL != hLog ) {
            PdhCloseLog ( hLog, 0 );
            hLog = NULL;
        }

        if ( NULL != hQuery ) {
            PdhCloseQuery ( hQuery );
            hQuery = NULL;
        }

        SetLastError ( SMLOG_THREAD_FAILED );        
    }

    DeallocateQueryBuffers ( pArg );

    while ( NULL != pArg->pFirstCounter ) {
        pDelCI = pArg->pFirstCounter;
        pArg->pFirstCounter = pDelCI->next;
        G_FREE( pDelCI );
    }

    return bRun;
}

BOOL
TraceLogProc (
    IN    PLOG_QUERY_DATA pArg
)
{
    LARGE_INTEGER   liStartDelayTics;
    LARGE_INTEGER   liWaitTics;
    LONGLONG        llSessionWaitTics = 0;
    LONGLONG        llNewFileWaitTics = INFINITE_TICS;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwIndex;
    BOOL            bRun = FALSE;
    BOOL            bStarted = FALSE;
    LPTSTR          szStringArray[4];
    TCHAR           szCurrentLogFile[MAX_PATH+1];
    INT             iCnfSerial = 0;
    ULONG           ulIndex;
    int             iEnableCount = 0;
    DWORD           dwSessionSerial;
    HANDLE          arrEventHandle[2];

    __try {

#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread created\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif

        liStartDelayTics.QuadPart = NULL_INTERVAL_TICS;
        liWaitTics.QuadPart = ((LONGLONG)(0));

        // Read registry values.
        if ( ERROR_SUCCESS == LoadQueryConfig ( pArg ) ) {
            bRun = TRUE;
        }
     
        if ( TRUE == bRun ) {
            // Delay of -1 signals exit immediately.
            liStartDelayTics.QuadPart = ComputeStartWaitTics ( pArg, TRUE );

            if ( NULL_INTERVAL_TICS == liStartDelayTics.QuadPart ) {
                bRun = FALSE;
            }
        }

        if ( bRun ) {

            ValidateCommandFilePath ( pArg );
            // to make sure we get to log the data
            SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        }

        while (bRun) {

            arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
            arrEventHandle[1] = pArg->hReconfigEvent;

            if ( 0 < liStartDelayTics.QuadPart ) {
                // NtWaitForMultipleObjects requires negative Tic value
                liStartDelayTics.QuadPart = ((LONGLONG)(0)) - liStartDelayTics.QuadPart;
                // Wait until specified start time, or until exit or reconfig event.
                if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                            2, 
                                            &arrEventHandle[0],
                                            WaitAny,
                                            FALSE, 
                                            &liStartDelayTics)) {
#if _DEBUG_OUTPUT
{
TCHAR szDebugString[MAX_PATH];
swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received exit or reconfig event\n", pArg->szQueryName);
OutputDebugString (szDebugString);
}
#endif
                    bRun = FALSE;   // if we're not supposed to be running then bail out
                    break;
                }
            }

            ComputeSessionTics( pArg, &llSessionWaitTics );

            // 0 signals no session time, so exit.
            if ( ((LONGLONG)(0)) == llSessionWaitTics ) {
                goto ProcessTraceRepeat;
            }

            // llNewFileWaitTics defaults to -1 if no time limit.
            ComputeNewFileTics( pArg, &llNewFileWaitTics );

            // InitTraceProperties creates the current file name
            dwSessionSerial = pArg->dwCurrentSerialNumber;

            InitTraceProperties ( pArg, TRUE, &dwSessionSerial, &iCnfSerial );

            dwStatus = GetTraceQueryStatus ( pArg, NULL );

            // If trace session with this name already started and successful,
            // don't create another session.
        
            if ( ERROR_SUCCESS != dwStatus ) {

                dwStatus = StartTrace(
                            &pArg->LoggerHandle, 
                            pArg->szLoggerName, 
                            &pArg->Properties );
                if (dwStatus == ERROR_SUCCESS) {
                    bStarted = TRUE;
                }

                if ( ( ERROR_SUCCESS == dwStatus ) 
                     && !( pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_PROCESS
                            || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_THREAD
                            || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_DISK_IO
                            || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP ) ) {
            
                    for ( ulIndex = 0; ulIndex < pArg->ulGuidCount; ulIndex++ ) {
                        // Enable user mode and special kernel tracing.
                        dwStatus = EnableTrace (
                                    TRUE,
                                    0,
                                    0,
                                    pArg->arrpGuid[ulIndex], 
                                    pArg->LoggerHandle);
                        if ( ERROR_SUCCESS == dwStatus ) {
                            iEnableCount++;
                        } else {
                            szStringArray[0] = pArg->arrpszProviderName[ulIndex];
                            szStringArray[1] = pArg->szQueryName;
                    
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_ENABLE_TRACE_PROV,
                                NULL,
                                2,
                                sizeof(DWORD),
                                szStringArray,      
                                (LPVOID)&dwStatus);
                        }
                    }
            
                    if ( 0 < iEnableCount ) {
                        dwStatus = ERROR_SUCCESS;
                    } else {
                        szStringArray[0] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_TRACE_NO_PROVIDERS,
                            NULL,
                            1,
                            0,
                            szStringArray,      
                            NULL);
                        bRun = FALSE;
                    }
                }
            
                if ( bRun && ERROR_SUCCESS == dwStatus ) {

                    pArg->dwCurrentState = SLQ_QUERY_RUNNING;
                    dwStatus = WriteRegistryDwordValue (
                                pArg->hKeyQuery, 
                                (LPCTSTR)L"Current State",
                                &pArg->dwCurrentState,
                                REG_DWORD );
                    

                    szStringArray[0] = pArg->szQueryName;
                    szStringArray[1] = pArg->szLogFileName;
                    ReportEvent (hEventLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        SMLOG_LOGGING_QUERY,
                        NULL,
                        2,
                        0,
                        szStringArray,
                        NULL);
                } else {
                    //StartTraceFailed 
                    //dwStatus should be ERROR_ALREADY_EXISTS if logger already started or anything else

                    if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                        szStringArray[0] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_TRACE_ALREADY_RUNNING,
                            NULL,
                            1,
                            0,
                            szStringArray,      
                            NULL);
                    } else {
                        szStringArray[0] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_START_TRACE,
                            NULL,
                            1,
                            sizeof(DWORD),
                            szStringArray,      
                            (LPVOID)&dwStatus );
                    }
            
                    bRun = FALSE;
                }
            } else {
                // This means that QueryTrace Returned Error Success.
                // The specified logger is already running. 
                szStringArray[0] = pArg->szQueryName;
            
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_TRACE_ALREADY_RUNNING,
                    NULL,
                    1,
                    0,
                    szStringArray,      
                    NULL);

                bRun = FALSE;
            }

            if ( TRUE == bRun ) {
        
                // Trace logger is now running.

                // Exit when:  
                //  Wait times out,
                //  Exit event signaled, or
                //  Reconfig event signaled.

                // -1 wait time signals no limit.

                // Loop wait intervals, calculating interval before each wait.
                while ( ((LONGLONG)(0)) != llSessionWaitTics ) {

                    // Calculate wait interval.
                    if ( INFINITE_TICS == llNewFileWaitTics 
                            || ( INFINITE_TICS != llSessionWaitTics
                                    && llNewFileWaitTics > llSessionWaitTics ) ) {
                        // No need to create new file within session
                        if ( INFINITE_TICS == llSessionWaitTics ) {
                            liWaitTics.QuadPart = llSessionWaitTics;
                            // Exit after first loop
                            llSessionWaitTics = 0;
                        } else {
                            liWaitTics.QuadPart = llSessionWaitTics;
                            // Exit after first loop
                            llSessionWaitTics = 0;
                        }
                    } else {
                        // Create new file before session ends.
                        liWaitTics.QuadPart = llNewFileWaitTics;

                        if ( INFINITE_TICS != llSessionWaitTics ) {
                            llSessionWaitTics -= llNewFileWaitTics;
                            // todo cnf:  The following should be logically impossible,
                            // because session > newfile wait.
                            if ( 0 > llSessionWaitTics ) {
                                llSessionWaitTics = 0;
                            }
                        }
                    }

                    // NtWaitForMultipleObjects requires negative Tic value
                    if ( INFINITE_TICS != liWaitTics.QuadPart ) {
                        liWaitTics.QuadPart = ((LONGLONG)(0)) - liWaitTics.QuadPart;
                    }
            
                    if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                            2, 
                                            arrEventHandle,
                                            WaitAny,
                                            FALSE, 
                                            ( INFINITE_TICS != liWaitTics.QuadPart ) ? &liWaitTics : NULL )) 
                    {
                        bRun = FALSE;
                        break;
                    } else {
                        // If cnf by time, llNewFileWaitTics will not be infinite
                        if ( INFINITE_TICS != llNewFileWaitTics 
                            && ((LONGLONG)(0)) != llSessionWaitTics ) {
                            // Time to create a new file. Don't update the autoformat
                            // serial number.  Use the initial autoformat serial number
                            InitTraceProperties ( pArg, FALSE, &dwSessionSerial, &iCnfSerial );
                            dwStatus = UpdateTrace(
                                        pArg->LoggerHandle, 
                                        pArg->szLoggerName, 
                                        &pArg->Properties );
                            // Todo cnf report event on bad status.
                        }
                    }
                }
            }
#if _DEBUG_OUTPUT
liWaitTics.QuadPart = ((LONGLONG)(0));
if ( pArg->bLoadNewConfig ) {
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received reconfig event\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
} else if ( STATUS_TIMEOUT != NtWaitForSingleObject (pArg->hExitEvent, FALSE, &liWaitTics )) {
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Thread received exit event\n", pArg->szQueryName);
    OutputDebugString (szDebugString);
}
#endif
            if (bStarted == TRUE) {
                // Stop the query.
                if ( !( pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_PROCESS
                        || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_THREAD
                        || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_DISK_IO
                        || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP ) ) {
                    for (dwIndex = 0; dwIndex < pArg->ulGuidCount; dwIndex++) {
    
                        dwStatus = EnableTrace (
                                    FALSE,
                                    0,
                                    0,
                                    pArg->arrpGuid[dwIndex], 
                                    pArg->LoggerHandle);
                    }
                }

                dwStatus = StopTrace (
                            pArg->LoggerHandle, 
                            pArg->szLoggerName, 
                            &pArg->Properties );
            }

    
            if ( pArg->bLoadNewConfig )
                break;

            if ( pArg->szCmdFileName != NULL )
                DoLogCommandFile (pArg, szCurrentLogFile, bRun);

            // If restart not enabled, then exit.
ProcessTraceRepeat:
            if ( bRun ) {
                bRun = ProcessRepeatOption ( pArg, &liStartDelayTics );
            }

        } // end while (bRun)

#if _DEBUG_OUTPUT
        szStringArray[0] = pArg->szQueryName;
        szStringArray[1] = szCurrentLogFile;
        ReportEvent (hEventLog,
            EVENTLOG_INFORMATION_TYPE,
            0,
            SMLOG_QUERY_STOPPED,
            NULL,
            2,
            0,
            szStringArray,
            NULL);
#endif

        SetLastError ( ERROR_SUCCESS );
    
    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        bRun = FALSE;
        SetLastError ( SMLOG_THREAD_FAILED );
    }

    return bRun;
}


DWORD
LoggingThreadProc (
    IN    LPVOID    lpThreadArg
)
{
    PLOG_QUERY_DATA     pThreadData = (PLOG_QUERY_DATA)lpThreadArg;
    DWORD               dwStatus = ERROR_SUCCESS;
    HRESULT             hr = NOERROR;
    BOOL                bContinue = TRUE;
    LPWSTR              szStringArray[2];

    if (pThreadData != NULL) {

        __try {

            hr = PdhiPlaRunAs( pThreadData->szQueryName, NULL, &pThreadData->hUserToken );

            if( ERROR_SUCCESS != hr ){
                szStringArray[0] = pThreadData->szQueryName;
                ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_INVALID_CREDENTIALS,
                        NULL,
                        1,
                        sizeof(HRESULT),
                        szStringArray,
                        (LPVOID)&hr
                    );

                return hr;
            }

            do {
                // read config from registry
                // expand counter paths as necessary
                if (pThreadData->dwLogType == SLQ_ALERT) {
                    // call Alert procedure
                    bContinue = AlertProc (pThreadData);
                } else if (pThreadData->dwLogType == SLQ_COUNTER_LOG) {
                    // call Logging procedure
                    bContinue = CounterLogProc (pThreadData);
                } else if (pThreadData->dwLogType == SLQ_TRACE_LOG) {
                    // call Logging procedure
                    bContinue = TraceLogProc (pThreadData);
                } else {
                    assert (FALSE); // incorrect log type for this function
                }
                // see if this thread was paused for reloading
                // or stopped to terminate
                if (pThreadData->bLoadNewConfig) {
                    bContinue = TRUE;
                    // Reset the reconfig flag and event.
                    pThreadData->bLoadNewConfig = FALSE;
					ResetEvent ( pThreadData->hReconfigEvent );
                } // else  bContinue is always returned as FALSE
                // so that will terminate this loop
            } while (bContinue);
            
            dwStatus = GetLastError();

        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            dwStatus = SMLOG_THREAD_FAILED;
        }

    } else {
        // unable to find data block so return
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( ERROR_SUCCESS != dwStatus ) {       
        szStringArray[0] = pThreadData->szQueryName;
        ReportEvent (
            hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            dwStatus,
            NULL,
            1,
            0,
            szStringArray,
            NULL
        );
    }
        
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\warndlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    warndlg.h

Abstract:

    Class definition for the expensive trace data warning dialog.

--*/

#ifndef _WARNDLG_H_
#define _WARNDLG_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Dialog controls
#define IDD_EXPENSIVEWARN               1200

#define IDC_STATIC_WARN                 1201
#define IDC_WARN_FIRST_HELP_CTRL_ID     1202
#define IDC_CHECK_NO_MORE               1202


class CProvidersProperty;

/////////////////////////////////////////////////////////////////////////////
// CWarnDlg dialog

class CWarnDlg : public CDialog
{
// Construction
public:
                    CWarnDlg(CWnd* pParent = NULL);   // standard constructor
    virtual         ~CWarnDlg(){};

            void    SetProvidersPage( CProvidersProperty* pPage ); 

// Dialog Data
    //{{AFX_DATA(CWarnDlg)
    enum { IDD = IDD_EXPENSIVEWARN };
    BOOL    m_CheckNoMore;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWarnDlg)
    protected:
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWarnDlg)
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CProvidersProperty* m_pProvidersPage;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _WARNDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogsvc\smlogsvc.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogsvc.h

Abstract:

    Header file for the Performance Logs and Alerts service

--*/

#ifndef _SMLOGSVC_H_
#define _SMLOGSVC_H_

#include <pdh.h>
#include "common.h"

#if !(_IMPLEMENT_WMI)
#define TRACEHANDLE             HANDLE
#define EVENT_TRACE_PROPERTIES  LPVOID
#endif

#define     IDS_UNDER                       101
#define     IDS_OVER                        102
#define     IDS_ALERT_MSG_FMT               103
#define     IDS_ALERT_TIMESTAMP_FMT         104
#define     IDS_CNF_SERIAL_NUMBER_FMT       105

#define     IDS_ERR_COUNTER_NOT_VALIDATED   150

// Start or sample delay of NULL_INTERVAL = ULONG_MAX = INFINITE signals to stop immediately.
// The largest single wait time is thus ULONG_MAX -1.

#define NULL_INTERVAL ((DWORD)(INFINITE))   // == ULONG_MAX == 0xFFFFFFFF
#define NULL_INTERVAL_TICS ((LONGLONG)(-1)) // == 0xFFFFFFFF'FFFFFFFF
#define INFINITE_TICS ((LONGLONG)(-1))      // == 0xFFFFFFFF'FFFFFFFF
    
// Maximum serial number is 999999 for Windows XP
#define MINIMUM_SERIAL_NUMBER   ((DWORD)(0x00000000))
#define MAXIMUM_SERIAL_NUMBER   ((DWORD)(0x000F423F))       

// definitions of dwAutoNameFormat
typedef struct _LOG_COUNTER_INFO {
    struct _LOG_COUNTER_INFO *next;
    HCOUNTER    hCounter;
} LOG_COUNTER_INFO, * PLOG_COUNTER_INFO;

typedef struct _ALERT_COUNTER_INFO {
    struct _ALERT_COUNTER_INFO *next;
    HCOUNTER    hCounter;
    PALERT_INFO_BLOCK   pAlertInfo;
} ALERT_COUNTER_INFO, * PALERT_COUNTER_INFO;

typedef struct _LOG_QUERY_DATA {
    struct _LOG_QUERY_DATA *next;   
    // These fields are written by the main thread
    // and read by the logging thread
    HANDLE      hThread;       
    HKEY        hKeyQuery;
    HANDLE      hExitEvent;
    HANDLE      hReconfigEvent;
    LONGLONG    llLastConfigured;
    // For queries, these fields are written 
    // and read by the logging thread
    SLQ_TIME_INFO   stiRegStart;
    SLQ_TIME_INFO   stiRegStop;
    SLQ_TIME_INFO   stiCreateNewFile;
    SLQ_TIME_INFO   stiRepeat;
    SLQ_TIME_INFO   stiCurrentStart;
    SLQ_TIME_INFO   stiCurrentStop;
    LPWSTR      szBaseFileName;
    LPWSTR      szLogFileFolder;
    LPWSTR      szSqlLogName;
    LPWSTR      szLogFileComment;
    LPWSTR      szCmdFileName;
    HANDLE      hUserToken;
    DWORD       dwLogType;              // Determines union type below
    DWORD       dwCurrentState;
    DWORD       dwLogFileType;
    DWORD       dwAppendMode;
    DWORD       dwCmdFileFailure;
    DWORD       dwAutoNameFormat;
    DWORD       dwCurrentSerialNumber;
    DWORD       dwMaxFileSize;
    DWORD       dwLogFileSizeUnit;
    TCHAR       szQueryName[MAX_PATH+1];
    TCHAR       szQueryKeyName[MAX_PATH+1];
    BOOL        bLoadNewConfig;
    union {
        struct {
            // For trace queries
            // these fields are written and read by the logging thread,
            // or by the main thread when creating a temporary query
            // for comparison.
			// Todo:  Still true?
            TRACEHANDLE             LoggerHandle;
            LPWSTR                  mszProviderList;
            LPGUID*                 arrpGuid;
            PTCHAR*                 arrpszProviderName;
			HANDLE					hNewFileEvent;
            EVENT_TRACE_PROPERTIES  Properties;
            TCHAR                   szLoggerName[MAX_PATH+1];   // Must follow Properties
            TCHAR                   szLogFileName[MAX_PATH+1];  // Must follow szLoggerName
            ULONG                   ulGuidCount;
            DWORD                   dwBufferSize;
            DWORD                   dwBufferMinCount;
            DWORD                   dwBufferMaxCount;
            DWORD                   dwBufferFlushInterval;
            DWORD                   dwFlags;
        };
        struct {
            // For counter and alert queries
            // these fields are written and read by the logging thread,
            // or by the main thread when creating a temporary query
            // for comparison.
            LPWSTR              mszCounterList;
            PLOG_COUNTER_INFO   pFirstCounter;    
            LPWSTR              szNetName;
            LPWSTR              szPerfLogName;
            LPWSTR              szUserText;
            DWORD               dwRealTimeQuery;
            DWORD               dwAlertActionFlags; // for alert queries
            DWORD               dwMillisecondSampleInterval;
            DWORD               dwNetMsgFailureReported;
            DWORD               dwAlertLogFailureReported;
        };
    };
} LOG_QUERY_DATA, FAR* PLOG_QUERY_DATA;


// global variables
extern HANDLE       hEventLog;
extern HINSTANCE    hModule;

extern SERVICE_STATUS_HANDLE    hPerfLogStatus;
extern SERVICE_STATUS           ssPerfLogStatus;

extern DWORD*       arrPdhDataCollectSuccess;  
extern INT          iPdhDataCollectSuccessCount;

// smlogsvc.c
void SysmonLogServiceControlHandler(
    IN  DWORD dwControl );

void 
SysmonLogServiceStart (
    IN  DWORD   argc,
    IN  LPTSTR  *argv );


int
__cdecl main(int argc, char *argv[]);

// Common functions

BOOL
GetLocalFileTime (
    LONGLONG    *pFileTime );

long
JulianDateFromSystemTime(
    SYSTEMTIME *pST );

DWORD    
ReadRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName, 
    PSLQ_TIME_INFO pSlqDefault,
    PSLQ_TIME_INFO pSlqValue );

DWORD    
ReadRegistryDwordValue (
    HKEY hKey, 
    LPCWSTR szQueryName,           // For error logging 
    LPCWSTR szValueName,
    PDWORD  pdwDefault, 
    LPDWORD pdwValue ); 

DWORD    
ReadRegistryStringValue (
    HKEY hKey, 
    LPCWSTR szQueryName,           // For error logging 
    LPCWSTR szValue,
    LPCWSTR szDefault, 
    LPWSTR *pszBuffer, 
    LPDWORD pdwLength );
        
DWORD
ReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR*  pszBuffer,
    UINT*    puiLength );

DWORD    
WriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  szValueName, 
    LPDWORD  pdwValue,
    DWORD    dwType);     // Also supports REG_BINARY
                          // *** Optional in C++

DWORD    
WriteRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szValueName, 
    PSLQ_TIME_INFO    pSlqTime );

LONGLONG
ComputeStartWaitTics (
    IN    PLOG_QUERY_DATA pArg,
    IN    BOOL  bWriteToRegistry );

DWORD
LoadQueryConfig (
    IN  PLOG_QUERY_DATA   pArg );

HRESULT
RegisterCurrentFile( 
    HKEY hkeyQuery, 
    LPWSTR strFileName, 
    DWORD dwSubIndex );

DWORD
BuildCurrentLogFileName (
    IN  LPCTSTR     szQueryName,
    IN  LPCTSTR     szBaseFileName,
    IN  LPCTSTR     szDefaultDir,
    IN  LPCTSTR     szSqlLogName,
    IN  LPTSTR      szOutFileBuffer,
    IN  LPDWORD     lpdwSerialNumber,
    IN  DWORD       dwAutoNameFormat,
    IN  DWORD       dwLogFileType,
    IN  INT         iCnfSerial );

BOOL
FileExists (
    IN LPCTSTR      szFileName );

void 
DeallocateQueryBuffers (
    IN PLOG_QUERY_DATA pThisThread );        

DWORD
SetStoppedStatus (
    IN PLOG_QUERY_DATA pQuery );

// Trace
void 
InitTraceProperties (
    IN PLOG_QUERY_DATA pQuery,
    IN BOOL         bUpdateSerial,
    IN OUT DWORD*   pdwSessionSerial,
    IN OUT INT*     pCnfSerial );

DWORD
GetTraceQueryStatus (
    IN PLOG_QUERY_DATA pQuery,
	IN OUT PLOG_QUERY_DATA pReturnQuery);

LPWSTR
FormatEventLogMessage(DWORD dwStatus);

DWORD
DoLogCommandFile (
    IN  PLOG_QUERY_DATA	pArg,
    IN  LPTSTR              szLogFileName,
    IN  BOOL                bStillRunning );

DWORD
GetQueryKeyName (
    IN  LPCTSTR szQueryName,
    OUT LPTSTR  szQueryKeyName,
    IN  DWORD   dwQueryKeyNameLen );


// logthred.c

DWORD
LoggingThreadProc (
    IN  LPVOID  lpThreadArg );

#endif //_SMLOGSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogsvc\utils.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Utils.c

Abstract:

	Contains utility methods which are used throughout the project.

--*/

#ifndef UNICODE
#define UNICODE     1
#endif

#ifndef _UNICODE
#define _UNICODE    1
#endif

// Define the following to use the minimum of shlwapip.h 

#ifndef NO_SHLWAPI_PATH
#define NO_SHLWAPI_PATH
#endif  

#ifndef NO_SHLWAPI_REG
#define NO_SHLWAPI_REG
#endif  

#ifndef NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_UALSTR
#endif  

#ifndef NO_SHLWAPI_STREAM
#define NO_SHLWAPI_STREAM
#endif  

#ifndef NO_SHLWAPI_HTTP
#define NO_SHLWAPI_HTTP
#endif  

#ifndef NO_SHLWAPI_INTERNAL
#define NO_SHLWAPI_INTERNAL
#endif  

#ifndef NO_SHLWAPI_GDI
#define NO_SHLWAPI_GDI
#endif  

#ifndef NO_SHLWAPI_UNITHUNK
#define NO_SHLWAPI_UNITHUNK
#endif  

#ifndef NO_SHLWAPI_TPS
#define NO_SHLWAPI_TPS
#endif  

#ifndef NO_SHLWAPI_MLUI
#define NO_SHLWAPI_MLUI
#endif  


#include <shlwapi.h>            // For PlaReadRegistryIndirectStringValue
#include <shlwapip.h>           // For PlaReadRegistryIndirectStringValue

#include <assert.h>
#include <stdlib.h>
#include <tchar.h>
#include <pdhp.h>

// Disable 64-bit warnings in math.h
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4032 )
#include <math.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#include "common.h"

// Time conversion constants

#define SECONDS_IN_DAY      86400
#define SECONDS_IN_HOUR      3600
#define SECONDS_IN_MINUTE      60

#define INDIRECT_STRING_LEN 9

LPCWSTR cszFormatIndirect = L"%s Indirect";

// Forward definitions - to be moved to pdhpla
PDH_FUNCTION    
PlaReadRegistryIndirectStringValue (
    HKEY hKey, 
    LPCWSTR cwszValueName,
    LPWSTR  *pszBuffer, 
    UINT*   puiLength 
);


BOOL __stdcall
GetLocalFileTime (
    LONGLONG    *pFileTime
)
{
    BOOL    bResult;
    SYSTEMTIME  st;

    assert ( NULL != pFileTime );

    GetLocalTime ( &st );
    bResult = SystemTimeToFileTime (&st, (LPFILETIME)pFileTime);

    return bResult;
}

BOOL __stdcall 
MakeStringFromInfo (
    PALERT_INFO_BLOCK pInfo,
    LPTSTR szBuffer,
    LPDWORD pcchBufferLength
)
{
    DWORD   dwSizeReqd;

    dwSizeReqd = pInfo->dwSize - sizeof(ALERT_INFO_BLOCK);
    dwSizeReqd /= sizeof(LPTSTR); // size of counter path in chars
    dwSizeReqd += 1; // sizeof inequality char
    dwSizeReqd += 20; // size of value in chars
    dwSizeReqd += 1; // term NULL

    if (dwSizeReqd <= *pcchBufferLength) {
        // copy info block contents to a string buffer
        *pcchBufferLength = _stprintf (szBuffer, L"%s%s%0.23g",
            pInfo->szCounterPath,
            (((pInfo->dwFlags & AIBF_OVER) == AIBF_OVER) ? L">" : L"<"),
            pInfo->dLimit);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL __stdcall 
MakeInfoFromString (
    LPCTSTR szBuffer,
    PALERT_INFO_BLOCK pInfo,
    LPDWORD pdwBufferSize
)
{
    LPCTSTR szSrc;
    LPTSTR  szDst;
    CHAR    szAnsiVal[64];
    DWORD   dwSizeUsed;
    DWORD   dwSizeLimit = *pdwBufferSize - sizeof(TCHAR);

    szAnsiVal[0] = '\0';
    dwSizeUsed = sizeof(ALERT_INFO_BLOCK);
    szSrc = szBuffer;
    szDst = (LPTSTR)&pInfo[1];
    pInfo->szCounterPath = szDst;
    // copy the string
    while (dwSizeUsed < dwSizeLimit) {
        if ((*szSrc == L'<') || (*szSrc == L'>')) break;
        *szDst++ = *szSrc++;
        dwSizeUsed += sizeof(TCHAR);
    }

    if (dwSizeUsed < dwSizeLimit) {
        *szDst++ = 0; // NULL term the string
        dwSizeUsed += sizeof(TCHAR);
    }

    pInfo->dwFlags = ((*szSrc == L'>') ? AIBF_OVER : AIBF_UNDER);
    szSrc++;

    // get limit value
    wcstombs (szAnsiVal, szSrc, sizeof(szAnsiVal));
    pInfo->dLimit = atof(szAnsiVal);

    // write size of buffer used
    pInfo->dwSize = dwSizeUsed;

    if (dwSizeUsed <= *pdwBufferSize) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

void _stdcall
ReplaceBlanksWithUnderscores(
    LPWSTR  szName )
{
    PdhiPlaFormatBlanksW( NULL, szName );
}

void _stdcall
TimeInfoToMilliseconds (
    SLQ_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs)
{
    assert ( SLQ_TT_DTYPE_UNITS == pTimeInfo->wDataType );

    TimeInfoToTics ( pTimeInfo, pllmsecs );

    *pllmsecs /= FILETIME_TICS_PER_MILLISECOND;

    return;
}

void _stdcall
TimeInfoToTics (
    SLQ_TIME_INFO* pTimeInfo,
    LONGLONG* pllTics)
{
    assert ( SLQ_TT_DTYPE_UNITS == pTimeInfo->wDataType );

    switch (pTimeInfo->dwUnitType) {
        case SLQ_TT_UTYPE_SECONDS:
            *pllTics = pTimeInfo->dwValue;
            break;
        case SLQ_TT_UTYPE_MINUTES:
            *pllTics = pTimeInfo->dwValue * SECONDS_IN_MINUTE;
            break;

        case SLQ_TT_UTYPE_HOURS:
            *pllTics = pTimeInfo->dwValue * SECONDS_IN_HOUR;
            break;

        case SLQ_TT_UTYPE_DAYS:
            *pllTics = pTimeInfo->dwValue * SECONDS_IN_DAY;
            break;

        default:
            *pllTics = 0;
    }

    *pllTics *= FILETIME_TICS_PER_SECOND;

    return;
}


PDH_FUNCTION
PlaReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  pcszValueName,
    LPWSTR*  pszBuffer,
    UINT*    puiLength
)
{
//
//  reads the indirect string value from under hKey and
//  frees any existing buffer referenced by pszBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the length
//  of the buffer (string length including NULL terminator) 
//
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    LPTSTR  szNewStringBuffer = NULL;
    UINT    uiBufferLen = 0;

    const UINT uiBufferLenGrow   = 256;

    assert ( NULL != hKey );
    assert ( NULL != pcszValueName );
    assert ( NULL != pszBuffer );
    assert ( NULL != puiLength );

    if ( NULL != hKey ) {
        if ( ( NULL != pcszValueName )    
            && ( NULL != pszBuffer )    
            && ( NULL != puiLength ) ) {  
        
            // find out the size of the required buffer

            do {
                /*
                 * allocate a large(r) buffer for the string
                 */
        
                if ( NULL != szNewStringBuffer ) {
                    G_FREE ( szNewStringBuffer );
                    szNewStringBuffer = NULL;
                }
                uiBufferLen += uiBufferLenGrow;

                szNewStringBuffer = (LPWSTR)G_ALLOC( uiBufferLen*sizeof(WCHAR));
                if ( NULL != szNewStringBuffer ) {

                    hr = SHLoadRegUIStringW (
                            hKey,
                            pcszValueName,
                            szNewStringBuffer,
                            uiBufferLen);

                    /*
                     * If we filled up the buffer, we'll pessimistically assume that
                     * there's more data available.  We'll loop around, grow the buffer,
                     * and try again.
                     */
                } else {
                    pdhStatus = ERROR_OUTOFMEMORY;
                    break;
                }

            } while ( (ULONG)lstrlen( szNewStringBuffer ) == uiBufferLen-1 
                        && SUCCEEDED ( hr ) );

            if ( NULL != szNewStringBuffer ) {
                if ( 0 == lstrlen (szNewStringBuffer) ) {
                    // nothing to read                
                    pdhStatus = ERROR_NO_DATA;
                } else {
                    if ( FAILED ( hr ) ) {
                        // Unable to read buffer
                        // Translate hr to pdhStatus
                        assert ( E_INVALIDARG != hr );
                        if ( E_OUTOFMEMORY == hr ) {
                            // Todo:  Return pdh memory code?
                            pdhStatus = ERROR_OUTOFMEMORY; 
                        } else {
                            pdhStatus = ERROR_NO_DATA;
                        }
                    } 
                }
            }
        } else {
            pdhStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        // null key
        pdhStatus = ERROR_BADKEY;
    }

    if ( ERROR_SUCCESS != pdhStatus ) {
        if ( NULL != szNewStringBuffer ) {
            G_FREE (szNewStringBuffer);
            szNewStringBuffer = NULL;
            uiBufferLen = 0;
        }
    } else {
        // then delete the old buffer and replace it with 
        // the new one
        if ( NULL != *pszBuffer ) {
            G_FREE (*pszBuffer );
        }
        *pszBuffer = szNewStringBuffer;
        *puiLength = uiBufferLen;
    }

    return pdhStatus;
}   


DWORD
SmReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR*  pszBuffer,
    UINT*    puiLength
)
//
//  reads the string value "szValueName" from under hKey and
//  frees any existing buffer referenced by pszBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer (in bytes) 
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szNewStringBuffer = NULL;
    UINT    uiBufferLen = 0;
    LPWSTR  szIndirectValueName = NULL;
    UINT    uiValueNameLen = 0;
    DWORD   dwType;
    DWORD   dwBufferSize = 0;

    if ( NULL == hKey ) {
        assert ( FALSE );
        dwStatus = ERROR_BADKEY;
    }
    else if ( ( NULL == puiLength ) || 
              ( NULL == pszBuffer ) || 
              ( NULL == szValueName ) ) {

        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if (dwStatus == ERROR_SUCCESS) {
        uiValueNameLen = lstrlen ( szValueName ) + INDIRECT_STRING_LEN + 1;

        szIndirectValueName = G_ALLOC ( uiValueNameLen * sizeof(WCHAR) );
          
        if ( NULL != szIndirectValueName ) {
            swprintf ( szIndirectValueName, cszFormatIndirect, szValueName );
            dwStatus = PlaReadRegistryIndirectStringValue (
                        hKey,
                        szIndirectValueName,
                        &szNewStringBuffer,
                        &uiBufferLen );
   
            if ( ERROR_SUCCESS == dwStatus) {
                if ( 0 == lstrlen( szNewStringBuffer ) ) {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
            } // else dwStatus has error
            G_FREE ( szIndirectValueName );
        } else {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( ERROR_NO_DATA == dwStatus ) {
            // There might be something to read under the non-indirect field.
            // Find out the size of the required buffer.
            dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwBufferSize);
            if (dwStatus == ERROR_SUCCESS) {
                // NULL character size is 2 bytes
                if (dwBufferSize > 2) {
                    // then there's something to read            
                    szNewStringBuffer = (WCHAR*) G_ALLOC ( dwBufferSize ); 
                    if (szNewStringBuffer != NULL) {
                        dwType = 0;
                        dwStatus = RegQueryValueExW (
                                hKey,
                                szValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)szNewStringBuffer,
                                &dwBufferSize);
                    
                        if ( 0 == lstrlenW ( szNewStringBuffer ) ) {
                            dwStatus = ERROR_NO_DATA;
                        }
                    } else {
                        // Todo:  Report event for this case.
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                } else {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
            }
        }

        if ( ERROR_SUCCESS != dwStatus ) {
            if ( NULL != szNewStringBuffer ) {
                G_FREE ( szNewStringBuffer ); 
                szNewStringBuffer = NULL;
                uiBufferLen = 0;
            }
            // apply default
            if ( NULL != szDefault ) {

                uiBufferLen = lstrlen(szDefault) + 1;
                if ( 1 < uiBufferLen ) {

                    szNewStringBuffer = (WCHAR*) G_ALLOC ( uiBufferLen *= sizeof (WCHAR) );

                    if ( NULL != szNewStringBuffer ) {
                        lstrcpyW ( szNewStringBuffer, szDefault);
                        dwStatus = ERROR_SUCCESS;
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                }
            } // else no default so no data returned
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            // Delete the old buffer and replace it with 
            // the new one.
            if ( NULL != *pszBuffer ) {
                G_FREE (*pszBuffer );       //delete (*pszBuffer );
            }
            *pszBuffer = szNewStringBuffer;
            *puiLength = uiBufferLen;
        } else {
            // if error then delete the buffer
            if ( NULL != szNewStringBuffer ) {
                G_FREE ( szNewStringBuffer );   //delete (szNewStringBuffer);
                *puiLength = 0;
            }
        }
    }

    return dwStatus;
}   

HRESULT
RegisterCurrentFile( HKEY hkeyQuery, LPWSTR strFileName, DWORD dwSubIndex )
{
    HRESULT hr = ERROR_SUCCESS;
    LPWSTR strLocalFileName = NULL;
    BOOL bLocalAlloc = FALSE;
    DWORD dwSize;

    if( strFileName == NULL ){
        return hr;
    }

    __try{
        if( dwSubIndex == (-1) ){

            // The only time this will get called with a (-1) is the first time
            // trace is building the file name.
            
            dwSize = (DWORD)((BYTE*)&strFileName[wcslen( strFileName )] - 
                             (BYTE*)&strFileName[0]);
            
            dwSize += 32 * sizeof(WCHAR);
            strLocalFileName = (LPWSTR)G_ALLOC( dwSize );
            
            if( NULL == strLocalFileName ){
                return ERROR_OUTOFMEMORY;
            }

            bLocalAlloc = TRUE;
            swprintf( strLocalFileName, strFileName, 1 /* Sub index starts at 1 */ );

        }else{
            strLocalFileName = strFileName;
        }

        dwSize = (DWORD)((BYTE*)&strLocalFileName[wcslen( strLocalFileName )] - 
                         (BYTE*)&strLocalFileName[0]);
 
        hr = RegSetValueExW (hkeyQuery,
                    L"Current Log File Name",
                    0L,
                    REG_SZ,
                    (CONST BYTE *)strLocalFileName,
                    dwSize
                );

        if( bLocalAlloc ){
            G_FREE( strLocalFileName );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return ERROR_ARENA_TRASHED;
    }

    return hr;
}

#if 0
void
StringFromGuid (
    REFGUID   rguid,
    CString& rstrGuid )
{
    rstrGuid.Format (
            TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            rguid.Data1, rguid.Data2, rguid.Data3, rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3], rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\about.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       about.cpp
//
//  Contents:   implementation of CAbout, CSCEAbout, CSCMAbout, CSSAbout, 
//              CRSOPAbout & CLSAbout
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "about.h"
#include <ntverp.h>
#define OUT_VERSION VER_PRODUCTVERSION_STR

/////////////////////////////////////////////////////////////////////
CSCEAbout::CSCEAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_SCEABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CSCMAbout::CSCMAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_SCMABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CSSAbout::CSSAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_SSABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CRSOPAbout::CRSOPAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_RSOPABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CLSAbout::CLSAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_LSABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}


/////////////////////////////////////////////////////////////////////
// HrLoadOleString()
//
// Load a string from the resource and return pointer to allocated
// OLE string.
//
// HISTORY
// 29-Jul-97   t-danm      Creation.
//
HRESULT
HrLoadOleString(
               UINT uStringId,               // IN: String Id to load from the resource
               OUT LPOLESTR * ppaszOleString)   // OUT: Pointer to pointer to allocated OLE string
{
   if (ppaszOleString == NULL) {
      TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
      return E_POINTER;
   }
   CString strT;     // Temporary string
   AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Needed for LoadString()
   if( IDS_SNAPINABOUT_VERSION == uStringId )
   {
      strT = OUT_VERSION;
   }
   else
   {
      VERIFY( strT.LoadString(uStringId) );
   }
   *ppaszOleString = reinterpret_cast<LPOLESTR>
                     (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
   if (*ppaszOleString == NULL) {
      return E_OUTOFMEMORY;
   }
   USES_CONVERSION;
   wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
   return S_OK;
} // HrLoadOleString()


STDMETHODIMP CAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
{
   return HrLoadOleString(m_uIdStrDescription, OUT lpDescription);
}

STDMETHODIMP CAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
{
   return HrLoadOleString(m_uIdStrProvider, OUT lpName);
}

STDMETHODIMP CAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
{
   return HrLoadOleString(m_uIdStrVersion, OUT lpVersion);
}

STDMETHODIMP CAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
{
   if (hAppIcon == NULL)
      return E_POINTER;
   AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
   *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
   if (*hAppIcon == NULL) {
      ASSERT(FALSE && "Unable to load icon");
      return E_FAIL;
   }
   return S_OK;
}

STDMETHODIMP CAbout::GetStaticFolderImage(
                                               OUT HBITMAP __RPC_FAR *hSmallImage,
                                               OUT HBITMAP __RPC_FAR *hSmallImageOpen,
                                               OUT HBITMAP __RPC_FAR *hLargeImage,
                                               OUT COLORREF __RPC_FAR *crMask)
{
   ASSERT(hSmallImage != NULL);
   ASSERT(hSmallImageOpen != NULL);
   ASSERT(hLargeImage != NULL);
   ASSERT(crMask != NULL);
   AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
   HINSTANCE hInstance = AfxGetInstanceHandle();

   //Raid #379315, 4/27/2001
   *hSmallImage = (HBITMAP)::LoadImage(
                            hInstance,
                            MAKEINTRESOURCE(m_uIdBitmapSmallImage),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_SHARED
                            );
   *hSmallImageOpen = (HBITMAP)::LoadImage(
                            hInstance,
                            MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_SHARED
                            );
   *hLargeImage = (HBITMAP)::LoadImage(
                            hInstance,
                            MAKEINTRESOURCE(m_uIdBitmapLargeImage),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_SHARED
                            );
   *crMask = m_crImageMask;
   #ifdef _DEBUG
   if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage) {
      TRACE0("WRN: CAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
      return E_FAIL;
   }
   #endif
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aaudit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aaudit.h
//
//  Contents:   definition of CAttrAudit
//
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRAUDIT_H__76BA1B2D_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRAUDIT_H__76BA1B2D_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrAudit dialog

class CAttrAudit : public CAttribute
{
// Construction
public:
	void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
	CAttrAudit();   // standard constructor


// Dialog Data
	//{{AFX_DATA(CAttrAudit)
	enum { IDD = IDD_ATTR_AUDIT };
	BOOL	m_AuditSuccess;
	BOOL	m_AuditFailed;
	CString	m_Title;
	CString	m_strLastInspect;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttrAudit)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAttrAudit)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSuccess();
	afx_msg void OnChangeFailed();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRAUDIT_H__76BA1B2D_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aaudit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aaudit.cpp
//
//  Contents:   implementation of CAttrAudit
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "AAudit.h"
#include "util.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrAudit dialog


CAttrAudit::CAttrAudit()
   : CAttribute (IDD)
{
    //{{AFX_DATA_INIT(CAttrAudit)
    m_AuditSuccess = FALSE;
    m_AuditFailed = FALSE;
    m_Title = _T("");
    m_strLastInspect = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a170HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrAudit::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrAudit)
    DDX_Check(pDX, IDC_CHANGE_SUCCESS, m_AuditSuccess);
    DDX_Check(pDX, IDC_CHANGE_FAILED, m_AuditFailed);
    DDX_Text(pDX, IDC_LAST_INSPECT, m_strLastInspect);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrAudit, CAttribute)
    //{{AFX_MSG_MAP(CAttrAudit)
        ON_BN_CLICKED(IDC_CHANGE_SUCCESS, OnChangeSuccess)
        ON_BN_CLICKED(IDC_CHANGE_FAILED, OnChangeFailed)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrAudit message handlers
BOOL CAttrAudit::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw=0;
      DWORD status = 0;

      UpdateData(TRUE);
      dw = 0;
      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         if (m_AuditSuccess)
            dw |= AUDIT_SUCCESS;

         if (m_AuditFailed)
            dw |= AUDIT_FAILURE;
      }
      m_pData->SetBase(dw);
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),dw, m_pData);
      m_pData->SetStatus(status);

      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}


void CAttrAudit::Initialize(CResult * pResult)
{
    LONG_PTR dw=0;

    CAttribute::Initialize(pResult);
    dw = pResult->GetBase();
    m_bConfigure = ( dw != (LONG_PTR)ULongToPtr(SCE_NO_VALUE) );
    if (m_bConfigure) {
        SetInitialValue((DWORD_PTR)dw);
    }

    pResult->GetDisplayName( NULL, m_strLastInspect, 2 );
}

void
CAttrAudit::SetInitialValue(DWORD_PTR dw) 
{
    m_AuditSuccess = ( (dw & AUDIT_SUCCESS) != 0 );
    m_AuditFailed = ( (dw & AUDIT_FAILURE) != 0 );
}

BOOL CAttrAudit::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_CHANGE_SUCCESS);
    AddUserControl(IDC_CHANGE_FAILED);
    EnableUserControls(m_bConfigure);

    return TRUE;  // return TRUE unless you set the focus to a control
}

void CAttrAudit::OnChangeSuccess()
{
    SetModified(TRUE);
}

void CAttrAudit::OnChangeFailed()
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogsvc\smlogsvc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    smlogsvc.c

Abstract:

    service to log performance counter and trace data,
    and to scan for alert conditions.
--*/

#ifndef UNICODE
#define UNICODE     1
#endif

#ifndef _UNICODE
#define _UNICODE    1
#endif

#ifndef _IMPLEMENT_WMI 
#define _IMPLEMENT_WMI 1
#endif

#ifndef _DEBUG_OUTPUT 
#define _DEBUG_OUTPUT 0
#endif

//
//  Windows Include files
//
#pragma warning ( disable : 4201)
#pragma warning ( disable : 4127)

// Define the following to use the minimum of shlwapip.h 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include <limits.h>

#if _IMPLEMENT_WMI
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
#include <wmiguid.h>
#include <wmium.h>
#include <pdhmsg.h>        // For BuildCurrentLogFileName
#include <pdhp.h>
#endif

#include <tchar.h>
#include <assert.h>
#include <limits.h>
#include "common.h"
#include "smlogsvc.h"
#include "smlogmsg.h"

#define  NT_KERNEL_LOGGER     ((LPWSTR)L"NT Kernel Logger")
#define  DEFAULT_LOG_FILE_FOLDER    L"%SystemDrive%\\PerfLogs"
#define  STATUS_MASK    ((DWORD)0x3FFFFFFF)

// todo:  Move SECONDS_IN_DAY definition
#define SECONDS_IN_DAY      ((LONGLONG)(86400))

// Global variables used by all modules
HANDLE      hEventLog = NULL;
HINSTANCE   hModule = NULL;
DWORD*      arrPdhDataCollectSuccess = NULL;  
INT         iPdhDataCollectSuccessCount = 0;

// hNewQueryEvent is signalled when a new query is started.  This tells the main
// thread to reconfigure its array of Wait objects. 
HANDLE      hNewQueryEvent = NULL;    

SERVICE_STATUS_HANDLE   hSmLogStatus;
SERVICE_STATUS          ssSmLogStatus;

// Static variables used by this module only

static PLOG_QUERY_DATA  pFirstQuery = NULL;
static CRITICAL_SECTION QueryDataLock;
static CRITICAL_SECTION ConfigurationLock;
static TCHAR            gszDefaultLogFileFolder[MAX_PATH+1] = TEXT("");

// Active session count should match the number of query data objects.
static DWORD                dwActiveSessionCount = 0;
static DWORD                dwMaxActiveSessionCount = MAXIMUM_WAIT_OBJECTS - 1;
static HANDLE               arrSessionHandle[MAXIMUM_WAIT_OBJECTS];


// Local function prototypes
DWORD
LoadCommonConfig(
    IN  PLOG_QUERY_DATA   pQuery);

void 
LockQueryData ( void );

void 
UnlockQueryData ( void );

PLOG_QUERY_DATA
GetQueryData (
    LPCTSTR  szQueryName );

void 
FreeQueryData (
    IN PLOG_QUERY_DATA pQuery );

void 
RemoveAndFreeQueryData (
    HANDLE hThisQuery );

BOOL
AlertFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery );

BOOL
CommonFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery );

BOOL
FieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery );

DWORD 
ConfigureQuery (
    HKEY    hKeyLogQuery,
    TCHAR*  szQueryKeyNameBuffer,
    TCHAR*  szQueryNameBuffer );

void 
ClearTraceProperties (
    IN PLOG_QUERY_DATA pQuery );

BOOL
TraceStopRestartFieldsMatch (
    IN PLOG_QUERY_DATA pOrigQuery,
    IN PLOG_QUERY_DATA pNewQuery );

DWORD
ReconfigureQuery (
    IN PLOG_QUERY_DATA pQuery );

DWORD
StartQuery (
    IN PLOG_QUERY_DATA pQuery );

DWORD
HandleMaxQueriesExceeded (
    IN PLOG_QUERY_DATA pQuery );

DWORD
InitTraceGuids(
    IN PLOG_QUERY_DATA pQuery );

BOOL
IsKernelTraceMode (
    IN DWORD dwTraceFlags );

DWORD
LoadPdhLogUpdateSuccess ( void );

void
LoadDefaultLogFileFolder ( void );

DWORD
ProcessLogFileFolder (     
    IN PLOG_QUERY_DATA pQuery,
    IN BOOL bReconfigure );

#if _IMPLEMENT_WMI

DWORD
IsCreateNewFile (
    IN  PLOG_QUERY_DATA pQuery,
    OUT BOOL*           pbValidBySize, 
    OUT BOOL*           pbValidByTime ); 

ULONG
TraceNotificationCallback(
    IN PWNODE_HEADER pWnode, 
    IN UINT_PTR LogFileIndex )
{
    UNREFERENCED_PARAMETER(LogFileIndex);
    
    if (   (IsEqualGUID(& pWnode->Guid, & TraceErrorGuid))
        && (pWnode->BufferSize >= (sizeof(WNODE_HEADER) + sizeof(ULONG))))
    {
        ULONG           LoggerId = (ULONG) pWnode->HistoricalContext;
        PLOG_QUERY_DATA pQuery   = pFirstQuery;
        ULONG           Status   = * ((ULONG *)
                                   (((PUCHAR) pWnode) + sizeof(WNODE_HEADER)));
        LOG_QUERY_DATA lqdTemp;
        HRESULT hr = ERROR_SUCCESS;
        DWORD   dwStatus = ERROR_SUCCESS;

        while ( NULL != pQuery ) {
            // todo:  Need to lock queue?
            if (pQuery->Properties.Wnode.HistoricalContext == LoggerId) {
                break;
            }
            pQuery = pQuery->next;
        }

        if ( STATUS_LOG_FILE_FULL == Status 
                || STATUS_THREAD_IS_TERMINATING == Status ) {

            if ( NULL != pQuery ) {
                SetEvent (pQuery->hExitEvent);
            }

        } else if ( STATUS_MEDIA_CHANGED == Status ) {
        
            BOOL bRun = TRUE;

            if ( NULL != pQuery ) {

                if( pQuery->hUserToken == NULL ){
                    // see if we can get a user token
                    hr = PdhiPlaRunAs( pQuery->szQueryName, NULL, &pQuery->hUserToken );

                    if ( ERROR_SUCCESS != hr ){
                        LPWSTR  szStringArray[2];
                        szStringArray[0] = pQuery->szQueryName;
                        ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_INVALID_CREDENTIALS,
                                NULL,
                                1,
                                sizeof(HRESULT),
                                szStringArray,
                                (LPVOID)&hr
                            );
                        bRun = FALSE;
                    } 
                }
                // Run command file, supplying previous filename
                if ( bRun && NULL != pQuery->szCmdFileName ) {
                    DoLogCommandFile (pQuery, pQuery->szLogFileName, TRUE);
                }
            }

            // Retrieve the current log file name for the next notification.
            dwStatus = GetTraceQueryStatus ( pQuery, &lqdTemp );

            if ( ERROR_SUCCESS == dwStatus ) {
                lstrcpy ( pQuery->szLogFileName, lqdTemp.szLogFileName );
                RegisterCurrentFile( pQuery->hKeyQuery, pQuery->szLogFileName, 0 );
            } // else { todo report error

            // Query to get the new filename
        } else {
            // report error
        }
        
    }

    return ERROR_SUCCESS;
}
#endif


// Functions

DWORD
GetSystemWideDefaultNullDataSource()
{
    static BOOLEAN bRead            = FALSE;
    static DWORD   dwNullDataSource = DATA_SOURCE_REGISTRY;

    if (bRead == FALSE) {
        HKEY  hKeyPDH  = NULL;
        DWORD dwStatus;
        DWORD dwType   = 0;
        DWORD dwSize   = sizeof(DWORD);

        dwStatus = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PDH",
                0L,
                KEY_READ,
                & hKeyPDH);
        if (dwStatus == ERROR_SUCCESS) {
            dwStatus = RegQueryValueExW(hKeyPDH,
                                        L"DefaultNullDataSource",
                                        NULL,
                                        & dwType,
                                        (LPBYTE) & dwNullDataSource,
                                        & dwSize);
            if (   dwStatus == ERROR_SUCCESS
                && dwType == REG_DWORD
                && dwNullDataSource == DATA_SOURCE_WBEM) {
                dwNullDataSource = DATA_SOURCE_WBEM;
            }
            else {
                dwNullDataSource = DATA_SOURCE_REGISTRY;
            }
            RegCloseKey(hKeyPDH);
        }
        bRead = TRUE;
    }
    return dwNullDataSource;
}

DWORD
ScanHexFormat(
    IN const WCHAR* Buffer,
    IN ULONG MaximumLength,
    IN const WCHAR* Format,
    ...)
/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    Buffer -
        Contains the source buffer which is to be scanned.

    MaximumLength -
        Contains the maximum length in characters for which Buffer is searched.
        This implies that Buffer need not be UNICODE_NULL terminated.

    Format -
        Contains the format string which defines both the acceptable string format
        contained in Buffer, and the variable parameters which follow.

    NOTE:  This code is from \ntos\rtl\guid.c

Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     FormatItems;

    va_start(ArgList, Format);
    for (FormatItems = 0;;) {
        switch (*Format) {
        case 0:
            return (*Buffer && MaximumLength) ? -1 : FormatItems;
        case '%':
            Format++;
            if (*Format != '%') {
                ULONG   Number;
                int     Width;
                int     Long;
                PVOID   Pointer;

                for (Long = 0, Width = 0;; Format++) {
                    if ((*Format >= '0') && (*Format <= '9')) {
                        Width = Width * 10 + *Format - '0';
                    } else if (*Format == 'l') {
                        Long++;
                    } else if ((*Format == 'X') || (*Format == 'x')) {
                        break;
                    }
                }
                Format++;
                for (Number = 0; Width--; Buffer++, MaximumLength--) {
                    if (!MaximumLength)
                        return (DWORD)(-1);
                    Number *= 16;
                    if ((*Buffer >= '0') && (*Buffer <= '9')) {
                        Number += (*Buffer - '0');
                    } else if ((*Buffer >= 'a') && (*Buffer <= 'f')) {
                        Number += (*Buffer - 'a' + 10);
                    } else if ((*Buffer >= 'A') && (*Buffer <= 'F')) {
                        Number += (*Buffer - 'A' + 10);
                    } else {
                        return (DWORD)(-1);
                    }
                }
                Pointer = va_arg(ArgList, PVOID);
                if (Long) {
                    *(PULONG)Pointer = Number;
                } else {
                    *(PUSHORT)Pointer = (USHORT)Number;
                }
                FormatItems++;
                break;
            }
            /* no break */
        default:
            if (!MaximumLength || (*Buffer != *Format)) {
                return (DWORD)(-1);
            }
            Buffer++;
            MaximumLength--;
            Format++;
            break;
        }
    }
}


DWORD
GUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    )
/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

    NOTE:  This code is from \ntos\rtl\guid.c

Return Value:

    Returns ERROR_SUCCESS if the buffer contained a valid GUID, else
    ERROR_INVALID_PARAMETER if the string was invalid.

--*/
{
    USHORT    Data4[8];
    int       Count;

    WCHAR GuidFormat[] = L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}";

    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Data4[Count] = 0;
    }

    if (ScanHexFormat(GuidString->Buffer, GuidString->Length / sizeof(WCHAR), GuidFormat, &Guid->Data1, &Guid->Data2, &Guid->Data3, &Data4[0], &Data4[1], &Data4[2], &Data4[3], &Data4[4], &Data4[5], &Data4[6], &Data4[7]) == -1) {
        return (DWORD)(ERROR_INVALID_PARAMETER);
    }
    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Guid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return ERROR_SUCCESS;
}


LPWSTR
FormatEventLogMessage(DWORD dwStatus)
{

    LPVOID lpMsgBuf = NULL;
    HINSTANCE hPdh = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;
    
    hPdh = LoadLibrary (_T("PDH.DLL"));    

    if (NULL != hPdh){
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;        
    }

    FormatMessage( 
        dwFlags,
        hPdh,
        dwStatus,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpMsgBuf,
        MAX_PATH,
        NULL );
    
    if ( NULL != hPdh ) {
        FreeLibrary( hPdh );
    }

    return lpMsgBuf;
}


BOOL
IsKernelTraceMode (
    IN DWORD dwTraceFlags )
{
    BOOL bReturn = FALSE;
    DWORD dwKernelMask = SLQ_TLI_ENABLE_KERNEL_TRACE
                            | SLQ_TLI_ENABLE_KERNEL_TRACE          
                            | SLQ_TLI_ENABLE_MEMMAN_TRACE          
                            | SLQ_TLI_ENABLE_FILEIO_TRACE        
                            | SLQ_TLI_ENABLE_PROCESS_TRACE       
                            | SLQ_TLI_ENABLE_THREAD_TRACE        
                            | SLQ_TLI_ENABLE_DISKIO_TRACE        
                            | SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE;

    bReturn = ( dwKernelMask & dwTraceFlags ) ? TRUE : FALSE;

    return bReturn;
}

long
JulianDateFromSystemTime(
    SYSTEMTIME *pST )
{
    static WORD wDaysInRegularMonth[] = {
        31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };

    static WORD wDaysInLeapYearMonth[] = {
        31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366
    };

    long JDate = 0;

    // Check for leap year.
    if (pST->wMonth > 1) {
        if ( ( pST->wYear % 400 == 0 )
                || ( pST->wYear % 100 != 0 
                        && pST->wYear % 4 == 0 ) ) {
            // this is a leap year
            JDate += wDaysInLeapYearMonth[pST->wMonth - 2];
        } else {
            // this is not a leap year
            JDate += wDaysInRegularMonth[pST->wMonth - 2];
        }
    }
    // Add in days for this month.
    JDate += pST->wDay;

    // Add in year.
    JDate += (pST->wYear) * 1000;

    return JDate;
}


DWORD
ReadRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName,
    PSLQ_TIME_INFO pPlqtDefault,
    PSLQ_TIME_INFO pPlqtValue
)
//
//  reads the time value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;

    SLQ_TIME_INFO   plqLocal;

    assert (pPlqtValue != NULL);
    assert (szValueName != NULL);

    if (hKey != NULL) {
        // then there should be something to read
        // find out the size of the required buffer
        dwStatus = RegQueryValueExW (
            hKey,
            szValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);
        if (dwStatus == ERROR_SUCCESS) {
            if ((dwBufferSize == sizeof(SLQ_TIME_INFO)) && (dwType == REG_BINARY)) {
                // then there's something to read
                dwType = 0;
                memset (&plqLocal, 0, sizeof(SLQ_TIME_INFO));
                dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)&plqLocal,
                    &dwBufferSize);

                if ( ERROR_SUCCESS == dwStatus ) {
                    *pPlqtValue = plqLocal;
                }
            } else {
                // nothing to read                
                dwStatus = ERROR_NO_DATA;
            }
        } else {
            // unable to read buffer
            // dwStatus has error
        }
    } else {
        // null key
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        LPCWSTR  szStringArray[2];
        szStringArray[0] = szValueName;
        szStringArray[1] = szQueryName;

        // apply default if it exists
        if (pPlqtDefault != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_QUERY_VALUE,
                NULL,
                2,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);

            *pPlqtValue = *pPlqtDefault;
            dwStatus = ERROR_SUCCESS;
        } 
        // else no default.
        // Leave it to the caller to log event.
    }

    return dwStatus;
}


DWORD
ReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,
    LPCWSTR  szValueName,
    PDWORD   pdwDefault,
    LPDWORD  pdwValue
)
//
//  reads the DWORD value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    DWORD   dwRegValue;

    assert (pdwValue != NULL);
    assert (szValueName != NULL);

    if (hKey != NULL) {
        // then there should be something to read
        // find out the size of the required buffer
        dwStatus = RegQueryValueExW (
            hKey,
            szValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);
        if (dwStatus == ERROR_SUCCESS) {
            if ( (dwBufferSize == sizeof(DWORD)) 
                && ( (REG_DWORD == dwType) || ( REG_BINARY == dwType) ) ) {
                // then there's something to read
                dwType = 0;
                dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwRegValue,
                    &dwBufferSize);
                if (dwStatus == ERROR_SUCCESS) {
                    *pdwValue = dwRegValue;
                }
            } else {
                // nothing to read                
                dwStatus = ERROR_NO_DATA;
            }
        } else {
            // unable to read buffer
            // dwStatus has error
        }
    } else {
        // null key
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        LPCWSTR  szStringArray[2];
        szStringArray[0] = szValueName;
        szStringArray[1] = szQueryName;

        if (pdwDefault != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_QUERY_VALUE,
                NULL,
                2,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);

            *pdwValue = *pdwDefault;
            dwStatus = ERROR_SUCCESS;
        }   // else no default.
            // Leave it to the caller to log event.
    }

    return dwStatus;
}


DWORD
ReadRegistryStringValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR   *pszBuffer,
    LPDWORD  pdwLength
)
//
//  reads the string value "szValueName" from under hKey and
//  frees any existing buffer referenced by pszBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer (in bytes) 
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    WCHAR*  szNewStringBuffer = NULL;

    assert (pdwLength!= NULL);
    assert (szValueName != NULL);

    *pdwLength = 0;

    if (hKey != NULL) {
        // then there should be something to read
        // find out the size of the required buffer
        dwStatus = RegQueryValueExW (
            hKey,
            szValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);
        if (dwStatus == ERROR_SUCCESS) {
            // NULL character size is 2 bytes
            if (dwBufferSize > 2) {
                // then there's something to read            
                szNewStringBuffer = (WCHAR*) G_ALLOC ( dwBufferSize ); // new UCHAR[dwBufferSize];
                if (szNewStringBuffer != NULL) {
                    dwType = 0;
                    dwStatus = RegQueryValueExW (
                        hKey,
                        szValueName,
                        NULL,
                        &dwType,
                        (LPBYTE)szNewStringBuffer,
                        &dwBufferSize);
                    
                    if ( 0 == lstrlenW ( szNewStringBuffer ) ) {
                        dwStatus = ERROR_NO_DATA;
                    }
                } else {
                    // Todo:  Report event for this case.
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            } else {
                // nothing to read                
                dwStatus = ERROR_NO_DATA;
            }
        } // else unable to read buffer
          // dwStatus has error
    } else {
        // null key
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        LPCWSTR  szStringArray[2];
        szStringArray[0] = szValueName;
        szStringArray[1] = szQueryName;

        if (szNewStringBuffer != NULL) {
            G_FREE ( szNewStringBuffer ); //delete (szNewStringBuffer);
            szNewStringBuffer = NULL;
            dwBufferSize = 0;
        }
        // apply default
        if (szDefault != NULL) {

            dwBufferSize = lstrlenW(szDefault) + 1;
            if ( 1 < dwBufferSize ) {
                dwBufferSize *= sizeof (WCHAR);             
            
                szNewStringBuffer = (WCHAR*) G_ALLOC ( dwBufferSize );

                if (szNewStringBuffer != NULL) {
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_QUERY_VALUE,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,      
                        (LPVOID)&dwStatus);

                    lstrcpyW (
                        szNewStringBuffer,
                        szDefault);
                    dwStatus = ERROR_SUCCESS;
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;

                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_QUERY_DEF_VAL,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,      
                        (LPVOID)&dwStatus);
                }
            }
        } // else no default so no data returned
          // Let the caller log the event if they want to.
        // Todo:  Report event for OUTOFMEMORY case.
    }

    if (dwStatus == ERROR_SUCCESS) {
        // then delete the old buffer and replace it with 
        // the new one
        if (*pszBuffer != NULL) {
            G_FREE (*pszBuffer );       //delete (*pszBuffer );
        }
        *pszBuffer = szNewStringBuffer;
        *pdwLength = dwBufferSize;
    } else {
        // if error then delete the buffer
        if (szNewStringBuffer != NULL) {
            G_FREE ( szNewStringBuffer );   //delete (szNewStringBuffer);
            *pdwLength = 0;
        }
    }

    return dwStatus;
}   
        

DWORD
ReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR*  pszBuffer,
    UINT*    puiLength )
{
    DWORD dwStatus = ERROR_SUCCESS; 
    LPCWSTR  szStringArray[2];

    szStringArray[0] = szValueName;
    szStringArray[1] = szQueryName;

    dwStatus = SmReadRegistryIndirectStringValue (
                hKey,
                szValueName,
                szDefault,       
                pszBuffer,
                puiLength );
/*
    Todo:  Report event on failure
    if ( NULL != szDefault ) {

        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            SMLOG_UNABLE_READ_QUERY_VALUE_NODEF,
            NULL,
            2,
            sizeof(DWORD),
            szStringArray,      
            (LPVOID)&dwStatus);
    }
*/
    return dwStatus;
}

DWORD
WriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  szValueName,
    LPDWORD  pdwValue,
    DWORD    dwType   
)
{
    DWORD    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);

    assert ((dwType == REG_DWORD) || 
            (dwType == REG_BINARY));
    
    dwStatus = RegSetValueEx (
        hKey, szValueName, 0L,
        dwType,
        (CONST BYTE *)pdwValue,
        dwValue);

    return dwStatus;
}


DWORD
WriteRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szValueName,
    PSLQ_TIME_INFO  pSlqTime
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(SLQ_TIME_INFO);

    dwStatus = RegSetValueEx (
        hKey, szValueName, 0L,
        REG_BINARY,
        (CONST BYTE *)pSlqTime,
        dwValue);

    return dwStatus;
}


DWORD
BuildCurrentLogFileName (
    IN  LPCTSTR     szQueryName,
    IN  LPCTSTR     szBaseFileName,
    IN  LPCTSTR     szDefaultDir,
    IN  LPCTSTR     szSqlLogName,
    IN  LPTSTR      szOutFileBuffer,
    IN  LPDWORD     lpdwSerialNumber,
    IN  DWORD       dwAutoNameFormat,
    IN  DWORD       dwLogFileType,
    IN  INT         iCnfSerial 
)
// presumes OutFileBuffer is large enough (i.e. >= MAX_PATH+1)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwStrBufLen = 0;
    DWORD dwInfoSize = 0;
    DWORD dwFlags = 0;

    dwStatus = PdhPlaGetInfo( 
       (LPTSTR)szQueryName, 
       NULL, 
       &dwInfoSize, 
       pInfo );

    if( ERROR_SUCCESS == dwStatus && 0 != dwInfoSize ){
        pInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
        if( NULL != pInfo && (sizeof(PDH_PLA_INFO) <= dwInfoSize) ){
            ZeroMemory( pInfo, dwInfoSize );

            pInfo->dwMask = PLA_INFO_FLAG_FORMAT|
                            PLA_INFO_FLAG_FILENAME|
                            PLA_INFO_FLAG_AUTOFORMAT|
                            PLA_INFO_FLAG_TYPE|
                            PLA_INFO_FLAG_DEFAULTDIR|
                            PLA_INFO_FLAG_SRLNUMBER|
                            PLA_INFO_FLAG_SQLNAME|
                            PLA_INFO_FLAG_STATUS;

            dwStatus = PdhPlaGetInfo( 
                        (LPTSTR)szQueryName, 
                        NULL, 
                        &dwInfoSize, 
                        pInfo );
            
            pInfo->dwFileFormat = dwLogFileType;
            pInfo->strBaseFileName = (LPTSTR)szBaseFileName;
            pInfo->dwAutoNameFormat = dwAutoNameFormat;
            // PLA_INFO_FLAG_TYPE is counter log vs trace log vs alert
            
            pInfo->strDefaultDir = (LPTSTR)szDefaultDir;
            pInfo->dwLogFileSerialNumber = *lpdwSerialNumber;
            pInfo->strSqlName = (LPTSTR)szSqlLogName;

            dwFlags = PLA_FILENAME_CREATEONLY;

            // iCnfSerial = 0 - No serial suffix for Create New File
            // iCnfSerial = -1 - Include format string for trace file serial number.
            if ( 0 == iCnfSerial ) {
                pInfo->ptCreateNewFile.dwAutoMode = SLQ_AUTO_MODE_NONE;
            } else {
                dwFlags |= PLA_FILENAME_USE_SUBEXT;
                if ( -1 == iCnfSerial ) {
                    dwFlags |= PLA_FILENAME_GET_SUBFMT;
                    pInfo->ptCreateNewFile.dwAutoMode = SLQ_AUTO_MODE_SIZE;
                } else {
                    pInfo->ptCreateNewFile.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                    pInfo->dwReserved1 = iCnfSerial;
                }
            }

            dwStatus = PdhPlaGetLogFileName (
                    (LPTSTR)szQueryName,
                    NULL, 
                    pInfo,
                    dwFlags,
                    &dwStrBufLen,
                    NULL );

            if ( ERROR_SUCCESS == dwStatus || PDH_INSUFFICIENT_BUFFER == dwStatus ) {
                // todo:  remove buf length restriction
                if ( dwStrBufLen <= MAX_PATH * sizeof(WCHAR) ) {
                    dwStatus = PdhPlaGetLogFileName (
                            (LPTSTR)szQueryName,
                            NULL, 
                            pInfo,
                            dwFlags,
                            &dwStrBufLen,
                            szOutFileBuffer );
                }
            }
        }
    }

    if ( NULL != pInfo ) { 
        G_FREE( pInfo );
    }

    return dwStatus;
}


BOOL
FileExists (
    IN LPCTSTR      szFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bFileExists = FALSE;
    HANDLE hFile = NULL;
    LONG lErrorMode;


    if ( NULL != szFileName ) {
        lErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

        hFile = CreateFile(
                        szFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                        NULL
                        );
        
        if (INVALID_HANDLE_VALUE == hFile ) {
            dwStatus = GetLastError();
        }

        if ( NULL != hFile 
            && INVALID_HANDLE_VALUE != hFile
            && ERROR_SUCCESS == dwStatus )
        {
            bFileExists = TRUE;
        }

        CloseHandle(hFile);
    
        SetErrorMode ( lErrorMode );
        
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return bFileExists;
}

DWORD
LoadCommonConfig(
    IN  PLOG_QUERY_DATA   pQuery)
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwBufferSize = 0;
    UINT            uiBufferLen = 0;
    SLQ_TIME_INFO   stiDefault;
    DWORD           dwDefault;
    DWORD           dwTempRestart;
    SYSTEMTIME      stLocalTime;
    FILETIME        ftLocalTime;
    DWORD           dwLocalMask = 0;
    DWORD           dwLocalAttributes = 0;

    // Schedule

    dwDefault = SLQ_QUERY_STOPPED;
    dwStatus = ReadRegistryDwordValue (
                pQuery->hKeyQuery, 
                pQuery->szQueryName,
                (LPCTSTR)L"Current State",
                &dwDefault, 
                &pQuery->dwCurrentState);


    if ( ERROR_SUCCESS == dwStatus ) {
        // Pass NULL default to avoid warning message.
        // A missing value here is normal, converting from Win2000 config.
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"RealTime DataSource",
                    NULL, 
                    &pQuery->dwRealTimeQuery);

        if ( ERROR_NO_DATA == dwStatus 
                || ERROR_FILE_NOT_FOUND == dwStatus
                || ( 0 == pQuery->dwRealTimeQuery ) ) {
            
            pQuery->dwRealTimeQuery = GetSystemWideDefaultNullDataSource();
            dwStatus = ERROR_SUCCESS;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        GetLocalTime (&stLocalTime);
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
        stiDefault.wTimeType = SLQ_TT_TTYPE_START;
        stiDefault.dwAutoMode = SLQ_AUTO_MODE_AT;
        stiDefault.llDateTime = *(LONGLONG *)&ftLocalTime;

        dwStatus = ReadRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"Start",
                    &stiDefault,
                    &pQuery->stiRegStart);
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
        stiDefault.wTimeType = SLQ_TT_TTYPE_STOP;
        stiDefault.dwAutoMode = SLQ_AUTO_MODE_NONE;
        stiDefault.llDateTime = MIN_TIME_VALUE;

        dwStatus = ReadRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"Stop",
                    &stiDefault,
                    &pQuery->stiRegStop);
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // Apply default value outside of Read method, to avoid
        // error message.  This value does not exist in Windows 2000
        dwStatus = ReadRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"Create New File",
                    NULL,
                    &pQuery->stiCreateNewFile);

        if ( ERROR_NO_DATA == dwStatus || ERROR_FILE_NOT_FOUND == dwStatus ) {
            stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
            stiDefault.wTimeType = SLQ_TT_TTYPE_CREATE_NEW_FILE;
            stiDefault.dwAutoMode = SLQ_AUTO_MODE_NONE;
            stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
            stiDefault.dwValue = 0;

            pQuery->stiCreateNewFile = stiDefault;

            dwStatus = ERROR_SUCCESS;
        }
    }
    
    // Restart flag is replaced by the Repeat time structure after Windows 2000.
    if ( ERROR_SUCCESS == dwStatus ) {
        // If autostop, collect Restart value.
        // Apply default value outside of Read method, to avoid
        // error message.  This value does not exist in Windows 2000
        if ( pQuery->stiRegStop.dwAutoMode != SLQ_AUTO_MODE_NONE ) {

            dwStatus = ReadRegistryDwordValue (
                        pQuery->hKeyQuery, 
                        pQuery->szQueryName,
                        (LPCTSTR)L"Restart",
                        NULL, 
                        &dwTempRestart );
            if ( ERROR_NO_DATA == dwStatus 
                || ERROR_FILE_NOT_FOUND == dwStatus ) 
            {
                dwTempRestart = SLQ_AUTO_MODE_NONE;
                dwStatus = ERROR_SUCCESS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // If autostop, collect Repeat value.

        // Apply default value outside of Read method, to avoid
        // error message.  This value does not exist in Windows 2000

        if ( pQuery->stiRegStop.dwAutoMode != SLQ_AUTO_MODE_NONE ) {

            dwStatus = ReadRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        pQuery->szQueryName,
                        (LPCTSTR)L"Repeat Schedule",
                        NULL, 
                        &pQuery->stiRepeat );
    
            if ( ERROR_NO_DATA == dwStatus 
                    || ERROR_FILE_NOT_FOUND == dwStatus
                    || SLQ_AUTO_MODE_NONE == pQuery->stiRepeat.dwAutoMode ) 
            {    
                // If the repeat value doesn't exist or is set to NONE,
                // default to the Restart mode value: NONE or AFTER

                stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
                stiDefault.wTimeType = SLQ_TT_TTYPE_REPEAT_SCHEDULE;

                stiDefault.dwAutoMode = dwTempRestart;
                stiDefault.dwUnitType = SLQ_TT_UTYPE_MINUTES;
                stiDefault.dwValue = 0;
                
                pQuery->stiRepeat = stiDefault;

                dwStatus = ERROR_SUCCESS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // Todo:  Log error events

        if ( NULL == pQuery->szLogFileComment ) {
            uiBufferLen = 0;
        } else {
            uiBufferLen = lstrlen ( pQuery->szLogFileComment ) + 1;
        }

        ReadRegistryIndirectStringValue (
            pQuery->hKeyQuery,
            pQuery->szQueryName,
            (LPCWSTR)L"Comment",
            NULL,       
            &pQuery->szLogFileComment,
            &uiBufferLen );
        
        // Ignore status, default is empty.
    }
// Todo:  File attributes only for counter and trace logs   
    // File attributes
    
    if ( ERROR_SUCCESS == dwStatus ) {

        dwDefault = (DWORD)-1;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    (LPCTSTR)L"Log File Max Size",
                    &dwDefault, 
                    &pQuery->dwMaxFileSize);    
    }


    if ( ERROR_SUCCESS == dwStatus ) {

        dwDefault = SLF_BIN_FILE; 
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"Log File Type",
                    &dwDefault, 
                    &pQuery->dwLogFileType);
        if (dwStatus == ERROR_SUCCESS) {
            pQuery->dwLogFileType = LOWORD(pQuery->dwLogFileType);

            // For Whistler Beta 1, append mode stored in high word of 
            // the log type registry value
            pQuery->dwAppendMode  =
                    (pQuery->dwLogFileType & 0xFFFF0000) == SLF_FILE_APPEND;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        // Pass NULL default to avoid warning message.
        // A missing value here is normal, converting from Win2000 config.
        dwLocalAttributes = 0;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    (LPCTSTR)L"Data Store Attributes",
                    NULL, 
                    &dwLocalAttributes );

        // Extract log file size units
        if ( ERROR_NO_DATA == dwStatus 
                || ERROR_FILE_NOT_FOUND == dwStatus
                || ( 0 == ( dwLocalAttributes & SLF_DATA_STORE_SIZE_MASK ) ) ) {
            // If file size unit value is missing, default to Win2000 values
            if ( SLQ_COUNTER_LOG == pQuery->dwLogType ) {
                if ( SLF_SQL_LOG != pQuery->dwLogFileType ) {
                    pQuery->dwLogFileSizeUnit = ONE_KB;
                } else {
                    pQuery->dwLogFileSizeUnit = ONE_RECORD;
                }
            } else if ( SLQ_TRACE_LOG == pQuery->dwLogType ) {
                pQuery->dwLogFileSizeUnit = ONE_MB;
            }
        } else {
            if ( dwLocalAttributes & SLF_DATA_STORE_SIZE_ONE_MB ) {
                pQuery->dwLogFileSizeUnit = ONE_MB;
            } else if ( dwLocalAttributes & SLF_DATA_STORE_SIZE_ONE_KB ) {
                pQuery->dwLogFileSizeUnit = ONE_KB;
            } else if ( dwLocalAttributes & SLF_DATA_STORE_SIZE_ONE_RECORD ) {
                pQuery->dwLogFileSizeUnit = ONE_RECORD;
            }
        }

        // Extract append flag if not already set by Whistler Beta 1 code
        if ( 0 == pQuery->dwAppendMode ) {
            if ( ERROR_NO_DATA == dwStatus 
                    || ERROR_FILE_NOT_FOUND == dwStatus
                    || ( 0 == ( dwLocalAttributes & SLF_DATA_STORE_APPEND_MASK ) ) ) 
            {
                // If file append mode value is missing, default to Win2000 values
                assert ( SLF_SQL_LOG != pQuery->dwLogFileType );
                if ( SLF_SQL_LOG != pQuery->dwLogFileType ) {
                    pQuery->dwAppendMode = 0;
                }
            } else {
                pQuery->dwAppendMode = ( dwLocalAttributes & SLF_DATA_STORE_APPEND );
            }
        }
        dwStatus = ERROR_SUCCESS;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwDefault = SLF_NAME_NNNNNN;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"Log File Auto Format",
                    &dwDefault, 
                    &pQuery->dwAutoNameFormat );
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        WCHAR   szDefault[MAX_PATH+1];

        // Dependent on AutoNameFormat setting.

        if ( SLF_NAME_NONE == pQuery->dwAutoNameFormat ) {
            // Default log file name is query name, if no autoformat.
            lstrcpyW ( ( LPWSTR)szDefault, pQuery->szQueryName );
        } else {
            szDefault[0] = _T('\0');
        }
        
        if ( NULL == pQuery->szBaseFileName ) {
            uiBufferLen = 0;
        } else {
            uiBufferLen = lstrlen ( pQuery->szBaseFileName ) + 1;
        }

        ReadRegistryIndirectStringValue (
            pQuery->hKeyQuery,
            pQuery->szQueryName,
            (LPCWSTR)L"Log File Base Name",
            szDefault,                      
            &pQuery->szBaseFileName,
            &uiBufferLen );

        ReplaceBlanksWithUnderscores ( pQuery->szBaseFileName );

        if ( 0 == lstrlen (szDefault) ) {
            if ( NULL != pQuery->szBaseFileName ) {
                if ( 0 == lstrlen ( pQuery->szBaseFileName ) ) {
                    // Ignore bad status if the base log file name 
                    //is NULL and auto format is enabled.
                    dwStatus = ERROR_SUCCESS;
                }
            } else {
                // Ignore bad status if the base log file name 
                //is NULL and auto format is enabled.
                dwStatus = ERROR_SUCCESS;
           }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        TCHAR*  pszTemp = NULL;
        DWORD   cchLen = 0;
        DWORD   cchExpandedLen = 0;


        dwStatus = ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    (LPCTSTR)L"Log File Folder",
                    gszDefaultLogFileFolder,
                    &pszTemp,
                    &dwBufferSize );

        //    
        // Parse all environment variables
        //
        if (pszTemp != NULL) {
            cchLen = ExpandEnvironmentStrings ( pszTemp, NULL, 0 );
        
            if ( 0 < cchLen ) {
                //
                // cchLen includes NULL.
                //
                if ( NULL != pQuery->szLogFileFolder ) {
                    G_FREE (pQuery->szLogFileFolder );
                    pQuery->szLogFileFolder = NULL;
                }
                pQuery->szLogFileFolder = G_ALLOC ( cchLen * sizeof(WCHAR) );

                if ( NULL != pQuery->szLogFileFolder ) {

                    cchExpandedLen = ExpandEnvironmentStrings ( 
                                        pszTemp, 
                                        pQuery->szLogFileFolder, 
                                        cchLen );

                    if ( 0 == cchExpandedLen ) {
                        dwStatus = GetLastError();
                        pQuery->szLogFileFolder[0] = L'\0';
                    }
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            } else {
                dwStatus = GetLastError();
            }
        }
    
        if ( NULL != pszTemp ) {
            G_FREE ( pszTemp );
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    (LPCTSTR)L"Sql Log Base Name",
                    NULL,
                    &pQuery->szSqlLogName,
                    &dwBufferSize );
        // Ignore status, default is empty.
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwDefault = 1;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    (LPCTSTR)L"Log File Serial Number",
                    &dwDefault, 
                    &pQuery->dwCurrentSerialNumber );
    
    }

    return dwStatus;
}


DWORD
LoadQueryConfig(
    IN  PLOG_QUERY_DATA   pQuery )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwBufferSize;
    UINT            uiBufferLen = 0;
    LPTSTR          szStringArray[2];
    SLQ_TIME_INFO   stiDefault;
    SLQ_TIME_INFO   stiTemp;
    DWORD           dwDefault;
    DWORD           dwType;

    // Do not write event for invalid log type.
    
    dwType = REG_DWORD;
    dwBufferSize = sizeof(DWORD);
    dwStatus = RegQueryValueExW (
            pQuery->hKeyQuery,
            (LPCTSTR)L"Log Type",
            NULL,
            &dwType,
            (LPBYTE)&pQuery->dwLogType,
            &dwBufferSize);

    if ( SLQ_COUNTER_LOG == pQuery->dwLogType ) {

        // Counters

        dwStatus = ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    (LPCTSTR)L"Counter List", 
                    NULL,
                    &pQuery->mszCounterList,
                    &dwBufferSize );

        if ( (ERROR_SUCCESS != dwStatus ) || ( 0 == dwBufferSize ) ) {
            // no counter list retrieved so there's not much
            // point in continuing
            szStringArray[0] = pQuery->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_COUNTER_LIST,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);
        } else {
            // Schedule

            // Collect Command file value.

            if ( ERROR_SUCCESS == dwStatus ) {
                ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"EOF Command File",
                            NULL,
                            &pQuery->szCmdFileName,
                            &dwBufferSize );
                // Ignore status, default is empty.
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
                stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
                stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
                stiDefault.dwValue = 15;

                dwStatus = ReadRegistrySlqTime (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"Sample Interval",
                            &stiDefault, 
                            &stiTemp);
                if ( ERROR_SUCCESS == dwStatus ) {
                    LONGLONG llMillisecInterval;
                    TimeInfoToMilliseconds( &stiTemp, &llMillisecInterval );
                    assert ( ULONG_MAX > llMillisecInterval );
                    if ( ULONG_MAX > llMillisecInterval ) {
                        pQuery->dwMillisecondSampleInterval = (DWORD)(llMillisecInterval);
                    } else {
                        pQuery->dwMillisecondSampleInterval = ULONG_MAX - 1;
                    }
                }
            }
        }
    } else if ( SLQ_ALERT == pQuery->dwLogType) {
        // Counters & alert limits

        dwStatus = ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    (LPCTSTR)L"Counter List", 
                    NULL,
                    &pQuery->mszCounterList,
                    &dwBufferSize );

        if ( (ERROR_SUCCESS != dwStatus ) || ( 0 == dwBufferSize ) ) {
            // no counter list retrieved so there's not much
            // point in continuing
            szStringArray[0] = pQuery->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_COUNTER_LIST,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);
        } else {
            // Schedule
            if ( ERROR_SUCCESS == dwStatus ) {
                stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
                stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
                stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
                stiDefault.dwValue = 15;

                dwStatus = ReadRegistrySlqTime (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"Sample Interval",
                            &stiDefault, 
                            &stiTemp);
                if ( ERROR_SUCCESS == dwStatus ) {
                    LONGLONG llMillisecInterval;
                    TimeInfoToMilliseconds( &stiTemp, &llMillisecInterval );
                    assert ( ULONG_MAX > llMillisecInterval );
                    if ( ULONG_MAX > llMillisecInterval ) {
                        pQuery->dwMillisecondSampleInterval = (DWORD)(llMillisecInterval);
                    } else {
                        pQuery->dwMillisecondSampleInterval = ULONG_MAX - 1;
                    }
                }
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                // get action flags
                dwDefault = 0;
                dwStatus = ReadRegistryDwordValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"Action Flags",
                            &dwDefault, 
                            &pQuery->dwAlertActionFlags);
            }

            if (( ERROR_SUCCESS == dwStatus ) && 
                ((pQuery->dwAlertActionFlags & ALRT_ACTION_SEND_MSG) != 0)) {
                dwStatus = ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"Network Name",
                            (LPCTSTR)L"",
                            &pQuery->szNetName,
                            &dwBufferSize );
            }

            if (( ERROR_SUCCESS == dwStatus ) && 
                ((pQuery->dwAlertActionFlags & ALRT_ACTION_EXEC_CMD) != 0)) {
                ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"Command File",
                            NULL,
                            &pQuery->szCmdFileName,
                            &dwBufferSize );

                if (( ERROR_SUCCESS == dwStatus ) && 
                    ((pQuery->dwAlertActionFlags & ALRT_CMD_LINE_U_TEXT) != 0)) {

                    // Todo:  Log error events

                    if ( NULL == pQuery->szUserText ) {
                        uiBufferLen = 0;
                    } else {
                        uiBufferLen = lstrlen ( pQuery->szUserText ) + 1;
                    }

                    ReadRegistryIndirectStringValue (
                                pQuery->hKeyQuery,
                                pQuery->szQueryName,
                                (LPCTSTR)L"User Text",
                                (LPCTSTR)L"",
                                &pQuery->szUserText,
                                &uiBufferLen );

                    // Ignore status, default is empty.
                }
            }

            if (( ERROR_SUCCESS == dwStatus ) && 
                ((pQuery->dwAlertActionFlags & ALRT_ACTION_START_LOG) != 0)) {
                dwStatus = ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            (LPCTSTR)L"Perf Log Name",
                            (LPCTSTR)L"",
                            &pQuery->szPerfLogName,
                            &dwBufferSize );
            }
        }
    } else if ( SLQ_TRACE_LOG == pQuery->dwLogType ) {

        // get trace log values
        DWORD dwProviderStatus;
        
        dwDefault = 0;
        dwStatus = ReadRegistryDwordValue (
            pQuery->hKeyQuery,
            pQuery->szQueryName,
            (LPCTSTR)L"Trace Flags",
            &dwDefault, 
            &pQuery->dwFlags);

        dwProviderStatus = ReadRegistryStringValue (
                pQuery->hKeyQuery,
                pQuery->szQueryName,
                (LPCTSTR)L"Trace Provider List", 
                NULL,
                &pQuery->mszProviderList,
                &dwBufferSize );

        if ( 0 == dwBufferSize ) {
            if ( (ERROR_SUCCESS != dwProviderStatus ) 
                && ( ! IsKernelTraceMode( pQuery->dwFlags ) ) ) {
                // No provider list retrieved and not kernel trace so there's not much
                // point in continuing
                if ( ERROR_SUCCESS == dwStatus ) {
                    dwStatus = SMLOG_UNABLE_READ_PROVIDER_LIST;
                }
                szStringArray[0] = pQuery->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_READ_PROVIDER_LIST,
                    NULL,
                    1,
                    sizeof(DWORD),
                    szStringArray,      
                    (LPVOID)&dwStatus);
            } else {
                // Allocate a minimal buffer for the NULL character to simplify later logic.
                pQuery->mszProviderList = G_ALLOC ( sizeof(TCHAR) );
                if ( NULL != pQuery->mszProviderList ) {
                    pQuery->mszProviderList[0] = _T('\0');
                } else{
                    dwStatus = ERROR_OUTOFMEMORY;
                    szStringArray[0] = pQuery->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_PROVIDER_LIST,
                        NULL,
                        1,
                        sizeof(DWORD),
                        szStringArray,      
                        (LPVOID)&dwStatus);
                }
            }
        }
        
        if ( ERROR_SUCCESS == dwStatus ) {

            dwDefault = 4;
            dwStatus = ReadRegistryDwordValue (
                pQuery->hKeyQuery,
                pQuery->szQueryName,
                (LPCTSTR)L"Trace Buffer Size",
                &dwDefault, 
                &pQuery->dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDefault = 2;
            dwStatus = ReadRegistryDwordValue (
                pQuery->hKeyQuery,
                pQuery->szQueryName,
                (LPCTSTR)L"Trace Buffer Min Count",
                &dwDefault, 
                &pQuery->dwBufferMinCount);
        }

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDefault = 25;
            dwStatus = ReadRegistryDwordValue (
                pQuery->hKeyQuery,
                pQuery->szQueryName,
                (LPCTSTR)L"Trace Buffer Max Count",
                &dwDefault, 
                &pQuery->dwBufferMaxCount);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            
            dwDefault = 0;
            dwStatus = ReadRegistryDwordValue (
                pQuery->hKeyQuery,
                pQuery->szQueryName,
                (LPCTSTR)L"Trace Buffer Flush Interval",
                &dwDefault, 
                &pQuery->dwBufferFlushInterval);
        }
        // Schedule

        // Collect Command file value.
        // This is true for both Counter and Trace log files.
        // Alerts use the Command file field for Alert command file.

        if ( ERROR_SUCCESS == dwStatus ) {
            ReadRegistryStringValue (
                        pQuery->hKeyQuery,
                        pQuery->szQueryName,
                        (LPCTSTR)L"EOF Command File",
                        NULL,
                        &pQuery->szCmdFileName,
                        &dwBufferSize );
            // Ignore status, default is empty.
        }
    } else {
        // Ignore partly created logs and alerts.
        assert ( SLQ_NEW_LOG == pQuery->dwLogType );
        if ( SLQ_NEW_LOG == pQuery->dwLogType ) {
            dwStatus = SMLOG_LOG_TYPE_NEW;
        } else {
            dwStatus = SMLOG_INVALID_LOG_TYPE;

            szStringArray[0] = pQuery->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_INVALID_LOG_TYPE,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&pQuery->dwLogType);
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = LoadCommonConfig ( pQuery );
    }

    return dwStatus;
}

void 
LockQueryData ( void )
{
    EnterCriticalSection ( &QueryDataLock );
}

void 
UnlockQueryData ( void )
{
    LeaveCriticalSection ( &QueryDataLock );
}

void 
EnterConfigure ( void )
{
    EnterCriticalSection ( &QueryDataLock );
}

void 
ExitConfigure ( void )
{
    LeaveCriticalSection ( &QueryDataLock );
}

PLOG_QUERY_DATA
GetQueryData (
    LPCTSTR  szQueryName )
{
    PLOG_QUERY_DATA pQuery;

    LockQueryData();

    pQuery = pFirstQuery;

    while ( NULL != pQuery ) {
        if ( !lstrcmpi(pQuery->szQueryName, szQueryName ) ) {
            // If the exit event isn't set, then this query is still active.
            if ((WaitForSingleObject (pQuery->hExitEvent, 0)) != WAIT_OBJECT_0) {
                break;
            } 
#if _DEBUG_OUTPUT
            else {
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Exit event is set\n", pQuery->szQueryName);
    OutputDebugString (szDebugString);
}
            }
#endif
        }
        pQuery = pQuery->next;
    }

    UnlockQueryData();

    return pQuery;
}


PLOG_QUERY_DATA 
GetQueryDataPtr (
    HANDLE hThisQuery
)
{
    PLOG_QUERY_DATA pQuery = NULL;
    LockQueryData();
    
    // Find the query data block in the list.

    if ( hThisQuery == pFirstQuery->hThread ) {
        pQuery = pFirstQuery;
    }

    if ( NULL == pQuery ) {

        for ( pQuery = pFirstQuery;
            NULL != pQuery->next;
            pQuery = pQuery->next ) {

            if ( hThisQuery == pQuery->next->hThread ) {
                pQuery = pQuery->next;
                break;
            }
        }
    }

    UnlockQueryData();
    return pQuery;
}


void 
DeallocateQueryBuffers (
    IN PLOG_QUERY_DATA pQuery )
{
    // Deallocate the buffers that can be deleted when the collection
    // thread is reconfigured.
    if (( SLQ_COUNTER_LOG == pQuery->dwLogType ) ||
        ( SLQ_ALERT == pQuery->dwLogType)) {

        if (pQuery->mszCounterList != NULL) {
            G_FREE(pQuery->mszCounterList);
            pQuery->mszCounterList = NULL;
        }
    }

    if ( SLQ_ALERT == pQuery->dwLogType) {
        if (pQuery->szNetName != NULL) {
            G_FREE(pQuery->szNetName);
            pQuery->szNetName = NULL;
        }

        if (pQuery->szPerfLogName != NULL) {
            G_FREE(pQuery->szPerfLogName);
            pQuery->szPerfLogName = NULL;
        }

        if (pQuery->szUserText != NULL) {
            G_FREE (pQuery->szUserText);
            pQuery->szUserText = NULL;
        }
    }

    if ( SLQ_TRACE_LOG == pQuery->dwLogType) {
        if (pQuery->mszProviderList != NULL) {
            G_FREE(pQuery->mszProviderList);
            pQuery->mszProviderList = NULL;
        }
    }

    if (pQuery->szLogFileComment != NULL) {
        G_FREE(pQuery->szLogFileComment);
        pQuery->szLogFileComment = NULL;
    }

    if (pQuery->szBaseFileName != NULL) {
        G_FREE(pQuery->szBaseFileName);
        pQuery->szBaseFileName = NULL;
    }

    if (pQuery->szLogFileFolder != NULL) {
        G_FREE(pQuery->szLogFileFolder);
        pQuery->szLogFileFolder = NULL;
    }

    if (pQuery->szSqlLogName != NULL) {
        G_FREE(pQuery->szSqlLogName);
        pQuery->szSqlLogName = NULL;
    }

    if (pQuery->szCmdFileName != NULL) {
        G_FREE(pQuery->szCmdFileName);
        pQuery->szCmdFileName = NULL;
    }
}


void 
ClearTraceProperties (
    IN PLOG_QUERY_DATA pQuery )
{
#if _IMPLEMENT_WMI
    G_ZERO (& pQuery->Properties, sizeof(EVENT_TRACE_PROPERTIES));
    G_ZERO (pQuery->szLoggerName, sizeof(pQuery->szLoggerName));
    G_ZERO (pQuery->szLogFileName, sizeof(pQuery->szLogFileName));

    if ( NULL != pQuery->arrpGuid ) {
        ULONG ulIndex;
        
        for ( ulIndex = 0; ulIndex < pQuery->ulGuidCount; ulIndex++ ) {
            if ( NULL != pQuery->arrpGuid[ulIndex] ) {
                G_FREE ( pQuery->arrpGuid[ulIndex] );
                pQuery->arrpGuid[ulIndex] = NULL;
            }
            if ( NULL != pQuery->arrpszProviderName[ulIndex] ) {
                G_FREE ( pQuery->arrpszProviderName[ulIndex] );
                pQuery->arrpszProviderName[ulIndex] = NULL;
            }
        }

        G_FREE ( pQuery->arrpGuid );
        pQuery->arrpGuid = NULL;

        if ( NULL != pQuery->arrpszProviderName ) {
            G_FREE ( pQuery->arrpszProviderName );
            pQuery->arrpszProviderName = NULL;
        }
    }

    pQuery->ulGuidCount = 0;

    pQuery->Properties.LoggerNameOffset  = sizeof(EVENT_TRACE_PROPERTIES);
    pQuery->Properties.LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                         + sizeof(pQuery->szLoggerName);
#endif
}


DWORD
LoadPdhLogUpdateSuccess ( void )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hKeySysmonLog = NULL;

    dwStatus = RegOpenKeyEx (
        (HKEY)HKEY_LOCAL_MACHINE,
        (LPCTSTR)TEXT("SYSTEM\\CurrentControlSet\\Services\\SysmonLog"),
        0L,
        KEY_READ,
        (PHKEY)&hKeySysmonLog);

    if (dwStatus == ERROR_SUCCESS) {
        TCHAR*  mszStatusList = NULL;
        DWORD   dwBufferSize = 0;
        DWORD   dwType = 0;
        
        // find out the size of the required buffer
        dwStatus = RegQueryValueExW (
            hKeySysmonLog,
            (LPCTSTR)_T("PdhDataCollectSuccessStatus"), 
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);         // In bytes

        // If there is something to read 
        if ( (ERROR_SUCCESS == dwStatus ) && ( 0 < dwBufferSize ) ) {
            mszStatusList = G_ALLOC ( dwBufferSize ); 

            if ( NULL != mszStatusList ) {
                mszStatusList[0] = _T('\0');
                dwType = 0;
                dwStatus = RegQueryValueExW (
                    hKeySysmonLog,
                    (LPCTSTR)_T("PdhDataCollectSuccessStatus"),
                    NULL,
                    &dwType,
                    (UCHAR*)mszStatusList,
                    &dwBufferSize);

                if ( (ERROR_SUCCESS == dwStatus ) 
                        && ( 0 < dwBufferSize ) 
                        && ( _T('\0') != mszStatusList[0] ) ) {

                    // Allocate and load Pdh data collection status value array.
                    INT     iStatusCount = 0;
                    TCHAR*  szThisStatus;

                    for (szThisStatus = mszStatusList;
                            *szThisStatus != 0;
                            szThisStatus += lstrlen(szThisStatus) + 1) {
                        iStatusCount++;
                    }
                    
                    arrPdhDataCollectSuccess = G_ALLOC ( iStatusCount * sizeof ( DWORD ) );
                    
                    if ( NULL != arrPdhDataCollectSuccess ) {
                        INT iStatusIndex;

                        szThisStatus = mszStatusList;
                        for ( iStatusIndex = 0; iStatusIndex < iStatusCount; iStatusIndex++ ) {
                            if (0 != *szThisStatus ) {
                                arrPdhDataCollectSuccess[iStatusIndex] = (DWORD)_ttoi( szThisStatus );
                                szThisStatus += lstrlen(szThisStatus) + 1;
                            } else {
                                break;
                            }
                        }
                    }
                    
                    iPdhDataCollectSuccessCount = iStatusCount;
                }
                if ( NULL != mszStatusList ) {
                    G_FREE ( mszStatusList );
                }
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
    } 

    return dwStatus;
}

DWORD
InitTraceGuids(
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD   dwStatus = ERROR_SUCCESS;

#if _IMPLEMENT_WMI
    LPTSTR  pszThisGuid;
    LONG   ulGuidIndex;
    LONG   ulpszGuidIndex;
    LONG   ulGuidCount = 0;
    LPGUID*  arrpGuid = NULL;
    PTCHAR*  arrpszGuid = NULL;
    WCHAR   pszThisGuidBuffer[64];
    UNICODE_STRING ustrGuid;

    if ( NULL != pQuery ) {
        if ( NULL != pQuery->mszProviderList ) {
            for (pszThisGuid = pQuery->mszProviderList;
                    *pszThisGuid != 0;
                    pszThisGuid += lstrlen(pszThisGuid) + 1) {
                ulGuidCount += 1;
                if ( NULL == pszThisGuid ) {
                    dwStatus = ERROR_INVALID_PARAMETER;
                    break;
                }
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            arrpGuid = G_ALLOC ( ulGuidCount * sizeof ( LPGUID ) );
            if (NULL == arrpGuid) {
                dwStatus = ERROR_OUTOFMEMORY;
            } else {
                G_ZERO ( arrpGuid, ulGuidCount * sizeof ( LPGUID ) );
                for ( ulGuidIndex = 0; ulGuidIndex < ulGuidCount; ulGuidIndex++) {
                    arrpGuid[ulGuidIndex] = G_ALLOC ( sizeof(GUID) );
                    if (NULL == arrpGuid[ulGuidIndex]) {
                        dwStatus = ERROR_OUTOFMEMORY;
                        break;
                    }
                }
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            // Create an array of pointers to individual provider Guids in the
            // mszProviderList.  The provider Guids are used as provider
            // names in error messages, and for comparison with provider list
            arrpszGuid = G_ALLOC ( ulGuidCount * sizeof ( TCHAR* ) );
            if (NULL == arrpszGuid) {
                dwStatus = ERROR_OUTOFMEMORY;
            } else {
                G_ZERO ( arrpszGuid, ulGuidCount * sizeof ( TCHAR* ) );

                for ( ulpszGuidIndex = 0; ulpszGuidIndex < ulGuidCount; ulpszGuidIndex++) {
                    arrpszGuid[ulpszGuidIndex] = G_ALLOC ( sizeof(TCHAR[MAX_PATH]) );
                    if (NULL == arrpszGuid[ulpszGuidIndex]) {
                        dwStatus = ERROR_OUTOFMEMORY;
                        break;
                    }
                }
            }

            if (ERROR_SUCCESS == dwStatus) {
                ulGuidIndex = 0;
                for (pszThisGuid = pQuery->mszProviderList;
                        *pszThisGuid != 0;
                        pszThisGuid += lstrlen(pszThisGuid) + 1) {

                    lstrcpyW ((LPWSTR)pszThisGuidBuffer, pszThisGuid);
        
                    ustrGuid.Length = (USHORT)(lstrlen(pszThisGuidBuffer)*sizeof(TCHAR)); // Size of GUID length << USHORT
                    ustrGuid.MaximumLength = sizeof (pszThisGuidBuffer);
                    ustrGuid.Buffer = pszThisGuidBuffer;
        
                    dwStatus = GUIDFromString (&ustrGuid, arrpGuid[ulGuidIndex] );

                    lstrcpy ( arrpszGuid[ulGuidIndex], pszThisGuid );
        
                    ulGuidIndex++;
                }
        
                pQuery->ulGuidCount = ulGuidCount;
                pQuery->arrpGuid = arrpGuid;
                pQuery->arrpszProviderName = arrpszGuid;
            }
        }

        if (ERROR_SUCCESS != dwStatus) {
            // If failure anywhere, deallocate arrays
            if ( NULL != arrpszGuid ) {
                for (ulpszGuidIndex--; ulpszGuidIndex>=0; ulpszGuidIndex--) {
                    G_FREE(arrpszGuid[ulpszGuidIndex]);
                }
                G_FREE(arrpszGuid);
            }
            if (NULL != arrpGuid) {
                for (ulGuidIndex--; ulGuidIndex>=0; ulGuidIndex--) {
                    G_FREE(arrpGuid[ulGuidIndex]);
                }
                G_FREE(arrpGuid);
            }
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
#else 
        dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
#endif
    return dwStatus;
}


DWORD
IsCreateNewFile (
    IN  PLOG_QUERY_DATA pQuery,
    OUT BOOL*   pbValidBySize,
    OUT BOOL*   pbValidByTime )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bLocalValidBySize = FALSE;
    BOOL    bLocalValidByTime = FALSE;


    if (  ( NULL != pQuery ) ) {
        if ( SLQ_AUTO_MODE_SIZE == pQuery->stiCreateNewFile.dwAutoMode ) {

            if ( ( SLF_SEQ_TRACE_FILE == pQuery->dwLogFileType )
                && ( -1 != pQuery->dwMaxFileSize )
                && ( 0 != pQuery->dwMaxFileSize ) ) 
            {
                bLocalValidBySize = TRUE;
            }
        } else if ( SLQ_AUTO_MODE_AFTER == pQuery->stiCreateNewFile.dwAutoMode ) {
            bLocalValidByTime = TRUE;
        }
        if  ( NULL != pbValidBySize ) {
            *pbValidBySize = bLocalValidBySize;
        }
        if  ( NULL != pbValidByTime ) {
            *pbValidByTime = bLocalValidByTime;
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }
        
    return dwStatus;
}


void 
InitTraceProperties (
    IN PLOG_QUERY_DATA pQuery,
    IN BOOL     bUpdateSerial,
    IN OUT DWORD*  pdwSessionSerial,
    IN OUT INT* piCnfSerial )
{
#if _IMPLEMENT_WMI

    HRESULT hr;
    DWORD   dwStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD   dwInfoSize = 0;
    BOOL    bBySize = FALSE;
    BOOL    bByTime = FALSE;
    INT     iLocalCnfSerial;
    DWORD   dwLocalSessionSerial = 0;       // Init for Prefix check
    BOOL    bFileExists;

    if ( NULL != pQuery && NULL != piCnfSerial ) {

        hr = PdhPlaGetInfoW( pQuery->szQueryName, NULL, &dwInfoSize, pInfo );
        if( ERROR_SUCCESS == hr && 0 != dwInfoSize ) {
            pInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
            if( NULL != pInfo && (sizeof(PDH_PLA_INFO) <= dwInfoSize) ){
                ZeroMemory( pInfo, dwInfoSize );

                pInfo->dwMask = PLA_INFO_FLAG_MODE|PLA_INFO_FLAG_LOGGERNAME;
                hr = PdhPlaGetInfoW( pQuery->szQueryName, NULL, &dwInfoSize, pInfo );
            }
        }
    
        ClearTraceProperties ( pQuery );
    
        dwStatus = IsCreateNewFile ( pQuery, &bBySize, &bByTime );

        // Create format string, store it in pQuery->szLogFileName

        if ( bBySize ) {
            // In BuildCurrentLogFileName, iCnfSerial of -1 signals code to
            // return the format string for cnf serial number
            iLocalCnfSerial = -1;
        } else {
            if ( bByTime ) {
                *piCnfSerial += 1;
                iLocalCnfSerial = *piCnfSerial;
            } else {
                iLocalCnfSerial = 0;
            }
        }
    
        if ( NULL != pdwSessionSerial ) {
            dwLocalSessionSerial = *pdwSessionSerial;
        } else {        
            dwLocalSessionSerial = pQuery->dwCurrentSerialNumber;
        }

        dwStatus = BuildCurrentLogFileName (
                        pQuery->szQueryName,
                        pQuery->szBaseFileName,
                        pQuery->szLogFileFolder,
                        pQuery->szSqlLogName,
                        pQuery->szLogFileName,
                        &dwLocalSessionSerial,
                        pQuery->dwAutoNameFormat,
                        pQuery->dwLogFileType,
                        iLocalCnfSerial );

        RegisterCurrentFile( pQuery->hKeyQuery, pQuery->szLogFileName, iLocalCnfSerial );

        // Update log serial number if modified.
        if ( bUpdateSerial && SLF_NAME_NNNNNN == pQuery->dwAutoNameFormat ) {
        
            pQuery->dwCurrentSerialNumber++;

            // Todo:  Info event on number wrap - Server Beta 3.
            if ( MAXIMUM_SERIAL_NUMBER < pQuery->dwCurrentSerialNumber ) {
                pQuery->dwCurrentSerialNumber = MINIMUM_SERIAL_NUMBER;
            }

            WriteRegistryDwordValue (
                pQuery->hKeyQuery,
                (LPCTSTR)L"Log File Serial Number",
                &pQuery->dwCurrentSerialNumber,
                REG_DWORD);
            // Todo: log event on error.
        }

        pQuery->Properties.Wnode.BufferSize = sizeof(pQuery->Properties)
                                            + sizeof(pQuery->szLoggerName)
                                            + sizeof(pQuery->szLogFileName);

        if ( TRUE == bBySize ) {
            // Add room for trace code to to return formatted filename string.
            pQuery->Properties.Wnode.BufferSize += 8;
        }
    
        pQuery->Properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

        // Fill out properties block and start.
        pQuery->Properties.BufferSize = pQuery->dwBufferSize;
        pQuery->Properties.MinimumBuffers = pQuery->dwBufferMinCount;
        pQuery->Properties.MaximumBuffers = pQuery->dwBufferMaxCount;

        if ( pInfo ) {
            if ( pInfo->Trace.strLoggerName != NULL ) {
                lstrcpy ( pQuery->szLoggerName, pInfo->Trace.strLoggerName );
            }
        } else {
            lstrcpy ( pQuery->szLoggerName, pQuery->szQueryName ); 
        }
          
        if ( (BOOL)( 0 == (pQuery->dwFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH)) )
            pQuery->Properties.FlushTimer = 0;
        else
            pQuery->Properties.FlushTimer = pQuery->dwBufferFlushInterval;
    
        if ( IsKernelTraceMode ( pQuery->dwFlags ) ) { 
            pQuery->Properties.Wnode.Guid = SystemTraceControlGuid;
            
            lstrcpy ( pQuery->szLoggerName, NT_KERNEL_LOGGER ); 


            if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_KERNEL_TRACE)) ) {
                // NT5 Beta 2 Single Kernel flag
                pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_PROCESS |
                                                  EVENT_TRACE_FLAG_THREAD |
                                                  EVENT_TRACE_FLAG_DISK_IO |
                                                  EVENT_TRACE_FLAG_NETWORK_TCPIP;
            } else {
                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_PROCESS_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_PROCESS;

                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_THREAD_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_THREAD;
            
                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_DISKIO_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_DISK_IO;
            
                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
            
            }
                
            if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_MEMMAN_TRACE)) ) 
                pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;

            if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_FILEIO_TRACE)) ) 
                pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
        
        } else {
            InitTraceGuids ( pQuery );
        }
        
        if ( -1 == pQuery->dwMaxFileSize ) {
            pQuery->Properties.MaximumFileSize = 0;
        } else {
            pQuery->Properties.MaximumFileSize = pQuery->dwMaxFileSize;
        }
        
        if ( ERROR_SUCCESS == dwStatus && TRUE == bBySize ) {
            pQuery->Properties.LogFileMode = 
                EVENT_TRACE_FILE_MODE_SEQUENTIAL | EVENT_TRACE_FILE_MODE_NEWFILE;
        } else if ( SLF_SEQ_TRACE_FILE == pQuery->dwLogFileType ) {
            pQuery->Properties.LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;

            // Only set Append mode if the file already exists.
            if ( pQuery->dwAppendMode && FileExists ( pQuery->szLogFileName ) ) {
                pQuery->Properties.LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
            }

        } else { 
            assert ( SLF_CIRC_TRACE_FILE == pQuery->dwLogFileType );
            pQuery->Properties.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;
        }

        if ( pInfo ) {
            pQuery->Properties.LogFileMode |= pInfo->Trace.dwMode;
            G_FREE( pInfo );
        }
        if ( NULL != pdwSessionSerial ) {
            *pdwSessionSerial = dwLocalSessionSerial;
        }
    } // Todo: else report error, return error
#endif

}


void 
FreeQueryData (
    IN PLOG_QUERY_DATA pQuery )
{
    // Caller must remove the thread data block from the list.

    // Threads are deleted by only one thread, so this should not
    // be deleted out from under.
    assert ( NULL != pQuery );

    if ( NULL != pQuery ) {
        // Free this entry.

        if (( SLQ_COUNTER_LOG == pQuery->dwLogType ) || 
            ( SLQ_ALERT == pQuery->dwLogType ) ){
        
            while ( NULL != pQuery->pFirstCounter ) {
                PLOG_COUNTER_INFO pDelCI = pQuery->pFirstCounter;
                pQuery->pFirstCounter = pDelCI->next;

                G_FREE( pDelCI );
            }
        } else {
            if ( NULL != pQuery->arrpGuid ) {
                ULONG ulIndex;
            
                for ( ulIndex = 0; ulIndex < pQuery->ulGuidCount; ulIndex++ ) {
                    if ( NULL != pQuery->arrpGuid[ulIndex] ) {
                        G_FREE ( pQuery->arrpGuid[ulIndex] );
                        pQuery->arrpGuid[ulIndex] = NULL;
                    }
                }

                G_FREE ( pQuery->arrpGuid );
                pQuery->arrpGuid = NULL;
            }
        }

        if ( NULL != pQuery->hThread ) {
            CloseHandle ( pQuery->hThread );
            pQuery->hThread = NULL;
        }

        if ( NULL != pQuery->hUserToken ) {
            CloseHandle ( pQuery->hUserToken );
            pQuery->hUserToken = NULL;
        }

        if ( NULL != pQuery->hExitEvent ) {
            CloseHandle ( pQuery->hExitEvent );
            pQuery->hExitEvent = NULL;
        }

        if ( NULL != pQuery->hReconfigEvent ) {
            CloseHandle ( pQuery->hReconfigEvent );
            pQuery->hReconfigEvent = NULL;
        }

        if ( NULL != pQuery->hKeyQuery ) {
            RegCloseKey ( pQuery->hKeyQuery );
            pQuery->hKeyQuery = NULL;
        }

        DeallocateQueryBuffers( pQuery );

        G_FREE (pQuery);
    }
}


void 
RemoveAndFreeQueryData (
    HANDLE hThisQuery
)
{
    PLOG_QUERY_DATA pQuery = NULL;
    BOOL bFound = FALSE;

    LockQueryData();
    
    // Find the query data block and remove it from the list.

    if ( hThisQuery == pFirstQuery->hThread ) {
        bFound = TRUE;
    }

    if ( bFound ) {
        pQuery = pFirstQuery;
        pFirstQuery = pFirstQuery->next;
    } else {

        PLOG_QUERY_DATA pQueryRemaining;
        
        for ( pQuery = pFirstQuery;
            NULL != pQuery->next;
            pQuery = pQuery->next ) {

            if ( hThisQuery == pQuery->next->hThread ) {
                pQueryRemaining = pQuery;
                pQuery = pQuery->next;
                pQueryRemaining->next = pQuery->next;
                bFound = TRUE;
                break;
            }
        }
    }

    assert ( bFound );

    if ( bFound ) {
        dwActiveSessionCount -= 1;
    }
    
    UnlockQueryData();
    
    assert ( NULL != pQuery );
#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Query removed\n", pQuery->szQueryName);
    OutputDebugString (szDebugString);
}
#endif

    if ( bFound ) {
        FreeQueryData( pQuery );
    }
}   


LONGLONG      
ComputeStartWaitTics(
    IN  PLOG_QUERY_DATA pQuery,
    IN  BOOL    bWriteToRegistry  
)
{
    LONGLONG    llWaitTics = ((LONGLONG)0);
    LONGLONG    llLocalDateTime;
    LONGLONG    llRptLocalDays = 0;
    LONGLONG    llRptStartTime = 0;
    LONGLONG    llRptStopTime = 0;
    LONGLONG    llRptLocalTime = 0;
    SLQ_TIME_INFO   stiSched;


    // Compute time to wait before logging starts.
    //
    // Time returned is millisecond granularity.
    //
    // Return value:
    //
    // Start time minus Now when At time is in the future.
    //
    // 0 signals no wait.  This is true when:
    //  Start is either Manual or At mode and start time set to before now.
    //      Exceptions for both of these cases are noted below.
    // 
    // NULL_INTERVAL_TICS signals exit immediately.  This is true when:
    //  Start is Manual and Start time is MAX_TIME_VALUE
    //  Stop is At mode and Stop time is past.
    //  Stop is Manual mode and Stop time is MIN_TIME_VALUE or any value <= Now
    //  Stop is After mode, After value is 0 (UI should protect against this).
    //  Stop is After mode, Start is At mode, stop time is past and repeat mode is Manual.
    //
    
    GetLocalFileTime (&llLocalDateTime);        

    if ( ( MAX_TIME_VALUE == pQuery->stiRegStart.llDateTime )
        && ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStart.dwAutoMode ) ) {
        // Manual Start, start time is MAX_TIME_VALUE
        // Note:  For repeat funcionality, manual start time might be > now.
        //    Need to keep the start mode Manual in this case to ensure that 
        //    SetStoppedStatus works.
        // Todo:  Don't allow repeat or restart with Manual mode?
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStop.dwAutoMode ) 
            && ( pQuery->stiRegStop.llDateTime  <= llLocalDateTime ) ) {
        // Past Stop Manual time. 
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( ( ( SLQ_AUTO_MODE_AT == pQuery->stiRegStop.dwAutoMode )
                && ( SLQ_AUTO_MODE_CALENDAR != pQuery->stiRepeat.dwAutoMode ) )
            && ( pQuery->stiRegStop.llDateTime  <= llLocalDateTime ) ) {
        // Past Stop At or time and repeat mode not set to calendar. 
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( SLQ_AUTO_MODE_AFTER == pQuery->stiRegStop.dwAutoMode ) {
        if ( 0 == pQuery->stiRegStop.dwValue ) {
            // Stop After mode and value is 0.
            llWaitTics = NULL_INTERVAL_TICS;
        } else if ( ( SLQ_AUTO_MODE_AT == pQuery->stiRegStart.dwAutoMode )
                    && ( SLQ_AUTO_MODE_NONE == pQuery->stiRepeat.dwAutoMode ) ) {
            LONGLONG    llTics;
            
            TimeInfoToTics ( &pQuery->stiRegStop, &llTics );
            
            if ( ( pQuery->stiRegStart.llDateTime + llTics ) < llLocalDateTime ) {
                // Start at, Stop After modes, stop time is past and no restart.
                llWaitTics = NULL_INTERVAL_TICS;
            }
        }
    } 
    
    // This code writes to local start and stop time structures to compute
    // start wait tics.  This avoids excessive log stops and starts, since
    // the original registry data structures are compared when the registry
    // has been modified, to determine if a log config has been changed by the UI.
    if ( NULL_INTERVAL_TICS != llWaitTics ) {

        pQuery->stiCurrentStart = pQuery->stiRegStart;
        pQuery->stiCurrentStop = pQuery->stiRegStop;

        // Handle repeat option separately.
        if ( SLQ_AUTO_MODE_CALENDAR == pQuery->stiRepeat.dwAutoMode ) {

            assert ( SLQ_AUTO_MODE_AT == pQuery->stiCurrentStart.dwAutoMode );
            assert ( SLQ_AUTO_MODE_AT == pQuery->stiCurrentStop.dwAutoMode );
//            assert ( ( pQuery->stiCurrentStop.llDateTime - pQuery->stiCurrentStart.llDateTime )
//                        < (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) );
        
            if ( pQuery->stiCurrentStop.llDateTime <= llLocalDateTime ) {

                llRptLocalDays = llLocalDateTime / (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY); 
                llRptLocalTime = llLocalDateTime - llRptLocalDays;

                llRptStopTime = pQuery->stiCurrentStop.llDateTime 
                                - ( pQuery->stiCurrentStop.llDateTime  
                                        / (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) );

                pQuery->stiCurrentStop.llDateTime = llRptLocalDays + llRptStopTime;
                if ( llRptStopTime < llRptLocalTime ) {
                    // Set to stop tomorrow.
                    pQuery->stiCurrentStop.llDateTime += (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) ;
                }

                llRptStartTime = pQuery->stiCurrentStart.llDateTime 
                                - ( pQuery->stiCurrentStart.llDateTime  
                                        / (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) );

                pQuery->stiCurrentStart.llDateTime = llRptLocalDays + llRptStartTime;

                if ( (pQuery->stiCurrentStop.llDateTime - pQuery->stiCurrentStart.llDateTime)
                    > (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) ) {
                    // Set to start tomorrow.
                    pQuery->stiCurrentStart.llDateTime += (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY);
                }  
            }
                
            if ( bWriteToRegistry ) {
                stiSched.wDataType = SLQ_TT_DTYPE_DATETIME;
                stiSched.wTimeType = SLQ_TT_TTYPE_REPEAT_START;
                stiSched.dwAutoMode = SLQ_AUTO_MODE_AT;
                stiSched.llDateTime = pQuery->stiCurrentStart.llDateTime;
            
                WriteRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    (LPCWSTR)L"Repeat Schedule Start",
                    &stiSched );

                stiSched.wTimeType = SLQ_TT_TTYPE_REPEAT_STOP;
                stiSched.dwAutoMode = SLQ_AUTO_MODE_AT;
                stiSched.llDateTime = pQuery->stiCurrentStop.llDateTime;
                
                WriteRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    (LPCWSTR)L"Repeat Schedule Stop",
                    &stiSched );

            }
        }
        
        if ( pQuery->stiCurrentStart.llDateTime <= llLocalDateTime ) {
            llWaitTics = ((LONGLONG)(0));
        } else {
            llWaitTics = pQuery->stiCurrentStart.llDateTime - llLocalDateTime;
        } 
        
        // If manual mode, set the start time to now, to handle repeat schedule.
        // If any thread other than the log thread accesses this field for a
        // running query, then need to synchronize access to the field.
        if( SLQ_AUTO_MODE_NONE == pQuery->stiCurrentStart.dwAutoMode 
            && MIN_TIME_VALUE == pQuery->stiCurrentStart.llDateTime ) 
        {
            pQuery->stiCurrentStart.llDateTime = llLocalDateTime + llWaitTics;
        }
    }

    return llWaitTics;
}


void
LoadDefaultLogFileFolder ( void )
{
    HKEY    hKeyLogService = NULL;   
    TCHAR   szLocalPath[MAX_PATH+1] = TEXT("");
    DWORD   cchExpandedLen;
    DWORD   dwStatus;

    dwStatus = RegOpenKeyEx (
        (HKEY)HKEY_LOCAL_MACHINE,
        (LPCTSTR)TEXT("SYSTEM\\CurrentControlSet\\Services\\SysmonLog"),
        0L,
        KEY_READ,
        (PHKEY)&hKeyLogService);

    // update the service status
    ssSmLogStatus.dwCheckPoint++;
    SetServiceStatus (hSmLogStatus, &ssSmLogStatus);

    if (dwStatus == ERROR_SUCCESS) {
        DWORD dwBufferSize = sizeof ( szLocalPath );

        dwStatus = RegQueryValueExW (
            hKeyLogService,
            (LPCTSTR)L"DefaultLogFileFolder",
            NULL,
            0L,
            (LPBYTE)szLocalPath,
            &dwBufferSize);

        RegCloseKey (hKeyLogService);

    }   // No message on error.  Just use load the local default.        
    
    if ( 0 == lstrlen (szLocalPath ) ) {
        lstrcpy ( szLocalPath, DEFAULT_LOG_FILE_FOLDER );
    }

    // Todo: local and global buffer sizes are fixed.

    cchExpandedLen = ExpandEnvironmentStrings (
                        szLocalPath,
                        gszDefaultLogFileFolder,
                        MAX_PATH+1 );
    
    if ( 0 == cchExpandedLen ) {
        gszDefaultLogFileFolder[0] = L'\0';
    }
}


DWORD
ProcessLogFileFolder (     
    IN PLOG_QUERY_DATA pQuery,
    IN BOOL bReconfigure )
{
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szLocalPath [MAX_PATH];

    szLocalPath[0] = _T('\0');

    if (GetFullPathName (
            pQuery->szLogFileFolder,
            MAX_PATH,
            szLocalPath,
            NULL) > 0) {

        LPTSTR      szEnd;
        LPSECURITY_ATTRIBUTES   lpSA = NULL;
        TCHAR       cBackslash = TEXT('\\');
        szEnd = &szLocalPath[3];

        if (*szEnd != 0) {
            LONG        lErrorMode;
            
            lErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
            
            // then there are sub dirs to create
            while (*szEnd != 0) {
                // go to next backslash
                while ((*szEnd != cBackslash) && (*szEnd != 0)) szEnd++;
                if (*szEnd == cBackslash) {
                    // terminate path here and create directory
                    *szEnd = 0;
                    if (!CreateDirectory (szLocalPath, lpSA)) {
                        // see what the error was and "adjust" it if necessary
                        dwStatus = GetLastError();
                        if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                            // this is OK
                            dwStatus = ERROR_SUCCESS;
                        }
                    }
                    // replace backslash and go to next dir
                    *szEnd++ = cBackslash;
                }
            }
            // create last dir in path now
            if (!CreateDirectory (szLocalPath, lpSA)) {
                // see what the error was and "adjust" it if necessary
                dwStatus = GetLastError();
                if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                    // this is OK
                    dwStatus = ERROR_SUCCESS;
                }
            }

            SetErrorMode ( lErrorMode );
        } else {
            // Root directory is ok.
            dwStatus = ERROR_SUCCESS;
        }
    } else {
        dwStatus = GetLastError();
    }

    // Report event on error
    if ( ERROR_SUCCESS != dwStatus ) {
        DWORD   dwMessageId; 
        LPCWSTR szStringArray[3];
        
        szStringArray[0] = pQuery->szLogFileFolder;
        szStringArray[1] = pQuery->szQueryName;
        szStringArray[2] = FormatEventLogMessage(dwStatus);

        if ( bReconfigure ) {
            dwMessageId = SMLOG_INVALID_LOG_FOLDER_STOP;
        } else {
            dwMessageId = SMLOG_INVALID_LOG_FOLDER_START;
        }

        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            dwMessageId,
            NULL,
            3,
            sizeof(DWORD),
            szStringArray,      
            (LPVOID)&dwStatus);
    }

    return dwStatus;
}

DWORD
OpenLogQueriesKey (
    REGSAM regsamAccess,
    PHKEY phKeyLogQueries )
{

    DWORD dwStatus;

    dwStatus = RegOpenKeyEx (
        (HKEY)HKEY_LOCAL_MACHINE,
        (LPCTSTR)TEXT("SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries"),
        0L,
        regsamAccess,
        phKeyLogQueries);

    return dwStatus;
}

DWORD
ClearQueryRunStates ( void )
{

    DWORD   dwStatus;            
    HKEY    hKeyLogQueries = NULL;            
    HKEY    hKeyThisLogQuery = NULL;            
    DWORD   dwQueryIndex;            
    TCHAR   szQueryNameBuffer[MAX_PATH+1];            
    DWORD   dwQueryNameBufferSize;            
    TCHAR   szQueryClassBuffer[MAX_PATH+1];            
    DWORD   dwQueryClassBufferSize;            
    LPTSTR  szCollectionName = NULL;            
    UINT    uiCollectionNameLen = 0;            
    LPTSTR  szStringArray[2];            
    DWORD   dwCurrentState;
    DWORD   dwDefault;
    DWORD   dwLogType;

    // For every query in the registry, if the state is SLQ_QUERY_RUNNING,
    // set it to SLQ_QUERY_STOPPED.
    //
    // This method must be called before starting the query threads.
    //
    // Only the service sets the state to SLQ_QUERY_RUNNING, so there is no 
    // race condition.

    // Open (each) query in the registry
    
    dwStatus = OpenLogQueriesKey (
                    KEY_READ | KEY_SET_VALUE,
                    (PHKEY)&hKeyLogQueries);

    if (dwStatus != ERROR_SUCCESS) {
        if (dwStatus == ERROR_FILE_NOT_FOUND) {
            // there is no logs nor alerts setting, bail out quietly
            //
            dwStatus = ERROR_SUCCESS;
        }
        else {
            // unable to read the log query information from the registry
            dwStatus = GetLastError();
            ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    SMLOG_UNABLE_OPEN_LOG_QUERY,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL);

            dwStatus = SMLOG_UNABLE_OPEN_LOG_QUERY;
        }
    } else {

        dwQueryIndex = 0;
        *szQueryNameBuffer = 0;
        dwQueryNameBufferSize = MAX_PATH+1;
        *szQueryClassBuffer = 0;
        dwQueryClassBufferSize = MAX_PATH+1;

        while ((dwStatus = RegEnumKeyEx (
            hKeyLogQueries,
            dwQueryIndex,
            szQueryNameBuffer,
            &dwQueryNameBufferSize,
            NULL,
            szQueryClassBuffer,
            &dwQueryClassBufferSize,
            NULL)) != ERROR_NO_MORE_ITEMS) {

            // open this key
            dwStatus = RegOpenKeyEx (
                hKeyLogQueries,
                szQueryNameBuffer,
                0L,
                KEY_READ | KEY_WRITE,
                (PHKEY)&hKeyThisLogQuery);

            if (dwStatus != ERROR_SUCCESS) {
                szStringArray[0] = szQueryNameBuffer;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_READ_LOG_QUERY,
                    NULL,
                    1,
                    sizeof(DWORD),
                    szStringArray,
                       (LPVOID)&dwStatus);
                // skip to next item
                goto CONTINUE_ENUM_LOOP;
            }

            // update the service status
            ssSmLogStatus.dwCheckPoint++;
            SetServiceStatus (hSmLogStatus, &ssSmLogStatus);

            dwStatus = SmReadRegistryIndirectStringValue (
                        hKeyThisLogQuery,
                        L"Collection Name",
                        NULL,
                        &szCollectionName,
                        &uiCollectionNameLen );
            
            if ( NULL != szCollectionName ) {
                if ( 0 < lstrlen ( szCollectionName ) ) {
                    lstrcpyn ( 
                        szQueryNameBuffer, 
                        szCollectionName, 
                        min(MAX_PATH, lstrlen(szCollectionName)+1 ) );
                }

                G_FREE ( szCollectionName );
                szCollectionName = NULL;
                uiCollectionNameLen = 0;
            }

            dwDefault = ((DWORD)-1);
            dwStatus = ReadRegistryDwordValue (
                        hKeyThisLogQuery, 
                        szQueryNameBuffer,
                        (LPCTSTR)L"Log Type",
                        &dwDefault, 
                        &dwLogType );

            if ( ( SLQ_COUNTER_LOG == dwLogType )
                || ( SLQ_TRACE_LOG == dwLogType ) 
                || ( SLQ_ALERT == dwLogType ) ) {
            
                // Check the current state of the query.  If it is SLQ_QUERY_RUNNING,
                // set it to SLQ_QUERY_STOPPED.  If, in addition, the Start mode is 
                // manual, set the start time to MAX, so that the query doesn't 
                // start automatically.

                // If the current state is SLQ_QUERY_START_PENDING, it is assumed to be a new
                // request, so leave the registry as is.
                //

                // Note:  For trace logs, this code only coordinates between trace log 
                // configs that are stored in the registry.

                dwDefault = SLQ_QUERY_STOPPED;
                dwStatus = ReadRegistryDwordValue (
                    hKeyThisLogQuery,
                    szQueryNameBuffer,
                    (LPCTSTR)L"Current State",
                    &dwDefault, 
                    &dwCurrentState );
                assert (dwStatus == ERROR_SUCCESS);
                // Status always success if default provided.

                // If query is in START_PENDING or STOPPED state, then
                // the registry contents are correct. If it is in
                // RUNNING state, then the service was stopped before
                // it could clean up the registry state.
                if ( SLQ_QUERY_RUNNING == dwCurrentState ) {
                    SLQ_TIME_INFO stiDefault;
                    SLQ_TIME_INFO stiActual;
                    LONGLONG      ftLocalTime;

                    dwCurrentState = SLQ_QUERY_STOPPED;
                    dwStatus = WriteRegistryDwordValue (
                                hKeyThisLogQuery, 
                                (LPCTSTR)L"Current State",
                                &dwCurrentState,
                                REG_DWORD );

                    if (dwStatus != ERROR_SUCCESS) {
                        szStringArray[0] = szQueryNameBuffer;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_WRITE_STOP_STATE,
                            NULL,
                            1,
                            sizeof(DWORD),
                            szStringArray,
                               (LPVOID)&dwStatus);
                        // skip to next item
                        goto CONTINUE_ENUM_LOOP;
                    } 

                    // If Start is manual mode, set start time to MAX, to signal
                    // not started.  
                    GetLocalFileTime ( &ftLocalTime );

                    stiDefault.wTimeType = SLQ_TT_TTYPE_START;
                    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AT;
                    stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
                    stiDefault.llDateTime = *(LONGLONG *)&ftLocalTime;

                    dwStatus = ReadRegistrySlqTime (
                                hKeyThisLogQuery, 
                                szQueryNameBuffer,
                                (LPCTSTR)L"Start",
                                &stiDefault,
                                &stiActual );

                    assert (dwStatus == ERROR_SUCCESS);
                    // Status always success if default provided.
            
                    if ( ( SLQ_AUTO_MODE_NONE == stiActual.dwAutoMode ) 
                        && ( MAX_TIME_VALUE != stiActual.llDateTime ) ) {

                        stiActual.llDateTime = MAX_TIME_VALUE;
                        dwStatus = WriteRegistrySlqTime (
                            hKeyThisLogQuery, 
                            (LPCTSTR)L"Start",
                            &stiActual);

                        if (dwStatus != ERROR_SUCCESS) {
                            szStringArray[0] = szQueryNameBuffer;
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_RESET_START_TIME,
                                NULL,
                                1,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&dwStatus);
                            // skip to next item
                            goto CONTINUE_ENUM_LOOP;
                        }
                    }             
                    
                    // If Stop is manual mode, set stop time to MIN, to signal
                    // not started.  
                    GetLocalFileTime ( &ftLocalTime );

                    stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
                    stiDefault.wTimeType = SLQ_TT_TTYPE_STOP;
                    stiDefault.dwAutoMode = SLQ_AUTO_MODE_NONE;
                    stiDefault.llDateTime = MIN_TIME_VALUE;

                    dwStatus = ReadRegistrySlqTime (
                                hKeyThisLogQuery, 
                                szQueryNameBuffer,
                                (LPCTSTR)L"Stop",
                                &stiDefault,
                                &stiActual );

                    assert (dwStatus == ERROR_SUCCESS);
                    // Status always success if default provided.
            
                    if ( ( SLQ_AUTO_MODE_NONE == stiActual.dwAutoMode ) 
                        && ( MIN_TIME_VALUE != stiActual.llDateTime ) ) {

                        stiActual.llDateTime = MIN_TIME_VALUE;
                        dwStatus = WriteRegistrySlqTime (
                            hKeyThisLogQuery, 
                            (LPCTSTR)L"Stop",
                            &stiActual);

                        if (dwStatus != ERROR_SUCCESS) {
                            szStringArray[0] = szQueryNameBuffer;
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_RESET_STOP_TIME,
                                NULL,
                                1,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&dwStatus);
                            // skip to next item
                            goto CONTINUE_ENUM_LOOP;
                        }
                    }                 
                }
            } // Ignore invalid log types when clearing status. 

CONTINUE_ENUM_LOOP:
            if ( NULL != hKeyThisLogQuery )
                RegCloseKey (hKeyThisLogQuery);
            hKeyThisLogQuery = NULL;
            // prepare for next loop
            dwQueryIndex++;
            *szQueryNameBuffer = 0;
            dwQueryNameBufferSize = MAX_PATH+1;
            *szQueryClassBuffer = 0;
            dwQueryClassBufferSize = MAX_PATH+1;
        } // end enumeration of log queries
    }

    if ( NULL != hKeyLogQueries ) {
        RegCloseKey (hKeyLogQueries);
    }
    return dwStatus;
}


BOOL
TraceStopRestartFieldsMatch (
    IN PLOG_QUERY_DATA pOrigQuery,
    IN PLOG_QUERY_DATA pNewQuery )
{
#if _IMPLEMENT_WMI
    // These are fields for which trace logging must
    // be stopped and restarted in order to reconfigure.
    BOOL    bRequested;
    BOOL    bCurrent;
    ULONG   ulGuidCount = 0;
    ULONG   ulGuidIndex = 0;
    TCHAR*  pszThisGuid = NULL;

    assert ( SLQ_TRACE_LOG == pOrigQuery->dwLogType );
    assert ( SLQ_TRACE_LOG == pNewQuery->dwLogType );

    if ( !CommonFieldsMatch ( pOrigQuery, pNewQuery ) ) 
        return FALSE;

    if ( pOrigQuery->stiCreateNewFile.dwAutoMode != pNewQuery->stiCreateNewFile.dwAutoMode ) {
        return FALSE;
    } else {
        if ( ( SLQ_AUTO_MODE_AFTER == pOrigQuery->stiCreateNewFile.dwAutoMode )
            && ( pOrigQuery->stiCreateNewFile.llDateTime != pNewQuery->stiCreateNewFile.llDateTime ) ) {
            return FALSE;
        }
    }

    // Compare new query fields against the existing properties structure.
    // Compare everything but flush interval, max buffer count and file name.
    if ( pOrigQuery->Properties.BufferSize != pNewQuery->dwBufferSize )
        return FALSE;

    if ( pOrigQuery->Properties.MinimumBuffers != pNewQuery->dwBufferMinCount )
        return FALSE;

    // Not kernel trace, so check query name
    if ((BOOL)( 0 == ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_KERNEL_TRACE ) ) ) {
        if ( 0 != lstrcmpi ( pOrigQuery->szLoggerName, pNewQuery->szQueryName ) ) {
            return FALSE;
        }
    }

    bRequested = (BOOL)( 0 != ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_KERNEL_TRACE ) );
    bCurrent = IsEqualGUID( &pOrigQuery->Properties.Wnode.Guid, &SystemTraceControlGuid );
    
    if ( bRequested != bCurrent ) {
        return FALSE;
    }

    // Extended memory trace

    bRequested = (BOOL)( 0 != ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_MEMMAN_TRACE ) );
    bCurrent = (BOOL)( 0 != ( pOrigQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS ) ); 

    if ( bRequested != bCurrent ) {
        return FALSE;
    }

    // Extended I/O trace

    bRequested = (BOOL)( 0 != ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_FILEIO_TRACE ) );
    bCurrent = (BOOL)( 0 != ( pOrigQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO ) ); 

    if ( bRequested != bCurrent ) {
        return FALSE;
    }

    if ( -1 == pNewQuery->dwMaxFileSize ) {
        if ( 0 != pOrigQuery->Properties.MaximumFileSize ) {
            return FALSE;
        }
    } else if ( pOrigQuery->Properties.MaximumFileSize != pNewQuery->dwMaxFileSize ) {
        return FALSE;
    }

    if ( ( SLF_SEQ_TRACE_FILE == pNewQuery->dwLogFileType ) 
            && ( EVENT_TRACE_FILE_MODE_SEQUENTIAL != pOrigQuery->Properties.LogFileMode ) ) {
        return FALSE;
    } else if ( ( SLF_CIRC_TRACE_FILE == pNewQuery->dwLogFileType ) 
            && ( EVENT_TRACE_FILE_MODE_CIRCULAR != pOrigQuery->Properties.LogFileMode ) ) {
        return FALSE;        
    }

    // Compare each provider string against array element.
    for (pszThisGuid = pNewQuery->mszProviderList;
            *pszThisGuid != 0;
            pszThisGuid += lstrlen(pszThisGuid) + 1) {
        ulGuidCount += 1;
    }

    if ( pOrigQuery->ulGuidCount != ulGuidCount )
        return FALSE;

    ulGuidIndex = 0;
    for (pszThisGuid = pNewQuery->mszProviderList;
            *pszThisGuid != 0;
            pszThisGuid += lstrlen(pszThisGuid) + 1) {

        if ( 0 != lstrcmpi ( pOrigQuery->arrpszProviderName[ulGuidIndex], pszThisGuid ) )
            return FALSE;
        ulGuidIndex++;
        assert ( ulGuidIndex <= ulGuidCount );
    }
    return TRUE;
#else 
    return FALSE;
#endif
}


BOOL
AlertFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery )
{
    if ( pFirstQuery->dwAlertActionFlags != pSecondQuery->dwAlertActionFlags )
        return FALSE;

    if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_ACTION_SEND_MSG) ) {     
        if ( 0 != lstrcmpi ( pFirstQuery->szNetName, pSecondQuery->szNetName ) ) {
            return FALSE;
        }
    }

    if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_ACTION_EXEC_CMD) ) {     
        if ( 0 != lstrcmpi ( pFirstQuery->szCmdFileName, pSecondQuery->szCmdFileName ) ) {
            return FALSE;
        }

        if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_CMD_LINE_U_TEXT ) ) {     
            if ( 0 != lstrcmpi ( pFirstQuery->szUserText, pSecondQuery->szUserText ) ) {
                return FALSE;
            }
        }
    }

    if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_ACTION_START_LOG) ) {     
        if ( 0 != lstrcmpi ( pFirstQuery->szPerfLogName, pSecondQuery->szPerfLogName ) ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CommonFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery )
{
    if ( pFirstQuery->dwCurrentState != pSecondQuery->dwCurrentState )
        return FALSE;

    if ( pFirstQuery->dwLogFileType != pSecondQuery->dwLogFileType )
        return FALSE;

    if ( pFirstQuery->dwAutoNameFormat != pSecondQuery->dwAutoNameFormat )
        return FALSE;

    if ( pFirstQuery->dwMaxFileSize != pSecondQuery->dwMaxFileSize )
        return FALSE;

    if ( pFirstQuery->stiRegStart.dwAutoMode != pSecondQuery->stiRegStart.dwAutoMode )
        return FALSE;

    if ( pFirstQuery->stiRegStop.dwAutoMode != pSecondQuery->stiRegStop.dwAutoMode )
        return FALSE;

    if ( pFirstQuery->stiRepeat.dwAutoMode != pSecondQuery->stiRepeat.dwAutoMode )
        return FALSE;

    if ( pFirstQuery->stiRegStart.llDateTime != pSecondQuery->stiRegStart.llDateTime )
        return FALSE;

    if ( pFirstQuery->stiRegStop.llDateTime != pSecondQuery->stiRegStop.llDateTime )
        return FALSE;

    if ( pFirstQuery->stiRepeat.llDateTime != pSecondQuery->stiRepeat.llDateTime )
        return FALSE;

    if (( SLQ_COUNTER_LOG == pFirstQuery->dwLogType ) || 
        ( SLQ_TRACE_LOG == pFirstQuery->dwLogType)) {

        if ( 0 != lstrcmpi ( pFirstQuery->szBaseFileName, pSecondQuery->szBaseFileName ) )
            return FALSE;

        if ( 0 != lstrcmpi ( pFirstQuery->szLogFileFolder, pSecondQuery->szLogFileFolder ) )
            return FALSE;

        if ( 0 != lstrcmpi ( pFirstQuery->szSqlLogName, pSecondQuery->szSqlLogName ) )
            return FALSE;

        if ( 0 != lstrcmpi ( pFirstQuery->szLogFileComment, pSecondQuery->szLogFileComment ) )
            return FALSE;
    
        if ( pFirstQuery->dwCurrentSerialNumber != pSecondQuery->dwCurrentSerialNumber )
            return FALSE;

        if ( pFirstQuery->dwLogFileSizeUnit != pSecondQuery->dwLogFileSizeUnit )
            return FALSE;

        if ( pFirstQuery->dwAppendMode != pSecondQuery->dwAppendMode      )
            return FALSE;

        if ( pFirstQuery->stiCreateNewFile.dwAutoMode != pSecondQuery->stiCreateNewFile.dwAutoMode )
            return FALSE;

        if ( pFirstQuery->stiCreateNewFile.llDateTime != pSecondQuery->stiCreateNewFile.llDateTime )
            return FALSE;

        if ( 0 != lstrcmpi(pFirstQuery->szCmdFileName, pSecondQuery->szCmdFileName ) )
            return FALSE;
    }

    if (( SLQ_COUNTER_LOG == pFirstQuery->dwLogType ) || 
        ( SLQ_ALERT == pFirstQuery->dwLogType)) {

        LPTSTR          szFirstPath;
        LPTSTR          szSecondPath;

        if ( pFirstQuery->dwMillisecondSampleInterval != pSecondQuery->dwMillisecondSampleInterval ) {
            return FALSE;
        }
        
        // Compare each counter string.  Note:  If counter order has changed, the query is
        // reconfigured.
        // For Alert queries, this code also checks the limit threshold logic and value.
        szSecondPath = pSecondQuery->mszCounterList;
        for ( szFirstPath = pFirstQuery->mszCounterList;
                *szFirstPath != 0;
                szFirstPath += lstrlen(szFirstPath) + 1) {

            if ( 0 != lstrcmpi( szFirstPath, szSecondPath ) ) {
                return FALSE;
            }    
            szSecondPath += lstrlen(szSecondPath) + 1;
        }
    
        if ( 0 != *szSecondPath ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
FieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery )
{
    assert ( pFirstQuery->dwLogType == pSecondQuery->dwLogType );

    if ( !CommonFieldsMatch ( pFirstQuery, pSecondQuery ) ) 
        return FALSE;

    if ( SLQ_ALERT == pFirstQuery->dwLogType ) {
        if ( !AlertFieldsMatch( pFirstQuery, pSecondQuery ) ) {
            return FALSE;
        }
    } else if ( SLQ_TRACE_LOG == pFirstQuery->dwLogType ) {
        LPTSTR  szFirstProv;
        LPTSTR  szSecondProv;

        if ( pFirstQuery->dwBufferSize != pSecondQuery->dwBufferSize )
            return FALSE;

        if ( pFirstQuery->dwBufferMinCount != pSecondQuery->dwBufferMinCount )
            return FALSE;

        if ( pFirstQuery->dwBufferMaxCount != pSecondQuery->dwBufferMaxCount )
            return FALSE;

        if ( pFirstQuery->dwBufferFlushInterval != pSecondQuery->dwBufferFlushInterval )
            return FALSE;

        if ( pFirstQuery->dwFlags != pSecondQuery->dwFlags )
            return FALSE;

        szSecondProv = pSecondQuery->mszProviderList;

        for ( szFirstProv = pFirstQuery->mszProviderList;
            *szFirstProv != 0;
            szFirstProv += lstrlen(szFirstProv) + 1) {


            if ( 0 != lstrcmpi ( szFirstProv, szSecondProv ) )
                return FALSE;

            szSecondProv += lstrlen(szSecondProv) + 1;
        }
    
        if ( 0 != *szSecondProv) {
            return FALSE;
        }
    } else if ( SLQ_COUNTER_LOG == pFirstQuery->dwLogType ) {
        if ( pFirstQuery->stiCreateNewFile.dwAutoMode != pSecondQuery->stiCreateNewFile.dwAutoMode ) {
            return FALSE;
        } else {
            if ( SLQ_AUTO_MODE_AFTER == pFirstQuery->stiCreateNewFile.dwAutoMode 
                && pFirstQuery->stiCreateNewFile.llDateTime != pSecondQuery->stiCreateNewFile.llDateTime ) {
                return FALSE;
            } // else change in max size handled in commmon fields match check.
        }
    }

    return TRUE;
}


DWORD
IsModified (
    IN PLOG_QUERY_DATA pQuery,
    OUT BOOL* pbModified
)
{
    DWORD dwStatus;
    SLQ_TIME_INFO   stiLastModified;
    SLQ_TIME_INFO   stiDefault;

    *pbModified = TRUE;

    // Check the last read date against 'last modified' in
    // the registry.  
    // If it is earlier than the registry, and the data in the
    // registry has changed, return TRUE.
    //
    // The check of thread data against registry data reduces the
    // number of times that the logging thread is interrupted.
    // This is necessary because each property page OnApply 
    // generates this check.
    //
    stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
    stiDefault.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AT;
    stiDefault.llDateTime = MAX_TIME_VALUE;

    dwStatus = ReadRegistrySlqTime (
        pQuery->hKeyQuery,
        pQuery->szQueryName,
        (LPCTSTR)L"Last Modified",
        &stiDefault,
        &stiLastModified );

    assert( ERROR_SUCCESS == dwStatus );
    // Status always success if default provided.

    if ( stiLastModified.llDateTime <= pQuery->llLastConfigured ) {
        *pbModified = FALSE;
    } else {
        LOG_QUERY_DATA TempQuery;

        memset (&TempQuery, 0, sizeof(TempQuery));
        lstrcpy (TempQuery.szQueryName, pQuery->szQueryName);
        TempQuery.hKeyQuery = pQuery->hKeyQuery;

        if ( ERROR_SUCCESS != LoadQueryConfig( &TempQuery ) ) {
            // Event has been logged.  Set mod flag to stop the query.
            *pbModified = TRUE;
        } else {
            *pbModified = !FieldsMatch ( pQuery, &TempQuery );
        }

        // Delete memory allocated by registry data load.
        DeallocateQueryBuffers ( &TempQuery );
    }

    return dwStatus;
}



DWORD
ReconfigureQuery (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;

        
    // *** Optimization - perform this check within IsModified, to avoid extra
    // load from the registry.
    LOG_QUERY_DATA TempQuery;
    BOOL bStopQuery = FALSE;

    memset (&TempQuery, 0, sizeof(TempQuery));
    lstrcpy (TempQuery.szQueryName, pQuery->szQueryName);
    TempQuery.hKeyQuery = pQuery->hKeyQuery;

    if ( ERROR_SUCCESS != LoadQueryConfig( &TempQuery ) ) {
        // Event has been logged.  Stop the query.
        bStopQuery = TRUE;
    } else {
        bStopQuery = ( NULL_INTERVAL_TICS == ComputeStartWaitTics ( &TempQuery, FALSE ) );
    } 

    if ( !bStopQuery ) {
        if ( SLQ_TRACE_LOG == pQuery->dwLogType 
                || SLQ_COUNTER_LOG == pQuery->dwLogType ) {
            // Stop the query if new log file folder is not valid.
            bStopQuery = ( ERROR_SUCCESS != ProcessLogFileFolder( &TempQuery, TRUE ) );
        }
    }

    if ( bStopQuery ) {

#if _DEBUG_OUTPUT
{
    TCHAR szDebugString[MAX_PATH];
    swprintf (szDebugString, (LPCWSTR)L"    Query %s: Set exit event\n", pQuery->szQueryName);
    OutputDebugString (szDebugString);
}
#endif                  
        SetEvent (pQuery->hExitEvent);

    } else {

        if (( SLQ_COUNTER_LOG == pQuery->dwLogType ) || 
            ( SLQ_ALERT == pQuery->dwLogType ) ){
        // Signal the logging thread to reconfigure.
            pQuery->bLoadNewConfig= TRUE;
            SetEvent (pQuery->hReconfigEvent);
        } else {
#if _IMPLEMENT_WMI
            BOOL bMustStopRestart;
            
            assert( SLQ_TRACE_LOG == pQuery->dwLogType );
            
            //
            // Change the current query.  For some properties, this
            // means stopping then restarting the query.
            // 
                
            bMustStopRestart = !TraceStopRestartFieldsMatch ( pQuery, &TempQuery );
                
            if ( !bMustStopRestart ) {

                if ( ERROR_SUCCESS != LoadQueryConfig( pQuery ) ) {
                    SetEvent (pQuery->hExitEvent);
                } else {

                    // Update the trace log session.  Do not increment
                    // the file autoformat serial number.
                    // Todo:  File name serial number is already incremented.
                    InitTraceProperties ( pQuery, FALSE, NULL, NULL );

                    dwStatus = GetTraceQueryStatus ( pQuery, NULL );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        dwStatus = UpdateTrace(
                                    pQuery->LoggerHandle, 
                                    pQuery->szLoggerName, 
                                    &pQuery->Properties );
                    }
                }

            } else {
                // Signal the logging thread to reconfigure.
                pQuery->bLoadNewConfig= TRUE;
                SetEvent (pQuery->hReconfigEvent);

            }
        }
    }
#else
    dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
#endif
    return dwStatus;
}


DWORD
GetTraceQueryStatus (
    IN PLOG_QUERY_DATA pQuery,
    IN OUT PLOG_QUERY_DATA pReturnQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;
#if _IMPLEMENT_WMI
    PLOG_QUERY_DATA pLocalQuery = NULL;

    if ( NULL != pQuery ) {
    
        if ( NULL != pReturnQuery ) {
            pLocalQuery = pReturnQuery;
        } else {
            pLocalQuery = G_ALLOC ( sizeof (LOG_QUERY_DATA) );
        }

        if ( NULL != pLocalQuery ) {
            ClearTraceProperties ( pLocalQuery );
    
            pLocalQuery->Properties.Wnode.BufferSize = sizeof(pQuery->Properties)
                                                  + sizeof(pQuery->szLoggerName)
                                                  + sizeof(pQuery->szLogFileName);

            pLocalQuery->Properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
      
            dwStatus = QueryTrace (
                            pQuery->LoggerHandle, 
                            pQuery->szLoggerName,
                            &pLocalQuery->Properties );

            if ( NULL == pReturnQuery ) {
                G_FREE ( pLocalQuery );
            }
        } else {
            dwStatus = ERROR_OUTOFMEMORY;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

#else
     dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
#endif
    return dwStatus;
}


DWORD
StartQuery (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPTSTR  szStringArray[2];

    HANDLE  hThread = NULL;
    DWORD   dwThreadId;

    pQuery->bLoadNewConfig= FALSE;

    // Create the logging thread.
    hThread = CreateThread (
        NULL, 0, LoggingThreadProc,
        (LPVOID)pQuery, 0, &dwThreadId);

    if ( NULL != hThread ) {
        pQuery->hThread = hThread;
    } else {
        // unable to start thread
        dwStatus = GetLastError();
        szStringArray[0] = pQuery->szQueryName;
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            SMLOG_UNABLE_START_THREAD,
            NULL,
            1,
            sizeof(DWORD),
            szStringArray,
            (LPVOID)&dwStatus);
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        SetStoppedStatus ( pQuery );
    }

    return dwStatus;
}


DWORD
SetStoppedStatus (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD           dwStatus;
    SYSTEMTIME      st;
    LONGLONG        llTime;

    pQuery->dwCurrentState = SLQ_QUERY_STOPPED;
    dwStatus = WriteRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    (LPCTSTR)L"Current State",
                    &pQuery->dwCurrentState,
                    REG_DWORD );

    if ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStart.dwAutoMode ) {
        pQuery->stiRegStart.llDateTime = MAX_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        (LPCTSTR)L"Start",
                        &pQuery->stiRegStart);
    }

    GetLocalTime(&st);
    SystemTimeToFileTime (&st, (FILETIME *)&llTime);

    // If stop is manual or StopAt with time before now (no repeat), set to manual 
    // with MIN_TIME_VALUE
    if ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStop.dwAutoMode 
                && llTime >= pQuery->stiRegStop.llDateTime ) 
    {
        pQuery->stiRegStop.dwAutoMode = SLQ_AUTO_MODE_NONE;
        pQuery->stiRegStop.llDateTime = MIN_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        (LPCTSTR)L"Stop",
                        &pQuery->stiRegStop);

    } else if ( ( SLQ_AUTO_MODE_AT == pQuery->stiRegStop.dwAutoMode 
                && ( SLQ_AUTO_MODE_CALENDAR != pQuery->stiRepeat.dwAutoMode ) )
                && ( llTime >= pQuery->stiRegStop.llDateTime ) ) {

        pQuery->stiRegStop.dwAutoMode = SLQ_AUTO_MODE_NONE;
        pQuery->stiRegStop.llDateTime = MIN_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        (LPCTSTR)L"Stop",
                        &pQuery->stiRegStop);
    }

    return dwStatus;
}


DWORD
HandleMaxQueriesExceeded (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;

    // The query has not been started yet, but still in "Start Pending" state.
    SetStoppedStatus ( pQuery );

    return dwStatus;
}
    

DWORD 
ConfigureQuery (
    HKEY    hKeyLogQuery,
    TCHAR*  szQueryKeyNameBuffer,
    TCHAR*  szQueryNameBuffer )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PLOG_QUERY_DATA   pQuery = NULL;

    pQuery = GetQueryData ( szQueryNameBuffer );
    if ( NULL != pQuery ) {
        BOOL    bModified;

        dwStatus = IsModified ( pQuery, &bModified );

        if (dwStatus == ERROR_SUCCESS) {
            if ( bModified ) {
                dwStatus = ReconfigureQuery ( pQuery );
                // LastModified and LastConfigured values are stored as GMT
                GetSystemTimeAsFileTime ( (LPFILETIME)(&pQuery->llLastConfigured) );
            }
        }
    } else {

        // No query data block found.  Create one and insert it into the list.
        BOOL    bStartQuery = FALSE;
        LPTSTR  szStringArray[2];

        // Allocate a thread info block.
        pQuery = G_ALLOC (sizeof(LOG_QUERY_DATA));
    
        if (pQuery != NULL) {
        
            // initialize the query data block
            G_ZERO (pQuery, sizeof(LOG_QUERY_DATA));
        
            pQuery->hKeyQuery = hKeyLogQuery;
            lstrcpy (pQuery->szQueryName, szQueryNameBuffer);
            lstrcpy (pQuery->szQueryKeyName, szQueryKeyNameBuffer);

            // Determine whether to continue, based on whether start wait time
            // is 0 or greater.

            // The thread is reinitialized in the logging procedure.
            // This pre-check avoids spurious thread creation.
            dwStatus = LoadQueryConfig( pQuery );

            if ( ERROR_SUCCESS != dwStatus ) {
                // Event already logged.
                bStartQuery = FALSE;
            } else {
                bStartQuery = ( NULL_INTERVAL_TICS != ComputeStartWaitTics ( pQuery, FALSE ) );
            }

            if ( bStartQuery ) {
                if ( SLQ_TRACE_LOG == pQuery->dwLogType 
                    || SLQ_COUNTER_LOG == pQuery->dwLogType ) {

                        bStartQuery = ( ERROR_SUCCESS == ProcessLogFileFolder( pQuery, FALSE ) );
                }
            }

            if ( bStartQuery ) {

                LockQueryData();

                if ( dwActiveSessionCount < dwMaxActiveSessionCount ) {
                    pQuery->hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

                    if ( NULL != pQuery->hExitEvent ) {
    
                        pQuery->hReconfigEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                        if ( NULL != pQuery->hReconfigEvent ) {
                            // LastModified and LastConfigured values are stored as GMT
                            GetSystemTimeAsFileTime ( (LPFILETIME)(&pQuery->llLastConfigured) );

                            dwStatus = StartQuery( pQuery );

                            if ( ERROR_SUCCESS == dwStatus ) {

                                // add it to the list and continue
                                if (pFirstQuery == NULL) {
                                    // then this is the first thread so add it
                                    pQuery->next = NULL;
                                    pFirstQuery = pQuery;
                                } else {
                                    // insert this at the head of the list since
                                    // that's the easiest and the order isn't
                                    // really important
                                    pQuery->next = pFirstQuery;
                                    pFirstQuery = pQuery;
                                }

                                dwActiveSessionCount += 1;
                                SetEvent (hNewQueryEvent );
                
                            } else {
                                // Unable to start query.
                                // Event has already been logged.
                                FreeQueryData ( pQuery );                                   
                            }
                        } else {
                            // Unable to create reconfig event.
                            dwStatus = GetLastError();
                            szStringArray[0] = szQueryNameBuffer;
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_CREATE_RECONFIG_EVENT,
                                NULL,
                                1,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&dwStatus);

                            FreeQueryData( pQuery );      
                        }
                    } else {
                        // Unable to create exit event.
                        dwStatus = GetLastError();
                        szStringArray[0] = szQueryNameBuffer;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_CREATE_EXIT_EVENT,
                            NULL,
                            1,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&dwStatus);

                        FreeQueryData( pQuery );                
                    }
                        
                } else {

                    szStringArray[0] = szQueryNameBuffer;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_MAXIMUM_QUERY_LIMIT,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);

                    dwStatus = HandleMaxQueriesExceeded ( pQuery );

                    FreeQueryData ( pQuery );                                   
                }

                UnlockQueryData();

            } else {
                // Wait time is -1, or config load error.
                FreeQueryData( pQuery );                
            }
        } else {
            // Memory allocation error.
            dwStatus = GetLastError();
            szStringArray[0] = szQueryNameBuffer;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_ALLOCATE_DATABLOCK,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&dwStatus);
        }
    }

    return dwStatus;
}

DWORD
DoLogCommandFile (
    IN  PLOG_QUERY_DATA pArg,
    IN  LPTSTR          szLogFileName,
    IN  BOOL            bStillRunning
)
{
    DWORD   dwStatus;
    BOOL    bStatus = FALSE;
    const   INT ciExtraChars = 3;
    INT     iBufLen = 0;
    INT     iStrLen = 0;
    LPTSTR  szCommandString = NULL;
    LPTSTR  szTempBuffer = NULL;
    LONG    lErrorMode;
    LPWSTR  szStringArray[3];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD   dwCreationFlags = NORMAL_PRIORITY_CLASS;

    if ( NULL != pArg && NULL != szLogFileName ) {

        if ( NULL != pArg->szCmdFileName ) { 
 
            dwStatus = pArg->dwCmdFileFailure;

            if ( ERROR_SUCCESS == dwStatus ) {

                iStrLen = lstrlen ( szLogFileName );
                iBufLen = iStrLen + ciExtraChars + 1;       // 1 is for NULL
                
                szCommandString = (LPTSTR)G_ALLOC(iBufLen * sizeof(TCHAR));

                iBufLen += lstrlen ( pArg->szCmdFileName ) + 1; // 1 is for space char, 
                                                                // NULL already counted.
        
                szTempBuffer = (LPTSTR)G_ALLOC(iBufLen * sizeof(TCHAR));

                if ( NULL != szCommandString && NULL != szTempBuffer ) {
                    // build command line arguments
                    szCommandString[0] = _T('\"');
                    lstrcpy (&szCommandString[1], szLogFileName );
                    lstrcpy (&szCommandString[iStrLen+1], (LPCTSTR)(LPCTSTR)TEXT("\" "));
                    lstrcpy (&szCommandString[iStrLen+2],
                        (bStillRunning ? (LPCTSTR)(LPCTSTR)TEXT("1") : (LPCTSTR)TEXT("0")));

                    // initialize Startup Info block
                    memset (&si, 0, sizeof(si));
                    si.cb = sizeof(si);
                    si.dwFlags = STARTF_USESHOWWINDOW ;
                    si.wShowWindow = SW_SHOWNOACTIVATE ;
                    
                    //si.lpDesktop = L"WinSta0\\Default";
                    memset (&pi, 0, sizeof(pi));

                    // supress pop-ups in the detached process
                    lErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

                    lstrcpy (szTempBuffer, pArg->szCmdFileName) ;

                    // see if this is a CMD or a BAT file
                    // if it is then create a process with a console window, otherwise
                    // assume it's an executable file that will create it's own window
                    // or console if necessary
                    //
                    _tcslwr (szTempBuffer);
                    if ((_tcsstr(szTempBuffer, (LPCTSTR)TEXT(".bat")) != NULL)
                        || (_tcsstr(szTempBuffer, (LPCTSTR)TEXT(".cmd")) != NULL))
                    {
                            dwCreationFlags |= CREATE_NEW_CONSOLE;
                    } else {
                            dwCreationFlags |= DETACHED_PROCESS;
                    }
               
                    // recopy the image name to the temp buffer since it was modified
                    // (i.e. lowercased) for the previous comparison.

                    lstrcpy (szTempBuffer, pArg->szCmdFileName) ;
                    iStrLen = lstrlen (szTempBuffer) ;

                    // now add on the alert text preceded with a space char
                    szTempBuffer [iStrLen] = TEXT(' ') ;
                    iStrLen++ ;
                    lstrcpy (&szTempBuffer[iStrLen], szCommandString) ;

                    if( pArg->hUserToken != NULL ){
                        bStatus = CreateProcessAsUser (
                            pArg->hUserToken,
                            NULL,
                            szTempBuffer,
                            NULL, NULL, FALSE,
                            dwCreationFlags,
                            NULL,
                            NULL,
                            &si,
                            &pi);
                    } else {
                        bStatus = CreateProcess (
                            NULL,
                            szTempBuffer,
                            NULL, NULL, FALSE,
                            dwCreationFlags,
                            NULL,
                            NULL,
                            &si,
                            &pi);
                    }

                    SetErrorMode(lErrorMode);
                
                    if (bStatus) {
                        dwStatus = ERROR_SUCCESS;
                        if ( NULL != pi.hThread && INVALID_HANDLE_VALUE != pi.hThread ) {
                            CloseHandle(pi.hThread);
                            pi.hThread = NULL;
                        }
                        if ( NULL != pi.hProcess && INVALID_HANDLE_VALUE != pi.hProcess ) {
                            CloseHandle(pi.hProcess);
                            pi.hProcess = NULL;
                        }
                    
                    } else {
                        dwStatus = GetLastError();
                    }
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            
                if ( ERROR_SUCCESS != dwStatus ) { 

                    szStringArray[0] = szTempBuffer;
                    szStringArray[1] = pArg->szQueryName;
                    szStringArray[2] = FormatEventLogMessage(dwStatus);

                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_LOG_CMD_FAIL,
                        NULL,
                        3,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&dwStatus );

                    pArg->dwCmdFileFailure = dwStatus;
                }
                
                if (szCommandString != NULL) G_FREE(szCommandString);
                if (szTempBuffer != NULL) G_FREE(szTempBuffer);
                
            }
        } else {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

DWORD
GetQueryKeyName (
    IN  LPCTSTR  szQueryName,
    OUT LPTSTR   szQueryKeyName,
    IN  DWORD    dwQueryKeyNameLen )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY    hKeyLogQueries = NULL;
    HKEY    hKeyThisLogQuery = NULL;
    DWORD   dwQueryIndex;
    TCHAR   szQueryNameBuffer[MAX_PATH+1];
    DWORD   dwQueryNameBufferSize;
    TCHAR   szQueryKeyNameBuffer[MAX_PATH+1];            
    TCHAR   szQueryClassBuffer[MAX_PATH+1];
    DWORD   dwQueryClassBufferSize;
    LPTSTR  szCollectionName = NULL;            
    UINT    uiCollectionNameLen = 0;            
    LPTSTR  szStringArray[2];

    assert ( 0 < lstrlen ( szQueryName ) );

    if ( NULL != szQueryName 
            && NULL != szQueryKeyName ) {
        if ( 0 < lstrlen ( szQueryName ) 
            && 0 < dwQueryKeyNameLen ) {

            // Note:  This method does not reallocate buffer or return
            // actual buffer size required.

            memset ( szQueryKeyName, 0, dwQueryKeyNameLen * sizeof (TCHAR) );

            dwStatus = OpenLogQueriesKey (
                            KEY_READ,
                            (PHKEY)&hKeyLogQueries);

            if (dwStatus != ERROR_SUCCESS) {
                // unable to read the log query information from the registry
                dwStatus = GetLastError();
                ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SMLOG_UNABLE_OPEN_LOG_QUERY,
                        NULL,
                        0,
                        0,
                        NULL,
                        NULL);
            } else {

                // Enumerate the queries in the registry.
                dwQueryIndex = 0;
                *szQueryNameBuffer = 0;
                dwQueryNameBufferSize = MAX_PATH+1;
                *szQueryClassBuffer = 0;
                dwQueryClassBufferSize = MAX_PATH+1;

                while ((dwStatus = RegEnumKeyEx (
                    hKeyLogQueries,
                    dwQueryIndex,
                    szQueryNameBuffer,
                    &dwQueryNameBufferSize,
                    NULL,
                    szQueryClassBuffer,
                    &dwQueryClassBufferSize,
                    NULL)) != ERROR_NO_MORE_ITEMS) 
                {
                    // open this key
                    dwStatus = RegOpenKeyEx (
                        hKeyLogQueries,
                        szQueryNameBuffer,
                        0L,
                        KEY_READ,
                        (PHKEY)&hKeyThisLogQuery);

                    if (dwStatus == ERROR_SUCCESS) {
                        if ( 0 == lstrcmpi ( szQueryNameBuffer, szQueryName ) ) {
                            if ( dwQueryKeyNameLen > (DWORD)lstrlen ( szQueryName ) ) {
                                lstrcpyn ( szQueryKeyName, szQueryName, min (MAX_PATH, lstrlen (szQueryName) + 1 ) );
                                break;
                            }
                        } else {
                            dwStatus = SmReadRegistryIndirectStringValue (
                                        hKeyThisLogQuery,
                                        L"Collection Name",
                                        NULL,
                                        &szCollectionName,
                                        &uiCollectionNameLen );
            
                            if ( NULL != szCollectionName ) {
                                if ( 0 < lstrlen(szCollectionName) ) {
                                    if ( 0 == lstrcmpi ( szCollectionName, szQueryName ) ) {
                                        if ( dwQueryKeyNameLen > (DWORD)lstrlen ( szQueryNameBuffer ) ) {
                                            lstrcpyn ( szQueryKeyName, szQueryNameBuffer, min (MAX_PATH, lstrlen (szQueryNameBuffer) + 1 ) );
                                            break;
                                        }
                                    }
                                }
                                G_FREE ( szCollectionName );
                                szCollectionName = NULL;
                                uiCollectionNameLen = 0;
                            }
                        }
                    }
                    if ( NULL != hKeyThisLogQuery ) {
                        RegCloseKey ( hKeyThisLogQuery );
                        hKeyThisLogQuery = NULL;
                    }
                    // prepare for next loop
                    dwStatus = ERROR_SUCCESS;
                    dwQueryIndex++;
                    *szQueryNameBuffer = 0;
                    dwQueryNameBufferSize = MAX_PATH;
                    *szQueryClassBuffer = 0;
                    dwQueryClassBufferSize = MAX_PATH;
                } // end enumeration of log queries
            }

            if ( ERROR_NO_MORE_ITEMS == dwStatus ) {
                dwStatus = ERROR_SUCCESS;
            }
        } else {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( NULL != hKeyLogQueries ) {
        RegCloseKey (hKeyLogQueries );
    }

    return dwStatus;
}


DWORD 
Configure ( void ) 
{
    DWORD   dwStatus;
    HKEY    hKeyLogQueries = NULL;
    HKEY    hKeyThisLogQuery = NULL;
    DWORD   dwQueryIndex;
    TCHAR   szQueryNameBuffer[MAX_PATH+1];
    DWORD   dwQueryNameBufferSize;
    TCHAR   szQueryKeyNameBuffer[MAX_PATH+1];
    TCHAR   szQueryClassBuffer[MAX_PATH+1];
    DWORD   dwQueryClassBufferSize;
    LPTSTR  szCollectionName = NULL;            
    UINT    uiCollectionNameLen = 0;            
    LPTSTR  szStringArray[2];

    __try {

        // Open each query in the registry
        dwStatus = OpenLogQueriesKey (
                        KEY_READ,
                        (PHKEY)&hKeyLogQueries);

        if (dwStatus != ERROR_SUCCESS) {
            if (dwStatus == ERROR_FILE_NOT_FOUND) {
                // no logs nor alerts settings, bail out quietly
                //
                dwStatus = ERROR_SUCCESS;
            }
            else {
                // unable to read the log query information from the registry
                dwStatus = GetLastError();
                ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SMLOG_UNABLE_OPEN_LOG_QUERY,
                        NULL,
                        0,
                        0,
                        NULL,
                        NULL);
            }
        } else {

            // enumerate and restart or start the queries in the registry
            dwQueryIndex = 0;
            *szQueryNameBuffer = 0;
            dwQueryNameBufferSize = MAX_PATH+1;
            *szQueryClassBuffer = 0;
            dwQueryClassBufferSize = MAX_PATH+1;

            while ((dwStatus = RegEnumKeyEx (
                hKeyLogQueries,
                dwQueryIndex,
                szQueryNameBuffer,
                &dwQueryNameBufferSize,
                NULL,
                szQueryClassBuffer,
                &dwQueryClassBufferSize,
                NULL)) != ERROR_NO_MORE_ITEMS) {

                // open this key
                dwStatus = RegOpenKeyEx (
                    hKeyLogQueries,
                    szQueryNameBuffer,
                    0L,
                    KEY_READ | KEY_WRITE,
                    (PHKEY)&hKeyThisLogQuery);

                if (dwStatus == ERROR_SUCCESS) {

                    // update the service status
                    ssSmLogStatus.dwCheckPoint++;
                    SetServiceStatus (hSmLogStatus, &ssSmLogStatus);            

                    if ( 0 < lstrlen(szQueryNameBuffer) ) {
                        lstrcpyn ( 
                            szQueryKeyNameBuffer, 
                            szQueryNameBuffer, 
                            min(MAX_PATH, lstrlen(szQueryNameBuffer)+1 ) );
                    }

                    dwStatus = SmReadRegistryIndirectStringValue (
                                hKeyThisLogQuery,
                                L"Collection Name",
                                NULL,
                                &szCollectionName,
                                &uiCollectionNameLen );
            
                    if ( NULL != szCollectionName ) {
                        if ( 0 < lstrlen(szCollectionName) ) {
                            lstrcpyn ( 
                                szQueryNameBuffer, 
                                szCollectionName, 
                                min(MAX_PATH, lstrlen(szCollectionName)+1 ) );
                        }
                        G_FREE ( szCollectionName );
                        szCollectionName = NULL;
                        uiCollectionNameLen = 0;
                    }

                    dwStatus = ConfigureQuery (
                                hKeyThisLogQuery,
                                szQueryKeyNameBuffer,
                                szQueryNameBuffer );
                    // hKeyThisLogQuery is stored in the Query data structure.
            
                } else {
                    szStringArray[0] = szQueryNameBuffer;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_LOG_QUERY,
                        NULL,
                        1,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&dwStatus);
                }

                // prepare for next loop
                dwStatus = ERROR_SUCCESS;
                dwQueryIndex++;
                *szQueryNameBuffer = 0;
                dwQueryNameBufferSize = MAX_PATH;
                *szQueryClassBuffer = 0;
                dwQueryClassBufferSize = MAX_PATH;
            } // end enumeration of log queries
        }

        if ( ERROR_NO_MORE_ITEMS == dwStatus ) {
            dwStatus = ERROR_SUCCESS;
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {


        dwStatus = SMLOG_THREAD_FAILED;  
    }

    if ( NULL != hKeyLogQueries ) {
        RegCloseKey (hKeyLogQueries );
    }

    return dwStatus;
}


void SysmonLogServiceControlHandler(
    IN  DWORD dwControl
)
{
    PLOG_QUERY_DATA    pQuery;
    DWORD dwStatus;

    switch (dwControl) {

    case SERVICE_CONTROL_SYNCHRONIZE:
        EnterConfigure();
        dwStatus = Configure ();
        ExitConfigure();
        if ( ERROR_SUCCESS == dwStatus )
            break;
        // If not successful, fall through to shutdown.
        // Errors already logged.

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        // stop logging & close queries and files
        // set stop event for all running thread
        
        LockQueryData();

        ssSmLogStatus.dwCurrentState    = SERVICE_STOP_PENDING;
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
        
        pQuery = pFirstQuery;

        while (pQuery != NULL) {
            SetEvent (pQuery->hExitEvent);
            pQuery = pQuery->next;
        }

        UnlockQueryData();
        break;

    case SERVICE_CONTROL_PAUSE:
        // stop logging, close queries and files
        // not supported, yet
        break;
    case SERVICE_CONTROL_CONTINUE:
        // reload ration and restart logging
        // not supported, yet
        break;
    case SERVICE_CONTROL_INTERROGATE:
        // update current status
    default:
        // report to event log that an unrecognized control
        // request was received.
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
    }
}


void
SysmonLogServiceStart (
    IN  DWORD   argc,
    IN  LPTSTR  *argv
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwQueryIndex;
    BOOL    bInteractive = FALSE;
    BOOL    bLogQueriesKeyExists = TRUE;

    if ((argc == 1) && (*argv[0] == 'I')) bInteractive = TRUE;

#if _DEBUG_OUTPUT        
    if ( NULL != hEventLog ) {
        ReportEvent (hEventLog,
            EVENTLOG_INFORMATION_TYPE,
            0,
            SMLOG_DEBUG_STARTING_SERVICE,
            NULL,
            0,
            0,
            NULL,
            NULL);
    }
#endif
    if (!bInteractive) {
        ssSmLogStatus.dwServiceType       = SERVICE_WIN32_OWN_PROCESS;
        ssSmLogStatus.dwCurrentState      = SERVICE_START_PENDING;
        ssSmLogStatus.dwControlsAccepted  = SERVICE_ACCEPT_STOP |
    //        SERVICE_ACCEPT_PAUSE_CONTINUE |
            SERVICE_ACCEPT_SHUTDOWN;
        ssSmLogStatus.dwWin32ExitCode = 0;
        ssSmLogStatus.dwServiceSpecificExitCode = 0;
        ssSmLogStatus.dwCheckPoint = 0;
        ssSmLogStatus.dwWaitHint = 1000;

        hSmLogStatus = RegisterServiceCtrlHandler (
            (LPCTSTR)TEXT("SysmonLog"), SysmonLogServiceControlHandler);

        if (hSmLogStatus == (SERVICE_STATUS_HANDLE)0) {
            dwStatus = GetLastError();
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                SMLOG_UNABLE_REGISTER_HANDLER,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&dwStatus);
            // this is fatal so bail out
        } 
#if _DEBUG_OUTPUT        
        else {
            if ( NULL != hEventLog ) {
                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SMLOG_DEBUG_HANDLER_REGISTERED,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL);
            }
        }
#endif 
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        InitializeCriticalSection ( &QueryDataLock );
        InitializeCriticalSection ( &ConfigurationLock );

#if _DEBUG_OUTPUT
        ssSmLogStatus.dwCurrentState    = SERVICE_RUNNING;
        ssSmLogStatus.dwCheckPoint++;
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
#endif    
        dwStatus = ClearQueryRunStates();
#if _DEBUG_OUTPUT        
        if ( NULL != hEventLog ) {
            ReportEvent (hEventLog,
                EVENTLOG_INFORMATION_TYPE,
                0,
                SMLOG_DEBUG_CLEAR_RUN_STATES,
                NULL,
                sizeof(DWORD),
                0,
                NULL,
                (LPVOID)&dwStatus);
        }
#endif 
        // Continue even if query run state error, unless
        // the Log Queries key is missing or not accessible.
        if ( SMLOG_UNABLE_OPEN_LOG_QUERY == dwStatus ) {
            bLogQueriesKeyExists = FALSE;
            // Sleep long enough for event to be written to event log.
            Sleep(500);
            if (!bInteractive) {
                ssSmLogStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                // Use status mask so that error matches the code in the application log.
                ssSmLogStatus.dwServiceSpecificExitCode = (SMLOG_UNABLE_OPEN_LOG_QUERY & STATUS_MASK);
            }
        } else {
            dwStatus = ERROR_SUCCESS;

            // Continue on error.
            LoadDefaultLogFileFolder();

            // Ignore PDH errors.  The only possible error is that the default 
            // data source has already been set for this process.
            // Set the default for the service to DATA_SOURCE_REGISTRY
            dwStatus = PdhSetDefaultRealTimeDataSource ( DATA_SOURCE_REGISTRY );


#if _DEBUG_OUTPUT        
            if ( NULL != hEventLog ) {
                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SMLOG_DEBUG_DEFAULT_FOLDER_LOADED,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL);
            }
#endif 
        
            // Continue on error.
            LoadPdhLogUpdateSuccess();

            hNewQueryEvent = CreateEvent ( NULL, TRUE, FALSE, NULL );

            if ( NULL == hNewQueryEvent ) {

                // Unable to create new query configuration event.
                dwStatus = GetLastError();
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_CREATE_CONFIG_EVENT,
                    NULL,
                    0,
                    sizeof(DWORD),
                    NULL,
                    (LPVOID)&dwStatus);
                // this is fatal so bail out
                if (!bInteractive) {
                    // Sleep long enough for event to be written to event log.
                    Sleep(500);
                    ssSmLogStatus.dwWin32ExitCode = dwStatus;
                }
            }
#if _DEBUG_OUTPUT        
            else {
                if ( NULL != hEventLog ) {
                    ReportEvent (hEventLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        SMLOG_DEBUG_CONFIG_EVENT_CREATED,
                        NULL,
                        0,
                        0,
                        NULL,
                        0);
                }
            }
#endif 

            if ( ( ERROR_SUCCESS == dwStatus ) && !bInteractive) {
                // Thread synchronization mechanisms now created,
                // so set status to Running.
                ssSmLogStatus.dwCurrentState = SERVICE_RUNNING;
                ssSmLogStatus.dwCheckPoint   = 0;
                SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
            }


#if _IMPLEMENT_WMI
            if ( ERROR_SUCCESS == dwStatus ) {
// Disable 64-bit warning
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4152 )

                dwStatus = WmiNotificationRegistration(
                        (const LPGUID) & TraceErrorGuid,
                        TRUE,
                        TraceNotificationCallback,
                        0,
                        NOTIFICATION_CALLBACK_DIRECT);
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
            }
#endif

            // Set up the queries and start threads.    

            if ( ERROR_SUCCESS == dwStatus && bLogQueriesKeyExists) {
                EnterConfigure();
                dwStatus = Configure ();
                ExitConfigure();
            }

            if ( NULL == pFirstQuery ) {
                // Nothing to do.  Stop the service.
                if (!bInteractive) {
                    ssSmLogStatus.dwCurrentState = SERVICE_STOP_PENDING;
                    SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
                }
            } else if ( ERROR_SUCCESS == dwStatus ) {

                // Loop in WaitForMultipleObjects.  When any
                // query is signaled, deallocate that query data block
                // and close its handles.  

                while ( TRUE ) {
                    BOOL bStatus;

                    LockQueryData();

                    // About to reconfigure the Wait array, so clear the event.
                    bStatus = ResetEvent ( hNewQueryEvent );

                    if ( NULL == pFirstQuery ) {

                        if (!bInteractive) {
                            ssSmLogStatus.dwCurrentState    = SERVICE_STOP_PENDING;
                            SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
                        }

                        UnlockQueryData();
                        break;
                    } else {
                        DWORD dwIndex = 0;  
                        DWORD dwWaitStatus;
                        PLOG_QUERY_DATA pQuery;

                        assert ( 0 < dwActiveSessionCount );

                        G_ZERO( arrSessionHandle, sizeof( HANDLE ) * ( dwActiveSessionCount + 1) );
            
                        // The first element is the global hNewQueryEvent to signal new sessions.
                        arrSessionHandle[dwIndex] = hNewQueryEvent;
                        dwIndex++;

                        for ( pQuery = pFirstQuery;
                                NULL != pQuery;
                                pQuery = pQuery->next ) {

                            assert ( NULL != pQuery->hThread );
                            if ( NULL != pQuery->hExitEvent && NULL != pQuery->hThread ) {
                                arrSessionHandle[dwIndex] = pQuery->hThread;
                                dwIndex++;
                                assert ( dwIndex <= dwActiveSessionCount + 1 );
                            }
                        }
                
                        UnlockQueryData();
                        // xxx handle error
                        dwWaitStatus = WaitForMultipleObjects (
                                        dwIndex,                
                                        arrSessionHandle, 
                                        FALSE,
                                        INFINITE );    

                        // when here, either a new query has been started, or
                        // at least one logging thread or has terminated so the
                        // memory can be released.
                        dwQueryIndex = dwWaitStatus - WAIT_OBJECT_0;

                        // release the dynamic memory if the wait object is not the StartQuery event.
                        if ( 0 < dwQueryIndex && dwQueryIndex < dwIndex ) {
                            SetStoppedStatus( GetQueryDataPtr( arrSessionHandle[dwQueryIndex] ) );
                            RemoveAndFreeQueryData( arrSessionHandle[dwQueryIndex] );
                        }
                    }
                } // End while 
            }

#if _IMPLEMENT_WMI
// Disable 64-bit warning
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4152 )
            WmiNotificationRegistration(
                    (const LPGUID) & TraceErrorGuid,
                    FALSE,
                    TraceNotificationCallback,
                    0,
                    NOTIFICATION_CALLBACK_DIRECT);
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
#endif

            if ( NULL != hNewQueryEvent ) {
                CloseHandle ( hNewQueryEvent );
                hNewQueryEvent = NULL;
            }
        }

        DeleteCriticalSection ( &QueryDataLock );
        DeleteCriticalSection ( &ConfigurationLock );
    }

    if (!bInteractive) {
        // Update the service status
        ssSmLogStatus.dwCurrentState    = SERVICE_STOPPED;
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
    }

    if ( NULL != arrPdhDataCollectSuccess ) { 
        G_FREE ( arrPdhDataCollectSuccess );
        arrPdhDataCollectSuccess = NULL;
        iPdhDataCollectSuccessCount = 0;
    }

    if (hEventLog != NULL) { 
        DeregisterEventSource ( hEventLog );
        hEventLog = NULL;
    }

    return;
}


int
__cdecl main (
    int argc,
    char *argv[])
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    DWORD    dwStatus = ERROR_SUCCESS;
    BOOL     bInteractive = FALSE;

    SERVICE_TABLE_ENTRY    DispatchTable[] = {
        {(LPTSTR)TEXT("SysmonLog"),    SysmonLogServiceStart    },
        {NULL,                    NULL                    }
    };

    hEventLog = RegisterEventSource (NULL, (LPCTSTR)TEXT("SysmonLog"));
#if _DEBUG_OUTPUT
    if ( NULL != hEventLog ) {
        ReportEvent (hEventLog,
            EVENTLOG_INFORMATION_TYPE,
            0,
            SMLOG_DEBUG_EVENT_SOURCE_REGISTERED,
            NULL,
            0,
            0,
            NULL,
            NULL);
    }
#endif

    hModule = (HINSTANCE) GetModuleHandle(NULL);

    if (argc > 1) {
        if ((argv[1][0] == '-') || (argv[1][0] == '/')) {
            if ((argv[1][1] == 'i') || (argv[1][1] == 'I')) {
                bInteractive = TRUE;
            }
        }
    }

    if (bInteractive) {
        DWORD   dwArgs = 1;
        LPTSTR  szArgs[1];
        szArgs[0] = (LPTSTR)TEXT("I");
        SysmonLogServiceStart (dwArgs, szArgs);      
    } else {
        if (!StartServiceCtrlDispatcher (DispatchTable)) {
            dwStatus = GetLastError();
            // log failure to event log
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                SMLOG_UNABLE_START_DISPATCHER,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&dwStatus);
        } 
#if _DEBUG_OUTPUT
        else {
            ReportEvent (hEventLog,
                EVENTLOG_INFORMATION_TYPE,
                0,
                SMLOG_DEBUG_SERVICE_CTRL_DISP_STARTED,
                NULL,
                0,
                0,
                NULL,
                NULL);
        }
#endif
    }
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\about.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       about.h
//
//  Contents:   definition of CAbout, CSCEAbout, CSCMAbout, CSSAbout, 
//              CRSOPAbout & CLSAbout
//
//----------------------------------------------------------------------------

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

// About for "SCE" snapin
class CAbout :
   public ISnapinAbout,
   public CComObjectRoot
{
BEGIN_COM_MAP(CAbout)
   COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:


// ISnapinAbout
   STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
   STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
   STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
   STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
   STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
   // The following data members MUST be initialized by the constructor
   // of the derived class.
   UINT m_uIdStrDescription;     // Resource Id of the description
   UINT m_uIdStrProvider;     // Resource Id of the provider (ie, Microsoft Corporation)
   UINT m_uIdStrVersion;         // Resource Id of the version of the snapin
   UINT m_uIdIconImage;       // Resource Id for the icon/image of the snapin
   UINT m_uIdBitmapSmallImage;
   UINT m_uIdBitmapSmallImageOpen;
   UINT m_uIdBitmapLargeImage;
   COLORREF m_crImageMask;

};

// About for "SCE" snapin
class CSCEAbout :
   public CAbout,
   public CComCoClass<CSCEAbout, &CLSID_SCEAbout>

{
   public:
   CSCEAbout();

   DECLARE_REGISTRY(CSCEAbout, _T("Wsecedit.SCEAbout.1"), _T("Wsecedit.SCEAbout.1"), IDS_SCE_DESC, THREADFLAGS_BOTH)
};


// About for "SCM" snapin
class CSCMAbout :
   public CAbout,
   public CComCoClass<CSCMAbout, &CLSID_SCMAbout>

{
   public:
   CSCMAbout();

   DECLARE_REGISTRY(CSCMAbout, _T("Wsecedit.SCMAbout.1"), _T("Wsecedit.SCMAbout.1"), IDS_SAV_DESC, THREADFLAGS_BOTH)
};


// About for "Security Settings" snapin
class CSSAbout :
   public CAbout,
   public CComCoClass<CSSAbout, &CLSID_SSAbout>

{
   public:
   CSSAbout();

   DECLARE_REGISTRY(CSSAbout, _T("Wsecedit.SSAbout.1"), _T("Wsecedit.SSAbout.1"), IDS_SS_DESC, THREADFLAGS_BOTH)
};

// About for "RSOP Security Settings" snapin
class CRSOPAbout :
   public CAbout,
   public CComCoClass<CRSOPAbout, &CLSID_RSOPAbout>

{
   public:
   CRSOPAbout();

   DECLARE_REGISTRY(CRSOPAbout, _T("Wsecedit.RSOPAbout.1"), _T("Wsecedit.RSOPAbout.1"), IDS_RSOP_DESC, THREADFLAGS_BOTH)
};


// About for "Local Security Settings" snapin
class CLSAbout :
   public CAbout,
   public CComCoClass<CLSAbout, &CLSID_LSAbout>

{
   public:
   CLSAbout();

   DECLARE_REGISTRY(CLSAbout, _T("Wsecedit.LSAbout.1"), _T("Wsecedit.LSAbout.1"), IDS_LS_DESC, THREADFLAGS_BOTH)
};


#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\achoice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       achoice.h
//
//  Contents:   definition of CAttrChoice
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_ACHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrChoice dialog

class CAttrChoice : public CAttribute
{
// Construction
public:
   CAttrChoice();   // standard constructor
   virtual void Initialize(CResult * pResult);
// Dialog Data
   //{{AFX_DATA(CAttrChoice)
	enum { IDD = IDD_ATTR_REGCHOICES };
   CComboBox   m_cbChoices;
   CString  m_Current;
	//}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CAttrChoice)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CAttrChoice)
   afx_msg void OnSelchangeChoices();
   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   PREGCHOICE m_pChoices;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\achoice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       achoice.cpp
//
//  Contents:   implementation of CAttrChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "AChoice.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrChoice dialog


CAttrChoice::CAttrChoice()
: CAttribute(IDD), m_pChoices(NULL)
{
   //{{AFX_DATA_INIT(CAttrChoice)
   m_Current = _T("");
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a237HelpIDs;
   m_uTemplateResID = IDD;
}


void CAttrChoice::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAttrChoice)
   DDX_Control(pDX, IDC_CHOICES, m_cbChoices);
   DDX_Text(pDX, IDC_CURRENT, m_Current);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrChoice, CAttribute)
   //{{AFX_MSG_MAP(CAttrChoice)
   ON_CBN_SELCHANGE(IDC_CHOICES, OnSelchangeChoices)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrChoice message handlers

void CAttrChoice::OnSelchangeChoices()
{
   CWnd *cwndOK;
   SetModified(TRUE);

/*
   cwndOK = GetDlgItem(IDOK);

   if (cwndOK) {
      cwndOK->EnableWindow( CB_ERR != m_cbChoices.GetCurSel() );
   }
*/
}

void CAttrChoice::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pChoices = pResult->GetRegChoices();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }

   prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetSetting());
   PREGCHOICE pChoice;
   DWORD dwSetting = 0; //Raid #395353, 5/16/2001

   if( m_pChoices ) //Raid #404000
      dwSetting = m_pChoices->dwValue;  
   if( prv->Value )
      dwSetting = (DWORD)_ttoi(prv->Value);

   pChoice = m_pChoices;
   while(pChoice) {
      if (dwSetting == pChoice->dwValue) {
         m_Current = pChoice->szName;
         break;
      }
      pChoice = pChoice->pNext;
   }

   pResult->GetDisplayName( NULL, m_Current, 2 );

}

BOOL CAttrChoice::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PREGCHOICE pChoice = m_pChoices;
   int nIndex = 0;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

   ASSERT(prv);
   ASSERT(pChoice);
   if (!prv || !pChoice) {
      return TRUE;
   }

   AddUserControl(IDC_CHOICES);

   DWORD dwBase = pChoice->dwValue; //Raid #404000
   if (prv->Value) {
      dwBase = (DWORD)_ttoi(prv->Value);
   }
   while(pChoice) {
      m_cbChoices.InsertString(nIndex,pChoice->szName);
      if (dwBase == pChoice->dwValue) {
         m_cbChoices.SetCurSel(nIndex);
      }
      m_cbChoices.SetItemData(nIndex++,pChoice->dwValue);
      pChoice = pChoice->pNext;
   }

   EnableUserControls(m_bConfigure);
   OnSelchangeChoices();

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      int nIndex = 0;
      int status = 0;
      DWORD rc=0;

      UpdateData(TRUE);
      DWORD dw = 0;
      if (!m_bConfigure) 
         dw = SCE_NO_VALUE;
      else 
      {
         nIndex = m_cbChoices.GetCurSel();
         if (CB_ERR != nIndex)
            dw = (DWORD) m_cbChoices.GetItemData(nIndex);
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      if ( prv ) 
      {
         PWSTR pTmp=NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), dw);
            pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( pTmp )
               wcscpy(pTmp,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               // if this happens, nothing else is probably running so just fail
               rc = ERROR_NOT_ENOUGH_MEMORY;
            }
         }

         if ( rc == ERROR_SUCCESS ) 
         {
             if ( prv->Value )
                LocalFree(prv->Value);
             
             prv->Value = pTmp;

             status = CEditTemplate::ComputeStatus(
                                        (PSCE_REGISTRY_VALUE_INFO)m_pData->GetBase(),
                                        (PSCE_REGISTRY_VALUE_INFO)m_pData->GetSetting());
             if ( m_pData->GetBaseProfile() )
                m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);
             
             m_pData->SetStatus(status);
             m_pData->Update(m_pSnapin);

         } 
         else
            return FALSE;
      }
   }

   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\addgrp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addgrp.cpp
//
//  Contents:   implementation of CSCEAddGroup
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "AddGrp.h"
#include "snapmgr.h"
#include "GetUser.h"
#include "resource.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSCEAddGroup dialog


CSCEAddGroup::CSCEAddGroup(CWnd* pParent /*=NULL*/)
    : CHelpDialog(a212HelpIDs, IDD, pParent)
{
   m_dwFlags = SCE_SHOW_GROUPS | SCE_SHOW_ALIASES | SCE_SHOW_SINGLESEL;
   m_pnlGroup = NULL;
   m_pKnownNames = NULL;
   m_fCheckName = TRUE;
   //{{AFX_DATA_INIT(CSCEAddGroup)
   // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

CSCEAddGroup::~CSCEAddGroup()
{
   SceFreeMemory( m_pnlGroup, SCE_STRUCT_NAME_LIST );
   m_pnlGroup = NULL;

   SceFreeMemory( m_pKnownNames, SCE_STRUCT_NAME_LIST );
   m_pKnownNames = NULL;
}

void CSCEAddGroup::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSCEAddGroup)
   // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}


DWORD CSCEAddGroup::GetModeFlags() {

   if (m_dwModeBits & MB_GROUP_POLICY) {
      return (SCE_SHOW_SCOPE_DOMAIN | SCE_SHOW_SCOPE_DIRECTORY);
   }
   if (m_dwModeBits & MB_LOCAL_POLICY) {
      return (SCE_SHOW_SCOPE_ALL | SCE_SHOW_DIFF_MODE_OFF_DC);
   }
   if (m_dwModeBits & MB_ANALYSIS_VIEWER) {
      return (SCE_SHOW_SCOPE_ALL | SCE_SHOW_DIFF_MODE_OFF_DC);
   }
   if (m_dwModeBits & MB_TEMPLATE_EDITOR) {
      return (SCE_SHOW_SCOPE_ALL);
   }

   return 0;
}


BEGIN_MESSAGE_MAP(CSCEAddGroup, CHelpDialog)
    //{{AFX_MSG_MAP(CSCEAddGroup)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_LOG_FILE, OnChangeLogFile)
    ON_NOTIFY( EN_MSGFILTER, IDC_LOG_FILE, OnEditMsgFilter )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
/////////////////////////////////////////////////////////////////////////////
// CSCEAddGroup message handlers

/*-------------------------------------------------------------------------------------
CSCEAddGroup::IsKnownAccount

Synopsis:   This functions searches throught m_pKnownNames and does a case
            insensitive match on [pszAccount].  If [pszAccount] exists in the
            array then this function returns TRUE.

Arguments:  [pszAccount]   - The account to look for.

Returns:    TRUE if [pszAccount] is in the list false otherwise

-------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::IsKnownAccount( LPCTSTR pszAccount )
{
   if ( pszAccount == NULL ) return FALSE;

   PSCE_NAME_LIST pNew = m_pKnownNames;
   while(pNew){
      if( !lstrcmpi( pszAccount, pNew->Name ) ){
         return TRUE;
      }
      pNew = pNew->Next;
   }
   return FALSE;
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::CleanName

Synopsis:   Removes leading and trailing spaces from the string.  This function
            places the string into the same buffer as is passed in.

Arguments:  [pszAccount]   - The buffer to clean.

------------------------------------------------------------------------------------*/
void CSCEAddGroup::CleanName( LPTSTR pszAccount )
{
   if ( pszAccount == NULL ) return;

   int i = 0;
   while( IsSpace( pszAccount[i] ) ){
      i++;
   }

   int iLen = lstrlen(pszAccount) - 1;
   while(iLen > i && IsSpace( pszAccount[iLen] ) ){
      iLen--;
   }

   iLen -= i;
   while(iLen >= 0){
      *pszAccount = *(pszAccount + i);
      pszAccount++;
      iLen--;
   }
   *pszAccount = 0;

}

/*------------------------------------------------------------------------------------
CSCEAddGroup::AddKnownAccount

Synopsis:   Adds a string to the Known accounts link list.  This list is later
            used to underline strings that are contained in this list

Arguments:  [pszAccount]   - The account to remeber.

------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::AddKnownAccount( LPCTSTR pszAccount )
{
   PSCE_NAME_LIST pNew = NULL;

   if ( pszAccount == NULL ) return FALSE;

   if(IsKnownAccount( pszAccount ) ){
      return TRUE;
   }
   pNew = (PSCE_NAME_LIST)LocalAlloc(0, sizeof(SCE_NAME_LIST));
   if(!pNew){
      return FALSE;
   }

   pNew->Name = (LPTSTR)LocalAlloc( 0, sizeof(TCHAR) * (1 + lstrlen(pszAccount)) );
   if(!pNew->Name){
      LocalFree(pNew);
      return FALSE;
   }
   lstrcpy(pNew->Name, pszAccount);

   pNew->Next = m_pKnownNames;
   m_pKnownNames = pNew;

   return TRUE;
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::OnBrowse

Synopsis:   Calls the CGetUser dialog box to create the object picker and display
            real choices.  Since we wan't to underline all names returned by
            object picker, this function also places all names returned by
            CGetUser into the known accounts array.

------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnBrowse()
{
   CGetUser gu;
   BOOL bFailed = TRUE;

   //
   // Get the rich edit control.
   //
   CRichEditCtrl *ed = (CRichEditCtrl *)GetDlgItem(IDC_LOG_FILE);

   if ( ed ) {

       //
       // Always multi select mode.
       //
       m_dwFlags &= ~SCE_SHOW_SINGLESEL;
       if (gu.Create( GetSafeHwnd(), m_dwFlags | GetModeFlags()) ) {
          //
          // Set the dialog text.
          // pAccount is a pointer to a member in getuser.cpp which will be freed there
          //
          PSCE_NAME_LIST pAccount = gu.GetUsers();

          //
          // Set the charformat, because we need to set it not to underline
          // things that we will paste into the edit control.
          //
          CHARFORMAT cf;
          ZeroMemory(&cf, sizeof( CHARFORMAT ));
          cf.cbSize = sizeof(CHARFORMAT);
          cf.dwMask = CFM_UNDERLINE;

          //
          // Enumerate through the account list and past them into the edit control.
          //
          int iLen;
          bFailed = FALSE;

          while (pAccount) {
             if(pAccount->Name){
                iLen = ed->GetTextLength();
                ed->SetSel( iLen, iLen);

                if(iLen){
                   ed->SetSelectionCharFormat( cf );
                   ed->ReplaceSel( L";" );
                   iLen ++;
                }

                if ( AddKnownAccount( pAccount->Name ) ) {

                    ed->ReplaceSel( pAccount->Name );

                } else {
                    bFailed = TRUE;
                }
             }
             pAccount = pAccount->Next;
          }
          //
          // Everything we pasted will be underlined.
          //
          UnderlineNames();

       }
   }

   if ( bFailed ) {
       //
       // something is wrong creating the object picker or pasting the account into the control
       // popup a message
       //

       CString strErr;
       strErr.LoadString( IDS_ERR_INVALIDACCOUNT );

       AfxMessageBox( strErr );
   }
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::OnInitDialog()

Synopsis:   Change the text for title and group static box.  To "Add Group" and
            "Group"

-------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::OnInitDialog()
{
   CDialog::OnInitDialog();
   CString str;

   //
   // Set the window title.  If the caller has already set the title then
   // we don't need to load the resource.
   //
   if(m_sTitle.IsEmpty()){
      // Set window text of dialog.
      m_sTitle.LoadString(IDS_ADDGROUP_TITLE);
   }

   if(m_sDescription.IsEmpty()){
      m_sDescription.LoadString(IDS_ADDGROUP_GROUP);
   }

   SetWindowText( m_sTitle );

   // Set group static text.
   CWnd *pWnd = GetDlgItem(IDC_STATIC_FILENAME);
   if (pWnd) {
      pWnd->SetWindowText(m_sDescription);
   }

   pWnd = GetDlgItem(IDC_LOG_FILE);
   if ( pWnd )
   {
       pWnd->SendMessage(EM_SETEVENTMASK, 0, ENM_CHANGE | ENM_KEYEVENTS);
       pWnd->SendMessage(EM_LIMITTEXT, 4096, 0); //Raid #271219
   }

   // disable OK button.
   pWnd = GetDlgItem(IDOK);
   if ( pWnd )
       pWnd->EnableWindow( FALSE );

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::OnChangeLogFile()

Synopsis:   Check to see if any text is available in edit control, and disable the
            OK button if no text is available.

-------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnChangeLogFile()
{
   // Enable disable edit OK button depending on edit control content.
   CRichEditCtrl *pWnd = reinterpret_cast<CRichEditCtrl *>(GetDlgItem(IDC_LOG_FILE));
   CString str;

   str.Empty();
   if (pWnd) {
      pWnd->GetWindowText(str);
   }

   CWnd *pControl = GetDlgItem(IDOK);
   if ( pControl )
       pControl->EnableWindow( !str.IsEmpty() );
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::UnderlineNames

Synopsis:   Underlines all names that are in the KnownAccounts list.

-------------------------------------------------------------------------------------*/
void CSCEAddGroup::UnderlineNames()
{
   LONG nStart, nEnd;

   //
   // Get the edit control.
   //
   CRichEditCtrl *pWnd = reinterpret_cast<CRichEditCtrl *>(GetDlgItem(IDC_LOG_FILE));
   if(!pWnd){
      return;
   }

   LPTSTR pszText = NULL;
   int iPos, iLen, i;

   //
   // Retrieve the edit control text.
   //
   iLen = pWnd->GetWindowTextLength();
    pszText = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (2 + iLen) );
   if(!pszText){
      return;
   }

   pWnd->GetWindowText(pszText, iLen+1);
   iPos = 0;

   //
   // Get the current selection (the position of the caret)
   //
   pWnd->GetSel(nStart, nEnd );

   //
   // Hide the window so it doesn't flicker.
   //
   pWnd->SetWindowPos( NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_NOSENDCHANGING);

   for(i = 0; i < iLen + 1; i++){
      //
      // Simi colon deliminated list.
      //
      if( pszText[i] == L';' ){
         pszText[i] = 0;
      }

      if(!pszText[i]){
         //
         // Format known names with underline.
         //
         CHARFORMAT cf;
         cf.cbSize = sizeof( CHARFORMAT );
         cf.dwMask = CFM_UNDERLINE;

         int isUn, ieUn;

         isUn = iPos;
         while( IsSpace(pszText[isUn]) ){
            isUn++;
         }

         ieUn = lstrlen( &(pszText[isUn]) ) - 1 + isUn;
         while( ieUn > 0 && IsSpace( pszText[ieUn] ) ){
            ieUn--;
         }

         //
         // See if we need to underline the name or not.
         //
         CleanName( &(pszText[isUn]) );
         if( IsKnownAccount( &(pszText[isUn]) ) ){
            cf.dwEffects = CFE_UNDERLINE;
         } else {
            cf.dwEffects &= ~CFE_UNDERLINE;
         }

         //
         // Make sure leading space characters aren't underlined.
         //
         if(isUn != iPos && cf.dwEffects & CFE_UNDERLINE){
            pWnd->SetSel( iPos, isUn);
            cf.dwEffects = 0;
            pWnd->SetSelectionCharFormat( cf );
            cf.dwEffects = CFE_UNDERLINE;
         } else {
            isUn = iPos;
         }

         //
         // trailing space characters are also not underlined.
         //
         if(cf.dwEffects & CFE_UNDERLINE){
            pWnd->SetSel(ieUn, i + 1);
            cf.dwEffects = 0;
            pWnd->SetSelectionCharFormat( cf );
            cf.dwEffects = CFE_UNDERLINE;
         } else {
            ieUn = i;
         }

         pWnd->SetSel( isUn, ieUn + 1);
         pWnd->SetSelectionCharFormat( cf );

         iPos = i + 1;
      }
   }

   //
   // Show the window without redrawing.  We will call RedrawWindow to redraw.
   //
   pWnd->SetWindowPos( NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOREDRAW);
   pWnd->RedrawWindow(NULL, NULL, RDW_INVALIDATE);

   //
   // Reset selection.
   //
   pWnd->SetSel(nStart, nEnd);
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::OnEditMsgFilter

Synopsis:   Captures input message events from the RichEdit control.  We want,
            to underline things as the user types them.

Arguments:  [pNM]    -  [in] Pointer to a MSGFILTER structure.
            [pResult]-  [out] Pointer to a LRESULT type.  Always set to 0
------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnEditMsgFilter( NMHDR *pNM, LRESULT *pResult)
{
   *pResult = 0;

#define pmf ((MSGFILTER *)pNM)
   switch( pmf->msg ){
   case WM_LBUTTONUP:
   case WM_KEYUP:
      //
      // If the caret is being moved around in the window then we don't want
      // to proccess the string since it isn't being changed.
      //
      if( pmf->msg == WM_KEYUP && pmf->wParam == VK_RIGHT ||
         pmf->wParam == VK_LEFT || pmf->wParam == VK_UP || pmf->wParam == VK_DOWN){
         break;
      }
      UnderlineNames();
      break;
   }
#undef pmf
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::CSCEAddGroup::OnOK()

Synopsis:   Copy the text the user input into the SCE_NAME_LIST structure.

-------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnOK()
{
   if( !CheckNames() ){
      return;
   }

   CreateNameList( &m_pnlGroup );
   CDialog::OnOK();
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::CreateNameList

Synopsis:   Creates the name list from the edit window.  The function will ensure
            that each name is only in the list once.

Arguments:  [pNameList]   -[out] Pointer a PSCE_NAME_LIST;

Returns:    The number of items added.
------------------------------------------------------------------------------------*/
int CSCEAddGroup::CreateNameList( PSCE_NAME_LIST *pNameList )
{
   if(!pNameList){
      return 0;
   }

   CWnd *pWnd = GetDlgItem(IDC_LOG_FILE);
   LPTSTR pszAccounts = NULL;

   //
   // Retrieve the window text.
   //
   int iLen = 0;
   if (pWnd) {
      iLen = pWnd->GetWindowTextLength();
      if(iLen){
        pszAccounts = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (iLen + 2));
        if(pszAccounts){
           pWnd->GetWindowText( pszAccounts, iLen+1);
        }
      }
   }

   //
   // Create an account name for each string daliminated by a semi colon.
   //
   int iCount = 0;
   if (pszAccounts) {
      LPTSTR pszCur = pszAccounts;
      int Len=0;

      for(int i = 0; i < iLen + 1; i++){
         if( pszAccounts[i] == L';' ){
            pszAccounts[i] = 0;
         }

         if( !pszAccounts[i] ){
            CleanName(pszCur);

            if((Len = lstrlen(pszCur))){
               //
               // Ensure that we don't already have this string in our link list.
               //
               PSCE_NAME_LIST pNew = NULL;
               pNew = *pNameList;
               while(pNew){
                  if(!lstrcmpi( pNew->Name, pszCur ) ){
                     pszCur[0] = 0;
                     break;
                  }
                  pNew = pNew->Next;
               }

               if(pszCur[0]){
                  //
                  // Create a new link.
                  //
                                 
                  SceAddToNameList( pNameList, pszCur, Len);
               }
            }

            //
            // Next string to check.
            //
            pszCur = pszAccounts + i + 1;
         }
      }
   }

   return TRUE;
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::CheckNames

Synopsis:   Verifies the account the user has added.  This function will display an
            error message box if any accounts are found to be in err. .

Returns:    TRUE if all names are valid, FALSE otherwise.
------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::CheckNames()
{
   PSCE_NAME_LIST pNameList = NULL;
   PSCE_NAME_LIST pErrList = NULL;

   if( !m_fCheckName ) //Raid #404989
   {
      return TRUE;
   }
   BOOL bErr = TRUE;
   if( !CreateNameList( &pNameList ) ){
      return TRUE;
   }

   CString tempstr; //raid #387570, #387739
   int iFind = -1;
   PSCE_NAME_LIST pNext = pNameList;
   while(pNext)
   {
      tempstr = pNext->Name;
      iFind = tempstr.FindOneOf(IDS_INVALID_USERNAME_CHARS);
      if( iFind == 0 )
      {
        CString text;
        CString charsWithSpaces;
        PCWSTR szInvalidCharSet = IDS_INVALID_USERNAME_CHARS; 

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        text.FormatMessage (IDS_INVALID_STRING, charsWithSpaces);

        AfxMessageBox(text);
        GetDlgItem(IDC_LOG_FILE)->SetFocus(); 
        return FALSE;
      }
      pNext = pNext->Next;
   }

   pNext = pNameList;                   
   while(pNext){
      LPTSTR pszStr = pNext->Name;
      if(!IsKnownAccount(pNext->Name)){
         BOOL fname = FALSE;
         while( pszStr && *pszStr ){
            if( *pszStr == L'\\' ){
               fname = TRUE;
               SID_NAME_USE su = CGetUser::GetAccountType( pNext->Name );
               if( su == SidTypeInvalid || su == SidTypeUnknown ||
                   !AddKnownAccount(pNext->Name) ){
                  PSCE_NAME_LIST pNew = (PSCE_NAME_LIST)LocalAlloc( 0, sizeof(SCE_NAME_LIST));
                  if(pNew){
                     pNew->Name = pNext->Name;
                     pNew->Next = pErrList;
                     pErrList = pNew;
                  }
               } else {
                  UnderlineNames();
               }
               break;
            }
            pszStr++;
         }
         if( !fname ) //Raid #404989
         {
            SID_NAME_USE su = CGetUser::GetAccountType( pNext->Name );
            if( su == SidTypeInvalid || su == SidTypeUnknown ||
                   !AddKnownAccount(pNext->Name) ){
               PSCE_NAME_LIST pNew = (PSCE_NAME_LIST)LocalAlloc( 0, sizeof(SCE_NAME_LIST));
               if(pNew){
                  pNew->Name = pNext->Name;
                  pNew->Next = pErrList;
                  pErrList = pNew;
               }
            } else {
               UnderlineNames();
            }
         }
      }
      pNext = pNext->Next;
   }
   if( pErrList ){
      CString strErr;
      strErr.LoadString( IDS_ERR_INVALIDACCOUNT );

      pNext = pErrList;
      while(pNext){
         pErrList = pNext->Next;
         strErr += pNext->Name;
         if(pErrList){
            strErr += L',';
         }
         LocalFree(pNext);
         pNext = pErrList;
      }

      AfxMessageBox( strErr );
      bErr = FALSE;
   }

   SceFreeMemory( pNameList, SCE_STRUCT_NAME_LIST );
   return bErr;
}

void CSCEAddGroup::OnChecknames()
{
   PSCE_NAME_LIST pNameList = NULL;
   if( CreateNameList( &pNameList ) ){
      PSCE_NAME_LIST pNext = pNameList;
      while(pNext){
         SID_NAME_USE su = CGetUser::GetAccountType( pNext->Name );
         if( su != SidTypeInvalid && su != SidTypeUnknown ){
            //
            // Add the name.
            //
            AddKnownAccount( pNext->Name );
         }
         pNext = pNext->Next;
      }

      SceFreeMemory( pNameList, SCE_STRUCT_NAME_LIST );

      UnderlineNames();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\addgrp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addgrp.h
//
//  Contents:   definition of CSCEAddGroup
//
//----------------------------------------------------------------------------
#if !defined(AFX_SCEADDGROUP_H__66CF106B_7057_11D2_A798_00C04FD92F7B__INCLUDED_)
#define AFX_SCEADDGROUP_H__66CF106B_7057_11D2_A798_00C04FD92F7B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HelpDlg.h"

#define IDS_INVALID_USERNAME_CHARS L"*"
/////////////////////////////////////////////////////////////////////////////
// CSCEAddGroup dialog
#ifndef IsSpace
//
// Useful macro for checking to see if a character represents white space
//
#define IsSpace( x ) ((x) == L' ' || ((x) >= 0x09 && (x) <= 0x0D))
#endif

class CSCEAddGroup : public CHelpDialog
{
// Construction
public:
        CSCEAddGroup(CWnd* pParent = NULL);   // standard constructor
    virtual ~CSCEAddGroup();

   //
   // Returns the list of groups/users chosen by the user.
   //
   PSCE_NAME_LIST GetUsers()
        { return m_pnlGroup; };

   //
   // Tell the group box which mode we're running under so we can display
   // appropriate options when browsing.
   //
   void SetModeBits(DWORD dwModeBits) 
   { 
	   m_dwModeBits = dwModeBits; 
   };

// Dialog Data
    //{{AFX_DATA(CSCEAddGroup)
    enum { IDD = IDD_APPLY_CONFIGURATION };
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSCEAddGroup)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
   //
   // If a string is added, then it will be underlined in the display.
   //
   BOOL AddKnownAccount( LPCTSTR pszAccount );
   //
   // Returns TRUE if [pszAccount] was added by a call to AddKnownAccount.
   //
   BOOL IsKnownAccount( LPCTSTR pszAccount );
   //
   // Removes leading and trailing space characters.
   //
   void CleanName( LPTSTR pszAccount );
   //
   // Underlines all names in the KnownAccount list.
   //
   void UnderlineNames();
   //
   // Creates a name list from the text of the edit box.
   //
   int CreateNameList( PSCE_NAME_LIST *pNameList );
   //
   // Verfies the account names.
   //
   BOOL CheckNames();


    // Generated message map functions
    //{{AFX_MSG(CSCEAddGroup)
    afx_msg void OnBrowse();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeLogFile();
    virtual void OnOK();
    afx_msg void OnEditMsgFilter( NMHDR *pNM, LRESULT *pResult);
    afx_msg void OnChecknames();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

   //
   // Retrieve flags appropriate to our current mode.
   //
   DWORD GetModeFlags();
   DWORD m_dwModeBits;
protected:
   //
   // The users/groups chosen or typed in by the user.
   //
   PSCE_NAME_LIST m_pnlGroup;
   //
   // List of known names which will be underlined in the UI.
   //
   PSCE_NAME_LIST m_pKnownNames;
public:
   //
   // If m_sTitle, is not empty when the dialog is invoked, the string
   // will be used as the title.  m_sDescription is the title for the group
   // box
   //
   CString m_sTitle, m_sDescription;

   //
   // Flags that will be passed to CGetUser.  This is the SCE_SHOW* flags.
   // This class initializes the flag to everything in the constructor
   //
   DWORD m_dwFlags;
   BOOL m_fCheckName; //Raid #404989
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCEADDGROUP_H__66CF106B_7057_11D2_A798_00C04FD92F7B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\addobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addobj.cpp
//
//  Contents:   implementation of CAddObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "util.h"
#include <accctrl.h>
#include "servperm.h"
#include "AddObj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddObject dialog


CAddObject::CAddObject(SE_OBJECT_TYPE SeType, LPTSTR ObjName, BOOL bIsContainer, CWnd* pParent)
    : CHelpDialog(a197HelpIDs, IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddObject)
   m_radConfigPrevent = 0;
   m_radInheritOverwrite = 0;
    //}}AFX_DATA_INIT

   m_pfnCreateDsPage=NULL;
   m_pSI=NULL;
   m_pNewSD=NULL;
   m_NewSeInfo = 0;
   m_Status=0;

   m_SeType=SeType;
   m_ObjName=ObjName;
   m_bIsContainer = bIsContainer;

   m_hwndACL = NULL;
}


void CAddObject::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddObject)
    DDX_Radio(pDX, IDC_CONFIG, m_radConfigPrevent);
    DDX_Radio(pDX, IDC_INHERIT, m_radInheritOverwrite);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddObject, CHelpDialog)
    //{{AFX_MSG_MAP(CAddObject)
    ON_BN_CLICKED(IDC_SECURITY, OnTemplateSecurity)
    ON_BN_CLICKED(IDC_CONFIG, OnConfig)
    ON_BN_CLICKED(IDC_PREVENT, OnPrevent)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddObject message handlers

void CAddObject::OnTemplateSecurity()
{
    INT_PTR nRet = 0;

   if( ::IsWindow( m_hwndACL ) )
      return;

    if ( SE_DS_OBJECT == m_SeType ) 
    {
        if ( !m_pfnCreateDsPage ) 
        {
            if (!g_hDsSecDll)
                g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

            if ( g_hDsSecDll) 
            {
                m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                               "DSCreateISecurityInfoObject");
            }
        }

        if ( m_pfnCreateDsPage ) {
            m_hwndACL = (HWND)MyCreateDsSecurityPage(&m_pSI, m_pfnCreateDsPage,
                                         &m_pNewSD, &m_NewSeInfo,
                                         (LPCTSTR)m_ObjName,
                                         CONFIG_SECURITY_PAGE,
                                         GetSafeHwnd()
                               );
        } else
            nRet = -1;

    } else {

        m_hwndACL = (HWND)MyCreateSecurityPage2(m_bIsContainer, &m_pNewSD, &m_NewSeInfo,
                                    (LPCTSTR)m_ObjName,
                                    m_SeType,
                                    CONFIG_SECURITY_PAGE,
                                    GetSafeHwnd(),
                                    FALSE   // not modeless
                                    );
    }

    if ( (HWND)-1 == m_hwndACL ) {
        CString str;
        str.LoadString(IDS_CANT_ASSIGN_SECURITY);
        AfxMessageBox(str);

    } else if ( !m_pNewSD ) {
        //
        // if m_pNewSD is still NULL, create a new one for everyone Full control
        //
        DWORD SDSize;

        if (SE_REGISTRY_KEY == m_SeType) {
           GetDefaultRegKeySecurity(&m_pNewSD,&m_NewSeInfo);
        } else {
           GetDefaultFileSecurity(&m_pNewSD,&m_NewSeInfo);
        }
    }
}

BOOL CAddObject::OnInitDialog()
{
    CDialog::OnInitDialog();


   SetDlgItemText(IDC_TITLE,m_ObjName);
   if (SE_REGISTRY_KEY == m_SeType) {
      CString str;
      str.LoadString(IDS_REGISTRY_CONFIGURE);
      SetDlgItemText(IDC_CONFIG,str);
      str.LoadString(IDS_REGISTRY_APPLY);
      SetDlgItemText(IDC_OVERWRITE,str);
      str.LoadString(IDS_REGISTRY_INHERIT);
      SetDlgItemText(IDC_INHERIT,str);
      str.LoadString(IDS_REGISTRY_PREVENT);
      SetDlgItemText(IDC_PREVENT,str);
   }

    if (1 == m_radConfigPrevent) {
       OnPrevent();
    } else {
       OnConfig();
    }

    UpdateData(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CAddObject::OnOK()
{
    UpdateData(TRUE);

    if ( !m_pNewSD ) {
        CString str;
        str.LoadString(IDS_SECURITY_REQUIRED);
        AfxMessageBox(str);
        return;
    }

    switch (m_radConfigPrevent) {
       case 0:
          // config
          switch(m_radInheritOverwrite) {
             case 0:
                // inherit
                m_Status = SCE_STATUS_CHECK;
                break;
             case 1:
                // overwrite
                m_Status = SCE_STATUS_OVERWRITE;
                break;
          }
          break;
       case 1:
          // prevent
          m_Status = SCE_STATUS_IGNORE;
          break;
    }

    if ( m_pSI ) {
        m_pSI->Release();
        m_pSI = NULL;
    }
    m_pfnCreateDsPage=NULL;

    CDialog::OnOK();
}

void CAddObject::OnCancel()
{
    if ( m_pNewSD ) {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;

    if ( m_pSI ) {
        m_pSI->Release();
        m_pSI = NULL;
    }
    m_pfnCreateDsPage=NULL;

    CDialog::OnCancel();
}

void CAddObject::OnConfig()
{
   CWnd *pRadio = GetDlgItem(IDC_INHERIT);
   if (pRadio)
      pRadio->EnableWindow(TRUE);
   
   pRadio = GetDlgItem(IDC_OVERWRITE);
   if (pRadio)
      pRadio->EnableWindow(TRUE);
}

void CAddObject::OnPrevent()
{
   CWnd *pRadio = GetDlgItem(IDC_INHERIT);
   if (pRadio) {
      pRadio->EnableWindow(FALSE);
   }
   pRadio = GetDlgItem(IDC_OVERWRITE);
   if (pRadio) {
      pRadio->EnableWindow(FALSE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aenable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aenable.cpp
//
//  Contents:   implementation of CAttrEnable
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "snapmgr.h"
#include "AEnable.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrEnable dialog


CAttrEnable::CAttrEnable(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CAttrEnable)
    m_Current = _T("");
    m_EnabledRadio = -1;
    m_Title = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a169HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrEnable::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrEnable)
    DDX_Text(pDX, IDC_CURRENT, m_Current);
    DDX_Radio(pDX, IDC_ENABLED, m_EnabledRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrEnable, CAttribute)
    //{{AFX_MSG_MAP(CAttrEnable)
    ON_BN_CLICKED(IDC_ENABLED, OnRadio)
    ON_BN_CLICKED(IDC_DISABLED, OnRadio)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrEnable message handlers

void CAttrEnable::Initialize(CResult * pResult)
{
   CString str;

   CAttribute::Initialize(pResult);

   LONG_PTR dw = pResult->GetBase();
   if ( (LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw ||
        (BYTE)SCE_NO_VALUE == (BYTE)dw ) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      //
      // BUG 145561 - dw is 0 vs non-0 boolean, not 0 vs 1
      //
      SetInitialValue((DWORD_PTR)(dw != 0));
   }

   pResult->GetDisplayName( NULL, m_Current, 2 );
}

void CAttrEnable::SetInitialValue(DWORD_PTR dw) 
{
   if (-1 == m_EnabledRadio) 
   {
      m_EnabledRadio = dw ? 0 : 1;
   }
}


void CAttrEnable::OnRadio()
{
   UpdateData(TRUE);
   CWnd *bnOK;

   SetModified(TRUE);

   bnOK = GetDlgItem(IDOK);
   if (bnOK ) {
      bnOK->EnableWindow(-1 != m_EnabledRadio);
   }
}

BOOL CAttrEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      int status = 0;
      UpdateData(TRUE);
      DWORD dw = 0;

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_EnabledRadio) 
         {
            // ENABLED
            case 0:
               dw = 1;
               break;
            // DISABLED
            case 1:
               dw = 0;
               break;
            default:
               dw = SCE_NO_VALUE;
               break;
         }
      }

      m_pData->SetBase((LONG_PTR)ULongToPtr(dw));
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),(LONG_PTR)ULongToPtr(dw), m_pData);
      m_pData->SetStatus(status);
      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}

BOOL CAttrEnable::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_ENABLED);
    AddUserControl(IDC_DISABLED);
    OnConfigure();
    OnRadio();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\addobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addobj.h
//
//  Contents:   definition of CAddObject
//
//----------------------------------------------------------------------------
#if !defined(AFX_ADDOBJ_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
#define AFX_ADDOBJ_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddObject dialog

class CAddObject : public CHelpDialog
{
// Construction
public:
    CAddObject(SE_OBJECT_TYPE SeType, LPTSTR ObjName, BOOL bIsContainer=TRUE, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CAddObject)
    enum { IDD = IDD_ADD_OBJECT };
    int		m_radConfigPrevent;
    int		m_radInheritOverwrite;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddObject)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddObject)
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnTemplateSecurity();
    virtual BOOL OnInitDialog();
    afx_msg void OnConfig();
    afx_msg void OnPrevent();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    PSECURITY_DESCRIPTOR GetSD() { return m_pNewSD; };
    SECURITY_INFORMATION GetSeInfo() { return m_NewSeInfo; };
    void SetSD(PSECURITY_DESCRIPTOR pSD) { m_pNewSD = pSD; }
    void SetSeInfo(SECURITY_INFORMATION SeInfo) { m_NewSeInfo = SeInfo; }
    BYTE GetStatus() { return m_Status; };

private:
    SE_OBJECT_TYPE m_SeType;
    CString m_ObjName;
    BOOL m_bIsContainer;

    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    BYTE m_Status;
    PFNDSCREATEISECINFO m_pfnCreateDsPage;
    LPDSSECINFO m_pSI;

   HWND m_hwndACL;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDOBJ_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aenable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aenable.h
//
//  Contents:   definition of CAttrEnable
//
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRENABLE_H__76BA1B2E_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRENABLE_H__76BA1B2E_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrEnable dialog

class CAttrEnable : public CAttribute
{
// Construction
public:
	virtual void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
	CAttrEnable(UINT nTemplateID);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAttrEnable)
	enum { IDD = IDD_ATTR_ENABLE };
	CString	m_Current;
	int		m_EnabledRadio;
	CString	m_Title;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttrEnable)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAttrEnable)
	virtual BOOL OnApply();
	virtual void OnRadio();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRENABLE_H__76BA1B2E_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aflags.cpp
//
//  Contents:   definition of CAttrRegFlags
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "chklist.h"
#include "util.h"
#include "aFlags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrRegFlags dialog


CAttrRegFlags::CAttrRegFlags()
: CAttribute(IDD), m_pFlags(NULL)
{
        //{{AFX_DATA_INIT(CAttrRegFlags)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a236HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrRegFlags::DoDataExchange(CDataExchange* pDX)
{
        CAttribute::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAttrRegFlags)
                // NOTE: the ClassWizard will add DDX and DDV calls here
   DDX_Text(pDX, IDC_CURRENT, m_Current);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrRegFlags, CAttribute)
        //{{AFX_MSG_MAP(CAttrRegFlags)
        //}}AFX_MSG_MAP
        ON_NOTIFY(CLN_CLICK, IDC_CHECKBOX, OnClickCheckBox)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrRegFlags message handlers
void CAttrRegFlags::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pFlags = pResult->GetRegFlags();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }

   pResult->GetDisplayName(NULL,m_Current,2);
}

BOOL CAttrRegFlags::OnInitDialog()
{
   CAttribute::OnInitDialog();
   CWnd *wndCL = NULL;
   DWORD fFlags = 0;
   DWORD fFlagsComp = 0;

   PREGFLAGS pFlags = m_pFlags;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   PSCE_REGISTRY_VALUE_INFO prvComp = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());
   if (prv && prv->Value) {
      fFlags = (DWORD)_ttoi(prv->Value);
   }
   if (prvComp && prvComp->Value) {
      fFlagsComp = (DWORD)_ttoi(prvComp->Value);
   }
   int nIndex = 0;

   CString strOut;

   wndCL = GetDlgItem(IDC_CHECKBOX);
   if (!wndCL) {
      //
      // This should never happen
      //
      ASSERT(wndCL);
      return FALSE;
   }
   wndCL->SendMessage(CLM_RESETCONTENT,0,0);

   while(pFlags) {
      nIndex = (int) wndCL->SendMessage(CLM_ADDITEM,
                                        (WPARAM)pFlags->szName,
                                        (LPARAM)pFlags->dwValue);
      if (nIndex != -1) {
         BOOL bSet;
         //
         // Template setting: editable
         //
         bSet = ((fFlags & pFlags->dwValue) == pFlags->dwValue);
         wndCL->SendMessage(CLM_SETSTATE,
                            MAKELONG(nIndex,1),
                            bSet ? CLST_CHECKED : CLST_UNCHECKED);
         //
         // Analyzed setting: always disabled
         //
         bSet = ((fFlagsComp & pFlags->dwValue) == pFlags->dwValue);
         wndCL->SendMessage(CLM_SETSTATE,
                            MAKELONG(nIndex,2),
                            CLST_DISABLED | (bSet ? CLST_CHECKED : CLST_UNCHECKED));
      }
      pFlags = pFlags->pNext;
   }

   AddUserControl(IDC_CHECKBOX);
   EnableUserControls(m_bConfigure);
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRegFlags::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      CWnd *wndCL = NULL;
      DWORD fFlags = 0;

      UpdateData(TRUE);

      wndCL = GetDlgItem(IDC_CHECKBOX);
      ASSERT(wndCL != NULL);

      if (!m_bConfigure || !wndCL)
         dw = SCE_NO_VALUE;
      else 
      {
         int nItems = (int) wndCL->SendMessage(CLM_GETITEMCOUNT,0,0);
         for (int i=0;i<nItems;i++) 
         {
            dw = (DWORD)wndCL->SendMessage(CLM_GETSTATE,MAKELONG(i,1));
            if (CLST_CHECKED == dw)
               fFlags |= wndCL->SendMessage(CLM_GETITEMDATA,i);
         }
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv != NULL);
      if ( prv ) 
      {
         PWSTR pTmp=NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), fFlags);
            pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( pTmp )
               lstrcpy(pTmp,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               return FALSE;
            }
         }

         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = pTmp;

         m_pData->SetBase((LONG_PTR)prv);
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}


void CAttrRegFlags::OnClickCheckBox(NMHDR *pNM, LRESULT *pResult) //Raid #389890, 5/11/2001
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aflags.h
//
//  Contents:   definition of CAttrRegFlags
//
//----------------------------------------------------------------------------
#if !defined(AFX_AFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
#define AFX_AFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrRegFlags dialog

class CAttrRegFlags : public CAttribute
{
// Construction
public:
	CAttrRegFlags();   // standard constructor

   virtual void Initialize(CResult * pResult);

// Dialog Data
	//{{AFX_DATA(CAttrRegFlags)
	enum { IDD = IDD_ATTR_REGFLAGS };
   CString  m_Current;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttrRegFlags)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	afx_msg void OnClickCheckBox(NMHDR *pNM, LRESULT *pResult);

	// Generated message map functions
	//{{AFX_MSG(CAttrRegFlags)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   PREGFLAGS m_pFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\amember.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AMember.h
//
//  Contents:   Definition of CAttrMember
//
//----------------------------------------------------------------------------
#if !defined(AFX_AMEMBER_H__817356C3_4A31_11D1_AB55_00C04FB6C6FA__INCLUDED_)
#define AFX_AMEMBER_H__817356C3_4A31_11D1_AB55_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "SelfDeletingPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrMember dialog

class CAttrMember : public CSelfDeletingPropertyPage
{
    DECLARE_DYNCREATE(CAttrMember)

// Construction
public:
    void SetSnapin(CSnapin *pSnapin);
    void SetMemberType(DWORD nType);
    void Initialize(CResult *pData);
    void SetDefineInDatabase(BOOL fDefineInDatabase);
    void SetSibling(CAttrMember *pAttrMember);
    CAttrMember();
    virtual ~CAttrMember();

// Dialog Data
    //{{AFX_DATA(CAttrMember)
    enum { IDD = IDD_ATTR_GROUP };
    BOOL    m_fDefineInDatabase;
    CString m_strHeader;
    CEdit   m_eNoMembers;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAttrMember)
	public:
    virtual void OnCancel();
	virtual BOOL OnApply();
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAttrMember)
    afx_msg void OnAdd();
    virtual BOOL OnInitDialog();
    afx_msg void OnClickMembers(NMHDR *pNM, LRESULT *pResult);
    afx_msg void OnDefineInDatabase();
    //}}AFX_MSG
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    void DoContextHelp (HWND hWndControl);
    PSCE_GROUP_MEMBERSHIP GetGroupInTemplate();

private: 
    BOOL SwapNoMembersDisplay(BOOL bNoMembers);
    void DeleteGroup(const CString &szGroupName);
    CString m_strPageTitle;
    bool m_bDirty;
    BOOL m_fOriginalDefineInDatabase;
    BOOL m_bAlias;
    BOOL m_bNoMembers;
    CSnapin * m_pSnapin;
    PSCE_NAME_STATUS_LIST m_pMergeList;
    DWORD m_dwType;
    CResult * m_pData;
    CAttrMember *m_pAttrMember;
    BOOL m_fProcessing;
    BOOL m_fInitialized;
    CCriticalSection m_CS;
};


#define GROUP_MEMBER_OF 1
#define GROUP_MEMBERS 2

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AMEMBER_H__817356C3_4A31_11D1_AB55_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\amember.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AMember.cpp
//
//  Contents:   implementation of CAttrMember
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "resource.h"
#include "chklist.h"
#include "util.h"
#include "getuser.h"
#include "snapmgr.h"
#include "resource.h"
#include "AMember.h"
#include "wrapper.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAttrMember property page

IMPLEMENT_DYNCREATE(CAttrMember, CSelfDeletingPropertyPage)

CAttrMember::CAttrMember() : CSelfDeletingPropertyPage(CAttrMember::IDD)
{
    //{{AFX_DATA_INIT(CAttrMember)
    m_fDefineInDatabase = FALSE;
    m_strHeader = _T("");
    //}}AFX_DATA_INIT

    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_ATTR_GROUP);
    m_psp.dwFlags |= PSP_PREMATURE;
    m_pMergeList = NULL;
    m_fProcessing = FALSE;
    m_fInitialized = FALSE;
    m_bNoMembers = FALSE;
    m_bDirty=false;
    m_fOriginalDefineInDatabase=FALSE;
    m_bAlias=FALSE;
    m_dwType=0;
    CAttribute::m_nDialogs++;
}

CAttrMember::~CAttrMember()
{
    if ( m_pMergeList ) {
        SceFreeMemory(m_pMergeList, SCE_STRUCT_NAME_STATUS_LIST);
        m_pMergeList = NULL;
    }
    m_pData->Release();
    CAttribute::m_nDialogs--;
}

void CAttrMember::DoDataExchange(CDataExchange* pDX)
{
    CSelfDeletingPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrMember)
    DDX_Check(pDX, IDC_DEFINE_GROUP, m_fDefineInDatabase);
    DDX_Text(pDX, IDC_HEADER, m_strHeader);
    DDX_Control(pDX, IDC_NO_MEMBERS,m_eNoMembers);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrMember, CSelfDeletingPropertyPage)
    //{{AFX_MSG_MAP(CAttrMember)
    ON_BN_CLICKED(IDC_DEFINE_GROUP, OnDefineInDatabase)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    //}}AFX_MSG_MAP
    ON_NOTIFY(CLN_CLICK, IDC_MEMBERS, OnClickMembers)
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrMember message handlers

void CAttrMember::OnDefineInDatabase()
{
    if (m_fProcessing)
        return;

    m_fProcessing = TRUE;

    //
    // for some strange reason the DDX isn't getting this BOOL set, so just do it
    // here which is basically the same thing
    //
    m_fDefineInDatabase = ( ((CButton *)GetDlgItem(IDC_DEFINE_GROUP))->GetCheck() == 1 );

    if (m_fDefineInDatabase) {
        (GetDlgItem(IDC_ADD))->EnableWindow(TRUE);
        //
        // use non CWnd calls for the checklist control
        //
        ::SendMessage(::GetDlgItem(this->m_hWnd, IDC_MEMBERS), WM_ENABLE, (WPARAM) TRUE, (LPARAM) 0);
    } else {
        (GetDlgItem(IDC_ADD))->EnableWindow(FALSE);
        //
        // use non CWnd calls for the checklist control
        //
        ::SendMessage(::GetDlgItem(this->m_hWnd, IDC_MEMBERS), WM_ENABLE, (WPARAM) FALSE, (LPARAM) 0);
    }

    SetModified(TRUE);

    //
    // Tell our siblings the m_fDefineInDatabase has changed
    //
    if (m_pAttrMember) {
        m_pAttrMember->SetDefineInDatabase(m_fDefineInDatabase);
    }

    m_fProcessing = FALSE;
}


void CAttrMember::OnAdd()
{
    CGetUser gu;
    HRESULT hr=S_OK;
    DWORD nFlag;

    if ( GROUP_MEMBERS == m_dwType )
       nFlag = SCE_SHOW_USERS | SCE_SHOW_DOMAINGROUPS;
    else {

        nFlag = SCE_SHOW_GROUPS | SCE_SHOW_ALIASES;   // NT5 DS, nested groups
    }

    nFlag |= SCE_SHOW_SCOPE_ALL | SCE_SHOW_DIFF_MODE_OFF_DC;
    if (gu.Create(GetSafeHwnd(),nFlag)) {

        PSCE_NAME_STATUS_LIST pList, pLast=NULL;
        LRESULT iItem;
        bool bFound;

        PSCE_NAME_LIST pName = gu.GetUsers();
        CWnd *pCheckList;
        pCheckList = GetDlgItem(IDC_MEMBERS);

        if (pName && m_bNoMembers) {
           m_bNoMembers = FALSE;
           m_eNoMembers.ShowWindow(SW_HIDE);
           pCheckList->ShowWindow(SW_SHOW);
        }
        while(pName) {
            if ( pName->Name ) {
                // Is the new name in m_pMerged yet?
                pList = m_pMergeList;
                pLast = NULL;
                iItem = 0;

                bFound = false;
                while(pList) {
                    // If so, then make sure its "Template" box is checked
                    if (lstrcmp(pList->Name,pName->Name) == 0) {
                       if (!(pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED)) {
                          m_bDirty = true;
                          pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                       }
                       bFound = true;
                       break;
                    }
                    pLast = pList;
                    pList = pList->Next;
                    iItem++;
                }

                // Otherwise add it both to m_pMerged and to the CheckList
                if (!bFound) {

                    PSCE_NAME_STATUS_LIST pNewNode;

                    pNewNode = (PSCE_NAME_STATUS_LIST)LocalAlloc(0,sizeof(SCE_NAME_STATUS_LIST));
                    if ( pNewNode ) {

                        pNewNode->Name = (LPTSTR)LocalAlloc(0, (lstrlen(pName->Name)+1)*sizeof(TCHAR));
                        if ( pNewNode->Name ) {
                            lstrcpy(pNewNode->Name, pName->Name);
                            pNewNode->Next = NULL;
                            pNewNode->Status = MERGED_TEMPLATE;
                        } else {
                            LocalFree(pNewNode);
                            pNewNode = NULL;
                        }
                    }
                    if ( pNewNode ) {
                        if ( pLast )
                            pLast->Next = pNewNode;
                        else
                            m_pMergeList = pNewNode;
                        pLast = pNewNode;

                        iItem = pCheckList->SendMessage(CLM_ADDITEM,(WPARAM)pLast->Name,(LPARAM)pLast->Name);
                        pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                        pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,2),CLST_DISABLED);
                        m_bDirty = true;

                    } else {
                        hr = E_OUTOFMEMORY;
                        ASSERT(FALSE);
                        break;
                    }
                }
                SetModified(TRUE);
            }
            pName = pName->Next;
        }
    }

    if (m_bDirty) {
        SetModified(TRUE);
    }

    if ( FAILED(hr) ) {
        CString str;
        str.LoadString(IDS_CANT_ADD_MEMBER);
        AfxMessageBox(str);
    }

}

/*---------------------------------------------------------------------

    Method:     OnInitDialog

    Synopsis:   Initialize the check list with members/memberof data

    Arguments:  None

    Returns:    TRUE = initialized successfully

----------------------------------------------------------------------*/
BOOL CAttrMember::OnInitDialog()
{
   CSelfDeletingPropertyPage::OnInitDialog();


   PSCE_NAME_STATUS_LIST pItem;
   HWND hCheckList;
   LRESULT nItem;
   PSCE_GROUP_MEMBERSHIP pgmTemplate;
   PSCE_GROUP_MEMBERSHIP pgmInspect;
   PSCE_NAME_LIST pnlTemplate=NULL;
   PSCE_NAME_LIST pnlInspect=NULL;
   PEDITTEMPLATE pet = NULL;
   CString str;

   UpdateData(TRUE);
   if (GROUP_MEMBER_OF == m_dwType) {
      str.LoadString(IDS_NO_MEMBER_OF);
   } else {
      str.LoadString(IDS_NO_MEMBERS);
   }
   m_eNoMembers.SetWindowText(str);

   pgmInspect = (PSCE_GROUP_MEMBERSHIP) m_pData->GetID();   // last inspection saved in ID field

   if ( NULL == pgmInspect ) {  // last inspection can't be NULL
       return TRUE;
   }

   m_fOriginalDefineInDatabase = m_fDefineInDatabase = FALSE;

   //
   // Try to find the base group in the template
   //
   pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE);
   if ( NULL == pet ) {
      return TRUE;
   }

   for (pgmTemplate=pet->pTemplate->pGroupMembership;
        pgmTemplate!=NULL;
        pgmTemplate=pgmTemplate->Next) {

      if ( _wcsicmp(pgmTemplate->GroupName, pgmInspect->GroupName) == 0 ) {
         //
         // If the group is in the template that means it is defined.... duh
         //
         m_fOriginalDefineInDatabase = m_fDefineInDatabase = TRUE;
         break;
      }
   }

   //
   // find the name lists to display
   //
   if ( pgmTemplate ) {

       if (GROUP_MEMBER_OF == m_dwType) {
           pnlTemplate = pgmTemplate->pMemberOf;
       } else {
           pnlTemplate = pgmTemplate->pMembers;
       }
   }

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != (LONG_PTR) pgmInspect &&
       pgmInspect ) {

       if (GROUP_MEMBER_OF == m_dwType) {
           pnlInspect = pgmInspect->pMemberOf;
       } else {
           pnlInspect = pgmInspect->pMembers;
       }
   }

   m_pMergeList = MergeNameStatusList(pnlTemplate, pnlInspect);

   pItem = m_pMergeList;
   hCheckList = ::GetDlgItem(m_hWnd,IDC_MEMBERS);

   ::SendMessage(hCheckList, CLM_RESETCONTENT, 0, 0 );
   ::SendMessage(hCheckList,CLM_SETCOLUMNWIDTH,0,60);

   if (!pItem) {
      m_bNoMembers = TRUE;
      m_eNoMembers.ShowWindow(SW_SHOW);
      ::ShowWindow(hCheckList,SW_HIDE);
   }

   while(pItem) {
      //
      // Store the name of the item in the item data so we can retrieve it later
      //
      nItem = ::SendMessage(hCheckList,CLM_ADDITEM,(WPARAM) pItem->Name,(LPARAM) pItem->Name);
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,1),
                  ((pItem->Status & MERGED_TEMPLATE) ? CLST_CHECKED : CLST_UNCHECKED));
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,2),
                  ((pItem->Status & MERGED_INSPECT) ? CLST_CHECKDISABLED : CLST_DISABLED));
      pItem = pItem->Next;
   }

   if ( GROUP_MEMBER_OF == m_dwType ) {

       m_bAlias = TRUE;

   } else {
       m_bAlias = FALSE;
   }

   CWnd *cwnd = GetDlgItem(IDC_ADD);
   if ( cwnd ) {
       cwnd->EnableWindow(!m_bAlias);
   }

   CButton *pButton = (CButton *) GetDlgItem(IDC_DEFINE_GROUP);
   if (pButton) {
       pButton->SetCheck(m_fDefineInDatabase);
   }

   OnDefineInDatabase();

   SetModified(FALSE);

   m_fInitialized = TRUE;

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*---------------------------------------------------------------------

    Method:     SetDefineInDatabase

    Synopsis:   Sets the m_fDefineInDatabase member var, and UI accorsingly

    Arguments:  fDefineInDatabase

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::SetDefineInDatabase(BOOL fDefineInDatabase)
{
   if (!m_fInitialized)
       return;

   if (m_fProcessing)
       return;

   m_fDefineInDatabase = fDefineInDatabase;

   CButton *pButton = (CButton *) GetDlgItem(IDC_DEFINE_GROUP);
   if (pButton) {
      pButton->SetCheck(fDefineInDatabase);
   }

   OnDefineInDatabase();
}


/*---------------------------------------------------------------------

    Method:     SetSibling

    Synopsis:   Sets the pointer to the Sibling class

    Arguments:  pAttrMember

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::SetSibling(CAttrMember *pAttrMember)
{
    m_pAttrMember = pAttrMember;
}


/*---------------------------------------------------------------------

    Method:     Initialize

    Synopsis:   Initialize member data

    Arguments:  pData - the CResult data record

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::Initialize(CResult * pData)
{
   m_pData = pData;
   pData->AddRef();

   m_bDirty=false;
}


/*---------------------------------------------------------------------

    Method:     GetGroupInTemplate

    Synopsis:   Returns a pointer to the SCE_GROUP_MEMBERSHIP structure
                that is being changed within the template

    Arguments:  None

    Returns:    Pointer the group being modified.

----------------------------------------------------------------------*/
PSCE_GROUP_MEMBERSHIP CAttrMember::GetGroupInTemplate()
{
   PSCE_GROUP_MEMBERSHIP    pgmTemplate;
   PSCE_GROUP_MEMBERSHIP    pgmInspect;
   PEDITTEMPLATE            pet;

   pgmInspect = (PSCE_GROUP_MEMBERSHIP) m_pData->GetID();   // last inspection saved in ID field

   if ( NULL == pgmInspect ) {  // last inspection can't be NULL
        return NULL;
   }

   pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE);
   if ( NULL == pet ) {
        return NULL;
   }

   for (pgmTemplate=pet->pTemplate->pGroupMembership;
        pgmTemplate!=NULL;
        pgmTemplate=pgmTemplate->Next) {

      if ( _wcsicmp(pgmTemplate->GroupName, pgmInspect->GroupName) == 0 ) {
         return pgmTemplate;
      }
   }

   return NULL;
}


/*---------------------------------------------------------------------

    Method:     SetMemberType

    Synopsis:   Initialize page data depending on the type

    Arguments:  nType - the page type for members of memberof

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::SetMemberType(DWORD nType)
{
   m_dwType = nType;
   if (GROUP_MEMBERS == nType) {
      m_strHeader.LoadString(IDS_GROUP_MEMBERS_HEADER);
      m_strPageTitle.LoadString(IDS_GROUP_MEMBERS_PAGE_TITLE);
   } else {
      m_strHeader.LoadString(IDS_GROUP_MEMBER_OF_HEADER);
      m_strPageTitle.LoadString(IDS_GROUP_MEMBER_OF_PAGE_TITLE);
   }
   m_psp.dwFlags |= PSP_USETITLE;
   m_psp.pszTitle = (LPCTSTR) m_strPageTitle;

}

void CAttrMember::SetSnapin(CSnapin * pSnapin)
{
   m_pSnapin = pSnapin;
}

void CAttrMember::OnCancel()
{
    if ( m_pMergeList ) {
       SceFreeMemory(m_pMergeList,SCE_STRUCT_NAME_STATUS_LIST);
    }
    m_pMergeList = NULL;
}


void CAttrMember::OnClickMembers(NMHDR *pNM, LRESULT *pResult)
{
   SetModified(TRUE);
   //
   // If no items are checked then show the no members edit box instead
   //
   CWnd *pCheckList;
   int iItem;
   int nItem;
   PNM_CHECKLIST pNMCheckList;

   pNMCheckList = (PNM_CHECKLIST) pNM;
   if (pNMCheckList->dwState & CLST_CHECKED) {
      //
      // They checked something, so obviously something is checked
      //
      return;
   }

   pCheckList = GetDlgItem(IDC_MEMBERS);
   nItem = (int) pCheckList->SendMessage(CLM_GETITEMCOUNT);
   for(iItem=0;iItem<nItem;iItem++) {
      if ((pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED) ||
          (pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,2)) & CLST_CHECKED)) {
         //
         // Something's checked, so abort
         //
         return;
      }
   }
   //
   // Nothing checked.  Swap to the no members edit box
   //
   m_bNoMembers = TRUE;
   m_eNoMembers.ShowWindow(SW_SHOW);
   pCheckList->ShowWindow(SW_HIDE);
}



BOOL CAttrMember::OnApply()
{
   int iItem;
   PEDITTEMPLATE pet=NULL;
   PSCE_PROFILE_INFO pspi=NULL;
   PSCE_NAME_STATUS_LIST pIndex;
   CWnd *pCheckList;
   PSCE_NAME_LIST pTemplate=NULL;
   PSCE_NAME_LIST pInspect=NULL;
   PSCE_NAME_LIST pDeleteNameList = NULL;
   PSCE_GROUP_MEMBERSHIP pSetting = NULL;
   PSCE_GROUP_MEMBERSHIP pBaseGroup = NULL;
   PSCE_GROUP_MEMBERSHIP pFindGroup = NULL;
   PSCE_GROUP_MEMBERSHIP pModifiedGroup = NULL;

   LPCTSTR szGroupName = (LPCTSTR) (m_pData->GetAttr());

   pCheckList = GetDlgItem(IDC_MEMBERS);
   pIndex = m_pMergeList;
   iItem = 0;
   HRESULT hr=S_OK;

   //
   // if the fDefineInDatabase has changed it is definitely dirty
   //
   m_bDirty = ( m_bDirty || (m_fOriginalDefineInDatabase != m_fDefineInDatabase) );

   //
   // only create the name list if the group is going to be defined in the database
   //
   if (m_fDefineInDatabase) {
       while(pIndex) {

          if (pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED) {

            if ( !(pIndex->Status & MERGED_TEMPLATE) ) {
                m_bDirty = true;
            }

            if ( SCESTATUS_SUCCESS != SceAddToNameList(&pTemplate, pIndex->Name, lstrlen(pIndex->Name))) {
                hr = E_FAIL;
                break;
            }
          } else if ( pIndex->Status & MERGED_TEMPLATE ) {
             m_bDirty = true;
          }

          pIndex = pIndex->Next;
          iItem++;
       }
   }

   if ( SUCCEEDED(hr) && m_bDirty) {

      pBaseGroup = GetGroupInTemplate();

      //
      // Need to add the group to the template
      //
      if ( (!pBaseGroup || (LONG_PTR)pBaseGroup == (LONG_PTR)ULongToPtr(SCE_NO_VALUE)) &&
           m_fDefineInDatabase) {

         pBaseGroup = (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LMEM_ZEROINIT,sizeof(SCE_GROUP_MEMBERSHIP));

         if ( pBaseGroup && szGroupName ) {
             pBaseGroup->GroupName = (PWSTR)LocalAlloc(0, (lstrlen(szGroupName)+1)*sizeof(TCHAR));

             if ( pBaseGroup->GroupName ) {
                 lstrcpy(pBaseGroup->GroupName,szGroupName);
                 //
                 // link the new structure to the pGroupMembership list
                 //
                 pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
                 if (pet) {
                    pspi = pet->pTemplate;
                 } else {
                     pspi = NULL;
                 }

                 if ( pspi ) {
                     pBaseGroup->Next = pspi->pGroupMembership;
                     pspi->pGroupMembership = pBaseGroup;

                     pBaseGroup->pMembers = NULL;
                     pBaseGroup->pMemberOf = NULL;

                 } else {
                    //
                    // error
                    ASSERT(FALSE);
                    LocalFree(pBaseGroup->GroupName);
                    hr = E_FAIL;
                 }
             } else {
                //
                // no memory
                //
                hr = E_OUTOFMEMORY;
             }
         } else {
             hr = E_OUTOFMEMORY;
         }

         if ( FAILED(hr) && pBaseGroup ) {
             LocalFree(pBaseGroup);
             pBaseGroup = NULL;
         }

         pModifiedGroup = pBaseGroup;

      //
      // Need to remove the group from the template
      //
      } else if (pBaseGroup && !m_fDefineInDatabase) {

        CString szGroupName;
        szGroupName = pBaseGroup->GroupName;
        pBaseGroup = NULL;
        DeleteGroup(szGroupName);
      //
      // An existing group was modified
      //
      } else {
        pModifiedGroup = pBaseGroup;
      }

      //
      // get group address to change the status field in the last inspection
      //
      pSetting = (PSCE_GROUP_MEMBERSHIP)(m_pData->GetID());

      int status;
      if (GROUP_MEMBERS == m_dwType) {

        if (pModifiedGroup != NULL) {
            pDeleteNameList = pModifiedGroup->pMembers;
            pModifiedGroup->pMembers = pTemplate;
        }

        if (NULL !=  pSetting ) {
            if ( !((pSetting->Status & SCE_GROUP_STATUS_NOT_ANALYZED) ||
                   (pSetting->Status & SCE_GROUP_STATUS_ERROR_ANALYZED))) {

                //
                // set good, not configured, or mismatch
                //
                pSetting->Status &= ~SCE_GROUP_STATUS_NC_MEMBERS;
                pSetting->Status &= ~SCE_GROUP_STATUS_MEMBERS_MISMATCH;
                if (pModifiedGroup == NULL) {
                    pSetting->Status |= SCE_GROUP_STATUS_NC_MEMBERS;
                } else if ( !SceCompareNameList(pTemplate, pSetting->pMembers) ) {
                    pSetting->Status |= SCE_GROUP_STATUS_MEMBERS_MISMATCH;
                }
            }

        } else {
           //
           // else should NEVER occur
           //
           status = SCE_GROUP_STATUS_MEMBERS_MISMATCH;
        }

      } else {
         //
         // memberof
         //

        if (pModifiedGroup != NULL) {
            pDeleteNameList = pModifiedGroup->pMemberOf;
            pModifiedGroup->pMemberOf = pTemplate;
        }

        if ( pSetting ) {
            if ( !((pSetting->Status & SCE_GROUP_STATUS_NOT_ANALYZED) ||
                   (pSetting->Status & SCE_GROUP_STATUS_ERROR_ANALYZED))) {

                //
                // set good, not configured, or mismatch
                //
                pSetting->Status &= ~SCE_GROUP_STATUS_NC_MEMBEROF;
                pSetting->Status &= ~SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
                if (pModifiedGroup == NULL) {
                    pSetting->Status |= SCE_GROUP_STATUS_NC_MEMBEROF;
                } else if ( !SceCompareNameList(pTemplate, pSetting->pMemberOf) ) {
                    pSetting->Status |= SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
                }
            }

        } else {
           // else should NEVER occur
            status = SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
        }
      }
      pTemplate = NULL;

      SceFreeMemory(pDeleteNameList,SCE_STRUCT_NAME_LIST);

      if ( pSetting ) {
          status = pSetting->Status;
      }

      //
      // update current record
      //
      // status
      m_pData->SetStatus(GetGroupStatus(status, STATUS_GROUP_RECORD));
      // members status
      m_pData->SetBase(GetGroupStatus(status, STATUS_GROUP_MEMBERS));
      // memberof status
      m_pData->SetSetting(GetGroupStatus(status, STATUS_GROUP_MEMBEROF));
      m_pData->Update(m_pSnapin);
      //
      // update the dirty flag in the template
      //
      PEDITTEMPLATE pet;
      pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
      if (pet) {
         pet->SetDirty(AREA_GROUP_MEMBERSHIP);
      }

   } // failed

   SceFreeMemory(pTemplate,SCE_STRUCT_NAME_LIST);

   if ( FAILED(hr) ) {
       CString str;
       str.LoadString(IDS_SAVE_FAILED);
       AfxMessageBox(str);
   } else {
       CancelToClose();
       SetModified(TRUE);
       return TRUE;
   }
   return FALSE;
}

BOOL CAttrMember::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CAttrMember::DoContextHelp (HWND hWndControl)
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetSeceditHelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) a214HelpIDs) )
    {

    }
}


void CAttrMember::DeleteGroup(const CString &szGroupName)
{
    CSingleLock cSL(&m_CS, FALSE);
    cSL.Lock();

    PEDITTEMPLATE pet = NULL;
    PSCE_PROFILE_INFO pspi = NULL;
    PSCE_GROUP_MEMBERSHIP pFindGroup = NULL;
    PSCE_GROUP_MEMBERSHIP pDeleteGroup = NULL;

    pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
    if (pet) {
        pspi = pet->pTemplate;
    } else {
        pspi = NULL;
    }

    if ( pspi ) {

        //
        // find the group in the template and remove it
        //
        pFindGroup = pspi->pGroupMembership;

        if (pFindGroup == NULL)
            return;

        if (pFindGroup->GroupName == szGroupName) {

            pspi->pGroupMembership = pFindGroup->Next;
            pDeleteGroup = pFindGroup;

        } else {

            while (pFindGroup->Next && (pFindGroup->Next->GroupName != szGroupName)) {
                pFindGroup = pFindGroup->Next;
            }

            if (pFindGroup->Next) {

                pDeleteGroup = pFindGroup->Next;
                pFindGroup->Next = pDeleteGroup->Next;
            }
        }

        if (pDeleteGroup) {
            LocalFree(pDeleteGroup->GroupName);
            SceFreeMemory(pDeleteGroup->pMembers,SCE_STRUCT_NAME_LIST);
            SceFreeMemory(pDeleteGroup->pMemberOf,SCE_STRUCT_NAME_LIST);
            LocalFree(pDeleteGroup);
        }

    } else {
        //
        // error
        //
        ASSERT(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\anumber.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ANumber.cpp
//
//  Contents:   Implementation of CAttrNumber
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "ANumber.h"
#include "DDWarn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*--------------------------------------------------------------------------------------
The constant values below are used to retrieve the string ID of the description for
a range of values.
    struct {
    int     iMin        - >= The value must be greater than or equal to this value.
    int     iMax        - <= The value must be less than or equale to this value.
    WORD    uResource   - The resource id of the item.
    WORD    uMask       - Flag that describes which memebers are valid.  The Resource
                            ID must always be valid.  If a flag is not set for the
                            coorisponding item, then the point is not checked against
                            the value.

                            RDIF_MIN        - The [iMin] member is valid.
                            RDIF_MAX        - [iMax] member is valid.
                            RDIF_END        - This is the end of the array. The last
                                                item in all declarations must set this
                                                flag.
--------------------------------------------------------------------------------------*/
//
// Minimum password description for number attribute.
//
RANGEDESCRIPTION g_rdMinPassword[] =
{
    { 0,    0,      IDS_CHANGE_IMMEDIATELY,     RDIF_MIN | RDIF_MAX },
    { 1,    0,      IDS_PASSWORD_CHANGE,        RDIF_MIN | RDIF_END }
};


//
// Maximum password description for number attribute.
//
RANGEDESCRIPTION g_rdMaxPassword[] =
{
    { 1,    999,    IDS_PASSWORD_EXPIRE,        RDIF_MIN | RDIF_MAX },
    { 0,    0,      IDS_PASSWORD_FOREVER,       RDIF_MIN | RDIF_END},
};

//
// Password len descriptions.
//
RANGEDESCRIPTION g_rdPasswordLen[] =
{
    {0,     0,      IDS_PERMIT_BLANK,           RDIF_MIN | RDIF_MAX },
    {1,     0,      IDS_PASSWORD_LEN,           RDIF_MIN | RDIF_END }
};


//
// Password histroy description.
//
RANGEDESCRIPTION g_rdPasswordHistory[] =
{
    {0,     0,      IDS_NO_HISTORY,             RDIF_MIN | RDIF_MAX },
    {1,     0,      IDS_PASSWORD_REMEMBER,      RDIF_MIN | RDIF_END }
};

//
// Password lockout descriptions
//
RANGEDESCRIPTION g_rdLockoutAccount[] =
{
    {0,     0,      IDS_NO_LOCKOUT,             RDIF_MIN | RDIF_MAX },
    {1,     0,      IDS_LOCKOUT_AFTER,          RDIF_MIN | RDIF_END }
};

//
// Lockout duration description.
//
RANGEDESCRIPTION g_rdLockoutFor[] =
{
    {1,     0,      IDS_DURATION,               RDIF_MIN },
    {0,     0,      IDS_LOCKOUT_FOREVER,        RDIF_MAX | RDIF_END}
};

RANGEDESCRIPTION g_rdAutoDisconnect[] =
{
   { 1, 0, IDS_RNH_AUTODISCONNECT_STATIC, RDIF_MIN },
   { 0, 0, IDS_RNH_AUTODISCONNECT_SPECIAL, RDIF_MAX | RDIF_END}
};

RANGEDESCRIPTION g_rdPasswordWarnings[] =
{
   { 0, 0, IDS_RNH_PASSWORD_WARNINGS_SPECIAL, RDIF_MIN | RDIF_MAX},
   { 1, 0, IDS_RNH_PASSWORD_WARNINGS_STATIC, RDIF_MIN | RDIF_END}
};

RANGEDESCRIPTION g_rdCachedLogons[] =
{
   { 0, 0, IDS_RNH_CACHED_LOGONS_SPECIAL, RDIF_MIN | RDIF_MAX},
   { 1, 0, IDS_RNH_CACHED_LOGONS_STATIC, RDIF_MIN | RDIF_END}
};



/*--------------------------------------------------------------------------------------
Method:     GetRangeDescription

Synopsis:   This function was specifically created for SCE.  Call this function if the
            Item ID to, and current range value to retrieve the corrisponding string.

Arguments:  [uType]     - [in]  ID of the point you want the description for.
            [i]         - [in]  The point you want the description for.
            [pstrRet]   - [out] The return value.

Returns:    ERROR_SUCCESS       - The operation was successfull.
            ERROR_INVALID_DATA  - The id may not be supported or [pstrRet] is NULL.
            Other Win32 errors if resource loading was not successful.

--------------------------------------------------------------------------------------*/
DWORD
GetRangeDescription(
    IN  UINT uType,
    IN  int i,
    OUT CString *pstrRet
    )
{
    switch(uType){
    case IDS_LOCK_DURATION:
        uType = GetRangeDescription(g_rdLockoutFor, i);
        break;
    case IDS_MAX_PAS_AGE:
        uType = GetRangeDescription(g_rdMaxPassword, i);
        break;
    case IDS_LOCK_COUNT:
        uType = GetRangeDescription(g_rdLockoutAccount, i);
        break;
    case IDS_MIN_PAS_AGE:
        uType = GetRangeDescription(g_rdMinPassword, i);
        break;
    case IDS_MIN_PAS_LEN:
        uType = GetRangeDescription(g_rdPasswordLen, i);
        break;
    case IDS_PAS_UNIQUENESS:
        uType = GetRangeDescription(g_rdPasswordHistory, i);
        break;
    case IDS_LOCK_RESET_COUNT:
       uType = 0;
       break;

    default:
        uType = 0;
    }

    if(uType && pstrRet){
        //
        // Try to load the resource string.
        //
        __try {
            if( pstrRet->LoadString(uType) ){
                return ERROR_SUCCESS;
            }
        } __except(EXCEPTION_CONTINUE_EXECUTION) {
            return (DWORD)E_POINTER;
        }
        return GetLastError();
    }
    return ERROR_INVALID_DATA;
}


/*--------------------------------------------------------------------------------------
Method:     GetRangeDescription

Synopsis:   This function works directly with the RANGEDESCRIPTION structure.  Tests
            to see which string resource ID to return.  This is determined by testing [i]
            with the [iMin] and [iMax] value of a RANGEDESCRIPTION structure. RDIF_MIN
            or/and RDIF_MAX must be set in the [uMask] member for this function to
            perform any comparisons

Arguments:  [pDesc]     - [in]  An array of RANGEDESCRIPTIONS, the last member of this
                                array must set RDIF_END flag in the [uMask] member.
            [i]         - [in]  The point to test.

Returns:    A String resource ID if successfull.  Otherwise 0.

--------------------------------------------------------------------------------------*/
UINT
GetRangeDescription(
    RANGEDESCRIPTION *pDesc,
    int i
    )
{
    RANGEDESCRIPTION *pCur = pDesc;
    if(!pDesc){
        return 0;
    }

    //
    // The uMask member of the description tells us wich members
    // of the structure is valid.
    //
    while( 1 ){
        if( (pCur->uMask & RDIF_MIN) ) {
            //
            // Test the minimum.
            //
            if(i >= pCur->iMin){
                if(pCur->uMask & RDIF_MAX){
                    //
                    // Test the maximum.
                    //
                    if( i <= pCur->iMax) {
                        return pCur->uResource;
                    }
                } else {
                    return pCur->uResource;
                }
            }
        } else if(pCur->uMask & RDIF_MAX) {
            //
            // Test only the maximum.
            //
            if(i <= pCur->iMax){
                return pCur->uResource;
            }
        }

        if(pCur->uMask & RDIF_END){
            //
            // This is the last element of the array, so end the loop.
            //
            break;
        }
        pCur++;
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CAttrNumber dialog
CAttrNumber::CAttrNumber(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
    m_cMinutes(0), 
    m_nLow(0), 
    m_nHigh(999), 
    m_nSave(0), 
    m_pRDescription(NULL)
{
    //{{AFX_DATA_INIT(CAttrNumber)
    m_strUnits = _T("");
    m_strSetting = _T("");
    m_strBase = _T("");
    m_strTemplateTitle = _T("");
    m_strLastInspectTitle = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a168HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrNumber::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrNumber)
    DDX_Control(pDX, IDC_SPIN, m_SpinValue);
    DDX_Text(pDX, IDC_UNITS, m_strUnits);
    DDX_Text(pDX, IDC_CURRENT, m_strSetting);
    DDX_Text(pDX, IDC_NEW, m_strBase);
    DDX_Text(pDX, IDC_TEMPLATE_TITLE, m_strTemplateTitle);
    DDX_Text(pDX, IDC_LI_TITLE, m_strLastInspectTitle);
    DDX_Text(pDX, IDC_RANGEERROR,m_strError);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrNumber, CAttribute)
    //{{AFX_MSG_MAP(CAttrNumber)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN, OnDeltaposSpin)
    ON_EN_KILLFOCUS(IDC_NEW, OnKillFocusNew)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_EN_UPDATE(IDC_NEW, OnUpdateNew)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrNumber message handlers

void CAttrNumber::OnDeltaposSpin( NMHDR* pNMHDR, LRESULT* pResult )
{
    NM_UPDOWN FAR *pnmud = (NM_UPDOWN FAR *)pNMHDR;

    if ( pnmud ) {

        //
        // get current value
        //
        long lVal = CurrentEditValue();

        if (SCE_FOREVER_VALUE == lVal) {
           if (pnmud->iDelta > 0) {
              if (m_cMinutes & DW_VALUE_OFF) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           } else {
              lVal = m_nLow;
           }
        } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
           if (pnmud->iDelta < 0) {
              if (m_cMinutes & DW_VALUE_FOREVER) {
                 lVal = SCE_FOREVER_VALUE;
              } else {
                 lVal = m_nLow;
              }
           } else {
              lVal = m_nHigh;
           }
        } else {
           lVal -= (LONG)(m_iAccRate*pnmud->iDelta);

           if ( lVal > m_nHigh ) {
               // if it is overflow, go back to low
               if ( m_cMinutes & DW_VALUE_OFF ) {
                  lVal = SCE_KERBEROS_OFF_VALUE;

               } else if (m_cMinutes & DW_VALUE_FOREVER) {
                  lVal = SCE_FOREVER_VALUE;
               } else {
                  lVal = m_nLow;
               }
           } else if ( (lVal < m_nLow) &&
                ((lVal != SCE_KERBEROS_OFF_VALUE) || !(m_cMinutes & DW_VALUE_OFF)) &&
                ((lVal != SCE_FOREVER_VALUE) || !(m_cMinutes & DW_VALUE_FOREVER))) {
               // if it is underflow, go back to high
              if ( (m_cMinutes & DW_VALUE_FOREVER) && (lVal != SCE_FOREVER_VALUE)) {
                 lVal = SCE_FOREVER_VALUE;
              } else if ((m_cMinutes & DW_VALUE_OFF) && (lVal != SCE_KERBEROS_OFF_VALUE)) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           }


           if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
               // zero is not allowed
               if ( m_nLow > 0 ) {
                   lVal = m_nLow;
               } else {
                   lVal = 1;
               }
           }
        }

        SetValueToEdit(lVal);
    }

    *pResult = 0;
}

void CAttrNumber::OnKillFocusNew()
{
   LONG lVal = CurrentEditValue();

   SetValueToEdit(lVal);
}

void CAttrNumber::SetValueToEdit(LONG lVal)
{
    CString strNew;

    if ( m_iStaticId )
        m_strTemplateTitle.LoadString(m_iStaticId);
    else
        m_strTemplateTitle = _T("");

    if ( 0 == lVal ) {
        strNew.Format(TEXT("%d"),lVal);

        if ( m_cMinutes & DW_VALUE_NEVER &&
                  m_iNeverId > 0 ) {
            // change to never
            m_strTemplateTitle.LoadString(m_iNeverId);
        }

    } else if ( SCE_FOREVER_VALUE == lVal ) {

        strNew.LoadString(IDS_FOREVER);
        if ( m_iNeverId )
            m_strTemplateTitle.LoadString(m_iNeverId);

    } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
       strNew.LoadString(IDS_OFF);
       if ( m_iNeverId ) {
           m_strTemplateTitle.LoadString(m_iNeverId);
       }
    } else {

        strNew.Format(TEXT("%d"),lVal);
    }
    m_nSave = lVal;

   SetDlgItemText(IDC_NEW,strNew);
   SetDlgItemText(IDC_TEMPLATE_TITLE,m_strTemplateTitle);
   SetModified(TRUE);
}

LONG CAttrNumber::CurrentEditValue()
{
   UINT uiVal = 0;
   LONG lVal = 0;
   BOOL bTrans = FALSE;

   uiVal = GetDlgItemInt(IDC_NEW,&bTrans,FALSE);
   lVal = uiVal;
   if (!bTrans ) {
      // if ( 0 == lVal && !bTrans ) {
      // errored, overflow, or nonnumeric

      CString str;
      if(m_cMinutes & DW_VALUE_FOREVER){
         str.LoadString(IDS_FOREVER);
         if(str == m_strBase){
            return SCE_FOREVER_VALUE;
         }
      }

      lVal = _ttol((LPCTSTR)m_strBase);
      if ( lVal == 0 ) {
         //
         // nonnumeric
         //
         lVal = (LONG) m_nSave;
         return lVal;
      }
   }

   if ( m_iAccRate > 1 && lVal > 0 ) {
      //
      // for log max size, make it multiples of m_iAccRate
      //
      int nCount = lVal % m_iAccRate;
      if ( nCount > 0 ) {
         lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
      }
   }
   if ( lVal > m_nHigh ) {
      // if it is overflow, go back to low
      if ( m_cMinutes & DW_VALUE_FOREVER ) {
         lVal = SCE_FOREVER_VALUE;
      } else if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else if ( m_cMinutes & DW_VALUE_FOREVER) {
         lVal = SCE_FOREVER_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
      // zero is not allowed
      if ( m_nLow > 0 ) {
         lVal = m_nLow;
      } else {
         lVal = 1;
      }
   }

   return lVal;
}


void CAttrNumber::OnConfigure()
{
   CWnd *cwnd;

   CAttribute::OnConfigure();

   //
   // Enable disable OK button depending on the state of the other controls.
   //
   cwnd = GetDlgItem(IDOK);
   if(cwnd){
       if(!m_bConfigure){
          cwnd->EnableWindow(TRUE);
       } else {
          OnUpdateNew();
       }
   }
}

BOOL CAttrNumber::OnInitDialog()
{
   CAttribute::OnInitDialog();

   UpdateData(TRUE);
/*
   if (m_bMinutes) {
      m_SpinValue.SetRange(-1,UD_MAXVAL-1);
   } else {
      m_SpinValue.SetRange(0,UD_MAXVAL);
   }
*/

   AddUserControl(IDC_NEW);
   AddUserControl(IDC_SPIN);

   OnConfigure();

   return TRUE;  // return TRUE unless you set the focus to a control
               // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      BOOL bUpdateAll = FALSE;
      DWORD dw = 0;
      CString strForever,strOff;
      int status = 0;

      UpdateData(TRUE);
   
      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else
         dw = CurrentEditValue();
   

      bUpdateAll = FALSE;


      CEditTemplate *pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);

      //
      // Check the numbers dependencies if a dependency fails then the dialog
      // will return ERROR_MORE_DATA and we can display more information for the user
      // to see.
      //
      if(DDWarn.CheckDependencies( dw ) == ERROR_MORE_DATA )
      {
         //
         // If the user presses cancel then we won't let them set this item's information
         // until they have set the configurion for the other items.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // The user pressed Auto set so we can set the other items.  They are automatically set
         // to the correct values.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               status = m_pSnapin->SetAnalysisInfo(
                                       pItem->pResult->GetID(),
                                       pItem->dwSuggested,
                                       pItem->pResult);
               pItem->pResult->SetStatus( status );

               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      //
      // Update the items security profile.
      // and redraw.
      //
      m_pData->SetBase((LONG_PTR)ULongToPtr(dw));
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),(LONG_PTR)ULongToPtr(dw), m_pData);
      m_pData->SetStatus(status);
      m_pData->Update(m_pSnapin, FALSE);
   }

   return CAttribute::OnApply();
}

void CAttrNumber::Initialize(CResult * pResult)
{
    LONG_PTR dw=0;

    CAttribute::Initialize(pResult);

    DDWarn.InitializeDependencies(m_pSnapin,pResult);

    m_strUnits = pResult->GetUnits();

    m_cMinutes = DW_VALUE_NOZERO;
    m_nLow = 0;
    m_nHigh = 999;
    m_nSave = 0;
    m_iNeverId = 0;
    m_iAccRate = 1;
    m_iStaticId = 0;

    CEditTemplate *pTemplate = pResult->GetBaseProfile();
     switch (pResult->GetID()) {
     // below no zero value
     case IDS_LOCK_DURATION:
         m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
         m_nHigh = 99999;
         m_iStaticId = IDS_DURATION;
         m_iNeverId = IDS_LOCKOUT_FOREVER;
         m_pRDescription = g_rdLockoutAccount;
         break;
     case IDS_MAX_PAS_AGE:
         m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
         m_iStaticId = IDS_PASSWORD_EXPIRE;
         m_iNeverId = IDS_PASSWORD_FOREVER;
         break;
         // below zero value means differently
     case IDS_LOCK_COUNT:
         m_cMinutes = DW_VALUE_NEVER;
         m_iNeverId = IDS_NO_LOCKOUT;
         m_iStaticId = IDS_LOCKOUT_AFTER;
         break;
     case IDS_MIN_PAS_AGE:
         m_cMinutes = DW_VALUE_NEVER;
         m_iNeverId = IDS_CHANGE_IMMEDIATELY;
         m_iStaticId = IDS_PASSWORD_CHANGE;
         m_nHigh = 998;
         m_pRDescription = g_rdMinPassword;
         break;
     case IDS_MIN_PAS_LEN:
         m_cMinutes = DW_VALUE_NEVER;
         m_nHigh = 14;
         m_iNeverId = IDS_PERMIT_BLANK;
         m_iStaticId = IDS_PASSWORD_LEN;
         m_pRDescription = g_rdPasswordLen;
         break;
     case IDS_PAS_UNIQUENESS:
         m_cMinutes = DW_VALUE_NEVER;
         m_nHigh = 24;
         m_iNeverId = IDS_NO_HISTORY;
         m_iStaticId = IDS_PASSWORD_REMEMBER;
         break;
         // below there is no zero values
     case IDS_LOCK_RESET_COUNT:
         m_nLow = 1;
         m_nHigh = 99999;
         m_iStaticId = IDS_LOCK_RESET_COUNT;
         break;
     case IDS_SYS_LOG_MAX:
     case IDS_SEC_LOG_MAX:
     case IDS_APP_LOG_MAX:
         m_nLow = 64;
         m_nHigh = 4194240;
         m_iAccRate = 64;
         // no static text
         break;
     case IDS_SYS_LOG_DAYS:
     case IDS_SEC_LOG_DAYS:
     case IDS_APP_LOG_DAYS:
         m_nHigh = 365;
         m_nLow = 1;
         m_iStaticId = IDS_OVERWRITE_EVENT;
         break;
    case IDS_KERBEROS_MAX_AGE:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
       m_nHigh = 99999;
       m_iStaticId = IDS_TICKET_EXPIRE;
       m_iNeverId = IDS_TICKET_FOREVER;
       break;
    case IDS_KERBEROS_RENEWAL:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO; // | DW_VALUE_OFF;
       m_nHigh = 99999;
       m_iStaticId = IDS_TICKET_RENEWAL_EXPIRE;
       m_iNeverId = IDS_TICKET_RENEWAL_FOREVER;
       break;
     case IDS_KERBEROS_MAX_SERVICE:
        m_nLow = 10;
        m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
        m_iStaticId = IDS_TICKET_EXPIRE;
        m_iNeverId = IDS_TICKET_FOREVER;
        m_nHigh = 99999;
        break;
     case IDS_KERBEROS_MAX_CLOCK:
        m_cMinutes = DW_VALUE_FOREVER;
        m_nHigh = 99999;
        m_iStaticId = IDS_MAX_TOLERANCE;
        m_iNeverId = IDS_NO_MAX_TOLERANCE;
        break;
     }

     if ((m_cMinutes & DW_VALUE_NOZERO) && (0 == m_nLow)) {
        m_nLow = 1;
     }

    m_strTemplateTitle = _T("");
    m_strLastInspectTitle = _T("");

    m_strBase.Empty();
    m_strSetting.Empty();

    dw = pResult->GetBase();
    if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) 
    {
       m_bConfigure = FALSE;
    } 
    else 
    {
       m_bConfigure = TRUE;
       SetInitialValue(PtrToUlong((PVOID)dw));
    }

    pResult->GetDisplayName( NULL, m_strSetting, 2 );
    dw = pResult->GetSetting();
    if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != dw) {
       if ((LONG_PTR)ULongToPtr(SCE_FOREVER_VALUE) == dw) {
          if ( (m_cMinutes & DW_VALUE_FOREVER) &&
               m_iNeverId > 0 ) {
              m_strLastInspectTitle.LoadString(m_iNeverId);
          }
       } else {
         if ( 0 == dw && (m_cMinutes & DW_VALUE_NEVER) &&
              m_iNeverId > 0 ) {
             // zero means different values
             m_strLastInspectTitle.LoadString(m_iNeverId);
         } else if ( m_iStaticId > 0 ) {
             m_strLastInspectTitle.LoadString(m_iStaticId);
         }
       }
    }

}

void CAttrNumber::SetInitialValue(DWORD_PTR dw) 
{
   //
   // Don't overwrite an already set value.
   //
   if (!m_strBase.IsEmpty()) 
   {
      return;
   }

   if (SCE_FOREVER_VALUE == dw) {
      m_strBase.LoadString(IDS_FOREVER);
      if ( (m_cMinutes & DW_VALUE_FOREVER) &&
           m_iNeverId > 0 ) {
         m_strTemplateTitle.LoadString(m_iNeverId);
      }
      m_nSave = SCE_FOREVER_VALUE;
   } else if (SCE_KERBEROS_OFF_VALUE == dw) {
      m_strBase.LoadString(IDS_OFF);
      if ( (m_cMinutes & DW_VALUE_OFF) &&
           m_iNeverId > 0 ) {
         m_strTemplateTitle.LoadString(m_iNeverId);
      }
      m_nSave = SCE_KERBEROS_OFF_VALUE;
   } 
   else 
   {
      m_nSave = dw;
      if ( 0 == dw && (m_cMinutes & DW_VALUE_NEVER) &&
           m_iNeverId > 0 ) {
         // zero means different values
         m_strTemplateTitle.LoadString(m_iNeverId);
      } else if ( m_iStaticId > 0 ) {
         m_strTemplateTitle.LoadString(m_iStaticId);
      }
      m_strBase.Format(TEXT("%d"),dw);
   }
}

void CAttrNumber::OnUpdateNew()
{
   DWORD dwRes = 0;
   UpdateData(TRUE);
   CString sNum;
   CEdit *pEdit = (CEdit *)GetDlgItem(IDC_NEW);
   CWnd  *pOK  = GetDlgItem(IDOK);

   DWORD dwValue = _ttoi(m_strBase);

   //
   // Don't do anything if the string is equal to predefined strings.
   //
   sNum.LoadString(IDS_FOREVER);

   if (m_strBase.IsEmpty()) {
      if (pOK) {
         pOK->EnableWindow(FALSE);
      }

   } else if (m_strBase == sNum) {
      if (pOK) {
         pOK->EnableWindow(TRUE);
      }

   } else {
      if ((long)dwValue < m_nLow) {
         //
         // Disable the OK button.
         //
         if ( pOK ) {
            pOK->EnableWindow(FALSE);
         }

         if (pEdit) {
            //
            // We will only force a select if edit text length >=
            //  minimum text length
            //
            sNum.Format(TEXT("%d"), m_nLow);
            dwValue = m_nLow;
            if (sNum.GetLength() < m_strBase.GetLength()) {
               pEdit->SetSel(0, -1);
            }
         }
      } else if ( (long)dwValue > m_nHigh ) {
         if (pOK) {
            pOK->EnableWindow(TRUE);
         }
         if (pEdit) {
            if (m_cMinutes & DW_VALUE_FOREVER) {
               sNum.LoadString(IDS_FOREVER);
               dwValue = 0;
            } else {
               sNum.Format(TEXT("%d"), m_nHigh);
               dwValue = m_nHigh;
            }
            m_strBase = sNum;
            UpdateData(FALSE);
            pEdit->SetSel(0, -1);
         }
      } else {

         //
         // Enable the OK button.
         //
         if (pOK) {
            pOK->EnableWindow(TRUE);
         }
      }
   }

   //
   // Load the description for this string.
   //
   if ((dwValue <= 0) && (m_iNeverId != 0)) {
      m_strTemplateTitle.LoadString(m_iNeverId);
   } else {
      m_strTemplateTitle.LoadString(m_iStaticId);
   }
   GetDlgItem(IDC_TEMPLATE_TITLE)->SetWindowText(m_strTemplateTitle);

   SetModified(TRUE); //Raid #404145
}

BOOL CAttrNumber::OnKillActive() 
{
   UINT uiVal = 0;
   LONG lVal = 0;
   BOOL bTrans = FALSE;
   CString strRange;
   int lMin = m_nLow;

   UpdateData(TRUE);

   if (m_cMinutes & DW_VALUE_NOZERO &&
       !(m_cMinutes & DW_VALUE_FOREVER) &&
       lMin == 0) {
      lMin = 1;
   }

   CString strFormat;
   strFormat.LoadString(IDS_RANGE);
   strRange.Format(strFormat,lMin,m_nHigh);

   uiVal = GetDlgItemInt(IDC_NEW,&bTrans,TRUE);
   lVal = uiVal;
   if ( !bTrans ) {
      CString str;
      if (m_cMinutes & DW_VALUE_FOREVER) {
         str.LoadString(IDS_FOREVER);
         if (str == m_strBase) {
            return TRUE;;
         }
      }
      lVal = _ttol((LPCTSTR)m_strBase);
      if ( lVal == 0 ) 
      {
         // nonnumeric
         lVal = (LONG) m_nSave;
         m_strError = strRange;
         UpdateData(FALSE);
         return FALSE;
      }
   }

   if ( m_iAccRate > 1 && lVal > 0 ) {
      // for log max size, make it multiples of m_iAccRate
      int nCount = lVal % m_iAccRate;
      if ( nCount > 0 ) {
         lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
      }
   }
   if ( lVal > m_nHigh ) {
      m_strError = strRange;
      UpdateData(FALSE);
      return FALSE;
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else if ( m_cMinutes & DW_VALUE_FOREVER) {
         lVal = SCE_FOREVER_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      m_strError = strRange;
      UpdateData(FALSE);
      return FALSE;
   }

   if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
      // zero is not allowed
      m_strError = strRange;
      UpdateData(FALSE);
      return FALSE;
   }

   return CAttribute::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aobject.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AObject.cpp
//
//  Contents:   Implementation of CAttrObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "util.h"
#include <accctrl.h>
#include "servperm.h"
#include "AObject.h"

#include <aclapi.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrObject dialog


CAttrObject::CAttrObject()
: CAttribute(IDD), 
m_pSceInspect(NULL), 
m_pSceTemplate(NULL), 
posInspect(NULL), 
posTemplate(NULL),
  m_bNotAnalyzed(FALSE), m_pfnCreateDsPage(NULL), m_pSI(NULL), m_pNewSD(NULL), m_pAnalSD(NULL),
  m_pCDI(NULL), m_AnalInfo(0), m_NewSeInfo(0), m_hwndTemplate(NULL), m_hwndInspect(NULL), m_pFolder(NULL)

{
   //{{AFX_DATA_INIT(CAttrObject)
   m_strLastInspect = _T("");
        m_radConfigPrevent = 0;
        m_radInheritOverwrite = 0;
        //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a198HelpIDs;
   m_uTemplateResID = IDD;
}

CAttrObject::~CAttrObject()
{
    if (::IsWindow(m_hwndInspect))
    {
        m_pSceInspect->Destroy(m_hwndInspect);
        m_hwndInspect = NULL;
    }
    delete m_pSceInspect;
    m_pSceInspect = NULL;

    if (::IsWindow(m_hwndTemplate))
    {
        m_pSceTemplate->Destroy(m_hwndTemplate);
        m_hwndTemplate = NULL;
    }
    delete m_pSceTemplate;
    m_pSceTemplate = NULL;
}

void CAttrObject::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAttrObject)
   DDX_Text(pDX, IDC_INSPECTED, m_strLastInspect);
        DDX_Radio(pDX, IDC_CONFIG, m_radConfigPrevent);
        DDX_Radio(pDX, IDC_INHERIT, m_radInheritOverwrite);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrObject, CAttribute)
//{{AFX_MSG_MAP(CAttrObject)
ON_BN_CLICKED(IDC_TEMPLATE_SECURITY, OnTemplateSecurity)
ON_BN_CLICKED(IDC_INSPECTED_SECURITY, OnInspectedSecurity)
ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_BN_CLICKED(IDC_CONFIG, OnConfig)
    ON_BN_CLICKED(IDC_PREVENT, OnPrevent)
    ON_BN_CLICKED(IDC_OVERWRITE, OnOverwrite)
    ON_BN_CLICKED(IDC_INHERIT, OnInherit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrObject message handlers

void CAttrObject::OnConfigure()
{
   CAttribute::OnConfigure();
   if ( m_bConfigure ) {
      //
      // Ensure that the security descriptor is set.
      //
      if( !m_pNewSD ){
        OnTemplateSecurity();
      }
      UpdateData(FALSE);
   }

   BOOL bEnable = TRUE;
   if(m_pFolder){
      DWORD dwStatus = 0;
      m_pFolder->GetObjectInfo( &dwStatus, NULL );

      switch( dwStatus ){
      case SCE_STATUS_NOT_ANALYZED:
      case SCE_STATUS_ERROR_NOT_AVAILABLE:
      case SCE_STATUS_NOT_CONFIGURED:
         bEnable = FALSE;
         break;
      default:
         bEnable = m_pAnalSD || m_AnalInfo;
      }
   } else {
      bEnable = m_pAnalSD || m_AnalInfo;
   }

   if (m_bConfigure) {
      if (0 == m_radConfigPrevent) {
         OnConfig();
      } else {
         OnPrevent();
      }
   }
}

void CAttrObject::Initialize(CFolder *pFolder,
                             CComponentDataImpl *pCDI) {

   CAttribute::Initialize(NULL);
   m_strName = pFolder->GetName();
   m_strPath = pFolder->GetName();
   m_dwType  = pFolder->GetType();
   switch (pFolder->GetType()) {
      case REG_OBJECTS:
         m_dwType = ITEM_REGSD;
         break;
      case FILE_OBJECTS:
         m_dwType = ITEM_FILESD;
         break;
      default:
         m_dwType = 0;
         break;
   }
   m_pObject = (PSCE_OBJECT_LIST)pFolder->GetData();
   m_pHandle = pCDI->GetSadHandle();
   m_pCDI = pCDI;

   m_pFolder = pFolder;
   Initialize2();
}

void CAttrObject::Initialize(CResult *pResult) {
   CAttribute::Initialize(pResult);

   m_strName = pResult->GetAttr();
   m_strPath = pResult->GetUnits();
   m_pHandle = (HANDLE)pResult->GetID();
   m_dwType  = pResult->GetType();
   m_pObject = (PSCE_OBJECT_LIST)pResult->GetBaseProfile();
   m_pCDI = NULL;

   Initialize2();
}

void CAttrObject::Initialize2()
{
   LPTSTR szPath;
   SCESTATUS status;

   AREA_INFORMATION Area;


   switch (m_dwType) {
      case ITEM_REGSD:
         Area = AREA_REGISTRY_SECURITY;
         break;
      case ITEM_FILESD:
         Area = AREA_FILE_SECURITY;
         break;
      default:
         ASSERT(FALSE);
         return;
   }

   m_pNewSD = NULL;
   m_NewSeInfo = 0;
   if ( m_pSI ) {
      m_pSI->Release();
      m_pSI = NULL;
   }
   m_pfnCreateDsPage=NULL;

   szPath = m_strPath.GetBuffer(1);

   status = SceGetObjectSecurity(m_pHandle,
                                 SCE_ENGINE_SMP,
                                 Area,
                                 szPath,
                                 &posTemplate);
   m_strPath.ReleaseBuffer();

   if (SCESTATUS_SUCCESS == status && posTemplate ) {
      switch (posTemplate-> Status) {
         case SCE_STATUS_IGNORE:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
         case SCE_STATUS_OVERWRITE:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 1;
            break;
         case SCE_STATUS_CHECK:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 0;
            break;
         default:
         case SCE_STATUS_NO_AUTO_INHERIT:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
      }

      if ( posTemplate->pSecurityDescriptor ) {

         MyMakeSelfRelativeSD(posTemplate->pSecurityDescriptor,
                              &m_pNewSD);
      }
      m_NewSeInfo = posTemplate->SeInfo;

   } else {
      m_bConfigure = FALSE;
   }

   szPath = m_strPath.GetBuffer(1);
   status = SceGetObjectSecurity(m_pHandle,
                                 SCE_ENGINE_SAP,
                                 Area,
                                 szPath,
                                 &posInspect);
   m_strPath.ReleaseBuffer();

   //
   // Display the same thing we displayed on the result pane
   //
   if (m_pFolder) {
      m_pFolder->GetDisplayName( m_strLastInspect, 1 );
   } else if (m_pData) {
      m_pData->GetDisplayName(0, m_strLastInspect, 1);
   } else {
      ASSERT(0);
      m_strLastInspect.LoadString(IDS_ERROR_VALUE);
   }

   //
   // if the item is good, there will be no SAP record, but a template record exists.
   //
   if ( posInspect ) {
      m_pAnalSD = posInspect->pSecurityDescriptor;
      m_AnalInfo = posInspect->SeInfo;
      //
      // We don't need to display children not configured in the dialog box.
      // Instead display the actual status of the item.
      //
      if( posInspect->Status == SCE_STATUS_CHILDREN_CONFIGURED) {
         m_strLastInspect.LoadString(IDS_NOT_CONFIGURED);
      }
      switch(posInspect->Status &
             ~(SCE_STATUS_PERMISSION_MISMATCH | SCE_STATUS_AUDIT_MISMATCH)) {
         case SCE_STATUS_CHILDREN_CONFIGURED:
         case SCE_STATUS_NOT_CONFIGURED:
         case SCE_STATUS_ERROR_NOT_AVAILABLE:
         case SCE_STATUS_NEW_SERVICE:
         case SCE_STATUS_NOT_ANALYZED:
            m_bNotAnalyzed = TRUE;
            break;
      }
   } else if ( posTemplate ) {
      m_pAnalSD = posTemplate->pSecurityDescriptor;
      m_AnalInfo = posTemplate->SeInfo;
   } else {
      m_bNotAnalyzed = TRUE;
   }

}

void CAttrObject::OnInspectedSecurity()
{
   SE_OBJECT_TYPE SeType;

   //
   // If we already have the inspected security window up then
   // don't bring up a second.
   //
   if (IsWindow(m_hwndInspect)) {
      ::BringWindowToTop(m_hwndInspect);
      return;
   }

   switch (m_dwType) {
      case ITEM_REGSD:
         SeType = SE_REGISTRY_KEY;
         break;
      case ITEM_FILESD:
         SeType = SE_FILE_OBJECT;
         break;
      default:
         ASSERT(FALSE);
         return;
   }

   if ( m_pAnalSD || m_AnalInfo ) {

      INT_PTR nRet;

      if ( SE_DS_OBJECT == SeType ) {

         if ( !m_pfnCreateDsPage ) {
            if (!g_hDsSecDll)
               g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

            if ( g_hDsSecDll) {
               m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                                      "DSCreateISecurityInfoObject");
            }
         }

         if ( m_pfnCreateDsPage ) {
            nRet= MyCreateDsSecurityPage(&m_pSI,
                                         m_pfnCreateDsPage,
                                         &m_pAnalSD,
                                         &m_AnalInfo,
                                         (LPCTSTR)(m_strName),
                                         ANALYSIS_SECURITY_PAGE_READ_ONLY,
                                         GetSafeHwnd());
         } else
            nRet = -1;

      } else {

         BOOL bContainer;
         if ( SE_FILE_OBJECT == SeType ) {

            if ( m_pObject )
                bContainer = m_pObject->IsContainer;
            else
               bContainer = TRUE;
         } else
            bContainer = TRUE;

         if (NULL == m_pSceInspect)
         {
             m_pSceInspect = new CModelessSceEditor(bContainer ? true : false,
                                           ANALYSIS_SECURITY_PAGE_READ_ONLY,
                                           GetSafeHwnd(),
                                           SeType,
                                           m_strName);
         }

         if (NULL != m_pSceInspect)
            m_pSceInspect->Create(&m_pAnalSD, &m_AnalInfo, &m_hwndInspect);
      }
/*
      BUG 147087 - don't display message, since this may have been canceled
      if (NULL == m_hwndInspect) {
         CString str;
         str.LoadString(IDS_CANT_SHOW_SECURITY);
         AfxMessageBox(str);
      }
*/
   }
}

void CAttrObject::OnTemplateSecurity()
{
   SE_OBJECT_TYPE SeType;

   //
   // If we already have the inspected security window up then
   // don't bring up a second.
   //
   if (IsWindow(m_hwndTemplate)) {
      ::BringWindowToTop(m_hwndTemplate);
      return;
   }

   switch (m_dwType) {
      case ITEM_REGSD:
         SeType = SE_REGISTRY_KEY;
         break;
      case ITEM_FILESD:
         SeType = SE_FILE_OBJECT;
         break;
      default:
         ASSERT(FALSE);
         return;
   }

   INT_PTR nRet;

   nRet = -1;

   if ( SE_DS_OBJECT == SeType ) {

      if ( !m_pfnCreateDsPage ) {
         if (!g_hDsSecDll)
            g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

         if ( g_hDsSecDll) {
            m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                                   "DSCreateISecurityInfoObject");
         }
      }

      if ( m_pfnCreateDsPage ) {
         nRet= MyCreateDsSecurityPage(&m_pSI,
                                      m_pfnCreateDsPage,
                                      &m_pNewSD,
                                      &m_NewSeInfo,
                                      (LPCTSTR)(m_strName),
                                      CONFIG_SECURITY_PAGE,
                                      GetSafeHwnd());
      } else
         nRet = -1;

   } else {

      BOOL bContainer = TRUE;

        if ( !m_pNewSD ) {

            //
            // if SD is NULL, then inherit is set.
            //
            DWORD SDSize;

            if ( SE_FILE_OBJECT == SeType ) {
               GetDefaultFileSecurity(&m_pNewSD,&m_NewSeInfo);
            } else {
               GetDefaultRegKeySecurity(&m_pNewSD,&m_NewSeInfo);
            }
        }

        // use m_pSceTemplate to create a modeless
        if (NULL == m_pSceTemplate)
        {
            m_pSceTemplate = new CModelessSceEditor(TRUE,
                                           CONFIG_SECURITY_PAGE,
                                           GetSafeHwnd(),
                                           SeType,
                                           m_strName);
        }

        if (NULL != m_pSceTemplate)
            m_pSceTemplate->Create(&m_pNewSD, &m_NewSeInfo, &m_hwndTemplate);
   }

   if (NULL == m_hwndTemplate ) {
/*
      BUG 147098 - don't display message, since this may have been canceled
      CString str;
      str.LoadString(IDS_CANT_ASSIGN_SECURITY);
      AfxMessageBox(str);
*/
   } else {
      SetModified(TRUE);
   }

}

BOOL CAttrObject::OnInitDialog()
{
   CAttribute::OnInitDialog();


   GetDlgItem(IDC_INSPECTED_SECURITY)->EnableWindow(!m_bNotAnalyzed);

   UpdateData(FALSE);
   AddUserControl(IDC_OVERWRITE);
   AddUserControl(IDC_INHERIT);
   AddUserControl(IDC_CONFIG);
   AddUserControl(IDC_PREVENT);
   AddUserControl(IDC_TEMPLATE_SECURITY);
  // AddUserControl(IDC_INSPECTED_SECURITY);

   OnConfigure();

   if (ITEM_REGSD == m_dwType) {
      CString str;
      str.LoadString(IDS_REGISTRY_CONFIGURE);
      SetDlgItemText(IDC_CONFIG,str);
      str.LoadString(IDS_REGISTRY_APPLY);
      SetDlgItemText(IDC_OVERWRITE,str);
      str.LoadString(IDS_REGISTRY_INHERIT);
      SetDlgItemText(IDC_INHERIT,str);
      str.LoadString(IDS_REGISTRY_PREVENT);
      SetDlgItemText(IDC_PREVENT,str);
   }

   if (m_bConfigure) {
      if (0 == m_radConfigPrevent) {
         OnConfig();
      } else {
         OnPrevent();
      }
   }
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CAttrObject::OnApply()
{
   // OnQueryCancel does all gestures and returns false if child windows are up
   if (!OnQueryCancel())
       return FALSE;

   if ( !m_bReadOnly )
   {
      LPTSTR szPath;

      UpdateData(TRUE);

      AREA_INFORMATION Area = 0;

      switch (m_dwType) {
         case ITEM_REGSD:
            Area = AREA_REGISTRY_SECURITY;
            break;
         case ITEM_FILESD:
            Area = AREA_FILE_SECURITY;
            break;
         default:
            ASSERT(FALSE);
      }

      if ( (NULL != m_pHandle) && (0 != Area) ) {

         SCESTATUS sceStatus=SCESTATUS_SUCCESS;
         BYTE status;

         if ( (m_pSnapin && m_pSnapin->CheckEngineTransaction()) ||
              (m_pCDI && m_pCDI->EngineTransactionStarted()) ) {


            if (!m_bConfigure ) {

               if ( NULL != posTemplate ) {
                  BOOL bContainer;

                  if ( m_pObject ) {
                     bContainer = m_pObject->IsContainer;
                  } else {
                     bContainer = TRUE;
                  }

                  //
                  // delete the SMP entry
                  //
                  szPath = m_strPath.GetBuffer(1);
                  sceStatus = SceUpdateObjectInfo(
                                                 m_pHandle,
                                                 Area,
                                                 szPath,
                                                 wcslen(szPath),
                                                 (BYTE)SCE_NO_VALUE,
                                                 bContainer,
                                                 NULL,
                                                 0,
                                                 &status
                                                 );
                  m_strPath.ReleaseBuffer();

   /*
                  if ( SCESTATUS_SUCCESS  == sceStatus &&
                       (BYTE)SCE_NO_VALUE != status &&
                       (DWORD)SCE_NO_VALUE != (DWORD)status ) {
   */
                  if (SCESTATUS_SUCCESS == sceStatus) {
                     if ((BYTE) SCE_NO_VALUE == status) {
                        status = SCE_STATUS_NOT_CONFIGURED;
                     }
                     if (m_pData) {
                        m_pData->SetStatus(status);
                     }

                     if ( m_pObject ) {
                        m_pObject->Status = status;
                     }
                  }
               }

            } else {

               BYTE dw;

               switch (m_radConfigPrevent) {
                  case 0:
                     // config
                     switch(m_radInheritOverwrite) {
                        case 0:
                           // inherit
                           dw = SCE_STATUS_CHECK;
                           break;
                        case 1:
                           // overwrite
                           dw = SCE_STATUS_OVERWRITE;
                           break;
                     }
                     break;
                  case 1:
                     // prevent
                     dw = SCE_STATUS_IGNORE;
                     break;
               }

               szPath = m_strPath.GetBuffer(1);

               sceStatus = SceUpdateObjectInfo(
                                              m_pHandle,
                                              Area,
                                              szPath,
                                              wcslen(szPath),
                                              dw,
                                              TRUE, //IsContainer
                                              m_pNewSD,
                                              m_NewSeInfo,
                                              &status
                                              );

               status = SCE_STATUS_NOT_ANALYZED;
               m_strPath.ReleaseBuffer();
               //
               // This should never happen, but does because
               //         of engine bugs
               //
               if ((BYTE) SCE_NO_VALUE == status) {
                  status = SCE_STATUS_NOT_CONFIGURED;
               }

               if (SCESTATUS_SUCCESS == sceStatus) {
                  if (m_pData) {
                     m_pData->SetStatus(status);
                  }

                  if ( m_pObject ) {
                     m_pObject->Status = status;
                  }
               }

            }
            if(m_pFolder){
               //
               // Update status information.
               //
               m_pCDI->UpdateObjectStatus( m_pFolder, TRUE );
            }
         } else {

            sceStatus = SCESTATUS_OTHER_ERROR;
         }

         if ( SCESTATUS_SUCCESS == sceStatus ) {
            PEDITTEMPLATE pet=NULL;
            if (m_pSnapin) {
               pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,Area);
            } else if (m_pCDI) {
               pet = m_pCDI->GetTemplate(GT_COMPUTER_TEMPLATE,Area);
            }

            if ( pet ) {
               pet->SetDirty(Area);
            }
            if (m_pData) {
               m_pData->Update(m_pSnapin);
            }
         } else {
            CString str;
            MyFormatResMessage(sceStatus,IDS_SAVE_FAILED,NULL,str);
            AfxMessageBox(str);
            return FALSE;
         }
      }

      SceFreeMemory((PVOID)posTemplate, SCE_STRUCT_OBJECT_SECURITY);
      posTemplate = NULL;

      SceFreeMemory((PVOID)posInspect, SCE_STRUCT_OBJECT_SECURITY);
      posInspect = NULL;

      if ( m_pNewSD ) {
         LocalFree(m_pNewSD);
         m_pNewSD = NULL;
      }

      m_NewSeInfo = 0;

      m_pAnalSD=NULL;
      m_AnalInfo=0;

      m_hwndParent = NULL;
      if ( m_pSI ) {
         m_pSI->Release();
         m_pSI = NULL;
      }
      m_pfnCreateDsPage=NULL;
   }

   return CAttribute::OnApply();
}

void CAttrObject::OnCancel()
{
   SceFreeMemory((PVOID)posTemplate, SCE_STRUCT_OBJECT_SECURITY);
   posTemplate = NULL;

   SceFreeMemory((PVOID)posInspect, SCE_STRUCT_OBJECT_SECURITY);
   posInspect = NULL;

   if ( m_pNewSD ) {
      LocalFree(m_pNewSD);
      m_pNewSD = NULL;
   }
   m_NewSeInfo = 0;

   m_pAnalSD=NULL;
   m_AnalInfo=0;

   m_hwndParent = NULL;
   if ( m_pSI ) {
      m_pSI->Release();
      m_pSI = NULL;
   }
   m_pfnCreateDsPage=NULL;

   CAttribute::OnCancel();
}

void CAttrObject::OnConfig()
{
   CWnd *pRadio;

   pRadio = GetDlgItem(IDC_INHERIT);
   pRadio->EnableWindow(TRUE);
   pRadio = GetDlgItem(IDC_OVERWRITE);
   pRadio->EnableWindow(TRUE);
   SetModified(TRUE);
}

void CAttrObject::OnPrevent()
{
   CWnd *pRadio;

   pRadio = GetDlgItem(IDC_INHERIT);
   pRadio->EnableWindow(FALSE);
   pRadio = GetDlgItem(IDC_OVERWRITE);
   pRadio->EnableWindow(FALSE);
   SetModified(TRUE);
}


void CAttrObject::OnOverwrite()
{
   SetModified(TRUE);
}

void CAttrObject::OnInherit()
{
   SetModified(TRUE);
}

//------------------------------------------------------------------
// override to prevent the sheet from being destroyed when there is
// child dialogs still up and running.
//------------------------------------------------------------------
BOOL CAttrObject::OnQueryCancel()
{
    if (::IsWindow(m_hwndInspect) || ::IsWindow(m_hwndTemplate))
    {
        CString strMsg;
        strMsg.LoadString(IDS_CLOSESUBSHEET_BEFORE_APPLY);
        AfxMessageBox(strMsg);
        return FALSE;
    }
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\anumber.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ANumber.h
//
//  Contents:   Definition of CAttrNumber
//
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRNUMBER_H__76BA1B2F_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRNUMBER_H__76BA1B2F_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "ddwarn.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrNumber dialog
#define RDIF_MIN            0x0001
#define RDIF_MAX            0x0002
#define RDIF_END            0x0004
#define RDIF_MAXINFINATE    0x0008

typedef struct _tag_RANGEDESCRIPTION
{
    int iMin;
    int iMax;
    WORD uResource;
    WORD uMask;
} RANGEDESCRIPTION, *PRANGEDESCRIPTION;


DWORD
GetRangeDescription(    // Sets [pstrRet] to the string corisponding to [uType] and [i]
    UINT uType,
    int i,
    CString *pstrRet
    );

UINT
GetRangeDescription(    // Returns the string resource described by [pDesc] and [i]
    RANGEDESCRIPTION *pDesc,
    int i
    );


extern RANGEDESCRIPTION g_rdMinPassword[];
extern RANGEDESCRIPTION g_rdMaxPassword[];
extern RANGEDESCRIPTION g_rdLockoutAccount[];
extern RANGEDESCRIPTION g_rdPasswordLen[];

class CAttrNumber : public CAttribute
{
// Construction
public:
    void Initialize(CResult * pResult);
    virtual void SetInitialValue(DWORD_PTR dw);
    CAttrNumber(UINT nTemplateID);   // standard constructor
	

// Dialog Data
    //{{AFX_DATA(CAttrNumber)
    enum { IDD = IDD_ATTR_NUMBER };
    CSpinButtonCtrl m_SpinValue;
    CString m_strUnits;
    CString m_strSetting;
    CString m_strBase;
    CString m_strTemplateTitle;
    CString m_strLastInspectTitle;
    CString m_strError;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrNumber)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrNumber)
    virtual BOOL OnInitDialog();
    afx_msg void OnDeltaposSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusNew();
    virtual BOOL OnApply();
    afx_msg void OnConfigure();
    afx_msg void OnUpdateNew();
    virtual BOOL OnKillActive();
   //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
    int m_cMinutes;
    long m_nLow;
    long m_nHigh;
    DWORD_PTR m_nSave;
    int m_iNeverId;
    int m_iAccRate;
    int m_iStaticId;
    RANGEDESCRIPTION *m_pRDescription;
    CDlgDependencyWarn DDWarn;
public:
    LONG CurrentEditValue();
    void SetValueToEdit(LONG lVal);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRNUMBER_H__76BA1B2F_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\applcnfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       applcnfg.cpp
//
//  Contents:   implementation of CApplyConfiguration
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "wrapper.h"
#include "snapmgr.h"
#include "applcnfg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CApplyConfiguration dialog


CApplyConfiguration::CApplyConfiguration()
: CPerformAnalysis(0, IDD)
{
   //{{AFX_DATA_INIT(CApplyConfiguration)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}


void CApplyConfiguration::DoDataExchange(CDataExchange* pDX)
{
   CPerformAnalysis::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CApplyConfiguration)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CApplyConfiguration, CPerformAnalysis)
   //{{AFX_MSG_MAP(CApplyConfiguration)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CApplyConfiguration message handlers

//+--------------------------------------------------------------------------
//
//  Method:     DoIt
//
//  Synopsis:   Actually configures the system (called from OnOK in the parent
//               class)
//
//---------------------------------------------------------------------------
DWORD CApplyConfiguration::DoIt() {
   //
   // Store the log file we're using for next time
   //
   LPTSTR szLogFile = m_strLogFile.GetBuffer(0);
   m_pComponentData ->GetWorkingDir(GWD_CONFIGURE_LOG,&szLogFile,TRUE,TRUE);
   m_strLogFile.ReleaseBuffer();
   //
   // We don't wan't to pass a pointer to an empty string.
   //
   return ApplyTemplate(
                NULL,
                m_strDataBase.IsEmpty() ? NULL : (LPCTSTR)m_strDataBase,
                m_strLogFile.IsEmpty() ? NULL : (LPCTSTR)m_strLogFile,
                AREA_ALL
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aobject.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AObject.h
//
//  Contents:   Definition of CAttrObject
//
//----------------------------------------------------------------------------
#if !defined(AFX_AOBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
#define AFX_AOBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrObject dialog

class CAttrObject : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pData);
    void Initialize(CFolder *pScopeData,CComponentDataImpl *pCDI);
    virtual void SetInitialValue(DWORD_PTR dw) { dw; };

    CAttrObject();   // standard constructor
    virtual ~CAttrObject();

// Dialog Data
    //{{AFX_DATA(CAttrObject)
        enum { IDD = IDD_ATTR_OBJECT };
    CString m_strLastInspect;
        int             m_radConfigPrevent;
        int             m_radInheritOverwrite;
        //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrObject)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    PSCE_OBJECT_SECURITY posTemplate;
    PSCE_OBJECT_SECURITY posInspect;

    // Generated message map functions
    //{{AFX_MSG(CAttrObject)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnQueryCancel();
    afx_msg void OnTemplateSecurity();
    afx_msg void OnInspectedSecurity();
    afx_msg void OnConfigure();
    virtual BOOL OnInitDialog();
        afx_msg void OnConfig();
        afx_msg void OnPrevent();
        afx_msg void OnOverwrite();
        afx_msg void OnInherit();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    PSECURITY_DESCRIPTOR m_pAnalSD;
    SECURITY_INFORMATION m_AnalInfo;
    PFNDSCREATEISECINFO m_pfnCreateDsPage;
    LPDSSECINFO m_pSI;

    CString m_strName;
    CString m_strPath;
    HANDLE m_pHandle;
    DWORD m_dwType;
    PSCE_OBJECT_LIST m_pObject;
    CComponentDataImpl *m_pCDI;
    HWND m_hwndInspect;
    HWND m_hwndTemplate;
    BOOL m_bNotAnalyzed;

    CFolder *m_pFolder;
    void Initialize2();

    CModelessSceEditor* m_pSceInspect;
    CModelessSceEditor* m_pSceTemplate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AOBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\applcnfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       applcnfg.h
//
//  Contents:   definition of CApplyConfiguration
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_APPLCNFG_H__6D0C4D6F_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
#define AFX_APPLCNFG_H__6D0C4D6F_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "perfanal.h"

/////////////////////////////////////////////////////////////////////////////
// CApplyConfiguration dialog

class CApplyConfiguration : public CPerformAnalysis
{
// Construction
public:
   CApplyConfiguration();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CApplyConfiguration)
   enum { IDD = IDD_ANALYSIS_GENERATE };
      // NOTE: the ClassWizard will add data members here
   //}}AFX_DATA



// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CApplyConfiguration)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   virtual DWORD DoIt();

   // Generated message map functions
   //{{AFX_MSG(CApplyConfiguration)
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_APPLCNFG_H__6D0C4D6F_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\areaprog.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       areaprog.cpp
//
//  Contents:   implementation of AreaProgress
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "wrapper.h"
#include "AreaProg.h"
#include "util.h"

typedef enum {
   INDEX_PRIV =0,
   INDEX_GROUP,
   INDEX_REG,
   INDEX_FILE,
   INDEX_DS,
   INDEX_SERVICE,
   INDEX_POLICY,
} AREA_INDEX;



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// AreaProgress dialog

AreaProgress::AreaProgress(CWnd* pParent /*=NULL*/)
    : CHelpDialog(a199HelpIDs, IDD, pParent)
{
    //{{AFX_DATA_INIT(AreaProgress)
    //}}AFX_DATA_INIT

   m_isDC = IsDomainController();
   m_nLastArea = -1;

   m_bmpChecked.LoadMappedBitmap(IDB_CHECK);
   m_bmpCurrent.LoadMappedBitmap(IDB_ARROW);

}

void AreaProgress::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(AreaProgress)
    DDX_Control(pDX, IDC_PROGRESS1, m_ctlProgress);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(AreaProgress, CHelpDialog)
    //{{AFX_MSG_MAP(AreaProgress)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// AreaProgress message handlers

BOOL AreaProgress::OnInitDialog()
{
    CDialog::OnInitDialog();
    int i,nAreas;
   CString strAreas[NUM_AREAS];


   // Map AREAs to string descriptions of the area
   i = GetAreaIndex(AREA_PRIVILEGES);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_PRIVILEGE);
   }

   i = GetAreaIndex(AREA_GROUP_MEMBERSHIP);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_GROUPS);
   }

   i = GetAreaIndex(AREA_REGISTRY_SECURITY);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_REGISTRY);
   }

   i = GetAreaIndex(AREA_FILE_SECURITY);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_FILESTORE);
   }

   i = GetAreaIndex(AREA_DS_OBJECTS);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_DSOBJECT);
   }

   i = GetAreaIndex(AREA_SYSTEM_SERVICE);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_SERVICE);
   }

   i = GetAreaIndex(AREA_SECURITY_POLICY);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_POLICY);
   }

   // Initialize Control Arrays
   nAreas = NUM_AREAS;
   if (!m_isDC) {
      nAreas--;
   }
   for(i=0;i< nAreas;i++) {
      m_stLabels[i].Attach(::GetDlgItem(GetSafeHwnd(),IDC_AREA1+i));
      m_stLabels[i].SetWindowText(strAreas[i]);
      // Make the label visible
      m_stLabels[i].ShowWindow(SW_SHOW);


      m_stIcons[i].Attach(::GetDlgItem(GetSafeHwnd(),IDC_ICON1+i));
      m_stIcons[i].ShowWindow(SW_SHOW);
   }


   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


int AreaProgress::GetAreaIndex(AREA_INFORMATION Area)
{
   int dwIndex;
   switch(Area) {
   case AREA_PRIVILEGES:
      dwIndex = INDEX_PRIV;
      break;
   case AREA_GROUP_MEMBERSHIP:
      dwIndex = INDEX_GROUP;
      break;
   case AREA_REGISTRY_SECURITY:
      dwIndex = INDEX_REG;
      break;
   case AREA_FILE_SECURITY:
      dwIndex = INDEX_FILE;
      break;
   case AREA_DS_OBJECTS:
      dwIndex = INDEX_DS;
      break;
   case AREA_SYSTEM_SERVICE:
      dwIndex = INDEX_SERVICE;
      break;
   case AREA_SECURITY_POLICY:
      dwIndex = INDEX_POLICY;
      break;
   default:
      dwIndex = -1;
   }

   if (!m_isDC && (dwIndex == INDEX_DS)) {
      dwIndex = -1;
   }
   if (!m_isDC && (dwIndex > INDEX_DS)) {
      dwIndex--;
   }
   return dwIndex;
}

void AreaProgress::SetMaxTicks(DWORD dwTicks)
{
#if _MFC_VER >= 0x0600
   m_ctlProgress.SetRange32(0,dwTicks);
#else
   m_ctlProgress.SetRange(0,dwTicks);
#endif
}

void AreaProgress::SetCurTicks(DWORD dwTicks)
{
   m_ctlProgress.SetPos(dwTicks);
}

void AreaProgress::SetArea(AREA_INFORMATION Area)
{
   int i,target;

   target = GetAreaIndex(Area);
   if (target <= m_nLastArea) {
      return;
   }
   if (m_nLastArea < 0) {
      m_nLastArea = 0;
   }
   for(i=m_nLastArea;i<target;i++) {
      m_stIcons[i].SetBitmap(m_bmpChecked);
   }
   m_stIcons[target].SetBitmap(m_bmpCurrent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aret.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aret.cpp
//
//  Contents:   implementation of CAttrRet
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "ARet.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrRet dialog


CAttrRet::CAttrRet(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CAttrRet)
    m_strAttrName = _T("");
    m_strLastInspect = _T("");
    m_rabRetention = -1;
    //}}AFX_DATA_INIT
    m_StartIds = IDS_AS_NEEDED;
    m_pHelpIDs = (DWORD_PTR)a189HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrRet::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrRet)
//    DDX_Text(pDX, IDC_ATTRIBUTE_NAME, m_strAttrName);
    DDX_Text(pDX, IDC_LAST_INSPECT, m_strLastInspect);
    DDX_Radio(pDX, IDC_RETENTION, m_rabRetention);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrRet, CAttribute)
    //{{AFX_MSG_MAP(CAttrRet)
        ON_BN_CLICKED(IDC_RETENTION, OnRetention)
        ON_BN_CLICKED(IDC_RADIO2, OnRetention)
        ON_BN_CLICKED(IDC_RADIO3, OnRetention)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrRet message handlers

BOOL CAttrRet::OnInitDialog()
{

   CAttribute::OnInitDialog();
   AddUserControl(IDC_RETENTION);
   AddUserControl(IDC_RADIO2);
   AddUserControl(IDC_RADIO3);
   EnableUserControls(m_bConfigure);

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRet::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      int status = 0;

      UpdateData(TRUE);

      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_rabRetention) 
         {
         case RADIO_RETAIN_BY_DAYS:
            dw = SCE_RETAIN_BY_DAYS;
            break;
         case RADIO_RETAIN_AS_NEEDED:
            dw = SCE_RETAIN_AS_NEEDED;
            break;
         case RADIO_RETAIN_MANUALLY:
            dw = SCE_RETAIN_MANUALLY;
            break;
         }
      }


      CEditTemplate *pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw
               ) == ERROR_MORE_DATA ){
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK){
            return FALSE;
         }

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++){
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult ){
               pItem->pResult->SetBase( pItem->dwSuggested );
               status = m_pSnapin->SetAnalysisInfo(pItem->pResult->GetID(),
                                                   pItem->dwSuggested,
                                                   pItem->pResult);
               pItem->pResult->SetStatus(status); //Raid #249167, 4/21/2001
               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      m_pData->SetBase(dw);
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),dw, m_pData);
      m_pData->SetStatus(status);

      m_pData->Update(m_pSnapin, FALSE);
   }

   return CAttribute::OnApply();
}




void CAttrRet::Initialize(CResult * pData)
{
   LONG_PTR dw = 0;
   CAttribute::Initialize(pData);

   DDWarn.InitializeDependencies(m_pSnapin,pData);

   m_StartIds = IDS_AS_NEEDED;

   //
   // Display the last inspected setting in its static box
   //
   pData->GetDisplayName( NULL, m_strLastInspect, 2 );

   // Set the template setting radio button appropriately
//   m_strAttrName = pData->GetAttrPretty();
   dw = pData->GetBase();
   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) {
      m_bConfigure = FALSE;
   } else {
      m_bConfigure = TRUE;
      SetInitialValue((DWORD_PTR)dw);
   }
}

void CAttrRet::SetInitialValue(DWORD_PTR dw) {

   switch(dw) {
   case SCE_RETAIN_BY_DAYS:
      m_rabRetention = RADIO_RETAIN_BY_DAYS;
      break;
   case SCE_RETAIN_AS_NEEDED:
      m_rabRetention = RADIO_RETAIN_AS_NEEDED;
      break;
   case SCE_RETAIN_MANUALLY:
      m_rabRetention = RADIO_RETAIN_MANUALLY;
      break;
   }
}

void CAttrRet::OnRetention()
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aret.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aret.h
//
//  Contents:   definition of CAttrRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ARET_H__D4CAC357_3499_11D1_AB4D_00C04FB6C6FA__INCLUDED_)
#define AFX_ARET_H__D4CAC357_3499_11D1_AB4D_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrRet dialog
#define RADIO_RETAIN_BY_DAYS     0
#define RADIO_RETAIN_AS_NEEDED   1
#define RADIO_RETAIN_MANUALLY    2

#include "ddwarn.h"

class CAttrRet : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pData);
    virtual void SetInitialValue(DWORD_PTR dw);
    CAttrRet(UINT nTemplateID);   // standard constructor
	
// Dialog Data
    //{{AFX_DATA(CAttrRet)
	enum { IDD = IDD_ATTR_RET };
    CString m_strAttrName;
    CString m_strLastInspect;
	int		m_rabRetention;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrRet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRet)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
	afx_msg void OnRetention();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CDlgDependencyWarn DDWarn;

public:
    UINT m_StartIds;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARET_H__D4CAC357_3499_11D1_AB4D_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\areaprog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       areaprog.h
//
//  Contents:   definition of AreaProgress
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_AREAPROG_H__38CE6730_56FF_11D1_AB64_00C04FB6C6FA__INCLUDED_)
#define AFX_AREAPROG_H__38CE6730_56FF_11D1_AB64_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

#define NUM_AREAS 7
/////////////////////////////////////////////////////////////////////////////
// AreaProgress dialog

class AreaProgress : public CHelpDialog
{
// Construction
public:
   void SetArea(AREA_INFORMATION Area);
   void SetCurTicks(DWORD dwTicks);
   void SetMaxTicks(DWORD dwTicks);
   AreaProgress(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
   //{{AFX_DATA(AreaProgress)
   enum { IDD = IDD_ANALYZE_PROGRESS };
   CProgressCtrl  m_ctlProgress;
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(AreaProgress)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:
   int GetAreaIndex(AREA_INFORMATION Area);

   // Generated message map functions
   //{{AFX_MSG(AreaProgress)
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

private:
   CBitmap m_bmpChecked;
   CBitmap m_bmpCurrent;
   int m_nLastArea;
   int m_isDC;

   CStatic m_stIcons[NUM_AREAS];
   CStatic m_stLabels[NUM_AREAS];
   CString m_strAreas[NUM_AREAS];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AREAPROG_H__38CE6730_56FF_11D1_AB64_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aright.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aright.cpp
//
//  Contents:   implementation of CAttrRight
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "util.h"
#include "chklist.h"
#include "ARight.h"
#include "getuser.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrRight dialog


CAttrRight::CAttrRight()
: CAttribute(IDD), 
m_pMergeList(NULL), 
m_bDirty(false)

{
   //{{AFX_DATA_INIT(CAttrRight)
        //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a191HelpIDs;
   m_uTemplateResID = IDD;
}

CAttrRight::~CAttrRight()
{
   if ( m_pMergeList ) {
      SceFreeMemory(m_pMergeList, SCE_STRUCT_NAME_STATUS_LIST);
      m_pMergeList = NULL;
   }
}

void CAttrRight::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAttrRight)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrRight, CAttribute)
//{{AFX_MSG_MAP(CAttrRight)
ON_BN_CLICKED(IDC_ADD, OnAdd)
        //}}AFX_MSG_MAP
   ON_NOTIFY(CLN_CLICK, IDC_RIGHTS, OnClickCheckBox)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrRight message handlers

void CAttrRight::Initialize(CResult * pData)
{
   CAttribute::Initialize(pData);

   //
   // The default for Not configured is false.
   //

   PSCE_PRIVILEGE_ASSIGNMENT pInspect, pTemplate;
   PSCE_NAME_LIST pnlTemplate=NULL,pnlInspect=NULL;

   pTemplate = (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetBase();
   pInspect = (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetSetting();

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == (LONG_PTR)pTemplate || !pTemplate) {
      m_bConfigure = FALSE;
      pTemplate = NULL;
   }

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == (LONG_PTR)pInspect) {
      pInspect = NULL;
   }

   if ( pTemplate ) {
      pnlTemplate = pTemplate->AssignedTo;
   }
   if ( pInspect ) {
      pnlInspect = pInspect->AssignedTo;
   }

   m_pMergeList = MergeNameStatusList(pnlTemplate, pnlInspect);

   m_bDirty=false;
}

BOOL CAttrRight::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PSCE_NAME_STATUS_LIST pItem;
   HWND hCheckList;
   LRESULT nItem;

   pItem = m_pMergeList;
   hCheckList = ::GetDlgItem(m_hWnd,IDC_RIGHTS);
   ::SendMessage(hCheckList,CLM_RESETCONTENT, 0, 0);
   RECT rAnal;
   LONG lWidth;

   GetDlgItem(IDC_ANALYZED_SETTING_STATIC)->GetWindowRect(&rAnal);
//   lWidth = rAnal.right - rAnal.left / 2;
   lWidth = 64;

   ::SendMessage(hCheckList,CLM_SETCOLUMNWIDTH,0,lWidth);

   while (pItem) {
      // Store the name of the item in the item data so we can retrieve it later
      nItem = ::SendMessage(hCheckList,CLM_ADDITEM,(WPARAM) pItem->Name,(LPARAM) pItem->Name);
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,1),
                    ((pItem->Status & MERGED_TEMPLATE) ? CLST_CHECKED : CLST_UNCHECKED));
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,2),
                    ((pItem->Status & MERGED_INSPECT) ? CLST_CHECKDISABLED : CLST_DISABLED));
      pItem = pItem->Next;
   }

   AddUserControl( IDC_RIGHTS );
   AddUserControl( IDC_ADD );
   OnConfigure();
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRight::OnApply()
{
   if ( !m_bReadOnly && m_pMergeList ) //Raid #388710
   {
      PEDITTEMPLATE pet = NULL;
      CWnd *pCheckList = GetDlgItem(IDC_RIGHTS);
      if ( !pCheckList ) {
         return FALSE;
      }
      UpdateData(TRUE);

      int iItem;
      PSCE_NAME_STATUS_LIST pIndex;
      PSCE_NAME_LIST pTemplate=NULL;
      PSCE_NAME_LIST pInspect=NULL;
      PSCE_NAME_LIST pTemp = NULL;
      DWORD status;
      DWORD misMatch = SCE_STATUS_GOOD;

      pIndex = m_pMergeList;
      iItem = 0;
      HRESULT hr=S_OK;
      PSCE_PROFILE_INFO pspi = (PSCE_PROFILE_INFO)m_pData->GetBaseProfile();
      //
      // should not change the list for last inspection
      // only change the base
      //
      if( m_bConfigure ){
              while (pIndex) {
                     if (pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED) {

                            if ( !(pIndex->Status & MERGED_TEMPLATE) )
                                   m_bDirty = true;

                            if ( SCESTATUS_SUCCESS != SceAddToNameList(&pTemplate, pIndex->Name, lstrlen(pIndex->Name))) {
                                   hr = E_FAIL;
                                   break;
                            }
                     } else if ( pIndex->Status & MERGED_TEMPLATE ) {
                            m_bDirty = true;
                     }
                     pIndex = pIndex->Next;
                     iItem++;
              }
      }

      status = ERROR_SUCCESS;
      if ( SUCCEEDED(hr) ) {

         PSCE_PRIVILEGE_ASSIGNMENT pSetting,pBasePriv;
         LPTSTR szPrivName=NULL;

         //
         // Get privilege rights from the CResult item.
         //
         pBasePriv = (PSCE_PRIVILEGE_ASSIGNMENT) (m_pData->GetBase());
         if(pBasePriv == (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) ){
             pBasePriv = NULL;
         }
         pSetting = (PSCE_PRIVILEGE_ASSIGNMENT) (m_pData->GetSetting());
         if(pSetting == (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) ){
             pSetting = NULL;
         }


         if(!m_bConfigure){
             //
             // If not configured then
            misMatch = SCE_STATUS_NOT_CONFIGURED;
             if(pBasePriv) {
                 status = m_pSnapin->UpdateAnalysisInfo(
                                           m_pData,
                                           TRUE,
                                           &pBasePriv
                                           );
                 if(pSetting){
                    pSetting->Status = SCE_STATUS_NOT_CONFIGURED;
                 }
                 m_bDirty = TRUE;
             }
         } else {
             if ( pSetting ) {
                szPrivName = pSetting->Name;
             }

             if ( !pBasePriv ) {
                 status = m_pSnapin->UpdateAnalysisInfo(
                                           m_pData,
                                           FALSE,
                                           &pBasePriv,
                                           szPrivName
                                           );
             }
             if ( pSetting ) {
                 //
                 // Check mismatch
                 //
                 if ( !SceCompareNameList(pTemplate, pSetting->AssignedTo) ) {
                     pSetting->Status = SCE_STATUS_MISMATCH;
                 } else {
                     pSetting->Status = SCE_STATUS_GOOD;
                 }
                 misMatch = pSetting->Status;
             } else {
                 // else should NEVER occur
                 misMatch = SCE_STATUS_MISMATCH;
             }
         }


         //
         // Set mismatch status of the result item.
         //
         if(misMatch != (DWORD)m_pData->GetStatus()){
            m_pData->SetStatus(misMatch);
            m_bDirty = TRUE;
         }

         if(status != ERROR_SUCCESS){
             hr = E_FAIL;
         } else if ( pBasePriv ) {

            pTemp = pBasePriv->AssignedTo;
            pBasePriv->AssignedTo = pTemplate;
            pTemplate = NULL;
            m_bDirty = TRUE;

            SceFreeMemory(pTemp,SCE_STRUCT_NAME_LIST);
            //
            // update dirty flag
            //
            if(m_pData->GetBaseProfile()){
                m_pData->GetBaseProfile()->SetDirty( AREA_PRIVILEGES );
            }
         }
      } // failed

      SceFreeMemory(pTemplate,SCE_STRUCT_NAME_LIST);

      if ( FAILED(hr) ) {
          CString str;
          str.LoadString(IDS_SAVE_FAILED);
          m_bDirty = FALSE;
          AfxMessageBox(str);
      }
      if (m_bDirty) {
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}

void CAttrRight::OnCancel()
{
   if ( m_pMergeList )
      SceFreeMemory(m_pMergeList,SCE_STRUCT_NAME_STATUS_LIST);
   m_pMergeList = NULL;

   //
   // Should not call base class
   //
   //CAttribute::OnCancel();
   DestroyWindow();
}

void CAttrRight::OnAdd()
{
   CGetUser gu;
   HRESULT hr=S_OK;

   if (gu.Create(GetSafeHwnd(),SCE_SHOW_SCOPE_ALL|SCE_SHOW_DIFF_MODE_OFF_DC|
                                SCE_SHOW_USERS | SCE_SHOW_LOCALGROUPS | SCE_SHOW_GLOBAL |
                                SCE_SHOW_WELLKNOWN | SCE_SHOW_BUILTIN)) {
      CWnd *pCheckList;
      PSCE_NAME_STATUS_LIST pList,pLast=NULL;
      LRESULT iItem;
      bool bFound;

      pCheckList = GetDlgItem(IDC_RIGHTS);

      PSCE_NAME_LIST pName = gu.GetUsers();
      while (pName) {
         if ( pName->Name ) {
            pList = m_pMergeList;
            pLast = NULL;
            iItem = 0;

            bFound = false;
            while (pList) {
               // If so, then make sure its "Template" box is checked
               if (lstrcmp(pList->Name,pName->Name) == 0) {
                  if (!(pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED)) {
                     m_bDirty = true;
                     pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                  }
                  bFound = true;
                  break;
               }
               pLast = pList;
               pList = pList->Next;
               iItem++;
            }

            // Otherwise add it both to m_pMerged and to the CheckList
            if (!bFound) {

               PSCE_NAME_STATUS_LIST pNewNode;

               pNewNode = (PSCE_NAME_STATUS_LIST)LocalAlloc(0,sizeof(SCE_NAME_STATUS_LIST));
               if ( pNewNode ) {

                  pNewNode->Name = (LPTSTR)LocalAlloc(0, (lstrlen(pName->Name)+1)*sizeof(TCHAR));
                  if ( pNewNode->Name ) {
                     lstrcpy(pNewNode->Name, pName->Name);
                     pNewNode->Next = NULL;
                     pNewNode->Status = MERGED_TEMPLATE;
                  } else {
                     LocalFree(pNewNode);
                     pNewNode = NULL;
                  }
               }
               if ( pNewNode ) {
                  if ( pLast ) {
                     pLast->Next = pNewNode;
                  } else {
                     m_pMergeList = pNewNode;
                  }
                  pLast = pNewNode;

                  iItem = pCheckList->SendMessage(CLM_ADDITEM,(WPARAM)pLast->Name,(LPARAM)pLast->Name);
                  pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                  pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,2),CLST_DISABLED);
                  m_bDirty = true;


               } else {
                  hr = E_OUTOFMEMORY;
                  ASSERT(FALSE);
                  break;
               }
            }
         }
         pName = pName->Next;
      }
   }

   if (m_bDirty) {
      SetModified(TRUE);
   }

   if ( FAILED(hr) ) {
       CString str;
       str.LoadString(IDS_CANT_ADD_USER);
       AfxMessageBox(str);
   }
}


void CAttrRight::OnClickCheckBox(NMHDR *pNM, LRESULT *pResult) //Raid #396108, 5/17/2001
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aright.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aright.h
//
//  Contents:   definition of CAttrRight
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ARIGHT_H__B4557B13_44C9_11D1_AB52_00C04FB6C6FA__INCLUDED_)
#define AFX_ARIGHT_H__B4557B13_44C9_11D1_AB52_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrRight dialog

class CAttrRight : public CAttribute
{
// Construction
public:
    virtual void Initialize(CResult *pData);
    virtual void SetInitialValue(DWORD_PTR dw) { dw; };
    CAttrRight();   // standard constructor
    virtual ~CAttrRight();

// Dialog Data
    //{{AFX_DATA(CAttrRight)
	enum { IDD = IDD_ATTR_RIGHT };
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrRight)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    bool m_bDirty;

    // Generated message map functions
    //{{AFX_MSG(CAttrRight)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    virtual void OnCancel();
    afx_msg void OnAdd();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
    afx_msg void OnClickCheckBox(NMHDR *pNM, LRESULT *pResult);
    PSCE_NAME_STATUS_LIST m_pMergeList;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARIGHT_H__B4557B13_44C9_11D1_AB52_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aservice.cpp
//
//  Contents:   implementation of CAnalysisService
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "cservice.h"
#include "Aservice.h"
#include "util.h"
#include "servperm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BYTE
CompareServiceNode(
    PSCE_SERVICES pBaseService,
    PSCE_SERVICES pAnalService
    )
{
    if ( NULL == pBaseService ||
         NULL == pAnalService ) {
        // one or both are not configured
        return SCE_STATUS_NOT_CONFIGURED;
    }

    if ( pBaseService == pAnalService ) {
        // same address
        pAnalService->Status = SCE_STATUS_GOOD;
        return SCE_STATUS_GOOD;
    }

    if ( pBaseService->Startup != pAnalService->Startup ) {
        // startup type is different
        pAnalService->Status = SCE_STATUS_MISMATCH;
        return SCE_STATUS_MISMATCH;
    }

    if ( NULL == pBaseService->General.pSecurityDescriptor &&
         NULL == pAnalService->General.pSecurityDescriptor ) {
        // both do not have SD - everyone full control
        pAnalService->Status = SCE_STATUS_GOOD;
        return SCE_STATUS_GOOD;
    }

    if ( NULL == pBaseService->General.pSecurityDescriptor ||
         NULL == pAnalService->General.pSecurityDescriptor ) {
        // one SD is NULL
        pAnalService->Status = SCE_STATUS_MISMATCH;
        return SCE_STATUS_MISMATCH;
    }

    BOOL bIsDif=FALSE;
    SCESTATUS rc = SceCompareSecurityDescriptors(
                            AREA_SYSTEM_SERVICE,
                            pBaseService->General.pSecurityDescriptor,
                            pAnalService->General.pSecurityDescriptor,
                            pBaseService->SeInfo | pAnalService->SeInfo,
                            &bIsDif
                            );
    if ( SCESTATUS_SUCCESS == rc &&
         bIsDif == FALSE ) {
        pAnalService->Status = SCE_STATUS_GOOD;
        return SCE_STATUS_GOOD;
    }

    pAnalService->Status = SCE_STATUS_MISMATCH;
    return SCE_STATUS_MISMATCH;
}

/////////////////////////////////////////////////////////////////////////////
// CAnalysisService dialog


CAnalysisService::CAnalysisService()
: CAttribute(IDD),
    m_pNewSD(NULL),
    m_NewSeInfo(0),
    m_pAnalSD(NULL),
    m_hwndShow(NULL),
    m_hwndChange(NULL),
    m_SecInfo(DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
    m_pEditSec(NULL),
    m_pShowSec(NULL)
{
    //{{AFX_DATA_INIT(CAnalysisService)
    m_nStartupRadio = -1;
    m_CurrentStr = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a194HelpIDs;
    m_uTemplateResID = IDD;
}

CAnalysisService::~CAnalysisService()
{
    if (::IsWindow(m_hwndShow))
    {
        m_pShowSec->Destroy(m_hwndShow);
        m_hwndShow = NULL;
    }
    delete m_pShowSec;
    m_pShowSec = NULL;

    if (::IsWindow(m_hwndChange))
    {
        m_pEditSec->Destroy(m_hwndChange);
        m_hwndChange = NULL;
    }
    delete m_pEditSec;
    m_pEditSec = NULL;
}

void CAnalysisService::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAnalysisService)
    DDX_Text(pDX, IDC_CURRENT, m_CurrentStr);
    DDX_Radio(pDX, IDC_ENABLED, m_nStartupRadio);
    DDX_Control(pDX, IDC_BASESD, m_bPermission);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAnalysisService, CAttribute)
    //{{AFX_MSG_MAP(CAnalysisService)
    ON_BN_CLICKED(IDC_BASESD, OnChangeSecurity)
    ON_BN_CLICKED(IDC_CURRENTSD, OnShowSecurity)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAnalysisService message handlers
BOOL CAnalysisService::OnApply()
{
   if ( !m_bReadOnly )
   {
       // OnQueryCancel does all gestures and returns false if child windows are up
       if (!OnQueryCancel())
           return FALSE;

       DWORD dw = 0;
       int status = 0;
       PEDITTEMPLATE pet = 0;

       UpdateData(TRUE);
       PSCE_SERVICES pNode = (PSCE_SERVICES)(m_pData->GetBase());

       if (!m_bConfigure ) 
       {
           if ( NULL != pNode ) 
           {
               m_pSnapin->SetupLinkServiceNodeToBase(FALSE, m_pData->GetBase());

               if ( m_pData->GetBase() != m_pData->GetSetting() ) 
               {
                   //
                   // analysis is not using the same node, free it
                   //
                   pNode->Next = NULL;
                   SceFreeMemory(pNode, SCE_STRUCT_SERVICES);
               } 
               else 
               {
                   //
                   // add the node to analysis
                   //
                   pNode->Status = SCE_STATUS_NOT_CONFIGURED;
                   m_pSnapin->AddServiceNodeToProfile(pNode);
               }
               m_pData->SetBase(0);
           }

           m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
           if ( m_pNewSD ) 
           {
               LocalFree(m_pNewSD);
               m_pNewSD = NULL;
           }
       } 
       else 
       {
           switch(m_nStartupRadio) 
           {
           case 0:
               // Automatic
               dw = SCE_STARTUP_AUTOMATIC;
               break;

           case 1:
               // Manual
               dw = SCE_STARTUP_MANUAL;
               break;

           default:
               // DISABLED
               dw = SCE_STARTUP_DISABLED;
               break;
           }

           if ( NULL != pNode &&
                m_pData->GetBase() == m_pData->GetSetting() ) 
           {
               //
               // a matched item is changed to mismatch
               // needs to create a new node
               //
               m_pSnapin->SetupLinkServiceNodeToBase(FALSE, m_pData->GetBase());
               m_pData->SetBase(0);
               //
               // add to analysis profile
               //
               pNode->Status = SCE_STATUS_MISMATCH;
               m_pSnapin->AddServiceNodeToProfile(pNode);

               pNode = NULL;
           }

           PSCE_SERVICES pSetting = (PSCE_SERVICES)(m_pData->GetSetting());
           BYTE status = 0;

           if ( NULL == pNode ) 
           {
               //
               // a node is changed from not configured to configured
               // or from match to mismatch
               //
               pNode = CreateServiceNode(m_pData->GetUnits(),
                                           m_pData->GetAttr(),
                                           dw,
                                           m_pNewSD,
                                           m_NewSeInfo);
               if ( pNode != NULL ) 
               {
                   //
                   // add to the service list
                   //
                   m_pSnapin->SetupLinkServiceNodeToBase(TRUE, (LONG_PTR)pNode);

                   m_pData->SetBase((LONG_PTR)pNode);

                   if ( pSetting ) 
                   {
                       status = CompareServiceNode(pNode, pSetting);
                       m_pData->SetStatus(status);
                   } 
                   else 
                   {
                       //
                       // this is a new configured service
                       // should create a "dump" analysis node to indictae
                       // this service is not a "matched" item
                       //
                       pSetting = CreateServiceNode(m_pData->GetUnits(),
                                                   m_pData->GetAttr(),
                                                   0,
                                                   NULL,
                                                   0);
                       if ( pSetting ) 
                       {
                           //
                           // link it to analysis profile
                           //

                           PEDITTEMPLATE pet = 0;
                           PSCE_PROFILE_INFO pInfo=NULL;

                           pet = m_pSnapin->GetTemplate(GT_LAST_INSPECTION, AREA_SYSTEM_SERVICE);

                           if (NULL != pet )
                              pInfo = pet->pTemplate;
                           
                           if ( pInfo ) 
                           {
                              pSetting->Status = SCE_STATUS_NOT_CONFIGURED;
                              pSetting->Next = pInfo->pServices;
                              pInfo->pServices = pSetting;

                              m_pData->SetSetting( (LONG_PTR)pSetting);
                           } 
                           else 
                           {
                              //
                              // free pSetting
                              //
                              LocalFree(pSetting->DisplayName);
                              LocalFree(pSetting->ServiceName);
                              LocalFree(pSetting);
                              pSetting = NULL;
                           }
                       }

                       m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
                   }

               } 
               else 
               {
                   //
                   // no memory, error out
                   //
                   if ( m_pNewSD ) 
                   {
                       LocalFree(m_pNewSD);
                       m_pNewSD = NULL;
                   }
               }
           } 
           else 
           {
               //
               // an existing service
               //
               pNode->Startup = (BYTE)dw;
               if ( m_pNewSD != NULL ) 
               {
                   if ( pNode->General.pSecurityDescriptor != m_pNewSD &&
                        pNode->General.pSecurityDescriptor != NULL ) 
                   {
                       LocalFree(pNode->General.pSecurityDescriptor);
                   }
                   pNode->General.pSecurityDescriptor = m_pNewSD;
                   m_pNewSD = NULL;

                   pNode->SeInfo = m_NewSeInfo;
               }
               //
               // update status field in the analysis node
               //
               if ( pSetting ) 
               {
                   status = CompareServiceNode(pNode, pSetting);
                   m_pData->SetStatus(status);
               } 
               else 
               {
                   // this is a new configured service
                   m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
               }
           }
       }

       pet = m_pData->GetBaseProfile();
       pet->SetDirty(AREA_SYSTEM_SERVICE);
       m_pData->Update(m_pSnapin);

       m_NewSeInfo = 0;
       m_hwndParent = NULL;
       m_hwndShow = NULL;
       m_hwndChange = NULL;
   }

    return CAttribute::OnApply();
}

void CAnalysisService::OnCancel()
{
    if ( m_pNewSD ) 
    {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;
    m_hwndParent = NULL;
    m_pAnalSD = NULL;

    m_hwndShow = NULL;
    m_hwndChange = NULL;
    CAttribute::OnCancel();
}

BOOL CAnalysisService::OnInitDialog()
{
    CAttribute::OnInitDialog();


    if ( 0 == m_pData->GetSetting() ) {

        CButton *rb = (CButton *)GetDlgItem(IDC_CURRENTSD);
        rb->EnableWindow(FALSE);
    }


    AddUserControl(IDC_ENABLED);
    AddUserControl(IDC_DISABLED);
    AddUserControl(IDC_IGNORE);
    AddUserControl(IDC_BASESD);

    OnConfigure();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAnalysisService::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   //
   // initialize setting
   //
   m_pNewSD = NULL;
   m_NewSeInfo = 0;
   m_pAnalSD = NULL;

   //
   // Never start up with do not configure set.  If they're coming 
   // here it is probably to set a value
   //
   m_bConfigure = TRUE;

   if ( 0 != pResult->GetSetting() ) {

       PSCE_SERVICES pServSetting = (PSCE_SERVICES)(pResult->GetSetting());

       switch ( pServSetting->Startup ) {
       case SCE_STARTUP_AUTOMATIC:
           m_CurrentStr.LoadString(IDS_AUTOMATIC);
           break;
       case SCE_STARTUP_MANUAL:
           m_CurrentStr.LoadString(IDS_MANUAL);
           break;
       default: // disabled
           m_CurrentStr.LoadString(IDS_DISABLED);
           break;
       }
       m_pAnalSD = pServSetting->General.pSecurityDescriptor;
   }

   PSCE_SERVICES pService;

   pService = (PSCE_SERVICES)(pResult->GetBase());
   if ( NULL == pService ) {
       m_bConfigure = FALSE;
       pService = (PSCE_SERVICES)(pResult->GetSetting());
   }
   if ( pService != NULL ) {
       switch ( pService->Startup ) {
       case SCE_STARTUP_AUTOMATIC:
           m_nStartupRadio = 0;
           break;
       case SCE_STARTUP_MANUAL:
           m_nStartupRadio = 1;
           break;
       default: // disabled
           m_nStartupRadio = 2;
           break;
       }

       if ( pService->General.pSecurityDescriptor ) {

            MyMakeSelfRelativeSD(pService->General.pSecurityDescriptor,
                                 &m_pNewSD);
       }
       m_NewSeInfo = pService->SeInfo;
   }

}


void CAnalysisService::OnShowSecurity()
{
    if ( IsWindow(m_hwndShow) ) {
       ::BringWindowToTop(m_hwndShow);
       return;
    }

    PSCE_SERVICES pService = (PSCE_SERVICES)(m_pData->GetSetting());

    SECURITY_INFORMATION SeInfo;

    if (pService)
        m_SecInfo = pService->SeInfo;

    // prepare the modeless property page data for the thread to create
    // the property sheet.

    if (NULL == m_pShowSec)
    {
        m_pShowSec = new CModelessSceEditor(false, 
                                            ANALYSIS_SECURITY_PAGE_RO_NP, 
                                            GetSafeHwnd(), 
                                            SE_SERVICE,
                                            m_pData->GetAttr());
    }

    if (NULL != m_pShowSec)
        m_pShowSec->Create(&m_pAnalSD, &m_SecInfo, &m_hwndShow);

}

void CAnalysisService::OnConfigure()
{
   CAttribute::OnConfigure();
   if (m_bConfigure && !m_pNewSD) {
       OnChangeSecurity();
   }
   else if (!m_bConfigure && IsWindow(m_hwndChange))
   {
       m_pEditSec->Destroy(m_hwndChange);
       m_hwndChange = NULL;
   }
}

void CAnalysisService::OnChangeSecurity()
{
   if ( IsWindow(m_hwndChange) ) {
      ::BringWindowToTop(m_hwndChange);
      return;
   }

   if ( !m_pNewSD ) {
      GetDefaultServiceSecurity(&m_pNewSD,&m_NewSeInfo);
   }

   // if it comes to this point, the m_hwndChange must not be a valid Window
   // so the can ask to create a modeless dialog

   if (NULL == m_pEditSec)
   {
       m_pEditSec = new CModelessSceEditor(false, 
                                           CONFIG_SECURITY_PAGE_NO_PROTECT, 
                                           GetSafeHwnd(), 
                                           SE_SERVICE,
                                           m_pData->GetAttr());
   }

   if (NULL != m_pEditSec)
        m_pEditSec->Create(&m_pNewSD, &m_NewSeInfo, &m_hwndChange);

}

//------------------------------------------------------------------
// override to prevent the sheet from being destroyed when there is
// child dialogs still up and running.
//------------------------------------------------------------------
BOOL CAnalysisService::OnQueryCancel()
{
    if (::IsWindow(m_hwndChange) || ::IsWindow(m_hwndShow))
    {
        CString strMsg;
        strMsg.LoadString(IDS_CLOSESUBSHEET_BEFORE_APPLY);
        AfxMessageBox(strMsg);
        return FALSE;
    }
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\aservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aservice.h
//
//  Contents:   definition of CAnalysisService
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAnalysisService dialog

class CAnalysisService : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pResult);
    CAnalysisService();   // standard constructor
    virtual ~CAnalysisService();

// Dialog Data
    //{{AFX_DATA(CAnalysisService)
    enum { IDD = IDD_ANALYSIS_SERVICE };
    int     m_nStartupRadio;
    CButton m_bPermission;
    CString m_CurrentStr;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAnalysisService)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAnalysisService)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnQueryCancel();
    virtual BOOL OnInitDialog();
    afx_msg void OnConfigure();
    afx_msg void OnChangeSecurity();
    afx_msg void OnShowSecurity();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:

private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    PSECURITY_DESCRIPTOR m_pAnalSD;

    HWND m_hwndShow;
    HWND m_hwndChange;
    SECURITY_INFORMATION m_SecInfo;

    CModelessSceEditor *m_pEditSec;
    CModelessSceEditor *m_pShowSec;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\asgncnfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       asgncnfg.cpp
//
//  Contents:   implementation of CAssignConfiguration
//                              
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "asgncnfg.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAssignConfiguration

IMPLEMENT_DYNAMIC(CAssignConfiguration, CFileDialog)

CAssignConfiguration::CAssignConfiguration(BOOL bOpenFileDialog, LPCTSTR lpszDefExt, LPCTSTR lpszFileName,
      DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
      CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags , lpszFilter, pParentWnd)
{
   m_bIncremental = TRUE;
}


BEGIN_MESSAGE_MAP(CAssignConfiguration, CFileDialog)
   //{{AFX_MSG_MAP(CAssignConfiguration)
   ON_BN_CLICKED(IDC_INCREMENTAL, OnIncremental)
   //}}AFX_MSG_MAP
   ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()


void CAssignConfiguration::OnIncremental()
{
   CButton *btn = (CButton *)GetDlgItem(IDC_INCREMENTAL);
   if (!btn) {
      return;
   }
   m_bIncremental = !(btn->GetCheck());
}

BOOL CAssignConfiguration::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CAssignConfiguration::DoContextHelp (HWND hWndControl)
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetSeceditHelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) a217HelpIDs) )
    {
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\attr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       attr.cpp
//
//  Contents:   implementation of CAttribute
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "Attr.h"
#include "snapmgr.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttribute dialog
void TrimNumber(CString &str)
{
   int i = str.Find( L' ' );
   if( i > 0 ){
      str = str.Left(i);
   }
}

DWORD CAttribute::m_nDialogs = 0;

CAttribute::CAttribute(UINT nTemplateID)
: CSelfDeletingPropertyPage(nTemplateID ? nTemplateID : IDD), 
    m_pSnapin(NULL), 
    m_pData(NULL), 
    m_bConfigure(TRUE), 
    m_uTemplateResID(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CAttribute)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_nDialogs++;
    m_pHelpIDs = (DWORD_PTR)a173HelpIDs;
}

CAttribute::~CAttribute()
{
   if (m_pData) 
   {
      m_pData->Release();
   }
   m_nDialogs--;
}

void CAttribute::DoDataExchange(CDataExchange* pDX)
{
    CSelfDeletingPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttribute)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Check(pDX,IDC_CONFIGURE,m_bConfigure);
    DDX_Text(pDX,IDC_TITLE,m_strTitle);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttribute, CSelfDeletingPropertyPage)
    //{{AFX_MSG_MAP(CAttribute)
    ON_WM_LBUTTONDBLCLK()
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp) //Bug 139470, Yanggao
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttribute message handlers
BOOL CAttribute::OnInitDialog ()
{
    CSelfDeletingPropertyPage::OnInitDialog ();

    return TRUE;
}

void CAttribute::Initialize(CResult * pResult)
{
   m_pData = pResult;
   if (m_pData) {
      m_pData->AddRef();
   }
}

void CAttribute::SetSnapin(CSnapin * pSnapin)
{
   m_pSnapin = pSnapin;
   if (m_pSnapin) 
   {
      m_hwndParent = pSnapin->GetParentWindow();
   }
}

void CAttribute::OnCancel()
{
}


BOOL CAttribute::OnApply()
{
   if ( !m_bReadOnly )
   {
       UpdateData();

       //
       // If we get here we've applied our modifications for this page
       // Since it's possible that we got here via Apply we want to be
       // able to reapply if any further changes are made
       //
       SetModified(FALSE);
       CancelToClose();
   }

   return TRUE;
}

/*----------------------------------------------------------------------------
Method:     CAttribute::EnableUserControls

Synopsis:   Enables or disables this control user control array.

Arugments:  [bEnable]   - If TRUE then enable the controls otherwise, disable
                            them.
----------------------------------------------------------------------------*/
void CAttribute::EnableUserControls (BOOL bEnable)
{
    HWND hwnd = 0;

    if (QueryReadOnly()) 
    {
       bEnable = FALSE;
       hwnd = ::GetDlgItem( this->m_hWnd, IDOK );
       if (hwnd) 
       {
          ::EnableWindow(hwnd, FALSE);
       }
       hwnd = ::GetDlgItem( this->m_hWnd, IDC_CONFIGURE );
       if (hwnd) 
       {
          ::EnableWindow(hwnd, FALSE);
       }
    }

    for( int i = 0; i < m_aUserCtrlIDs.GetSize(); i++)
    {
        hwnd = ::GetDlgItem( this->m_hWnd, m_aUserCtrlIDs[i] );
        if(hwnd)
        {
            //
            // The reason that there are two calls below that apparently
            // do the same thing is that all of the controls in our dialogs
            // respond to the ::EnableWindow() call except the CheckList
            // control, which will respond to the ::SendMessage(WM_ENABLE).
            // And conversley, all the other controls will not respond to
            // the ::SendMessage(WM_ENABLE).  It shouldn't be a problem
            // to make both calls but it is definitely something to watch.
            //
            // The reason the CheckList control has a problem is that when
            // it is told to disable itself, it disables all of its child windows
            // (check boxes) but re-enables its main window within the WM_ENABLE
            // handling so that it can scroll in the disabled state.  Then when we
            // try to call ::EnableWindow on it, Windows or MFC thinks the
            // window is already enabled so it doesn't send it a WM_ENABLE
            // message.  So if we send the WM_ENABLE message directly it
            // circumvents the other processing in ::EnableWindow that results
            // in the WM_ENABLE message not being sent.
            //
            ::SendMessage(hwnd, WM_ENABLE, (WPARAM) bEnable, (LPARAM) 0);
            ::EnableWindow(hwnd, bEnable);
        }
    }
}


/*----------------------------------------------------------------------------
Method:     CAttribute::OnConfigure

Synopsis:   Enable/Disable controls based on new state of the
            "Define this attribute...." checkbox

----------------------------------------------------------------------------*/
void CAttribute::OnConfigure() 
{
   UpdateData(TRUE);

   SetModified(TRUE);

   EnableUserControls(m_bConfigure);

   if (m_bConfigure && m_pData) 
   {
      switch(m_pData->GetType()) 
      {
         case ITEM_PROF_REGVALUE:
         case ITEM_REGVALUE:
         case ITEM_LOCALPOL_REGVALUE:
            SetInitialValue(m_pData->GetRegDefault());
            break;

         default:
            SetInitialValue(m_pData->GetProfileDefault());
            break;
      }


      UpdateData(FALSE);
   }
}


/*----------------------------------------------------------------------------
Method:     CAttribute::SetConfigure

Synopsis:   Set the configure state and

Arugments:  [bConfigure] - Configure is TRUE or FALSE.

----------------------------------------------------------------------------*/
void CAttribute::SetConfigure( BOOL bConfigure )
{
   m_bConfigure = bConfigure;
   UpdateData(FALSE);
   OnConfigure();
}

void CAttribute::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    CSelfDeletingPropertyPage::OnLButtonDblClk(nFlags, point);

    //
    // If the configure check box isn't visible then don't do anything
    // This dialog can't be configured
    //
    CWnd *pConfigure = GetDlgItem(IDC_CONFIGURE);
    if (!pConfigure || !pConfigure->IsWindowVisible()) 
    {
        return;
    }


    for( int i = 0; i < m_aUserCtrlIDs.GetSize(); i++ )
    {
        CWnd *pWnd = GetDlgItem( m_aUserCtrlIDs[i] );
        if(pWnd)
        {
            CRect rect;
            pWnd->GetWindowRect(&rect);
            ScreenToClient(&rect);

            if(rect.PtInRect( point ) && !pWnd->IsWindowEnabled() )
            {
                    SetConfigure( TRUE );
                    break;
            }
        }
    }

}

BOOL CAttribute::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        if(pHelpInfo->iCtrlId != -1) //Bug 311884, Yanggao
            this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CAttribute::DoContextHelp (HWND hWndControl)
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetSeceditHelpFilename(),
            HELP_WM_HELP,
            m_pHelpIDs))
    {

    }
}

BOOL CAttribute::OnContextHelp(WPARAM wParam, LPARAM lParam) //Bug 139470, Yanggao
{
    HMENU hMenu = CreatePopupMenu();
    if( hMenu )
    {
        CString str;
        str.LoadString(IDS_WHAT_ISTHIS); 
        if( AppendMenu(hMenu, MF_STRING, IDM_WHAT_ISTHIS, str) )
        {
            int itemID = TrackPopupMenu(hMenu, 
                                TPM_LEFTALIGN|TPM_TOPALIGN|TPM_RETURNCMD|
                                TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                                LOWORD(lParam), HIWORD(lParam), 0, (HWND)wParam, NULL);
            if( IDM_WHAT_ISTHIS == itemID ) //Raid #139470, 4/11/2001
            {
                if( ((HWND)wParam) != this->m_hWnd )
                {
                    ::WinHelp((HWND)wParam,
                        GetSeceditHelpFilename(),
                        HELP_WM_HELP,
                        m_pHelpIDs);
                }
                else
                {
                    POINT pos;
                    pos.x = LOWORD(lParam);
                    pos.y = HIWORD(lParam);
                    ScreenToClient( &pos );
                    CWnd* pWnd = ChildWindowFromPoint(pos, CWP_SKIPINVISIBLE);
                    if( pWnd )
                    {
				        ::WinHelp(pWnd->m_hWnd,
                            GetSeceditHelpFilename(),
                            HELP_WM_HELP,
                            m_pHelpIDs);
                    }
                    else
                    {
                        ::WinHelp((HWND)wParam,
                            GetSeceditHelpFilename(),
                            HELP_WM_HELP,
                            m_pHelpIDs);
                    }
                }
            }
        }
    }
    return TRUE;
}

//------------------------------------------------------------
// implementation for CModelessSceEditor

//------------------------------------------------------------
//------------------------------------------------------------
CModelessSceEditor::CModelessSceEditor (bool bIsContainer,
      DWORD flag,
      HWND hParent,
      SE_OBJECT_TYPE seType,
      LPCWSTR lpszObjName) 
: m_pThread(NULL)
{
    m_MLShtData.bIsContainer = bIsContainer;
    m_MLShtData.flag = flag;
    m_MLShtData.hwndParent = hParent;
    m_MLShtData.SeType = seType,
    m_MLShtData.strObjectName = lpszObjName;
}

//------------------------------------------------------------
//------------------------------------------------------------
CModelessSceEditor::~CModelessSceEditor()
{
    delete m_pThread;
}

//------------------------------------------------------------
// will create a modeless sce editor inside its own thread m_pThread
//------------------------------------------------------------
void CModelessSceEditor::Create (PSECURITY_DESCRIPTOR* ppSeDescriptor,
   SECURITY_INFORMATION* pSeInfo,
   HWND* phwndSheet)
{
    *phwndSheet = NULL;     // prepare to fail

    if (NULL == m_pThread)
    {
        m_pThread = (CModelessDlgUIThread*)AfxBeginThread(RUNTIME_CLASS(CModelessDlgUIThread));
        if (NULL == m_pThread)
        {
            CString strMsg;
            strMsg.LoadString(IDS_FAIL_CREATE_UITHREAD);
            AfxMessageBox(strMsg);
            return;
        }
        m_pThread->WaitTillRun();   // will suspend this thread till the m_pThread start running
    }

    m_MLShtData.ppSeDescriptor = ppSeDescriptor;
    m_MLShtData.pSeInfo = pSeInfo;
    m_MLShtData.phwndSheet = phwndSheet;

    m_pThread->PostThreadMessage(SCEM_CREATE_MODELESS_SHEET, (WPARAM)(&m_MLShtData), 0);
}

//------------------------------------------------------------
//------------------------------------------------------------
void CModelessSceEditor::Destroy(HWND hwndSheet)
{
    if (::IsWindow(hwndSheet))
    {
        m_pThread->PostThreadMessage(SCEM_DESTROY_WINDOW, (WPARAM)hwndSheet, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\astring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AString.h
//
//  Contents:   definition of CAttrString
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRSTRING_H__76BA1B30_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRSTRING_H__76BA1B30_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "attr.h"
#include "snapmgr.h"
/////////////////////////////////////////////////////////////////////////////
// CAttrString dialog

class CAttrString : public CAttribute
{
// Construction
public:
   CAttrString(UINT nTemplateID);   // standard constructor

   virtual void Initialize(CResult * pResult);

// Dialog Data
    //{{AFX_DATA(CAttrString)
    enum { IDD = IDD_ATTR_STRING };
    CString m_strSetting;
    CString m_strBase;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrString)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrString)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    virtual BOOL OnKillActive();
    afx_msg void OnConfigure();
	afx_msg void OnChangeNew();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL m_bNoBlanks;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRSTRING_H__76BA1B30_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\asgncnfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       asgncnfg.h
//
//  Contents:   definition of CAssignConfiguration
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ASGNCNFG_H__6D0C4D6E_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
#define AFX_ASGNCNFG_H__6D0C4D6E_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAssignConfiguration dialog

class CAssignConfiguration : public CFileDialog
{
	DECLARE_DYNAMIC(CAssignConfiguration)

public:
	CAssignConfiguration(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

   BOOL m_bIncremental;
protected:
	//{{AFX_MSG(CAssignConfiguration)
	afx_msg void OnIncremental();
	//}}AFX_MSG
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

    void DoContextHelp (HWND hWndControl);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ASGNCNFG_H__6D0C4D6E_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\astring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       attrstring.cpp
//
//  Contents:   implementation of CAttrString
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "AString.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrString dialog


CAttrString::CAttrString(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
    m_bNoBlanks(FALSE)

{
    //{{AFX_DATA_INIT(CAttrString)
    m_strSetting = _T("");
    m_strBase = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a167HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrString::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrString)
    DDX_Text(pDX, IDC_CURRENT, m_strSetting);
    DDX_Text(pDX, IDC_NEW, m_strBase);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrString, CAttribute)
    //{{AFX_MSG_MAP(CAttrString)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_EN_CHANGE(IDC_NEW, OnChangeNew)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrString message handlers

BOOL CAttrString::OnInitDialog()
{
   CAttribute::OnInitDialog();

   AddUserControl(IDC_NEW);
   OnConfigure();

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAttrString::OnConfigure()
{
   CAttribute::OnConfigure();

   CWnd *item = 0;

   if (m_bNoBlanks) {
      item = GetDlgItem(IDOK);
      if (item) {
         if (m_bConfigure) {
            item->EnableWindow(!m_strBase.IsEmpty());
         } else  {
            item->EnableWindow(TRUE);
         }
      }
   }
}

void CAttrString::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   pResult->GetDisplayName( NULL, m_strSetting, 2 );

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == pResult->GetBase() ||
      NULL == pResult->GetBase() ){
      m_bConfigure = FALSE;
   } else {
      m_bConfigure = TRUE;
      pResult->GetDisplayName( NULL, m_strBase,    1 );
   }
   if (m_pData->GetID() == IDS_NEW_ADMIN ||
       m_pData->GetID() == IDS_NEW_GUEST) {
      m_bNoBlanks = TRUE;
   } else {
      m_bNoBlanks = FALSE;
   }

}

BOOL CAttrString::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      UpdateData(TRUE);

      BOOL bChanged=TRUE;

      m_strBase.TrimLeft();
      m_strBase.TrimRight();

      if (!m_bConfigure) 
      {
         dw = 0;
         if ( (LONG_PTR)ULongToPtr(SCE_NO_VALUE) == m_pData->GetBase() ||
              0 == m_pData->GetBase() ) 
         {
             bChanged = FALSE;
         }
      } 
      else 
      {
         dw = (LONG_PTR)(LPCTSTR)m_strBase;
         if ( m_pData->GetBase() && dw &&
              (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != m_pData->GetBase() &&
              _wcsicmp((LPTSTR)(m_pData->GetBase()), (LPTSTR)dw) == 0 ) 
         {
             bChanged = FALSE;
         }
      }

      if ( bChanged ) 
      {
          if ( m_pData->GetSetting() == m_pData->GetBase() &&
               m_pData->GetSetting() ) 
          {
              // a good item, need take the base into setting
              m_pSnapin->TransferAnalysisName(m_pData->GetID());
          }

          m_pData->SetBase(dw);

          DWORD dwStatus = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),dw, m_pData);
          m_pData->SetStatus(dwStatus);
          m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}


void CAttrString::OnChangeNew()
{
   CWnd *cwnd = 0;
   if (m_bNoBlanks) {
      UpdateData(TRUE);

      cwnd = GetDlgItem(IDOK);
      if (cwnd) {
         cwnd->EnableWindow(!m_strBase.IsEmpty());
      }
   }

   SetModified(TRUE);
}

BOOL CAttrString::OnKillActive() {
   if ( m_bNoBlanks && m_bConfigure ) //Raid #407190
   {
      UpdateData(TRUE);
      m_strBase.TrimLeft();
      m_strBase.TrimRight();
      UpdateData(FALSE);
      if (m_strBase.IsEmpty())
      {
         CString str;
         str.LoadString(IDS_EMPTY_NAME_STRING);
         AfxMessageBox(str);
         return FALSE;
      }
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\caudit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       caudit.cpp
//
//  Contents:   implementation of CConfigAudit
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CAudit.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigAudit dialog


CConfigAudit::CConfigAudit(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CConfigAudit)
    m_fFailed = FALSE;
    m_fSuccessful = FALSE;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a180HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigAudit::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigAudit)
    DDX_Check(pDX, IDC_FAILED, m_fFailed);
    DDX_Check(pDX, IDC_SUCCESSFUL, m_fSuccessful);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigAudit, CAttribute)
    //{{AFX_MSG_MAP(CConfigAudit)
        ON_BN_CLICKED(IDC_FAILED, OnFailed)
        ON_BN_CLICKED(IDC_SUCCESSFUL, OnSuccessful)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigAudit message handlers

BOOL CConfigAudit::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      UpdateData(TRUE);
      if (!m_bConfigure) 
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         if (m_fSuccessful)
            dw |= AUDIT_SUCCESS;
         
         if (m_fFailed)
            dw |= AUDIT_FAILURE;
      }
       m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());

      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}


void
CConfigAudit::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);
   LONG_PTR dw = pResult->GetBase();
   m_bConfigure = (dw != (LONG_PTR)ULongToPtr(SCE_NO_VALUE));
   if (m_bConfigure) 
   {
      SetInitialValue((DWORD_PTR)dw);
   }
}

void
CConfigAudit::SetInitialValue(DWORD_PTR dw) 
{
   m_fSuccessful = (dw & AUDIT_SUCCESS) != 0;
   m_fFailed = (dw & AUDIT_FAILURE) != 0;
}

BOOL CConfigAudit::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_SUCCESSFUL);
    AddUserControl(IDC_FAILED);
    EnableUserControls(m_bConfigure);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigAudit::OnFailed()
{
        SetModified(TRUE);
}

void CConfigAudit::OnSuccessful()
{
        SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\attrprop.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       attrprop.cpp
//
//  Contents:   implementation of code for adding property pages
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include <accctrl.h>
#include "servperm.h"
#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "UIThread.h"
#include "attr.h"
#include "aaudit.h"
#include "aenable.h"
#include "AMember.h"
#include "anumber.h"
#include "AObject.h"
#include "ARet.h"
#include "ARight.h"
#include "aservice.h"
#include "astring.h"
#include "CAudit.h"
#include "CEnable.h"
#include "CGroup.h"
#include "CName.h"
#include "CNumber.h"
#include "cobject.h"
#include "CPrivs.h"
#include "CRet.h"
#include "cservice.h"
#include "regvldlg.h"
#include "perfanal.h"
#include "applcnfg.h"
#include "wrapper.h"
#include "locdesc.h"
#include "profdesc.h"
#include "newprof.h"
#include "laudit.h"
#include "lenable.h"
#include "lret.h"
#include "lnumber.h"
#include "lstring.h"
#include "lright.h"
#include "achoice.h"
#include "cchoice.h"
#include "lchoice.h"
#include "dattrs.h"
#include "lflags.h"
#include "aflags.h"
#include "multisz.h"
#include "precpage.h"

//+--------------------------------------------------------------------------
//
//  Function:   CloneAttrDialog
//
//  Synopsis:   Create a new CAttribute object of the appropriate class for
//              the type and pData passed in
//
//  Arguments:  [type]  - The type of data the CAttribute will represent
//              [pData] - More information about the CAttribute
//              [bGP]   - True to use CDomain* instead of CConfig* dialogs
//
//
//---------------------------------------------------------------------------
CAttribute *CloneAttrDialog(CResult *pData, BOOL bGP) 
{
   switch(pData->GetType()) 
   {
      case ITEM_ANAL_SERV:
         return new CAnalysisService;

      case ITEM_B2ON:
         return new CAttrAudit;

      case ITEM_BON:
      case ITEM_BOOL:
         return new CAttrEnable (0);

      case ITEM_FILESD:
      case ITEM_REGSD:
         return new CAttrObject;

      case ITEM_DW:
         return new CAttrNumber (0);

      case ITEM_GROUP:
         // PropertySheet based
         break;

      case ITEM_PRIVS:
         return new CAttrRight;

      case ITEM_PROF_B2ON:
         return bGP ? new CDomainAudit : new CConfigAudit (0);

      case ITEM_PROF_BOOL:
         return bGP ? new CDomainEnable : new CConfigEnable (0);

      case ITEM_PROF_FILESD:
      case ITEM_PROF_REGSD:
         return bGP ? new CDomainObject : new CConfigObject (0);

      case ITEM_PROF_DW:
         return bGP ? new CDomainNumber : new CConfigNumber (0);

      case ITEM_PROF_GROUP:
         return bGP ? new CDomainGroup : new CConfigGroup (0);

      case ITEM_PROF_PRIVS:
         return bGP ? new CDomainPrivs : new CConfigPrivs (0);

      case ITEM_PROF_REGVALUE:
         switch(pData->GetID()) 
         {
            case SCE_REG_DISPLAY_NUMBER:
               return bGP ? new CDomainRegNumber : new CConfigRegNumber (0);

            case SCE_REG_DISPLAY_STRING:
               return bGP ? new CDomainRegString(0) : new CConfigRegString (0); //Raid #381309, 4/31/2001

            case SCE_REG_DISPLAY_FLAGS:
               return bGP ? new CDomainRegFlags : new CConfigRegFlags (0);

            case SCE_REG_DISPLAY_CHOICE:
               return bGP ? new CDomainChoice : new CConfigChoice (0);

            case SCE_REG_DISPLAY_MULTISZ:
                if ( bGP )
                    return new CDomainRegMultiSZ;
                else
                    return new CConfigRegMultiSZ;

            default:
               return bGP ? new CDomainRegEnable : new CConfigRegEnable (0);
         }

      case ITEM_PROF_RET:
         return bGP ? new CDomainRet : new CConfigRet (0);

      case ITEM_PROF_SERV:
         return bGP ? new CDomainService : new CConfigService (0);

      case ITEM_PROF_SZ:
         return bGP ? new CDomainName : new CConfigName (0);

      case ITEM_REGVALUE:
         switch (pData->GetID()) 
         {
            case SCE_REG_DISPLAY_NUMBER:
               return new CAttrRegNumber;

            case SCE_REG_DISPLAY_STRING:
               return new CAttrRegString (0);

            case SCE_REG_DISPLAY_CHOICE:
               return new CAttrChoice;

            case SCE_REG_DISPLAY_FLAGS:
               return new CAttrRegFlags;

            case SCE_REG_DISPLAY_MULTISZ:
               return new CAttrRegMultiSZ;

            default:
               return new CAttrRegEnable;
         }

      case ITEM_RET:
         return new CAttrRet (0);

      case ITEM_SZ:
         return new CAttrString (0);

      case ITEM_LOCALPOL_RET:
         return new CLocalPolRet;

      case ITEM_LOCALPOL_SZ:
         return new CLocalPolString;

      case ITEM_LOCALPOL_B2ON:
         return new CLocalPolAudit;

      case ITEM_LOCALPOL_BON:
      case ITEM_LOCALPOL_BOOL:
         return new CLocalPolEnable;

      case ITEM_LOCALPOL_DW:
         return new CLocalPolNumber;

      case ITEM_LOCALPOL_PRIVS:
         return new CLocalPolRight;

      case ITEM_LOCALPOL_REGVALUE:
         switch (pData->GetID()) 
         {
            case SCE_REG_DISPLAY_NUMBER:
               return new CLocalPolRegNumber;

            case SCE_REG_DISPLAY_STRING:
               return new CLocalPolRegString (0);

            case SCE_REG_DISPLAY_MULTISZ:
               return new CLocalPolRegMultiSZ;

            case SCE_REG_DISPLAY_CHOICE:
               return new CLocalPolChoice;

            case SCE_REG_DISPLAY_FLAGS:
               return new CLocalPolRegFlags;

            default:
               return new CLocalPolRegEnable;
         }
   }

   return 0;
}

BOOL IsPointerType(CResult *pData) 
{
   switch (pData->GetType()) 
   {
      case ITEM_LOCALPOL_PRIVS:
      case ITEM_LOCALPOL_SZ:
         return TRUE;

      case ITEM_REGVALUE:
         switch (pData->GetID()) 
         {
            case SCE_REG_DISPLAY_STRING:
            case SCE_REG_DISPLAY_MULTISZ:
               return TRUE;

            default:
               return FALSE;
         }
         break;

      default:
         break;
   }
   return FALSE;
}

HRESULT CSnapin::AddAttrPropPages(LPPROPERTYSHEETCALLBACK pCallback,
                          CResult *pData,
                          LONG_PTR handle) 
{
   ASSERT(pCallback);
   ASSERT(pData);
   if (!pCallback || !pData) 
   {
      return E_POINTER;
   }

   BOOL           bGP = ( (GetModeBits() & MB_SINGLE_TEMPLATE_ONLY) == MB_SINGLE_TEMPLATE_ONLY );
   BOOL           bReadOnly = ( (GetModeBits() & MB_READ_ONLY) == MB_READ_ONLY );
   RESULT_TYPES   type = pData->GetType();
   CAttribute*    pAttr = NULL;
   HRESULT        hr = S_OK;

   //
   // If the item has an entry from global policy then treat it as read only
   //
   if ((GetModeBits() & MB_LOCALSEC) == MB_LOCALSEC) 
   {
      bGP = FALSE;
      if (type == ITEM_LOCALPOL_REGVALUE) 
      {
         SCE_REGISTRY_VALUE_INFO *pRegValue = NULL;
         pRegValue = (PSCE_REGISTRY_VALUE_INFO)pData->GetSetting();
         if ( pRegValue && pRegValue->Status != SCE_STATUS_NOT_CONFIGURED ) 
         {
            bReadOnly = TRUE;
         }
      } 
	   else if (IsPointerType(pData)) 
	   {
         //
         // If there is a setting it's a pointer; if not, it is NULL
         //
         if (pData->GetSetting()) 
		   {
            bReadOnly = TRUE;
         }
      } 
	   else if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != pData->GetSetting()) 
	   {
         bReadOnly = TRUE;
      }
   }
   if (type == ITEM_GROUP) 
   {
      CAttrMember *pMemberPage = new CAttrMember;
      CAttrMember *pMemberOfPage = new CAttrMember;


      if ( pMemberPage && pMemberOfPage) 
	   {
         pMemberPage->Initialize(pData);
         pMemberPage->SetMemberType(GROUP_MEMBERS);
         pMemberPage->SetSnapin(this);
         pMemberPage->SetSibling(pMemberOfPage);
         HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pMemberPage->m_psp);
         if (hPage) 
		   {
             hr = pCallback->AddPage (hPage);
             ASSERT (SUCCEEDED (hr));
             // the pointer is already added to the sheet
             pMemberPage = NULL;
         } 
		   else 
         {
            // Oops, fail to create the property sheet page
            hr = E_FAIL;
         }

         if ( SUCCEEDED(hr) ) 
         {
            pMemberOfPage->Initialize(pData);
            pMemberOfPage->SetMemberType(GROUP_MEMBER_OF);
            pMemberOfPage->SetSnapin(this);
            pMemberOfPage->SetSibling(pMemberPage);
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pMemberOfPage->m_psp);
            if (hPage) 
			   {
                hr = pCallback->AddPage (hPage);
                ASSERT (SUCCEEDED (hr));
                // the pointer is already added to the sheet
                pMemberOfPage = NULL;
            } 
			   else 
            {
                hr = E_FAIL;
            }
         }
      } 
	   else 
	   {
          hr = E_OUTOFMEMORY;
      }

      if ( pMemberPage ) 
	   {
          delete pMemberPage;
      }

      if ( pMemberOfPage ) 
	   {
          delete pMemberOfPage;
      }
   } 
   else 
   {
      pAttr = CloneAttrDialog(pData,bGP);
      if (pAttr) 
	   {
         pAttr->SetSnapin(this);
         pAttr->Initialize(pData);
         pAttr->SetReadOnly(bReadOnly);
         pAttr->SetTitle(pData->GetAttrPretty());
         HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAttr->m_psp);
         if (hPage) 
		   {
            hr = pCallback->AddPage (hPage);
            ASSERT (SUCCEEDED (hr));
         } 
		   else 
		   {
             //
             // fail to create the property sheet
             //
             delete pAttr;
             hr = E_FAIL;
         }
      } 
	   else 
	   {
         hr = E_OUTOFMEMORY;
      }
   }

   if ( SUCCEEDED(hr) ) 
   {
      //
      // In RSOP mode we need to add a precedence page too
      //
      if ((GetModeBits() & MB_RSOP) == MB_RSOP) 
	   {
         CPrecedencePage *ppp = new CPrecedencePage;
         if (ppp) 
		   {
            ppp->SetTitle(pData->GetAttrPretty());
            ppp->Initialize(pData,GetWMIRsop());
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&ppp->m_psp);
            if (hPage) 
			   {
               hr = pCallback->AddPage (hPage);
               ASSERT (SUCCEEDED (hr));
            } 
			   else 
			   {
                //
                // if the property sheet fails to be created, should free the buffer
                //
                delete ppp;
                hr = E_FAIL;
            }
         } 
		   else 
		   {
            hr = E_OUTOFMEMORY;
         }
      }
   }

   return hr;
}


HRESULT CComponentDataImpl::AddAttrPropPages(LPPROPERTYSHEETCALLBACK pCallback,
                                     CFolder *pData,
                                     LONG_PTR handle) 
{
   HRESULT hr=E_FAIL;
   CString strName;

   ASSERT(pCallback);
   ASSERT(pData);
   if (!pCallback || !pData) 
   {
      return E_POINTER;
   }

   BOOL bReadOnly = ((GetModeBits() & MB_READ_ONLY) == MB_READ_ONLY);
   pData->GetDisplayName(strName,0);

   CAttrObject *pAttr = new CAttrObject;
   if (pAttr) 
   {
      pAttr->Initialize(pData,this);
      pAttr->SetTitle(strName);
      pAttr->SetReadOnly(bReadOnly);
      HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAttr->m_psp);
      if ( hPage ) 
      {
         hr = pCallback->AddPage (hPage);
         ASSERT (SUCCEEDED (hr));
      } 
	   else 
      {
         delete pAttr;
         hr = E_FAIL;
      }
   } 
   else 
   {
      hr = E_OUTOFMEMORY;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\attr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       Attr.h
//
//  Contents:   definition of CModelessSceEditor & CAttribute
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ATTR_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTR_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "cookie.h"
#include "SelfDeletingPropertyPage.h"

typedef struct tagModelessSheetData
{
    bool bIsContainer;
    DWORD flag;
    HWND hwndParent;
    SE_OBJECT_TYPE SeType;
    CString strObjectName;
    PSECURITY_DESCRIPTOR* ppSeDescriptor;
    SECURITY_INFORMATION* pSeInfo;
    HWND* phwndSheet;
} MLSHEET_DATA, *PMLSHEET_DATA;

// this class is created for displaying modeless security editor dialog.
// under MMC, modeless dialog won't work unless it is running inside its own
// thread. When multiple sce editors can be launched for easy comparsions,
// it is highly preferred that we launch it modeless. We must use this class
// to create such modeless sce editors. It should be able to use one class to create
// multiple modeless dialogs. However, this is not always working because of MMC
// limitations. That is why the function Reset is not implemented at this time.
//************************************************************************************
// Important: this class depends on CUIThread implementations even though it only
// has a CWinThread pointer. That is because of AfxBeginThread's return type
//************************************************************************************
// How to use this class:
// (1) Create an instance when you need to create such a modeless dialog
// (2) Call Create function to display the modeless. Usually the caller provides
//      ppSeDescriptor, pSeInfo, and phwndSheet. The caller wants to have a handle
//      to the dialog because we need to make sure that its parent is not allowed
//      to go away while the modeless is up and running.
// (3) When certain actions should force the modeless dialog to go away, call Destroy
//      function (passing the modeless dialog's handle) to destroy the dialog.
// (4) destruct the instance when no longer in use
// See examples inside aservice.cpp/.h
class CModelessDlgUIThread;
class CModelessSceEditor
{
public:
    CModelessSceEditor(bool fIsContainer, DWORD flag, HWND hParent, SE_OBJECT_TYPE seType, LPCWSTR lpszObjName);
    virtual ~CModelessSceEditor();

    void Reset(bool fIsContainer, DWORD flag, HWND hParent, SE_OBJECT_TYPE seType, LPCWSTR lpszObjName);

    void Create(PSECURITY_DESCRIPTOR* ppSeDescriptor, SECURITY_INFORMATION* pSeInfo, HWND* phwndSheet);
    void Destroy(HWND hwndSheet);

protected:

    MLSHEET_DATA m_MLShtData;

    CModelessDlgUIThread* m_pThread;
};

/////////////////////////////////////////////////////////////////////////////
// CAttribute dialog
void TrimNumber(CString &str);
class CAttribute : public CSelfDeletingPropertyPage
{
// Construction
public:
    CAttribute(UINT nTemplateID);   // standard constructor
    virtual ~CAttribute();

    virtual void EnableUserControls( BOOL bEnable );

    void AddUserControl( UINT uID )
    { 
       m_aUserCtrlIDs.Add(uID); 
    };

// Dialog Data
    //{{AFX_DATA(CAttribute)
    enum { IDD = IDD_ANALYZE_SECURITY };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    void SetReadOnly(BOOL bRO) 
    { 
       m_bReadOnly = bRO; 
    }
    BOOL QueryReadOnly() 
    { 
       return m_bReadOnly; 
    }
   

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttribute)
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
   virtual BOOL OnInitDialog ();

   virtual void Initialize(CResult * pResult);
   virtual void SetSnapin(CSnapin * pSnapin);
   virtual void SetTitle(LPCTSTR sz) 
   { 
      m_strTitle = sz; 
   };
   void SetConfigure( BOOL bConfigure );
// Implementation
protected:
    CSnapin * m_pSnapin;

    // Generated message map functions
    //{{AFX_MSG(CAttribute)
        virtual void OnCancel();
        virtual BOOL OnApply();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
   virtual afx_msg void OnConfigure();
	//}}AFX_MSG
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    void DoContextHelp (HWND hWndControl);

    virtual void SetInitialValue (DWORD_PTR dw) 
    { 
       dw; 
    };
   CResult *m_pData;
   HWND m_hwndParent;
   CUIntArray m_aUserCtrlIDs;   // User control IDS.
   BOOL m_bConfigure;
   BOOL m_bReadOnly;
   CString m_strTitle;

   // every dialog that wants to handle help, you have to assign appropriately this member
   DWORD_PTR    m_pHelpIDs;
   // every dialog muse in its constructor add this line: m_uTemplateResID = IDD
   UINT         m_uTemplateResID;

public:
   static DWORD m_nDialogs;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTR_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cchoice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CChoice.h
//
//  Contents:   definition of CConfigChoice
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CCHOICE_H__B03DDCA9_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_CCHOICE_H__B03DDCA9_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigChoice dialog

class CConfigChoice : public CAttribute
{
// Construction
public:
   virtual void Initialize(CResult * pResult);
//   virtual void SetInitialValue(DWORD_PTR dw) {};
   CConfigChoice(UINT nTemplateID);   // standard constructor

// Dialog Data
   //{{AFX_DATA(CConfigChoice)
	enum { IDD = IDD_CONFIG_REGCHOICES };
	CComboBox	m_cbChoices;
	//}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CConfigChoice)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CConfigChoice)
   virtual BOOL OnInitDialog();
   virtual BOOL OnApply();
   afx_msg void OnSelchangeChoices();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   PREGCHOICE m_pChoices;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CCHOICE_H__B03DDCA9_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\caudit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CAudit.h
//
//  Contents:   definition of CConfigAudit
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CAUDIT_H__4CF5E61F_E353_11D0_9C6D_00C04FB6C6FA__INCLUDED_)
#define AFX_CAUDIT_H__4CF5E61F_E353_11D0_9C6D_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "attr.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigAudit dialog

class CConfigAudit : public CAttribute
{
// Construction
public:
	virtual void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
	CConfigAudit(UINT nTemplateID);   // standard constructor
  
// Dialog Data
	//{{AFX_DATA(CConfigAudit)
	enum { IDD = IDD_CONFIG_AUDIT };
	BOOL	m_fFailed;
	BOOL	m_fSuccessful;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigAudit)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigAudit)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnFailed();
	afx_msg void OnSuccessful();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CAUDIT_H__4CF5E61F_E353_11D0_9C6D_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cenable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cenable.cpp
//
//  Contents:   implementation of CConfigEnable
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CEnable.h"
#include "util.h"
#include "regvldlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigEnable dialog
CConfigEnable::CConfigEnable(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CConfigEnable)
    m_nEnabledRadio = -1;
    //}}AFX_DATA_INIT
    m_fNotDefine = TRUE;
    m_pHelpIDs = (DWORD_PTR)a182HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigEnable::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigEnable)
    DDX_Radio(pDX, IDC_ENABLED, m_nEnabledRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigEnable, CAttribute)
    //{{AFX_MSG_MAP(CConfigEnable)
        ON_BN_CLICKED(IDC_DISABLED, OnDisabled)
        ON_BN_CLICKED(IDC_ENABLED, OnEnabled)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigEnable message handlers

void CConfigEnable::Initialize(CResult *pResult)
{
   CAttribute::Initialize(pResult);

   LONG_PTR dw = pResult->GetBase();
   if ( (LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw ||
        (BYTE)SCE_NO_VALUE == (BYTE)dw ) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      //
      // BUG 145561 - dw is 0 vs non-0 boolean, not 0 vs 1
      //
      SetInitialValue((DWORD_PTR)(dw != 0));
   }
}

void CConfigEnable::SetInitialValue(DWORD_PTR dw) {
   //
   // Make sure we only set the INITIAL value and
   // don't reset an already-set value.
   //
   if (-1 == m_nEnabledRadio && m_fNotDefine) //Raid #413225, 6/11/2001, Yanggao
   {
      if( (DWORD_PTR)ULongToPtr(SCE_NO_VALUE) == dw ) //Raid #403460
      {
          return;
      }
      m_nEnabledRadio = (dw ? 0 : 1);
   }
}

BOOL CConfigEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw=0;
      UpdateData(TRUE);

      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_nEnabledRadio) 
         {
         // ENABLED
         case 0:
            dw = 1;
            break;
         // DISABLED
         case 1:
            dw = 0;
            break;
         }
      }

      m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());

      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}


BOOL CConfigEnable::OnInitDialog()
{
   CAttribute::OnInitDialog();

   AddUserControl(IDC_ENABLED);
   AddUserControl(IDC_DISABLED);
   OnConfigure();
   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigEnable::OnDisabled()
{
        SetModified(TRUE);
}

void CConfigEnable::OnEnabled()
{
        SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cchoice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cchoice.cpp
//
//  Contents:   implementation of CConfigChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "CChoice.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigChoice dialog


CConfigChoice::CConfigChoice(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
   //{{AFX_DATA_INIT(CConfigChoice)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a236HelpIDs;
   m_uTemplateResID = IDD;
}


void CConfigChoice::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CConfigChoice)
   DDX_Control(pDX, IDC_CHOICES, m_cbChoices);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigChoice, CAttribute)
   //{{AFX_MSG_MAP(CConfigChoice)
   ON_CBN_SELCHANGE(IDC_CHOICES, OnSelchangeChoices)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigChoice message handlers

void CConfigChoice::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pChoices = pResult->GetRegChoices();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value) //Raid #372939, 4/20/2001; #395353, #396098, 5/16/2001 
   {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }
}

BOOL CConfigChoice::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PREGCHOICE pChoice = m_pChoices;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   int nIndex = 0;

   ASSERT(prv);
   ASSERT(pChoice);
   if (!prv || !pChoice) {
      return TRUE;
   }

   CString strOut;
   DWORD dwValue = pChoice->dwValue; //Raid #404000

   if (prv->Value)
   {
      dwValue = (DWORD)_ttoi(prv->Value);
   }

   while(pChoice) {
      m_cbChoices.InsertString(nIndex,pChoice->szName);
      if (dwValue == pChoice->dwValue) {
         m_cbChoices.SetCurSel(nIndex);
      }
      m_cbChoices.SetItemData(nIndex++,pChoice->dwValue);
      pChoice = pChoice->pNext;
   }

   AddUserControl(IDC_CHOICES);
   EnableUserControls(m_bConfigure);
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int nIndex = 0;

      UpdateData(TRUE);
      if (!m_bConfigure) 
         dw = SCE_NO_VALUE;
      else 
      {
         nIndex = m_cbChoices.GetCurSel();
         if (CB_ERR != nIndex)
            dw = (DWORD)m_cbChoices.GetItemData(nIndex);
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv != NULL);
      if ( prv ) 
      {
         PWSTR pTmp=NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), dw);
            pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( pTmp )
               wcscpy(pTmp,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               return FALSE;
            }
         }

         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = pTmp;

         m_pData->SetBase((LONG_PTR)prv);
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}

void CConfigChoice::OnSelchangeChoices()
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cenable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CEnable.h
//
//  Contents:   definition of CConfigEnable
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CENABLE_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CENABLE_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "attr.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigEnable dialog

class CConfigEnable : public CAttribute
{
// Construction
public:
	CConfigEnable(UINT nTemplateID);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfigEnable)
	enum { IDD = IDD_CONFIG_ENABLE };
	int		m_nEnabledRadio;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigEnable)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigEnable)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnDisabled();
	afx_msg void OnEnabled();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	BOOL m_fNotDefine;
	virtual void Initialize(CResult *pdata);
   virtual void SetInitialValue(DWORD_PTR dw);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CENABLE_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cflags.cpp
//
//  Contents:   implementation of CConfigRegFlags
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "chklist.h"
#include "util.h"
#include "CFlags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigRegFlags dialog


CConfigRegFlags::CConfigRegFlags(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), m_pFlags(NULL)
{
	//{{AFX_DATA_INIT(CConfigRegFlags)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR) a236HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigRegFlags::DoDataExchange(CDataExchange* pDX)
{
	CAttribute::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigRegFlags)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigRegFlags, CAttribute)
	//{{AFX_MSG_MAP(CConfigRegFlags)
	//}}AFX_MSG_MAP
    ON_NOTIFY(CLN_CLICK, IDC_CHECKBOX, OnClickCheckBox)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigRegFlags message handlers
void CConfigRegFlags::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pFlags = pResult->GetRegFlags();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }
}

BOOL CConfigRegFlags::OnInitDialog()
{
   CAttribute::OnInitDialog();
   CWnd *wndCL = NULL;
   DWORD fFlags = 0;
   PREGFLAGS pFlags = m_pFlags;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   if (prv && prv->Value) {
      fFlags = (DWORD)_ttoi(prv->Value);
   }
   int nIndex = 0;

   CString strOut;

   wndCL = GetDlgItem(IDC_CHECKBOX);
   if (!wndCL) {
      //
      // This should never happen
      //
      ASSERT(wndCL);
      return FALSE;
   }
   wndCL->SendMessage(CLM_RESETCONTENT,0,0);

   while(pFlags) {
      nIndex = (int) wndCL->SendMessage(CLM_ADDITEM,
                                        (WPARAM)pFlags->szName,
                                        (LPARAM)pFlags->dwValue);
      if (nIndex != -1) {
         BOOL bSet;
         bSet = ((fFlags & pFlags->dwValue) == pFlags->dwValue);
         wndCL->SendMessage(CLM_SETSTATE,
                            MAKELONG(nIndex,1),
                            bSet ? CLST_CHECKED : CLST_UNCHECKED);
      }
      pFlags = pFlags->pNext;
   }

   AddUserControl(IDC_CHECKBOX);
   EnableUserControls(m_bConfigure);
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigRegFlags::OnApply() 
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      CWnd *wndCL = NULL;
      DWORD fFlags = 0;

      UpdateData(TRUE);

      wndCL = GetDlgItem(IDC_CHECKBOX);
      ASSERT(wndCL != NULL);

      if (!m_bConfigure || !wndCL) 
         dw = SCE_NO_VALUE;
      else 
      {
         int nItems = (int) wndCL->SendMessage(CLM_GETITEMCOUNT,0,0);
         for(int i=0;i<nItems;i++) 
         {
            dw = (DWORD) wndCL->SendMessage(CLM_GETSTATE,MAKELONG(i,1)); 
            if (CLST_CHECKED == dw)
               fFlags |= (DWORD)wndCL->SendMessage(CLM_GETITEMDATA,i);
         }
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv != NULL);
      if ( prv ) 
      {
         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), fFlags);
            prv->Value = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( prv->Value )
               lstrcpy(prv->Value,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               return FALSE;
            }
         }

         m_pData->SetBase((LONG_PTR)prv);
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();	
}


void CConfigRegFlags::OnClickCheckBox(NMHDR *pNM, LRESULT *pResult) //Raid #391172, 5/11/2001
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cgroup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cgroup.cpp
//
//  Contents:   implementation of CConfigGroup
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CGroup.h"
#include "Addgrp.h"
#include "GetUser.h"
#include "wrapper.h"
#include "util.h"
#include "snapmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigGroup dialog


CConfigGroup::CConfigGroup(UINT nTemplateID)
: CAttribute (nTemplateID ? nTemplateID : IDD), 
    m_fDirty(false), 
    m_bNoMembers(FALSE), 
    m_bNoMemberOf(FALSE)

{
    //{{AFX_DATA_INIT(CConfigGroup)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a107HelpIDs;
   m_uTemplateResID = IDD;
}


void CConfigGroup::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigGroup)
    DDX_Control(pDX, IDC_MEMBERS, m_lbMembers);
    DDX_Control(pDX, IDC_MEMBEROF, m_lbMemberOf);
    DDX_Control(pDX, IDC_NO_MEMBERS, m_eNoMembers);
    DDX_Control(pDX, IDC_NO_MEMBER_OF, m_eNoMemberOf);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigGroup, CAttribute)
    //{{AFX_MSG_MAP(CConfigGroup)
    ON_BN_CLICKED(IDC_ADD_MEMBER, OnAddMember)
    ON_BN_CLICKED(IDC_ADD_MEMBEROF, OnAddMemberof)
    ON_BN_CLICKED(IDC_REMOVE_MEMBER, OnRemoveMember)
    ON_BN_CLICKED(IDC_REMOVE_MEMBEROF, OnRemoveMemberof)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigGroup message handlers

void CConfigGroup::OnAddMember()
{
   CSCEAddGroup gu(this);
   gu.m_sTitle.LoadString( IDS_ADDMEMBER );
   gu.m_sDescription.LoadString(IDS_GROUP_MEMBERS_HEADER);

   gu.m_dwFlags = SCE_SHOW_USERS | SCE_SHOW_GLOBAL | SCE_SHOW_WELLKNOWN;
   gu.SetModeBits(m_pSnapin->GetModeBits());

   PSCE_NAME_LIST pName = 0;

   CThemeContextActivator activator;
   if (gu.DoModal() == IDOK ) 
   {
      pName = gu.GetUsers();
      while(pName) 
      {
         if (LB_ERR == m_lbMembers.FindStringExact(-1,pName->Name)) 
         {
             if (LB_ERR == m_lbMemberOf.FindStringExact(-1,pName->Name)) 
             {
                if (m_bNoMembers) 
                {
                   m_bNoMembers = FALSE;
                   m_lbMembers.ShowWindow(SW_SHOW);
                   m_eNoMembers.ShowWindow(SW_HIDE);
                }
                m_lbMembers.AddString(pName->Name);
                m_fDirty = true;
             } else {
                 // already in the Members Of list, shouldn't add to members
             }
         }
         pName = pName->Next;
      }
      SetModified(TRUE);

   }
}

void CConfigGroup::OnAddMemberof()
{
   CSCEAddGroup gu;
   PSCE_NAME_LIST pName = 0;
   DWORD nFlag = 0;

    if ( IsDomainController() ) 
    {
        nFlag = SCE_SHOW_GROUPS | SCE_SHOW_ALIASES;
    } else {
        nFlag = SCE_SHOW_ALIASES;
    }

   gu.m_dwFlags = nFlag;
   gu.SetModeBits(m_pSnapin->GetModeBits());
   gu.m_sTitle.LoadString( IDS_GROUP_MEMBER_OF_HEADER );

   CThemeContextActivator activator;
   if (gu.DoModal() == IDOK ) 
   {
      pName = gu.GetUsers();
      while(pName) 
      {
         if (LB_ERR == m_lbMemberOf.FindStringExact(-1,pName->Name)) 
         {
             if (LB_ERR == m_lbMembers.FindStringExact(-1,pName->Name)) 
             {
                if (m_bNoMemberOf) 
                {
                   m_bNoMemberOf = FALSE;
                   m_lbMemberOf.ShowWindow(SW_SHOW);
                   m_eNoMemberOf.ShowWindow(SW_HIDE);
                }
                m_lbMemberOf.AddString(pName->Name);
                m_fDirty = true;
             } 
             else 
             {
                 // already find in the members list, shouldn't add it
                 // otherwise, it will be in a circle
             }
         }
         pName = pName->Next;
      }
      SetModified(TRUE);
   }
}

void CConfigGroup::OnRemoveMember()
{
   int cbItems = m_lbMembers.GetSelCount();
   if (cbItems > 0) 
   {
      int* pnItems = new int [cbItems];
      if ( pnItems ) 
      {
          m_lbMembers.GetSelItems(cbItems,pnItems);

          m_fDirty = true;
          SetModified(TRUE);

          while(cbItems--) 
          {
             m_lbMembers.DeleteString(pnItems[cbItems]);
          }

          delete[] pnItems;
      }
   }
   if (0 == m_lbMembers.GetCount()) 
   {
      m_bNoMembers = TRUE;
      m_lbMembers.ShowWindow(SW_HIDE);
      m_eNoMembers.ShowWindow(SW_SHOW);
   }
}

void CConfigGroup::OnRemoveMemberof()
{
   int cbItems = m_lbMemberOf.GetSelCount();
   if (cbItems > 0) 
   {
      int* pnItems = new int [cbItems];
      if ( pnItems ) 
      {
          m_lbMemberOf.GetSelItems(cbItems,pnItems);

          m_fDirty = true;
          SetModified(TRUE);
          while(cbItems--) 
          {
             m_lbMemberOf.DeleteString(pnItems[cbItems]);
          }

          delete[] pnItems;
      }
   }
   if (0 == m_lbMemberOf.GetCount()) 
   {
      m_bNoMemberOf = TRUE;
      m_lbMemberOf.ShowWindow(SW_HIDE);
      m_eNoMemberOf.ShowWindow(SW_SHOW);
   }

}
/*//////////////////////////////////////////////////////////////////////////////
    Method:     OnApply

    Synopsis:   Save all changes to for the group

    Arguments:  None

    Returns:    None

////////////////////////////////////////////////////////////////////////////////*/
BOOL CConfigGroup::OnApply()
{
   if ( !m_bReadOnly )
   {
      PSCE_GROUP_MEMBERSHIP pgm = 0;
      PSCE_NAME_LIST pNames = 0;
      CString strItem;
      int cItems = 0;
      int i = 0;

      if (m_fDirty) 
      {
         //
         // the group pointer is saved in the ID field
         //
         pgm = (PSCE_GROUP_MEMBERSHIP) (m_pData->GetID());

         //
         // should not free the old buffer first because
         // creation of the new buffer may fail
         //
         PSCE_NAME_LIST pTemp1=NULL, pTemp2=NULL;
         DWORD err=ERROR_SUCCESS;

         if (!m_bNoMembers) 
         {
            cItems = m_lbMembers.GetCount();
            for(i=0;i<cItems;i++) 
            {
               pNames = (PSCE_NAME_LIST) LocalAlloc(LPTR,sizeof(SCE_NAME_LIST));

               if ( pNames ) 
               {
                   m_lbMembers.GetText(i,strItem);
                   pNames->Name = (PWSTR) LocalAlloc(LPTR,(strItem.GetLength()+1)*sizeof(TCHAR));

                   if ( pNames->Name ) 
                   {
                       lstrcpy(pNames->Name,(LPCTSTR)strItem);

                       pNames->Next = pTemp1;
                       pTemp1 = pNames;
                   } 
                   else 
                   {
                       //
                       // no memory
                       //
                       LocalFree(pNames);
                       err = ERROR_NOT_ENOUGH_MEMORY;

                       break;
                   }
               } 
               else 
               {
                   err = ERROR_NOT_ENOUGH_MEMORY;
                   break;
               }
            }
         }

         if ( err == ERROR_SUCCESS ) 
         {
            if (!m_bNoMemberOf) 
            {
               cItems = m_lbMemberOf.GetCount();
               for (i=0;i<cItems;i++) 
               {
                  pNames = (PSCE_NAME_LIST) LocalAlloc(LPTR,sizeof(SCE_NAME_LIST));

                  if ( pNames ) 
                  {
                     m_lbMemberOf.GetText(i,strItem);
                     pNames->Name = (PWSTR) LocalAlloc(LPTR,(strItem.GetLength()+1)*sizeof(TCHAR));

                     if ( pNames->Name ) 
                     {
                        lstrcpy(pNames->Name,(LPCTSTR)strItem);

                        pNames->Next = pTemp2;
                        pTemp2 = pNames;
                     } 
                     else 
                     {
                        //
                        // no memory
                        //
                        LocalFree(pNames);
                        err = ERROR_NOT_ENOUGH_MEMORY;

                        break;
                     }
                  } 
                  else 
                  {
                     err = ERROR_NOT_ENOUGH_MEMORY;
                     break;
                  }
               }
            }
         }

         if ( err == ERROR_SUCCESS ) 
         {
             SceFreeMemory(pgm->pMembers,SCE_STRUCT_NAME_LIST);
             pgm->pMembers = pTemp1;

             SceFreeMemory(pgm->pMemberOf,SCE_STRUCT_NAME_LIST);
             pgm->pMemberOf = pTemp2;

             m_pData->Update(m_pSnapin);
             m_fDirty = false;

         } 
         else 
         {
             //
             // error occured, can't save data
             // free the temp buffer and return to the dialog
             //
             SceFreeMemory(pTemp1,SCE_STRUCT_NAME_LIST);
             SceFreeMemory(pTemp2,SCE_STRUCT_NAME_LIST);

             return FALSE;
         }

      }
   }

   return CAttribute::OnApply();
}


BOOL CConfigGroup::OnInitDialog()
{
   CAttribute::OnInitDialog();

   CString str;

   UpdateData(TRUE);

   str.LoadString(IDS_NO_MEMBERS);
   m_eNoMembers.SetWindowText(str);
   str.LoadString(IDS_NO_MEMBER_OF);
   m_eNoMemberOf.SetWindowText(str);

   PSCE_GROUP_MEMBERSHIP pgm = (PSCE_GROUP_MEMBERSHIP) (m_pData->GetID());
   if ( pgm ) 
   {
       SCESTATUS rc;

       m_bAlias = FALSE;
       PSCE_NAME_LIST pNames = pgm->pMembers;
       if (!pNames) 
       {
          m_bNoMembers = TRUE;
          m_lbMembers.ShowWindow(SW_HIDE);
          m_eNoMembers.ShowWindow(SW_SHOW);
       } 
       else while(pNames) 
       {
          if (pNames->Name && lstrlen(pNames->Name)) 
          {
             m_lbMembers.AddString(pNames->Name);
          }
          pNames = pNames->Next;
       }
       pNames = pgm->pMemberOf;
       if (!pNames) 
       {
          m_bNoMemberOf = TRUE;
          m_lbMemberOf.ShowWindow(SW_HIDE);
          m_eNoMemberOf.ShowWindow(SW_SHOW);
       } 
       else while(pNames) 
       {
          if (pNames->Name && lstrlen(pNames->Name)) 
          {
             m_lbMemberOf.AddString(pNames->Name);
          }
          pNames = pNames->Next;
       }

       // alias can't be members of any other groups, so disable memberof buttons

       CWnd *cwnd = GetDlgItem(IDC_ADD_MEMBEROF);
       if ( cwnd )
           cwnd->EnableWindow(!m_bAlias);

       cwnd = GetDlgItem(IDC_REMOVE_MEMBEROF);
       if ( cwnd )
           cwnd->EnableWindow(!m_bAlias);
   }

  // m_btnTitle.SetWindowText(m_pData->GetAttrPretty());
   if ( m_bReadOnly )
   {
      GetDlgItem (IDC_ADD_MEMBER)->EnableWindow (FALSE);
      GetDlgItem (IDC_REMOVE_MEMBER)->EnableWindow (FALSE);
      GetDlgItem (IDC_ADD_MEMBEROF)->EnableWindow (FALSE);
      GetDlgItem (IDC_REMOVE_MEMBEROF)->EnableWindow (FALSE);
   }


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cgroup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CGroup.h
//
//  Contents:   definition of CConfigGroup
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CGROUP_H__8606032F_F7C3_11D0_9C6F_00C04FB6C6FA__INCLUDED_)
#define AFX_CGROUP_H__8606032F_F7C3_11D0_9C6F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "attr.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigGroup dialog

class CConfigGroup : public CAttribute
{
// Construction
public:
    CConfigGroup(UINT nTemplateID);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConfigGroup)
    enum { IDD = IDD_CONFIG_MEMBERSHIP };
    CButton m_btTitleMembers;
    CButton m_btTitleMemberOf;
    CListBox    m_lbMembers;
    CListBox    m_lbMemberOf;
    CEdit   m_eNoMembers;
    CEdit   m_eNoMemberOf;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigGroup)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigGroup)
    afx_msg void OnAddMember();
    afx_msg void OnAddMemberof();
    afx_msg void OnRemoveMember();
    afx_msg void OnRemoveMemberof();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    bool m_fDirty;
    BOOL m_bAlias;
    BOOL m_bNoMembers;
    BOOL m_bNoMemberOf;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CGROUP_H__8606032F_F7C3_11D0_9C6F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CFlags.h
//
//  Contents:   definition of CConfigRegFlags
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
#define AFX_CFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigRegFlags dialog

class CConfigRegFlags : public CAttribute
{
// Construction
public:
	CConfigRegFlags(UINT nTemplateID);   // standard constructor

   virtual void Initialize(CResult * pResult);

// Dialog Data
	//{{AFX_DATA(CConfigRegFlags)
	enum { IDD = IDD_CONFIG_REGFLAGS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigRegFlags)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	afx_msg void OnClickCheckBox(NMHDR *pNM, LRESULT *pResult);

	// Generated message map functions
	//{{AFX_MSG(CConfigRegFlags)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   PREGFLAGS m_pFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cname.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cname.cpp
//
//  Contents:   implementation of CConfigName
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CName.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PCWSTR g_pcszNEWLINE = L"\x00d\x00a";

/////////////////////////////////////////////////////////////////////////////
// CConfigName dialog


CConfigName::CConfigName(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
    m_bNoBlanks(FALSE)

{
    //{{AFX_DATA_INIT(CConfigName)
    m_strName = _T("");
    m_bConfigure = TRUE;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a183HelpIDs;
    m_uTemplateResID = IDD;
}

CConfigName::~CConfigName ()
{
}

void CConfigName::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigName)
  //  DDX_Radio(pDX, IDC_ACCEPT, m_nAcceptCurrentRadio);
      DDX_Text(pDX, IDC_NAME, m_strName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigName, CAttribute)
    //{{AFX_MSG_MAP(CConfigName)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
   ON_EN_CHANGE(IDC_NAME, OnChangeName)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigName message handlers

void CConfigName::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == pResult->GetBase() ||
       0 == pResult->GetBase() ) 
   {
      m_strName = _T("");
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      m_strName = (LPTSTR) pResult->GetBase();
   }

   if (m_pData->GetID() == IDS_NEW_ADMIN ||
       m_pData->GetID() == IDS_NEW_GUEST) 
   {
      m_bNoBlanks = TRUE;
   } 
   else
      m_bNoBlanks = FALSE;
}

BOOL CConfigName::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      CString  szDoubleNewLine (g_pcszNEWLINE);
      szDoubleNewLine += g_pcszNEWLINE;

      UpdateData(TRUE);

      m_strName.TrimLeft();
      m_strName.TrimRight();

      // 249188 SCE UI: allows adding empty lines to REG_MULTI_SZ fields
      // Replace all double newlines with single newlines.  This has the effect
      // of deleting empty lines.
      while (m_strName.Replace (szDoubleNewLine, g_pcszNEWLINE) != 0);

      UpdateData (FALSE);

      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else
         dw = (LONG_PTR)(LPCTSTR)m_strName;

      if ( SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile()) ) 
      {
          switch ( m_pData->GetID() ) 
	      {
          case IDS_NEW_ADMIN:
              dw = (LONG_PTR)(m_pData->GetBaseProfile()->pTemplate->NewAdministratorName);
              break;
          case IDS_NEW_GUEST:
              dw = (LONG_PTR)(m_pData->GetBaseProfile()->pTemplate->NewGuestName);
               break;
          default:
              dw = 0;
              break;
          }

          m_pData->SetBase(dw);
          m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}

void CConfigName::OnConfigure()
{
   CAttribute::OnConfigure();

   if(m_bConfigure && m_pData) //Raid #367756, 4/13/2001
   {
      UpdateData(TRUE);  
      if( m_strName.IsEmpty() )
      {
         switch(m_pData->GetType()) 
         {
            case ITEM_PROF_REGVALUE:
                {
                    DWORD_PTR dw = (DWORD_PTR)m_pData->GetRegDefault();
                    LPTSTR sz = SZToMultiSZ((PCWSTR)dw);

                    m_strName = sz;
                    if(sz)
                    {
                        LocalFree(sz);
                    }
                    ((CWnd*)(GetDlgItem(IDC_NAME)))->SetWindowText(m_strName);
                    break;
                }
            default:
                break;
         }
      }
   }

   CWnd *cwnd = 0;

   if (m_bNoBlanks) 
   {
      cwnd = GetDlgItem(IDOK);
      if (cwnd) 
      {
         if (m_bConfigure)
            cwnd->EnableWindow(!m_strName.IsEmpty());
         else
            cwnd->EnableWindow(TRUE);
      }
   }
}

BOOL CConfigName::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_NAME);
    OnConfigure();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigName::OnChangeName()
{
   CWnd *cwnd = 0;

   SetModified(TRUE);
   if (m_bNoBlanks) 
   {
      UpdateData(TRUE);

      cwnd = GetDlgItem(IDOK);
      if (cwnd)
         cwnd->EnableWindow(!m_strName.IsEmpty());
   }
}

BOOL CConfigName::OnKillActive() 
{
   if (m_bNoBlanks && !m_bReadOnly && m_bConfigure ) //Raid #406748
   {
      UpdateData(TRUE);
      m_strName.TrimLeft(); //Raid #406738
      m_strName.TrimRight();
      UpdateData(FALSE);
      if (m_strName.IsEmpty())
      {
         //Raid #313721, Yang Gao, 3/29/2001
         CString str;
         str.LoadString(IDS_EMPTY_NAME_STRING);
         AfxMessageBox(str);
         return FALSE;
      }
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\chklist.h ===
//-----------------------------------------------------------------------------
//
// chklist.h - Definitions and prototypes for the checklist pseudo-control
//
// Copyright 1996-2001, Microsoft Corporation
//
//
//-----------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_SCE"

//BOOL RegisterCheckListWndClass(void);


//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_CLICK           (0U-1000U)      // lparam = PNM_CHECKLIST

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
} NM_CHECKLIST, *PNM_CHECKLIST;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cname.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CName.h
//
//  Contents:   definition of CConfigName
//                              
//----------------------------------------------------------------------------

#if !defined(AFX_CNAME_H__7F9B3B39_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CNAME_H__7F9B3B39_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "attr.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigName dialog

class CConfigName : public CAttribute
{
// Construction
public:
	virtual void Initialize(CResult * pResult);
//   virtual void SetInitialValue(DWORD_PTR dw) { };

	CConfigName(UINT nTemplateID);   // standard constructor
   virtual ~CConfigName ();

// Dialog Data
	//{{AFX_DATA(CConfigName)
	enum { IDD = IDD_CONFIG_NAME };
	CString	m_strName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigName)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigName)
	virtual BOOL OnApply();
	afx_msg void OnConfigure();
	virtual BOOL OnInitDialog();
   virtual BOOL OnKillActive();
	afx_msg void OnChangeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   BOOL m_bNoBlanks;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNAME_H__7F9B3B39_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\chklist.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-2001           **/
/**********************************************************************/

/*

    CHKLIST.CPP

    This file contains the implementation of the CheckList control.

*/

#include "stdafx.h"
#include <windowsx.h>
#include "chklist.h"
#include "debug.h"
#include "util.h"

//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    32
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8

//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


typedef struct _USERDATA_STRUCT_LABEL
{
    LPARAM      lParam;
    int         nLabelHeight;
    int         itemIndex;
} USERDATA_STRUCT_LABEL, *LPUSERDATA_STRUCT_LABEL;

class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;

    int m_nDefaultVerticalSpace;
    int m_nDefaultItemHeight;
    int m_nNewItemYPos;

    HWND m_hwndCheckFocus;

    BOOL m_fInMessageEnable;

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd, LONG *pnAmountObscured = NULL);
    void SetTopIndex(HWND hWnd, LONG nIndex);
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);

public:
    HWND m_hWnd;
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};

BOOL RegisterCheckListWndClass(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    wc.hInstance        = AfxGetInstanceHandle(); //hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CCheckList::g_ucScrollLines = (UINT)-1;


CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_fInMessageEnable(FALSE), m_cWheelDelta(0)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

    m_hWnd = hWnd;
    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_CHECKMASK;

    // for wsecedit only
    if ( m_cSubItems > 3 ) {
        m_cSubItems = 3;
    }

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    m_nDefaultVerticalSpace = rc.top;
    m_nDefaultItemHeight = rc.bottom - rc.top;
    m_nNewItemYPos = rc.top;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}


LRESULT
CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

    switch (wNotify)
    {
    case EN_SETFOCUS:
        {
            // Make the focus go to one of the checkboxes
            POINT pt;
            DWORD dwPos = GetMessagePos();
            pt.x = GET_X_LPARAM(dwPos);
            pt.y = GET_Y_LPARAM(dwPos);
            MapWindowPoints(NULL, hWnd, &pt, 1);
            MsgButtonDown(hWnd, 0, pt.x, pt.y);
        }
        break;

    case BN_CLICKED:
        {
            LPUSERDATA_STRUCT_LABEL lpUserData;
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            lpUserData = (LPUSERDATA_STRUCT_LABEL)
                            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                                GWLP_USERDATA);
            nmc.dwItemData = lpUserData->lParam;

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);

        }
        break;

    case BN_SETFOCUS:
        if (GetFocus() != hwndCtrl)
        {
            // This causes another BN_SETFOCUS
            SetFocus(hwndCtrl);
        }
        else
        {
            if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
            {
                // Remember where the focus is
                m_hwndCheckFocus = hwndCtrl;

                // Make sure the row is scrolled into view
                EnsureVisible(hWnd, GET_ITEM(idCmd));
            }
            // Always draw the focus rect
            DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        }
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CCheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0);

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CCheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int xPos, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    if (nItemIndex == -1)
    {
        return;
    }
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    if( hWnd == m_hWnd ) //Raid #387542, 5/9/2001
    {
        POINT pos = {xPos,yPos};
        HWND ChildhWnd = ::ChildWindowFromPointEx(hWnd, pos, CWP_SKIPINVISIBLE|CWP_SKIPDISABLED);
        if( ChildhWnd )
        {
            LPUSERDATA_STRUCT_LABEL pUserData = (LPUSERDATA_STRUCT_LABEL)GetWindowLongPtr(ChildhWnd, GWLP_USERDATA);
            if( pUserData )
            {
                nItemIndex = pUserData->itemIndex;
            }
            else
            {
                return;
            }
        }
    }

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        int id = MAKE_CTRL_ID(nItemIndex, j);
        HWND hwndCheck = GetDlgItem(hWnd, id);
        if (IsWindowEnabled(hwndCheck))
        {
            // Don't just SetFocus here.  We sometimes call this during
            // EN_SETFOCUS, and USER doesn't like it when you mess with
            // focus during a focus change.
            //
            //SetFocus(hwndCheck);
            PostMessage(hWnd,
                        WM_COMMAND,
                        GET_WM_COMMAND_MPS(id, hwndCheck, BN_SETFOCUS));
            break;
        }
    }
}


void
CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    HWND hwndCurrentCheck;
    BOOL fCheckEnabled;

    if (!m_fInMessageEnable)
    {
        m_fInMessageEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                hwndCurrentCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(i, j));
                fCheckEnabled =   (BOOL) GetWindowLongPtr(hwndCurrentCheck, GWLP_USERDATA);

                //
                // If the user of the checklist control is disabling the control
                // altogether, or the current checkbox has been disabled singularly
                // then disable the checkbox
                //
                if (!fEnabled || !fCheckEnabled)
                {
                    EnableWindow(hwndCurrentCheck, FALSE);
                }
                else
                {
                    EnableWindow(hwndCurrentCheck, TRUE);
                }
            }
        }
        // Note that the main chklist window must remain enabled
        // for scrolling to work while "disabled".
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);

        m_fInMessageEnable = FALSE;
    }
}


void
CCheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgSize");
    TraceAssert(hWnd != NULL);

    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_nNewItemYPos - 1;
        si.nPage = nHeight;

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}

LONG CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND                    hwndPrev = 0;
    LPUSERDATA_STRUCT_LABEL lpUserData = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));
    if ( !hWnd || !pszLabel || IsBadStringPtr(pszLabel, MAX_PATH) )
        return -1;

    lpUserData = new (USERDATA_STRUCT_LABEL);
    if ( lpUserData )
    {
        SCROLLINFO  si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS;
        si.nPos = 0;
        GetScrollInfo(hWnd, SB_VERT, &si);

        // Set the initial label height extra big so the control can wrap the text,
        // then reset it after creating the control.
        RECT    rc;
        GetClientRect(hWnd, &rc);
        LONG    nLabelHeight = rc.bottom;

        AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
        HMODULE hModule = AfxGetInstanceHandle();

        // Create a new label control
        HWND hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 TEXT("edit"),
                                 pszLabel,
                                 WS_CHILD | WS_VISIBLE | WS_GROUP | ES_MULTILINE | ES_READONLY | ES_LEFT,// | WS_GROUP,
                                 m_rcItemLabel.left,
                                 m_nNewItemYPos - si.nPos,
                                 m_rcItemLabel.right - m_rcItemLabel.left,
                                 nLabelHeight,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                                 hModule,
                                 NULL);
        if ( hwndNew )
        {
            HWND hwndEdit = hwndNew;
            //
            // Reset window height after word wrap has been done.
            //
            LONG nLineCount = (LONG) SendMessage(hwndNew, EM_GETLINECOUNT, 0, (LPARAM) 0);
            nLabelHeight = nLineCount * m_nDefaultItemHeight;
            SetWindowPos(hwndNew,
                         NULL,
                         0,
                         0,
                         m_rcItemLabel.right - m_rcItemLabel.left,
                         nLabelHeight,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

            //
            // Save item data
            //
            lpUserData->lParam = lParam;
            lpUserData->nLabelHeight = nLabelHeight;
            lpUserData->itemIndex = m_cItems; //Raid #387542

            SetLastError(0);
            SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) lpUserData); //Raid #286697, 4/4/2001
            if( 0 == GetLastError() )
            {
                // Set the font
                SendMessage(hwndNew,
                            WM_SETFONT,
                            SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                            0);

                // Set Z-order position just after the last checkbox. This keeps
                // tab order correct.
                if (m_cItems > 0)
                {
                    hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
                    SetWindowPos(hwndNew,
                                 hwndPrev,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                }

                // Create new checkboxes
                DWORD dwCheckStyle = WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX;
                for (LONG j = 0; j < m_cSubItems; j++)
                {
                    hwndPrev = hwndNew;
                    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                             TEXT("BUTTON"),
                                             NULL,
                                             dwCheckStyle,
                                             m_nCheckPos[j],
                                             m_nNewItemYPos - si.nPos,
                                             m_cxCheckBox,
                                             m_rcItemLabel.bottom - m_rcItemLabel.top,
                                             hWnd,
                                             (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                             hModule,
                                             NULL);
                    if (!hwndNew)
                    {
                        while (j >= 0)
                        {
                            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                            j--;
                        }

                        DestroyWindow (hwndEdit);
                        delete lpUserData;
                        TraceLeaveValue(-1);
                    }

                    // Set Z-order position just after the last checkbox. This keeps
                    // tab order correct.
                    SetWindowPos(hwndNew,
                                 hwndPrev,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                    //
                    // Default "enabled" to TRUE
                    //
                    SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) TRUE);

                    // Only want this style on the first checkbox
                    dwCheckStyle &= ~WS_GROUP;
                }

                // We now officially have a new item
                m_cItems++;

                // calculate Y pos for next item to be inserted
                m_nNewItemYPos += nLabelHeight + m_nDefaultVerticalSpace;

                //
                // The last thing is to set the scroll range
                //
                GetClientRect(hWnd, &rc);
                si.cbSize = sizeof(si);
                si.fMask = SIF_PAGE | SIF_RANGE;
                si.nMin = 0;
                si.nMax = m_nNewItemYPos - 1;
                si.nPage = rc.bottom;

                SetScrollInfo(hWnd, SB_VERT, &si, FALSE);
            }
            else
            {
               delete lpUserData;
               DestroyWindow(hwndNew);
            }
        }
        else
            delete lpUserData;
    }

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    HWND hwndCtrl;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    if (iSubItem > 0)
    {
        hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
        if (hwndCtrl != NULL)
        {
            SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (LPARAM) !(lState & CLST_DISABLED));
            SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
            EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
        }
    }

    TraceLeaveVoid();
}


LONG
CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE));

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG                    j;
    LPUSERDATA_STRUCT_LABEL pUserData;
    LONG                    nLabelHeight;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

    m_cxCheckColumn = cxColumn;

    if (m_cSubItems > 0)
    {
        m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

        for (j = m_cSubItems - 1; j > 0; j--)
            m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

        //              (leftmost check pos) - (horz margin)
        m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            nLabelHeight = pUserData->nLabelHeight;
        }
        else
        {
            nLabelHeight = nBottom - nTop;
        }

        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nLabelHeight,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += nLabelHeight + m_nDefaultVerticalSpace;
        nBottom += nLabelHeight + m_nDefaultVerticalSpace;
    }

    TraceLeaveVoid();
}


void
CCheckList::ResetContent(HWND hWnd)
{
    LPUSERDATA_STRUCT_LABEL pUserData;
    HWND                    hwndCurrentLabel;

    for (LONG i = 0; i < m_cItems; i++)
    {
        hwndCurrentLabel = GetDlgItem(hWnd, MAKE_LABEL_ID((int)i));
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   hwndCurrentLabel,
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            delete(pUserData);
        }
        DestroyWindow(hwndCurrentLabel);

        for (LONG j = 1; j <= m_cSubItems; j++)
        {
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));
        }
    }

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG                    nCount = 0;
    RECT                    rc;
    LONG                    nTopIndex;
    LONG                    nAmountShown = 0;
    LONG                    nAmountObscured = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    if (!GetClientRect(hWnd, &rc))
    {
        return 1;
    }

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return 1;
    }

    while ((nTopIndex < m_cItems) && (nAmountShown < rc.bottom))
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                        GWLP_USERDATA);
        nAmountShown += (m_nDefaultVerticalSpace + pUserData->nLabelHeight - nAmountObscured);
        nAmountObscured = 0;    // nAmountObscured only matters for the first iteration where
                                // the real top index's amount shown is being calculated
        nCount++;
        nTopIndex++;
    }

    //
    // since that last one may be obscured see if we need to adjust nCount
    //
    if (nAmountShown > rc.bottom)
    {
        nCount--;
    }

    return max(1, nCount);
}

LONG
CCheckList::GetTopIndex(HWND hWnd, LONG *pnAmountObscured)
{
    LONG                    nIndex = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;
    SCROLLINFO              si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    //
    // initialize
    //
    if (pnAmountObscured != NULL)
    {
        *pnAmountObscured = 0;
    }

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                        GWLP_USERDATA);
        //
        // if there are no items get out
        //
        if (pUserData == NULL)
        {
            return -1;
        }

        while (si.nPos >= (m_nDefaultVerticalSpace + pUserData->nLabelHeight))
        {
            si.nPos -= (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
            nIndex++;
            pUserData = (LPUSERDATA_STRUCT_LABEL)
                        GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                            GWLP_USERDATA);
        }

        if (pnAmountObscured != NULL)
        {
            *pnAmountObscured = si.nPos;
        }
    }

    return nIndex;
}

void
CCheckList::SetTopIndex(HWND hWnd, LONG nIndex)
{
    int                     i;
    int                     nPos = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    for (i=0; i<nIndex; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        nPos += (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
    }

    m_cWheelDelta = 0;
    MsgVScroll(hWnd, SB_THUMBPOSITION, nPos);
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG                    nAmountObscured = 0;
    LONG                    nTopIndex;
    RECT                    rc;
    LPUSERDATA_STRUCT_LABEL pUserData;

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return;
    }

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else if (nItemIndex == nTopIndex)
    {
        if (nAmountObscured != 0)
        {
            SetTopIndex(hWnd, nItemIndex);
        }
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
        {
            if (!GetClientRect(hWnd, &rc))
            {
                //
                // This is just best effort
                //
                SetTopIndex(hWnd, nItemIndex - nVisible + 1);
            }
            else
            {
                //
                // Calculate what the top index should be to allow
                // nItemIndex to be fully visible
                //
                nTopIndex = nItemIndex + 1;
                do
                {
                    nTopIndex--;
                    pUserData = (LPUSERDATA_STRUCT_LABEL)
                                GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                                    GWLP_USERDATA);
                    if (pUserData != NULL)
                    {
                        rc.bottom -= (pUserData->nLabelHeight + m_nDefaultVerticalSpace);
                        if (rc.bottom < 0)
                        {
                            nTopIndex++;
                        }
                    }
                    else
                    {
                        //
                        // Should not hit this, just added to make things safe
                        //
                        rc.bottom = 0;
                        nTopIndex = 0;
                    }
                } while (rc.bottom > 0);

                SetTopIndex(hWnd, nTopIndex);
            }
        }
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    HDC hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}

LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT                 lResult = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_DESTROY:
        pThis->ResetContent(hWnd);
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND: 
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL);
        pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL);
        pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE:
        TraceAssert(pThis != NULL);
        pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            pUserData->lParam = lParam;
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            lResult = pUserData->lParam;
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            lResult = TRUE;
            break;
        }
    // Fall Through
    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cnumber.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cnumber.cpp
//
//  Contents:   implementation of CConfigNumber
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CNumber.h"
#include "util.h"

#include "ANumber.h"
#include "DDWarn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigNumber dialog
CConfigNumber::CConfigNumber(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
m_cMinutes(0), 
m_nLow(0), 
m_nHigh(999), 
m_nSave(0)

{
    //{{AFX_DATA_INIT(CConfigNumber)
    m_strUnits = _T("");
    m_strValue = _T("");
    m_strStatic = _T("");
    m_strError = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a181HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigNumber::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigNumber)
    DDX_Control(pDX, IDC_SPIN, m_SpinValue);
    DDX_Text(pDX, IDC_UNITS, m_strUnits);
    DDX_Text(pDX, IDC_VALUE, m_strValue);
    DDX_Text(pDX, IDC_HEADER,m_strStatic);
    DDX_Text(pDX, IDC_RANGEERROR,m_strError);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigNumber, CAttribute)
    //{{AFX_MSG_MAP(CConfigNumber)
//    ON_EN_KILLFOCUS(IDC_VALUE, OnKillFocus)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN, OnDeltaposSpin)
    ON_EN_UPDATE(IDC_VALUE, OnUpdateValue)
    ON_BN_CLICKED(IDC_CONFIGURE,OnConfigure)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigNumber message handlers

void CConfigNumber::OnDeltaposSpin( NMHDR* pNMHDR, LRESULT* pResult )
{
    NM_UPDOWN FAR *pnmud;
    pnmud = (NM_UPDOWN FAR *)pNMHDR;

    SetModified(TRUE);
    if ( pnmud ) {

        //
        // get current value
        //
        long lVal = CurrentEditValue();

        if (SCE_FOREVER_VALUE == lVal) {
           if (pnmud->iDelta > 0) {
              if (m_cMinutes & DW_VALUE_OFF) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           } else {
              lVal = m_nLow;
           }
        } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
           if (pnmud->iDelta < 0) {
              if (m_cMinutes & DW_VALUE_FOREVER) {
                 lVal = SCE_FOREVER_VALUE;
              } else {
                 lVal = m_nLow;
              }
           } else {
              lVal = m_nHigh;
           }
        } else {
           lVal -= (LONG)(m_iAccRate*pnmud->iDelta);

           if ( lVal > m_nHigh ) {
               // if it is overflow, go back to low
               if ( m_cMinutes & DW_VALUE_OFF ) {
                  lVal = SCE_KERBEROS_OFF_VALUE;

               } else if (m_cMinutes & DW_VALUE_FOREVER) {
                  lVal = SCE_FOREVER_VALUE;
               } else {
                  lVal = m_nLow;
               }
           } else if ( (lVal < m_nLow) &&
                ((lVal != SCE_KERBEROS_OFF_VALUE) || !(m_cMinutes & DW_VALUE_OFF)) &&
                ((lVal != SCE_FOREVER_VALUE) || !(m_cMinutes & DW_VALUE_FOREVER))) {
               // if it is underflow, go back to high
              if ( (m_cMinutes & DW_VALUE_FOREVER) && (lVal != SCE_FOREVER_VALUE)) {
                 lVal = SCE_FOREVER_VALUE;
              } else if ((m_cMinutes & DW_VALUE_OFF) && (lVal != SCE_KERBEROS_OFF_VALUE)) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           }


           if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
               // zero is not allowed
               if ( m_nLow > 0 ) {
                   lVal = m_nLow;
               } else {
                   lVal = 1;
               }
           }
        }

        SetValueToEdit(lVal);
    }

    *pResult = 0;
}

void CConfigNumber::OnKillFocus()
{
   LONG lVal = CurrentEditValue();

   SetValueToEdit(lVal);

}

void CConfigNumber::SetValueToEdit(LONG lVal)
{
    CString strNew;

    SetModified(TRUE);

    if ( m_iStaticId )
        m_strStatic.LoadString(m_iStaticId);
    else
        m_strStatic = _T("");

    if ( 0 == lVal ) {
        strNew.Format(TEXT("%d"),lVal);

        if ( m_cMinutes & DW_VALUE_NEVER &&
                  m_iNeverId > 0 ) {
            // change to never
            m_strStatic.LoadString(m_iNeverId);
        }

    } else if ( SCE_FOREVER_VALUE == lVal ) {

        strNew.LoadString(IDS_FOREVER);
        if ( m_iNeverId ) {
            m_strStatic.LoadString(m_iNeverId);
        }

    } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
       strNew.LoadString(IDS_OFF);
       if ( m_iNeverId ) {
           m_strStatic.LoadString(m_iNeverId);
       }
    } else {
        strNew.Format(TEXT("%d"),lVal);
    }
    m_nSave = lVal;

     SetDlgItemText(IDC_VALUE,strNew);
     SetDlgItemText(IDC_HEADER,m_strStatic);
}

LONG CConfigNumber::CurrentEditValue()
{
   UINT uiVal = 0;
   LONG lVal = 0;
   BOOL bTrans = FALSE;

   uiVal = GetDlgItemInt(IDC_VALUE,&bTrans,TRUE);
   lVal = uiVal;
   if ( !bTrans ) {
      CString str;
      if (m_cMinutes & DW_VALUE_FOREVER) {
         str.LoadString(IDS_FOREVER);
         if (str == m_strValue) {
            return SCE_FOREVER_VALUE;
         }
      }
      lVal = _ttol((LPCTSTR)m_strValue);
      if ( lVal == 0 ) {
         // nonnumeric
         lVal = (LONG) m_nSave;
         return lVal;
      }
   }

   if ( m_iAccRate > 1 && lVal > 0 ) {
      // for log max size, make it multiples of m_iAccRate
      int nCount = lVal % m_iAccRate;
      if ( nCount > 0 ) {
         lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
      }
   }
   if ( lVal > m_nHigh ) {
      // if it is overflow, go back to low
      if ( m_cMinutes & DW_VALUE_FOREVER ) {
         lVal = SCE_FOREVER_VALUE;
      } else if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else if ( m_cMinutes & DW_VALUE_FOREVER) {
         lVal = SCE_FOREVER_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
      // zero is not allowed
      if ( m_nLow > 0 ) {
         lVal = m_nLow;
      } else {
         lVal = 1;
      }
   }

   return lVal;
}

void CConfigNumber::OnConfigure()
{
   UpdateData(TRUE);

   CAttribute::OnConfigure();

   CWnd* cwnd = GetDlgItem(IDOK);
   if(cwnd)
   {
       if(!m_bConfigure) 
           cwnd->EnableWindow(TRUE);
       else 
           OnUpdateValue();
   }
}



BOOL CConfigNumber::OnInitDialog()
{
    CAttribute::OnInitDialog();
    AddUserControl(IDC_VALUE);
    AddUserControl(IDC_SPIN);
    AddUserControl(IDC_UNITS);

    UpdateData(TRUE);

    OnConfigure();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      BOOL bSet = FALSE;
      LONG_PTR dw = 0;
      CString strForever;
      CString strOff;

      UpdateData(TRUE);
      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else
         dw = CurrentEditValue();

      CEditTemplate *petSave = m_pData->GetBaseProfile();

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw) == ERROR_MORE_DATA )
      {
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               SetProfileInfo(
                  pItem->pResult->GetID(),
                  pItem->dwSuggested,
                  pItem->pResult->GetBaseProfile());

               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      //
      // Update this items profile.
      //
      m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());
      m_pData->Update(m_pSnapin, false);

      LPTSTR pszAlloc = NULL; //Raid #402030
      m_pData->GetBaseNoUnit(pszAlloc);
      if(pszAlloc)
      {
         SetDlgItemText(IDC_VALUE,pszAlloc);
         delete [] pszAlloc;
      }

   }

   return CAttribute::OnApply();
}

void CConfigNumber::Initialize(CResult * pResult)
{
   LONG_PTR dw=0;

   CAttribute::Initialize(pResult);
   m_strUnits = pResult->GetUnits();
   DDWarn.InitializeDependencies(m_pSnapin,pResult);

   m_cMinutes = DW_VALUE_NOZERO;
   m_nLow = 0;
   m_nHigh = 999;
   m_nSave = 0;
   m_iNeverId = 0;
   m_iAccRate = 1;
   m_iStaticId = 0;

   CEditTemplate *pTemplate = pResult->GetBaseProfile();
    switch (pResult->GetID())
        {
    // below no zero value
    case IDS_LOCK_DURATION:
        m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
        m_nHigh = 99999;
        m_iStaticId = IDS_DURATION;
        m_iNeverId = IDS_LOCKOUT_FOREVER;
        break;
    case IDS_MIN_PAS_AGE:
        m_cMinutes = DW_VALUE_NEVER;
        m_iNeverId = IDS_CHANGE_IMMEDIATELY;
        m_iStaticId = IDS_PASSWORD_CHANGE;
        m_nHigh = 998;
        break;
    case IDS_MAX_PAS_AGE:
        m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
        m_iStaticId = IDS_PASSWORD_EXPIRE;
        m_iNeverId = IDS_PASSWORD_FOREVER;
        break;
        // below zero value means differently
    case IDS_LOCK_COUNT:
        m_cMinutes = DW_VALUE_NEVER;
        m_iNeverId = IDS_NO_LOCKOUT;
        m_iStaticId = IDS_LOCKOUT_AFTER;
        break;
    case IDS_MIN_PAS_LEN:
        m_cMinutes = DW_VALUE_NEVER;
        m_nHigh = 14;
        m_iNeverId = IDS_PERMIT_BLANK;
        m_iStaticId = IDS_PASSWORD_LEN;
        break;
    case IDS_PAS_UNIQUENESS:
        m_cMinutes = DW_VALUE_NEVER;
        m_nHigh = 24;
        m_iNeverId = IDS_NO_HISTORY;
        m_iStaticId = IDS_PASSWORD_REMEMBER;
        break;
        // below there is no zero values
    case IDS_LOCK_RESET_COUNT:
        m_nLow = 1;
        m_nHigh = 99999;
        m_iStaticId = IDS_LOCK_RESET_COUNT;
        break;
    case IDS_SYS_LOG_MAX:
    case IDS_SEC_LOG_MAX:
    case IDS_APP_LOG_MAX:
        m_nLow = 64;
        m_nHigh = 4194240;
        m_iAccRate = 64;
        // no static text
        break;
    case IDS_SYS_LOG_DAYS:
    case IDS_SEC_LOG_DAYS:
    case IDS_APP_LOG_DAYS:
        m_nHigh = 365;
        m_nLow = 1;
        m_iStaticId = IDS_OVERWRITE_EVENT;
        break;
    case IDS_KERBEROS_MAX_AGE:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
       m_iStaticId = IDS_TICKET_EXPIRE;
       m_iNeverId = IDS_TICKET_FOREVER;
       m_nHigh = 99999;
       break;
    case IDS_KERBEROS_RENEWAL:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO; // | DW_VALUE_OFF;
       m_iStaticId = IDS_TICKET_RENEWAL_EXPIRE;
       m_iNeverId = IDS_TICKET_RENEWAL_FOREVER;
       m_nHigh = 99999;
       break;
    case IDS_KERBEROS_MAX_SERVICE:
       m_nLow = 10;
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
       m_iStaticId = IDS_TICKET_EXPIRE;
       m_iNeverId = IDS_TICKET_FOREVER;
       m_nHigh = 99999;
       break;
    case IDS_KERBEROS_MAX_CLOCK:
       m_cMinutes = DW_VALUE_FOREVER;
       m_iStaticId = IDS_MAX_TOLERANCE;
       m_iNeverId = IDS_NO_MAX_TOLERANCE;
       m_nHigh = 99999;
       break;
   }

   if ((m_cMinutes & DW_VALUE_NOZERO) && (0 == m_nLow)) {
      m_nLow = 1;
   }

   m_strStatic = _T("");
   dw = pResult->GetBase();

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      SetInitialValue (dw);
   }

}

void CConfigNumber::SetInitialValue(DWORD_PTR dw)
{
   //
   // Don't overwrite an already set value.
   //
   if (!m_strValue.IsEmpty()) 
   {
      return;
   }

   if (SCE_FOREVER_VALUE == dw) {
      // forever value
      m_strValue.LoadString(IDS_FOREVER);
      if ( (m_cMinutes & DW_VALUE_FOREVER) &&
           m_iNeverId > 0 ) {
         m_strStatic.LoadString(m_iNeverId);
      }
      m_nSave = SCE_FOREVER_VALUE;
   } else if (SCE_KERBEROS_OFF_VALUE == dw) {
      // off value
      m_strValue.LoadString(IDS_OFF);
      if ( (m_cMinutes & DW_VALUE_OFF) &&
           m_iNeverId > 0 ) {
         m_strStatic.LoadString(m_iNeverId);
      }
      m_nSave = SCE_KERBEROS_OFF_VALUE;
   } else {

      if (  0 == dw && (m_cMinutes & DW_VALUE_NOZERO) ) {
         // no zero vallue is allowed
         if ( m_nLow > 0 ) {
            dw = m_nLow;
         } else {
            dw = 1;
         }
      }
      m_strValue.Format(TEXT("%d"),dw);
      m_nSave = dw;

      if ( 0 == dw && (m_cMinutes & DW_VALUE_NEVER) &&
           m_iNeverId > 0 ) {
         // zero means different values
         m_strStatic.LoadString(m_iNeverId);
      } else if ( m_iStaticId > 0 ) {
         m_strStatic.LoadString(m_iStaticId);
      }
   }
}

void CConfigNumber::OnUpdateValue()
{
    DWORD dwRes = 0;
    UpdateData(TRUE);
    SetModified(TRUE);

    CString sNum;
    CEdit *pEdit = (CEdit *)GetDlgItem(IDC_VALUE);
    CWnd  *pOK  = GetDlgItem(IDOK);

    DWORD dwValue = _ttoi(m_strValue);


    //
    // Don't do anything if the string is equal to predefined strings.
    //
    sNum.LoadString(IDS_FOREVER);

    if (m_strValue.IsEmpty()) {
       if (pOK) {
          pOK->EnableWindow(FALSE);
       }
    } else if(m_strValue == sNum){
        if(pOK && !QueryReadOnly()){
            pOK->EnableWindow(TRUE);
        }
    } else {

      if((LONG)dwValue < m_nLow){
         //
         // Disable the OK button.
         //
         if( pOK ){
            pOK->EnableWindow(FALSE);
         }

         if(pEdit){
            //
            // We will only force a select if edit text length >=
            //  minimum text length
            //
            sNum.Format(TEXT("%d"), m_nLow);
            dwValue = m_nLow;
            if(sNum.GetLength() < m_strValue.GetLength()){
               pEdit->SetSel(0, -1);
            }
         }
      } else if( (LONG)dwValue > m_nHigh ) {
         if(!QueryReadOnly() && pOK){
            pOK->EnableWindow(TRUE);
         }
         if(pEdit){
            if(m_cMinutes & DW_VALUE_FOREVER){
               sNum.LoadString(IDS_FOREVER);
               dwValue = 0;
            } else {
               sNum.Format(TEXT("%d"), m_nHigh);
               dwValue = m_nHigh;
            }
            m_strValue = sNum;
            UpdateData(FALSE);
            pEdit->SetSel(0, -1);
         }
      } else if(!QueryReadOnly() && pOK){
         //
         // Enable the OK button.
         //
         if (pOK) {
            pOK->EnableWindow(TRUE);
         }
      }
   }
    //
    // Load the description for this string.
    //
   if ((dwValue <= 0) && (m_iNeverId != 0)) {
      m_strStatic.LoadString(m_iNeverId);
   } else {
      m_strStatic.LoadString(m_iStaticId);
   }
   GetDlgItem(IDC_HEADER)->SetWindowText(m_strStatic);
}

BOOL CConfigNumber::OnKillActive()
{
    UINT uiVal = 0;
    LONG lVal = 0;
    BOOL bTrans = FALSE;
    CString strRange;
    int lMin = m_nLow;

    UpdateData(TRUE);

    if (!m_bConfigure)
    {
        return TRUE;
    }

    if ((m_cMinutes & DW_VALUE_NOZERO) &&
        !(m_cMinutes & DW_VALUE_FOREVER) &&
        lMin == 0)
    {
        lMin = 1;
    }

    CString strFormat;
    strFormat.LoadString(IDS_RANGE);
    strRange.Format(strFormat,lMin,m_nHigh);

    uiVal = GetDlgItemInt(IDC_VALUE, &bTrans, TRUE);
    lVal = uiVal;
    if (!bTrans)
    {
        CString str;
        if (m_cMinutes & DW_VALUE_FOREVER)
        {
            str.LoadString(IDS_FOREVER);
            if (str == m_strValue)
            {
                return TRUE;
            }
        }
        lVal = _ttol((LPCTSTR)m_strValue);
        if (lVal == 0)
        {
            // nonnumeric
            lVal = (LONG) m_nSave;
            m_strError = strRange;
            UpdateData(FALSE);
            return FALSE;
        }
    }

    if (m_iAccRate > 1 && lVal > 0)
    {
        // for log max size, make it multiples of m_iAccRate
        int nCount = lVal % m_iAccRate;
        if ( nCount > 0 )
        {
            lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
        }
    }

    if (lVal > m_nHigh)
    {
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    if ((lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE))
    {
        // if it is underflow, go back to high
        if (m_cMinutes & DW_VALUE_OFF)
        {
            lVal = SCE_KERBEROS_OFF_VALUE;
        }
        else if (m_cMinutes & DW_VALUE_FOREVER)
        {
            lVal = SCE_FOREVER_VALUE;
        }
        else
        {
            // Leave alone and let the OnKillActive catch it
        }
    }

    if ((lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE))
    {
        // if it is underflow, go back to high
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    if (0 == lVal && (m_cMinutes & DW_VALUE_NOZERO))
    {
        // zero is not allowed
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    return CAttribute::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cnumber.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CNumber.h
//
//  Contents:   definition of CConfigNumber
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CNUMBER_H__7F9B3B37_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CNUMBER_H__7F9B3B37_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "attr.h"
#include "ddwarn.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigNumber dialog

class CConfigNumber : public CAttribute
{
// Construction
public:
    CConfigNumber(UINT nTemplateID);   // standard constructor


// Dialog Data
    //{{AFX_DATA(CConfigNumber)
    enum { IDD = IDD_CONFIG_NUMBER };
    CSpinButtonCtrl m_SpinValue;
    CString m_strUnits;
    CString m_strValue;
    CString m_strStatic;
    CString m_strError;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigNumber)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    int m_cMinutes;
    long m_nLow;
    long m_nHigh;
    DWORD_PTR m_nSave;
    int m_iNeverId;
    int m_iAccRate;
    int m_iStaticId;
    CDlgDependencyWarn DDWarn;

    // Generated message map functions
    //{{AFX_MSG(CConfigNumber)
    afx_msg void OnKillFocus();
    afx_msg void OnDeltaposSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnConfigure();
    virtual BOOL OnInitDialog();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
	afx_msg void OnUpdateValue();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    virtual void Initialize(CResult *pResult);
    virtual void SetInitialValue(DWORD_PTR dw);
    LONG CurrentEditValue();
    void SetValueToEdit(LONG lVal);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNUMBER_H__7F9B3B37_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cobject.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cobject.cpp
//
//  Contents:   implementation of CConfigObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "util.h"
#include "servperm.h"
#include "CObject.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigObject dialog


CConfigObject::CConfigObject(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
m_pfnCreateDsPage(NULL), 
m_pSI(NULL), 
m_pNewSD(NULL), 
m_NewSeInfo(0), 
m_hwndSecurity(NULL)

{

    //{{AFX_DATA_INIT(CConfigObject)
        m_radConfigPrevent = 0;
        m_radInheritOverwrite = 0;
        //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a197HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigObject::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigObject)
        DDX_Radio(pDX, IDC_CONFIG, m_radConfigPrevent);
        DDX_Radio(pDX, IDC_INHERIT, m_radInheritOverwrite);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigObject, CAttribute)
    //{{AFX_MSG_MAP(CConfigObject)
    ON_BN_CLICKED(IDC_SECURITY, OnTemplateSecurity)
        ON_BN_CLICKED(IDC_CONFIG, OnConfig)
        ON_BN_CLICKED(IDC_PREVENT, OnPrevent)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigObject message handlers

BOOL CConfigObject::OnApply()
{
   if ( !m_bReadOnly )
   {
       DWORD dw = 0;
       int status = 0;

       UpdateData(TRUE);
       PEDITTEMPLATE pTemp = m_pData->GetBaseProfile();

       switch (m_radConfigPrevent) 
       {
          case 0:
             // config
             switch(m_radInheritOverwrite) 
             {
                case 0:
                   // inherit
                   dw = SCE_STATUS_CHECK;
                   break;

                case 1:
                   // overwrite
                   dw = SCE_STATUS_OVERWRITE;
                   break;

                default:
                   break;
             }
             break;

          case 1:
             // prevent
             dw = SCE_STATUS_IGNORE;
             break;

          default:
             break;
       }

       PSCE_OBJECT_SECURITY pObjSec=(PSCE_OBJECT_SECURITY)(m_pData->GetID());

       if ( NULL == pObjSec ) 
       {
           //
           // this branch is impossible
           //
           if ( m_pNewSD != NULL ) 
           {
               LocalFree(m_pNewSD);
               m_pNewSD = NULL;
           }
       } 
       else 
       {
           //
           // an existing object
           //
           pObjSec->Status = (BYTE)dw;

           if ( m_pNewSD != NULL ) 
           {
               if ( pObjSec->pSecurityDescriptor != m_pNewSD &&
                    pObjSec->pSecurityDescriptor != NULL ) 
               {
                   LocalFree(pObjSec->pSecurityDescriptor);
               }
               pObjSec->pSecurityDescriptor = m_pNewSD;
               m_pNewSD = NULL;

               pObjSec->SeInfo = m_NewSeInfo;
           }
           m_pData->SetStatus(dw);
       }
       m_pData->Update(m_pSnapin);

       m_NewSeInfo = 0;
       m_hwndParent = NULL;

       if ( m_pSI ) 
       {
           m_pSI->Release();
           m_pSI = NULL;
       }
       m_pfnCreateDsPage=NULL;
   }

    return CAttribute::OnApply();
}

void CConfigObject::OnCancel()
{
    if ( m_pNewSD ) {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;
    m_hwndParent = NULL;

    if ( m_pSI ) {
        m_pSI->Release();
        m_pSI = NULL;
    }
    m_pfnCreateDsPage=NULL;

    CAttribute::OnCancel();
}

void CConfigObject::OnTemplateSecurity()
{
    SE_OBJECT_TYPE SeType;

    if (IsWindow(m_hwndSecurity)) {
       ::BringWindowToTop(m_hwndSecurity);
       return;
    }

    switch(m_pData->GetType()) {
    case ITEM_PROF_REGSD:
       SeType = SE_REGISTRY_KEY;
       break;
    case ITEM_PROF_FILESD:
        SeType = SE_FILE_OBJECT;
       break;
    default:
       ASSERT(FALSE);
       return;
    }

    INT_PTR nRet;

    if ( SE_DS_OBJECT == SeType ) {

        if ( !m_pfnCreateDsPage ) {
            if (!g_hDsSecDll)
                g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

            if ( g_hDsSecDll) {
                m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                               "DSCreateISecurityInfoObject");
            }
        }

        if ( m_pfnCreateDsPage ) {
            nRet= MyCreateDsSecurityPage(&m_pSI, m_pfnCreateDsPage,
                                         &m_pNewSD, &m_NewSeInfo,
                                        (LPCTSTR)(m_pData->GetAttr()),
                                        QueryReadOnly() ? SECURITY_PAGE_READ_ONLY : SECURITY_PAGE,
                                        m_hwndParent);
        } else
            nRet = -1;

    } else {
        BOOL bContainer;
        if ( SE_FILE_OBJECT == SeType ) {
            if ( m_pData->GetID() ) {
               bContainer = ((PSCE_OBJECT_SECURITY)(m_pData->GetID()))->IsContainer;
            } else {
               bContainer = FALSE;
            }
        } else {
           bContainer = TRUE;
        }
        m_hwndSecurity = (HWND) MyCreateSecurityPage2(bContainer,
                                               &m_pNewSD,
                                               &m_NewSeInfo,
                                               (LPCTSTR)(m_pData->GetAttr()),
                                               SeType,
                                               QueryReadOnly() ? SECURITY_PAGE_READ_ONLY : SECURITY_PAGE,
                                               GetSafeHwnd(),
                                               FALSE);  // not modeless
    }

    if (NULL == m_hwndSecurity ) {
/*
        BUG 147098 applies here - don't display message if this was canceled
        CString str;
        str.LoadString(IDS_CANT_ASSIGN_SECURITY);
        AfxMessageBox(str);
*/
    }

}

void CConfigObject::Initialize(CResult * pData)
{
   CAttribute::Initialize(pData);

   if ( m_pSI ) {
       m_pSI->Release();
       m_pSI = NULL;
   }
   m_pfnCreateDsPage=NULL;

   m_pNewSD = NULL;
   m_NewSeInfo = 0;

//   if (SCE_NO_VALUE == pData->GetBase()) {
   if ( pData->GetID() ) {

      PSCE_OBJECT_SECURITY pObject = (PSCE_OBJECT_SECURITY)(pData->GetID());

      switch (pObject-> Status) {
         case SCE_STATUS_IGNORE:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
         case SCE_STATUS_OVERWRITE:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 1;
            break;
         case SCE_STATUS_CHECK:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 0;
            break;
         case SCE_STATUS_NO_AUTO_INHERIT:
         default:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
      }

      if ( pObject->pSecurityDescriptor ) {

           MyMakeSelfRelativeSD(pObject->pSecurityDescriptor,
                                &m_pNewSD);
      }
      m_NewSeInfo = pObject->SeInfo;

   }
}



BOOL CConfigObject::OnInitDialog()
{
    CAttribute::OnInitDialog();

    UpdateData(FALSE);
    AddUserControl(IDC_OVERWRITE);
    AddUserControl(IDC_PREVENT);
    AddUserControl(IDC_INHERIT);
    AddUserControl(IDC_SECURITY);
    AddUserControl(IDC_CONFIG);

    OnConfigure();

    if (ITEM_PROF_REGSD == m_pData->GetType()) {
       CString str;
       str.LoadString(IDS_REGISTRY_CONFIGURE);
       SetDlgItemText(IDC_CONFIG,str);
       str.LoadString(IDS_REGISTRY_APPLY);
       SetDlgItemText(IDC_OVERWRITE,str);
       str.LoadString(IDS_REGISTRY_INHERIT);
       SetDlgItemText(IDC_INHERIT,str);
       str.LoadString(IDS_REGISTRY_PREVENT);
       SetDlgItemText(IDC_PREVENT,str);
    }
    if (QueryReadOnly()) {
       CString str;
       str.LoadString(IDS_VIEW_SECURITY);
       SetDlgItemText(IDC_SECURITY,str);
    }
    if (m_bConfigure) {
       if (0 == m_radConfigPrevent) {
          OnConfig();
       } else {
          OnPrevent();
       }
    }
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigObject::OnConfig()
{
   CWnd *pRadio = 0;

   if (m_bConfigure && !QueryReadOnly()) 
   {
      pRadio = GetDlgItem(IDC_INHERIT);
      pRadio->EnableWindow(TRUE);
      pRadio = GetDlgItem(IDC_OVERWRITE);
      pRadio->EnableWindow(TRUE);
   }
}

void CConfigObject::OnPrevent()
{
   CWnd *pRadio = GetDlgItem(IDC_INHERIT);
   pRadio->EnableWindow(FALSE);
   pRadio = GetDlgItem(IDC_OVERWRITE);
   pRadio->EnableWindow(FALSE);
}

void
CConfigObject::EnableUserControls( BOOL bEnable ) {
   CAttribute::EnableUserControls(bEnable);
   //
   // IDC_SECURITY needs to be available even in read only
   // mode so that the security page can be viewed.
   //
   // The page itself will be read only if necessary
   //
   if (QueryReadOnly() && bEnable) {
      CWnd *wnd = GetDlgItem(IDC_SECURITY);
      if (wnd) {
         wnd->EnableWindow(TRUE);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cobject.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CObject.h
//
//  Contents:   definition of CConfigObject
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_COBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
#define AFX_COBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigObject dialog

class CConfigObject : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pData);
    CConfigObject(UINT nTemplateID);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConfigObject)
	enum { IDD = IDD_CONFIG_OBJECT };
	int		m_radConfigPrevent;
	int		m_radInheritOverwrite;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigObject)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigObject)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    afx_msg void OnTemplateSecurity();
	afx_msg void OnConfig();
	afx_msg void OnPrevent();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
   virtual void EnableUserControls( BOOL bEnable );
private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    PFNDSCREATEISECINFO m_pfnCreateDsPage;
    LPDSSECINFO m_pSI;

    HWND m_hwndSecurity;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\command.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       command.cpp
//
//  Contents:   implementation of CComponentDataImpl
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "wrapper.h"
#include "snapmgr.h"
#include "asgncnfg.h"
#include "util.h"
#include <io.h>

static BOOL RecursiveCreateDirectory(
    IN LPCTSTR pszDir
    )
{
    DWORD   dwAttr;
    DWORD   dwErr;
    LPCTSTR psz;
    DWORD   cch;
    WCHAR   wch;
    LPTSTR  pszParent = NULL;
    BOOL    fResult = FALSE;

    dwAttr = GetFileAttributes(pszDir);

    if (0xFFFFFFFF != dwAttr)
    {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
            fResult = TRUE;
        goto CommonReturn;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        return FALSE;

    if (CreateDirectory(pszDir, NULL))  // lpSecurityAttributes
    {
        fResult = TRUE;
        goto CommonReturn;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto CommonReturn;

    // Peal off the last path name component
    cch = _tcslen(pszDir);
    psz = pszDir + cch;

    while (TEXT('\\') != *psz)
    {
        if (psz == pszDir)
            // Path didn't have a \.
            goto CommonReturn;
        psz--;
    }

    cch = (DWORD)(psz - pszDir);
    if (0 == cch)
        // Detected leading \Path
       goto CommonReturn;

    // Check for leading \\ or x:\.
    wch = *(psz - 1);
    if ((1 == cch && TEXT('\\') == wch) || (2 == cch && TEXT(':') == wch))
        goto CommonReturn;

    if (NULL == (pszParent = (LPWSTR) LocalAlloc(0, (cch + 1) * sizeof(WCHAR))))
        goto CommonReturn;
    memcpy(pszParent, pszDir, cch * sizeof(TCHAR));
    pszParent[cch] = TEXT('\0');

    if (!RecursiveCreateDirectory(pszParent))
        goto CommonReturn;
    if (!CreateDirectory(pszDir, NULL))                // lpSecurityAttributes
    {
        dwErr = GetLastError();
        goto CommonReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (pszParent != NULL)
        LocalFree(pszParent);
    return fResult;
}

//+------------------------------------------------------------------------------------
// CComponentDataImpl::GetWorkingDir
//
// Gets the default or last set directory used for the uIDDir.
// Some defaults defined by this function are.
//
// %windir%\security\database    - ANALYSIS
// %windir%\security\Templates   - Default profile location.
//
// Arguments:  [uIDDir]    - The ID of the working directory to set or retrieve.
//             [pStr]      - Either the source or the return value.   When the
//                            function returns this value will be set to a directory
//                            location.
//
//             [bSet]      - TRUE if [pStr] is to be set as the new working directory.
//             [bFile]     - [pStr] contains a file name.
//
// Returns:    TRUE        - If the function succees.
//             FALSE       - if something went wrong.
//             We don't really need to much granularity because this is not a critical
//             function.
//+------------------------------------------------------------------------------------
BOOL
CComponentDataImpl::GetWorkingDir(
   GWD_TYPES uIDDir,
   LPTSTR *pStr,
   BOOL bSet,
   BOOL bFile
   )
{
   BOOL fRet = FALSE;

   if(!pStr)
   {
      return FALSE;
   }

   LPTSTR szLocationValue = NULL;
   switch(uIDDir)
   {
      case GWD_CONFIGURE_LOG:
         szLocationValue = CONFIGURE_LOG_LOCATIONS_KEY;
         break;
      case GWD_ANALYSIS_LOG:
         szLocationValue = ANALYSIS_LOG_LOCATIONS_KEY;
         break;
      case GWD_OPEN_DATABASE:
         szLocationValue = OPEN_DATABASE_LOCATIONS_KEY;
         break;
      case GWD_IMPORT_TEMPLATE:
         szLocationValue = IMPORT_TEMPLATE_LOCATIONS_KEY;
         break;
      case GWD_EXPORT_TEMPLATE:
         szLocationValue = IMPORT_TEMPLATE_LOCATIONS_KEY; //104152, yanggao, 3/21/2001
         break;
   }


   LPTSTR pszPath = NULL;
   int i = 0;

   if( bSet )
   {
      if(!pStr || !(*pStr))
         return FALSE;

      i = lstrlen( *pStr );
      if(bFile)
      {
         //
         // Remove the file from the end of the string.
         //
         while(i && (*pStr)[i] != '\\')
            i--;
      }

      //
      // Create space for the new path and copy what we want.
      //
      pszPath = (LPTSTR)LocalAlloc( 0, (i + 1) * sizeof(TCHAR));
      if(!pszPath)
         return FALSE;

      memcpy(pszPath, *pStr, (i * sizeof(TCHAR)));
      pszPath[i] = 0;

      MyRegSetValue(HKEY_CURRENT_USER,
                    DEFAULT_LOCATIONS_KEY,
                    szLocationValue,
                    (BYTE*)pszPath,
                    (i+1)*sizeof(TCHAR),
                    REG_SZ);

      LocalFree(pszPath);
      return TRUE;
   }

   DWORD dwType = REG_SZ;
   if (MyRegQueryValue(HKEY_CURRENT_USER,
                   DEFAULT_LOCATIONS_KEY,
                   szLocationValue,
                   (PVOID*)&pszPath,
                   &dwType) == ERROR_SUCCESS)
   {
      *pStr = pszPath;
      return TRUE;
   }

   CString  sAppend;
   DWORD    dwRet;
   pszPath = NULL;

   switch ( uIDDir )
   {
      case GWD_CONFIGURE_LOG:
      case GWD_ANALYSIS_LOG:
         sAppend.LoadString(IDS_LOGFILE_DEFAULT);
         // fall through
      case GWD_OPEN_DATABASE:
         //
         // Used for open DB.
         //
         if (sAppend.IsEmpty())
         {
            sAppend.LoadString( IDS_DB_DEFAULT );
         } // else fell through


         //
         // Default directory for analysis.
         //
         pszPath = (LPTSTR)LocalAlloc( 0, (MAX_PATH +  sAppend.GetLength() + 1) * sizeof(TCHAR));
         if (pszPath == NULL)
            return FALSE;

         if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, pszPath)))
         {
            lstrcpy( &(pszPath[lstrlen(pszPath)]), sAppend );

            //
            // Check to see if the directory does not exist, it may need
            // to be created if this is the first time this user has
            // opened a database.
            //
            TCHAR szTempFile[MAX_PATH];
            CString str;

			str.LoadString(IDS_TEMP_FILENAME);
			if (!GetTempFileName(pszPath,str,0,szTempFile))
            {
               if ((GetLastError() == ERROR_DIRECTORY) && (RecursiveCreateDirectory(pszPath)))
               {
                  fRet = TRUE;
               }
               else
               {
                  LocalFree(pszPath);
                  fRet = FALSE;
               }
            }
            else
            {
               DeleteFile(szTempFile);
               fRet = TRUE;
            }
         }
         else
         {
            LocalFree(pszPath);
            pszPath = NULL;
         }
         break;

      case GWD_IMPORT_TEMPLATE:
      case GWD_EXPORT_TEMPLATE:

         sAppend.LoadString( IDS_DEFAULT_TEMPLATE_DIR );

         //
         // Default directory for analysis.
         //
         dwRet = GetSystemWindowsDirectory( NULL, 0);
         if (dwRet)
         {
            pszPath = (LPTSTR)LocalAlloc( 0, (dwRet +  sAppend.GetLength() + 1) * sizeof(TCHAR));
            if (!pszPath)
               return FALSE;

            GetSystemWindowsDirectory( pszPath, dwRet + 1);
            lstrcpy( &(pszPath[lstrlen(pszPath)]), sAppend );

            i = lstrlen(pszPath);

            //
            // Make sure the user can write to this directory:
            //
            TCHAR szTempFile[MAX_PATH];
            HANDLE hTempFile=NULL;
			CString str;

			str.LoadString(IDS_TEMP_FILENAME);
            szTempFile[0] = L'\0';
            if (GetTempFileName(pszPath,str,0,szTempFile))
            {
               hTempFile = ExpandAndCreateFile(szTempFile,
                                               GENERIC_READ|GENERIC_WRITE,
                                               0,
                                               NULL,
                                               CREATE_NEW,
                                               FILE_ATTRIBUTE_TEMPORARY,
                                               NULL);
            }
            if (hTempFile)
            {
               //
               // We have write access to this directory
               //
               ::CloseHandle(hTempFile);
               DeleteFile(szTempFile);
               fRet = TRUE;
            }
            else
            {
               //
               // We don't have write access to this directory.  Find another
               // or we can't get a temp file name
               //
               LPTSTR szPath;
               LPITEMIDLIST pidl;
               LPMALLOC pMalloc;

               //
               // For some reason this won't compile with SHGetFolderPath()
               // Therefore go the long way around and deal with the pidl.
               //
               if (NOERROR == SHGetSpecialFolderLocation(m_hwndParent,CSIDL_PERSONAL,&pidl))
               {
                  if (SHGetPathFromIDList(pidl,szTempFile))
                  {
                     szPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szTempFile)+ 1) * sizeof(TCHAR));
                     if (szPath)
                     {
                        //
                        // If we can't create a new path then use the old one so the user
                        // at least has a starting place to browse from
                        //
                        lstrcpy(szPath,szTempFile);
                        LocalFree(pszPath);
                        pszPath = szPath;
                        fRet = TRUE;
                     }
                  }
                  if (SUCCEEDED(SHGetMalloc(&pMalloc)))
                  {
                     pMalloc->Free(pidl);
                     pMalloc->Release();
                  }
               }
               //
               // If we can't write here the user will have to browse for something
               //
            }
         }
         break;
   }

   *pStr = pszPath;
   return fRet;
}

UINT_PTR CALLBACK OFNHookProc(
  HWND hdlg,      // handle to child dialog box
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
)
{

    if ( WM_NOTIFY == uiMsg )
    {
        OFNOTIFY* pOFNotify = (OFNOTIFY*) lParam;
        if ( pOFNotify && CDN_FILEOK == pOFNotify->hdr.code )
        {
            //
            // Don't accept filenames with DBCS characters that are greater then 255 in them
            //
            //Raid #263854, 4/3/2001
            BOOL ferr = TRUE;
            CString strErr;
            if(WideCharToMultiByte(CP_ACP, 0, pOFNotify->lpOFN->lpstrFile,
                                    -1, NULL, 0, NULL, &ferr))
            {
                return 0;
            }

            strErr.LoadString(IDS_NO_DBCS);
            strErr += L"\r\n\r\n";
            strErr += pOFNotify->lpOFN->lpstrFile;
            AfxMessageBox(strErr);

            ::SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);

            return 1;
        }
    }
    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnOpenDataBase()
//
//  Synopsis:   Picks a new database for SAV to work on
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnOpenDataBase()
{
   //
   // Find the desired new database
   //
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CString strDir;

   strDefExtension.LoadString(IDS_DEFAULT_DB_EXTENSION);
   strFilter.LoadString(IDS_DB_FILTER);

   strOfnTitle.LoadString(IDS_OPEN_DB_OFN_TITLE);

   LPTSTR pszDir = NULL;
   //
   // Build a working directory for this object,
   //
   if (GetWorkingDir( GWD_OPEN_DATABASE, &pszDir ) )
   {
      strDir = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }

   WCHAR           szFile[MAX_PATH];
   ::ZeroMemory (szFile, MAX_PATH * sizeof(WCHAR));
   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));

    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = m_hwndParent;
    //HINSTANCE     hInstance;

    // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
    // MFC delimits with '|' not '\0'
   LPTSTR pch = szFilter;
    while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH * sizeof(WCHAR);
    ofn.lpstrInitialDir = (PCWSTR) strDir;
    ofn.lpstrTitle = strOfnTitle;
    ofn.Flags = OFN_HIDEREADONLY|    // Don't show the read only prompt
                OFN_SHAREAWARE|
                OFN_NOREADONLYRETURN|
                OFN_EXPLORER |        // Explorer style dialog;
                OFN_DONTADDTORECENT|
                OFN_ENABLEHOOK;
    ofn.lpstrDefExt = (PCWSTR) strDefExtension;
    ofn.lpfnHook = OFNHookProc;

   if ( GetOpenFileName (&ofn) )
   {
      //
      // Set the working directory of the database.
      //
      pszDir = szFile;
      GetWorkingDir( GWD_OPEN_DATABASE, &pszDir, TRUE, TRUE );
     if( IsSystemDatabase( ofn.lpstrFile /*fo.GetPathName()*/) )
     {
         AfxMessageBox( IDS_CANT_OPEN_SYSTEM_DB, MB_OK);
         return S_FALSE;
     }
     SadName = ofn.lpstrFile; //fo.GetPathName();
     SetErroredLogFile(NULL);
      //
      // If new database doesn't exist then ask for a configuration to import
      //

     DWORD dwAttr = GetFileAttributes(SadName);

     if (0xFFFFFFFF == dwAttr)
     {
         SCESTATUS sceStatus = SCESTATUS_SUCCESS;
         //
         // New database, so assign a configuration
         //
         if( OnAssignConfiguration( &sceStatus ) == S_FALSE)
         {
                     //
            // If the user decides to cancel the import of a configuration, then,
            // we need to unload the sad information and display the correct
            // error message.  Set the sad errored to PROFILE_NOT_FOUND so error,
            // is correct. There is no need to call LoadSadinfo.
            //
            UnloadSadInfo();
            if( sceStatus != SCESTATUS_SUCCESS )
               SadErrored = sceStatus;
            else
               SadErrored = SCESTATUS_PROFILE_NOT_FOUND;
            if(m_AnalFolder)
            {
               m_pConsole->SelectScopeItem(m_AnalFolder->GetScopeItem()->ID);
            }
            return S_OK;
         }
     }

      //
      // Invalidiate currently open database
      //
      RefreshSadInfo();
      return S_OK;
   }
   else
   {
       DWORD dwErr = CommDlgExtendedError();
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnNewDataBase()
//
//  Synopsis:   Picks a new database for SAV to work on
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnNewDatabase()
{
   //
   // Find the desired new database
   //
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CWnd cwndParent;

   strDefExtension.LoadString(IDS_DEFAULT_DB_EXTENSION);
   strFilter.LoadString(IDS_DB_FILTER);
   strOfnTitle.LoadString(IDS_NEW_DB_OFN_TITLE);

   // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
    // MFC delimits with '|' not '\0'
    while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters

   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = SadName.GetBuffer(MAX_PATH);
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT;
   ofn.lpstrTitle = strOfnTitle;

   if (GetOpenFileName(&ofn))
   {
      PVOID pHandle = NULL;

      SadName.ReleaseBuffer();
      //
      // If new database doesn't exist then ask for a configuration to import
      //
      DWORD dwAttr = GetFileAttributes(SadName);

      if (0xFFFFFFFF == dwAttr)
      {
         //
         // New database, so assign a configuration
         //
         SCESTATUS sceStatus;
         OnAssignConfiguration(&sceStatus);
      }

      //
      // Invalidiate currently open database
      //
      SetErroredLogFile(NULL);
      RefreshSadInfo();
      return S_OK;
   }

   return S_FALSE;
}


//+--------------------------------------------------------------------------
//
//  Method:     OnAssignConfiguration()
//
//  Synopsis:   Assigns a configuration template to SAV's currently selected
//              database
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnAssignConfiguration( SCESTATUS *pSceStatus )
{

   //
   //Currently pSceStatus is only used for passing back the error
   //when user presses cancel on select template diaglog.


   //
   // Find the desired new database
   //
   CString strDefExtension;         // Default extension
   CString strCurFile;
   CString strFilter;               // Extension filter
   CString strOfnTitle;
   CWnd cwndParent;
   BOOL bIncremental;
   SCESTATUS status;
   HKEY hKey;                       // HKEY of TemplateUsed.
   DWORD dwBufSize = 0;             // Size of szTemplateUsed in bytes
   DWORD dwType    = 0;             // Type of registry item, return by query
   DWORD dwStatus;

   *pSceStatus = 0;

   //
   // Display a warning and give a chance to cancel
   // if they try to configure a non-system database
   //
   if (IsSystemDatabase(SadName))
   {
      BOOL bImportAnyway;

      bImportAnyway = AfxMessageBox(IDS_IMPORT_WARNING,MB_OKCANCEL);
      if (IDCANCEL == bImportAnyway)
      {
         return S_FALSE;
      }
   }


   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_ASSIGN_CONFIG_OFN_TITLE);

   //
   // Get the last directory used by templates.
   //
   LPTSTR pszDir = NULL;
   if(strCurFile.IsEmpty())
   {
      if (GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir ) )
      {
         strCurFile = pszDir;
         LocalFree(pszDir);
         pszDir = NULL;
      }
   }
   strCurFile += TEXT("\\*.");
   strCurFile += strDefExtension;

   cwndParent.Attach(m_hwndParent);
   CAssignConfiguration ac(TRUE,        // File Open, not file save
                  strDefExtension,      // Default Extension
                  strCurFile,           // Initial File Name == current DB
                  OFN_HIDEREADONLY|     // Don't show the read only prompt
                  OFN_EXPLORER|         // Explorer style dialog
                  OFN_ENABLETEMPLATE|   // custom template
                  OFN_SHAREAWARE|       // We're not going to need exclusive
                  OFN_DONTADDTORECENT|
                  OFN_PATHMUSTEXIST,    // The Template must exist for us to assign it.
                  strFilter,            // Filter for allowed extensions
                  &cwndParent);         // Dialog's Parent window

   cwndParent.Detach();

   ac.m_ofn.lpstrTitle = strOfnTitle.GetBuffer(1);
   ac.m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_ASSIGN_CONFIG_CHECK);
   if (IDOK == ac.DoModal())
   {
      CThemeContextActivator activator;
      strCurFile = ac.GetPathName();
      bIncremental = ac.m_bIncremental;

      //
      // Set the working dir to this file.
      //
      pszDir = strCurFile.GetBuffer(0);
      GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir, TRUE, TRUE);
      strCurFile.ReleaseBuffer();
      CWaitCursor wc;

      //
      // Unload the sad info before we choose to do an import.
      //
      UnloadSadInfo();
      status = AssignTemplate(
                    strCurFile.IsEmpty() ? NULL:(LPCTSTR)strCurFile,
                    SadName,
                    bIncremental
                    );

      if (SCESTATUS_SUCCESS != status)
      {
         CString strErr;

         MyFormatResMessage(status,IDS_IMPORT_FAILED,NULL,strErr);
         AfxMessageBox(strErr);

         //
         // We don't know if the database is still OK to read so open it anyways.
         //
         LoadSadInfo(TRUE);
	 if( SCESTATUS_SPECIAL_ACCOUNT == SadErrored ) //Raid #589139,XPSP1 DCR, yanggao, 4/12/2002.
            *pSceStatus = SadErrored;
         return S_FALSE;
      }

      RefreshSadInfo();
      return S_OK;
   }
   *pSceStatus = SCESTATUS_NO_TEMPLATE_GIVEN;
    return S_FALSE;

}

//+--------------------------------------------------------------------------
//
//  Method:     OnSecureWizard()
//
//  Synopsis:   Launch the secure wizard (registered)
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnSecureWizard()
{

    HRESULT hr=S_FALSE;
    PWSTR pstrWizardName=NULL;

    if ( GetSecureWizardName(&pstrWizardName, NULL) )
    {

        PROCESS_INFORMATION ProcInfo;
        STARTUPINFO StartInfo;
        BOOL fOk;


        RtlZeroMemory(&StartInfo,sizeof(StartInfo));
        StartInfo.cb = sizeof(StartInfo);
        StartInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartInfo.wShowWindow = (WORD)SW_SHOWNORMAL;

        fOk = CreateProcess(pstrWizardName, NULL,
                       NULL, NULL, FALSE,
                       0,
                       NULL,
                       NULL,
                       &StartInfo,
                       &ProcInfo
                       );

        if ( fOk )
        {
            ::CloseHandle(ProcInfo.hProcess);
            ::CloseHandle(ProcInfo.hThread);

            hr = S_OK;
        }

        LocalFree(pstrWizardName);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnSaveConfiguration()
//
//  Synopsis:   Saves the assigned computer template to an INF file
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnSaveConfiguration()
{
   //
   // Find the desired new database
   //
   CString strDefExtension;
   CString strFilter;
   CWnd cwndParent;
   CString strDefName;
   CString strName;
   SCESTATUS status = SCESTATUS_SUCCESS;
   CString strOfnTitle;

   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_EXPORT_CONFIG_OFN_TITLE);

   //
   // Get the working directory for INF files.
   //
   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;

   // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
    // MFC delimits with '|' not '\0'
    while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters


   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = strDefName.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT;
   ofn.lpstrTitle = strOfnTitle;

   if (GetSaveFileName(&ofn))
   {
      strDefName.ReleaseBuffer();
      strName = ofn.lpstrFile;

      //
      // Set the working directory for inf files.
      //
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();
      //
      // Generate new inf file
      //

      status = SceCopyBaseProfile(GetSadHandle(),
                                  SCE_ENGINE_SCP,
                                  (LPTSTR)(LPCTSTR)strName,
                                  AREA_ALL,
                                  NULL );
      if (SCESTATUS_SUCCESS != status)
      {
         CString str;
         CString strErr;
         GetSceStatusString(status, &strErr);

         AfxFormatString2(str,IDS_EXPORT_FAILED,strName,strErr);
         AfxMessageBox(str);
         return S_FALSE;
      }

      return S_OK;
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnExportPolicy()
//
//  Synopsis:   This function exports either the effective or local table
//              from the system security database to a file.
//
//              The function asks the user for a file through the CFileOpen
//              class, then writes out the contents of either the effective
//              or local policy table in the system database.
//
//  Arguments:  [bEffective]  - Either to export the effect or local table.
//
//  Returns:    S_OK    - if everything went well.
//              S_FALSE - something failed.
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnExportPolicy( BOOL bEffective )
{
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CString strDefName;
   CString strName;
   DWORD dwErr = 0;
   BOOL bCopySuccess = FALSE;

   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_EXPORT_POLICY_OFN_TITLE);

   //
   // Get the working directory for locations.
   //
   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;

   // Translate filter into commdlg format (lots of \0)
   LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
   // MFC delimits with '|' not '\0'
   while ((pch = _tcschr(pch, '|')) != NULL)
      *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters


   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = strDefName.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT;
   ofn.lpstrTitle = strOfnTitle;

   if (GetSaveFileName(&ofn))
   {
      strDefName.ReleaseBuffer();
      strName = ofn.lpstrFile;

      //
      // Set the working directory for locations.
      //
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();

      //
      // Make sure we can make the file.
      //
      DWORD dwErr = FileCreateError( strName, 0 );
      if(dwErr == IDNO)
      {
         return S_FALSE;
      }

      //
      // Generate the template
      //

      SCESTATUS sceStatus;
      CWaitCursor wc;

      sceStatus = SceSetupGenerateTemplate(
                     NULL,                // Computer name
                     NULL,                // The system database
                     bEffective,          // For right now just the Local Pol table.
                     strName.GetBuffer(0),
                     NULL,
                     AREA_ALL
                     );
      strName.ReleaseBuffer();

      if(sceStatus != SCESTATUS_SUCCESS)
      {
         //
         // Display the error message
         //
         DWORD dwError = SceStatusToDosError( sceStatus );
         CString strErr;
         MyFormatMessage( sceStatus, NULL, NULL, strErr );
         strErr += strName;

         AfxMessageBox( strErr, MB_ICONEXCLAMATION | MB_OK );
         return S_FALSE;

      }
      return S_OK;
   }

   return S_FALSE;
}


//+--------------------------------------------------------------------------------------------
// CComponentDataImpl::OnImportPolicy
//
// Import policy opens a file open dialog box in which the user is allowed to choose
// a security configuration INF file to import into security policy.
//
//
// Arguments:  [pDataObject]  - The data object associated with the folder calling
//                              this function.
// Returns:    S_OK           - Import was successful.
//             S_FALSE        - Something went wrong.
//---------------------------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnImportPolicy(LPDATAOBJECT pDataObject)
{
   CEditTemplate *pet = NULL;
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CWnd cwndParent;
   CString strDefName;
   CString strName;


   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_IMPORT_POLICY_OFN_TITLE);


   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;

   cwndParent.Attach(m_hwndParent);
   CAssignConfiguration fo(TRUE,                // File open
                  strDefExtension,     // Default Extension
                  strDefName,          // Initial File Name == current DB
                  OFN_HIDEREADONLY|    // Don't show the read only prompt
                  OFN_SHAREAWARE|
                  OFN_EXPLORER|        // Explorer style dialog
                  OFN_ENABLETEMPLATE|   // custom template
                  OFN_DONTADDTORECENT|
                  OFN_PATHMUSTEXIST,    // The Template must exist for us to assign it.
                  strFilter,           // Filter for allowed extensions
                  &cwndParent);        // Dialog's Parent window
   cwndParent.Detach();

   fo.m_ofn.lpstrTitle = strOfnTitle.GetBuffer(1);
   fo.m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_ASSIGN_CONFIG_CHECK);

   CThemeContextActivator activator;
   if (IDOK == fo.DoModal()) 
   {
      PVOID pHandle = NULL;
      BOOL bIncremental = fo.m_bIncremental;

      strName = fo.GetPathName();
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();
      CWaitCursor wc;

      CEditTemplate *pet;

      //
      // pet will be freed in m_Templates in DeleteTemplate
      //
      pet = GetTemplate(strName,AREA_ALL);

      CString strErr;
      CString strSCE;
      int ret=0;

      if ( pet == NULL ) 
      {
          //
          // this is an invalid template or something is wrong reading the data out
          //

          strSCE.LoadString(IDS_EXTENSION_NAME);
          strErr.Format(IDS_IMPORT_POLICY_INVALID,strName);
          m_pConsole->MessageBox(strErr,strSCE,MB_OK,&ret);

          return S_FALSE;

      } 
      else 
      {
         if ( ( bIncremental &&
                (SCESTATUS_SUCCESS != SceAppendSecurityProfileInfo(m_szSingleTemplateName,
                                          AREA_ALL,
                                          pet->pTemplate,
                                          NULL))) ||
              (!bIncremental && !CopyFile(strName,m_szSingleTemplateName,FALSE) ) )
         {
             //
             // Import Failed
             //
             strSCE.LoadString(IDS_EXTENSION_NAME);
             strErr.Format(IDS_IMPORT_POLICY_FAIL,strName);
             m_pConsole->MessageBox(strErr,strSCE,MB_OK,&ret);

             DeleteTemplate(strName);

             return S_FALSE;
         }

         DeleteTemplate(strName);

      }

      DeleteTemplate(m_szSingleTemplateName);

      //
      // Update the window.
      //
      pet = GetTemplate(m_szSingleTemplateName);
      if(pet)
      {
         DWORD dwErr = pet->RefreshTemplate();
         if ( 0 != dwErr )
         {
            CString strErr;

            MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
            AfxMessageBox(strErr);
            return S_FALSE;
         }
      }
      RefreshAllFolders();
      return S_OK;
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------------------------
// CComponentDataImpl::OnImportLocalPolicy
//
// Import policy opens a file open dialog box in which the user is allowed to choose
// a security configuration INF file to import into local policy.
//
// The function asks for the file name then calls SceConfigureSystem() with the
// SCE_NO_CONFIG option.  This imports the specifide file into the local policy
// database.
//
// After the database is updated, we refresh the local policy template held in memory.
//
// Arguments:  [pDataObject]  - The data object associated with the folder calling
//                              this function.
// Returns:    S_OK           - Import was successful.
//             S_FALSE        - Something went wrong.
//---------------------------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnImportLocalPolicy(LPDATAOBJECT pDataObject)
{
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CString strDefName;
   CString strName;
   DWORD dwErr = 0;
   SCESTATUS sceStatus = SCESTATUS_SUCCESS;
   CString strErr;
   CString strY;


   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_IMPORT_POLICY_OFN_TITLE);

   // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
    // MFC delimits with '|' not '\0'
    while ((pch = _tcschr(pch, TEXT('|'))) != NULL)
        *pch++ = TEXT('\0');
    // do not call ReleaseBuffer() since the string contains '\0' characters

   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;


   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = strDefName.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT;
   ofn.lpstrTitle = strOfnTitle;

   if (GetOpenFileName(&ofn))
   {
      PVOID pHandle = NULL;

      strName = ofn.lpstrFile;
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();
      CWaitCursor wc;

      CEditTemplate *pet;
      pet = GetTemplate(strName,AREA_SECURITY_POLICY|AREA_PRIVILEGES);
      if (!pet)
      {
         goto ret_error;
      }

      //
      // We're going to alter this one so make sure it doesn't save out
      //
      pet->SetNoSave(TRUE);

      //
      // Remove entries that are set by domain policy since they'll be overwritten
      // anyway and we don't allow setting things that'll be overwritten.
      //
      RemovePolicyEntries(pet);

      //
      // 120502 - SceUpdateSecurityProfile doesn't work with SCE_STRUCT_INF,
      //          but the AREA_SECURITY_POLICY and AREA_PRIVILEGES sections are
      //          compatable so we can call it SCE_ENGINE_SYSTEM, which will work.
      //
      SCETYPE origType = pet->pTemplate->Type;
      pet->pTemplate->Type = SCE_ENGINE_SYSTEM;

      sceStatus = SceUpdateSecurityProfile(NULL,
                                        AREA_SECURITY_POLICY|AREA_PRIVILEGES,
                                        pet->pTemplate,
                                        SCE_UPDATE_SYSTEM
                                        );
      //
      // Set the type back so the engine knows how to delete it properly
      //
      pet->pTemplate->Type = origType;

      if (SCESTATUS_SUCCESS != sceStatus)
      {
         goto ret_error;
      }
      //
      // Update the window.
      //
      pet = GetTemplate(GT_LOCAL_POLICY);
      if(pet)
      {
         DWORD dwErr = pet->RefreshTemplate();
         if ( 0 != dwErr )
         {
            CString strErr;

            MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
            AfxMessageBox(strErr);
            return S_FALSE;
         }
      }
      RefreshAllFolders();
      return S_OK;
   }

   strDefName.ReleaseBuffer();
   return S_FALSE;
ret_error:
   strDefName.ReleaseBuffer();
   MyFormatMessage( sceStatus, NULL, NULL, strErr);
   strErr += strName;
   strErr += L"\n";
   strErr += strY;
   AfxMessageBox( strErr, MB_OK);
   return S_FALSE;

}


HRESULT
CComponentDataImpl::OnAnalyze()
{
   PEDITTEMPLATE pet;

   //
   // If the computer template has been changed then save it before
   // we can inspect against it
   //
   pet = GetTemplate(GT_COMPUTER_TEMPLATE);
   if (pet && pet->IsDirty())
   {
      pet->Save();
   }

   m_pUIThread->PostThreadMessage(SCEM_ANALYZE_PROFILE,(WPARAM)(LPCTSTR)SadName,(LPARAM)this);
   return S_OK;
}

BOOL
CComponentDataImpl::RemovePolicyEntries(PEDITTEMPLATE pet)
{
   PEDITTEMPLATE petPol = GetTemplate(GT_EFFECTIVE_POLICY);

   if (!petPol)
   {
      return FALSE;
   }

#define CD(X) if (petPol->pTemplate->X != SCE_NO_VALUE) { pet->pTemplate->X = SCE_NO_VALUE; };

   CD(MinimumPasswordAge);
   CD(MaximumPasswordAge);
   CD(MinimumPasswordLength);
   CD(PasswordComplexity);
   CD(PasswordHistorySize);
   CD(LockoutBadCount);
   CD(ResetLockoutCount);
   CD(LockoutDuration);
   CD(RequireLogonToChangePassword);
   CD(ForceLogoffWhenHourExpire);
   CD(EnableAdminAccount);
   CD(EnableGuestAccount);

   // These members aren't declared in NT4
   CD(ClearTextPassword);
   CD(AuditDSAccess);
   CD(AuditAccountLogon);
   CD(LSAAnonymousNameLookup);

   CD(MaximumLogSize[0]);
   CD(MaximumLogSize[1]);
   CD(MaximumLogSize[2]);
   CD(AuditLogRetentionPeriod[0]);
   CD(AuditLogRetentionPeriod[1]);
   CD(AuditLogRetentionPeriod[2]);
   CD(RetentionDays[0]);
   CD(RetentionDays[1]);
   CD(RetentionDays[2]);
   CD(RestrictGuestAccess[0]);
   CD(RestrictGuestAccess[1]);
   CD(RestrictGuestAccess[2]);
   CD(AuditSystemEvents);
   CD(AuditLogonEvents);
   CD(AuditObjectAccess);
   CD(AuditPrivilegeUse);
   CD(AuditPolicyChange);
   CD(AuditAccountManage);
   CD(AuditProcessTracking);

   //
   // These two are strings rather than DWORDs
   //
   if (petPol->pTemplate->NewAdministratorName && pet->pTemplate->NewAdministratorName)
   {
      LocalFree(pet->pTemplate->NewAdministratorName);
      pet->pTemplate->NewAdministratorName = NULL;
   }
   if (petPol->pTemplate->NewGuestName && pet->pTemplate->NewGuestName)
   {
      LocalFree(pet->pTemplate->NewGuestName);
      pet->pTemplate->NewGuestName = NULL;
   }

#undef CD

   //
   // Clear privileges set in PetPol out of pet
   //

   SCE_PRIVILEGE_ASSIGNMENT *ppaPet = pet->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
   SCE_PRIVILEGE_ASSIGNMENT *ppaPol = petPol->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;

   SCE_PRIVILEGE_ASSIGNMENT *ppaLast = NULL;
   for(SCE_PRIVILEGE_ASSIGNMENT *ppa = ppaPol; ppa != NULL ; ppa = ppa->Next)
   {
      for (SCE_PRIVILEGE_ASSIGNMENT *ppa2 = ppaPet;
           ppa2 != NULL;
           ppaLast = ppa2, ppa2 = ppa2->Next) {
         if (0 == lstrcmpi(ppa->Name,ppa2->Name))
         {
            if (ppaLast)
            {
               ppaLast->Next = ppa2->Next;
            }
            else
            {
               //  Front of list
               ppaPet = ppa2->Next;
            }
            ppa2->Next = NULL;
            SceFreeMemory(ppa2,SCE_STRUCT_PRIVILEGE);
            ppa2 = ppaLast;
            //
            // Found it, so don't bother checking the rest
            //
            break;
         }
      }
   }

   //
   // Clear reg values set in PetPol out of pet
   //
   SCE_REGISTRY_VALUE_INFO *rvPet = pet->pTemplate->aRegValues;
   SCE_REGISTRY_VALUE_INFO *rvPol = petPol->pTemplate->aRegValues;
   for(DWORD i=0;i< petPol->pTemplate->RegValueCount;i++)
   {
      for (DWORD j=0;j<pet->pTemplate->RegValueCount;j++)
      {
         if (0 == lstrcmpi(rvPol[i].FullValueName,rvPet[j].FullValueName))
         {
            // Match.  Delete Value from pet
            if (rvPet[j].Value)
            {
               LocalFree(rvPet[j].Value);
               rvPet[j].Value = NULL;
            }
            //
            // Found it, so don't bother checking rest
            //
            break;
         }
      }
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cookie.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       cookie.cpp
//
//  Contents:   Functions for handling SCE cookies for the scope and
//              result panes
//
//  History:
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "cookie.h"
#include "snapmgr.h"
#include "wrapper.h"
#include <sceattch.h>
#include "precdisp.h"
#include "util.h"
#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CFolder::~CFolder() 
{
   if (m_pScopeItem) 
   {
      delete m_pScopeItem;
      m_pScopeItem = NULL;
   }
   CoTaskMemFree(m_pszName);
   CoTaskMemFree(m_pszDesc);

   
   while (!m_resultItemList.IsEmpty () )
   {
      CResult* pResult = m_resultItemList.RemoveHead ();
      if ( pResult )
         pResult->Release ();
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     SetDesc
//
//  Synopsis:   Sets the description of the folder
//
//  Arguments:  [szDesc] - [in] the new description of the folder
//
//  Returns:    TRUE if successfull, FALSE otherwise
//
//  Modifies:   m_pszDesc
//
//  History:
//
//---------------------------------------------------------------------------
BOOL CFolder::SetDesc(LPCTSTR szDesc)
{
   UINT     uiByteLen = 0;
   LPOLESTR psz = 0;

   if (szDesc != NULL) 
   {
      uiByteLen = (lstrlen(szDesc) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL) 
      {
         lstrcpy(psz, szDesc);
         CoTaskMemFree(m_pszDesc);
         m_pszDesc = psz;
      } 
      else
         return FALSE;
      
   } 
   else
      return FALSE;
   
   return TRUE;
}
// --------------------------------------------------------------------------
//  Method:     SetViewUpdate
//
//  Synopsis:   Sets and gets update flag of this folder
//
//  History: Raid #258237, 4/12/2001
//
//---------------------------------------------------------------------------
void CFolder::SetViewUpdate(BOOL fUpdate)
{
    m_ViewUpdate = fUpdate;
}

BOOL CFolder::GetViewUpdate() const
{
    return m_ViewUpdate;
}
//+--------------------------------------------------------------------------
//
//  Method:     SetMode
//
//  Synopsis:   Sets the SCE Mode that this folder is operating under and
//              calculates the "Mode Bits" appropriate for that mode
//
//  Arguments:  [dwMode]  - The mode to set
//
//  Returns:    TRUE if the mode is valid, FALSE otherwise
//
//  Modifies:   m_dwMode
//              m_ModeBits
//
//  History:    20-Jan-1998   Robcap     created
//
//---------------------------------------------------------------------------
BOOL CFolder::SetMode(DWORD dwMode) 
{
   //
   // Make sure this is a legitimate mode
   //
   switch (dwMode) 
   {
      case SCE_MODE_RSOP_COMPUTER:
      case SCE_MODE_RSOP_USER:
      case SCE_MODE_LOCALSEC:
      case SCE_MODE_COMPUTER_MANAGEMENT:
      case SCE_MODE_DC_MANAGEMENT:
      case SCE_MODE_LOCAL_USER:
      case SCE_MODE_LOCAL_COMPUTER:
      case SCE_MODE_REMOTE_USER:
      case SCE_MODE_REMOTE_COMPUTER:
      case SCE_MODE_DOMAIN_USER:
      case SCE_MODE_DOMAIN_COMPUTER:
      case SCE_MODE_OU_USER:
      case SCE_MODE_OU_COMPUTER:
      case SCE_MODE_EDITOR:
      case SCE_MODE_VIEWER:
      case SCE_MODE_DOMAIN_COMPUTER_ERROR:
         m_dwMode = dwMode;
         break;
      default:
         return FALSE;
         break;
   }

   //
   // Calculate the mode bits for this mode
   //
   m_ModeBits = 0;
   //
   // Directory Services not avalible in NT4
   //
   if ((dwMode == SCE_MODE_DOMAIN_COMPUTER) ||
       (dwMode == SCE_MODE_DC_MANAGEMENT)) 
   {
      m_ModeBits |= MB_DS_OBJECTS_SECTION;
   }
   if ((dwMode == SCE_MODE_OU_USER) ||
       (dwMode == SCE_MODE_DOMAIN_USER) ||
       (dwMode == SCE_MODE_REMOTE_COMPUTER) ||
       (dwMode == SCE_MODE_REMOTE_USER) ||
       (dwMode == SCE_MODE_RSOP_USER) ||
       (dwMode == SCE_MODE_DOMAIN_COMPUTER_ERROR) ||
       (dwMode == SCE_MODE_LOCAL_USER)) 
   {
      m_ModeBits |= MB_NO_NATIVE_NODES |
                    MB_NO_TEMPLATE_VERBS |
                    MB_WRITE_THROUGH;
   }
   if ((dwMode == SCE_MODE_OU_COMPUTER) ||
       (dwMode == SCE_MODE_DOMAIN_COMPUTER) ) 
   {
      m_ModeBits |= MB_SINGLE_TEMPLATE_ONLY |
                    MB_NO_TEMPLATE_VERBS |
                    MB_GROUP_POLICY |
                    MB_WRITE_THROUGH;
   }
   if (dwMode == SCE_MODE_RSOP_COMPUTER) 
   {
      m_ModeBits |= MB_SINGLE_TEMPLATE_ONLY |
                    MB_NO_TEMPLATE_VERBS |
                    MB_WRITE_THROUGH;
   }

   if (dwMode == SCE_MODE_RSOP_COMPUTER ||
       dwMode == SCE_MODE_RSOP_USER) 
   {
      m_ModeBits |= MB_READ_ONLY |
                    MB_RSOP;
   }

   if (SCE_MODE_LOCAL_COMPUTER == dwMode) 
   {
        m_ModeBits |= MB_LOCAL_POLICY |
                      MB_LOCALSEC |
                      MB_NO_TEMPLATE_VERBS |
                      MB_SINGLE_TEMPLATE_ONLY |
                      MB_WRITE_THROUGH;

        if (!IsAdmin()) {
           m_ModeBits |= MB_READ_ONLY;
        }

      if (IsDomainController()) 
      {
          m_ModeBits |= MB_DS_OBJECTS_SECTION;
      }
   }

   if ( dwMode == SCE_MODE_EDITOR ) 
   {
      m_ModeBits |= MB_TEMPLATE_EDITOR;
      m_ModeBits |= MB_DS_OBJECTS_SECTION;

   } 
   else if ( dwMode == SCE_MODE_VIEWER ) 
   {
      m_ModeBits |= MB_ANALYSIS_VIEWER;
      if (IsDomainController()) 
	   {
         m_ModeBits |= MB_DS_OBJECTS_SECTION;
      }
   } 
   else if (dwMode == SCE_MODE_LOCALSEC) 
   {
      m_ModeBits |= MB_LOCALSEC;
      if (!IsAdmin()) 
      {
         m_ModeBits |= MB_READ_ONLY;
      }
      if (IsDomainController()) 
	   {
         m_ModeBits |= MB_DS_OBJECTS_SECTION;
      }
   }

   return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Method:     Create
//
//  Synopsis:   Initialize a CFolder Object
//
//
//  Arguments:  [szName]       - The folder's display name
//              [szDesc]       - The folder's discription
//              [infName]      - The inf file associated with the folder (optional)
//              [nImage]       - The folder's closed icon index
//              [nOpenImage]   - the folder's open icon index
//              [type]         - The folder' type
//              [bHasChildren] - True if the folder has children folders
//              [dwMode]       - The Mode the folder operates under
//              [pData]        - Extra data to associate with the folder
//
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CFolder::Create(LPCTSTR szName,           // Name
                LPCTSTR szDesc,           // Description
                LPCTSTR infName,          // inf file name
                int nImage,               // closed icon index
                int nOpenImage,           // open icon index
                FOLDER_TYPES type,        // folder type
                BOOL bHasChildren,        // has children
                DWORD dwMode,             // mode
                PVOID pData)              // data
{
   UINT uiByteLen = 0;
   LPOLESTR psz = 0;
   HRESULT hr = S_OK;

   ASSERT(m_pScopeItem == NULL); // Calling create twice on this item?

   CString str;
   //
   // Two-stage construction
   //
   m_pScopeItem = new SCOPEDATAITEM;
   if (!m_pScopeItem)
      return E_OUTOFMEMORY;
   
   ZeroMemory(m_pScopeItem,sizeof(m_pScopeItem));
   //
   // Set folder type
   //
   m_type = type;

   //
   // Add node name
   //
   if (szName != NULL || szDesc != NULL ) 
   {
      m_pScopeItem->mask = SDI_STR;
      //
      // Displayname is a callback (unsigned short*)(-1)
      m_pScopeItem->displayname = MMC_CALLBACK;
   }

   if ( szName != NULL ) 
   {
      uiByteLen = (lstrlen(szName) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL)
         lstrcpy(psz, szName);
      else
         hr = E_OUTOFMEMORY;

      CoTaskMemFree(m_pszName);
      m_pszName = psz;
   }

   if (szDesc != NULL) 
   {
      uiByteLen = (lstrlen(szDesc) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL) 
         lstrcpy(psz, szDesc);
      else
         hr = E_OUTOFMEMORY;
      
      CoTaskMemFree(m_pszDesc);
      m_pszDesc = psz;
   }


   if (infName != NULL) 
   {
      uiByteLen = (lstrlen(infName) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL) 
         lstrcpy(psz, infName);
      else
         hr = E_OUTOFMEMORY;
      
      CoTaskMemFree(m_infName);
      m_infName = psz;
   }

   //
   // Add close image
   //
   m_pScopeItem->mask |= SDI_IMAGE;  // no close image for now
   //    m_pScopeItem->nImage = (int)MMC_CALLBACK;

   m_pScopeItem->nImage = nImage;

   //
   // Add open image
   //
   if (nOpenImage != -1) 
   {
      m_pScopeItem->mask |= SDI_OPENIMAGE;
      m_pScopeItem->nOpenImage = nOpenImage;
   }

   //
   // Add button to node if the folder has children
   //
   if (bHasChildren == TRUE) 
   {
      m_pScopeItem->mask |= SDI_CHILDREN;
      //
      // The number of children doesn't make any difference now,
      // so pick 1 until the node is expanded and the true value
      // is known
      //
      m_pScopeItem->cChildren = 1;
   }

   //
   // Set the SCE Mode and calculate the mode bits
   //
   if (dwMode)
      SetMode(dwMode);
   
   m_pData = pData;

   return hr;
}


//+------------------------------------------------------------------------------------------------
// CFolder::SetDesc
//
// Translate dwStatus and dwNumChildren to a string and sets m_szDesc
//
// Argumens:   [dwStats]         - Object status.
//             [dwNumChildren]   - Number of children for the object.
//
// Returns: TRUE  - If successful
//          FALSE - If no more memory is available (or dwStatus is greater then 999)
//-------------------------------------------------------------------------------------------------
BOOL CFolder::SetDesc( DWORD dwStatus, DWORD dwNumChildren )
{
   if(dwStatus > 999)
      return FALSE;

   TCHAR szText[256];
   swprintf(szText, L"%03d%d", dwStatus, dwNumChildren);

   SetDesc(szText);

   return TRUE;
}



//+------------------------------------------------------------------------------------------------
// CFolder::GetObjectInfo
//
// Translate m_szDesc into dwStatus and dwNumChildren
//
// Argumens:   [pdwStats]         - Object status.
//             [pdwNumChildren]   - Number of children for the object.
//
// Returns: TRUE  - If successful
//          FALSE - m_szDesc is NULL
//-------------------------------------------------------------------------------------------------
BOOL CFolder::GetObjectInfo( DWORD *pdwStatus, DWORD *pdwNumChildren )
{
   if(!m_pszDesc)
      return FALSE;
   
   if( lstrlen(m_pszDesc) < 4)
      return FALSE;

   if(pdwStatus )
      *pdwStatus = (m_pszDesc[0]-L'0')*100 + (m_pszDesc[1]-L'0')*10+ (m_pszDesc[2]-L'0');

   if(pdwNumChildren)
      *pdwNumChildren = _wtol( m_pszDesc + 3 );

   return TRUE;
}

/*--------------------------------------------------------------------------------------------------
Method:     GetResultItemHandle()

Synopisi:   This function must be called to retreive a valid handle to this folders result items.
         The handle must be freed by a call to ReleaseResultItemHandle().  If these two functions
         are not called in conjunction.  The behavior fo the result items will be strange.

Arguments:  [handle] - [out]  The handle value to use for any other functions that require a
                     handle.

Returns: ERROR_SUCCESS           - A valid result item was returned
         ERROR_INVALID_PARAMETER    - [handle] is NULL
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::GetResultItemHandle(
    HANDLE *handle)
{
    if(!handle)
        return ERROR_INVALID_PARAMETER;
   
    m_iRefCount++;
    *handle = (HANDLE)&m_resultItemList;
    return ERROR_SUCCESS;
}

/*--------------------------------------------------------------------------------------------------
Method:     GetResultItem()

Synopisi:   Returns the result item pointed to by position and sets [pos] to the next item.

Arguments:  [handle] - [in] A valid handle returns by GetResultItemHandle()
         [pos]    - [in|out] The position of the result.  If this value is NULL, the first result
                     item in the list is returned.
         [pResult]   - [out] A pointer to a result item pointer

Returns: ERROR_SUCCESS           - A result item was found for the position.
         ERROR_INVALID_PARAMETER    - [handle] is invalid, or [pResult] is NULL
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::GetResultItem(
    HANDLE handle,
    POSITION &pos,
    CResult **pResult)
{
   if(!handle || handle != (HANDLE)&m_resultItemList || !pResult)
      return ERROR_INVALID_PARAMETER;

   if(!pos)
   {
      pos = m_resultItemList.GetHeadPosition();

      if(!pos)
      {
         *pResult = NULL;
         return ERROR_SUCCESS;
      }
   }

   *pResult = m_resultItemList.GetNext(pos);
   return ERROR_SUCCESS;
}

/*--------------------------------------------------------------------------------------------------
Method:     GetResultItemPosition()

Synopisi:   Returns the position of the result item in the result item list for this folder item.

Arguments:  [handle] - A valid handle returns by GetResultItemHandle()
         [pResult]   - The retult item position to return.

Returns: NULL     - Invalid handle or the result item is not part of this folder.
         POSITION    - A valid position value that can be used in other calls that require the
                     position of the result item.
--------------------------------------------------------------------------------------------------*/
POSITION CFolder::GetResultItemPosition(
    HANDLE handle,
    CResult *pResult)
{
    if(handle != (HANDLE)&m_resultItemList)
        return NULL;
    

    POSITION  pos = m_resultItemList.GetHeadPosition();
    while(pos)
    {
        if(pResult == m_resultItemList.GetNext(pos))
            break;
    }

    return pos;
}

/*--------------------------------------------------------------------------------------------------
Method:     RemoveAllResultItems()

Synopisi:   Removes all result items from the list.  This call sets the ref count to 0 so it could
         be a very damaging call.
--------------------------------------------------------------------------------------------------*/
void CFolder::RemoveAllResultItems()
{
    //
    // Very Very dangerous call.
    //
    m_iRefCount = 1;
    HANDLE handle = (HANDLE)&m_resultItemList;
    ReleaseResultItemHandle (handle);
}

DWORD CFolder::GetDisplayName( CString &str, int iCol )
{
    int npos;
    DWORD dwRet = ERROR_INVALID_PARAMETER;

    if(!iCol)
    {
        str = GetName();
        dwRet = ERROR_SUCCESS;
    }

    switch(m_type)
    {
    case PROFILE:
    case REG_OBJECTS:
        if(!iCol)
        {
            npos = str.ReverseFind(L'\\');
            str = GetName() + npos + 1;
            dwRet = ERROR_SUCCESS;
        }
        break;
    case FILE_OBJECTS:
        if (0 == iCol) 
        {
           npos = str.ReverseFind(L'\\');
           if (str.GetLength() > npos + 1) 
           {
              str=GetName() + npos + 1;
           }
           dwRet = ERROR_SUCCESS;
        }


        break;
    case STATIC:
        if(iCol == 2)
        {
            str = GetDesc();
            dwRet = ERROR_SUCCESS;
        }
        break;

    }

    if(dwRet != ERROR_SUCCESS)
    {
        if( ((m_type >= ANALYSIS && m_type <=AREA_FILESTORE_ANALYSIS) ||
             (m_type >= LOCALPOL_ACCOUNT && m_type <= LOCALPOL_LAST))
             && iCol == 1)
        {
            str = GetDesc();
            dwRet = ERROR_SUCCESS;
        } 
        else if(iCol <= 3 && GetDesc() != NULL) 
        {
            LPTSTR szDesc = GetDesc();
            switch(iCol)
            {
            case 1:
                // first 3 digits of m_pszDesc
                dwRet = 0;
                GetObjectInfo( &dwRet, NULL );

                ObjectStatusToString(dwRet, &str);
                dwRet = ERROR_SUCCESS;
                break;

            case 2:
                // first 2 digits of m_pszDesc
                dwRet = 0;
                GetObjectInfo( &dwRet, NULL );

                dwRet &= (~SCE_STATUS_PERMISSION_MISMATCH | 0x0F);
                ObjectStatusToString(dwRet, &str);
                dwRet = ERROR_SUCCESS;
                break;

             case 3:
                str = szDesc+3;
                dwRet = ERROR_SUCCESS;
                break;

             default:
                break;
            }
        }
    }

    return dwRet;
}

/*--------------------------------------------------------------------------------------------------
Method:     AddResultItem()

Synopisi:   Adds a result item to the list.

Arguments:  [handle] - [in] A handle returned by GetResultItemHandle().
         [pResult]   - [in] The result item to add.


Returns: ERROR_SUCCESS           - The result item was added.
         ERROR_INVALID_PARAMETER    - [handle] is invalid, or pResult is NULL.
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::AddResultItem(
    HANDLE handle,
    CResult *pResult)
{
    if(!pResult || handle != (HANDLE)&m_resultItemList)
        return ERROR_INVALID_PARAMETER;

    m_resultItemList.AddHead(pResult);
    return ERROR_SUCCESS;
}

/*--------------------------------------------------------------------------------------------------
Method:     RemoveResultItem()

Synopisi:   Removes a result item from the list..

Arguments:  [handle] - [in] A handle returned by GetResultItemHandle().
         [pResult]   - [in] The result item to remove.


Returns: ERROR_SUCCESS           - The item was removed
         ERROR_INVALID_PARAMETER    - [handle] is invalid, or pResult is NULL.
         ERROR_RESOURCE_NOT_FOUND   - The result item does not exist withen this folder.
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::RemoveResultItem (
   HANDLE handle,
   CResult *pItem)
{
   if(!pItem || handle != (HANDLE)&m_resultItemList)
      return ERROR_INVALID_PARAMETER;
   

   POSITION posCur;
   POSITION pos = m_resultItemList.GetHeadPosition();
   while(pos)
   {
      posCur = pos;
      if ( m_resultItemList.GetNext(pos) == pItem )
      {
         m_resultItemList.RemoveAt(posCur);
         return ERROR_SUCCESS;
      }
   }

   return ERROR_RESOURCE_NOT_FOUND;
}

/*--------------------------------------------------------------------------------------------------
Method:     ReleaseResultItemHandle()

Synopisi:   Release associated data with the handle.  If the ref count goes to zero then
         all result items are removed from the list.

Arguments:  [handle] - [in] A handle returned by GetResultItemHandle().

Returns: ERROR_SUCCESS           - The function succeded
         ERROR_INVALID_PARAMETER    - [handle] is invalid.
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::ReleaseResultItemHandle(
    HANDLE &handle)
{
   if(handle != (HANDLE)&m_resultItemList)
      return ERROR_INVALID_PARAMETER;

   if( !m_iRefCount )
      return ERROR_SUCCESS;

   m_iRefCount--;

   if(!m_iRefCount)
   {
      while (!m_resultItemList.IsEmpty () )
      {
         CResult* pResult = m_resultItemList.RemoveHead ();
         if ( pResult )
            pResult->Release ();
      }
   }

    handle = NULL;
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// CResult
//

//+--------------------------------------------------------------------------
//
//  Method:     Create
//
//  Synopsis:   Initialize a CResult Object
//
//
//  Arguments:  [szAttr]    - The result item's display name
//              [dwBase]    - The item's template setting
//              [dwSetting] - The item's last inspected setting
//              [type]      - The type of the item's setting
//              [status]    - The matched status of the item
//              [cookie]    - The MMC cookie for this item
//              [szUnits]   - The units this item's setting is measured in
//              [nID]       - An identifier for the item, dependant on the type
//              [pBaseInfo] - The template object this item belongs to
//              [pDataObj]  - The data object of the scope pane this item belongs to
//              [pNotify]   - Object to pass notifications through
//  History:
//
//---------------------------------------------------------------------------
HRESULT CResult::Create(LPCTSTR szAttr,           // attribute's display name
                LONG_PTR dwBase,          // template setting
                LONG_PTR dwSetting,       // last inspected setting
                RESULT_TYPES type,        // type of the item's setting
                int status,               // matched status of the item
                MMC_COOKIE cookie,        // the MMC cookie for this item
                LPCTSTR szUnits,          // units the setting is measured in
                LONG_PTR nID,             // An identifier for the item, dependant on the type
                PEDITTEMPLATE pBaseInfo,  // The template object this item belongs to
                LPDATAOBJECT pDataObj,    // The data object of the scope pane this item belongs to
                LPNOTIFY   pNotify,       // Notification object
                CSnapin *pSnapin)         // Snapin window which owns this object
{
   HRESULT hr = S_OK;

   m_type = type;
   m_status = status;
   m_cookie = cookie;
   m_dwBase = dwBase;
   m_dwSetting = dwSetting;
   m_nID = nID;
   m_profBase = pBaseInfo;
   //m_pDataObj = pDataObj;
   m_pNotify = pNotify;
   m_pSnapin = pSnapin;

   UINT     uiByteLen = 0;
   LPTSTR   psz = 0;

   if ( szAttr != NULL ) 
   {
      uiByteLen = (lstrlen(szAttr) + 1);
      psz = new TCHAR[uiByteLen];

      if (psz != NULL) 
      {
         lstrcpy(psz, szAttr);
      } 
      else 
      {
         hr = E_OUTOFMEMORY;
      }

      if (m_szAttr)
      {
          delete [] m_szAttr;
      }
      m_szAttr = psz;
   }

   if ( szUnits != NULL ) 
   {
       SetUnits( szUnits );
       if(!m_szUnits){
           hr = E_OUTOFMEMORY;
       }
   }

   return hr;
}



void CResult::SetUnits(
    LPCTSTR sz)
{
   if (ITEM_GROUP == GetType()) 
   {
      //
      // we shouldn't be storing this in a string storage
      // This isn't actually a string and shouldn't be copied.  Yuck.
      //
      m_szUnits = (LPTSTR)sz;
   } 
   else 
   {
      if(m_szUnits)
      {
         LocalFree(m_szUnits);
      }
      m_szUnits = NULL;
      if(sz)
      {
         int iLen = lstrlen(sz);
         m_szUnits = (LPTSTR) LocalAlloc(0, (iLen + 1) * sizeof(TCHAR));

         if(!m_szUnits)
            return;

         lstrcpy(m_szUnits, sz);
      }
   }
}




//+--------------------------------------------------------------------------
//
//  Method:     Update
//
//  Synopsis:   Updates a changed result item and broadcasts
//              that change appropriately
//
//  History:
//
//---------------------------------------------------------------------------
void CResult::Update(CSnapin *pSnapin, BOOL bEntirePane)
{
   LPARAM hint = 0;

   //
   // Set the appropriate template section as needing to be saved
   //
   if (m_profBase) 
   {
      //
      // m_profBase will only be set for Configuation templates.
      // It will not be set for Analysis items
      //
      if (m_cookie && ((CFolder *)m_cookie)->GetType() < AREA_POLICY_ANALYSIS ) 
      {
         switch ( ((CFolder *)m_cookie)->GetType()) 
         {
            case POLICY_ACCOUNT:
            case POLICY_LOCAL:
            case POLICY_EVENTLOG:
            case POLICY_PASSWORD:
            case POLICY_KERBEROS:
            case POLICY_LOCKOUT:
            case POLICY_AUDIT:
            case POLICY_OTHER:
            case POLICY_LOG:
               m_profBase->SetDirty(AREA_SECURITY_POLICY);
               break;
            case AREA_PRIVILEGE:
               m_profBase->SetDirty(AREA_PRIVILEGES);
               break;
            case AREA_GROUPS:
               m_profBase->SetDirty(AREA_GROUP_MEMBERSHIP);
               break;
            case AREA_SERVICE:
               m_profBase->SetDirty(AREA_SYSTEM_SERVICE);
               break;
            case AREA_REGISTRY:
               m_profBase->SetDirty(AREA_REGISTRY_SECURITY);
               break;
            case AREA_FILESTORE:
               m_profBase->SetDirty(AREA_FILE_SECURITY);
               break;
         }
      }
   }

   //
   // Query the snap in data.
   //
   LPDATAOBJECT pDataObj;
   if( pSnapin->QueryDataObject( m_cookie, CCT_RESULT, &pDataObj ) != S_OK){
      return;
   }


   if(!m_pNotify){
      return;
   }

   //
   // Update all views.
   //
   if(bEntirePane)
   {
      if(!pSnapin->GetSelectedFolder())
      {
          return;
      }
      if( pDataObj && m_pNotify ) //Raid #357968, #354861, 4/25/2001
      {
          LPNOTIFY pNotify = m_pNotify;
          pSnapin->GetSelectedFolder()->RemoveAllResultItems();
          pNotify->UpdateAllViews(
              pDataObj,
              (LPARAM)pSnapin->GetSelectedFolder(),
              UAV_RESULTITEM_UPDATEALL
              );
      }
   } 
   else
   {
      if (pDataObj && m_pNotify)
      {
          m_pNotify->UpdateAllViews(
              pDataObj,
              NULL,
              pSnapin->GetSelectedFolder(),
              this,
              UAV_RESULTITEM_UPDATE
              );
          pDataObj->Release(); 
      }
   }
}


//+--------------------------------------------------------------------------
//
//  Method:    GetAttrPretty
//
//  Synopsis:  Get the Attribute's display name as it should be displayed
//             in the result pane
//
//  History:
//
//---------------------------------------------------------------------------
LPCTSTR CResult::GetAttrPretty()
{
   return GetAttr();
}

//+--------------------------------------------------------------------------
//
//  Method:     CResult::GetStatusErrorString
//
//  Synopsis:   This function caclulates the error status string to display
//              for the CResult item.  In LPO mode it always returns
//              IDS_NOT_DEFINED, and for MB_TEMPLATE_EDITOR mode it always
//              Loads IDS_NOT_CONFIGURED
//
//  Arguments:  [pStr]    - [Optional] CString object to load resource with.
//
//  Returns:    The resource ID to load. else zero if the error is not
//              defined.
//
//  History:    a-mthoge 11/17/1998
//
//---------------------------------------------------------------------------
DWORD CResult::GetStatusErrorString( CString *pStr )
{
   DWORD nRes = 0;
   if( m_cookie )
   {
      if( ((CFolder *)m_cookie)->GetModeBits() & MB_LOCALSEC )
      {
         if (GetType() ==ITEM_LOCALPOL_REGVALUE) 
         {
            nRes = IDS_NOT_DEFINED;
         } 
         else 
         {
            nRes = IDS_NOT_APPLICABLE;
         }
      } 
      else if ( ((CFolder *)m_cookie)->GetModeBits() & MB_RSOP ) 
      {
         nRes = IDS_NO_POLICY;
      } 
      else if (((CFolder *)m_cookie)->GetModeBits() & MB_ANALYSIS_VIEWER) 
      {
         nRes = IDS_NOT_ANALYZED;
      } 
      else if( ((CFolder *)m_cookie)->GetModeBits() & (MB_TEMPLATE_EDITOR | MB_SINGLE_TEMPLATE_ONLY) )
      {
         nRes = IDS_NOT_CONFIGURED;
      }
   }

   if(!nRes)
   {
      nRes = GetStatus();
      if(!nRes)
      {
         nRes = GetStatus();
      }
      nRes = ObjectStatusToString( nRes, pStr );
   } 
   else if(pStr)
   {
      pStr->LoadString( nRes );
   }
   return nRes;
}

LPCTSTR CResult::GetSourceGPOString()
{
//   ASSERT(pFolder->GetModeBits() & RSOP);

   vector<PPRECEDENCEDISPLAY>* vppd = GetPrecedenceDisplays();
   if (vppd && !vppd->empty()) 
   {
      PPRECEDENCEDISPLAY ppd = vppd->front();
      return ppd->m_szGPO;
   }
   return NULL;
}

//+--------------------------------------------------------------------------
//
//  Method:     CResult::GetDisplayName
//
//  Synopsis:   Gets the display name for the result item.
//
//  Arguments:  [pFolder]    - [Optional] If this parameter is NULL, m_Cookie
//                             is used as the CFolder object.
//              [str]        - [out] On exit this function will contain the
//                             string to display.
//              [iCol]       - [in] The column you want to retrieve the string
//                             for.
//
//  Returns:    ERROR_SUCCESS    - [str] is a valid string for the column.
//
//  History:    a-mthoge 11/17/1998
//
//---------------------------------------------------------------------------
DWORD
CResult::GetDisplayName(
                       CFolder *pFolder,
                       CString &str,
                       int iCol
                       )
{
   DWORD dwRet = ERROR_INVALID_PARAMETER;

   //
   // If pFolder is not passed in then use the cookie as the CFolder
   // object.
   //
   if ( pFolder )
   {
// bogus assertion?
//         ASSERT(pFolder != (CFolder *)GetCookie());
   } else {
      pFolder = (CFolder *)GetCookie();
   }

   LPTSTR pszAlloc = NULL;
   int npos = 0;
   if (iCol == 0) {
      //
      // First column strings.
      //
      str = GetAttr();

      if (pFolder &&
          (pFolder->GetType() < AREA_POLICY || pFolder->GetType() > REG_OBJECTS) ) {
         //
         // SCE Object strings
         //
         npos = str.ReverseFind(L'\\');
      } else {
         npos = 0;
      }

      //
      // All other strings.
      //
      if ( npos > 0 ) {
         str = GetAttr() + npos + 1;
      }
      return ERROR_SUCCESS;
   }

   if ( pFolder ) {
      //
      // Items that are defined by the folder type.
      //
      if ((pFolder->GetType() == AREA_REGISTRY ||
           pFolder->GetType() == AREA_FILESTORE) &&
          ((pFolder->GetModeBits() & MB_RSOP) == MB_RSOP) &&
          iCol == 1) {
         str = GetSourceGPOString();
      }

      switch (pFolder->GetType()) {
      case AREA_REGISTRY:
      case AREA_FILESTORE:
         //
         // profile objects area
         //
         switch (GetStatus()) {
         case SCE_STATUS_IGNORE:
            str.LoadString(IDS_OBJECT_IGNORE);
            break;
         case SCE_STATUS_OVERWRITE:
            str.LoadString(IDS_OBJECT_OVERWRITE);
            break;
         }
         dwRet = ERROR_SUCCESS;
         break;
      }
      if ( pFolder->GetType() >= AREA_REGISTRY_ANALYSIS && pFolder->GetType() < AREA_LOCALPOL ) {
         switch ( iCol ) {
         case 1:
            // permission status
            dwRet = GetStatus() & (~SCE_STATUS_AUDIT_MISMATCH | 0x0F);
            ObjectStatusToString(dwRet, &str);
            break;
         case 2:
            // auditing status
            dwRet = GetStatus() & (~SCE_STATUS_PERMISSION_MISMATCH | 0x0F);
            ObjectStatusToString(dwRet, &str);
            break;
         default:
            str = TEXT("0");
            break;
         }
         dwRet = ERROR_SUCCESS;
      }

      if (dwRet == ERROR_SUCCESS) {
         return dwRet;
      }
   }

   //
   // Items determined by result type.
   //
   switch ( GetType () ) {
   case ITEM_PROF_GROUP:
      if ( GetID() ) {
         //
         // Group member ship strings.
         //
         PSCE_GROUP_MEMBERSHIP pgm;
         pgm = (PSCE_GROUP_MEMBERSHIP)( GetID() );
         if ( iCol == 1) {
            //
            // Members string.
            //
            ConvertNameListToString(pgm->pMembers, &pszAlloc);
         } else if (iCol == 2){
            //
            // Members of string.
            //
            ConvertNameListToString(pgm->pMemberOf, &pszAlloc);
         } else if (iCol == 3) {
            ASSERT(m_pSnapin->GetModeBits() & MB_RSOP);
            str = GetSourceGPOString();
         } else {
            ASSERT(0 && "Illegal column");
         }
         if (pszAlloc) {
            str = pszAlloc;
            delete [] pszAlloc;
         }
      }
      dwRet = ERROR_SUCCESS;
      break;
   case ITEM_GROUP:
      if ( GetID() ) {
         PSCE_GROUP_MEMBERSHIP pgm;
         pgm = (PSCE_GROUP_MEMBERSHIP)(GetID());

         if (iCol == 1) {
            TranslateSettingToString(
                                    GetGroupStatus( pgm->Status, STATUS_GROUP_MEMBERS ),
                                    NULL,
                                    GetType(),
                                    &pszAlloc
                                    );
         } else if (iCol == 2) {

            TranslateSettingToString(
                                    GetGroupStatus(pgm->Status, STATUS_GROUP_MEMBEROF),
                                    NULL,
                                    GetType(),
                                    &pszAlloc
                                    );
         } else {
            ASSERT(0 && "Illegal column");
         }
         //
         // Test to see if the result item already has a string, if it does then
         // we will delete the old string.
         //
         if (pszAlloc) {
            str = pszAlloc;
            delete [] pszAlloc;
         }
      }
      dwRet = ERROR_SUCCESS;
      break;
   case ITEM_PROF_REGVALUE:
      if (iCol == 2 && (m_pSnapin->GetModeBits() & MB_RSOP) == MB_RSOP) {
         str = GetSourceGPOString();
         break;
      }
   case ITEM_REGVALUE:
   case ITEM_LOCALPOL_REGVALUE:
      {
         PSCE_REGISTRY_VALUE_INFO prv = NULL;

         if (iCol == 1) {
            prv = (PSCE_REGISTRY_VALUE_INFO)(GetBase());
         } else if (iCol == 2) {
            prv = (PSCE_REGISTRY_VALUE_INFO)(GetSetting());
         } else {
            ASSERT(0 && "Illegal column");
         }

         if ( prv ) {
            if ( iCol > 1 && !(prv->Value)) {
               //
               // Determine status fron analysis.
               //
               GetStatusErrorString( &str );
               dwRet = ERROR_SUCCESS;
               break;
            }

            //
            // Determine string by the item value.
            //
            if ( dwRet != ERROR_SUCCESS ) {
               pszAlloc = NULL;
               switch ( GetID() ) {
               case SCE_REG_DISPLAY_NUMBER:
                  if ( prv->Value ) {
                     TranslateSettingToString(
                                             _wtol(prv->Value),
                                             GetUnits(),
                                             ITEM_DW,
                                             &pszAlloc
                                             );
                  }
                  break;
               case SCE_REG_DISPLAY_CHOICE:
                  if ( prv->Value ) {
                     TranslateSettingToString(_wtol(prv->Value),
                                              NULL,
                                              ITEM_REGCHOICE,
                                              &pszAlloc);
                  }
                  break;
               case SCE_REG_DISPLAY_FLAGS:
                  if ( prv->Value ) {
                     TranslateSettingToString(_wtol(prv->Value),
                                              NULL,
                                              ITEM_REGFLAGS,
                                              &pszAlloc);
                     if( pszAlloc == NULL ) //Raid #286697, 4/4/2001
                     {
                         str.LoadString(IDS_NO_MIN);  
                         dwRet = ERROR_SUCCESS;
                     }
                  }
                  break;

               case SCE_REG_DISPLAY_MULTISZ:
               case SCE_REG_DISPLAY_STRING:
                  if (prv && prv->Value) {
                     str = prv->Value;
                     dwRet = ERROR_SUCCESS;
                  }
                  break;
               default: // boolean
                  if ( prv->Value ) {
                     long val;
                     val = _wtol(prv->Value);
                     TranslateSettingToString( val,
                                               NULL,
                                               ITEM_BOOL,
                                               &pszAlloc
                                             );
                  }
                  break;

               }
            }

            if (dwRet != ERROR_SUCCESS) {
               if ( pszAlloc ) {
                  str = pszAlloc;
                  delete [] pszAlloc;
               } else {
                  GetStatusErrorString(&str);
               }
            }
         }
         dwRet = ERROR_SUCCESS;
      }
      break;
   }

   if (dwRet != ERROR_SUCCESS) {
      //
      // Other areas.
      //
      if (iCol == 1) {
         if( GetBase() == (LONG_PTR)ULongToPtr(SCE_NO_VALUE)){
            if( m_pSnapin->GetModeBits() & MB_LOCALSEC){
               str.LoadString(IDS_NOT_APPLICABLE);
            } else {
               str.LoadString(IDS_NOT_CONFIGURED);
            }
         } else {
            //
            // Edit template
            //
            GetBase(pszAlloc);
         }
      } else if (iCol == 2) {
         if ((m_pSnapin->GetModeBits() & MB_RSOP) == MB_RSOP) {
            //
            // RSOP Mode
            //
            str = GetSourceGPOString();
         } else {
            //
            // Analysis Template.
            //
            GetSetting(pszAlloc);
         }

      } else {
         ASSERT(0 && "Illegal column");
      }

      if (pszAlloc) {
         str = pszAlloc;
         delete [] pszAlloc;
      }
      dwRet = ERROR_SUCCESS;
   }

   return dwRet;
}


//+--------------------------------------------------------------------------
//
//  Function:   TranslateSettingToString
//
//  Synopsis:   Convert a result pane setting into a string
//
//  Arguments:  [setting]  - [in] The value to be converted
//              [unit]     - [in, optiona] The string for the units to use
//              [type]     - [in] The type of the setting to be converted
//              [LPTSTR]   - [in|out] the address to store the string at
//
//  Returns:   *[LPTSTR]   - the translated string
//
//---------------------------------------------------------------------------
void CResult::TranslateSettingToString(LONG_PTR setting,
                                  LPCTSTR unit,
                                  RESULT_TYPES type,
                                  LPTSTR* pTmpstr)
{
   DWORD nRes = 0;

   if (!pTmpstr) 
   {
      ASSERT(pTmpstr);
      return;
   }

   *pTmpstr = NULL;

   switch ( setting ) 
   {
   case SCE_KERBEROS_OFF_VALUE:
      nRes = IDS_OFF;
      break;

   case SCE_FOREVER_VALUE:
      nRes = IDS_FOREVER;
      break;

   case SCE_ERROR_VALUE:
      nRes = IDS_ERROR_VALUE;
      break;

   case SCE_NO_VALUE:
      nRes = GetStatusErrorString( NULL );
      break;

   case SCE_NOT_ANALYZED_VALUE:
      nRes = GetStatusErrorString( NULL );
      break;

    default:
      switch ( type ) 
      {
         case ITEM_SZ:
         case ITEM_PROF_SZ:
         case ITEM_LOCALPOL_SZ:
            if (setting && setting != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)) 
            {
               *pTmpstr = new TCHAR[lstrlen((LPTSTR)setting)+1];
               if (*pTmpstr)
                  wcscpy(*pTmpstr,(LPTSTR)setting);
            } 
            else
               nRes = GetStatusErrorString(NULL);
            break;

         case ITEM_PROF_BOOL:
         case ITEM_LOCALPOL_BOOL:
         case ITEM_BOOL:
            if ( setting )
               nRes = IDS_ENABLED;
            else
               nRes = IDS_DISABLED;
            break;

         case ITEM_PROF_BON:
         case ITEM_LOCALPOL_BON:
         case ITEM_BON:
            if ( setting )
               nRes = IDS_ON;
            else
               nRes = IDS_OFF;
            break;

         case ITEM_PROF_B2ON:
         case ITEM_LOCALPOL_B2ON:
         case ITEM_B2ON: 
         {
            CString strAudit;
            CString strFailure;
            if ( setting & AUDIT_SUCCESS )
               strAudit.LoadString(IDS_SUCCESS);

            if ( setting & AUDIT_FAILURE ) 
            {
               if (setting & AUDIT_SUCCESS) 
                  strAudit += TEXT(", ");
               
               strFailure.LoadString(IDS_FAILURE);
               strAudit += strFailure;
            }
            if (strAudit.IsEmpty())
               strAudit.LoadString(IDS_DO_NOT_AUDIT);

            *pTmpstr = new TCHAR [ strAudit.GetLength()+1 ];
            if (*pTmpstr)
               wcscpy(*pTmpstr, (LPCTSTR) strAudit);
         }
         break;

         case ITEM_PROF_RET:
         case ITEM_LOCALPOL_RET:
         case ITEM_RET: 
            switch(setting) 
            {
               case SCE_RETAIN_BY_DAYS:
                  nRes = IDS_BY_DAYS;
                  break;

               case SCE_RETAIN_AS_NEEDED:
                  nRes = IDS_AS_NEEDED;
                  break;

               case SCE_RETAIN_MANUALLY:
                  nRes = IDS_MANUALLY;
                  break;

               default:
                  break;
            }
            break;

         case ITEM_PROF_REGCHOICE:
         case ITEM_REGCHOICE: 
         {
            PREGCHOICE pRegChoice = m_pRegChoices;
            while(pRegChoice) 
            {
               if (pRegChoice->dwValue == (DWORD)setting) 
               {
                  *pTmpstr = new TCHAR[lstrlen(pRegChoice->szName)+1];
                  if (*pTmpstr)
                     wcscpy(*pTmpstr, (LPCTSTR) pRegChoice->szName);
                  break;
               }
               pRegChoice = pRegChoice->pNext;
            }
            break;
         }

         case ITEM_REGFLAGS: 
         {
            TCHAR *pStr = NULL;
            PREGFLAGS pRegFlags = m_pRegFlags;
            while(pRegFlags) 
            {
               if ((pRegFlags->dwValue & (DWORD) setting) == pRegFlags->dwValue) 
               {
                  pStr = *pTmpstr;
                  *pTmpstr = new TCHAR[(pStr?lstrlen(pStr):0)+lstrlen(pRegFlags->szName)+2];
                  if (*pTmpstr) 
                  {
                     if (pStr) 
                     {
                        lstrcpy(*pTmpstr, (LPCTSTR) pStr);
                        lstrcat(*pTmpstr,L",");
                        lstrcat(*pTmpstr, pRegFlags->szName);
                     } 
                     else 
                        lstrcpy(*pTmpstr, pRegFlags->szName);
                  }
                  if (pStr)
                     delete [] pStr;
               }
               pRegFlags = pRegFlags->pNext;
            }
            break;
         }

         case ITEM_PROF_GROUP:
         case ITEM_PROF_PRIVS:
            if (NULL != setting && (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != setting )
               ConvertNameListToString((PSCE_NAME_LIST) setting,pTmpstr);
            break;

         case ITEM_LOCALPOL_PRIVS:
            if (NULL != setting && (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != setting )
               ConvertNameListToString(((PSCE_PRIVILEGE_ASSIGNMENT) setting)->AssignedTo,pTmpstr);
            break;

         case ITEM_PRIVS:
            if (NULL != setting && (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != setting )
               ConvertNameListToString(((PSCE_PRIVILEGE_ASSIGNMENT) setting)->AssignedTo,pTmpstr);
            else
               nRes = GetStatusErrorString(NULL);
            break;

         case ITEM_GROUP:
            //nRes = GetStatusErrorString(NULL);
            nRes = ObjectStatusToString((DWORD) setting, NULL);

            if ( setting == MY__SCE_MEMBEROF_NOT_APPLICABLE )
                nRes = IDS_NOT_APPLICABLE;
            break;

         case ITEM_PROF_DW:
         case ITEM_LOCALPOL_DW:
         case ITEM_DW:
            nRes = 0;
            if ( unit ) 
            {
               *pTmpstr = new TCHAR[wcslen(unit)+20];
               if (*pTmpstr)
                  swprintf(*pTmpstr, L"%d %s", setting, unit);
            } 
            else 
            {
               *pTmpstr = new TCHAR[20];
               if (*pTmpstr)
                  swprintf(*pTmpstr, L"%d", setting);
            }
            break;

         default:
            *pTmpstr = NULL;
            break;
      }
      break;
   }
   if (nRes) 
   {
      CString strRes;
      if (strRes.LoadString(nRes)) 
      {
         *pTmpstr = new TCHAR[strRes.GetLength()+1];
         if (*pTmpstr)
            wcscpy(*pTmpstr, (LPCTSTR) strRes);
         else 
         {
            //
            // Couldn't allocate string so display will be blank.
            //
         }
      } 
      else 
      {
         //
         // Couldn't load string so display will be blank.
         //
      }
   }
}


//+--------------------------------------------------------------------------
//
//  Function:  GetProfileDefault()
//
//  Synopsis:  Find the default values for undefined policies
//
//  Returns:   The value to assign as the default value for the policy.
//
//             SCE_NO_VALUE is returned on error.
//
//+--------------------------------------------------------------------------
DWORD_PTR
CResult::GetProfileDefault() {
   PEDITTEMPLATE pet = NULL;
   SCE_PROFILE_INFO *pspi = NULL;

   if (!m_pSnapin) {
      return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
   }
   pet = m_pSnapin->GetTemplate(GT_DEFAULT_TEMPLATE);
   if (pet && pet->pTemplate) {
      pspi = pet->pTemplate;
   }

#define PROFILE_DEFAULT(X,Y) ((pspi && (pspi->X != SCE_NO_VALUE)) ? pspi->X : Y)
#define PROFILE_KERB_DEFAULT(X,Y) ((pspi && pspi->pKerberosInfo && (pspi->pKerberosInfo->X != SCE_NO_VALUE)) ? pspi->pKerberosInfo->X : Y)
   switch (m_nID) {
      // L"Maximum passage age", L"Days"
      case IDS_MAX_PAS_AGE:
         return PROFILE_DEFAULT(MaximumPasswordAge,42);

      // L"Minimum passage age", L"Days"
      case IDS_MIN_PAS_AGE:
         return PROFILE_DEFAULT(MinimumPasswordAge,0);

      // L"Minimum passage length", L"Characters"
      case IDS_MIN_PAS_LEN:
         return PROFILE_DEFAULT(MinimumPasswordLength,0);

      // L"Password history size", L"Passwords"
      case IDS_PAS_UNIQUENESS:
         return PROFILE_DEFAULT(PasswordHistorySize,0);

      // L"Password complexity", L""
      case IDS_PAS_COMPLEX:
         return PROFILE_DEFAULT(PasswordComplexity,0);

      // L"Clear Text Password", L""
      case IDS_CLEAR_PASSWORD:
         return PROFILE_DEFAULT(ClearTextPassword,0);

      // L"Require logon to change password", L""
      case IDS_REQ_LOGON:
         return PROFILE_DEFAULT(RequireLogonToChangePassword,0);

      case IDS_KERBEROS_MAX_SERVICE:
            return PROFILE_KERB_DEFAULT(MaxServiceAge,600);

      case IDS_KERBEROS_MAX_CLOCK:
            return PROFILE_KERB_DEFAULT(MaxClockSkew,5);

      case IDS_KERBEROS_RENEWAL:
            return PROFILE_KERB_DEFAULT(MaxRenewAge,10);

      case IDS_KERBEROS_MAX_AGE:
            return PROFILE_KERB_DEFAULT(MaxTicketAge,7);

      case IDS_KERBEROS_VALIDATE_CLIENT:
            return PROFILE_KERB_DEFAULT(TicketValidateClient,1);

      // L"Account lockout count", L"Attempts"
      case IDS_LOCK_COUNT:
         return PROFILE_DEFAULT(LockoutBadCount,0);

      // L"Reset lockout count after", L"Minutes"
      case IDS_LOCK_RESET_COUNT:
         return PROFILE_DEFAULT(ResetLockoutCount,30);

      // L"Lockout duration", L"Minutes"
      case IDS_LOCK_DURATION:
         return PROFILE_DEFAULT(LockoutDuration,30);

      // L"Event Auditing Mode",
      case IDS_EVENT_ON:
         return 0;

      // L"Audit system events"
      case IDS_SYSTEM_EVENT:
         return PROFILE_DEFAULT(AuditSystemEvents,0);

      // L"Audit logon events"
      case IDS_LOGON_EVENT:
         return PROFILE_DEFAULT(AuditLogonEvents,0);

      // L"Audit Object Access"
      case IDS_OBJECT_ACCESS:
         return PROFILE_DEFAULT(AuditObjectAccess,0);

      // L"Audit Privilege Use"
      case IDS_PRIVILEGE_USE:
         return PROFILE_DEFAULT(AuditPrivilegeUse,0);

      // L"Audit policy change"
      case IDS_POLICY_CHANGE:
         return PROFILE_DEFAULT(AuditPolicyChange,0);

      // L"Audit Account Manage"
      case IDS_ACCOUNT_MANAGE:
         return PROFILE_DEFAULT(AuditAccountManage,0);

      // L"Audit process tracking"
      case IDS_PROCESS_TRACK:
         return PROFILE_DEFAULT(AuditProcessTracking,0);
      // L"Audit directory service access"
      case IDS_DIRECTORY_ACCESS:
         return PROFILE_DEFAULT(AuditDSAccess,0);

      // L"Audit Account Logon"
      case IDS_ACCOUNT_LOGON:
         return PROFILE_DEFAULT(AuditAccountLogon,0);

         // L"Network access: Allow anonymous SID/Name translation"
   case IDS_LSA_ANON_LOOKUP:
       return PROFILE_DEFAULT(LSAAnonymousNameLookup,0);

      // L"Force logoff when logon hour expire", L""
      case IDS_FORCE_LOGOFF:
         return PROFILE_DEFAULT(ForceLogoffWhenHourExpire,0);

      // L"Accounts: Administrator account status"
      case IDS_ENABLE_ADMIN:
         return PROFILE_DEFAULT(EnableAdminAccount,1);

      // L"Accounts: Guest account status"
      case IDS_ENABLE_GUEST:
         return PROFILE_DEFAULT(EnableGuestAccount,0);

      // L"... Log Maximum Size", L"KBytes"
      case IDS_SYS_LOG_MAX:
         return PROFILE_DEFAULT(MaximumLogSize[0],512);
      case IDS_SEC_LOG_MAX:
         return PROFILE_DEFAULT(MaximumLogSize[0],512);
      case IDS_APP_LOG_MAX:
         return PROFILE_DEFAULT(MaximumLogSize[0],512);
         return 512;

      // L"... Log Retention Method",
      case IDS_SYS_LOG_RET:
         return PROFILE_DEFAULT(AuditLogRetentionPeriod[0],1);
      case IDS_SEC_LOG_RET:
         return PROFILE_DEFAULT(AuditLogRetentionPeriod[0],1);
      case IDS_APP_LOG_RET:
         return PROFILE_DEFAULT(AuditLogRetentionPeriod[0],1);
         return 1;

      // L"... Log Retention days", "days"
      case IDS_SYS_LOG_DAYS:
         return PROFILE_DEFAULT(RetentionDays[0],7);
      case IDS_SEC_LOG_DAYS:
         return PROFILE_DEFAULT(RetentionDays[0],7);
      case IDS_APP_LOG_DAYS:
         return PROFILE_DEFAULT(RetentionDays[0],7);

      // L"RestrictGuestAccess", L""
      case IDS_SYS_LOG_GUEST:
         return PROFILE_DEFAULT(RestrictGuestAccess[0],1);
      case IDS_SEC_LOG_GUEST:
         return PROFILE_DEFAULT(RestrictGuestAccess[0],1);
      case IDS_APP_LOG_GUEST:
         return PROFILE_DEFAULT(RestrictGuestAccess[0],1);
   }

   return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
}


//+--------------------------------------------------------------------------
//
//  Function:  GetRegDefault()
//
//  Synopsis:  Find the default values for undefined policies
//
//  Returns:   The value to assign as the default value for the policy.
//
//             SCE_NO_VALUE is returned on error.
//
//+--------------------------------------------------------------------------
DWORD_PTR
CResult::GetRegDefault() {
   SCE_PROFILE_INFO *pspi = NULL;
   LPTSTR szValue = NULL;
   DWORD_PTR dwValue = SCE_NO_VALUE;

   if (!m_pSnapin) {
      return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
   }

   PEDITTEMPLATE pet = m_pSnapin->GetTemplate(GT_DEFAULT_TEMPLATE);
   if (!pet || !pet->pTemplate) {
      return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
   }

   if (pet && pet->pTemplate) {
      pspi = pet->pTemplate;
   }

   PSCE_REGISTRY_VALUE_INFO regArrayThis = (PSCE_REGISTRY_VALUE_INFO)m_dwBase;
   if (pspi != NULL) 
   {
      PSCE_REGISTRY_VALUE_INFO regArray = pspi->aRegValues;
      DWORD nCount = pspi->RegValueCount;

      for(DWORD i=0;i<nCount;i++) 
      {
         if (0 == lstrcmpi(regArray[i].FullValueName,
                           regArrayThis->FullValueName)) 
         {
            szValue = regArray[i].Value;
            break;
         }
      }
   }

   switch (regArrayThis->ValueType) 
   {
      case SCE_REG_DISPLAY_ENABLE:
         if (szValue) 
         {
            dwValue =  (DWORD)StrToLong(szValue); //Raid #413311, 6/11/2001, Yanggao
         }
         if (dwValue == SCE_NO_VALUE) 
         {
            // default: enable
            dwValue = 1;
         }
         break;
      case SCE_REG_DISPLAY_NUMBER:
         if (szValue) {
            dwValue =  (DWORD)StrToLong(szValue); //Raid #413311, 6/11/2001, Yanggao
         }
         if (dwValue == SCE_NO_VALUE) {
            dwValue = 1;
         }
         break;
      case SCE_REG_DISPLAY_STRING:
         if( szValue )
         {
            dwValue = (DWORD_PTR)szValue;
         }
         break;
      case SCE_REG_DISPLAY_CHOICE:
         if (szValue) 
         {
            dwValue =  (DWORD)StrToLong(szValue); //Raid #413311, 6/11/2001, Yanggao
         }
         if (dwValue == SCE_NO_VALUE) 
         {
            dwValue = 0;
         }
         break;
      case REG_MULTI_SZ: //Raid #413311, 6/11/2001, Yanggao
         if (szValue) 
         {
            dwValue =  (DWORD_PTR)szValue;  //Raid #367756, 4/13/2001
         }
         break;
      default:
         if (szValue) 
         {
            dwValue =  (DWORD)StrToLong(szValue); //Raid #413311, 6/11/2001, Yanggao
         }
         //Some security option in group policy is not defined. Their property pages should not display
         //any item checked. It confuses user and creates inconsistence.
         break;
   }

   return dwValue;
}
//+--------------------------------------------------------------------------
//
//  Function:  GetSnapin()
//
//  Synopsis:  Find current snapin of result item.
//
//  Returns:   Pointer of snapin
//
//+--------------------------------------------------------------------------
CSnapin* CResult::GetSnapin()
{
   return m_pSnapin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\copyutil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       copyutil.cpp
//
//  Contents:   Utility routines for copying SCE sections to the clipboard
//
//  HISTORY:    10-Nov-97          robcap           Created
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "snapmgr.h"
#include "wrapper.h"
#include "util.h"
#include <secedit.h>


//+--------------------------------------------------------------------------
//
//  Method:     GetFolderCopyPasteInfo
//
//  Synopsis:   Finds the SCE area and clipboard format that correspond
//              to the folder type given in [Folder]
//
//  Arguments:  [Folder] - the folder type to find the area and cf for
//              [*Area]  - output only
//              [*cf]    - output only
//
//  Returns:    *[Area]  - the SCE area that corresponds to [Folder]
//              *[cf]    - the clipboard format that corresponds to [Folder]
//
//
//  History:    10-Nov-1997      RobCap   created
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::GetFolderCopyPasteInfo(FOLDER_TYPES Folder,     // In
                                           AREA_INFORMATION *Area,  // Out
                                           UINT *cf) {              // Out

   switch (Folder) {
      case POLICY_ACCOUNT:
      case POLICY_PASSWORD:
      case POLICY_KERBEROS:
      case POLICY_LOCKOUT:
      case POLICY_AUDIT:
         *Area = AREA_SECURITY_POLICY;
         *cf = cfSceAccountArea;
         break;

      case POLICY_LOCAL:
      case POLICY_OTHER:
      case AREA_PRIVILEGE:
         *Area = AREA_SECURITY_POLICY | AREA_PRIVILEGES;
         *cf = cfSceLocalArea;
         break;

      case POLICY_EVENTLOG:
      case POLICY_LOG:
         *Area = AREA_SECURITY_POLICY;
         *cf = cfSceEventLogArea;
         break;

      case AREA_GROUPS:
         *Area = AREA_GROUP_MEMBERSHIP;
         *cf = cfSceGroupsArea;
         break;
      case AREA_SERVICE:
         *Area = AREA_SYSTEM_SERVICE;
         *cf = cfSceServiceArea;
         break;
      case AREA_REGISTRY:
         *Area = AREA_REGISTRY_SECURITY;
         *cf = cfSceRegistryArea;
         break;
      case AREA_FILESTORE:
         *Area = AREA_FILE_SECURITY;
         *cf = cfSceFileArea;
         break;
      default:
         return FALSE;
   }

   return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Method:     OnCopyArea
//
//  Synopsis:   Copy a folder to the clipboard
//
//  Arguments:  [szTemplate] - the name of the template file to copy from
//              [ft]         - the type of folder to copy
//
//  Returns:    HRESULT
//
//  History:    10-Nov-1997      RobCap   created
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnCopyArea(LPCTSTR szTemplate,FOLDER_TYPES ft) {
   HRESULT hr;
   SCESTATUS status;
   PEDITTEMPLATE pTemp;
   CString strPath,strFile;
   LPTSTR szPath,szFile;

   DWORD dw;
   CFile pFile;
   HANDLE hBuf;
   PVOID pBuf;
   PSCE_ERROR_LOG_INFO ErrLog;
   AREA_INFORMATION Area;
   UINT cf;

   hr = S_OK;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CWaitCursor wc;
   //
   // Get a temporary directory path in strPath
   // If our buffer isn't large enough then keep reallocating until it is
   //
   dw = MAX_PATH;
   do {
      szPath = strPath.GetBuffer(dw);
      dw = GetTempPath(MAX_PATH,szPath);
      strPath.ReleaseBuffer();
   } while (dw > (DWORD)strPath.GetLength() );


   //
   // Can't get a path to the temporary directory
   //
   if (!dw) {
      return E_FAIL;
   }

   //
   // Get a temporary file in that directory
   //
   szFile = strFile.GetBuffer(dw+MAX_PATH);
   if (!GetTempFileName(szPath,L"SCE",0,szFile)) {
      strFile.ReleaseBuffer();
      return E_FAIL;
   }

   strFile.ReleaseBuffer();

   //
   // Get the template that we're trying to copy
   //
   pTemp = GetTemplate(szTemplate);
   if (!pTemp) {
      return E_FAIL;
   }

   if (!GetFolderCopyPasteInfo(ft,&Area,&cf)) {
      return E_FAIL;
   }

   status = SceWriteSecurityProfileInfo(szFile,
                                        Area,
                                        pTemp->pTemplate,
                                        NULL);
   if (SCESTATUS_SUCCESS == status) {

      if (!pFile.Open(szFile,CFile::modeRead)) {
         return E_FAIL;
      }
      dw = pFile.GetLength();
      hBuf = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE,dw);
      if (!hBuf) {
         return E_OUTOFMEMORY;
      }
      pBuf = GlobalLock(hBuf);
      if (!pBuf) {
          GlobalFree(hBuf);
          return E_FAIL;
      }
      pFile.Read(pBuf,dw);
      GlobalUnlock(pBuf);

      if (OpenClipboard(NULL)) {
         EmptyClipboard();
         //
         // Add the data to the clipboard in CF_TEXT format, so it
         // can be pasted to Notepad
         //
         SetClipboardData(CF_TEXT,hBuf);
         //
         // Add the data to the clipboard in our custom format, so
         // we can read it back in on paste
         //
         SetClipboardData(cf,hBuf);

         CloseClipboard();
      } else {
         hr = E_FAIL;
      }

      pFile.Close();
      pFile.Remove(szFile);

      GlobalFree(hBuf);

   } else {
      return E_FAIL;
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnPasteArea
//
//  Synopsis:   Paste an area from the clipboard
//
//  Arguments:  [szTemplate] - the name of the template file to paste from
//              [ft]         - the type of folder to paste
//
//  Returns:    HRESULT
//
//  History:    10-Nov-1997      RobCap   created
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnPasteArea(LPCTSTR szTemplate,FOLDER_TYPES ft) {
   SCESTATUS status;
   PEDITTEMPLATE pTemp;
   PSCE_PROFILE_INFO spi;
   CString strPath;
   CString strFile;
   LPTSTR szPath,szFile;
   AREA_INFORMATION Area;
   UINT cf;
   int k;

   DWORD dw;
   CFile *pFile;
   CFile pFileOut;

   PVOID pBuf;
   PVOID pHandle;

   HRESULT hr = S_OK;

   COleDataObject DataObject;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CWaitCursor wc;

   //
   // Find the SCE Area and clipboard format for ft
   //
   if (!GetFolderCopyPasteInfo(ft,&Area,&cf)) {
      return E_FAIL;
   }

   //
   // Get a temporary directory path in strPath
   // If our buffer isn't large enough then keep reallocating until it is
   //
   dw = MAX_PATH;
   do {
      szPath = strPath.GetBuffer(dw);
      dw = GetTempPath(MAX_PATH,szPath);
      strPath.ReleaseBuffer();
   } while (dw > (DWORD)strPath.GetLength() );


   //
   // Can't get a path to the temporary directory
   //
   if (!dw) {
      return E_FAIL;
   }

   //
   // Get a temporary file in that directory
   //
   szFile = strFile.GetBuffer(dw+MAX_PATH);
   if (!GetTempFileName(szPath,L"SCE",0,szFile)) {
       strFile.ReleaseBuffer();
       return E_FAIL;
   }
   strFile.ReleaseBuffer();

   //
   // Get the template we're pasting into
   //
   pTemp = GetTemplate(szTemplate);
   if (!pTemp) {
      return E_FAIL;
   }

   //
   // Attach the data object to the clipboard; we don't need
   // to worry about releasing it since that will be done in
   // DataObject's destructor
   //
   if (!DataObject.AttachClipboard()) {
      return E_FAIL;
   }

   if (!DataObject.IsDataAvailable((CLIPFORMAT)cf)) {
      return E_FAIL;
   }

   pFile = DataObject.GetFileData((CLIPFORMAT)cf);

   if (pFile) {
      //
      // Write the data from the clipboard to a temporary file
      //
      if ( pFileOut.Open(szFile,CFile::modeWrite) ) {
         dw = pFile->GetLength();
         pBuf = new BYTE [dw];
         if (NULL != pBuf) {
            pFile->Read(pBuf,dw);
            pFileOut.Write(pBuf,dw);
         } else {
            hr = E_FAIL;
         }
         pFileOut.Close();
      }
      pFile->Close();
   } else {
      return E_FAIL;
   }

   if (S_OK == hr) {
      //
      // Have the engine open the temporary file as a template
      //
      if (EngineOpenProfile(szFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
         delete pBuf;
         return E_FAIL;
      }


      //
      // Load the temporary template area into our scratch SCE_PROFILE_INFO
      //

      //
      // SceGetSecurityProfileInfo will allocate an SCE_PROFILE_INFO struct
      // if a pointer to a NULL one is passed in
      //
      spi = NULL;
      status = SceGetSecurityProfileInfo(pHandle,
                                         SCE_ENGINE_SCP,
                                         Area,
                                         &spi,
                                         NULL);
      SceCloseProfile(&pHandle);
      pHandle = NULL;

      if (SCESTATUS_SUCCESS == status) {

         PSCE_REGISTRY_VALUE_INFO    pRegValues;
         //
         // The load succeeded, so free the appropriate old area and copy the
         // new version from the scratch SCE_PROFILE_INFO
         //
         switch(ft) {
         case POLICY_ACCOUNT:
            pTemp->pTemplate->MinimumPasswordAge = spi->MinimumPasswordAge;
            pTemp->pTemplate->MaximumPasswordAge = spi->MaximumPasswordAge;
            pTemp->pTemplate->PasswordComplexity = spi->PasswordComplexity;
            pTemp->pTemplate->ClearTextPassword  = spi->ClearTextPassword;
            pTemp->pTemplate->PasswordHistorySize = spi->PasswordHistorySize;
            pTemp->pTemplate->RequireLogonToChangePassword = spi->RequireLogonToChangePassword;
            pTemp->pTemplate->MinimumPasswordLength = spi->MinimumPasswordLength;
            pTemp->pTemplate->LockoutBadCount = spi->LockoutBadCount;
            pTemp->pTemplate->ResetLockoutCount = spi->ResetLockoutCount;
            pTemp->pTemplate->LockoutDuration = spi->LockoutDuration;
            if (spi->pKerberosInfo) {
               if (!pTemp->pTemplate->pKerberosInfo) {
                  pTemp->pTemplate->pKerberosInfo = (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR,sizeof(SCE_KERBEROS_TICKET_INFO));
               }
               if (pTemp->pTemplate->pKerberosInfo) {
                   pTemp->pTemplate->pKerberosInfo->MaxTicketAge = spi->pKerberosInfo->MaxTicketAge;
                   pTemp->pTemplate->pKerberosInfo->MaxServiceAge = spi->pKerberosInfo->MaxServiceAge;
                   pTemp->pTemplate->pKerberosInfo->MaxClockSkew = spi->pKerberosInfo->MaxClockSkew;
                   pTemp->pTemplate->pKerberosInfo->MaxRenewAge = spi->pKerberosInfo->MaxRenewAge;
                   pTemp->pTemplate->pKerberosInfo->TicketValidateClient = spi->pKerberosInfo->TicketValidateClient;
               }
            } else if (pTemp->pTemplate->pKerberosInfo) {
               LocalFree(pTemp->pTemplate->pKerberosInfo);
               pTemp->pTemplate->pKerberosInfo = NULL;
            }
            break;

         case POLICY_LOCAL:
            pTemp->pTemplate->AuditAccountManage = spi->AuditAccountManage;
            pTemp->pTemplate->AuditLogonEvents = spi->AuditLogonEvents;
            pTemp->pTemplate->AuditObjectAccess = spi->AuditObjectAccess;
            pTemp->pTemplate->AuditPolicyChange = spi->AuditPolicyChange;
            pTemp->pTemplate->AuditPrivilegeUse = spi->AuditPrivilegeUse;
            pTemp->pTemplate->AuditProcessTracking = spi->AuditProcessTracking;
            pTemp->pTemplate->AuditSystemEvents = spi->AuditSystemEvents;
            pTemp->pTemplate->AuditDSAccess = spi->AuditDSAccess;
            pTemp->pTemplate->AuditAccountLogon = spi->AuditAccountLogon;
            pTemp->pTemplate->LSAAnonymousNameLookup = spi->LSAAnonymousNameLookup;


            pTemp->pTemplate->ForceLogoffWhenHourExpire = spi->ForceLogoffWhenHourExpire;
            pTemp->pTemplate->EnableAdminAccount = spi->EnableAdminAccount;
            pTemp->pTemplate->EnableGuestAccount = spi->EnableGuestAccount;
            pTemp->pTemplate->NewAdministratorName = spi->NewAdministratorName;
            pTemp->pTemplate->NewGuestName = spi->NewGuestName;
            spi->NewAdministratorName = NULL;
            spi->NewGuestName = NULL;

            //
            // copy reg value section too
            //
            dw = pTemp->pTemplate->RegValueCount;
            pRegValues = pTemp->pTemplate->aRegValues;

            pTemp->pTemplate->RegValueCount = spi->RegValueCount;
            pTemp->pTemplate->aRegValues = spi->aRegValues;

            spi->RegValueCount = dw;
            spi->aRegValues = pRegValues;

            SceRegEnumAllValues(
                &(pTemp->pTemplate->RegValueCount),
                &(pTemp->pTemplate->aRegValues)
                );
            //
            // copy user rights
            //
            SceFreeMemory(pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo,SCE_STRUCT_PRIVILEGE);
            pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo = spi->OtherInfo.scp.u.pPrivilegeAssignedTo;
            spi->OtherInfo.scp.u.pPrivilegeAssignedTo = NULL;
            break;

         case POLICY_PASSWORD:
            pTemp->pTemplate->MinimumPasswordAge = spi->MinimumPasswordAge;
            pTemp->pTemplate->MaximumPasswordAge = spi->MaximumPasswordAge;
            pTemp->pTemplate->PasswordComplexity = spi->PasswordComplexity;
            pTemp->pTemplate->ClearTextPassword  = spi->ClearTextPassword;

            pTemp->pTemplate->PasswordHistorySize = spi->PasswordHistorySize;
            pTemp->pTemplate->RequireLogonToChangePassword = spi->RequireLogonToChangePassword;
            pTemp->pTemplate->MinimumPasswordLength = spi->MinimumPasswordLength;
            break;

         case POLICY_LOCKOUT:
            pTemp->pTemplate->LockoutBadCount = spi->LockoutBadCount;
            pTemp->pTemplate->ResetLockoutCount = spi->ResetLockoutCount;
            pTemp->pTemplate->LockoutDuration = spi->LockoutDuration;
            break;

         case POLICY_KERBEROS:
             pTemp->pTemplate->pKerberosInfo->MaxTicketAge = spi->pKerberosInfo->MaxTicketAge;
             pTemp->pTemplate->pKerberosInfo->MaxServiceAge = spi->pKerberosInfo->MaxServiceAge;
             pTemp->pTemplate->pKerberosInfo->MaxClockSkew = spi->pKerberosInfo->MaxClockSkew;
             pTemp->pTemplate->pKerberosInfo->MaxRenewAge = spi->pKerberosInfo->MaxRenewAge;
             pTemp->pTemplate->pKerberosInfo->TicketValidateClient = spi->pKerberosInfo->TicketValidateClient;
            break;

         case POLICY_AUDIT:
            pTemp->pTemplate->AuditAccountManage = spi->AuditAccountManage;
            pTemp->pTemplate->AuditLogonEvents = spi->AuditLogonEvents;
            pTemp->pTemplate->AuditObjectAccess = spi->AuditObjectAccess;
            pTemp->pTemplate->AuditPolicyChange = spi->AuditPolicyChange;
            pTemp->pTemplate->AuditPrivilegeUse = spi->AuditPrivilegeUse;
            pTemp->pTemplate->AuditProcessTracking = spi->AuditProcessTracking;
            pTemp->pTemplate->AuditSystemEvents = spi->AuditSystemEvents;
            pTemp->pTemplate->AuditDSAccess = spi->AuditDSAccess;
            pTemp->pTemplate->AuditAccountLogon = spi->AuditAccountLogon;
            break;

         case POLICY_OTHER:
            pTemp->pTemplate->ForceLogoffWhenHourExpire = spi->ForceLogoffWhenHourExpire;
            pTemp->pTemplate->EnableGuestAccount = spi->EnableGuestAccount;
            pTemp->pTemplate->EnableAdminAccount = spi->EnableAdminAccount;
            pTemp->pTemplate->LSAAnonymousNameLookup = spi->LSAAnonymousNameLookup;
            pTemp->pTemplate->NewAdministratorName = spi->NewAdministratorName;
            pTemp->pTemplate->NewGuestName = spi->NewGuestName;
            spi->NewAdministratorName = NULL;
            spi->NewGuestName = NULL;

            //
            // copy reg value section too
            //
            dw = pTemp->pTemplate->RegValueCount;
            pRegValues = pTemp->pTemplate->aRegValues;

            pTemp->pTemplate->RegValueCount = spi->RegValueCount;
            pTemp->pTemplate->aRegValues = spi->aRegValues;

            spi->RegValueCount = dw;
            spi->aRegValues = pRegValues;

            SceRegEnumAllValues(
                &(pTemp->pTemplate->RegValueCount),
                &(pTemp->pTemplate->aRegValues)
                );

            break;

         case AREA_PRIVILEGE:
            SceFreeMemory(pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo,SCE_STRUCT_PRIVILEGE);
            pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo = spi->OtherInfo.scp.u.pPrivilegeAssignedTo;
            spi->OtherInfo.scp.u.pPrivilegeAssignedTo = NULL;
            break;

         case POLICY_EVENTLOG:
         case POLICY_LOG:
            for(k=0;k<3;k++) {
               pTemp->pTemplate->MaximumLogSize[k] = spi->MaximumLogSize[k];
               pTemp->pTemplate->AuditLogRetentionPeriod[k] = spi->AuditLogRetentionPeriod[k];
               pTemp->pTemplate->RetentionDays[k] = spi->RetentionDays[k];
               pTemp->pTemplate->RestrictGuestAccess[k] = spi->RestrictGuestAccess[k];
            }
            break;

         case AREA_GROUPS:
            SceFreeMemory(pTemp->pTemplate->pGroupMembership,SCE_STRUCT_GROUP);
            pTemp->pTemplate->pGroupMembership = spi->pGroupMembership;
            spi->pGroupMembership = NULL;
            break;

         case AREA_SERVICE:
            SceFreeMemory(pTemp->pTemplate->pServices,SCE_STRUCT_SERVICES);
            pTemp->pTemplate->pServices = spi->pServices;
            spi->pServices = NULL;
            break;
         case AREA_REGISTRY:
            SceFreeMemory(pTemp->pTemplate->pRegistryKeys.pAllNodes,SCE_STRUCT_OBJECT_ARRAY);
            pTemp->pTemplate->pRegistryKeys = spi->pRegistryKeys;
            spi->pRegistryKeys.pAllNodes = NULL;
            break;
         case AREA_FILESTORE:
            SceFreeMemory(pTemp->pTemplate->pFiles.pAllNodes,SCE_STRUCT_OBJECT_ARRAY);
            pTemp->pTemplate->pFiles = spi->pFiles;
            spi->pFiles.pAllNodes = NULL;
            break;
         default:
            break;
         }
      }
      SceFreeProfileMemory(spi);
      pTemp->SetDirty(Area);

      RefreshAllFolders();
   } else {
      //
      // Don't do anything special, just be sure to clean up below....
      //
   }


   //
   // Delete the temporary file
   //
   pFileOut.Remove(szFile);
   if (pBuf) {
      delete pBuf;
   }
   if (pFile) {
      delete pFile;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cookie.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _SERVICE_H
#define _SERVICE_H

#include "hidwnd.h"
#include "precdisp.h"

// Forward declarations
class CSnapin;
class CResult;

#define RESULT_GROUP_INFO_BASE            1
#define RESULT_GROUP_INFO_SETTING         2
#define RESULT_GROUP_INFO_STATUS          4

// Internal structure used for cookies
struct FOLDER_DATA {
   UINT        ResID;
   UINT        DescID;

   FOLDER_TYPES    type;
};

typedef CList<CResult *, CResult *> CResultItemList;
class CFolder {
   //    friend class CSnapin;
   //    friend class CComponentDataImpl;
public:
   // UNINITIALIZED is an invalid memory address and is a good cookie initializer
   CFolder()
   {
      m_cookie = UNINITIALIZED;
      m_enumed = FALSE;
      m_pScopeItem = NULL;
      m_type = NONE;
      m_pszName = NULL;
      m_pszDesc = NULL;
      m_infName = NULL;
      m_dwMode = 0;
      m_ModeBits = 0;
      m_pData = NULL;
      m_iRefCount = 0;
      m_dwState = state_Unknown;
      m_ViewUpdate = FALSE;
     SetState(state_Unknown, state_Unknown);
   };

   virtual ~CFolder();

   // Interface
public:
   BOOL IsEnumerated() 
   { 
      return  m_enumed;
   };
   void Set(BOOL state) 
   { 
      m_enumed = state;
   };
   void SetCookie(MMC_COOKIE cookie) 
   { 
      m_cookie = cookie;
   }
   BOOL SetDesc(LPCTSTR szDesc);

   FOLDER_TYPES GetType() 
   { 
      ASSERT(m_type != NONE); 
      return m_type;
   };
   LPOLESTR GetName() 
   { 
      return m_pszName;
   };
   LPOLESTR GetDesc() 
   { 
      return m_pszDesc;
   };
   LPOLESTR GetInfFile() 
   { 
      return m_infName;
   }

   DWORD GetDisplayName(CString &str, int iCol );

   void SetInfFile(LPOLESTR sz) 
   { 
      if (!m_infName) 
      { 
         m_infName = sz; 
      } 
   }
   BOOL operator == (const CFolder& rhs) const 
   { 
      return rhs.m_cookie == m_cookie;
   };
   BOOL operator == (long cookie) const 
   { 
      return cookie == m_cookie;
   };
   LPSCOPEDATAITEM GetScopeItem() 
   { 
      return m_pScopeItem;
   }
   BOOL SetMode(DWORD dwMode);
   DWORD GetMode() 
   { 
      return m_dwMode;
   }
   DWORD GetModeBits() 
   { 
      return m_ModeBits;
   }
   DWORD AddModeBits(DWORD dwMB) 
   { 
		return m_ModeBits |= dwMB; 
   }
   PVOID GetData() 
   { 
      return m_pData; 
   }
   void SetData(PVOID pData) 
   { 
      m_pData = pData; 
   }

   // Implementation
   //private:
   HRESULT Create(LPCTSTR szName, LPCTSTR szDesc, LPCTSTR infName, int nImage,
               int nOpenImage, FOLDER_TYPES type, BOOL bHasChildren, DWORD dwMode,
               PVOID pData);

   DWORD GetState()
   { 
      return m_dwState; 
   };

   void SetState(
      DWORD dwState,
      DWORD dwMask = 0xFFFFFFFF)
   { 
      m_dwState = (dwState | (m_dwState & dwMask)); 
   };
public:
   //
   // Functions for objects.
   //
   BOOL SetDesc( DWORD dwStatus, DWORD dwNumChildren );
   BOOL GetObjectInfo( DWORD *pdwStatus, DWORD *pdwNumChildren );


public:
   //
   // Result item member functions.
   //
    DWORD GetResultItemHandle(                // Gets this folder result item handle
        HANDLE *handle);
    DWORD ReleaseResultItemHandle(            // Releases memory associated with the handle.
        HANDLE &handle);

    DWORD GetResultItem(                      // Returns the result item with the given permission
        HANDLE handle,
        POSITION &pos,
        CResult **pResult);

    DWORD AddResultItem(                      // Adds a Result item to the list
        HANDLE handle,
        CResult *pItem);

   DWORD RemoveResultItem(                   // Removes a Result item
      HANDLE handle,
      CResult *pItem);

   int GetResultListCount()                // Returns the number of result items in the list
   { 
      return (int)m_resultItemList.GetCount(); 
   };

   POSITION GetResultItemPosition(              // Returns the POSITION of the result item.
        HANDLE handle,
        CResult *pResult);

    void RemoveAllResultItems();

public:
	BOOL GetViewUpdate() const;
	void SetViewUpdate(BOOL fUpdate);
   //
   // flags
   enum CFolderEnums {
      state_InvalidTemplate = 0x0001,
      state_Unknown         = 0x0002,
      state_beingRemoved    = 0x0004
   };
   // Attributes
protected:
   int m_iRefCount;
   CResultItemList m_resultItemList;

private:
   LPSCOPEDATAITEM m_pScopeItem;
   MMC_COOKIE      m_cookie;
   BOOL            m_enumed;
   FOLDER_TYPES    m_type;
   LPOLESTR        m_pszName;
   LPOLESTR        m_pszDesc;
   LPOLESTR        m_infName;
   DWORD           m_dwMode;
   DWORD           m_ModeBits;
   PVOID           m_pData;
   BOOL            m_ViewUpdate;
   DWORD       m_dwState;
};

typedef struct _tag_SCECOLUMNINFO
{
    LPCTSTR pszText;
    BOOL   bDelete;

}SCECOLUMNINFO, *PSCECOLUMNINFO;


#define RRFCREATE_COPY      1
#define RRFCREATE_DELETE    2
#define RRFCREATE_NORMAL    3


// Linked result items.  Must be at least 4 for Analysis Groups at present
   #define MAX_ITEM_ID_INDEX 4
   #define NUM_GROUP_SIBLINGS 2
class CResult
{
   //    friend class CSnapin;
   //    friend class CComponentDataImpl;

public:
   // UNINITIALIZED is an invalid memory address and is a good cookie initializer
   CResult()
   {
      m_szAttr = NULL;
      m_dwBase = 0;
      m_dwSetting = 0;
      m_type = ITEM_OTHER;
      m_status = SCE_STATUS_NOT_CONFIGURED;
      m_cookie = UNINITIALIZED;
      m_szUnits = NULL;
      m_nID = NULL;
      m_profBase = NULL;
      /*m_pDataObj = NULL;*/
      m_pNotify = NULL;
      m_pRegChoices = NULL;
      m_pRegFlags = NULL;
      m_pvecPrecedenceDisplays = NULL;
      m_iRefCount = 1;

      for (int i=0;i<NUM_GROUP_SIBLINGS;i++) {
         m_siblingCookies[i] = 0;
      }
   };

   void Empty()
   {
      PREGCHOICE p = NULL;
      while(m_pRegChoices) 
      {
         p = m_pRegChoices->pNext;
         LocalFree(m_pRegChoices);
         m_pRegChoices = p;
      }
      PREGFLAGS f = NULL;
      while(m_pRegFlags) 
      {
         f = m_pRegFlags->pNext;
         LocalFree(m_pRegFlags);
         m_pRegFlags = f;
      }

      if ( m_szAttr )
      {
         delete [] m_szAttr;
         m_szAttr = NULL;
      }

      if (ITEM_GROUP != m_type) 
      {
         if( m_szUnits )
         {
            LocalFree(m_szUnits);
            m_szUnits = NULL;
         }
      }

      if (m_pvecPrecedenceDisplays) 
      {
         for(vector<PPRECEDENCEDISPLAY>::iterator i = m_pvecPrecedenceDisplays->begin();
                 i != m_pvecPrecedenceDisplays->end();
                 ++i ) 
         {
            delete *i;
         }
         delete m_pvecPrecedenceDisplays;
         m_pvecPrecedenceDisplays = NULL;
      }
   }

   int AddRef() 
   { 
      return ++m_iRefCount; 
   }
   int Release() 
   { 
      if (--m_iRefCount == 0)
      {
         delete this;
         return 0;
      }
      return m_iRefCount;
   };

   virtual ~CResult() 
   {
      Empty();
   };

   // Interface
public:
   void GetBaseNoUnit(LPTSTR& sz) { TranslateSettingToString(m_dwBase, NULL, m_type,&sz);};
   CSnapin* GetSnapin();
   DWORD_PTR GetProfileDefault();
   DWORD_PTR GetRegDefault();
   LPCTSTR GetAttrPretty();
   void Update(CSnapin *pSnapin, BOOL bEntirePane = FALSE);
   void SetRelativeCookies(MMC_COOKIE cookie1, MMC_COOKIE cookie2) { m_siblingCookies[0] = cookie1; m_siblingCookies[1] = cookie2;};
   MMC_COOKIE GetCookie() { return m_cookie;}
   RESULT_TYPES GetType() { return m_type;};
   LPTSTR GetAttr() { return m_szAttr;};
   LONG_PTR GetBase() { return m_dwBase;}
   LONG_PTR GetSetting() { return m_dwSetting;}
   void GetSetting(LPTSTR& sz) { TranslateSettingToString(m_dwSetting, m_szUnits, m_type,&sz);}
   void GetBase(LPTSTR& sz) { TranslateSettingToString(m_dwBase, m_szUnits, m_type,&sz);}
   BOOL operator == (LPTSTR attr) const { return lstrcmp(m_szAttr, attr) == 0;};
   void SetUnits(LPCTSTR sz);
   LPTSTR GetUnits() { return m_szUnits;}
   void SetBase(LONG_PTR base) { m_dwBase = base;}
   void SetSetting(LONG_PTR base) { m_dwSetting = base;}
   LONG_PTR GetID() { return m_nID;}
   void SetID(LONG_PTR nID) { m_nID = nID;}
   void SetStatus(int status) { m_status = status;}
   int GetStatus() { return m_status;}
   void SetRegChoices(PREGCHOICE RegChoices) { m_pRegChoices = RegChoices;}
   PREGCHOICE GetRegChoices() { return m_pRegChoices;}
   void SetRegFlags(PREGFLAGS RegFlags) { m_pRegFlags = RegFlags;}
   PREGFLAGS GetRegFlags() { return m_pRegFlags;}
   void SetBaseProfile(PEDITTEMPLATE prof) { m_profBase = prof;}
   PEDITTEMPLATE GetBaseProfile() { return m_profBase;}

   vector<PPRECEDENCEDISPLAY>* GetPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetPolicyPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetGroupPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetPrivilegePrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetFilePrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetRegistryPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetServicePrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetRegValuePrecedenceDisplays();

    DWORD
    GetDisplayName(
        CFolder *pFolder,
        CString &str,
        int iCol
        );

   // Implementation
   HRESULT Create(LPCTSTR szAttr, LONG_PTR lBase, LONG_PTR lSetting,
               RESULT_TYPES type, int status, MMC_COOKIE cookie,
               LPCTSTR szUnits, LONG_PTR nID,PEDITTEMPLATE pBase,
               LPDATAOBJECT pDataObj,LPNOTIFY pNotify,CSnapin *pSnapin);

    LPCTSTR GetSourceGPOString();
protected:
   void
   TranslateSettingToString(  LONG_PTR setting, LPCTSTR unit, RESULT_TYPES type,
                              LPTSTR *pTmpstr
                              );
   DWORD
   GetStatusErrorString( CString *pStr );


   // Attributes
private:
   //LPRESULTDATA m_pResultPane;
   DWORD m_dwArea;
   LPTSTR    m_szAttr;
   LONG_PTR m_dwBase;
   LONG_PTR m_dwSetting;
   LPTSTR m_szUnits;
   RESULT_TYPES m_type;
   int         m_status;
   MMC_COOKIE  m_cookie;
   MMC_COOKIE m_siblingCookies[NUM_GROUP_SIBLINGS];
   LONG_PTR        m_nID;
   PEDITTEMPLATE m_profBase;
   LPNOTIFY m_pNotify;
   PREGCHOICE m_pRegChoices;
   PREGFLAGS m_pRegFlags;
   CSnapin *m_pSnapin;
   vector<PPRECEDENCEDISPLAY>* m_pvecPrecedenceDisplays;
   int m_iRefCount;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cret.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cret.cpp
//
//  Contents:   implementation of CConfigRet
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "CRet.h"
#include "util.h"
#include "DDWarn.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CConfigRet dialog


CConfigRet::CConfigRet(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CConfigRet)
    m_strAttrName = _T("");
    m_StartIds = IDS_AS_NEEDED;
    m_rabRetention = -1;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR) a190HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigRet::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigRet)
//    DDX_Text(pDX, IDC_ATTRIBUTE_NAME, m_strAttrName);
    DDX_Radio(pDX, IDC_RETENTION, m_rabRetention);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigRet, CAttribute)
    //{{AFX_MSG_MAP(CConfigRet)
    ON_BN_CLICKED(IDC_RETENTION, OnRetention)
    ON_BN_CLICKED(IDC_RADIO2, OnRadio2)
    ON_BN_CLICKED(IDC_RADIO3, OnRadio3)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigRet message handlers

BOOL CConfigRet::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;

      UpdateData(TRUE);


      if (!m_bConfigure) 
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_rabRetention) 
         {
         case RADIO_RETAIN_BY_DAYS:
            dw = SCE_RETAIN_BY_DAYS;
            break;
         case RADIO_RETAIN_AS_NEEDED:
            dw = SCE_RETAIN_AS_NEEDED;
            break;
         case RADIO_RETAIN_MANUALLY:
            dw = SCE_RETAIN_MANUALLY;
            break;
         }
      }

      CEditTemplate *petSave = m_pData->GetBaseProfile();

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw) == ERROR_MORE_DATA )
      {
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               SetProfileInfo(
                  pItem->pResult->GetID(),
                  pItem->dwSuggested,
                  pItem->pResult->GetBaseProfile()
                  );

               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      //
      // Update this items profile.
      //
      m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());


      m_pData->Update(m_pSnapin, false);
   }

   return CAttribute::OnApply();
}

BOOL CConfigRet::OnInitDialog()
{

   CAttribute::OnInitDialog();

   AddUserControl(IDC_RETENTION);
   AddUserControl(IDC_RADIO2);
   AddUserControl(IDC_RADIO3);
   EnableUserControls(m_bConfigure);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigRet::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   DDWarn.InitializeDependencies(m_pSnapin,pResult);

   m_StartIds = IDS_AS_NEEDED;

   LONG_PTR dw = pResult->GetBase();
   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      SetInitialValue((DWORD_PTR)dw);
   }
}

void CConfigRet::SetInitialValue(DWORD_PTR dw) 
{
   if (-1 == m_rabRetention &&
       SCE_NO_VALUE != dw) 
   {
      switch (dw) 
      {
         case SCE_RETAIN_BY_DAYS:
            m_rabRetention = RADIO_RETAIN_BY_DAYS;
            break;
         case SCE_RETAIN_AS_NEEDED:
            m_rabRetention = RADIO_RETAIN_AS_NEEDED;
            break;
         case SCE_RETAIN_MANUALLY:
            m_rabRetention = RADIO_RETAIN_MANUALLY;
            break;
      }
   }
}

void CConfigRet::OnRetention()
{
    SetModified(TRUE);
}

void CConfigRet::OnRadio2()
{
    SetModified(TRUE);
}

void CConfigRet::OnRadio3()
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cret.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cret.h
//
//  Contents:   definition of CConfigRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CRET_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
#define AFX_CRET_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "ddwarn.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigRet dialog

class CConfigRet : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pResult);
    virtual void SetInitialValue(DWORD_PTR dw);
    CConfigRet(UINT nTemplateID);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConfigRet)
	enum { IDD = IDD_CONFIG_RET };
    CString m_strAttrName;
	int		m_rabRetention;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigRet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRet)
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
	afx_msg void OnRetention();
	afx_msg void OnRadio2();
	afx_msg void OnRadio3();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CDlgDependencyWarn DDWarn;

public:
    UINT m_StartIds;
};

#define RADIO_RETAIN_BY_DAYS 0
#define RADIO_RETAIN_AS_NEEDED 1
#define RADIO_RETAIN_MANUALLY 2

#define SCE_RETAIN_BY_DAYS 1
#define SCE_RETAIN_AS_NEEDED 0
#define SCE_RETAIN_MANUALLY 2

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CRET_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cprivs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CConfigPrivs.h
//
//  Contents:   definition of CConfigRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CPRIVS_H__3C25C0A7_F23B_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CPRIVS_H__3C25C0A7_F23B_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "attr.h"
#include "cookie.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigPrivs dialog

class CConfigPrivs : public CAttribute {
// Construction
public:
	CConfigPrivs(UINT nTemplateID);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfigPrivs)
	enum { IDD = IDD_CONFIG_PRIVS };
	CListBox	m_lbGrant;
	CButton	m_btnRemove;
	CButton	m_btnAdd;
	CButton	m_btnTitle;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigPrivs)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigPrivs)
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	virtual BOOL OnApply();
    virtual void OnCancel();
	virtual BOOL OnInitDialog();
   afx_msg void OnConfigure();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   virtual PSCE_PRIVILEGE_ASSIGNMENT GetPrivData();
   virtual void SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa);

   virtual void SetInitialValue(DWORD_PTR dw);

    BOOL m_fDirty;
private:
    BOOL m_bOriginalConfigure;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CPRIVS_H__3C25C0A7_F23B_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cprivs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cprivs.cpp
//
//  Contents:   implementation of CConfigPrivs
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CPrivs.h"
#include "GetUser.h"
#include "AddGrp.h"

#include "snapmgr.h"

#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

BOOL
WseceditGetNameForSpecialSids(
    OUT PWSTR   *ppszEveryone OPTIONAL,
    OUT PWSTR   *ppszAuthUsers OPTIONAL,
    OUT PWSTR   *ppszAdmins OPTIONAL,
    OUT PWSTR   *ppszAdministrator OPTIONAL
    );

PSID
WseceditpGetAccountDomainSid(
    );

/////////////////////////////////////////////////////////////////////////////
// CConfigPrivs dialog
/////////////////////////////////////////////////////////////////////////////

CConfigPrivs::CConfigPrivs(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD),
m_fDirty(false)

{
    //{{AFX_DATA_INIT(CConfigPrivs)
        //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a106HelpIDs;
   m_uTemplateResID = IDD;
}


void CConfigPrivs::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_GRANTLIST, m_lbGrant);
    DDX_Control(pDX, IDC_REMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_ADD, m_btnAdd);
    DDX_Control(pDX, IDC_TITLE, m_btnTitle);
}


BEGIN_MESSAGE_MAP(CConfigPrivs, CAttribute)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigPrivs message handlers
/////////////////////////////////////////////////////////////////////////////

void CConfigPrivs::OnAdd()
{
   CSCEAddGroup gu(this);
   PSCE_NAME_LIST pName = 0;

   if( IDD_CONFIG_PRIVS == m_uTemplateResID ) //Raid #404989
   {
       gu.m_fCheckName = FALSE;
   }
   gu.m_dwFlags = SCE_SHOW_USERS | SCE_SHOW_LOCALGROUPS | SCE_SHOW_GLOBAL | SCE_SHOW_WELLKNOWN | SCE_SHOW_BUILTIN;
   gu.SetModeBits(m_pSnapin->GetModeBits());

   CString str;
   str.LoadString( IDS_ADD_USERGROUP );
   gu.m_sTitle.Format( IDS_ADD_TITLE, str );
   gu.m_sDescription.LoadString( IDS_ADD_USERGROUP );

   CThemeContextActivator activator;
   if (gu.DoModal() ==IDOK ) {
      pName = gu.GetUsers();
      UINT cstrMax = 0;  //Raid #271219
      LPWSTR pstrMax = NULL;
      UINT cstr = 0;
      while(pName)
      {
         if (LB_ERR == m_lbGrant.FindStringExact(-1,pName->Name))
         {
            if( LB_ERR == m_lbGrant.AddString(pName->Name) )
            {
                return;
            }
            m_fDirty = true;
            
            cstr = wcslen(pName->Name);
            if( cstr > cstrMax )
            {
              cstrMax = cstr;
              pstrMax = pName->Name;
            }
         }
         pName = pName->Next;
      }
      SetModified(TRUE);

      CDC* pCDC = m_lbGrant.GetDC();
      CSize strsize = pCDC->GetOutputTextExtent(pstrMax);
      m_lbGrant.ReleaseDC(pCDC);
      RECT winsize;
      m_lbGrant.GetWindowRect(&winsize); 
      if( strsize.cx > winsize.right-winsize.left )
      {
         m_lbGrant.SetHorizontalExtent(strsize.cx);
      }
   }
}

void CConfigPrivs::OnRemove()
{
    int cbItems;
   int *pnItems;

   cbItems = m_lbGrant.GetSelCount();
   pnItems = new int [cbItems];

   if ( pnItems ) {

       m_lbGrant.GetSelItems(cbItems,pnItems);

       if (cbItems) {
          m_fDirty = true;
                  SetModified(TRUE);
       }

       while(cbItems--) {
          m_lbGrant.DeleteString(pnItems[cbItems]);
       }

       delete[] pnItems;
   }
}

void CConfigPrivs::OnConfigure()
{
   CAttribute::OnConfigure();

   if (m_bConfigure == m_bOriginalConfigure) {
      m_fDirty = false;
   } else {
      m_fDirty = true;
   }
}

BOOL CConfigPrivs::OnApply()
{
   if ( !m_bReadOnly )
   {
      PSCE_PRIVILEGE_ASSIGNMENT ppa = 0;
      PSCE_NAME_LIST pNames = 0;
      CString strItem;
      int cItems = 0;
      int i = 0;

      UpdateData(TRUE);

      if(!m_bConfigure)
      {
          PSCE_PRIVILEGE_ASSIGNMENT pDelete;

          pDelete = GetPrivData();

          //
          // Remove the item from the template

          if( pDelete && pDelete != (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) )
          {
               m_pData->SetID((LONG_PTR)NULL);
               if (m_pData->GetSetting()) //Raid #390777
               {
                   m_pData->SetSetting((LONG_PTR)ULongToPtr(SCE_NO_VALUE));
               }
               m_pData->SetUnits((LPTSTR)pDelete->Name);
               m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
               m_pData->SetBase((LONG_PTR)ULongToPtr(SCE_NO_VALUE));

               m_pData->GetBaseProfile()->UpdatePrivilegeAssignedTo(
                           TRUE,        // Delete the profile.
                           &pDelete);
                           m_pData->GetBaseProfile()->SetDirty(AREA_PRIVILEGES);
               m_pData->Update(m_pSnapin);
          }
      }
      else if (m_fDirty)
      {

          ppa = GetPrivData();

          PWSTR    pszPrivName = m_pData->GetUnits();

          if ( ppa ) {
              //
              // to handle configured privilege case where Units is NULL
              //
              pszPrivName = ppa->Name;
          }

          int      cSpecialItems = m_lbGrant.GetCount();
          DWORD    dwIds = 0;
          CString  strDenyItem;

          //
          // simulate SCE engine behavior to special case certain privileges/rights
          //

          if ( pszPrivName )
           {
               if ( lstrcmpi(pszPrivName, SE_INTERACTIVE_LOGON_NAME) == 0 )
               {
                   if ( cSpecialItems == 0 ) {
                       //
                       // logon locally right cannot be assigned to no one
                       //
                       dwIds = IDS_PRIV_WARNING_LOCAL_LOGON;

                   } else {

                       PWSTR pszAdmins = NULL;

                       //
                       // get the administrators group name
                       // logon locally right must be assigned to the administrator group
                       //
                       if ( WseceditGetNameForSpecialSids(NULL,
                                                          NULL,
                                                          &pszAdmins,
                                                          NULL) )
                       {
                           for (i=0;i<cSpecialItems;i++)
                           {
                               m_lbGrant.GetText(i,strDenyItem);
                               if ( (lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAdmins)) == 0 )
                               {
                                   break;
                               }
                           }

                           if ( i >= cSpecialItems ) {
                               //
                               // cannot find administrators
                               //
                               dwIds = IDS_PRIV_WARNING_LOCAL_LOGON;
                           }

                           LocalFree(pszAdmins);

                       }

                       else
                       {
                           dwIds = IDS_PRIV_WARNING_ACCOUNT_TRANSLATION;
                       }

                   }
               }
               else if (lstrcmpi(pszPrivName, SE_DENY_INTERACTIVE_LOGON_NAME) == 0 )
               {
                   PWSTR pszEveryone = NULL;
                   PWSTR pszAuthUsers = NULL;
                   PWSTR pszAdmins = NULL;
                   PWSTR pszAdministrator=NULL;

                   //
                   // deny logon locally right cannot be assigned to any of the following
                   //  everyone, authenticated users, administrators, administrator
                   //
                   if ( WseceditGetNameForSpecialSids(&pszEveryone,
                                                      &pszAuthUsers,
                                                      &pszAdmins,
                                                      &pszAdministrator) )
                   {

                       //
                       // make sure this check covers the free text administrator account as well
                       //
                       PWSTR pTemp = wcschr(pszAdministrator, L'\\');

                       if ( pTemp ) {
                           pTemp++;
                       }

                       for (i=0;i<cSpecialItems;i++)
                       {
                           m_lbGrant.GetText(i,strDenyItem);
                           if ( lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszEveryone) == 0 ||
                                lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAuthUsers) == 0 ||
                                lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAdmins) == 0 ||
                                lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAdministrator) == 0 ||
                                (pTemp && lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pTemp) == 0 ) )
                           {
                               dwIds = IDS_PRIV_WARNING_DENYLOCAL_LOGON;
                               break;
                           }
                       }

                       LocalFree(pszEveryone);
                       LocalFree(pszAuthUsers);
                       LocalFree(pszAdmins);
                       LocalFree(pszAdministrator);
                   }

                   else
                   {
                       dwIds = IDS_PRIV_WARNING_ACCOUNT_TRANSLATION;
                   }
               }

               if (dwIds == IDS_PRIV_WARNING_LOCAL_LOGON ||
                   dwIds == IDS_PRIV_WARNING_DENYLOCAL_LOGON ||
                   dwIds == IDS_PRIV_WARNING_ACCOUNT_TRANSLATION )
               {

                   //
                   // if any of the items fail the check, display the warning
                   // or popup a warning message box
                   //
                   CString strWarning;
                   strWarning.LoadString(dwIds);

                   CWnd *pWarn = GetDlgItem(IDC_WARNING);
                   if (pWarn)
                   {
                       pWarn->SetWindowText(strWarning);
                       pWarn->ShowWindow(SW_SHOW);
                       pWarn = GetDlgItem(IDC_WARNING_ICON);
                       if (pWarn)
                           pWarn->ShowWindow(SW_SHOW);
                   }
                   else
                   {
                       //
                       // Dialog box not available in some modes such as Local Policy
                       //

                       AfxMessageBox(strWarning);
                   }

                   return FALSE;
               }
           }

           if ( ppa == NULL && m_pData->GetUnits() )
           {
               if ( m_pData->GetBaseProfile()->UpdatePrivilegeAssignedTo(
                                                                        FALSE,
                                                                        &ppa,
                                                                        m_pData->GetUnits()
                                                                        ) == ERROR_SUCCESS)
               {
                   m_pData->GetBaseProfile()->SetDirty(AREA_PRIVILEGES);
                   SetPrivData(ppa);
               }
           }

           if ( ppa )
           {
               PSCE_NAME_LIST pNewList=NULL;

               cItems = m_lbGrant.GetCount();
               HRESULT hr=S_OK;


               if (cItems != LB_ERR && m_bConfigure)
               {
                   for (i=0;i<cItems;i++)
                   {
                       m_lbGrant.GetText(i,strItem);
                       if ( SceAddToNameList(&pNewList, (LPTSTR)(LPCTSTR)strItem, strItem.GetLength()) != SCESTATUS_SUCCESS)
                       {
                           hr = E_FAIL;
                           break;
                       }
                   }
               }
               else
                   hr = E_FAIL;

               if ( SUCCEEDED(hr) )
               {
                   SceFreeMemory(ppa->AssignedTo,SCE_STRUCT_NAME_LIST);
                   ppa->AssignedTo = pNewList;

                   SetPrivData(ppa);
                   m_pData->Update(m_pSnapin);
                   m_fDirty = false;
               }
               else
               {
                   //
                   // free the new list, failed due to memory problem
                   //
                   if ( pNewList ) {
                       SceFreeMemory(pNewList,SCE_STRUCT_NAME_LIST);
                   }
               }
           }
       }
   }

   return CAttribute::OnApply();
}

void CConfigPrivs::OnCancel()
{
   m_bConfigure = m_bOriginalConfigure;
   CAttribute::OnCancel();
}

PSCE_PRIVILEGE_ASSIGNMENT
CConfigPrivs::GetPrivData() {
   ASSERT(m_pData);
   if (m_pData) {
      return (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetID();
   }
   return NULL;
}

void
CConfigPrivs::SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa) {
   ASSERT(m_pData);
   if (m_pData) {
      m_pData->SetID((LONG_PTR)ppa);
      if (ppa) {
         m_pData->SetBase((LONG_PTR)ppa->AssignedTo);
      } else {
         m_pData->SetBase(NULL);
      }
   }
}

BOOL CConfigPrivs::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PSCE_PRIVILEGE_ASSIGNMENT ppa;
   PSCE_NAME_LIST pNames;

   UpdateData(FALSE);

   ::SetMapMode(::GetDC(m_lbGrant.m_hWnd), MM_TEXT);
   
   ppa = GetPrivData();

   if ( ppa ) {

       pNames = ppa->AssignedTo;
       UINT cstrMax = 0; //Raid #271219
       LPWSTR pstrMax = NULL;
       UINT cstr = 0;
       while(pNames)
       {
          m_lbGrant.AddString(pNames->Name);
          cstr = wcslen(pNames->Name);
          if( cstr > cstrMax )
          {
              cstrMax = cstr;
              pstrMax = pNames->Name;
          }
          pNames = pNames->Next;
       }

       CDC* pCDC = m_lbGrant.GetDC();
       CSize strsize = pCDC->GetOutputTextExtent(pstrMax);
       m_lbGrant.ReleaseDC(pCDC);
       RECT winsize;
       m_lbGrant.GetWindowRect(&winsize); 
       if( strsize.cx > winsize.right-winsize.left )
       {
          m_lbGrant.SetHorizontalExtent(strsize.cx);
       }
       
       m_bConfigure = TRUE;
   } else if(m_pData->GetBase() == (LONG_PTR)ULongToPtr(SCE_NO_VALUE)){
      m_bConfigure = FALSE;
   }

   if (m_pData->GetSetting())
   {
      CWnd *pWarn = GetDlgItem(IDC_WARNING);
      if (pWarn)
      {
         CString strWarning;
         strWarning.LoadString(IDS_PRIV_WARNING);
         pWarn->SetWindowText(strWarning);
         pWarn->ShowWindow(SW_SHOW);

         pWarn = GetDlgItem(IDC_WARNING_ICON);
         if (pWarn)
         {
            pWarn->ShowWindow(SW_SHOW);
         }
      }
   }


   m_bOriginalConfigure = m_bConfigure;

   //
   // Update the user controls depending on the setting.
   //
   AddUserControl(IDC_GRANTLIST);
   AddUserControl(IDC_ADD);
   AddUserControl(IDC_REMOVE);

   m_btnTitle.SetWindowText(m_pData->GetAttrPretty());
   UpdateData(FALSE);
   EnableUserControls(m_bConfigure);
    return TRUE;

    // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigPrivs::SetInitialValue(DWORD_PTR dw)
{

}

BOOL
WseceditGetNameForSpecialSids(
    OUT PWSTR   *ppszEveryone OPTIONAL,
    OUT PWSTR   *ppszAuthUsers OPTIONAL,
    OUT PWSTR   *ppszAdmins OPTIONAL,
    OUT PWSTR   *ppszAdministrator OPTIONAL
    )
/*++
Routine Description:

    This routine returns the localized account name for the Everyone and the Auth User SIDs

Arguments:

    ppszEveryone     -   ptr to fill in (should be freed outside)

    ppszAuthUsers    -   ptr to fill in (should be freed outside)

    ppszAdmins       -   ptr to fill in for Administrators

    ppszAdministrator -  ptr to fill in for local administrator account

Return value:

    TRUE if succeeded else FALSE

-- */

{
    //
    // buffers for the SIDs
    //
    SID     Sid;
    DWORD   dwSize = sizeof(SID);
    PSID    pSid=NULL;

    BOOL    bError = TRUE;

    //
    // variables for sid lookup
    //
    SID_NAME_USE   tmp;
    DWORD dwSizeDom;
    PWSTR   dummyBuf = NULL;

    if ( ppszEveryone ) {

        //
        // create the SID for "everyone"
        //
        if ( CreateWellKnownSid(
                               WinWorldSid,
                               NULL,
                               &Sid,
                               &dwSize)) {

            //
            // get the required size of the account name and domain buffer
            //
            dwSize = 0;
            dwSizeDom = 0;

            LookupAccountSid(
                            NULL,
                            &Sid,
                            NULL,
                            &dwSize,
                            NULL,
                            &dwSizeDom,
                            &tmp
                            );

            *ppszEveryone = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
            dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

            if ( *ppszEveryone && dummyBuf ) {

                //
                // lookup the SID to get the account name - domain name is ignored
                //
                if ( LookupAccountSid(
                                     NULL,
                                     &Sid,
                                     *ppszEveryone,
                                     &dwSize,
                                     dummyBuf,
                                     &dwSizeDom,
                                     &tmp
                                     ) ) {
                    bError = FALSE;
                }
            }
        }

        LocalFree(dummyBuf);
        dummyBuf = NULL;

        if (bError) {
            LocalFree(*ppszEveryone);
            *ppszEveryone = NULL;
            return FALSE;
        }
    }

    //
    // "Authenticated Users"
    //

    if ( ppszAuthUsers ) {

        dwSize = sizeof(SID);
        bError = TRUE;

        //
        // create the SID for "authenticated users"
        //
        if ( CreateWellKnownSid(
                               WinAuthenticatedUserSid,
                               NULL,
                               &Sid,
                               &dwSize)) {

            //
            // get the required size of account name and domain buffers
            //
            dwSize = 0;
            dwSizeDom = 0;

            LookupAccountSid(
                            NULL,
                            &Sid,
                            NULL,
                            &dwSize,
                            NULL,
                            &dwSizeDom,
                            &tmp
                            );

            *ppszAuthUsers = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
            dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

            if ( *ppszAuthUsers && dummyBuf ) {

                //
                // lookup the SID to get account name - domain name is ignored
                //
                if ( LookupAccountSid(
                                     NULL,
                                     &Sid,
                                     *ppszAuthUsers,
                                     &dwSize,
                                     dummyBuf,
                                     &dwSizeDom,
                                     &tmp
                                     ) ) {
                    bError = FALSE;
                }
            }
        }

        LocalFree(dummyBuf);
        dummyBuf = NULL;

        if (bError) {

            LocalFree(*ppszAuthUsers);
            *ppszAuthUsers = NULL;

            if ( ppszEveryone ) {
                LocalFree(*ppszEveryone);
                *ppszEveryone = NULL;
            }
            return FALSE;
        }
    }

    //
    // administrators group
    //

    if ( ppszAdmins ) {

        dwSize = 0;
        bError = TRUE;

        //
        // get the size for the well known SID of administrators group
        //
        CreateWellKnownSid(
                   WinBuiltinAdministratorsSid,
                   NULL,
                   pSid,
                   &dwSize);

        if ( dwSize > 0 ) {

            //
            // alocate buffer and create the well known SID
            // cannot use the SID buffer because Admins SID has more than
            // one subauthority
            //
            pSid = (PSID)LocalAlloc(LPTR, dwSize);

            if ( pSid &&

                 CreateWellKnownSid(
                           WinBuiltinAdministratorsSid,
                           NULL,
                           pSid,
                           &dwSize) ) {

                dwSize = 0;
                dwSizeDom = 0;

                //
                // get the size for account name and domain buffers
                //
                LookupAccountSid(
                                NULL,
                                pSid,
                                NULL,
                                &dwSize,
                                NULL,
                                &dwSizeDom,
                                &tmp
                                );

                *ppszAdmins = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
                dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

                if ( *ppszAdmins && dummyBuf ) {

                    //
                    // look up the name, domain name (BUILTIN) is ignored
                    //
                    if ( LookupAccountSid(
                                         NULL,
                                         pSid,
                                         *ppszAdmins,
                                         &dwSize,
                                         dummyBuf,
                                         &dwSizeDom,
                                         &tmp
                                         ) ) {
                        bError = FALSE;
                    }
                }
            }

            LocalFree(pSid);
            pSid = NULL;
        }

        LocalFree(dummyBuf);
        dummyBuf = NULL;

        if (bError) {

            //
            // anything fail will free all buffers and return FALSE
            //

            LocalFree(*ppszAdmins);
            *ppszAdmins = NULL;

            if ( ppszAuthUsers ) {

                LocalFree(*ppszAuthUsers);
                *ppszAuthUsers = NULL;
            }

            if ( ppszEveryone ) {
                LocalFree(*ppszEveryone);
                *ppszEveryone = NULL;
            }
            return FALSE;
        }
    }

    //
    // the administrator user account
    //
    if ( ppszAdministrator ) {

        dwSize = 0;
        bError = TRUE;

        PWSTR dummy2=NULL;

        //
        // Get Account domain SID first
        //
        PSID pDomSid = WseceditpGetAccountDomainSid();

        if ( pDomSid ) {

            //
            // get the size for the administrator account (local account domain is used)
            //
            CreateWellKnownSid(
                       WinAccountAdministratorSid,
                       pDomSid,
                       pSid,
                       &dwSize);

            if ( dwSize > 0 ) {

                //
                // cannot use the SID buffer because administrator account SID
                // has more than one subauthority
                //
                pSid = (PSID)LocalAlloc(LPTR, dwSize);

                if ( pSid &&
                     CreateWellKnownSid(
                               WinAccountAdministratorSid,
                               pDomSid,
                               pSid,
                               &dwSize) ) {

                    //
                    // get size for the account name and domain buffer
                    //
                    dwSize = 0;
                    dwSizeDom = 0;

                    LookupAccountSid(
                                    NULL,
                                    pSid,
                                    NULL,
                                    &dwSize,
                                    NULL,
                                    &dwSizeDom,
                                    &tmp
                                    );

                    dummy2 = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
                    dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

                    if ( dummy2 && dummyBuf ) {

                        //
                        // lookup the account name and domain name
                        //
                        if ( LookupAccountSid(
                                             NULL,
                                             pSid,
                                             dummy2,
                                             &dwSize,
                                             dummyBuf,
                                             &dwSizeDom,
                                             &tmp
                                             ) ) {

                            *ppszAdministrator = (PWSTR)LocalAlloc(LPTR, (dwSize+dwSizeDom+2)*sizeof(WCHAR));

                            if ( *ppszAdministrator ) {

                                //
                                // the name to return is a fully qualified name such as Domain\Administrator
                                //
                                wcscpy(*ppszAdministrator, dummyBuf);
                                wcscat(*ppszAdministrator, L"\\");
                                wcscat(*ppszAdministrator, dummy2);

                                bError = FALSE;
                            }
                        }
                    }
                }

                LocalFree(pSid);
                pSid = NULL;
            }

            LocalFree(dummyBuf);
            dummyBuf = NULL;

            LocalFree(dummy2);
            dummy2 = NULL;

            LocalFree(pDomSid);
        }

        if (bError) {

            //
            // anything fail will free all buffers and return FALSE
            //
            LocalFree(*ppszAdministrator);
            *ppszAdministrator = NULL;

            if ( ppszAdmins ) {

                LocalFree(*ppszAdmins);
                *ppszAdmins = NULL;
            }

            if ( ppszAuthUsers ) {

                LocalFree(*ppszAuthUsers);
                *ppszAuthUsers = NULL;
            }

            if ( ppszEveryone ) {
                LocalFree(*ppszEveryone);
                *ppszEveryone = NULL;
            }
            return FALSE;
        }

    }

    return TRUE;

}

PSID
WseceditpGetAccountDomainSid(
    )
{

    NTSTATUS Status;

    LSA_HANDLE PolicyHandle;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO  PolicyAccountDomainInfo=NULL;

    PSID DomainSid=NULL;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( NULL,
                            (PLSA_OBJECT_ATTRIBUTES)&PolicyObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );

    if ( NT_SUCCESS(Status) ) {

        //
        // Query the account domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)&PolicyAccountDomainInfo );

        if ( NT_SUCCESS(Status) ) {

            DWORD Len = GetLengthSid(PolicyAccountDomainInfo->DomainSid);

            DomainSid = (PSID)LocalAlloc(LPTR, Len );

            if ( DomainSid ) {

                Status = CopySid( Len, DomainSid, PolicyAccountDomainInfo->DomainSid );

                if ( !NT_SUCCESS(Status) ) {
                    LocalFree(DomainSid);
                    DomainSid = NULL;
                }
            }

            LsaFreeMemory(PolicyAccountDomainInfo);

        }

        LsaClose( PolicyHandle );

    }

    return(DomainSid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cservice.cpp
//
//  Contents:   implementation of CConfigService
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "Cservice.h"
#include "util.h"
#include "servperm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigService dialog


CConfigService::CConfigService(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
m_hwndSecurity(NULL), 
m_pNewSD(NULL), 
m_NewSeInfo(0)

{
    //{{AFX_DATA_INIT(CConfigService)
    m_nStartupRadio = -1;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR) a195HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigService::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigService)
    DDX_Radio(pDX, IDC_ENABLED, m_nStartupRadio);
    DDX_Control(pDX, IDC_BASESD, m_bPermission);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigService, CAttribute)
    //{{AFX_MSG_MAP(CConfigService)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_BN_CLICKED(IDC_BASESD, OnChangeSecurity)
	ON_BN_CLICKED(IDC_DISABLED, OnDisabled)
	ON_BN_CLICKED(IDC_IGNORE, OnIgnore)
	ON_BN_CLICKED(IDC_ENABLED, OnEnabled)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigService message handlers

BOOL CConfigService::OnApply()
{
   if ( !m_bReadOnly )
   {
       DWORD dw = 0;
       int status = 0;

       UpdateData(TRUE);
       PEDITTEMPLATE pTemp = m_pData->GetBaseProfile();

       if (!m_bConfigure ) 
       {
           if ( m_pData->GetBase() != 0 ) 
           {
               if ( pTemp != NULL && pTemp->pTemplate != NULL ) 
               {
                   //
                   // look for the address stored in m_pData->GetBase()
                   // if found it, delete it.
                   //
                   PSCE_SERVICES pServParent, pService;

                   for ( pService=pTemp->pTemplate->pServices, pServParent=NULL;
                         pService != NULL; pServParent=pService, pService=pService->Next ) 
                   {
                       if (pService == (PSCE_SERVICES)m_pData->GetBase() ) 
                       {
                           //
                           // a configured service becomes not configured
                           //
                           if ( pServParent == NULL ) 
                           {
                               // the first service
                               pTemp->pTemplate->pServices = pService->Next;

                           } 
                           else
                               pServParent->Next = pService->Next;

                           pService->Next = NULL;
                           break;
                       }
                   }
                   m_pData->SetBase(NULL); //Raid #378271, 4/27/2001
               } 
               else
               {
                   // should never happen
                  //
                  // free the service node
                  //
                  SceFreeMemory((PVOID)(m_pData->GetBase()), SCE_STRUCT_SERVICES);
                  m_pData->SetBase(0);
               }
           }
           if ( m_pNewSD ) 
           {
               LocalFree(m_pNewSD);
               m_pNewSD = NULL;
           }
       } 
       else 
       {
           switch(m_nStartupRadio) 
           {
           case 0:
               // Automatic
               dw = SCE_STARTUP_AUTOMATIC;
               break;

           case 1:
               // Manual
               dw = SCE_STARTUP_MANUAL;
               break;

           default:
               // DISABLED
               dw = SCE_STARTUP_DISABLED;
               break;
           }

           PSCE_SERVICES pNode=(PSCE_SERVICES)(m_pData->GetBase());

           if ( NULL == pNode ) 
           {
               //
               // a node is changed from not configured to configured
               //
               pNode = CreateServiceNode(m_pData->GetUnits(),
                                           m_pData->GetAttr(),
                                           dw,
                                           m_pNewSD,
                                           m_NewSeInfo);
               if ( pNode != NULL ) 
               {
                   //
                   // add to the service list
                   //
                   pNode->Next = pTemp->pTemplate->pServices;
                   pTemp->pTemplate->pServices = pNode;

                   m_pData->SetBase((LONG_PTR)pNode);

                   m_pNewSD = NULL;
               } 
               else 
               {
                   //
                   // no memory, error out
                   //
                   if ( m_pNewSD ) 
                   {
                       LocalFree(m_pNewSD);
                       m_pNewSD = NULL;
                   }
               }
           } 
           else 
           {
               //
               // an existing service
               //
               pNode->Startup = (BYTE)dw;

               if ( m_pNewSD != NULL ) 
               {
                   if ( pNode->General.pSecurityDescriptor != m_pNewSD &&
                        pNode->General.pSecurityDescriptor != NULL ) 
                   {
                       LocalFree(pNode->General.pSecurityDescriptor);
                   }
                   pNode->General.pSecurityDescriptor = m_pNewSD;
                   m_pNewSD = NULL;

                   pNode->SeInfo = m_NewSeInfo;
               }
           }
       }

       m_pData->Update(m_pSnapin);

       m_NewSeInfo = 0;
       m_hwndParent = NULL;
   }

   return CAttribute::OnApply();
}

void CConfigService::OnCancel()
{
    if ( m_pNewSD ) 
    {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;
    m_hwndParent = NULL;

    m_bConfigure = m_bOriginalConfigure;

    CAttribute::OnCancel();
}

BOOL CConfigService::OnInitDialog()
{
    CAttribute::OnInitDialog();

    m_bOriginalConfigure = m_bConfigure;

    AddUserControl(IDC_ENABLED);
    AddUserControl(IDC_DISABLED);
    AddUserControl(IDC_IGNORE);
    AddUserControl(IDC_BASESD);

    if (QueryReadOnly()) 
	{
       CString str;
       str.LoadString(IDS_VIEW_SECURITY);

		if ( GetDlgItem(IDC_SECURITY) )
			SetDlgItemText(IDC_SECURITY,str);
		else if ( GetDlgItem(IDC_BASESD) )
			SetDlgItemText(IDC_BASESD,str);
    }

    OnConfigure();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigService::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   PSCE_SERVICES pService;

   pService = (PSCE_SERVICES)(pResult->GetBase());
   if ( NULL == pService ) {
       m_bConfigure = FALSE;
       pService = (PSCE_SERVICES)(pResult->GetSetting());
   }

   m_pNewSD = NULL;
   m_NewSeInfo = 0;

   if ( pService != NULL ) {
       switch ( pService->Startup ) {
       case SCE_STARTUP_AUTOMATIC:
           m_nStartupRadio = 0;
           break;
       case SCE_STARTUP_MANUAL:
           m_nStartupRadio = 1;
           break;
       default: // disabled
           m_nStartupRadio = 2;
           break;
       }
       //
       // initialize SD and SeInfo
       //
       if ( pService->General.pSecurityDescriptor ) {

            MyMakeSelfRelativeSD(pService->General.pSecurityDescriptor,
                                 &m_pNewSD);
       }
       m_NewSeInfo = pService->SeInfo;
   }

}


PSCE_SERVICES
CreateServiceNode(LPTSTR ServiceName,
                  LPTSTR DisplayName,
                  DWORD Startup,
                  PSECURITY_DESCRIPTOR pSD,
                  SECURITY_INFORMATION SeInfo)
{

    if ( NULL == ServiceName ) {
        return NULL;
    }

    PSCE_SERVICES pTemp;

    pTemp = (PSCE_SERVICES)LocalAlloc(0,sizeof(SCE_SERVICES));

    if ( pTemp != NULL ) {
        pTemp->ServiceName = (LPTSTR)LocalAlloc(0, (wcslen(ServiceName)+1)*sizeof(TCHAR));

        if ( pTemp->ServiceName != NULL ) {

            if ( DisplayName != NULL ) {
                pTemp->DisplayName = (LPTSTR)LocalAlloc(0, (wcslen(DisplayName)+1)*sizeof(TCHAR));

                if ( pTemp->DisplayName != NULL ) {
                    wcscpy(pTemp->DisplayName, DisplayName);
                } else {
                    // no memory to allocate
                    LocalFree(pTemp->ServiceName);
                    LocalFree(pTemp);
                    return NULL;
                }
            } else
                pTemp->DisplayName = NULL;

            wcscpy(pTemp->ServiceName, ServiceName);

            pTemp->Status = 0;
            pTemp->Startup = (BYTE)Startup;

            pTemp->General.pSecurityDescriptor = pSD;
            pTemp->SeInfo = SeInfo;

            pTemp->Next = NULL;

            return pTemp;

        } else {
            // no memory to allocate
            LocalFree(pTemp);
            return NULL;
        }
    }

    return NULL;
}

void CConfigService::OnConfigure()
{
   CAttribute::OnConfigure();
   if (m_bConfigure && !m_pNewSD)
   {
      OnChangeSecurity();
   }
}

void CConfigService::OnChangeSecurity()
{
    if (IsWindow(m_hwndSecurity)) 
    {
       ::BringWindowToTop(m_hwndSecurity);
       return;
    }

    PSECURITY_DESCRIPTOR m_pOldSD = m_pNewSD; //Raid #358244, 4/5/2001
    SECURITY_INFORMATION m_OldSeInfo = m_NewSeInfo;
    if (!m_pNewSD) 
    {
       GetDefaultServiceSecurity(&m_pNewSD,&m_NewSeInfo);
    }

    INT_PTR nRet = MyCreateSecurityPage2(FALSE,
            &m_pNewSD,
            &m_NewSeInfo,
            (LPCTSTR)(m_pData->GetAttr()),
            SE_SERVICE,
            QueryReadOnly() ? SECURITY_PAGE_RO_NP : SECURITY_PAGE_NO_PROTECT,
            GetSafeHwnd(),
            FALSE);    // not modeless

    if ( -1 == nRet ) 
    {
        CString str;
        str.LoadString(IDS_CANT_ASSIGN_SECURITY);
        AfxMessageBox(str);
    }
    SetModified(TRUE);
}

void CConfigService::OnDisabled() 
{
	SetModified(TRUE);
}

void CConfigService::OnIgnore() 
{
	SetModified(TRUE);
}

void CConfigService::OnEnabled() 
{
	SetModified(TRUE);
}

void 
CConfigService::EnableUserControls( BOOL bEnable ) {
   CAttribute::EnableUserControls(bEnable);
   //
   // IDC_SECURITY needs to be available even in read only
   // mode so that the security page can be viewed.
   //
   // The page itself will be read only if necessary
   //
   if (QueryReadOnly() && bEnable) 
   {
      CWnd* pWnd = GetDlgItem(IDC_SECURITY);
      if (pWnd) 
	  {
         pWnd->EnableWindow(TRUE);
      }
	  else 
	  {
		  pWnd = GetDlgItem(IDC_BASESD);
		  if (pWnd) 
		  {
			 pWnd->EnableWindow(TRUE);
		  }
	  }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\dataobj.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:       dataobj.cpp
//
//  Contents:   Implementation of data object class
//
//  History:
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"
#include "snapmgr.h"
#include "DataObj.h"
#include <sceattch.h>

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
UINT CDataObject::m_cfNodeType               = RegisterClipboardFormat(CCF_NODETYPE);
UINT CDataObject::m_cfNodeTypeString         = RegisterClipboardFormat(CCF_SZNODETYPE);
UINT CDataObject::m_cfNodeID                 = RegisterClipboardFormat(CCF_NODEID2);

UINT CDataObject::m_cfDisplayName            = RegisterClipboardFormat(CCF_DISPLAY_NAME);
UINT CDataObject::m_cfSnapinClassID          = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
UINT CDataObject::m_cfInternal               = RegisterClipboardFormat(SNAPIN_INTERNAL);

UINT CDataObject::m_cfSceSvcAttachment       = RegisterClipboardFormat(CCF_SCESVC_ATTACHMENT);
UINT CDataObject::m_cfSceSvcAttachmentData   = RegisterClipboardFormat(CCF_SCESVC_ATTACHMENT_DATA);
UINT CDataObject::m_cfModeType               = RegisterClipboardFormat(CCF_SCE_MODE_TYPE);
UINT CDataObject::m_cfGPTUnknown             = RegisterClipboardFormat(CCF_SCE_GPT_UNKNOWN);
UINT CDataObject::m_cfRSOPUnknown            = RegisterClipboardFormat(CCF_SCE_RSOP_UNKNOWN);
UINT CDataObject::m_cfMultiSelect            = ::RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the requested data
//
//  History:
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetDataHere(LPFORMATETC lpFormatetc,  // In
                         LPSTGMEDIUM lpMedium)     // In
{
   HRESULT hr = DV_E_CLIPFORMAT;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (!lpFormatetc)
      return E_INVALIDARG;
   
   //
   // Based on the CLIPFORMAT, write data to the stream
   //
   const CLIPFORMAT cf = lpFormatetc->cfFormat;

   if (cf == m_cfNodeType)
      hr = CreateNodeTypeData(lpMedium);
   else if (cf == m_cfNodeTypeString)
      hr = CreateNodeTypeStringData(lpMedium);
   else if (cf == m_cfDisplayName)
      hr = CreateDisplayName(lpMedium);
   else if (cf == m_cfSnapinClassID)
      hr = CreateSnapinClassID(lpMedium);
   else if (cf == m_cfInternal)
      hr = CreateInternal(lpMedium);
   else if (cf == m_cfSceSvcAttachment)
      hr = CreateSvcAttachment(lpMedium);
   else if (cf == m_cfSceSvcAttachmentData)
      hr = CreateSvcAttachmentData(lpMedium);
   else if (cf == m_cfModeType)
      hr = CreateModeType(lpMedium);
   else if (cf == m_cfGPTUnknown)
      hr = CreateGPTUnknown(lpMedium);
   else if (cf == m_cfRSOPUnknown)
      hr = CreateRSOPUnknown(lpMedium);

   return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetData
//
//  Synopsis:   Support for mutli select is added.  First return the mutli
//              select GUID information if that is what we are being called for.
//              The else if copies the actual mutli-select information.
//
//              The function will only copy the mutli select information if
//              the FORMATEETC.cfFormat == CDataObject::m_cfInternal and
//              FORMATETC.tymed == TYMED_HGLOBAL.
//
//  History:    1-14-1999 - a-mthoge
//
//---------------------------------------------------------------------------
STDMETHODIMP
CDataObject::GetData(LPFORMATETC lpFormatetcIn,
                     LPSTGMEDIUM lpMedium)
{
   HRESULT hRet = S_OK;

   if (NULL == lpFormatetcIn ||
       NULL == lpMedium) 
   {
      return E_POINTER;
   }

   if(lpFormatetcIn->cfFormat == m_cfMultiSelect &&
      lpFormatetcIn->tymed    == TYMED_HGLOBAL &&
      m_nInternalArray )
   {
      //
      // Need to create a SSMCObjectTypes structure and return this
      // to MMC for mutli select.
      //
      // we only support result items created by SCE.
      //
      lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(DWORD) + sizeof(GUID) );
      if(!lpMedium->hGlobal)
         return E_FAIL;

      //
      // Set count and GUID to 1.
      //
      SMMCObjectTypes *pTypes = (SMMCObjectTypes *)GlobalLock(lpMedium->hGlobal);
      pTypes->count = 1;
      memcpy( &(pTypes->guid), &m_internal.m_clsid, sizeof(GUID));

      GlobalUnlock(lpMedium->hGlobal);
      return S_OK;
   } 
   else if(lpFormatetcIn->cfFormat == m_cfInternal &&
      lpFormatetcIn->tymed    == TYMED_HGLOBAL &&
      m_nInternalArray )
   {
      //
      // Copy the contents of the mutli select to STGMEDIUM
      //
      lpMedium->hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(INTERNAL) * (m_nInternalArray + 1));
      if(!lpMedium->hGlobal)
         return E_FAIL;

      //
      // The first element in the array is set to
      // MMC_MUTLI_SELECT_COOKIE and the type is set the count of items after the
      // first structure.
      //
      INTERNAL *pInternal = (INTERNAL *)GlobalLock( lpMedium->hGlobal );

      pInternal->m_cookie = (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE;
      pInternal->m_type   = (DATA_OBJECT_TYPES)m_nInternalArray;

      //
      // Copy the rest of the INTERNAL structures to this array.
      //
      pInternal++;
      memcpy(pInternal, m_pInternalArray, sizeof(INTERNAL) * m_nInternalArray);
   } 
   else if (lpFormatetcIn->cfFormat == m_cfNodeID &&
              lpFormatetcIn->tymed    == TYMED_HGLOBAL ) 
   {
      return CreateNodeId(lpMedium);
   }
   return hRet;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:
//
//---------------------------------------------------------------------------
STDMETHODIMP
CDataObject::EnumFormatEtc(DWORD dwDirection,
                           LPENUMFORMATETC*
                           ppEnumFormatEtc)
{
   return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::Create
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the data in pBuffer
//
//  Arguments:  [pBuffer]  - [in] the data to be written
//              [len]      - [in] the length of that data
//              [lpMedium] - [in,out] where to store the data
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CDataObject::Create(const void* pBuffer,
                    int len,
                    LPSTGMEDIUM lpMedium)
{
   HRESULT hr = DV_E_TYMED;

   //
   // Do some simple validation
   //
   if (pBuffer == NULL || lpMedium == NULL)
      return E_POINTER;

   //
   // Make sure the type medium is HGLOBAL
   //
   if (lpMedium->tymed == TYMED_HGLOBAL) 
   {
      //
      // Create the stream on the hGlobal passed in
      //
      LPSTREAM lpStream;
      hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

      if (SUCCEEDED(hr)) 
      {
         //
         // Write to the stream the number of bytes
         //
         ULONG written;
         hr = lpStream->Write(pBuffer, len, &written);

         //
         // Because we told CreateStreamOnHGlobal with 'FALSE',
         // only the stream is released here.
         // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
         // at the correct time.  This is according to the IDataObject specification.
         //
         lpStream->Release();
      }
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeTypeData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with our node type
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
   const GUID *pNodeType;
   //
   // Create the node type object in GUID format
   //

    switch (m_internal.m_foldertype) 
    {
     case LOCALPOL:
        pNodeType = &cNodetypeSceTemplate;
        break;
     
     case PROFILE:
        if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) ||
             ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) ) 
        {
           pNodeType = &cNodetypeSceTemplate;
        } 
        else 
        {
           // other areas aren't extensible on this node
           // return our generic node type
           pNodeType = &cSCENodeType;
        }
        break;

     case AREA_SERVICE_ANALYSIS:
        pNodeType = &cNodetypeSceAnalysisServices;
        break;

     case AREA_SERVICE:
        pNodeType = &cNodetypeSceTemplateServices;
        break;

     default:
        if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
            pNodeType = &cNodeType;
        else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
           pNodeType = &cRSOPNodeType;
        else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SAVSnapin) )
            pNodeType = &cSAVNodeType;
        else
            pNodeType = &cSCENodeType;
        break;
    }

   return Create(reinterpret_cast<const void*>(pNodeType), sizeof(GUID), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeTypeStringData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with the string representation
//              of our node type
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
   //
   // Create the node type object in GUID string format
   //
   LPCTSTR pszNodeType;

    switch (m_internal.m_foldertype) 
    {
     case AREA_SERVICE_ANALYSIS:
        pszNodeType = lstruuidNodetypeSceAnalysisServices;
        break;

     case AREA_SERVICE:
        pszNodeType = lstruuidNodetypeSceTemplateServices;
        break;

     case LOCALPOL:
        pszNodeType = lstruuidNodetypeSceTemplate;
        break;

     case PROFILE:
       if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
          pszNodeType = lstruuidNodetypeSceTemplate;
       else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
          pszNodeType = lstruuidNodetypeSceTemplate;
       else 
       {
          // other snapin types do not allow extensions on this level
          // return our generic node type
          pszNodeType = cszSCENodeType;
       }
       break;

     default:
         if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
             pszNodeType = cszNodeType;
         else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
            pszNodeType = cszRSOPNodeType;
         else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SAVSnapin) )
             pszNodeType = cszSAVNodeType;
         else
             pszNodeType = cszSCENodeType;
        break;
    }

   return Create(pszNodeType, ((wcslen(pszNodeType)+1) * sizeof(WCHAR)), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeID
//
//  Synopsis:   Create an hGlobal in [lpMedium] with our node ID
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CDataObject::CreateNodeId(LPSTGMEDIUM lpMedium)
{
   SNodeID2 *nodeID = NULL;
   BYTE *id = NULL;
   DWORD dwIDSize = 0;
   DWORD dwIDNameSize = 0;
   LPTSTR szNodeName = NULL;
   CFolder *pFolder = NULL;
   LPTSTR szMedium = NULL;
   //
   // Create the node type object in GUID format
   //


   switch (m_internal.m_foldertype) 
   {
      case LOCATIONS:
      case PROFILE:
      case REG_OBJECTS:
      case FILE_OBJECTS:
         //
         // There can be many nodes of these types and they will be
         // locked to the system so just use the display name
         //
         if (m_internal.m_cookie) 
         {
            pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
            szNodeName = pFolder->GetName();
            dwIDNameSize = (lstrlen(szNodeName)+1)*sizeof(TCHAR);
            dwIDSize = sizeof(SNodeID2)+dwIDNameSize;
            lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE,dwIDSize);
            if(!lpMedium->hGlobal)
               return STG_E_MEDIUMFULL;
            
            nodeID = (SNodeID2 *)GlobalLock(lpMedium->hGlobal);
            nodeID->dwFlags = 0;
            nodeID->cBytes = dwIDNameSize;

            memcpy(nodeID->id,szNodeName,dwIDNameSize);
         } 
         else
            return E_FAIL;
         break;

      default:
         //
         // Everything else is unique: there's one and only one node
         // of the type per snapin.
         //
         dwIDSize = sizeof(FOLDER_TYPES)+sizeof(SNodeID2);
         lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE,dwIDSize);
         if(!lpMedium->hGlobal)
            return STG_E_MEDIUMFULL;
         
         nodeID = (SNodeID2 *)GlobalLock(lpMedium->hGlobal);
         nodeID->dwFlags = 0;
         nodeID->cBytes = sizeof(FOLDER_TYPES);
         memcpy(nodeID->id,&(m_internal.m_foldertype),sizeof(FOLDER_TYPES));
         GlobalUnlock(lpMedium->hGlobal);
         break;
   }
   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeTypeData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with SCE's display name,
//              which will differ depending on where it's being viewed from
//              as reported by the mode bits
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
   //
   // This is the display named used in the scope pane and snap-in manager
   //

   //
   // Load the name from resource
   // Note - if this is not provided, the console will used the snap-in name
   //

   CString szDispName;

   if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SAVSnapin) )
      szDispName.LoadString(IDS_ANALYSIS_VIEWER_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SCESnapin) )
      szDispName.LoadString(IDS_TEMPLATE_EDITOR_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_LSSnapin) )
      szDispName.LoadString(IDS_LOCAL_SECURITY_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
      szDispName.LoadString(IDS_EXTENSION_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
      szDispName.LoadString(IDS_EXTENSION_NAME);
   else
      szDispName.LoadString(IDS_NODENAME);

/*  // can't depend on m_ModeBits because it's not set yet
   if (m_ModeBits & MB_ANALYSIS_VIEWER) {
      szDispName.LoadString(IDS_ANALYSIS_VIEWER_NAME);
   } else if (m_ModeBits & MB_TEMPLATE_EDITOR) {
      szDispName.LoadString(IDS_TEMPLATE_EDITOR_NAME);
   } else if ( (m_ModeBits & MB_NO_NATIVE_NODES) ||
              (m_ModeBits & MB_SINGLE_TEMPLATE_ONLY) ) {
      szDispName.LoadString(IDS_EXTENSION_NAME);
   } else {
      szDispName.LoadString(IDS_NODENAME);
   }
*/
   return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateSnapinClassID
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with SCE's class ID
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateSnapinClassID(LPSTGMEDIUM lpMedium)
{
   //
   // Create the snapin classid in CLSID format
   //
   return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateInternal
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with SCE's internal data type
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
   return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::AddInternal
//
//  Synopsis:   Adds an INTERNAL object to the array of internal objects.
//
//  History:    1-14-1999  a-mthoge
//
//---------------------------------------------------------------------------
void CDataObject::AddInternal( MMC_COOKIE cookie, DATA_OBJECT_TYPES  type)
{
   //
   // Allocate memory for one more internal array.
   INTERNAL *hNew = (INTERNAL *)LocalAlloc( 0, sizeof(INTERNAL) * (m_nInternalArray + 1) );
   if(!hNew)
      return;
   
   m_nInternalArray++;

   //
   // Copy other internal array information.
   //
   if( m_pInternalArray )
   {
      memcpy(hNew, m_pInternalArray, sizeof(INTERNAL) * (m_nInternalArray - 1) );
      LocalFree( m_pInternalArray );
   }

   //
   // Set the new internal array members.
   //
   hNew[ m_nInternalArray - 1].m_cookie = cookie;
   hNew[ m_nInternalArray - 1].m_type   = type;

   //
   // Set the CObjectData internal array pointer.
   //
   m_pInternalArray = hNew;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateSvcAttachment
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with the name of the inf
//              template a service attachment should modify or with an empty
//              string for the inf-templateless analysis section
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateSvcAttachment(LPSTGMEDIUM lpMedium)
{
   LPCTSTR sz = 0;

   if ((AREA_SERVICE == m_internal.m_foldertype) ||
       (AREA_SERVICE_ANALYSIS == m_internal.m_foldertype)) 
   {
      CFolder *pFolder = reinterpret_cast<CFolder *>(m_internal.m_cookie);
      if (pFolder) 
      {
         sz = pFolder->GetInfFile();
         if (sz) 
            return Create(sz,(lstrlen(sz)+1)*sizeof(TCHAR),lpMedium);
         else
            return E_FAIL;
      } 
      else
         return E_FAIL;
   }

   //
   // This shouldn't be asked for except in the SERVICE areas
   //
   return E_UNEXPECTED;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateSvcAttachmentData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to the
//              ISceSvcAttachmentData interface that an attachment should use
//              to communicate with SCE
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateSvcAttachmentData(LPSTGMEDIUM lpMedium)
{
   if ((AREA_SERVICE == m_internal.m_foldertype) ||
       (AREA_SERVICE_ANALYSIS == m_internal.m_foldertype)) 
   {
      return Create(&m_pSceSvcAttachmentData,sizeof(m_pSceSvcAttachmentData),lpMedium);
   }

   //
   // This shouldn't be asked for except in the SERVICE areas
   //
   return E_UNEXPECTED;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateModeType
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with the Mode that SCE was
//              started in
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateModeType(LPSTGMEDIUM lpMedium)
{
   DWORD mode = m_Mode;
   if (mode == SCE_MODE_DOMAIN_COMPUTER_ERROR)
      mode = SCE_MODE_DOMAIN_COMPUTER;
   
   return Create(&mode,sizeof(DWORD),lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateGPTUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to GPT's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateGPTUnknown(LPSTGMEDIUM lpMedium)
{
   LPUNKNOWN pUnk = 0;

   if (!m_pGPTInfo) 
   {
      //
      // If we don't have a pointer to a GPT interface then we must not
      // be in a mode where we're extending GPT and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   HRESULT hr = m_pGPTInfo->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&pUnk));
   if (SUCCEEDED(hr))
      return Create(&pUnk,sizeof(pUnk),lpMedium);
   else
      return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateRSOPUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to RSOP's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateRSOPUnknown(LPSTGMEDIUM lpMedium)
{
   HRESULT hr = E_FAIL;
   LPUNKNOWN pUnk = NULL;

   if (!m_pRSOPInfo) 
   {
      //
      // If we don't have a pointer to a RSOP interface then we must not
      // be in a mode where we're extending RSOP and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   hr = m_pRSOPInfo->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&pUnk));
   if (SUCCEEDED(hr))
      return Create(&pUnk,sizeof(pUnk),lpMedium);
   else
      return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\cservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cservice.h
//
//  Contents:   definition of CConfigService
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
#define AFX_CSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

PSCE_SERVICES
CreateServiceNode(LPTSTR ServiceName,
                  LPTSTR DisplayName,
                  DWORD Startup,
                  PSECURITY_DESCRIPTOR pSD,
                  SECURITY_INFORMATION SeInfo);

/////////////////////////////////////////////////////////////////////////////
// CConfigService dialog

class CConfigService : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pResult);
    virtual void SetInitialValue(DWORD_PTR dw) {};
    CConfigService(UINT nTemplateID);   // standard constructor


// Dialog Data
    //{{AFX_DATA(CConfigService)
    enum { IDD = IDD_CONFIG_SERVICE };
    int     m_nStartupRadio;
    CButton m_bPermission;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigService)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigService)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    afx_msg void OnConfigure();
    afx_msg void OnChangeSecurity();
	afx_msg void OnDisabled();
	afx_msg void OnIgnore();
	afx_msg void OnEnabled();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
   virtual void EnableUserControls( BOOL bEnable );

private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    HWND m_hwndSecurity;
    BOOL m_bOriginalConfigure;   

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\ddwarn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ddwarn.h
//
//  Contents:   definition of CDlgDependencyWarn
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_DDWARN_H__A405CAFD_800F_11D2_812B_00C04FD92F7B__INCLUDED_)
#define AFX_DDWARN_H__A405CAFD_800F_11D2_812B_00C04FD92F7B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn dialog
//
// DPCHECK_OPERATOR tells how to compare the values.
//
enum DPCHECK_OPERATOR
{
   DPCHECK_CONFIGURED   = 1,     // The dependent item must be configured.
                                 // A default value must be specifide for the suggested item.
   DPCHECK_NOTCONFIGURED,        // The dependent item must be not configured,
                                 // (only valid if the item itsel if not configured).
   DPCHECK_LESSEQUAL,            // The dependent item must be less than or equal.
   DPCHECK_LESS,                 // The dependent item must be less than.
   DPCHECK_GREATEREQUAL,         // The dependent item must be greater than or eqaul.
   DPCHECK_GREATER,              // The dependent item must be greater.
                                 
                                 //The next two case are special cases for retention Method
   
   DPCHECK_RETENTION_METHOD_CONFIGURED,       // The dependent item must be configured
   DPCHECK_RETENTION_METHOD_NOTCONFIGURED,    // The dependent item must not be configured
                                 
                                       //The next two case are special cases for Retain *** Log for
   DPCHECK_RETAIN_FOR_CONFIGURED,      //The dependent item must be configured
   DPCHECK_RETAIN_FOR_NOTCONFIGURED,   //The dependent item must not be configured
};

//
// Flags for Depenecy checking.
//                                 value is set to the items value.
// DPCHECK_VALIDFOR_NC           - The test is valid for not configured [uDepends] items,
//                                 by default checks are not valid for not configured items.
// DPCHECK_FOREVER               - The item can be configured for FOREVER
// DPCHECK_NEVER                 - Treat configured to never (0) as not configured
// DPCHECK_INVERSE               - Conversion is done by devision not multiplication.
//                                 seconds - days would be an inverse where
//
#define DPCHECK_VALIDFOR_NC      0x10000000
#define DPCHECK_FOREVER          0x20000000
#define DPCHECK_INVERSE          0x40000000
#define DPCHECK_NEVER            0x80000000

//
// Used for creating a dependency list.  For it to work correctly you must
// create the list so that
// uID               - is a valid ID for the result item you are checking
// uDepends          - is a valid ID for a result item in the same Folder.
// uDependencyCount  - is the total dependencies for this item.
// uDefault          - Only used if uOpFlags has DPCHECK_CONFIGURED
// uOpFlags          - The test you want to perform and any other special flags.
//                     The low order word is the operation to perform.
//                     The high order word is used for special flags.
//
typedef struct _tag_DEPENDENCYLIST
{
   UINT uID;                     // The ID we are checking
   UINT uDepends;                // The ID of the dependent item.
   UINT uDependencyCount;        // The number of sequential dependencies.
   UINT uDefault;                // The default value to use if there are no good values.
   UINT uConversion;             // Conversion number.  The dependent values are converted
                                 // items value.
   UINT uOpFlags;                // What kind of check to perfrom and other flags.
} DEPENDENCYLIST, *PDEPENDENCYLIST;


//
// Min max information for the dependency checks.
//
typedef struct _tag_DEPENDENCYMINMAX
{
   UINT uID;                     // The ID of the item.
   UINT uMin;                    // Minimum value.
   UINT uMax;                    // Maximum value.
   UINT uInc;                    // Increment value.
} DEPENDENCYMINMAX, *PDEPENDENCYMINMAX;

//
// This structure will be created by the Dependency check, The caller can
// enumerate through the dialog failed list to see which items failed.
// The [dwSuggested] member will be set to the value that should be set for the
// [pResult] item.
// GetFailedCount()     - Returns number of items that failed the dependency check
// GetFailedInfo(int i) - Returns a pointer to this structure.
//
typedef struct _tag_DEPENDENCYFAILED
{
   const DEPENDENCYLIST *pList;  // The attributes of the item
   CResult *pResult;             // The CResult associated with this item.
   LONG_PTR dwSuggested;         // The suggested setting for this value.

}DEPENDENCYFAILED, *PDEPENDENCYFAILED;


///////////////////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn Class declaration.
// Usage:   First call CheckDendencies with some valid values.  If CheckDendencies returns
// ERROR_MORE_DATA, then [m_aFailedList] has failed items.  If you want to display the
// information to the user you can call DoModal() for the dialog box.  DoModal will return
// IDOK if the user presses 'Auto set' or IDCANCEL if the user presses Cancel.  You
// can then enumerate through the failed list through a for loop with the count of
// dependecies returned by GetFailedCount(), then get each failed item by calling
// GetFailedInfo() which returns a PDEPENDENCYFAILED item.
//
class CDlgDependencyWarn : public CHelpDialog
{
// Construction
public:
   CDlgDependencyWarn(CWnd* pParent = NULL);    // standard constructor
   virtual ~CDlgDependencyWarn();                       // Destructor

   DWORD
   InitializeDependencies(
      CSnapin *pSnapin,    // The snapin who owns the CResult item.
      CResult *pResult,    // The CResult item we are checking
      PDEPENDENCYLIST pList = NULL,
      int iCount = 0
   );

   DWORD
   CheckDependencies(
      DWORD dwValue        // The value we are checking.
      );

   CResult *
   GetResultItem(
      CResult *pBase,      // Need this to find the CFolder container
      UINT uID             // The ID to search for.
      );

   const PDEPENDENCYFAILED
   GetFailedInfo(int i)    // Get a specifide failed dependcies.
      { return m_aFailedList[i]; };
   int
   GetFailedCount()        //
      { return (int)m_aFailedList.GetSize(); };

   BOOL
   GetResultItemString(
      CString &str,
      int iCol,
      CResult *pResult,
      LONG_PTR dwValue  =  NULL
      );
// Dialog Data
   //{{AFX_DATA(CDlgDependencyWarn)
   enum { IDD = IDD_WARNING_DIALOG };
      // NOTE: the ClassWizard will add data members here
   //}}AFX_DATA



// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CDlgDependencyWarn)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CDlgDependencyWarn)
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CImageList m_imgList;
   CTypedPtrArray< CPtrArray, PDEPENDENCYFAILED> m_aFailedList;
   CTypedPtrArray< CPtrArray, CResult *> m_aDependsList;
   LONG_PTR m_dwValue;
   CResult *m_pResult;
   CSnapin *m_pSnapin;
   PDEPENDENCYLIST m_pList;
   int m_iCount;

public:
   static DEPENDENCYMINMAX m_aMinMaxInfo[];
   static const DEPENDENCYMINMAX *LookupMinMaxInfo(UINT uID);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DDWARN_H__A405CAFD_800F_11D2_812B_00C04FD92F7B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\dattrs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       dattrs.h
//
//  Contents:   definition of CDomainRet, CDomainAudit, CDomainEnable, 
//              CDomainChoice, CDomainRegFlags, CDomainGroup, CDomainName,
//              CDomainNumber, CDomainObject, CDomainPrivs, CDomainService,
//              CDomainRegNumber, CDomainRegString, CDomainRegEnable
//                              
//----------------------------------------------------------------------------
#if !defined DATTRS_H
#define DATTRS_H

#include "cret.h"
#include "cchoice.h"
#include "cflags.h"
#include "cgroup.h"
#include "cnumber.h"
#include "cname.h"
#include "cobject.h"
#include "cprivs.h"
#include "cservice.h"
#include "Caudit.h"
#include "cenable.h"
#include "regvldlg.h"


/*
 * CDomain* dialogs are copies of the CConfig* dialogs
 * except with a different dialog resource.
 *
 * Inherit all behaviour except for the resource
 */


class CDomainRet : public CConfigRet
{
public:
   enum { IDD =IDD_DOMAIN_RET };
   CDomainRet() : 
   CConfigRet(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainAudit : public CConfigAudit
{
public:
   enum { IDD =IDD_DOMAIN_AUDIT };
   CDomainAudit() : 
   CConfigAudit(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainEnable : public CConfigEnable
{
public:
   enum { IDD =IDD_DOMAIN_ENABLE };
   CDomainEnable() : 
   CConfigEnable(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainChoice : public CConfigChoice
{
public:
   enum { IDD =IDD_DOMAIN_REGCHOICES };
   CDomainChoice() : CConfigChoice(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegFlags : public CConfigRegFlags
{
public:
   enum { IDD =IDD_DOMAIN_REGFLAGS };
   CDomainRegFlags() : CConfigRegFlags(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainGroup : public CConfigGroup
{
public:
   enum { IDD =IDD_DOMAIN_MEMBERSHIP };
   CDomainGroup() : CConfigGroup(IDD)
   {
       m_uTemplateResID = IDD;
   }

   virtual BOOL OnInitDialog()
   {
      CConfigGroup::OnInitDialog ();

      if ( m_bReadOnly )
      {
         GetDlgItem (IDC_ADD_MEMBER)->EnableWindow (FALSE);
         GetDlgItem (IDC_REMOVE_MEMBER)->EnableWindow (FALSE);
         GetDlgItem (IDC_ADD_MEMBEROF)->EnableWindow (FALSE);
         GetDlgItem (IDC_REMOVE_MEMBEROF)->EnableWindow (FALSE);
      }

      return TRUE;
   }
};

class CDomainName : public CConfigName
{
public:
   enum { IDD =IDD_DOMAIN_NAME };
   CDomainName() : CConfigName(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual ~CDomainName ()
   {
   }
};

class CDomainNumber : public CConfigNumber
{
public:
   enum { IDD =IDD_DOMAIN_NUMBER };
   CDomainNumber() : CConfigNumber(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainObject : public CConfigObject
{
public:
   enum { IDD =IDD_DOMAIN_OBJECT };
   CDomainObject() : CConfigObject(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainPrivs : public CConfigPrivs
{
public:
   enum { IDD =IDD_DOMAIN_PRIVS };
   CDomainPrivs() : CConfigPrivs(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainService : public CConfigService
{
public:
   enum { IDD =IDD_DOMAIN_SERVICE };
   CDomainService() : CConfigService(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegNumber : public CConfigRegNumber
{
public:
   enum { IDD =IDD_DOMAIN_NUMBER };
   CDomainRegNumber() : CConfigRegNumber(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegString : public CConfigRegString
{
public:
   enum { IDD =IDD_DOMAIN_NAME };
   CDomainRegString(UINT nTemplateID) : //Raid #381309, 4/31/2001
        CConfigRegString(nTemplateID ? nTemplateID : IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegEnable : public CConfigRegEnable
{
public:
   enum { IDD =IDD_DOMAIN_ENABLE };
   CDomainRegEnable() : 
   CConfigRegEnable(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

#endif // DATTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#if DBG == 1
static int indentLevel = 0;


void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    va_list arglist;
    WCHAR Buffer[512];
    int cb;

//    if ( level < 0 )
//        indentLevel += level;
    //
    // Format the output into a buffer and then print it.
    //
//    wstring strTabs;

//    for (int nLevel = 0; nLevel < indentLevel; nLevel++)
//        strTabs += L"  ";

//    OutputDebugStringW (strTabs.c_str ());

    va_start(arglist, format);

    cb = _vsnwprintf (Buffer, sizeof(Buffer), format, arglist);
    if ( cb )
    {
        OutputDebugStringW (Buffer);
    }

    va_end(arglist);

//    if ( level > 0 )
//        indentLevel += level;
}


PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\ddwarn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ddwarn.cpp
//
//  Contents:   implementation of CDlgDependencyWarn
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "snapmgr.h"
#include "cookie.h"
#include "DDWarn.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn dialog

CDlgDependencyWarn::CDlgDependencyWarn(CWnd* pParent /*=NULL*/)
   : CHelpDialog(a238HelpIDs, IDD, pParent)
{
   m_pResult = NULL;
   m_dwValue = SCE_NO_VALUE;
   //{{AFX_DATA_INIT(CDlgDependencyWarn)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

CDlgDependencyWarn::~CDlgDependencyWarn()
{
   for(int iCheck = 0; iCheck < m_aFailedList.GetSize(); iCheck++){
      if(m_aFailedList[iCheck]){
         LocalFree(m_aFailedList[iCheck]);
      }
   }
   m_aFailedList.RemoveAll();

   for(int iCheck = 0; iCheck < m_aDependsList.GetSize(); iCheck++){
      if(m_aDependsList[iCheck]){
         m_aDependsList[iCheck]->Release();
      }
   }
   m_aDependsList.RemoveAll();
}

void CDlgDependencyWarn::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgDependencyWarn)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}

//////////////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn::m_aMinMaxInfo
// Min max info for items.
//////////////////////////////////////////////////////////////////////////////////////
DEPENDENCYMINMAX CDlgDependencyWarn::m_aMinMaxInfo [] =
{
   // ID                   // Min value   // Max Value   // Increment by //Flags
   { IDS_LOCK_DURATION,    1,              99999,        1},
   { IDS_MIN_PAS_AGE,      0,              998,          1},
   { IDS_MAX_PAS_AGE,      0,              999,          1},
   { IDS_LOCK_COUNT,       0,              999,          1},
   { IDS_MIN_PAS_LEN,      0,              14,           1},
   { IDS_PAS_UNIQUENESS,   0,              24,           1},
   { IDS_LOCK_RESET_COUNT, 1,              99999,        1},
   { IDS_SYS_LOG_MAX,      64,             4194240,      64},
   { IDS_SEC_LOG_MAX,      64,             4194240,      64},
   { IDS_APP_LOG_MAX,      64,             4194240,      64},
   { IDS_SYS_LOG_DAYS,     1,              365,          1},
   { IDS_SEC_LOG_DAYS,     1,              365,          1},
   { IDS_APP_LOG_DAYS,     1,              365,          1},
   { IDS_KERBEROS_MAX_AGE, 1,              99999,        1},
   { IDS_KERBEROS_RENEWAL, 1,              99999,        1},
   { IDS_KERBEROS_MAX_SERVICE, 10,         99999,        1},
   { IDS_KERBEROS_MAX_CLOCK, 0,            99999,        1}
};

//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::GetMinMaxInfo
//
// Returns the row which contains the [uID]
//
// Arguments:  [uID] - The ID to search for.
//
// Returns:    A row pointer or NULL if the ID is not contained in the table.
//-------------------------------------------------------------------------------------
const DEPENDENCYMINMAX *
CDlgDependencyWarn::LookupMinMaxInfo(UINT uID)
{
   int nSize = sizeof(m_aMinMaxInfo)/sizeof(DEPENDENCYMINMAX);
   for(int i = 0; i < nSize; i++){
      if(m_aMinMaxInfo[i].uID == uID){
         return &(m_aMinMaxInfo[i]);
      }
   }
   return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////
// The dependency list.
// The ID defines what we are checking.
// The Dependent IDS are the items the item is dependent on.
// Count       -  The number of dependencies.
// Default     -  The default value for the item if no other values can be used.
//                This is only used if the Item must be configured and it is not.
// Conversion  -  What units the item must be converted to before performing the check.
// Operator    -
//////////////////////////////////////////////////////////////////////////////////////
DEPENDENCYLIST g_aDList [] =
{
      // ID                // Depend ID         //Count/Default/Conversion  //Check type
   //
   // Password reset count <= password Lock duratio, and Password lock count must be
   // configured.
   //
   { IDS_LOCK_RESET_COUNT, IDS_LOCK_DURATION,         4, 30, 1,             DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_LOCK_COUNT,            0, 5, 1,              DPCHECK_CONFIGURED|DPCHECK_NEVER },
   { 0,                    IDS_LOCK_DURATION,         0, 0, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_LOCK_COUNT,            0, 0, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},

   //
   // Password lock duration, Reset count must be <=, and if this item is not configured,
   // then Reset Count is also not configured.
   //
   { IDS_LOCK_DURATION,    IDS_LOCK_RESET_COUNT,      4, 30, 1,             DPCHECK_LESSEQUAL |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_LOCK_COUNT,            0, 5, 1,              DPCHECK_CONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_RESET_COUNT,      0, 5, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_LOCK_COUNT,            0, 5, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},

   //
   // Password Lock count.  If this item is configured then both Lock count and reset
   // should be configured.  If it is not configured or 0 then the above items can not
   // configured.
   //
   { IDS_LOCK_COUNT,       IDS_LOCK_DURATION,         4, 0, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_RESET_COUNT,      0, 0, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_DURATION,         0, 30,1,              DPCHECK_CONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_RESET_COUNT,      0, 30,1,              DPCHECK_CONFIGURED|DPCHECK_NEVER},

   //
   // Kerberos Max ticket age is dependent on all three things being set.
   //
   { IDS_KERBEROS_MAX_AGE, IDS_KERBEROS_RENEWAL,      4, 7, 24,             DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_FOREVER | DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 10, 60,            DPCHECK_LESSEQUAL |
                                                                            DPCHECK_FOREVER | DPCHECK_INVERSE | DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_KERBEROS_RENEWAL,      0, 0, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 0, 1,              DPCHECK_NOTCONFIGURED},

   //
   // Kerberos renewel is dependent on all three things being set.
   //
   { IDS_KERBEROS_RENEWAL, IDS_KERBEROS_MAX_AGE,      4, 0, 24,             DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 0, 1440,           DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_AGE,      0, 7, 24,             DPCHECK_LESSEQUAL | DPCHECK_VALIDFOR_NC |
                                                                            DPCHECK_FOREVER | DPCHECK_INVERSE },
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 10, 1440,          DPCHECK_LESSEQUAL | DPCHECK_VALIDFOR_NC |
                                                                            DPCHECK_FOREVER | DPCHECK_INVERSE },

   //
   // Kerberose max service age is dependent on all three being set.
   //
   { IDS_KERBEROS_MAX_SERVICE, IDS_KERBEROS_MAX_AGE,  4, 7, 60,             DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_KERBEROS_RENEWAL,      0, 10, 1440,          DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_VALIDFOR_NC },
   { 0,                    IDS_KERBEROS_RENEWAL,      0, 0, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_AGE,      0, 0, 1,              DPCHECK_NOTCONFIGURED},

   //
   // Password min age is dependent on password max age being set.
   //
   { IDS_MIN_PAS_AGE,      IDS_MAX_PAS_AGE,           2, 30, 1,             DPCHECK_GREATER | DPCHECK_FOREVER |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_MAX_PAS_AGE,           0, 0, 1,              DPCHECK_NOTCONFIGURED},

   //
   // Password max age is dependent on password min age being set.
   //
   { IDS_MAX_PAS_AGE,      IDS_MIN_PAS_AGE,           2, 30, 1,             DPCHECK_LESS | DPCHECK_FOREVER |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_MIN_PAS_AGE,           0, 0, 1,              DPCHECK_NOTCONFIGURED},
   //
   //"Retention method for application log" is dependent on
   //"Retain Application Log for
   //
   { IDS_APP_LOG_RET,      IDS_APP_LOG_DAYS,          2, 7, 1,              DPCHECK_RETENTION_METHOD_CONFIGURED },
   { 0,                    IDS_APP_LOG_DAYS,          0, 0, 1,              DPCHECK_RETENTION_METHOD_NOTCONFIGURED },
   { IDS_SEC_LOG_RET,      IDS_SEC_LOG_DAYS,          2, 7, 1,              DPCHECK_RETENTION_METHOD_CONFIGURED },
   { 0,                    IDS_SEC_LOG_DAYS,          0, 0, 1,              DPCHECK_RETENTION_METHOD_NOTCONFIGURED },
   { IDS_SYS_LOG_RET,      IDS_SYS_LOG_DAYS,          2, 7, 1,              DPCHECK_RETENTION_METHOD_CONFIGURED },
   { 0,                    IDS_SYS_LOG_DAYS,          0, 0, 1,              DPCHECK_RETENTION_METHOD_NOTCONFIGURED },

   //
   //"Retain Application Log for is dependent on
   //"Retention method for application log"
   //
   { IDS_APP_LOG_DAYS,     IDS_APP_LOG_RET,          2, SCE_RETAIN_BY_DAYS, 1, DPCHECK_RETAIN_FOR_CONFIGURED },
   { 0,                    IDS_APP_LOG_RET,          0, 0, 1,                  DPCHECK_RETAIN_FOR_NOTCONFIGURED },
   { IDS_SEC_LOG_DAYS,     IDS_SEC_LOG_RET,          2, SCE_RETAIN_BY_DAYS, 1, DPCHECK_RETAIN_FOR_CONFIGURED },
   { 0,                    IDS_SEC_LOG_RET,          0, 0, 1,                  DPCHECK_RETAIN_FOR_NOTCONFIGURED },
   { IDS_SYS_LOG_DAYS,     IDS_SYS_LOG_RET,          2, SCE_RETAIN_BY_DAYS, 1, DPCHECK_RETAIN_FOR_CONFIGURED },
   { 0,                    IDS_SYS_LOG_RET,          0, 0, 1,                  DPCHECK_RETAIN_FOR_NOTCONFIGURED }

};


//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::InitializeDependancies
//
// Initialize the dependancies check.  This needs to be done immediately when the
// property sheet whose dependancies we'll want to check is created because it
// ensures that all of the result items who this attribute is dependant on stick
// around.
//
// Arguments   [pSnapin]   - The snapin which is associated with the CREsult item.
//             [pResult]   - The result item we are checking.
//             [pList]     - An alternate dependancy list to use
//             [iCount]    - The size of the alternate dependancy list
// Returns:
//    ERROR_SUCCESS           - Everything initialized properly
//    ERROR_INVALID_PARAMETER - Either [pSnapin] or [pResult] is NULL.
//-------------------------------------------------------------------------------------
DWORD
CDlgDependencyWarn::InitializeDependencies(
   CSnapin *pSnapin,    // The snapin who owns the CResult item.
   CResult *pResult,    // The CResult item we are checking
   PDEPENDENCYLIST pList,// The Dependency list check.
   int iCount           // The count of dependencies in the list.
   )
{
   if( !pSnapin || !pResult){
      return ERROR_INVALID_PARAMETER;
   }
   m_pResult = pResult;
   m_pSnapin = pSnapin;

   //
   // If no dependency list is passed in then set it to the default one.
   //
   if(!pList){
      pList = g_aDList;
      iCount = sizeof(g_aDList)/sizeof(DEPENDENCYLIST);
   }

   //
   // Find the item in the table.
   //
   for(int i = 0; i < iCount; i++){
      if( pList[i].uID == (UINT)pResult->GetID() ){
         break;
      }
      i += (pList[i].uDependencyCount - 1);
   }


   //
   // No dependencies for this item
   //
   if( i >= iCount){
      m_pList = NULL;
      m_iCount = 0;
      return ERROR_SUCCESS;
   }

   //
   // Count of dependencies for the item.
   //
   m_iCount = pList[i].uDependencyCount;
   m_pList = &(pList[i]);

   CResult *pDepends = NULL;

   //
   // Check each dependency.
   //
   pList = m_pList;
   for(int iCheck = 0;
       iCheck < m_iCount;
       iCheck++, pList++){
      pDepends = GetResultItem( pResult, pList->uDepends );
      if(pDepends){
         //
         // We're going to need this dependant item later
         //
         pDepends->AddRef();
         m_aDependsList.Add( pDepends );
      }
   }

   return ERROR_SUCCESS;

}

//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::CheckDendencies
//
// This function is used to see if all the dependencies for the result value
// are met.  If a check fails then the function returns ERROR_MORE_DATA and
// the calling procedure can optionally display more information through the dialog
// box.  The function also creates suggested values that would meet the
// dependencies as specifide in the dependency table.
//
// Arguments:
//             [dwValue]   - The new value.
// Returns:
//    ERROR_SUCCESS           - The value is fine or there is no record in the table.
//    ERROR_MORE_DATA         - At least of of the dependency checks failed.
//    ERROR_NOT_READY         - InitializeDependencies hasn't yet been called
//-------------------------------------------------------------------------------------

DWORD
CDlgDependencyWarn::CheckDependencies(
   DWORD dwValue       // The value we are checking.
   )
{
   if( !m_pSnapin || !m_pResult) {
      return ERROR_NOT_READY;
   }

   if (!m_pList) {
      //
      // No Dependancies
      //
      return ERROR_SUCCESS;
   }

   //
   // Save this information for later use, just in case the dialog box is displayed.
   //
   m_dwValue = dwValue;

   //
   // Free up the dependency array, as it is no longer valid when this function
   // starts.
   //
   CResult *pDepends = NULL;
   for(int iCheck = 0; iCheck < m_aFailedList.GetSize(); iCheck++){
      if(m_aFailedList[iCheck]){
         LocalFree(m_aFailedList[iCheck]);
      }
   }
   m_aFailedList.RemoveAll();


   //
   // Check each dependency.
   //
   PDEPENDENCYLIST pList = m_pList;
   for(int iCheck = 0; iCheck < m_aDependsList.GetSize(); iCheck++,pList++){
      ASSERT(pList->uConversion != 0);

      pDepends = m_aDependsList[iCheck];
      if(pDepends){
         //
         // perform check.
         //
         BOOL bFailed = FALSE;
         DWORD dwCheck = 0;
         DWORD dwItem  = 0;
         LONG_PTR dwSuggest = 0;
         BOOL bNever = 0;
         BOOL bSourceConfigured;
         BOOL bDependConfigured;

         switch( 0x0000FFFF & pList->uOpFlags ){
         case DPCHECK_CONFIGURED:
            //Rule:if the source is configured, depend must be configured

            //
            // The depent item must be configured.  Failure accurs only if the items
            // value is some error value of SCE.
            //
            dwSuggest = (LONG_PTR)pList->uDefault;

            bNever = pList->uOpFlags & DPCHECK_NEVER;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_NO_VALUE == dwValue || SCE_ERROR_VALUE == dwValue) {
               // this item is not configured
               bSourceConfigured = FALSE;
            }
            else if( 0 == dwValue && bNever ){
               bSourceConfigured = FALSE;
            }
            else{
               bSourceConfigured = true;
            }


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck || SCE_ERROR_VALUE == dwCheck) {
            // the dependant item is not configured
               bDependConfigured = false;
            } else if ( 0 == dwCheck && bNever ) {
            // the dependant item is not configured if bNever is true
               bDependConfigured = false;
            }
            else{
               bDependConfigured = true;
            }


            bFailed = bSourceConfigured ? !bDependConfigured : false;



            break;

         case DPCHECK_NOTCONFIGURED:
            //Rule: if source is not configured, depend should not be
            //configured

            dwSuggest = (LONG_PTR)SCE_NO_VALUE;

            bNever = pList->uOpFlags & DPCHECK_NEVER;
            dwCheck = (DWORD) pDepends->GetBase();

                        //check if source is configured
            if (SCE_NO_VALUE == dwValue ) {
               // this item is not configured
               bSourceConfigured = FALSE;
            }
            else if( 0 == dwValue && bNever ){
               bSourceConfigured = FALSE;
            }
            else{
               bSourceConfigured = true;
            }


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck ) {
            // the dependant item is not configured
               bDependConfigured = false;
            } else if ( 0 == dwCheck && bNever ) {
            // the dependant item is not configured if bNever is true
               bDependConfigured = false;
            }
            else{
               bDependConfigured = true;
            }

            bFailed = bSourceConfigured ? false : bDependConfigured;

            break;

         //This case statement is Specially for retention method case
         case DPCHECK_RETENTION_METHOD_CONFIGURED:
            //Here is the rule for DPCHECK_RETENTION_METHOD_CONFIGURED and DPCHECK_RETENTION_METHOD_NOTCONFIGURED
            //If and Only if "Overwrite Event by days" is checked
            //Retain **** Log for is configured
            //Rule:if the source is configured, depend must be configured

            dwSuggest = (LONG_PTR)pList->uDefault;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if ( SCE_RETAIN_BY_DAYS == dwValue )
               bSourceConfigured = true;
            else
               bSourceConfigured = false;


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck || SCE_ERROR_VALUE == dwCheck)
               bDependConfigured = false;
            else
               bDependConfigured = true;


            bFailed = bSourceConfigured ? !bDependConfigured : false;

            break;

         case DPCHECK_RETENTION_METHOD_NOTCONFIGURED:
            //Rule: if source is not configured, depend should not be
            //configured

            dwSuggest = (LONG_PTR)SCE_NO_VALUE;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_RETAIN_BY_DAYS == dwValue )
               bSourceConfigured = true;
            else
               bSourceConfigured = false;


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck || SCE_ERROR_VALUE == dwCheck)
               bDependConfigured = false;
            else
               bDependConfigured = true;

            bFailed = bSourceConfigured ? false : bDependConfigured;

            break;

         //This case statement is Specially for Retain *** Log For case
         case DPCHECK_RETAIN_FOR_CONFIGURED:
            //Here is the rule for DPCHECK_RETAIN_FOR_CONFIGURED and DPCHECK_RETAIN_FOR_NOTCONFIGURED
            //If "Retain **** Log for" is configured
            //then "Overwrite Event by days" is checked

            dwSuggest = (LONG_PTR)pList->uDefault;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_NO_VALUE == dwValue || SCE_ERROR_VALUE == dwValue)
               bSourceConfigured = false;
            else
               bSourceConfigured = true;

            //check if depend is configured
            if (SCE_RETAIN_BY_DAYS == dwCheck )
               bDependConfigured = true;
            else
               bDependConfigured = false;

            bFailed = bSourceConfigured ? !bDependConfigured : false;

            break;

         case DPCHECK_RETAIN_FOR_NOTCONFIGURED:
            //Rule: if source is not configured, depend should not be
            //configured

            dwSuggest = (LONG_PTR)SCE_NO_VALUE;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_NO_VALUE == dwValue || SCE_ERROR_VALUE == dwValue)
               bSourceConfigured = false;
            else
               bSourceConfigured = true;

            //check if depend is configured
            if (SCE_RETAIN_BY_DAYS == dwCheck )
               bDependConfigured = true;
            else
               bDependConfigured = false;

            bFailed = bSourceConfigured ? false : bDependConfigured;

            break;

         default:
            //
            // convert the values as needed.  If the check value is NOT Configured,
            // Then we don't have anything to do, unless the item must be configured
            // for the value to be correct.  This is specifide by DPCHECK_VALIDFOR_NC
            // being set.  At this point, if the depend item is not configured then
            // we will set the check item to the default value.  We will allow the
            // check to be performed, (mostly because we need to get the suggested value.
            //
            dwItem = dwValue;

            dwCheck = (DWORD)pDepends->GetBase();
            if( (!(pList->uOpFlags & DPCHECK_VALIDFOR_NC)
                && dwCheck == SCE_NO_VALUE) || dwItem == SCE_NO_VALUE ){
               //
               // The dependent item is not configured and DPCHECK_VALIDFOR_NC is
               // not set, nothing to do.
               continue;
            } else if(dwCheck == SCE_NO_VALUE){

               //
               // Set the suggested value to the default specifide in the table.
               //
               if(pList->uOpFlags & DPCHECK_INVERSE){
                  dwSuggest = (LONG_PTR) ((DWORD)pList->uDefault/ m_pList->uConversion);
               } else {
                  dwSuggest = (LONG_PTR) ((DWORD)pList->uDefault * m_pList->uConversion);
               }
               dwCheck = pList->uDefault;
            }

            if( pList->uOpFlags & DPCHECK_FOREVER){
               //
               // Convert values to maximum natural number.
               //
               if(dwItem == SCE_FOREVER_VALUE){
                  dwItem = -1;
               }

               //
               // The value to check against.
               //
               if(dwCheck == SCE_FOREVER_VALUE){
                  dwCheck = -1;
               } else {
                  goto ConvertUnits;
               }
            } else {
ConvertUnits:
               //
               // Normal conversion routine.  We need to convert the number to
               // the item we are checkings units.
               //
               if(pList->uOpFlags & DPCHECK_INVERSE){
                  //
                  // When deviding by integers we want to round up, not down.
                  //
                  dwCheck = (DWORD)(dwCheck / pList->uConversion) + (dwCheck%m_pList->uConversion ? 1:0);
               } else {
                  dwCheck = (DWORD)(dwCheck * pList->uConversion);
               }
            }

            switch( 0x0000FFFF & pList->uOpFlags ){
            case DPCHECK_GREATEREQUAL:
               //
               // Fails only if the dependency value is less than the item we
               // are checking.
               //
               if( dwCheck < dwItem){
                  dwSuggest = (LONG_PTR)dwValue;
                  bFailed = TRUE;
               }
               break;
            case DPCHECK_GREATER:
               //
               // Fails only if the dependency value is less than or equal to
               // the item we are checking.
               //
               if( dwCheck <= dwItem){
                  dwSuggest = (LONG_PTR)(dwValue + 1);
                  bFailed = TRUE;
               }
               break;
            case DPCHECK_LESSEQUAL:
               //
               // Fails if the dependency value is greater than the value.
               //
               if( dwCheck > dwItem ){
                  dwSuggest = (LONG_PTR)dwValue;
                  bFailed = TRUE;
               }
               break;
            case DPCHECK_LESS:
               //
               // Fails if the dependency value is greater than or equal to the value.
               //
               if( dwCheck >= dwItem ){
                  dwSuggest = (LONG_PTR)dwValue - 1;
                  bFailed = TRUE;
               }
               break;
            }

            //
            // We do one more final check on the dependency value.  If the dependency value
            // is not configured or an error then we know the test failed.
            // so set the bFailed flag.  The suggested value has already been set at
            // this point.
            //
            if( pDepends->GetBase() == (LONG_PTR)SCE_NO_VALUE ||
                pDepends->GetBase() == (LONG_PTR)SCE_ERROR_VALUE ){
               bFailed = TRUE;
            }
         }

         if(bFailed){
            //
            // The check failed so add the item to the failed list.
            //
            dwItem = (DWORD)dwSuggest;

            //
            // Calculate the actual value.
            //
            if(dwItem == -1 && pList->uOpFlags & DPCHECK_FOREVER){
               //
               // Special case for forever value.
               dwSuggest = (LONG_PTR)SCE_FOREVER_VALUE;
            } else if(dwItem != SCE_NO_VALUE){
               //
               // Other values must be converted back to their units.
               //
               if(pList->uOpFlags & DPCHECK_INVERSE){
                  dwSuggest = (LONG_PTR) (dwItem * pList->uConversion);
               } else {
                  if(dwItem%pList->uConversion){
                     dwSuggest = (LONG_PTR) ((dwItem + pList->uConversion)/m_pList->uConversion);
                  } else {
                     dwSuggest = (LONG_PTR) ((dwItem)/pList->uConversion);
                  }


               }
            }

            //
            // check bounds on suggested settings.
            //
            const DEPENDENCYMINMAX *pMinMax = LookupMinMaxInfo( (UINT)pDepends->GetID());
            if(pMinMax && dwSuggest != SCE_NO_VALUE && dwSuggest != SCE_FOREVER_VALUE){
               if(pMinMax->uMin > (UINT)dwSuggest){
                  dwSuggest = pMinMax->uMin;
               } else if( pMinMax->uMax < (UINT)dwSuggest ){
                  dwSuggest = pMinMax->uMax;
               }
            }

            if( pDepends->GetBase() != dwSuggest ) //Raid #402030
            {
               PDEPENDENCYFAILED pAdd = (PDEPENDENCYFAILED)LocalAlloc(0, sizeof(DEPENDENCYFAILED));
               if(pAdd){
               //
               // Add the item to the failed list.
               //
               pAdd->pList = pList;
               pAdd->pResult = pDepends;
               pAdd->dwSuggested = dwSuggest;
               m_aFailedList.Add( pAdd );
               }
            }
         }
      }
   }

   //
   // Returns ERROR_MORE_DATA if one of the dependencies failed.
   //
   if(m_aFailedList.GetSize()){
      return ERROR_MORE_DATA;
   }
   return ERROR_SUCCESS;
}

//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::GetResultItem
//
// Returns the first result item associated with [pBase] with matching
// [uID] throught CResult::GetID();
// Arguments   [pBase]  - To get the CFolder object.
//             [uID]    - The ID we are looking for.
// Returns:
//    If the function succeeds then a valid CREsult item is returned otherwise
//    NULL
//-------------------------------------------------------------------------------------
CResult *
CDlgDependencyWarn::GetResultItem(CResult *pBase, UINT uID)
{
   if(!pBase){
      return NULL;
   }

   CFolder *pFolder = reinterpret_cast<CFolder *>(pBase->GetCookie());
   if(!pFolder){
      //
      // Nothing to do.
      //
      return NULL;
   }

   HANDLE handle;
   pFolder->GetResultItemHandle ( &handle );
   if(!handle){
      //
      // Nothing to do.
      //
      return NULL;
   }

   POSITION pos = NULL;

   //
   // Enumerate through all the result items and find out if any of them
   // matches the ID.  If so then return the item.
   //
   pFolder->GetResultItem (handle, pos, &pBase);
   while(pBase){
      if( (UINT)pBase->GetID() == uID){
         break;
      }

      if(!pos){
         pBase = NULL;
         break;
      }
      pFolder->GetResultItem(handle, pos, &pBase);
   }

   pFolder->ReleaseResultItemHandle (handle);
   return pBase;
}

BEGIN_MESSAGE_MAP(CDlgDependencyWarn, CHelpDialog)
   //{{AFX_MSG_MAP(CDlgDependencyWarn)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn message handlers

//+-------------------------------------------------------------------------
// CDlgDependencyWarn::OnInitDialog
//
// When this dialog is initialized.  We prepare the listctrl for display.
// Set the title of the window and the static window that displays
// information text for the user.
// Create the columns in the list ctrl.
// For each dependency that failed, Insert the item into the list ctrl,
// and set each columns text, by querying the string from the specifide
// result item.
//
// Returns: the default.
BOOL CDlgDependencyWarn::OnInitDialog()
{
   CDialog::OnInitDialog();

   if(!m_pResult){
      //
      // Nothing to do.
      //
      return TRUE;
   }

   CWnd *pWnd       = GetDlgItem(IDC_WARNING);
   CListCtrl *pCtrl = reinterpret_cast<CListCtrl *>(GetDlgItem(IDC_FAILEDLIST));
   CString str, strVal, strTitle, strFormat;
   GetWindowText(str);
   //
   // Set the window text

   GetResultItemString(strTitle, 0, m_pResult);
   GetResultItemString(strVal, 1, m_pResult, (LONG_PTR)m_dwValue);

   strFormat.Format( str, strTitle );
   SetWindowText(strFormat);

   if(pWnd){
      //
      // Set the description text.
      //
      pWnd->GetWindowText(str);
      strFormat.Format( str, strTitle, strVal );
      pWnd->SetWindowText(strFormat);
   }

   int iItem = 0;
   if(pCtrl){
      //
      // Insert the columns.
      //
      CRect rect;
      pCtrl->GetWindowRect(rect);
      str.LoadString(IDS_ATTR);
      iItem = (int)(rect.Width() * 0.45);
      pCtrl->InsertColumn(0, str, LVCFMT_LEFT, iItem);

      str.LoadString(IDS_BASE_ANALYSIS);
      rect.left += iItem;
      iItem = rect.Width()/2;
      pCtrl->InsertColumn(1, str, LVCFMT_LEFT, iItem);

      str.LoadString(IDS_SUGGESTSETTING);
      rect.left += iItem;
      pCtrl->InsertColumn(2, str, LVCFMT_LEFT, rect.Width());
   }

   //
   // Create image list for this dialog.
   //
   CBitmap bmp;
   if(bmp.LoadBitmap(IDB_ICON16)){
      CDC *dc = GetDC();
      CDC bmDC;

      if ( bmDC.CreateCompatibleDC(dc) ) {
          CBitmap *obmp = bmDC.SelectObject(&bmp);
          COLORREF cr = bmDC.GetPixel(0, 0);
          bmDC.SelectObject(obmp);
          bmp.DeleteObject();

          m_imgList.Create(IDB_ICON16, 16, 0, cr);

          pCtrl->SetImageList(&m_imgList, LVSIL_SMALL);
      }
      ReleaseDC(dc);
   }


   CFolder *pFolder = reinterpret_cast<CFolder *>(m_pResult->GetCookie());
   if(pFolder){
      //
      // Add the items to the error list.
      //
      for(int i = 0; i < m_aFailedList.GetSize(); i++){
         if(!m_aFailedList[i]){
            continue;
         }

         CResult *pDepend = m_aFailedList[i]->pResult;
         if(pDepend){
            //
            // First column text.
            //
            pDepend->GetDisplayName(NULL, str, 0);

            int dwStatus = pDepend->GetStatus();
            pDepend->SetStatus(SCE_STATUS_NOT_CONFIGURED);
            iItem = pCtrl->InsertItem(0, str, GetResultImageIndex(pFolder, pDepend) );
            pDepend->SetStatus( dwStatus );

            //
            // Second column text.
            //
            GetResultItemString(str, 1, pDepend, pDepend->GetBase());
            pCtrl->SetItemText(iItem, 1, str);

            //
            // Suggested item text.
            //
            GetResultItemString(str, 1, pDepend, m_aFailedList[i]->dwSuggested);
            pCtrl->SetItemText(iItem, 2, str);
         }
      }
   }
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

//+----------------------------------------------------------------------------------
// CDlgDependencyWarn::GetResultItemString
//
// Queries the result item for the full text it would display in the specifide
// column if [dwValue] were it's base value.
//
// Arguments:  [str]    - The returned string
//             [iCol]   - The column being queryed.
//             [pResult]- The result being queryed
//             [dwValue]- The base value to set before quering string.  The old value
//                        is not erased.
//
// Returns:    TRUE     - [str] is a valid string.
//             FALSE    - something went wrong.
//-----------------------------------------------------------------------------------
BOOL
CDlgDependencyWarn::GetResultItemString(
   CString &str,
   int iCol,
   CResult *pResult,
   LONG_PTR dwValue
   )
{
   if(!pResult){
      return FALSE;
   }
   CFolder *pFolder = reinterpret_cast<CFolder *>(pResult->GetCookie());

   if(!pFolder){
      return FALSE;
   }

   //
   // Remember the old status and base.
   int iStatus = pResult->GetStatus();
   LONG_PTR lpData = pResult->GetBase();

   //
   // Set the base value to the new one, and status to not configured.
   //
   pResult->SetBase( dwValue );
   pResult->SetStatus(SCE_STATUS_NOT_CONFIGURED);

   //
   // Query for the string.
   //
   pResult->GetDisplayName( NULL, str, iCol );

   //
   // Reset the old status and base.
   //
   pResult->SetStatus( iStatus );
   pResult->SetBase(lpData);
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


#include "stdafx.h"  // Added by ClassView
class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
   COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() { m_pSceSvcAttachmentData = NULL;
                    m_ModeBits = 0;
                    m_Mode = 0;
                    m_nInternalArray = 0;
                    m_pInternalArray = NULL;

                    m_pGPTInfo = NULL;
                    m_pRSOPInfo = NULL;
                  };
    virtual ~CDataObject(){
                    if( m_pInternalArray ){
                       GlobalFree(m_pInternalArray );
                    }
                  };

// Clipboard formats that are required by the console
public:
    static UINT    m_cfNodeType;
    static UINT    m_cfNodeTypeString;
    static UINT    m_cfDisplayName;
    static UINT    m_cfSnapinClassID;
    static UINT    m_cfInternal;
    static UINT    m_cfSceSvcAttachment;
    static UINT    m_cfSceSvcAttachmentData;
    static UINT    m_cfModeType;
    static UINT    m_cfGPTUnknown;
    static UINT    m_cfRSOPUnknown;
    static UINT    m_cfMultiSelect;
    static UINT    m_cfNodeID;

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
   void SetModeBits(DWORD mode) 
   { 
	   m_ModeBits = mode; 
   }
   void SetMode(DWORD mode) { m_Mode = mode; }
   void SetType(DATA_OBJECT_TYPES type) // Step 3
   { 
      ASSERT(m_internal.m_type == CCT_UNINITIALIZED); 
      m_internal.m_type = type; 
   }

   void SetFolderType(FOLDER_TYPES foldertype) 
   { 
      m_internal.m_foldertype = foldertype; 
   }
   void SetCookie(MMC_COOKIE cookie) 
   { 
      m_internal.m_cookie = cookie; 
   } // Step 3
   void SetClsid(const CLSID& clsid) 
   { 
      m_internal.m_clsid = clsid; 
   }
   void SetSceSvcAttachmentData(LPSCESVCATTACHMENTDATA pData) 
   { 
      m_pSceSvcAttachmentData = pData; 
   }
   void AddInternal( MMC_COOKIE cookie, DATA_OBJECT_TYPES  type);

   void SetGPTInfo(LPGPEINFORMATION pGPTInfo) 
   { 
      m_pGPTInfo = pGPTInfo; 
   }
   void SetRSOPInfo(LPRSOPINFORMATION pRSOPInfo) 
   { 
      m_pRSOPInfo = pRSOPInfo; 
   }

private:
   HRESULT CreateSvcAttachmentData(LPSTGMEDIUM lpMedium);
   HRESULT CreateSvcAttachment(LPSTGMEDIUM lpMedium);
   HRESULT CreateNodeId(LPSTGMEDIUM lpMedium);
   HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
   HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
   HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
   HRESULT CreateSnapinClassID(LPSTGMEDIUM lpMedium);
   HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3
   HRESULT CreateModeType(LPSTGMEDIUM lpMedium);
   HRESULT CreateGPTUnknown(LPSTGMEDIUM lpMedium);
   HRESULT CreateRSOPUnknown(LPSTGMEDIUM lpMedium);

   HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
   INTERNAL m_internal;    // Step 3
   INTERNAL *m_pInternalArray;
   int m_nInternalArray;

   LPSCESVCATTACHMENTDATA m_pSceSvcAttachmentData;
   DWORD m_ModeBits;
   DWORD m_Mode;
   LPGPEINFORMATION m_pGPTInfo;
   LPRSOPINFORMATION m_pRSOPInfo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\defvals.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       defvals.h
//
//----------------------------------------------------------------------------
#ifndef DEF_VALS_H
#define DEF_VALS_H

#define MAX_PASS_AGE_DEFAULT 72
#define MIN_PASS_AGE_DEFAULT 0
#define MIN_PASS_LENGTH_DEFAULT 7
#define PASS_HISTORY_SIZE_DEFAULT 18
#define PASS_COMPLEXITY_DEFAULT 1
#define REQUIRE_LOGIN_DEFAULT 1
#define LOCKOUT_BAD_COUNT_DEFAULT 0
#define RESET_LOCKOUT_COUNT_DEFAULT 5
#define LOCKOUT_DURATION_DEFAULT 30
#define AUDIT_SYSTEM_EVENTS_DEFAULT 0
#define AUDIT_LOGON_EVENTS_DEFAULT 0
#define AUDIT_OBJECT_ACCESS_DEFAULT 0
#define AUDIT_PRIVILEGE_USE_DEFAULT 0
#define AUDIT_POLICY_CHANGE_DEFAULT 0
#define AUDIT_ACCOUNT_MANAGE_DEFAULT 0
#define AUDIT_PROCESS_TRACKING_DEFAULT 0
#define AUDIT_DS_ACCESS_DEFAULT 3
#define AUDIT_ACCOUNT_LOGON_DEFAULT 0
#define FORCE_LOGOFF_DEFAULT 0
#define ENABLE_ADMIN_DEFAULT 1
#define ENABLE_GUEST_DEFAULT 0
#define SECURE_SYSTEM_PARTITION_DEFAULT 1
#define SYS_MAX_LOG_SIZE_DEFAULT 512
#define SEC_MAX_LOG_SIZE_DEFAULT 512
#define APP_MAX_LOG_SIZE_DEFAULT 512
#define SYS_LOG_RETENTION_PERIOD_DEFAULT 512
#define SEC_LOG_RETENTION_PERIOD_DEFAULT 512
#define APP_LOG_RETENTION_PERIOD_DEFAULT 512
#define SYS_LOG_RETENTION_DAYS_DEFAULT 7
#define SEC_LOG_RETENTION_DAYS_DEFAULT 7
#define APP_LOG_RETENTION_DAYS_DEFAULT 7
#define SYS_RESTRICT_GUEST_ACCESS_DEFAULT 0
#define SEC_RESTRICT_GUEST_ACCESS_DEFAULT 0
#define APP_RESTRICT_GUEST_ACCESS_DEFAULT 0
#define LSA_ANON_LOOKUP_DEFAULT 0

#define FILE_SYSTEM_SECURITY_DEFAULT TEXT("D:(A;CIOI;GA;;;WD)")
#define REGISTRY_SECURITY_DEFAULT TEXT("D:(A;CI;GA;;;WD)")
#define SERVICE_SECURITY_DEFAULT TEXT("D:(A;CIOI;GA;;;WD)")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\defaults.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       defaults.h
//
//----------------------------------------------------------------------------
#ifndef __SECMGR_DEFAULTS__
#define __SECMGR_DEFAULTS__

#define RNH_AUTODISCONNECT_NAME  L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\AutoDisconnect"
#define RNH_AUTODISCONNECT_LOW   1
#define RNH_AUTODISCONNECT_HIGH  99999
#define RNH_AUTODISCONNECT_FLAGS DW_VALUE_FOREVER | DW_VALUE_NOZERO
#define RNH_AUTODISCONNECT_SPECIAL_STRING IDS_RNH_AUTODISCONNECT_SPECIAL
#define RNH_AUTODISCONNECT_STATIC_STRING IDS_RNH_AUTODISCONNECT_STATIC

#define RNH_CACHED_LOGONS_NAME L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CachedLogonsCount"
#define RNH_CACHED_LOGONS_LOW 0
#define RNH_CACHED_LOGONS_HIGH 50
#define RNH_CACHED_LOGONS_FLAGS DW_VALUE_NEVER
#define RNH_CACHED_LOGONS_SPECIAL_STRING IDS_RNH_CACHED_LOGONS_SPECIAL
#define RNH_CACHED_LOGONS_STATIC_STRING IDS_RNH_CACHED_LOGONS_STATIC

#define RNH_PASSWORD_WARNINGS_NAME L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PasswordExpiryWarning"
#define RNH_PASSWORD_WARNINGS_LOW 0
#define RNH_PASSWORD_WARNINGS_HIGH 999
#define RNH_PASSWORD_WARNINGS_FLAGS 0
#define RNH_PASSWORD_WARNINGS_SPECIAL_STRING 0
#define RNH_PASSWORD_WARNINGS_STATIC_STRING IDS_RNH_PASSWORD_WARNINGS_STATIC

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Wsecedit Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Wsecedit Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)


#endif

//
// yet another trace style used by chklist.h & disabled here
//
#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()	{ return; }
#define TraceLeaveValue(value)  { return(value); }

#define TraceSetMask(dwMask)  
#define TraceEnter(dwMask, fn) 
#define TraceLeave           

#define Trace               
#define TraceMsg(s)        
#define TraceGUID(s, rGUID)

#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\edittemp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       edittemp.h
//
//  Contents:   definition of CEditTemplate
//                              
//----------------------------------------------------------------------------
#ifndef EDITTEMP_H
#define EDITTEMP_H
#include "stdafx.h"
#include "hidwnd.h"
#pragma warning(push,3)
#include <scesvc.h>
#pragma warning(pop)

class CComponentDataImpl;


#define AREA_DESCRIPTION 0x1000

class CEditTemplate {
public:
   BOOL SetDirty(AREA_INFORMATION Area);
   void LockWriteThrough();
   void UnLockWriteThrough();
   BOOL IsLockedWriteThrough() {return m_bLocked;};

   BOOL IsDirty();
   BOOL SetWriteThrough(BOOL bOn) { return m_bWriteThrough = bOn; };
   BOOL QueryWriteThrough() { return m_bWriteThrough; };
   BOOL SetWriteThroughDirty(BOOL bOn) { return m_bWriteThroughDirty = bOn; };
   void SetNotificationWindow(LPNOTIFY pNotify) { m_pNotify = pNotify; };

   BOOL QueryWriteThroughDirty() { return m_bWriteThroughDirty; };
   BOOL Save(LPCTSTR szName=NULL);
   BOOL AddService(LPCTSTR szService,
                   LPSCESVCATTACHMENTPERSISTINFO pPersistInfo);
   BOOL SetInfFile(LPCTSTR szName);
   BOOL CheckArea(AREA_INFORMATION Area) { return ((Area & m_AreaLoaded) == Area); }
   DWORD QueryArea() { return m_AreaLoaded; }
   void AddArea(AREA_INFORMATION Area) { m_AreaLoaded |= Area; }
   void ClearArea(AREA_INFORMATION Area) { m_AreaLoaded &= ~Area; SetDirty(Area); }
   void SetProfileHandle(PVOID hProfile) { m_hProfile = hProfile; }
   BOOL SetDescription(LPCTSTR szDesc);
   void SetComponentDataImpl(CComponentDataImpl *pCDI) { m_pCDI = pCDI; }
   DWORD RefreshTemplate(AREA_INFORMATION aiAreaToAdd = 0);
   BOOL SetNoSave(BOOL b) { return m_bNoSave = b; }
   BOOL QueryNoSave() { return m_bNoSave; }
   BOOL SetPolicy(BOOL b) { return m_bPolicy = b; }
   BOOL QueryPolicy() { return m_bPolicy; }

   LPCTSTR GetInfName()
      { return m_szInfFile; };

   void SetTemplateDefaults();
   LPCTSTR GetDesc() const;   
public:

   CEditTemplate();
   virtual ~CEditTemplate();
public:
   DWORD
   UpdatePrivilegeAssignedTo(
       BOOL bRemove,
       PSCE_PRIVILEGE_ASSIGNMENT *ppaLink,
       LPCTSTR pszName = NULL
       );
   LPCTSTR
   GetFriendlyName() //Raid Bug292634, Yang Gao, 3/30/2001
        { return (m_strFriendlyName.IsEmpty() ? (LPCTSTR)m_szInfFile : m_strFriendlyName); };
   void
   SetFriendlyName(LPCTSTR pszName)
        { m_strFriendlyName = pszName; };

public:
   static DWORD
   ComputeStatus(
      PSCE_REGISTRY_VALUE_INFO prvEdit,
      PSCE_REGISTRY_VALUE_INFO prvAnal
      );
   static DWORD
   ComputeStatus(
      PSCE_PRIVILEGE_ASSIGNMENT pEdit,
      PSCE_PRIVILEGE_ASSIGNMENT pAnal
      );

private:

   CMap<CString, LPCTSTR, LPSCESVCATTACHMENTPERSISTINFO, LPSCESVCATTACHMENTPERSISTINFO&> m_Services;

   PVOID m_hProfile;
   LPTSTR m_szInfFile;
   AREA_INFORMATION m_AreaDirty;
   BOOL m_bWriteThrough;
   BOOL m_bWriteThroughDirty;
   BOOL m_bNoSave;
   AREA_INFORMATION m_AreaLoaded;
   CComponentDataImpl *m_pCDI;
   LPTSTR m_szDesc;
   LPNOTIFY m_pNotify;
   CString m_strFriendlyName;
   BOOL m_bWMI;
   BOOL m_bPolicy;
   BOOL m_bLocked;
public:
   //
   // Public attributes.
   //
   PSCE_PROFILE_INFO pTemplate;

};

typedef CEditTemplate EDITTEMPLATE, *PEDITTEMPLATE;

#endif // EDITTEMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\dsobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "util.h"
#include "servperm.h"
#include "addobj.h"
#include "wrapper.h"

//#include <objsel.h>
//#include <ntdsapi.h>
//#include <dsgetdc.h>
#include <initguid.h>

#include <cmnquery.h>
#include <dsquery.h>
#include <dsclient.h>

static CLIPFORMAT g_cfDsObjectNames = 0;

#if USE_DS
HRESULT MyDsFindDsObjects(
                         IN LPTSTR pMyScope,
                         OUT PDWORD pCount,
                         OUT LPTSTR **ppSelObjs
                         );

HRESULT MyDsFreeObjectBuffer(
                            IN DWORD nCount,
                            IN LPTSTR *pSelObjs
                            );
#endif
//
// in snapmgr.cpp
//
int BrowseCallbackProc(HWND hwnd,UINT uMsg, LPARAM lParam, LPARAM pData);

HRESULT CComponentDataImpl::AddAnalysisFolderToList(LPDATAOBJECT lpDataObject,
                                                    MMC_COOKIE cookie,
                                                    FOLDER_TYPES folderType)
{
   PEDITTEMPLATE pet = NULL;
   PSCE_PROFILE_INFO pProfileInfo = NULL;

   PVOID pHandle = SadHandle;
   if ( !pHandle ) {
      return E_INVALIDARG;
   }

   //
   // to select a folder.
   //

   BROWSEINFO bi;
   CString strTitle;
   LPITEMIDLIST pidlRoot = NULL;

   if (FAILED(SHGetSpecialFolderLocation(m_hwndParent,CSIDL_DRIVES,&pidlRoot))) {
      return E_FAIL;
   }

   ZeroMemory(&bi,sizeof(bi));
   bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_BROWSEINCLUDEFILES | BIF_EDITBOX | BIF_NEWDIALOGSTYLE;
   bi.lpfn = BrowseCallbackProc;
   strTitle.LoadString(IDS_ADDFILESANDFOLDERS_TITLE);
   bi.lpszTitle = strTitle;
   bi.hwndOwner = m_hwndParent;
   bi.pidlRoot = pidlRoot;

   LPITEMIDLIST pidlLocation = NULL;

   pidlLocation = SHBrowseForFolder(&bi);

   if (!pidlLocation) {
      return E_FAIL;
   }

   CString strPath;
   LPMALLOC pMalloc = NULL;

   SHGetPathFromIDList(pidlLocation,strPath.GetBuffer(MAX_PATH));
   strPath.ReleaseBuffer();

   if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
      pMalloc->Free(pidlLocation);
      pMalloc->Free(pidlRoot);
      pMalloc->Release();
   }

   HRESULT hr=E_FAIL;

   if ( strPath.GetLength() ) {

      PSECURITY_DESCRIPTOR pSelSD=NULL;
      SECURITY_INFORMATION SelSeInfo = 0;
      BYTE ConfigStatus = 0;
      if (GetAddObjectSecurity(  m_hwndParent,
                                 strPath,
                                 TRUE,
                                 SE_FILE_OBJECT,
                                 pSelSD,
                                 SelSeInfo,
                                 ConfigStatus
                                 ) == E_FAIL) {

         return hr;
      }
      //
      // only add the object(s) if a security descriptor is selected
      //
      if ( pSelSD && SelSeInfo ) {

         //
         // add to the engine directly
         //
         SCESTATUS sceStatus=SCESTATUS_SUCCESS;
         BYTE AnalStatus;

         //
         // start the transaction if it's not started
         //
         if ( EngineTransactionStarted() ) {

            sceStatus =  SceUpdateObjectInfo(  pHandle,
                                               AREA_FILE_SECURITY,
                                               (LPTSTR)(LPCTSTR)strPath,
                                               strPath.GetLength(), // number of characters
                                               ConfigStatus,
                                               TRUE,
                                               pSelSD,
                                               SelSeInfo,
                                               &AnalStatus
                                               );

            if ( SCESTATUS_SUCCESS == sceStatus &&
                 (pet = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_FILE_SECURITY))) {

               pProfileInfo = pet->pTemplate;
               //
               // just free the object list and unmark the area
               // so when the node is clicked, the profile info
               // will be reloaded
               //
               SceFreeMemory((PVOID)(pProfileInfo->pFiles.pOneLevel), SCE_STRUCT_OBJECT_LIST);
               pProfileInfo->pFiles.pOneLevel = NULL;
               pet->ClearArea(AREA_FILE_SECURITY);

               pet->SetDirty(AREA_FILE_SECURITY);

            }

            if ( SCESTATUS_SUCCESS == sceStatus ) {
               hr = S_OK;
            }

         } else {
            //
            // transaction can't be started to update the object
            //
            hr = E_FAIL;
         }

      } // if no SD is selected, the object won't be added

      if ( pSelSD ) {
         LocalFree(pSelSD);
         pSelSD = NULL;
      }
      if ( FAILED(hr) ) {
         CString str;
         str.LoadString(IDS_CANT_ADD_FOLDER);
         AfxMessageBox(str);
      }

   } // cancel is clicked
   return hr;

}

/*-------------------------------------------------------------------------------------
Method:         CComponentDataImpl::GetAddObjectSecurity

Synopsis:       Gets security information for files and folders that are begin added.

Arguments:      [hwndParent]    - [in] Parent of the dialogs displayed.
                        [strFile]               - [in] File to display in the dialogs.
                        [bContainer]    - [in] Container security or not.
                        [pSelSD]                - [out] Security descriptor.
                        [SelSeInfo]             - [out] Se info.
                        [ConfigStatus]  - [out] Status of the configration

Returns:
                S_OK            - Operation was successful
                S_FAIL          - Operation was canceled.
-------------------------------------------------------------------------------------*/
HRESULT
CComponentDataImpl::GetAddObjectSecurity(
                                        HWND hwndParent,
                                        LPCTSTR strFile,
                                        BOOL bContainer,
                                        SE_OBJECT_TYPE seType,
                                        PSECURITY_DESCRIPTOR &pSelSD,
                                        SECURITY_INFORMATION &SelSeInfo,
                                        BYTE &ConfigStatus
                                        )
{

   if (!strFile || !lstrlen(strFile)) {
      return E_FAIL;
   }

   //
   // Default values.
   //
   DWORD SDSize;

   pSelSD = NULL;
   SelSeInfo = NULL;

   ConfigStatus = 0;
   INT_PTR nRet;
   //
   // Bring up the ACL editor.
   //
   nRet =  MyCreateSecurityPage2(  bContainer,
                                   &pSelSD,
                                   &SelSeInfo,
                                   (LPCTSTR)strFile,
                                   seType,
                                   CONFIG_SECURITY_PAGE,
                                   hwndParent,
                                   FALSE    // not modeless
                                );

   if (nRet == -1) {
      if (pSelSD) {
         LocalFree(pSelSD);
         pSelSD = NULL;
      }
      CString str;
      str.LoadString(IDS_CANT_ASSIGN_SECURITY);
      AfxMessageBox(str);
      return E_FAIL;
   }

   if (nRet <= 0) {
      if (pSelSD) {
         LocalFree(pSelSD);
         pSelSD = NULL;
      }
      return E_FAIL;
   }

   if ( !pSelSD ) {

      DWORD SDSize;
      //
      // if no security is selected, use Everyone Full control
      //
      if ( SE_FILE_OBJECT == seType ) {
         GetDefaultFileSecurity(&pSelSD,&SelSeInfo);
      } else {
         GetDefaultRegKeySecurity(&pSelSD,&SelSeInfo);
      }
   }

   //
   // Bring up the object editor.
   //
   CWnd *pWnd = NULL;
   BOOL bAllocWnd = FALSE;

   if (hwndParent) {
      pWnd = CWnd::FromHandlePermanent( hwndParent );
      if (pWnd == NULL) {
         pWnd = new CWnd;
         if (!pWnd) {
             if (pSelSD) {
                LocalFree(pSelSD);
                pSelSD = NULL;
             }
            return E_FAIL;
         }
         bAllocWnd = TRUE;
         pWnd->Attach(hwndParent);
      }
   }

   CAddObject theObjAcl(
                       seType,
                       (LPTSTR)(LPCTSTR)strFile,
                       TRUE,
                       pWnd
                       );


   //
   // CAddObject frees these pointers
   //
   theObjAcl.SetSD(pSelSD);
   pSelSD = NULL;
   theObjAcl.SetSeInfo(SelSeInfo);
   SelSeInfo = NULL;

   CThemeContextActivator activator;
   nRet =  theObjAcl.DoModal();
   if (bAllocWnd) {
      pWnd->Detach();
      delete pWnd;
   }

   if (nRet == IDOK ) {

      pSelSD = theObjAcl.GetSD();
      SelSeInfo = theObjAcl.GetSeInfo();
      ConfigStatus = theObjAcl.GetStatus();

      return S_OK;
   }

   if ( pSelSD ) {
      LocalFree(pSelSD);
      pSelSD = NULL;
   }

   return E_FAIL;
}

HRESULT CComponentDataImpl::AddAnalysisFilesToList(LPDATAOBJECT lpDataObject,MMC_COOKIE cookie, FOLDER_TYPES folderType)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;

   PVOID pHandle = SadHandle;
   if ( !pHandle ) {
      return E_INVALIDARG;
   }

   HRESULT hr=E_FAIL;

   //
   // to select a file.
   //

   CFileDialog fd(true,
                  NULL,
                  NULL,
                  OFN_DONTADDTORECENT|
                  OFN_ALLOWMULTISELECT);
   CThemeContextActivator activator;
   if (IDOK == fd.DoModal()) {

      POSITION pos = fd.GetStartPosition();

      if ( pos ) {
         //
         // if anyone is selected, invoke acl editor
         //
         CString strPath = fd.GetNextPathName(pos);

         if ( strPath.GetLength() ) {

            PSECURITY_DESCRIPTOR pSelSD=NULL;
            SECURITY_INFORMATION SelSeInfo = 0;
            BYTE ConfigStatus = 0;

            if( GetAddObjectSecurity(  m_hwndParent,
                                            strPath,
                                            TRUE,
                                            SE_FILE_OBJECT,
                                            pSelSD,
                                            SelSeInfo,
                                            ConfigStatus
                                            ) == E_FAIL ){

                    return S_OK;
            }

            if ( pSelSD && SelSeInfo ) {
               //
               // only add the object(s) if a security descriptor is selected
               //
               SCESTATUS sceStatus=SCESTATUS_SUCCESS;

               //
               // start the transaction if it's not started
               //
               if ( EngineTransactionStarted() ) {

                   do {
                      //
                      // add to the engine directly
                      //
                      BYTE AnalStatus;

                      sceStatus =  SceUpdateObjectInfo(
                                                      pHandle,
                                                      AREA_FILE_SECURITY,
                                                      (LPTSTR)(LPCTSTR)strPath,
                                                      strPath.GetLength(), // number of characters
                                                      ConfigStatus,
                                                      FALSE,
                                                      pSelSD,
                                                      SelSeInfo,
                                                      &AnalStatus
                                                      );

                      if ( SCESTATUS_SUCCESS == sceStatus &&
                           (pet = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_FILE_SECURITY))) {

                        pProfileInfo = pet->pTemplate;
                         //
                         // just free the object list and unmark the area
                         // so when the node is clicked, the profile info
                         // will be reloaded
                         //
                         SceFreeMemory((PVOID)(pProfileInfo->pFiles.pOneLevel), SCE_STRUCT_OBJECT_LIST);
                         pProfileInfo->pFiles.pOneLevel = NULL;
                         pet->ClearArea(AREA_FILE_SECURITY);

                         pet->SetDirty(AREA_FILE_SECURITY);

                      }

                      if ( SCESTATUS_SUCCESS != sceStatus ) {
                          CString str;
                          str.LoadString(IDS_SAVE_FAILED);
                         AfxMessageBox(str);
                         break;
                      }

                   } while (pos && (strPath = fd.GetNextPathName(pos)) );

                   if ( SCESTATUS_SUCCESS == sceStatus ) {
                      hr = S_OK;
                   }

               } else {
                   //
                   // no transaction is started to update the object
                   //
                   hr = E_FAIL;
               }

            } // if no SD is selected, the object won't be added

            if ( pSelSD ) {
               LocalFree(pSelSD);
               pSelSD = NULL;
            }

            if ( FAILED(hr) ) {
                CString str;
                str.LoadString(IDS_CANT_ADD_FILE);
               AfxMessageBox(str);
            }
         }
      }

   }

   return hr;
}

HRESULT CComponentDataImpl::UpdateScopeResultObject(LPDATAOBJECT pDataObj,
                                         MMC_COOKIE cookie,
                                         AREA_INFORMATION area)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;

   if ( !cookie || area != AREA_REGISTRY_SECURITY ) {
      return E_INVALIDARG;
   }

   pet = GetTemplate(GT_COMPUTER_TEMPLATE,area);
   if ( pet ) {
      pProfileInfo = pet->pTemplate;
      //
      // just free the object list and unmark the area
      // so when the node is clicked, the profile info
      // will be reloaded
      //
      switch ( area ) {
         case AREA_REGISTRY_SECURITY:

            SceFreeMemory((PVOID)(pProfileInfo->pRegistryKeys.pOneLevel), SCE_STRUCT_OBJECT_LIST);
            pProfileInfo->pRegistryKeys.pOneLevel = NULL;
            break;
         case AREA_FILE_SECURITY:
            SceFreeMemory((PVOID)(pProfileInfo->pFiles.pOneLevel), SCE_STRUCT_OBJECT_LIST);
            pProfileInfo->pFiles.pOneLevel = NULL;
            break;

         default:
            return E_INVALIDARG;
      }

      pet->ClearArea(area);

      CFolder *pFolder = (CFolder *)cookie;

      DeleteChildrenUnderNode(pFolder);

      if ( pFolder->IsEnumerated() ) {
         pFolder->Set(FALSE);
         EnumerateScopePane(cookie,pFolder->GetScopeItem()->ID);
      }

      pFolder->RemoveAllResultItems();
      m_pConsole->UpdateAllViews(NULL,(LONG_PTR)pFolder,UAV_RESULTITEM_UPDATEALL);
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\edittemp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       edittemp.cpp
//
//  Contents:   CEditTemplate class to handle editing of SCE's INF files
//
//  History:
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "edittemp.h"
#include "util.h"
#include "snapmgr.h"
#include <secedit.h>
#include "wrapper.h"
#include "wmihooks.h"

#include <sceattch.h>
#include <locale.h>

//+--------------------------------------------------------------------------
//
//  Method:     AddService
//
//  Synopsis:   Adds a service attachment to the template
//
//  Arguments:  [szService]    - [in] the name of the new service
//              [pPersistInfo] - [in] A pointer to the service extensions'
//                                    persistance interface
//
//  Returns:    TRUE if successfull, FALSE if either argument is null
//
//  Modifies:   m_Services
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::AddService(LPCTSTR szService, LPSCESVCATTACHMENTPERSISTINFO pPersistInfo) {
   if (!szService || !pPersistInfo) {
      return FALSE;
   }
   m_Services.SetAt(szService,pPersistInfo);
   return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Method:     IsDirty
//
//  Synopsis:   Queries whether or not there is unsaved data in the template
//
//  Returns:    TRUE if there is unsaved information, FALSE otherwise
//
//  Modifies:
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::IsDirty() {

   //
   // Some area is dirty
   //
   if (0 != m_AreaDirty) {
      return TRUE;
   }

   //
   // Loop through services until we find one that is dirty
   // or there are no more to check.
   //
   CString strService;
   LPSCESVCATTACHMENTPERSISTINFO pAttachPI;
   POSITION pos;

   pos = m_Services.GetStartPosition();
   while (pos) {
      m_Services.GetNextAssoc(pos,strService,pAttachPI);
      if (pAttachPI && (S_OK == pAttachPI->IsDirty(m_szInfFile))) {
         return TRUE;
      }
   }

   //
   // We didn't find anything dirty
   //
   return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     SetDirty
//
//  Synopsis:   Notify the template that some data within it has been changed.
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  Modifies:
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::SetDirty(AREA_INFORMATION Area) {
   DWORD AreaDirtyOld;

   AreaDirtyOld = m_AreaDirty;

   m_AreaDirty |= Area;

   //
   // If the template is supposed to immediately save any changes then
   // do so.
   //
   if (QueryWriteThrough() && !m_bLocked) {
      SetWriteThroughDirty(TRUE);

      if (Save()) {
         //
         // #204628 - don't call PolicyChanged twiced when writing through
         // Call it in SetDirty and then skip it in Save, so we don't call it
         // once in SetDirty's call to Save and a second time when Save is called
         // on its own
         //
         // #204779 - call the notification window rather than directly calling
         // the IGPEInformation interface
         //
         if (m_pNotify && QueryPolicy()) {
            m_pNotify->RefreshPolicy();
         }
      } else {
         m_AreaDirty = AreaDirtyOld;
         return FALSE;
      }
   }

   return TRUE;
}

//+--------------------------------------------------------------------------------------
// CEditTemplate::SetTemplateDefaults
//
// The caller will have to remove all memory objects used by this template if
// this function
// is called.  Everything becomes NULL and nothing is freed.
//+--------------------------------------------------------------------------------------
void CEditTemplate::SetTemplateDefaults()
{
   //
   // Local Policy Changes.  Initialize everything to not changed
   //
   SCE_PROFILE_INFO *ppi = pTemplate;

   m_AreaLoaded = 0;
   m_AreaDirty = 0;
   if(!ppi){
      ppi = pTemplate = (PSCE_PROFILE_INFO) LocalAlloc(LPTR,sizeof(SCE_PROFILE_INFO));
      if (!pTemplate) {
         return;
      }
   }

   //
   // Must keep to type of this template.
   //
   SCETYPE dwType = ppi->Type;
   PSCE_KERBEROS_TICKET_INFO pKerberosInfo = ppi->pKerberosInfo;

   ZeroMemory( ppi, sizeof(SCE_PROFILE_INFO));
   ppi->Type = dwType;

   //
   // Set defaults to the rest of the template.
   //
   ppi->MinimumPasswordAge=SCE_NO_VALUE;
   ppi->MaximumPasswordAge=SCE_NO_VALUE;
   ppi->MinimumPasswordLength=SCE_NO_VALUE;
   ppi->PasswordComplexity=SCE_NO_VALUE;
   ppi->PasswordHistorySize=SCE_NO_VALUE;
   ppi->LockoutBadCount=SCE_NO_VALUE;
   ppi->ResetLockoutCount=SCE_NO_VALUE;
   ppi->LockoutDuration=SCE_NO_VALUE;
   ppi->RequireLogonToChangePassword=SCE_NO_VALUE;
   ppi->ForceLogoffWhenHourExpire=SCE_NO_VALUE;
   ppi->EnableAdminAccount=SCE_NO_VALUE;
   ppi->EnableGuestAccount=SCE_NO_VALUE;
   ppi->ClearTextPassword=SCE_NO_VALUE;
   ppi->LSAAnonymousNameLookup=SCE_NO_VALUE;
   for (int i=0;i<3;i++) {
      ppi->MaximumLogSize[i]=SCE_NO_VALUE;
      ppi->AuditLogRetentionPeriod[i]=SCE_NO_VALUE;
      ppi->RetentionDays[i]=SCE_NO_VALUE;
      ppi->RestrictGuestAccess[i]=SCE_NO_VALUE;
   }
   ppi->AuditSystemEvents=SCE_NO_VALUE;
   ppi->AuditLogonEvents=SCE_NO_VALUE;
   ppi->AuditObjectAccess=SCE_NO_VALUE;
   ppi->AuditPrivilegeUse=SCE_NO_VALUE;
   ppi->AuditPolicyChange=SCE_NO_VALUE;
   ppi->AuditAccountManage=SCE_NO_VALUE;
   ppi->AuditProcessTracking=SCE_NO_VALUE;
   ppi->AuditDSAccess=SCE_NO_VALUE;
   ppi->AuditAccountLogon=SCE_NO_VALUE;

   //
   // String values
   //
   ppi->NewAdministratorName=NULL;
   ppi->NewGuestName=NULL;
   //
   // registry values
   //
   ppi->RegValueCount= 0;
   ppi->aRegValues = NULL;


   //
   // Kerberos information, if it was created then set the values.
   //
   if(pKerberosInfo){
      pKerberosInfo->MaxTicketAge         = SCE_NO_VALUE;
      pKerberosInfo->MaxRenewAge          = SCE_NO_VALUE;
      pKerberosInfo->MaxServiceAge        = SCE_NO_VALUE;
      pKerberosInfo->MaxClockSkew         = SCE_NO_VALUE;
      pKerberosInfo->TicketValidateClient = SCE_NO_VALUE;

      ppi->pKerberosInfo = pKerberosInfo;
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     Save
//
//  Synopsis:   Save the template to  disk
//
//  Arguments: [szName] - [in] [optional] the name of the INF file to save to
//
//  Returns:    TRUE if the save is successful, False otherwise
//
//  Modifies:   m_AreaDirty
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::Save(LPCTSTR szName) {
   DWORD AreaDirty;
   BOOL bSaveAs = FALSE;
   BOOL bSaveDescription = FALSE;

   setlocale(LC_ALL, ".OCP");
   SCESTATUS status = SCESTATUS_OTHER_ERROR;
   PSCE_ERROR_LOG_INFO errBuf = NULL;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (QueryNoSave()) {
      m_AreaDirty = 0;
      return TRUE;
   }

   AreaDirty = m_AreaDirty;

   //
   // If szName isn't given then default to m_szInfFile
   //
   if (!szName) {
      szName = m_szInfFile;
      //
      // We should never be able to get into a situation where
      // szName still isn't set, but just in case somebody called
      // us without szName or m_szInfFile
      //
      ASSERT(szName);
      if (!szName) {
         return FALSE;
      }
   } else {
      if (lstrcmp(szName,m_szInfFile) != 0) {
         //
         // Saving to a different name (Save As)
         //

         //
         // Make sure the path to that filename exists:
         //
         if (SCESTATUS_SUCCESS != SceCreateDirectory( m_szInfFile, FALSE, NULL )) {
            return FALSE;
         }

         AreaDirty = AREA_ALL|AREA_DESCRIPTION;
         bSaveAs = TRUE;
      }
   }

   if (AreaDirty & AREA_DESCRIPTION) {
      bSaveDescription = TRUE;
      AreaDirty &= ~AREA_DESCRIPTION;
      if (!AreaDirty) {
         //
         // Make sure we have something else to save and
         // create the file.  AREA_SECURITY_POLICY is cheap.
         //
         AreaDirty |= AREA_SECURITY_POLICY;
      }

      //
      // Bug 365485 - make sure we only write this to an already
      // existing temp file so that we don't accidentally create
      // an ansi one instead of unicode.  We can easily do this
      // by writing the description section last since we can
      // depend on the engine getting the rest right
      //
   }

   if (AreaDirty) {
      //
      // Save the dirty areas of the profile
      //
      if (lstrcmpi(GT_COMPUTER_TEMPLATE,szName) == 0) {

         if (m_hProfile) {
             //
             // do not update object area
             //
             status = SceUpdateSecurityProfile(m_hProfile,
                                              AreaDirty & ~(AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_DS_OBJECTS),
                                              pTemplate,
                                              0
                                              );

         }
         ASSERT(m_pCDI);
         if (m_pCDI) {
            m_pCDI->EngineCommitTransaction();
         }
      } else if (lstrcmp(GT_LOCAL_POLICY_DELTA,szName) == 0) {
         //
         // Save Changes only to Local Policy
         //
         status = SceUpdateSecurityProfile(NULL,
                                           AreaDirty & ~(AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_DS_OBJECTS),
                                           pTemplate,
                                           SCE_UPDATE_SYSTEM
                                           );
         SetTemplateDefaults();
         if (!bSaveAs) {
            m_AreaDirty = 0;
            m_AreaLoaded = 0;
         }

      } else if ((lstrcmp(GT_LAST_INSPECTION,szName) != 0) &&
                 (lstrcmp(GT_RSOP_TEMPLATE,szName) != 0) &&
                 (lstrcmp(GT_LOCAL_POLICY,szName) != 0) &&
                 (lstrcmp(GT_EFFECTIVE_POLICY,szName) != 0)) {

         status = SceWriteSecurityProfileInfo(szName,
                                              AreaDirty,
                                              pTemplate,
                                              &errBuf);
      } else {
         //
         // No need (or way) to save the last inspection area
         //
         status = SCESTATUS_SUCCESS;
      }

      if (SCESTATUS_SUCCESS == status) {
         //
         // Those areas are no longer dirty.
         //
         if (!bSaveAs) {
            m_AreaDirty = 0;
         }

      } else {
         //
         // Save failed; Notify the user & return false
         //
         CString strTitle,strMsg,strBase;
         strTitle.LoadString(IDS_NODENAME);
         strBase.LoadString(IDS_SAVE_FAILED);
         strBase += GetFriendlyName();
         //MyFormatMessage(status, (LPCTSTR)strBase, errBuf,strMsg);
         AfxMessageBox(strBase);

         return FALSE;
      }
   }

   if (bSaveDescription) {
      if (m_szDesc) {
         if (WritePrivateProfileSection(
                                   szDescription,
                                   NULL,
                                   szName)) {

            WritePrivateProfileString(
                                     szDescription,
                                     L"Description",
                                     m_szDesc,
                                     szName);
         }
      }
   }

   //
   // Save any dirty services
   //
   CString strService;
   LPSCESVCATTACHMENTPERSISTINFO pAttachPI;
   POSITION pos;
   SCESVCP_HANDLE *scesvcHandle;
   PVOID pvData;
   BOOL bOverwriteAll;

   pos = m_Services.GetStartPosition();
   while (pos) {
      m_Services.GetNextAssoc(pos,strService,pAttachPI);
      if (S_OK == pAttachPI->IsDirty( (LPTSTR)szName )) {

         if (SUCCEEDED(pAttachPI->Save( (LPTSTR)szName,(SCESVC_HANDLE *)&scesvcHandle,&pvData,&bOverwriteAll ))) {
            if (scesvcHandle) {

                if (lstrcmp(GT_COMPUTER_TEMPLATE,szName) == 0) {
                    //
                    // database
                    //
                   status =  SceSvcUpdateInfo(
                                m_hProfile,
                                scesvcHandle->ServiceName,
                                (PSCESVC_CONFIGURATION_INFO)pvData
                                );

                } else {
                   //
                   // inf templates
                   //
                   status = SceSvcSetInformationTemplate(scesvcHandle->TemplateName,
                                                scesvcHandle->ServiceName,
                                                bOverwriteAll,
                                                (PSCESVC_CONFIGURATION_INFO)pvData);
                }
                if (SCESTATUS_SUCCESS != status) {
                    CString strTitle,strMsg,strBase;
                    strTitle.LoadString(IDS_NODENAME);
                    strBase.LoadString(IDS_SAVE_FAILED);
                    strBase += scesvcHandle->ServiceName; //szName;
                    MyFormatMessage(status, (LPCTSTR)strBase, errBuf,strMsg);
                    AfxMessageBox(strMsg);
                }
            }
         }
      }
   }
   return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Method:     SetInfFile
//
//  Synopsis:   Set the name of the INF file this template is associated with
//
//  Arguments:  [szFile] - [in] the name of the INF file to associate with
//
//  Returns:    TRUE if the filename is set successfully, FALSE otherwise
//
//  Modifies:   m_szInfFile
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::SetInfFile(LPCTSTR szFile) {
   LPTSTR szInfFile;

   if (szFile) {
      szInfFile = new TCHAR[lstrlen(szFile)+1];
      if (szInfFile) {
         lstrcpy(szInfFile,szFile);
         if (m_szInfFile) {
            delete[] m_szInfFile;
         }
         m_szInfFile = szInfFile;
      } else {
         return FALSE;
      }
   }
   return szFile != 0;
}


//+--------------------------------------------------------------------------
//
//  Method:     SetDescription
//
//  Synopsis:   Set the description for this template file
//
//  Arguments:  [szDesc] [in] the description for the template
//
//  Returns:    TRUE if the description is set successfully, FALSE otherwise
//
//  Modifies:   m_szDesc
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::SetDescription(LPCTSTR szDesc) {
   LPTSTR szDescription;

   if (szDesc) {
      szDescription = new TCHAR[lstrlen(szDesc)+1];
      if (szDescription) {
         lstrcpy(szDescription,szDesc);
         if (m_szDesc) {
            delete[] m_szDesc;
         }
         m_szDesc = szDescription;
         SetDirty(AREA_DESCRIPTION);
      } else {
         return FALSE;
      }
   }
   return szDesc != 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     CEditTemplate
//
//  Synopsis:   Constructor for CEditTemplate
//
//  History:
//
//---------------------------------------------------------------------------
CEditTemplate::CEditTemplate() {

   m_AreaDirty = 0;
   m_AreaLoaded = 0;
   m_bWriteThrough = FALSE;
   m_bWriteThroughDirty = FALSE;
   m_hProfile = NULL;
   m_szInfFile = NULL;
   m_pNotify = NULL;
   m_pCDI = NULL;
   m_bNoSave = FALSE;
   m_strFriendlyName.Empty();
   m_szDesc = NULL;
   m_bWMI = NULL;
   m_bPolicy = FALSE;
   m_bLocked = FALSE;
   pTemplate = NULL;
}


//+--------------------------------------------------------------------------
//
//  Method:     ~CEditTemplate
//
//  Synopsis:   Destructor for CEditTemplate
//
//  History:
//
//---------------------------------------------------------------------------
CEditTemplate::~CEditTemplate() {
   POSITION pos;
   CString strKey;

   pos = m_Services.GetStartPosition();
   LPSCESVCATTACHMENTPERSISTINFO pAttachPI;
   while (pos) {
      m_Services.GetNextAssoc(pos,strKey,pAttachPI);
      delete pAttachPI;
   }
   if (m_szInfFile) {
      delete[] m_szInfFile;
   }
   if (m_szDesc) {
      delete[] m_szDesc;
   }
   if (pTemplate) {
      if (m_bWMI) {
         FreeWMI_SCE_PROFILE_INFO((PWMI_SCE_PROFILE_INFO)pTemplate);
      } else {
         SceFreeProfileMemory(pTemplate);
      }
      pTemplate = NULL;
   }
   m_AreaDirty = 0;
}


//+--------------------------------------------------------------------------
//
//  Method:     RefreshTemplate
//
//  Synopsis:   Reload the loaded parts of the template
//
//  Arguments:  [aiArea]     - Areas to load even if not previously loaded
//
//  Returns:    0 if the template is reloaded successfully, an error code otherwise
//
//  Modifies:   pTemplate;
//---------------------------------------------------------------------------
DWORD
CEditTemplate::RefreshTemplate(AREA_INFORMATION aiAreaToAdd) {
   AREA_INFORMATION aiArea;
   PVOID pHandle = NULL;
   SCESTATUS rc;


   aiArea = m_AreaLoaded | aiAreaToAdd;
   if (!m_szInfFile) {
      return 1;
   }

   m_AreaDirty = 0;

   if (pTemplate) {
      if (m_bWMI) {
         FreeWMI_SCE_PROFILE_INFO((PWMI_SCE_PROFILE_INFO)pTemplate);
      } else {
         SceFreeProfileMemory(pTemplate);
      }
      pTemplate = NULL;
   }

   if ((lstrcmpi(GT_COMPUTER_TEMPLATE,m_szInfFile) == 0) ||
       (lstrcmpi(GT_LAST_INSPECTION,m_szInfFile) == 0) ||
       (lstrcmpi(GT_LOCAL_POLICY, m_szInfFile) == 0) ||
       (lstrcmpi(GT_EFFECTIVE_POLICY, m_szInfFile) == 0) ) {
      //
      // Analysis pane areas from jet database, not INF files
      //
      SCETYPE sceType;

      PSCE_ERROR_LOG_INFO perr = NULL;

      if  (lstrcmpi(GT_COMPUTER_TEMPLATE,m_szInfFile) == 0) {
         sceType = SCE_ENGINE_SMP;
      } else if (lstrcmpi(GT_LOCAL_POLICY, m_szInfFile) == 0)  {
         sceType = SCE_ENGINE_SYSTEM;
         if (!IsAdmin()) {
            m_hProfile = NULL;
         }
      } else if (lstrcmpi(GT_EFFECTIVE_POLICY,m_szInfFile) == 0){
         sceType = SCE_ENGINE_GPO;
      } else {
         sceType = SCE_ENGINE_SAP;
      }

      rc = SceGetSecurityProfileInfo(m_hProfile,                  // hProfile
                                     sceType,                     // Profile type
                                     aiArea,                      // Area
                                     &pTemplate,                // SCE_PROFILE_INFO [out]
                                     &perr);                      // Error List [out]

      if (SCESTATUS_SUCCESS != rc) {
         if ((SCE_ENGINE_GPO == sceType) &&
             (0 == lstrcmpi(GT_EFFECTIVE_POLICY,m_szInfFile))) {
            SetTemplateDefaults();
            return 0;
         } else {
            return IDS_ERROR_CANT_GET_PROFILE_INFO;
         }
      }
   } else if (lstrcmpi(GT_RSOP_TEMPLATE, m_szInfFile) == 0)  {
      if (!m_pCDI) {
         return IDS_ERROR_CANT_GET_PROFILE_INFO;
      }
      m_bWMI = TRUE;

      CWMIRsop Rsop(m_pCDI->m_pRSOPInfo);
      HRESULT hr;
      PWMI_SCE_PROFILE_INFO pProfileInfo;

      //
      // GetPrecedenceOneRSOPInfo should (but doesn't) support
      // getting just the requested area.
      //
      hr = Rsop.GetPrecedenceOneRSOPInfo(&pProfileInfo);
      if (FAILED(hr)) {
         return IDS_ERROR_CANT_GET_PROFILE_INFO;
      }
      pTemplate = pProfileInfo;
      //
      // Since it doesn't, set all areas not just the ones that
      // were asked for
      //
      AddArea(AREA_ALL);
      return 0;
   } else {
      LPTSTR szInfFile=NULL;

      if  (lstrcmpi(GT_DEFAULT_TEMPLATE,m_szInfFile) == 0) {
         DWORD RegType;
         rc = MyRegQueryValue(HKEY_LOCAL_MACHINE,
                         SCE_REGISTRY_KEY,
                         SCE_REGISTRY_DEFAULT_TEMPLATE,
                         (PVOID *)&szInfFile,
                         &RegType );

         if (ERROR_SUCCESS != rc) {
            if (szInfFile) {
               LocalFree(szInfFile);
               szInfFile = NULL;
            }
            return IDS_ERROR_CANT_GET_PROFILE_INFO;
         }
         if (EngineOpenProfile(szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
            SetTemplateDefaults();
            LocalFree(szInfFile);
            szInfFile = NULL;
            return 0;
         }
         LocalFree(szInfFile);
         szInfFile = NULL;
      } else {
         if (EngineOpenProfile(m_szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
            return IDS_ERROR_CANT_OPEN_PROFILE;
         }
      }
      ASSERT(pHandle);

      //
      // get information from this template
      //
      PSCE_ERROR_LOG_INFO perr = NULL;

      rc = SceGetSecurityProfileInfo(pHandle,
                                     SCE_ENGINE_SCP,
                                     aiArea,
                                     &pTemplate,
                                     &perr //NULL  // &ErrBuf do not care errors
                                    );

      if (SCESTATUS_SUCCESS != rc) {
         // Oops!
      }
      SceCloseProfile(&pHandle);
      pHandle = NULL;
   }
   /*
         if do not care errors, no need to use this buffer

         if ( ErrBuf ) {
            SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
            ErrBuf = NULL;
         }
   */
   if (rc != SCESTATUS_SUCCESS) {
      return IDS_ERROR_CANT_GET_PROFILE_INFO;
   }

   //
   // Set the area in the template
   //
   AddArea(aiArea);


   if ( aiArea & AREA_SECURITY_POLICY && pTemplate ) {
      //
      // expand registry value section based on registry values list on local machine
      //

      SceRegEnumAllValues(
                         &(pTemplate->RegValueCount),
                         &(pTemplate->aRegValues)
                         );
   }

   return 0;
}

//+----------------------------------------------------------------------------------
//Method:       UpdatePrivilegeAssignedTo
//
//Synopsis:     Updates a priviledge item, depending on the [bRemove] argument.
//              if [bRemove] is
//              FALSE   - A new link is created and the pointer is returned through
//                          ppaLink
//              TRUE    - The link is removed from the list.
//
//Arguments:    [bRemove]   - Weither to remove or add an item.
//              [ppaLink]   - The link to be removed or added.  This paramter is
//                              set to NULL if remove is successful or a pointer
//                              to a new SCE_PRIVILEGE_ASSIGNMENT item.
//              [pszName]   - Only used when adding a new item.
//
//Returns:      ERROR_INVALID_PARAMETER     - [ppaLink] is NULL or if removing
//                                              [*ppaLink] is NULL.
//                                              if adding then if [pszName] is NULL
//              ERROR_RESOURCE_NOT_FOUND    - If the link could not be found
//                                              in this template.
//              E_POINTER                   - If [pszName] is a bad pointer or
//                                              [ppaLink] is bad.
//              E_OUTOFMEMORY               - Not enough resources to complete the
//                                              operation.
//              ERROR_SUCCESS               - The opration was successful.
//----------------------------------------------------------------------------------+
DWORD
CEditTemplate::UpdatePrivilegeAssignedTo(
    BOOL bRemove,
    PSCE_PRIVILEGE_ASSIGNMENT *ppaLink,
    LPCTSTR pszName
    )
{

    if(!ppaLink){
        return ERROR_INVALID_PARAMETER;
    }
    PSCE_PRIVILEGE_ASSIGNMENT *pNext = NULL;
    PSCE_PRIVILEGE_ASSIGNMENT pCurrent = NULL;

    if(bRemove) {
        __try {
            if(!*ppaLink){
                return ERROR_INVALID_PARAMETER;
            }
        } __except(EXCEPTION_CONTINUE_EXECUTION) {
            return (DWORD)E_POINTER;
        }

        //
        // Remove the link from the list.
        //

        pCurrent = pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
        if(pCurrent == (*ppaLink) ){
            pNext = &(pTemplate->OtherInfo.smp.pPrivilegeAssignedTo);
        } else if(pCurrent && pCurrent != (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE)) {
            while( pCurrent->Next ){
                if(pCurrent->Next == *ppaLink){
                    pNext = &(pCurrent->Next);
                    break;
                }
                pCurrent = pCurrent->Next;
            }
        }

        if(pNext && pCurrent){
            (*pNext) = (*ppaLink)->Next;

            if( (*ppaLink)->Name){
                LocalFree( (*ppaLink)->Name);
                (*ppaLink)->Name = NULL;
            }

            SceFreeMemory( (*ppaLink)->AssignedTo, SCE_STRUCT_NAME_LIST);
            LocalFree( *ppaLink );

            *ppaLink = NULL;
        } else {
            return ERROR_RESOURCE_NOT_FOUND;
        }
    } else {
        int iLen;

        if(!pszName){
            return ERROR_INVALID_PARAMETER;
        }
        __try {
            iLen = lstrlen( pszName );
        } __except(EXCEPTION_CONTINUE_EXECUTION){
            return (DWORD)E_POINTER;
        }
        //
        // Create a new link.
        //
        pCurrent = (PSCE_PRIVILEGE_ASSIGNMENT)LocalAlloc( 0, sizeof(SCE_PRIVILEGE_ASSIGNMENT));
        if(!pCurrent){
            return (DWORD)E_OUTOFMEMORY;
        }
        ZeroMemory(pCurrent, sizeof(SCE_PRIVILEGE_ASSIGNMENT));
        //
        // Allocate space for the name.
        //
        pCurrent->Name = (LPTSTR)LocalAlloc( 0, sizeof(TCHAR) * (iLen + 1));
        if(!pCurrent->Name){
            LocalFree(pCurrent);
            return (DWORD)E_OUTOFMEMORY;
        }
        lstrcpy(pCurrent->Name, pszName);
        if (*ppaLink) {
           pCurrent->Status = (*ppaLink)->Status;
           pCurrent->AssignedTo = (*ppaLink)->AssignedTo;
        }
        //
        // Assign it to the link.
        //
        pCurrent->Next = pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
        pTemplate->OtherInfo.smp.pPrivilegeAssignedTo = pCurrent;
        *ppaLink = pCurrent;
    }

   return ERROR_SUCCESS;
}

DWORD
CEditTemplate::ComputeStatus(
   PSCE_PRIVILEGE_ASSIGNMENT pEdit,
   PSCE_PRIVILEGE_ASSIGNMENT pAnal
   )
{
   if (!pEdit || (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) == pEdit) {
      return  SCE_STATUS_NOT_CONFIGURED;
   } else if (pEdit->Status == SCE_STATUS_NOT_CONFIGURED) {
      return SCE_STATUS_NOT_CONFIGURED;
   } else if (!pAnal || (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) == pAnal) {
      return SCE_STATUS_MISMATCH;
   } else if (SceCompareNameList(pEdit->AssignedTo, pAnal->AssignedTo)) {
      return SCE_STATUS_GOOD;
   }

   return pAnal->Status;
}


DWORD
CEditTemplate::ComputeStatus(
   PSCE_REGISTRY_VALUE_INFO prvEdit,
   PSCE_REGISTRY_VALUE_INFO prvAnal
   )
{
   //
   // Calculate information.
   //
   if(!prvEdit){
      return SCE_STATUS_NOT_CONFIGURED;
   }

   if(!prvAnal || (PSCE_REGISTRY_VALUE_INFO)ULongToPtr(SCE_NO_VALUE) == prvAnal){
      return SCE_STATUS_ERROR_NOT_AVAILABLE;
   }

   //
   // Calulate base on other information
   //
   if ( !(prvEdit->Value) ) {
      return SCE_STATUS_NOT_CONFIGURED;
   } else if ( (prvAnal->Value == NULL || prvAnal->Value == (LPTSTR)ULongToPtr(SCE_ERROR_VALUE))) {
       return prvAnal->Status;
   } else if ( _wcsicmp(prvEdit->Value, prvAnal->Value) != 0 ) {
       return SCE_STATUS_MISMATCH;
   }

   return SCE_STATUS_GOOD;
}

void
CEditTemplate::LockWriteThrough() {
   ASSERT(!m_bLocked);
   m_bLocked = TRUE;
}

void
CEditTemplate::UnLockWriteThrough() {
   ASSERT(m_bLocked);

   BOOL bSave = m_bLocked;
   m_bLocked = FALSE;

   //
   // Set dirty to save out any still dirty changes that
   // would have been written out had we not been locked
   //
   if ( bSave ) {
       SetDirty(0);
       SetTemplateDefaults();
   }
}

//Bug 212287, Yanggao, 3/20/2001
LPCTSTR CEditTemplate::GetDesc() const
{
   return m_szDesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\delobjs.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       delobjs.cpp
//
//  Contents:   Functions for handling the deletion of template objects
//
//---------------------------------------------------------------------------



#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "wrapper.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT CSnapin::OnDeleteObjects(
   LPDATAOBJECT pDataObj,
   DATA_OBJECT_TYPES cctType,
   MMC_COOKIE cookie,
   LPARAM arg,
   LPARAM param)
{

   if ( 0 == cookie)
      return S_OK;

   if (NULL == pDataObj)
      return S_OK;

   INTERNAL *pAllInternals, *pInternal;
   pAllInternals = ExtractInternalFormat( pDataObj );

   //
   // Find out if this is a mutli select item.
   //
   int iCnt = 1;
   pInternal = pAllInternals;

   if(!pInternal)
      return S_OK;

   if(pAllInternals && pAllInternals->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE)
   {
      pInternal = pAllInternals;
      iCnt = (int)pInternal->m_type;
      pInternal++;
   }

   CFolder *pFolder = m_pSelectedFolder;
   BOOL bAsk = TRUE;

   while( iCnt-- ){
      cookie  = pInternal->m_cookie;
      cctType = pInternal->m_type;

      if ( cctType == CCT_RESULT ) {
         CResult* pResult = (CResult *)cookie;

         RESULT_TYPES rsltType = pResult->GetType();

         if ( rsltType == ITEM_PROF_GROUP ||
              rsltType == ITEM_PROF_REGSD ||
              rsltType == ITEM_PROF_FILESD
              ) {

            if(bAsk ){
               CString str,strFmt;

               //
               // The first cast asks the users if they wish to delete all selected items.
               // the second case asks to delete one file.
               //
               if(bAsk && iCnt > 1 ){
                  str.LoadString( IDS_DELETE_ALL_ITEMS);
               } else {
                  strFmt.LoadString(IDS_QUERY_DELETE);
                  str.Format(strFmt,pResult->GetAttr());
               }

               //
               // Ask the question.  We only want to ask the question once, so set
               // bAsk to false so that we neve enter this block again.
               //
               if ( IDNO == AfxMessageBox((LPCTSTR)str, MB_YESNO, 0) ) {
                  iCnt = 0;
                  continue;
               }
               bAsk = FALSE;
            }

            //
            // free memory associated with the item
            //
            BOOL                  bDelete=FALSE;

            TRACE(_T("CSnapin::OnDeleteObjects-pResult(%x)\n"),pResult);

            if ( rsltType == ITEM_PROF_GROUP ) {

               PSCE_GROUP_MEMBERSHIP pGroup, pParentGrp;
               PEDITTEMPLATE         pTemplate;
               //
               // delete this group from the template
               //
               pTemplate = pResult->GetBaseProfile();

               if ( pResult->GetBase() != 0 && pTemplate && pTemplate->pTemplate &&
                    pTemplate->pTemplate->pGroupMembership ) {

                  for ( pGroup=pTemplate->pTemplate->pGroupMembership, pParentGrp=NULL;
                      pGroup != NULL; pParentGrp=pGroup, pGroup=pGroup->Next ) {

                     if ( pResult->GetBase() == (LONG_PTR)pGroup ) {
                        //
                        // remove this node from the list
                        //
                        if ( pParentGrp ) {
                           pParentGrp->Next = pGroup->Next;
                        } else {
                           pTemplate->pTemplate->pGroupMembership = pGroup->Next;
                        }
                        pGroup->Next = NULL;
                        TRACE(_T("CSnapin::OnDeleteObjects-pGroup(%x)\n"),pGroup);
                        //
                        // free the node
                        //
                        if ( pGroup ) {
                           SceFreeMemory((PVOID)pGroup, SCE_STRUCT_GROUP);
                        }
                        break;
                     }
                  }
               }
               if ( pTemplate ) {
                  (void)pTemplate->SetDirty(AREA_GROUP_MEMBERSHIP);
               }

               bDelete = TRUE;

            } else if ( rsltType == ITEM_PROF_REGSD ||
                        rsltType == ITEM_PROF_FILESD
                        ) {

               PSCE_OBJECT_SECURITY  pObject;
               PSCE_OBJECT_ARRAY     poa;
               DWORD                 i,j;
               PEDITTEMPLATE         pTemplate;
               AREA_INFORMATION      Area;

               pObject = (PSCE_OBJECT_SECURITY)(pResult->GetID());
               pTemplate = pResult->GetBaseProfile();

               if ( rsltType == ITEM_PROF_REGSD ) {
                  poa = pTemplate->pTemplate->pRegistryKeys.pAllNodes;
                  Area = AREA_REGISTRY_SECURITY;
               } else if ( rsltType == ITEM_PROF_FILESD ) {
                  poa = pTemplate->pTemplate->pFiles.pAllNodes;
                  Area = AREA_FILE_SECURITY;
               } else {
                  poa = pTemplate->pTemplate->pDsObjects.pAllNodes;
                  Area = AREA_DS_OBJECTS;
               }

               if ( pResult->GetID() != 0 && pTemplate &&
                    pTemplate->pTemplate && poa ) {

                  i=0;
                  while ( i < poa->Count &&
                          (pResult->GetID() != (LONG_PTR)(poa->pObjectArray[i])) )
                     i++;

                  if ( i < poa->Count ) {
                     //
                     // remove this node from the array, but the arry won't be reallocated
                     //
                     for ( j=i+1; j<poa->Count; j++ ) {
                        poa->pObjectArray[j-1] = poa->pObjectArray[j];
                     }
                     poa->pObjectArray[poa->Count-1] = NULL;

                     poa->Count--;
                     //
                     // free the node
                     //
                     TRACE(_T("CSnapin::OnDeleteObjects-pObject(%x)\n"),pObject);
                     if ( pObject ) {
                        if ( pObject->Name != NULL )
                           LocalFree( pObject->Name );

                        if ( pObject->pSecurityDescriptor != NULL )
                           LocalFree(pObject->pSecurityDescriptor);

                        LocalFree( pObject );
                     }
                  }
               }
               if ( pTemplate ) {
                  (void)pTemplate->SetDirty(Area);
               }

               bDelete = TRUE;
            }
            if ( bDelete ) {
               //
               // delete from the result pane
               //
               HRESULTITEM hItem = NULL;
               if(m_pResult->FindItemByLParam( (LPARAM)pResult, &hItem) == S_OK){
                   m_pResult->DeleteItem(hItem, 0);
               }
                  //
                  // delete the item from result list and free the buffer
                  //
                  POSITION pos=NULL;

                  //if ( FindResult((long)cookie, &pos) ) {
                  //   if ( pos ) {
                  if (m_pSelectedFolder->RemoveResultItem(
                              m_resultItemHandle,
                              pResult
                              ) == ERROR_SUCCESS) {

                  //
                  // delete the node
                  //
                  delete pResult;
               }

               //
               // Notify any other views to also delete the item
               //
               m_pConsole->UpdateAllViews((LPDATAOBJECT)this, (LONG_PTR)pResult, UAV_RESULTITEM_REMOVE);
            }
         }
      }
      pInternal++;
   }

   if( pAllInternals )
   {
      FREE_INTERNAL(pAllInternals);
   }
   return S_OK;
}


CResult* CSnapin::FindResult(MMC_COOKIE cookie, POSITION* thePos)
{
   POSITION pos = NULL; //m_resultItemList.GetHeadPosition();
   POSITION curPos;
   CResult* pResult = NULL;

   if(!m_pSelectedFolder || !m_resultItemHandle)
   {
      return  NULL;
   }

   do {
      curPos = pos;
      if( m_pSelectedFolder->GetResultItem(
                              m_resultItemHandle,
                              pos,
                              &pResult) != ERROR_SUCCESS )
      {
         break;
      }

      // pos is already updated to the next item after this call
      //pResult = m_resultItemList.GetNext(pos);

      // how to compare result item correctly ?
      // for now, let's compare the pointer address.
      if ((MMC_COOKIE)pResult == cookie) 
      {
         if ( thePos ) 
         {
            *thePos = curPos;
         }

         return pResult;
      }
   } while( pos );

   if ( thePos )
      *thePos = NULL;

   return NULL;
}

void
OnDeleteHelper(CRegKey& regkeySCE,CString tmpstr) {
   //
   // replace the "\" with "/" because registry does not take "\" in a single key
   //
   int npos = tmpstr.Find(L'\\');
   while (npos != -1) {
      *(tmpstr.GetBuffer(1)+npos) = L'/';
      npos = tmpstr.Find(L'\\');
   }
   regkeySCE.DeleteSubKey(tmpstr);

   regkeySCE.Close();
}

HRESULT CComponentDataImpl::OnDelete(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   ASSERT(lpDataObject);
   AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

   if ( lpDataObject == NULL ) {
      return S_OK;
   }

   HRESULT hr = S_OK;

   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   if ( pInternal ) {
      MMC_COOKIE cookie = pInternal->m_cookie;

      CFolder* pFolder = (CFolder *)cookie;
      FOLDER_TYPES fldType = pFolder->GetType();

      if ( fldType == LOCATIONS ||
           fldType == PROFILE ) {

         CString str;
         str.Format(IDS_DELETE_CONFIRM,pFolder->GetName() );

         if ( IDYES == AfxMessageBox((LPCTSTR)str, MB_YESNO, 0) ) {
            //
            // delete the nodes and all related children info
            //
            if ( fldType == PROFILE ) {
               if (CAttribute::m_nDialogs > 0) {
                  CString str;
                  AfxFormatString1(str,IDS_CLOSE_PAGES,pFolder->GetName());
                  AfxMessageBox(str,MB_OK);
                  hr = S_FALSE;
               } else {
                  //
                  // delete a single inf file
                  //
                  DeleteFile(pFolder->GetInfFile());

                  hr = DeleteOneTemplateNodes(cookie);
               }

            } else {
               //
               // delete a registry path from SCE
               //
               CRegKey regkeySCE;
               CString tmpstr;
               tmpstr.LoadString(IDS_TEMPLATE_LOCATION_KEY);
               LONG lRes;

               lRes = regkeySCE.Open(HKEY_LOCAL_MACHINE, tmpstr);
               if (lRes == ERROR_SUCCESS) {
                  OnDeleteHelper(regkeySCE,pFolder->GetName());
               }
               //
               // Bug 375324: Delete from HKCU as well as HKLM
               //
               lRes = regkeySCE.Open(HKEY_CURRENT_USER, tmpstr);
               if (lRes == ERROR_SUCCESS) {
                  OnDeleteHelper(regkeySCE,pFolder->GetName());
               }

               MMC_COOKIE FindCookie=FALSE;
               HSCOPEITEM pItemChild;

               pItemChild = NULL;
               hr = m_pScope->GetChildItem(pFolder->GetScopeItem()->ID, &pItemChild, &FindCookie);
               //
               // find a child item
               //
               while ( pItemChild ) {
                  if ( FindCookie ) {
                     //
                     // find a template, delete it
                     //
                     DeleteOneTemplateNodes(FindCookie);
                  }

                  // get next pointer
                  pItemChild = NULL;
                  FindCookie = FALSE;
                  hr = m_pScope->GetChildItem( pFolder->GetScopeItem()->ID, &pItemChild, &FindCookie);

               }
               //
               // delete this location node
               //
               DeleteThisNode(pFolder);

            }

         }
      }
      FREE_INTERNAL(pInternal);
   }

   return hr;
}


HRESULT CComponentDataImpl::DeleteOneTemplateNodes(MMC_COOKIE cookie)
{

   if ( !cookie ) {
      return S_OK;
   }

   CFolder *pFolder = (CFolder *)cookie;

   //
   // delete the template info first, this will delete handles
   // associated with any extension services
   //
   if ( pFolder->GetInfFile() ) {

      DeleteTemplate(pFolder->GetInfFile());

   }
   //
   // delete the scope items and m_scopeItemList (for all children)
   //
   DeleteChildrenUnderNode(pFolder);

   //
   // delete this location node
   //
   DeleteThisNode(pFolder);

   return S_OK;

}

void CComponentDataImpl::DeleteTemplate(CString infFile)
{

   PEDITTEMPLATE pTemplateInfo = NULL;

   CString stri = infFile;
   stri.MakeLower();

   if ( m_Templates.Lookup(stri, pTemplateInfo) ) {

      m_Templates.RemoveKey(stri);

      if ( pTemplateInfo ) {

         if ( pTemplateInfo->pTemplate )
            SceFreeProfileMemory(pTemplateInfo->pTemplate);

         delete pTemplateInfo;
      }
   }
}


void CSnapin::CreateProfilePolicyResultList(MMC_COOKIE cookie,
                                            FOLDER_TYPES type,
                                            PEDITTEMPLATE pSceInfo,
                                            LPDATAOBJECT pDataObj)
{
   if ( !pSceInfo ) {
      return;
   }

   bool bVerify=false;
   UINT i;
   DWORD curVal;
   UINT IdsMax[]={IDS_SYS_LOG_MAX, IDS_SEC_LOG_MAX, IDS_APP_LOG_MAX};
   UINT IdsRet[]={IDS_SYS_LOG_RET, IDS_SEC_LOG_RET, IDS_APP_LOG_RET};
   UINT IdsDays[]={IDS_SYS_LOG_DAYS, IDS_SEC_LOG_DAYS, IDS_APP_LOG_DAYS};
   UINT IdsGuest[]={IDS_SYS_LOG_GUEST, IDS_SEC_LOG_GUEST, IDS_APP_LOG_GUEST};

   switch ( type ) {
      case POLICY_PASSWORD:

         // L"Maximum passage age", L"Days"
         AddResultItem(IDS_MAX_PAS_AGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->MaximumPasswordAge, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Minimum passage age", L"Days"
         AddResultItem(IDS_MIN_PAS_AGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->MinimumPasswordAge, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Minimum passage length", L"Characters"
         AddResultItem(IDS_MIN_PAS_LEN, SCE_NO_VALUE,
                       pSceInfo->pTemplate->MinimumPasswordLength, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Password history size", L"Passwords"
         AddResultItem(IDS_PAS_UNIQUENESS, SCE_NO_VALUE,
                       pSceInfo->pTemplate->PasswordHistorySize, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Password complexity", L""
         AddResultItem(IDS_PAS_COMPLEX, SCE_NO_VALUE,
                       pSceInfo->pTemplate->PasswordComplexity, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

// NT5 new flag
         // L"Clear Text Password", L""
         AddResultItem(IDS_CLEAR_PASSWORD, SCE_NO_VALUE,
                       pSceInfo->pTemplate->ClearTextPassword, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

#if defined(USE_REQ_LOGON_ITEM)
         // L"Require logon to change password", L""
         AddResultItem(IDS_REQ_LOGON, SCE_NO_VALUE,
                       pSceInfo->pTemplate->RequireLogonToChangePassword, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

#endif
         break;

      case POLICY_KERBEROS:
         if (!VerifyKerberosInfo(pSceInfo->pTemplate)) {
            AddResultItem(IDS_CANT_DISPLAY_ERROR_OOM,NULL,NULL,ITEM_OTHER,-1,cookie);
            break;
         }
         AddResultItem(IDS_KERBEROS_MAX_SERVICE,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxServiceAge,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_MAX_CLOCK,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxClockSkew,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_RENEWAL,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxRenewAge,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_MAX_AGE,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxTicketAge,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_VALIDATE_CLIENT,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->TicketValidateClient,
                       ITEM_PROF_BOOL,-1,cookie,bVerify,pSceInfo,pDataObj);
         break;

      case POLICY_LOCKOUT:

         // L"Account lockout count", L"Attempts"
         AddResultItem(IDS_LOCK_COUNT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->LockoutBadCount, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Reset lockout count after", L"Minutes"
         AddResultItem(IDS_LOCK_RESET_COUNT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->ResetLockoutCount, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Lockout duration", L"Minutes"
         AddResultItem(IDS_LOCK_DURATION, SCE_NO_VALUE,
                       pSceInfo->pTemplate->LockoutDuration, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         break;

      case POLICY_AUDIT:

         //
         // Event auditing
         //
         //        if ( pSceInfo->pTemplate->EventAuditingOnOff)
         //           curVal = 1;
         //        else
         //           curVal = 0;
         // L"Event Auditing Mode",
         //        AddResultItem(IDS_EVENT_ON, SCE_NO_VALUE,
         //                      pSceInfo->pTemplate->EventAuditingOnOff, ITEM_PROF_BON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit system events"
         AddResultItem(IDS_SYSTEM_EVENT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditSystemEvents, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit logon events"
         AddResultItem(IDS_LOGON_EVENT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditLogonEvents, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Object Access"
         AddResultItem(IDS_OBJECT_ACCESS, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditObjectAccess, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Privilege Use"
         AddResultItem(IDS_PRIVILEGE_USE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditPrivilegeUse, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit policy change"
         AddResultItem(IDS_POLICY_CHANGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditPolicyChange, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Account Manage"
         AddResultItem(IDS_ACCOUNT_MANAGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditAccountManage, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit process tracking"
         AddResultItem(IDS_PROCESS_TRACK, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditProcessTracking, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit directory service access"
         AddResultItem(IDS_DIRECTORY_ACCESS, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditDSAccess, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Account Logon"
         AddResultItem(IDS_ACCOUNT_LOGON, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditAccountLogon, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         break;

      case POLICY_OTHER:

         //
         // Account Logon category
         //
         // L"Force logoff when logon hour expire", L""
         AddResultItem(IDS_FORCE_LOGOFF, SCE_NO_VALUE,
                       pSceInfo->pTemplate->ForceLogoffWhenHourExpire, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Accounts: Administrator account status", L""
         AddResultItem(IDS_ENABLE_ADMIN, SCE_NO_VALUE,
                       pSceInfo->pTemplate->EnableAdminAccount, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Accounts: Guest account status", L""
         AddResultItem(IDS_ENABLE_GUEST, SCE_NO_VALUE,
                       pSceInfo->pTemplate->EnableGuestAccount, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"New Administrator account name"
         AddResultItem(IDS_NEW_ADMIN, 0,
                       (LONG_PTR)(LPCTSTR)pSceInfo->pTemplate->NewAdministratorName,
                       ITEM_PROF_SZ, -1, cookie,bVerify,pSceInfo,pDataObj);

         // L"New Guest account name"
         AddResultItem(IDS_NEW_GUEST, NULL,
                       (LONG_PTR)(LPCTSTR)pSceInfo->pTemplate->NewGuestName,
                       ITEM_PROF_SZ, -1, cookie,bVerify,pSceInfo,pDataObj);

         // L"Network access: Allow anonymous SID/Name translation"
         AddResultItem(IDS_LSA_ANON_LOOKUP, SCE_NO_VALUE,
                       pSceInfo->pTemplate->LSAAnonymousNameLookup, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         CreateProfileRegValueList(cookie, pSceInfo, pDataObj);

         break;

      case POLICY_LOG:
         //
         // Event Log setting
         //
         for ( i=0; i<3; i++) {

            // L"... Log Maximum Size", L"KBytes"
            AddResultItem(IdsMax[i], SCE_NO_VALUE,
                          pSceInfo->pTemplate->MaximumLogSize[i], ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

            // L"... Log Retention Method",
            AddResultItem(IdsRet[i], SCE_NO_VALUE,
                          pSceInfo->pTemplate->AuditLogRetentionPeriod[i], ITEM_PROF_RET, -1, cookie, bVerify,pSceInfo,pDataObj);

			//
			// AuditLogRetentionPeriod has already been interpreted by the 
			// SCE engine into the RetentionDays setting. So, the RSOP UI 
			// should display RetentionDays if it exists in the WMI db.
			//

//            if ( pSceInfo->pTemplate->AuditLogRetentionPeriod[i] == 1) {
//               curVal = pSceInfo->pTemplate->RetentionDays[i];
//            } else {
//               curVal = SCE_NO_VALUE;
//            }
            // L"... Log Retention days", "days"
//            AddResultItem(IdsDays[i], SCE_NO_VALUE, curVal, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);
            AddResultItem(IdsDays[i], SCE_NO_VALUE, 
					pSceInfo->pTemplate->RetentionDays[i], ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

            // L"RestrictGuestAccess", L""
            AddResultItem(IdsGuest[i], SCE_NO_VALUE,
                          pSceInfo->pTemplate->RestrictGuestAccess[i], ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);
         }

         break;
   }

}


void
CSnapin::CreateAnalysisPolicyResultList(MMC_COOKIE cookie,
                                        FOLDER_TYPES type,
                                        PEDITTEMPLATE pSceInfo,
                                        PEDITTEMPLATE pBase,
                                        LPDATAOBJECT pDataObj )
{
   if ( !pSceInfo || !pBase ) {
      AddResultItem(IDS_ERROR_NO_ANALYSIS_INFO,NULL,NULL,ITEM_OTHER,-1,cookie);
      return;
   }

   bool bVerify=true;
   UINT i;
   UINT IdsMax[]={IDS_SYS_LOG_MAX, IDS_SEC_LOG_MAX, IDS_APP_LOG_MAX};
   UINT IdsRet[]={IDS_SYS_LOG_RET, IDS_SEC_LOG_RET, IDS_APP_LOG_RET};
   UINT IdsDays[]={IDS_SYS_LOG_DAYS, IDS_SEC_LOG_DAYS, IDS_APP_LOG_DAYS};
   UINT IdsGuest[]={IDS_SYS_LOG_GUEST, IDS_SEC_LOG_GUEST, IDS_APP_LOG_GUEST};

   DWORD status;
   LONG_PTR setting;

   switch ( type ) {
      case POLICY_PASSWORD_ANALYSIS:
         //
         // password category
         //
         // L"Maximum passage age", L"Days"
         AddResultItem(IDS_MAX_PAS_AGE,
                       pSceInfo->pTemplate->MaximumPasswordAge,
                       pBase->pTemplate->MaximumPasswordAge,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

            // L"Minimum passage age", L"Days"
         AddResultItem(IDS_MIN_PAS_AGE,
                       pSceInfo->pTemplate->MinimumPasswordAge,
                       pBase->pTemplate->MinimumPasswordAge,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Minimum passage length", L"Characters"
         AddResultItem(IDS_MIN_PAS_LEN,
                       pSceInfo->pTemplate->MinimumPasswordLength,
                       pBase->pTemplate->MinimumPasswordLength,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password history size", L"Passwords"
         AddResultItem(IDS_PAS_UNIQUENESS,
                       pSceInfo->pTemplate->PasswordHistorySize,
                       pBase->pTemplate->PasswordHistorySize,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password complexity", L""
         AddResultItem(IDS_PAS_COMPLEX,
                       pSceInfo->pTemplate->PasswordComplexity,
                       pBase->pTemplate->PasswordComplexity,
                       ITEM_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Clear Text Password", L""
         AddResultItem(IDS_CLEAR_PASSWORD,
                       pSceInfo->pTemplate->ClearTextPassword,
                       pBase->pTemplate->ClearTextPassword,
                       ITEM_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#if defined(USE_REQ_LOGON_ITEM)
         // L"Require logon to change password", L""
         AddResultItem(IDS_REQ_LOGON,
                       pSceInfo->pTemplate->RequireLogonToChangePassword,
                       pBase->pTemplate->RequireLogonToChangePassword,
                       ITEM_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#endif
         break;
      case POLICY_KERBEROS_ANALYSIS:
         if (!VerifyKerberosInfo(pSceInfo->pTemplate) ||
             !VerifyKerberosInfo(pBase->pTemplate)) {
            AddResultItem(IDS_CANT_DISPLAY_ERROR_OOM,NULL,NULL,ITEM_OTHER,-1,cookie);
            break;
         }
         AddResultItem(IDS_KERBEROS_MAX_SERVICE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxServiceAge,
                       pBase->pTemplate->pKerberosInfo->MaxServiceAge,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_CLOCK,
                       pSceInfo->pTemplate->pKerberosInfo->MaxClockSkew,
                       pBase->pTemplate->pKerberosInfo->MaxClockSkew,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_VALIDATE_CLIENT,
                       pSceInfo->pTemplate->pKerberosInfo->TicketValidateClient,
                       pBase->pTemplate->pKerberosInfo->TicketValidateClient,
                       ITEM_BOOL,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_RENEWAL,
                       pSceInfo->pTemplate->pKerberosInfo->MaxRenewAge,
                       pBase->pTemplate->pKerberosInfo->MaxRenewAge,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_AGE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxTicketAge,
                       pBase->pTemplate->pKerberosInfo->MaxTicketAge,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case POLICY_LOCKOUT_ANALYSIS:
         //
         // Account Lockout category
         //
         // L"Account lockout count", L"Attempts"
         AddResultItem(IDS_LOCK_COUNT, pSceInfo->pTemplate->LockoutBadCount,
                       pBase->pTemplate->LockoutBadCount, ITEM_DW, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Reset lockout count after", L"Minutes"
         AddResultItem(IDS_LOCK_RESET_COUNT, pSceInfo->pTemplate->ResetLockoutCount,
                       pBase->pTemplate->ResetLockoutCount, ITEM_DW, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Lockout duration", L"Minutes"
         AddResultItem(IDS_LOCK_DURATION, pSceInfo->pTemplate->LockoutDuration,
                       pBase->pTemplate->LockoutDuration, ITEM_DW, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case POLICY_AUDIT_ANALYSIS:
         //
         // Event auditing
         //
         // L"Event Auditing Mode",
         //        AddResultItem(IDS_EVENT_ON, pSceInfo->pTemplate->EventAuditingOnOff,
         //                   pBase->pTemplate->EventAuditingOnOff, ITEM_BON, 1, cookie, bVerify);

         // L"Audit system events"
         AddResultItem(IDS_SYSTEM_EVENT, pSceInfo->pTemplate->AuditSystemEvents,
                       pBase->pTemplate->AuditSystemEvents, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit logon events"
         AddResultItem(IDS_LOGON_EVENT, pSceInfo->pTemplate->AuditLogonEvents,
                       pBase->pTemplate->AuditLogonEvents, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Object Access"
         AddResultItem(IDS_OBJECT_ACCESS, pSceInfo->pTemplate->AuditObjectAccess,
                       pBase->pTemplate->AuditObjectAccess, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Privilege Use"
         AddResultItem(IDS_PRIVILEGE_USE, pSceInfo->pTemplate->AuditPrivilegeUse,
                       pBase->pTemplate->AuditPrivilegeUse, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit policy change"
         AddResultItem(IDS_POLICY_CHANGE, pSceInfo->pTemplate->AuditPolicyChange,
                       pBase->pTemplate->AuditPolicyChange, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Account Manage"
         AddResultItem(IDS_ACCOUNT_MANAGE, pSceInfo->pTemplate->AuditAccountManage,
                       pBase->pTemplate->AuditAccountManage, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit process tracking"
         AddResultItem(IDS_PROCESS_TRACK, pSceInfo->pTemplate->AuditProcessTracking,
                       pBase->pTemplate->AuditProcessTracking, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit directory access "
         AddResultItem(IDS_DIRECTORY_ACCESS, pSceInfo->pTemplate->AuditDSAccess,
                       pBase->pTemplate->AuditDSAccess, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit account logon"
         AddResultItem(IDS_ACCOUNT_LOGON, pSceInfo->pTemplate->AuditAccountLogon,
                       pBase->pTemplate->AuditAccountLogon, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane
         break;

      case POLICY_LOG_ANALYSIS:

         //
         // Event Log setting
         //
         for ( i=0; i<3; i++) {
            // Maximum Log Size
            AddResultItem(IdsMax[i], pSceInfo->pTemplate->MaximumLogSize[i],
                          pBase->pTemplate->MaximumLogSize[i], ITEM_DW, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"... Log Retention Method",
            AddResultItem(IdsRet[i], pSceInfo->pTemplate->AuditLogRetentionPeriod[i],
                          pBase->pTemplate->AuditLogRetentionPeriod[i], ITEM_RET, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            if ( pSceInfo->pTemplate->AuditLogRetentionPeriod[i] == 1 ||
                 pBase->pTemplate->AuditLogRetentionPeriod[i] == 1)
               // L"... Log Retention days", "days"
               AddResultItem(IdsDays[i], pSceInfo->pTemplate->RetentionDays[i],
                             pBase->pTemplate->RetentionDays[i], ITEM_DW, 1, cookie, bVerify,
                             pBase,               //The template to save this attribute in
                             pDataObj);           //The data object for the scope note who owns the result pane

            // L"RestrictGuestAccess", L""
            AddResultItem(IdsGuest[i], pSceInfo->pTemplate->RestrictGuestAccess[i],
                          pBase->pTemplate->RestrictGuestAccess[i], ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane
         }

         break;

      case POLICY_OTHER_ANALYSIS:

            // L"Force logoff when logon hour expire", L""
            AddResultItem(IDS_FORCE_LOGOFF, pSceInfo->pTemplate->ForceLogoffWhenHourExpire,
                          pBase->pTemplate->ForceLogoffWhenHourExpire, ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"Accounts: Administrator account status", L""
            AddResultItem(IDS_ENABLE_ADMIN, pSceInfo->pTemplate->EnableAdminAccount,
                          pBase->pTemplate->EnableAdminAccount, ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"Accounts: Guest account status", L""
            AddResultItem(IDS_ENABLE_GUEST, pSceInfo->pTemplate->EnableGuestAccount,
                          pBase->pTemplate->EnableGuestAccount, ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

          // L"Network access: Allow anonymous SID/Name translation"
          AddResultItem(IDS_LSA_ANON_LOOKUP, pSceInfo->pTemplate->LSAAnonymousNameLookup,
                        pBase->pTemplate->LSAAnonymousNameLookup, ITEM_BOOL, 1, cookie, bVerify,
                        pBase,               //The template to save this attribute in
                        pDataObj);           //The data object for the scope note who owns the result pane


          // L"New Administrator account name"
         setting = (LONG_PTR)(pSceInfo->pTemplate->NewAdministratorName);
         if ( !pBase->pTemplate->NewAdministratorName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pSceInfo->pTemplate->NewAdministratorName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pBase->pTemplate->NewAdministratorName);
            status = SCE_STATUS_GOOD;
         }
         AddResultItem(IDS_NEW_ADMIN, setting,
                       (LONG_PTR)(LPCTSTR)pBase->pTemplate->NewAdministratorName,
                       ITEM_SZ, status, cookie,false,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"New Guest account name"
         setting = (LONG_PTR)(pSceInfo->pTemplate->NewGuestName);
         if ( !pBase->pTemplate->NewGuestName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pSceInfo->pTemplate->NewGuestName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pBase->pTemplate->NewGuestName);
            status = SCE_STATUS_GOOD;
         }
         AddResultItem(IDS_NEW_GUEST, setting,
                       (LONG_PTR)(LPCTSTR)pBase->pTemplate->NewGuestName,
                       ITEM_SZ, status, cookie,false,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         CreateAnalysisRegValueList(cookie, pSceInfo, pBase, pDataObj,ITEM_REGVALUE);

         break;
   }
}

void
CSnapin::CreateLocalPolicyResultList(MMC_COOKIE cookie,
                                     FOLDER_TYPES type,
                                     PEDITTEMPLATE pLocal,
                                     PEDITTEMPLATE pEffective,
                                     LPDATAOBJECT pDataObj )
{
   if ( !pLocal || !pEffective ) {
      AddResultItem(IDS_ERROR_NO_LOCAL_POLICY_INFO,NULL,NULL,ITEM_OTHER,-1,cookie);
      return;
   }

   bool bVerify= false;
   UINT i;
   UINT IdsMax[]={IDS_SYS_LOG_MAX, IDS_SEC_LOG_MAX, IDS_APP_LOG_MAX};
   UINT IdsRet[]={IDS_SYS_LOG_RET, IDS_SEC_LOG_RET, IDS_APP_LOG_RET};
   UINT IdsDays[]={IDS_SYS_LOG_DAYS, IDS_SEC_LOG_DAYS, IDS_APP_LOG_DAYS};
   UINT IdsGuest[]={IDS_SYS_LOG_GUEST, IDS_SEC_LOG_GUEST, IDS_APP_LOG_GUEST};

   DWORD status;
   LONG_PTR setting;

   switch ( type ) {
      case LOCALPOL_PASSWORD:
         //
         // password category
         //
         // L"Maximum passage age", L"Days"
         AddResultItem(IDS_MAX_PAS_AGE,
                       pEffective->pTemplate->MaximumPasswordAge,
                       pLocal->pTemplate->MaximumPasswordAge,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

            // L"Minimum passage age", L"Days"
         AddResultItem(IDS_MIN_PAS_AGE,
                       pEffective->pTemplate->MinimumPasswordAge,
                       pLocal->pTemplate->MinimumPasswordAge,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Minimum passage length", L"Characters"
         AddResultItem(IDS_MIN_PAS_LEN,
                       pEffective->pTemplate->MinimumPasswordLength,
                       pLocal->pTemplate->MinimumPasswordLength,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password history size", L"Passwords"
         AddResultItem(IDS_PAS_UNIQUENESS,
                       pEffective->pTemplate->PasswordHistorySize,
                       pLocal->pTemplate->PasswordHistorySize,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password complexity", L""
         AddResultItem(IDS_PAS_COMPLEX,
                       pEffective->pTemplate->PasswordComplexity,
                       pLocal->pTemplate->PasswordComplexity,
                       ITEM_LOCALPOL_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Clear Text Password", L""
         AddResultItem(IDS_CLEAR_PASSWORD,
                       pEffective->pTemplate->ClearTextPassword,
                       pLocal->pTemplate->ClearTextPassword,
                       ITEM_LOCALPOL_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#if defined(USE_REQ_LOGON_ITEM)
         // L"Require logon to change password", L""
         AddResultItem(IDS_REQ_LOGON,
                       pEffective->pTemplate->RequireLogonToChangePassword,
                       pLocal->pTemplate->RequireLogonToChangePassword,
                       ITEM_LOCALPOL_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#endif
         break;

      case LOCALPOL_KERBEROS:
         if (!VerifyKerberosInfo(pLocal->pTemplate) ||
             !VerifyKerberosInfo(pEffective->pTemplate)) {
            AddResultItem(IDS_CANT_DISPLAY_ERROR_OOM,NULL,NULL,ITEM_OTHER,-1,cookie);
            break;
         }
         AddResultItem(IDS_KERBEROS_MAX_SERVICE,
                       pEffective->pTemplate->pKerberosInfo->MaxServiceAge,
                       pLocal->pTemplate->pKerberosInfo->MaxServiceAge,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_CLOCK,
                       pEffective->pTemplate->pKerberosInfo->MaxClockSkew,
                       pLocal->pTemplate->pKerberosInfo->MaxClockSkew,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_VALIDATE_CLIENT,
                       pEffective->pTemplate->pKerberosInfo->TicketValidateClient,
                       pLocal->pTemplate->pKerberosInfo->TicketValidateClient,
                       ITEM_LOCALPOL_BOOL,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_RENEWAL,
                       pEffective->pTemplate->pKerberosInfo->MaxRenewAge,
                       pLocal->pTemplate->pKerberosInfo->MaxRenewAge,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_AGE,
                       pEffective->pTemplate->pKerberosInfo->MaxTicketAge,
                       pLocal->pTemplate->pKerberosInfo->MaxTicketAge,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case LOCALPOL_LOCKOUT:
         //
         // Account Lockout category
         //
         // L"Account lockout count", L"Attempts"
         AddResultItem(IDS_LOCK_COUNT,
                       pEffective->pTemplate->LockoutBadCount,
                       pLocal->pTemplate->LockoutBadCount,ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Reset lockout count after", L"Minutes"
         AddResultItem(IDS_LOCK_RESET_COUNT,
                       pEffective->pTemplate->ResetLockoutCount,
                       pLocal->pTemplate->ResetLockoutCount,
                       ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Lockout duration", L"Minutes"
         AddResultItem(IDS_LOCK_DURATION,
                       pEffective->pTemplate->LockoutDuration,
                       pLocal->pTemplate->LockoutDuration,
                       ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case LOCALPOL_AUDIT:
         //
         // Event auditing
         //
         // L"Event Auditing Mode",
         //        AddResultItem(IDS_EVENT_ON, pLocal->pTemplate->EventAuditingOnOff,
         //                   pEffective->pTemplate->EventAuditingOnOff, ITEM_LOCALPOL_BON, 1, cookie, bVerify);

         // L"Audit system events"
         AddResultItem(IDS_SYSTEM_EVENT,
                       pEffective->pTemplate->AuditSystemEvents,
                       pLocal->pTemplate->AuditSystemEvents,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit logon events"
         AddResultItem(IDS_LOGON_EVENT,
                       pEffective->pTemplate->AuditLogonEvents,
                       pLocal->pTemplate->AuditLogonEvents,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Object Access"
         AddResultItem(IDS_OBJECT_ACCESS,
                       pEffective->pTemplate->AuditObjectAccess,
                       pLocal->pTemplate->AuditObjectAccess,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Privilege Use"
         AddResultItem(IDS_PRIVILEGE_USE,
                       pEffective->pTemplate->AuditPrivilegeUse,
                       pLocal->pTemplate->AuditPrivilegeUse,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit policy change"
         AddResultItem(IDS_POLICY_CHANGE,
                       pEffective->pTemplate->AuditPolicyChange,
                       pLocal->pTemplate->AuditPolicyChange,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Account Manage"
         AddResultItem(IDS_ACCOUNT_MANAGE,
                       pEffective->pTemplate->AuditAccountManage,
                       pLocal->pTemplate->AuditAccountManage,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit process tracking"
         AddResultItem(IDS_PROCESS_TRACK,
                       pEffective->pTemplate->AuditProcessTracking,
                       pLocal->pTemplate->AuditProcessTracking,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit directory access "
         AddResultItem(IDS_DIRECTORY_ACCESS,
                       pEffective->pTemplate->AuditDSAccess,
                       pLocal->pTemplate->AuditDSAccess,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit account logon"
         AddResultItem(IDS_ACCOUNT_LOGON,
                       pEffective->pTemplate->AuditAccountLogon,
                       pLocal->pTemplate->AuditAccountLogon,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane
         break;

      case LOCALPOL_LOG:

         //
         // Event Log setting
         //
         for ( i=0; i<3; i++) {
            // Maximum Log Size
            AddResultItem(IdsMax[i],
                          pEffective->pTemplate->MaximumLogSize[i],
                          pLocal->pTemplate->MaximumLogSize[i],
                          ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"... Log Retention Method",
            AddResultItem(IdsRet[i],
                          pEffective->pTemplate->AuditLogRetentionPeriod[i],
                          pLocal->pTemplate->AuditLogRetentionPeriod[i],
                          ITEM_LOCALPOL_RET, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            if ( pLocal->pTemplate->AuditLogRetentionPeriod[i] == 1 ||
                 pEffective->pTemplate->AuditLogRetentionPeriod[i] == 1)
               // L"... Log Retention days", "days"
               AddResultItem(IdsDays[i],
                             pEffective->pTemplate->RetentionDays[i],
                             pLocal->pTemplate->RetentionDays[i],
                             ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                             pLocal,               //The template to save this attribute in
                             pDataObj);           //The data object for the scope note who owns the result pane

            // L"RestrictGuestAccess", L""
            AddResultItem(IdsGuest[i],
                          pEffective->pTemplate->RestrictGuestAccess[i],
                          pLocal->pTemplate->RestrictGuestAccess[i],
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane
         }

         break;

      case LOCALPOL_OTHER:

            // L"Force logoff when logon hour expire", L""
         AddResultItem(IDS_FORCE_LOGOFF,
                          pEffective->pTemplate->ForceLogoffWhenHourExpire,
                          pLocal->pTemplate->ForceLogoffWhenHourExpire,
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane


            // L"Accounts: Administrator account status", L""
         AddResultItem(IDS_ENABLE_ADMIN,
                          pEffective->pTemplate->EnableAdminAccount,
                          pLocal->pTemplate->EnableAdminAccount,
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane


            // L"Accounts: Guest account status", L""
         AddResultItem(IDS_ENABLE_GUEST,
                          pEffective->pTemplate->EnableGuestAccount,
                          pLocal->pTemplate->EnableGuestAccount,
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

         // L"Network access: Allow anonymous SID/Name translation"
         AddResultItem(IDS_LSA_ANON_LOOKUP,
                       pEffective->pTemplate->LSAAnonymousNameLookup,
                       pLocal->pTemplate->LSAAnonymousNameLookup,
                       ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"New Administrator account name"
         setting = (LONG_PTR)(pEffective->pTemplate->NewAdministratorName);
         if ( !pLocal->pTemplate->NewAdministratorName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pEffective->pTemplate->NewAdministratorName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pEffective->pTemplate->NewAdministratorName);
            status = SCE_STATUS_GOOD;
         }

         AddResultItem(IDS_NEW_ADMIN, setting,
                       (LONG_PTR)(LPCTSTR)pLocal->pTemplate->NewAdministratorName,
                       ITEM_LOCALPOL_SZ, status, cookie,false,
                       pLocal,              //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"New Guest account name"
         setting = (LONG_PTR)(pEffective->pTemplate->NewGuestName);
         if ( !pLocal->pTemplate->NewGuestName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pEffective->pTemplate->NewGuestName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pEffective->pTemplate->NewGuestName);
            status = SCE_STATUS_GOOD;
         }
         AddResultItem(IDS_NEW_GUEST, setting,
                       (LONG_PTR)(LPCTSTR)pLocal->pTemplate->NewGuestName,
                       ITEM_LOCALPOL_SZ, status, cookie,false,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         CreateAnalysisRegValueList(cookie, pEffective, pLocal, pDataObj,ITEM_LOCALPOL_REGVALUE);

         break;

      case LOCALPOL_PRIVILEGE: {
         // find in the current setting list
          CString strDisp;
          TCHAR szPriv[255];
          TCHAR szDisp[255];
          DWORD cbDisp;
          DWORD dwMatch;
          PSCE_PRIVILEGE_ASSIGNMENT pPrivLocal;
          PSCE_PRIVILEGE_ASSIGNMENT pPrivEffective;

          for ( int i=0; i<cPrivCnt; i++ ) {

             cbDisp = 255;
             if ( SCESTATUS_SUCCESS == SceLookupPrivRightName(i,szPriv, (PINT)&cbDisp) ) {
                 // find the local setting
                 for (pPrivLocal=pLocal->pTemplate->OtherInfo.sap.pPrivilegeAssignedTo;
                     pPrivLocal!=NULL;
                     pPrivLocal=pPrivLocal->Next) {

                     if ( _wcsicmp(szPriv, pPrivLocal->Name) == 0 ) {
                         break;
                     }
                 }

                // find the effective setting
                for (pPrivEffective=pEffective->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
                    pPrivEffective!=NULL;
                    pPrivEffective=pPrivEffective->Next) {

                    if ( _wcsicmp(szPriv, pPrivEffective->Name) == 0 ) {
                        break;
                    }
                }

                cbDisp = 255;
                GetRightDisplayName(NULL,(LPCTSTR)szPriv,szDisp,&cbDisp);

                //
                // Status field is not loaded for local policy mode, except for not configured
                //
                dwMatch = CEditTemplate::ComputeStatus( pPrivLocal, pPrivEffective );

                CResult *pResult = AddResultItem(szDisp,              // The name of the attribute being added
                              (LONG_PTR)pPrivEffective,  // The local policy setting of the attribute
                              (LONG_PTR)pPrivLocal,      // The effective policy setting of the attribute
                              ITEM_LOCALPOL_PRIVS,       // The type of of the attribute's data
                              dwMatch,                   // The mismatch status of the attribute
                              cookie,                    // The cookie for the result item pane
                              FALSE,                     // True if the setting is set only if it differs from base (so copy the data)
                              szPriv,                    // The units the attribute is set in
                              0,                         // An id to let us know where to save this attribute
                              pLocal,                    // The template to save this attribute in
                              pDataObj);                 // The data object for the scope note who owns the result pane
             }
         }

         break;
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     TransferAnalysisName
//
//  Synopsis:   Copy a name data from the last inspection information to the
//              computer template
//
//  Arguments:  [dwItem]  - The id of the item to copy
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void
CSnapin::TransferAnalysisName(LONG_PTR dwItem)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;
   PSCE_PROFILE_INFO pBaseInfo;

   pet = GetTemplate(GT_LAST_INSPECTION,AREA_SECURITY_POLICY);
   if (!pet) {
      return;
   }
   pProfileInfo = pet->pTemplate;

   pet = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);
   if (!pet) {
      return;
   }
   pBaseInfo = pet->pTemplate;

   switch ( dwItem ) {
      case IDS_NEW_GUEST:
         if ( pProfileInfo->NewGuestName ) {
            LocalFree(pProfileInfo->NewGuestName);
         }

         pProfileInfo->NewGuestName = pBaseInfo->NewGuestName;
         pBaseInfo->NewGuestName = NULL;

         break;
      case IDS_NEW_ADMIN:
         if ( pProfileInfo->NewAdministratorName ) {
            LocalFree(pProfileInfo->NewAdministratorName);
         }

         pProfileInfo->NewAdministratorName = pBaseInfo->NewAdministratorName;
         pBaseInfo->NewAdministratorName = NULL;
         break;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\getuser.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       getuser.h
//
//  Contents:   definition of CGetUser
//                              
//----------------------------------------------------------------------------
#ifndef GETUSER_H
#define GETUSER_H

#define SCE_SHOW_USERS            0x1
#define SCE_SHOW_GROUPS           0x2
#define SCE_SHOW_ALIASES          0x4
#define SCE_SHOW_ALL              0x7
#define SCE_SHOW_LOCALONLY        0x8
#define SCE_SHOW_DOMAINGROUPS     0x10
#define SCE_SHOW_SINGLESEL        0x20

#define SCE_SHOW_BUILTIN          0x40
#define SCE_SHOW_WELLKNOWN        0x80
#define SCE_SHOW_GLOBAL           0x100
#define SCE_SHOW_LOCALGROUPS      0x200

#define SCE_SHOW_SCOPE_LOCAL      0x400
#define SCE_SHOW_SCOPE_DOMAIN     0x800
#define SCE_SHOW_SCOPE_DIRECTORY  0x1000
#define SCE_SHOW_SCOPE_ALL        (SCE_SHOW_SCOPE_LOCAL|SCE_SHOW_SCOPE_DOMAIN|SCE_SHOW_SCOPE_DIRECTORY)

#define SCE_SHOW_DIFF_MODE_OFF_DC 0x2000


typedef struct _tag_WSCE_ACCOUNTINFO
{
    LPTSTR pszName;
    SID_NAME_USE sidType;
} WSCE_ACCOUNTINFO, *PWSCE_ACCOUNTINFO;

class CGetUser
{
public:
    PSCE_NAME_LIST GetUsers();
    BOOL Create(HWND hwnd, DWORD nShowFlag);
    CGetUser();
    virtual ~CGetUser();

    void SetServer( LPCTSTR pszServerName )
      { m_pszServerName = pszServerName; };

protected:
    HINSTANCE m_hinstNetUI;
    PSCE_NAME_LIST m_pNameList;

public:
    static SID_NAME_USE
    GetAccountType(LPCTSTR pszName);

protected:
    LPCTSTR m_pszServerName;
    static CTypedPtrArray<CPtrArray, PWSCE_ACCOUNTINFO> m_aKnownAccounts;
};

#endif // GETUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\getuser.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       getuser.cpp
//
//  Contents:   implementation of CGetUser
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "GetUser.h"
#include "util.h"
#include "wrapper.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

const TCHAR c_szSep[]               = TEXT("\\");

//////////////////////////////////////////////////////////////////////
// CGetUser Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CTypedPtrArray<CPtrArray, PWSCE_ACCOUNTINFO> CGetUser::m_aKnownAccounts;

BOOL IsDomainAccountSid( PSID pSid )
{
   if ( pSid == NULL ) {
     return(FALSE);
   }

   if ( !IsValidSid(pSid) ) {
     return(FALSE);
   }

   PISID ISid = (PISID)pSid;

   if ( ISid->IdentifierAuthority.Value[5] != 5 ||
       ISid->IdentifierAuthority.Value[0] != 0 ||
       ISid->IdentifierAuthority.Value[1] != 0 ||
       ISid->IdentifierAuthority.Value[2] != 0 ||
       ISid->IdentifierAuthority.Value[3] != 0 ||
       ISid->IdentifierAuthority.Value[4] != 0 ) {
      //
      // this is not a account from account domain
      //
      return(FALSE);
   }

   if ( ISid->SubAuthorityCount == 0 ||
      ISid->SubAuthority[0] != SECURITY_NT_NON_UNIQUE ) {
      return(FALSE);
   }

   return(TRUE);
}


/*------------------------------------------------------------------------------------------------------------
CGetUser::GetAccountType

Synopsis:   Returns the type of the user account.  Call this function with a NULL to remove saved
            account name information.

Arguments:  [pszName]   - The account name old NT4 format

Returns:    One of the enumerated Sid types.
------------------------------------------------------------------------------------------------------------*/

SID_NAME_USE
CGetUser::GetAccountType(LPCTSTR pszName)
{
    if(!pszName){
        // Delete the whole list.
        for(int i = 0; i < m_aKnownAccounts.GetSize(); i++){
            PWSCE_ACCOUNTINFO pAccount = m_aKnownAccounts[i];

            if(pAccount){
                if(pAccount->pszName){
                    LocalFree(pAccount->pszName);
                }

                LocalFree(pAccount);
            }

        }
        m_aKnownAccounts.RemoveAll();

        return SidTypeUnknown;
    }

    // Check to see if we've already got the account.
    for(int i = 0; i < m_aKnownAccounts.GetSize(); i++){
        if( !lstrcmpi( m_aKnownAccounts[i]->pszName, pszName) ){
            return m_aKnownAccounts[i]->sidType;
        }
    }

    PSID            sid         = NULL;
    LPTSTR          pszDomain   = NULL;
    DWORD           cbSid       = 0,
                    cbRefDomain = 0;
    SID_NAME_USE    type        = SidTypeUnknown;

    LookupAccountName(
            NULL,
            pszName,
            sid,
            &cbSid,
            NULL,
            &cbRefDomain,
            &type
            );

    if(cbSid){
        sid = (PSID)LocalAlloc(0, cbSid);
        if(!sid){
            return SidTypeUnknown;
        }
        pszDomain = (LPTSTR)LocalAlloc(0, (cbRefDomain + 1) * sizeof(TCHAR));
        if(!pszDomain){
            cbRefDomain = 0;
        }

        type = SidTypeUser;
        if( LookupAccountName(
                NULL,
                pszName,
                sid,
                &cbSid,
                pszDomain,
                &cbRefDomain,
                &type
                ) ){

            //
            // Add the account name to the list.
            //
            PWSCE_ACCOUNTINFO pNew = (PWSCE_ACCOUNTINFO)LocalAlloc(0, sizeof(WSCE_ACCOUNTINFO));
            if(pNew){
                pNew->pszName = (LPTSTR)LocalAlloc(0, (lstrlen( pszName ) + 1) * sizeof(TCHAR));
                if(!pNew->pszName){
                    LocalFree(pNew);
                    LocalFree(sid);
                    if ( pszDomain ) {
                        LocalFree(pszDomain);
                    }
                    return SidTypeUnknown;
                }
                lstrcpy(pNew->pszName, pszName);
                pNew->sidType = type;

                m_aKnownAccounts.Add(pNew);
            }
        }

        LocalFree(sid);
        if(pszDomain){
            LocalFree(pszDomain);
        }

    }
    return type;
}


CGetUser::CGetUser()
{
    m_pszServerName = NULL;

   m_pNameList = NULL;
}

CGetUser::~CGetUser()
{
   PSCE_NAME_LIST p;

   while(m_pNameList) {
      p=m_pNameList;
      m_pNameList = m_pNameList->Next;
      LocalFree(p->Name);
      LocalFree(p);
   }
}

BOOL CGetUser::Create(HWND hwnd, DWORD nShowFlag)
{
   if( m_pNameList ) {
      return FALSE;
   }
   HRESULT hr;
   IDsObjectPicker *pDsObjectPicker;
   BOOL bRet = TRUE;
   PSCE_NAME_LIST pName;
   BOOL bDC = IsDomainController( m_pszServerName );
   BOOL bHasADsPath;
   //
   // Initialize and get the Object picker interface.
   //
   hr = CoInitialize(NULL);
   if (!SUCCEEDED(hr)) {
      return FALSE;
   }
   hr = CoCreateInstance(
            CLSID_DsObjectPicker,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDsObjectPicker,
            (void **) &pDsObjectPicker
            );
   if(!SUCCEEDED(hr)){
      CoUninitialize();
      return FALSE;
   }


#define SCE_SCOPE_INDEX_DOMAIN 0
#define SCE_SCOPE_INDEX_DIRECTORY 1
#define SCE_SCOPE_INDEX_LOCAL 2
#define SCE_NUM_SCOPE_INDICES 3
   DSOP_SCOPE_INIT_INFO aScopes[SCE_NUM_SCOPE_INDICES];
   DSOP_SCOPE_INIT_INFO aScopesUsed[SCE_NUM_SCOPE_INDICES];

   ZeroMemory(aScopes, sizeof(aScopes));
   ZeroMemory(aScopesUsed, sizeof(aScopesUsed));

    DWORD dwDownLevel = 0, dwUpLevel = 0;

    //
    // Users
    //
    if (nShowFlag & SCE_SHOW_USERS ) {
        dwDownLevel |=  DSOP_DOWNLEVEL_FILTER_USERS;
        dwUpLevel   |= DSOP_FILTER_USERS ;
    }

    if( nShowFlag & SCE_SHOW_LOCALGROUPS ){
       dwUpLevel |= DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
       dwDownLevel |= DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    if( nShowFlag & SCE_SHOW_BUILTIN ){
       dwUpLevel |= DSOP_FILTER_BUILTIN_GROUPS;
       dwDownLevel |= DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    } else {
       dwDownLevel |= DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
    }


    //
    // Built in groups.
    //
    if (nShowFlag & SCE_SHOW_GROUPS ) {
      dwDownLevel |= DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;
        dwUpLevel   |= DSOP_FILTER_BUILTIN_GROUPS;
    }

    //
    // Domain groups.
    //
    if( nShowFlag & (SCE_SHOW_GROUPS | SCE_SHOW_DOMAINGROUPS | SCE_SHOW_ALIASES | SCE_SHOW_GLOBAL) ){
        if( !(nShowFlag & SCE_SHOW_LOCALONLY)){
            dwUpLevel |=    DSOP_FILTER_UNIVERSAL_GROUPS_SE
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE
                            | DSOP_FILTER_GLOBAL_GROUPS_SE
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
        } else if(bDC){

          dwDownLevel |= DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER;
            dwUpLevel |=    DSOP_FILTER_GLOBAL_GROUPS_SE
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
        }
    }


    //
    //
    // principal well known sids.
    //
    if( (!(nShowFlag & SCE_SHOW_LOCALONLY) &&
        nShowFlag & SCE_SHOW_GROUPS &&
        nShowFlag & SCE_SHOW_USERS) ||
        nShowFlag & SCE_SHOW_WELLKNOWN ){
/*
        dwDownLevel |=  DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER
                      | DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP
                      | DSOP_DOWNLEVEL_FILTER_INTERACTIVE
                      | DSOP_DOWNLEVEL_FILTER_SYSTEM
                      | DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER
                      | DSOP_DOWNLEVEL_FILTER_WORLD
                      | DSOP_DOWNLEVEL_FILTER_ANONYMOUS
                      | DSOP_DOWNLEVEL_FILTER_BATCH
                      | DSOP_DOWNLEVEL_FILTER_DIALUP
                      | DSOP_DOWNLEVEL_FILTER_NETWORK
                      | DSOP_DOWNLEVEL_FILTER_SERVICE
                      | DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER
                      | DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE
                      | DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE
                      | DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON;
*/
        dwDownLevel |= DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

        dwUpLevel |= DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
    }


   DSOP_INIT_INFO  InitInfo;
   ZeroMemory(&InitInfo, sizeof(InitInfo));

   //
   // Other attributes that we need object picker to return to use.
   //
   PCWSTR aAttributes[] = { L"groupType",
                            L"objectSid" };

   InitInfo.cAttributesToFetch = 2;
   InitInfo.apwzAttributeNames = aAttributes;
   //
   // First Item we want to view is the local computer.
   //
   aScopes[SCE_SCOPE_INDEX_LOCAL].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_LOCAL].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   aScopes[SCE_SCOPE_INDEX_LOCAL].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   aScopes[SCE_SCOPE_INDEX_LOCAL].FilterFlags.Uplevel.flBothModes = dwUpLevel;
   aScopes[SCE_SCOPE_INDEX_LOCAL].FilterFlags.flDownlevel = dwDownLevel;

   //
   // Flags for the domain we're joined to.
   //
   aScopes[SCE_SCOPE_INDEX_DOMAIN].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_DOMAIN].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
   aScopes[SCE_SCOPE_INDEX_DOMAIN].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE | DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   //
   // May need to differentiate native & mixed modes on non-DCs.
   //
   if (nShowFlag & SCE_SHOW_DIFF_MODE_OFF_DC && !bDC) {
      aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.Uplevel.flNativeModeOnly = dwUpLevel;
      aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.Uplevel.flMixedModeOnly =
                                         ( dwUpLevel & (~( DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE )) );
   } else {
      aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.Uplevel.flBothModes = dwUpLevel;
   }
   aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.flDownlevel = dwDownLevel;

   //
   // Next set flags for other scope items. Everything same, only not show builtin and local groups
   //
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].FilterFlags.Uplevel.flBothModes = ( dwUpLevel &
                                                (~( DSOP_FILTER_BUILTIN_GROUPS |DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE )) );
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].FilterFlags.flDownlevel = dwDownLevel & (~ DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS );
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS |
                                                                 DSOP_DOWNLEVEL_FILTER_COMPUTERS;
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                               | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                                               | DSOP_SCOPE_TYPE_WORKGROUP
                                               | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                               | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
                                               | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                               | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
   //
   // Show each scope's information or not.
   //
   InitInfo.cDsScopeInfos = 0;

   if (nShowFlag & SCE_SHOW_SCOPE_LOCAL) {
      memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_LOCAL],sizeof(DSOP_SCOPE_INIT_INFO));
      InitInfo.cDsScopeInfos++;
   }
   if (nShowFlag & SCE_SHOW_SCOPE_DOMAIN) {
      memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_DOMAIN],sizeof(DSOP_SCOPE_INIT_INFO));
      InitInfo.cDsScopeInfos++;
   }
   if (nShowFlag & SCE_SHOW_SCOPE_DIRECTORY) {
      memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_DIRECTORY],sizeof(DSOP_SCOPE_INIT_INFO));
      InitInfo.cDsScopeInfos++;
   }

   ASSERT(InitInfo.cDsScopeInfos > 0);

   //
   // If workgroup is supplied then we must filter computers.
   //
   int i;
   for (i=0;i<sizeof(aScopes)/sizeof(aScopes[0]);i++) {
      if( aScopes[i].flType & DSOP_SCOPE_TYPE_WORKGROUP ){
         aScopes[i].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
      }
   }

   //
   // Initialize and display the object picker.
   //

   InitInfo.cbSize = sizeof(InitInfo);
   InitInfo.aDsScopeInfos = aScopesUsed;
   InitInfo.flOptions = ((nShowFlag & SCE_SHOW_SINGLESEL) ? 0:DSOP_FLAG_MULTISELECT);

   InitInfo.pwzTargetComputer = m_pszServerName;

   hr = pDsObjectPicker->Initialize(&InitInfo);

   if( FAILED(hr) ){
      CoUninitialize();
      return FALSE;
   }

   IDataObject *pdo = NULL;

   hr = pDsObjectPicker->InvokeDialog(hwnd, &pdo);

   while (SUCCEEDED(hr) && pdo) { // FALSE LOOP
      //
      // The user pressed OK. Prepare clipboard dataformat from the object picker.
      //
      STGMEDIUM stgmedium =
      {
         TYMED_HGLOBAL,
         NULL
      };

      CLIPFORMAT cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

      FORMATETC formatetc =
      {
         cf,
         NULL,
         DVASPECT_CONTENT,
         -1,
         TYMED_HGLOBAL
      };

      hr = pdo->GetData(&formatetc, &stgmedium);

      if ( FAILED(hr) ) {
         bRet = FALSE;
         pdo->Release();
         pdo = NULL;
         break;
      }

      //
      // Lock the selection list.
      //
      PDS_SELECTION_LIST pDsSelList =
      (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

      ULONG i;
      ULONG iLen = 0;

      //
      // Enumerate through all selections.
      //
      for (i = 0; i < pDsSelList->cItems && bRet; i++) {
         LPTSTR pszCur = pDsSelList->aDsSelection[i].pwzADsPath;
         bHasADsPath = TRUE;
         int iPath = 0;

         //
         // Se if this is a valid string.  If the string isn't empty or NULL then use it
         // with the full path, we will figure out later wiether we need to strip the prefix.
         //
         if (pszCur && *pszCur
                         ){
            //
            // Create name with one path.
            //
            iLen = lstrlen(pszCur);
            while (iLen) {
               if ( pszCur[iLen] == L'/' ) {
                  if (iPath) {
                     iLen++;
                     iPath -= iLen;
                     break;
                  }
                  iPath = iLen;
               }
               iLen--;
            }
            pszCur += iLen;
         } else {
            //
            // Use just the name then.
            //
            bHasADsPath = FALSE;
            pszCur = pDsSelList->aDsSelection[i].pwzName;
            if (!pszCur || !(*pszCur)) {
               continue;
            }
         }

         iLen = lstrlen(pszCur);


         if (iLen) {
            //
            // Allocate and copy the user name.
            //
            LPTSTR pszNew = (LPTSTR)LocalAlloc( LMEM_FIXED, (iLen + 1) * sizeof(TCHAR));
            if (!pszNew) {
               bRet = FALSE;
               break;
            }

            lstrcpy(pszNew, pszCur);

            if (bHasADsPath)
            {
                if (iPath) {
                   //
                   // Set forward slash to back slash.
                   //
                   pszNew[iPath] = L'\\';
                }

                ULONG uAttributes;
                //
                // Bug 395424:
                //
                // Obsel passes attributes in VT_I4 on DCs and in VT_UI4 on other systems
                // Need to check both to properly detect built-ins, etc.
                //

                if (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_UI4) {
                   uAttributes = V_UI4(pDsSelList->aDsSelection[i].pvarFetchedAttributes);
                } else if (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_I4) {
                   uAttributes = static_cast<ULONG>(V_I4(pDsSelList->aDsSelection[i].pvarFetchedAttributes));
                }

                //
                // Determine if the name we recieved is group.
                // The type and value of pDsSelList->aDsSelection[i].pvarFetchedAttributes
                // may change in the future release by Object Picker. Therefore,
                // the following code should change accordingly.
                //
                if ( (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_UI4) ||
                     (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_I4 ))
                {
                    //
                    // Determine if it is a built-in group.  We don't want
                    // built-in groups to have a prefix.
                    //
                    if ( uAttributes & 0x1 &&
                         V_ISARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1) )
                    {
                        lstrcpy( pszNew, &(pszCur[iPath + 1]) );
                    }
                    else if ( uAttributes & 0x4 &&
                              V_ISARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1) )
                    {
                        //
                        // It's a group, but we have to check the sids account type.  If it's
                        // not in the domain accounts authority then we can assume it's a built-in sid
                        //
                        PVOID pvData = NULL;
                        HRESULT hr = SafeArrayAccessData( V_ARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1), &pvData);

                        if (SUCCEEDED(hr) ) {
                            if ( IsValidSid( (PSID)pvData ) && !IsDomainAccountSid( (PSID)pvData ) )
                            {
                                lstrcpy(pszNew, &(pszCur[iPath + 1]) );
                            }
                            hr = SafeArrayUnaccessData( V_ARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1) );
                        }
                    }
                }
                else if(V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_EMPTY)
                {
                    LPTSTR pszTemp = pDsSelList->aDsSelection[i].pwzClass;
                    //
                    // Determine if it is a well-known account.  We don't want
                    // well-known account to have a prefix.
                    //
                    if (lstrcmpi(pszTemp, _T("user")))
                    {
                        lstrcpy( pszNew, &(pszCur[iPath + 1]) );
                    }
                }
            }

            //
            // Make sure we don't already have this name in the list.
            //
            pName = m_pNameList;
            while (pName) {
               if (!lstrcmpi(pName->Name, pszNew)) {
                  LocalFree(pszNew);
                  pszNew = NULL;
                  break;
               }
               pName = pName->Next;
            }

            if ( !pszNew ) {
               //
               // Don;t do anything because this name already exists.
               //
               continue;
            }

            //
            // New entry in list.
            //
            pName = (PSCE_NAME_LIST) LocalAlloc(LPTR,sizeof(SCE_NAME_LIST));
            if ( !pName ) {
               LocalFree(pszNew);
               bRet = FALSE;
               break;
            }
            ZeroMemory(pName, sizeof(SCE_NAME_LIST));

            //GetAccountType(pszNew);
            pName->Name = pszNew;
            pName->Next = m_pNameList;
            m_pNameList = pName;
         }
      }
      GlobalUnlock(stgmedium.hGlobal);
      ReleaseStgMedium(&stgmedium);
      pdo->Release();
      break;
   }

   pDsObjectPicker->Release();
   CoUninitialize();

   if (!bRet) {
      //
      // If we had an error somewhere clean up.
      //
      pName = m_pNameList;
      while (pName) {
         if (pName->Name) {
            LocalFree(pName->Name);
         }
         m_pNameList = pName->Next;
         LocalFree(pName);

         pName = m_pNameList;
      }
      m_pNameList = NULL;
   }
   return bRet;

}

PSCE_NAME_LIST CGetUser::GetUsers()
{
   return m_pNameList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "util.h"
#include "AString.h"
#include "ANumber.h"
#include "AEnable.h"
#include "AAudit.h"
#include "ARet.h"
#include "ARight.h"
#include "CAudit.h"
#include "CNumber.h"
#include "CEnable.h"
#include "CName.h"
#include "CPrivs.h"
#include "CGroup.h"
#include "Cret.h"
#include "chklist.h"
#include "servperm.h"
#include "aobject.h"
#include "cobject.h"

#include "UIThread.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify
/////////////////////////////////////////////////////////////////////////////

HRESULT CSnapin::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   ASSERT(FALSE);

   return S_OK;
}

HRESULT CSnapin::OnShow(LPDATAOBJECT pDataObj, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   // Note - arg is TRUE when it is time to enumerate
   if (arg == TRUE) 
   {
      m_ShowCookie = cookie;

      // Show the headers for this nodetype
      InitializeHeaders(cookie);
      // Show data
      EnumerateResultPane(cookie, param, pDataObj);

      // BUBBUG - Demonstration to should how you can attach
      // and a toolbar when a particular nodes gets focus.
      // warning this needs to be here as the toolbars are
      // currently hidden when the previous node looses focus.
      // This should be update to show the user how to hide
      // and show toolbars. (Detach and Attach).

      //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
      //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);


   } 
   else 
   {
      // Free data associated with the result pane items, because
      // your node is no longer being displayed.
      // Note: The console will remove the items from the result pane
      m_ShowCookie = 0;

      DeleteServiceResultList(cookie);
      DeleteList(FALSE);
   }

   return S_OK;
}

HRESULT CSnapin::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   return S_OK;
}

BOOL CALLBACK MyPropSheetDlgProc(HWND hwnd, UINT uMsg, WPARAM wp, LPARAM lp) 
{
   return FALSE;
}


HRESULT CSnapin::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   return S_OK;
}

HRESULT CSnapin::OnPropertyChange(LPDATAOBJECT lpDataObject)
{

   return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Method:     InitializeHeaders
//
//  Synopsis:   Set the result item headers appropriate for the area
//
//  Arguments:  [cookie] - [in] the folder whose result item to setting headers for
//
//  Returns:
//
//  History:
//
//---------------------------------------------------------------------------
SCE_COLUMNINFO g_columnInfo[] = {

    { AREA_REGISTRY_ANALYSIS,        5,              0 },
    { IDS_COL_OBJECT,       LVCFMT_LEFT,    220 },
    { IDS_PERMISSION,       LVCFMT_LEFT,    80 },
    { IDS_AUDITING,         LVCFMT_LEFT,    70 },
    { IDS_COL_BAD_COUNT,    LVCFMT_LEFT,    60 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { AREA_REGISTRY,        2,              0 },
    { IDS_COL_OBJECT,       LVCFMT_LEFT,    220 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { AREA_GROUPS,          4,              0 },
    { IDS_GROUP_NAME,       LVCFMT_LEFT,    200 },
    { IDS_COL_MEMBERSHIP,   LVCFMT_LEFT,    120 },
    { IDS_COL_MEMBEROF,     LVCFMT_LEFT,    120 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { AREA_SERVICE,         4,              0 },
    { IDS_COL_SERVICE,      LVCFMT_LEFT,    170 },
    { IDS_STARTUP,          LVCFMT_LEFT,    80 },
    { IDS_PERMISSION,       LVCFMT_LEFT,    80 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { POLICY_PASSWORD,      3,              0 },
    { IDS_ATTR,             LVCFMT_LEFT,    250 },
    { IDS_BASE_TEMPLATE,    LVCFMT_LEFT,    190 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { POLICY_PASSWORD_ANALYSIS, 4,          0 },
    { IDS_ATTR,             LVCFMT_LEFT,    200 },
    { IDS_BASE_ANALYSIS,    LVCFMT_LEFT,    120 },
    { IDS_SETTING,          LVCFMT_LEFT,    120 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { LOCALPOL_PASSWORD,    3,              0 },
    { IDS_ATTR,             LVCFMT_LEFT,    200 },
    { IDS_LOCAL_POLICY_COLUMN,             LVCFMT_LEFT,    120 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { NONE,                 2,              0 },
    { IDS_NAME,             LVCFMT_LEFT,    180 },
    { IDS_DESC,             LVCFMT_LEFT,    270 },
};

HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
   HRESULT hr = S_OK;

   ASSERT(m_pHeader);

   // Create a new array of column sizes.  We just need to copy the static buffer
   // g_columnInfo.
   FOLDER_TYPES type;
   CFolder* pFolder = (CFolder *)cookie;
   if ( NULL == cookie) 
   {
      // the root
      type = NONE;
   } 
   else 
      type = pFolder->GetType();

   PSCE_COLUMNINFO pCur = NULL;
   CString str;
   int i = 0;
   int iDesc = 0;
   int iInsert = 0;

   PSCE_COLINFOARRAY pHeader = NULL;
   if(m_pComponentData){
       pHeader = reinterpret_cast<CComponentDataImpl *>(m_pComponentData)->GetColumnInfo( type );
   }
   if( !pHeader )
   {
        // Create new header look up.
        switch(type){
        case AREA_REGISTRY:
        case AREA_FILESTORE:
           type = AREA_REGISTRY;
           break;

        case AREA_REGISTRY_ANALYSIS:
        case AREA_FILESTORE_ANALYSIS:
        case REG_OBJECTS:
        case FILE_OBJECTS:
           type = AREA_REGISTRY_ANALYSIS;
           break;

        case AREA_GROUPS:
        case AREA_GROUPS_ANALYSIS:
           type = AREA_GROUPS;
           break;

        case AREA_SERVICE:
        case AREA_SERVICE_ANALYSIS:
           type = AREA_SERVICE;
           break;

        default:
           if ( type >= POLICY_PASSWORD &&
                type <= AREA_FILESTORE ) 
           {
              type = POLICY_PASSWORD;
           } 
           else if ( type >= POLICY_PASSWORD_ANALYSIS &&
                       type <= REG_OBJECTS ) 
           {
              type = POLICY_PASSWORD_ANALYSIS;
           } 
           else if (type >= LOCALPOL_PASSWORD &&
                      type <= LOCALPOL_LAST) 
           {
              type = LOCALPOL_PASSWORD;
           } 
           else 
           {
               type = NONE;
           }
           break;
        }

        pCur = g_columnInfo;
        for( i = 0; i < sizeof(g_columnInfo)/sizeof(SCE_COLUMNINFO);i++)
        {
           if(pCur[i].colID == type)
           {
              iInsert = pCur[i].nCols;
              i++;
              break;
           }
           i += pCur[i].nCols;
        }

        //
        // RSOP Mode has an extra column for the GPO source
        // If we're not in RSOP mode then ignore that column
        //
        if (((GetModeBits() & MB_RSOP) != MB_RSOP) && (NONE != type)) 
        {
           iInsert--;
        }

        if(pFolder)
        {
            type = pFolder->GetType();
        }

        iDesc = i;
        pCur += iDesc;
        pHeader = (PSCE_COLINFOARRAY)LocalAlloc(0, sizeof(SCE_COLINFOARRAY) + (sizeof(int) * iInsert) );
        if(pHeader)
        {
            pHeader->iIndex = i;
            pHeader->nCols  = iInsert;

            for(i = 0; i < iInsert; i++)
            {
                pHeader->nWidth[i] = pCur[i].nWidth;
            }

            reinterpret_cast<CComponentDataImpl *>(m_pComponentData)->SetColumnInfo( type, pHeader );
        }
   } 
   else 
   {
       iDesc   = pHeader->iIndex;
       iInsert = pHeader->nCols;
   }

   // Insert the columns.
   m_nColumns = iInsert;

   BOOL bGroupPolicy = FALSE;

   //
   // special case Group Policy mode since "Policy Setting" has
   // to be displayed instead of "Computer Setting"
   //

   if (GetModeBits() & MB_GROUP_POLICY) 
   {
       bGroupPolicy = TRUE;
   }

   pCur = g_columnInfo + iDesc;
   for(i = 0; i < iInsert; i++)
   {
        if (bGroupPolicy && pCur->colID == IDS_BASE_TEMPLATE) 
        {
            str.LoadString( IDS_POLICY_SETTING );
        }
        else 
        {
            str.LoadString( pCur->colID );
        }

        if(pHeader)
        {
            m_pHeader->InsertColumn( i, str, pCur->nCols, pHeader->nWidth[i] );
        } 
        else 
        {
            m_pHeader->InsertColumn( i, str, pCur->nCols, pCur->nWidth );
        }
        pCur++;
   }

   switch(type) {
      case STATIC:
      case ROOT:
      case ANALYSIS:
      case CONFIGURATION:
      case LOCATIONS:
      case PROFILE:
      case LOCALPOL:
      case POLICY_LOCAL:
      case POLICY_ACCOUNT:
      case POLICY_LOCAL_ANALYSIS:
      case POLICY_ACCOUNT_ANALYSIS:
      case LOCALPOL_ACCOUNT:
      case LOCALPOL_LOCAL:
         m_pResult->ModifyViewStyle(MMC_NOSORTHEADER,(MMC_RESULT_VIEW_STYLE)0);
         break;
      default:
         m_pResult->ModifyViewStyle((MMC_RESULT_VIEW_STYLE)0,MMC_NOSORTHEADER);
         break;
   }

   return hr;
}

HRESULT CSnapin::InitializeBitmaps(MMC_COOKIE cookie)
{
   ASSERT(m_pImageResult != NULL);

   CBitmap bmp16x16;
   CBitmap bmp32x32;

   // Load the bitmaps from the dll

   bmp16x16.LoadBitmap(IDB_ICON16 /*IDB_16x16 */);
   bmp32x32.LoadBitmap(IDB_ICON32 /*IDB_32x32 */);

   // Set the images
   m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                                     reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                                     0, RGB(255, 0, 255));

   return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   CComponentDataImpl::SerializeColumnInfo
//
//  Synopsis:   Saves or loads column information contained in m_mapColumns.
//              The function saves out the information in char format.
//              SCECOLUMNS:%d   - number of column information structures.
//              T:%d,           - type of column (key)
//              I:%d,           - Index into [g_columnInfo]
//              C:%d,           - Number of columns
//              W:%d,           - Width of a column.
//
//  Arguments:  [pStm]          - Stream to read or write to.
//              [pTotalWrite]   - [Optional] Total number of bytes written.
//              [bRead]         - If True then we should read from the stream.
//
//  Returns:    ERROR_SUCCESS   - Everything was successful.
//              E_OUTOFMEMORY   - Out of memory.
//
//  History:
//
//---------------------------------------------------------------------------
DWORD CComponentDataImpl::SerializeColumnInfo(
    IStream *pStm,
    ULONG *pTotalWrite,
    BOOL bRead)
{
   ULONG nBytesWritten = 0;
   POSITION pos = NULL;
   FOLDER_TYPES fType;
   PSCE_COLINFOARRAY pData = 0;
   ULONG totalWrite = 0;
   int i = 0;

   LPCTSTR pszHeader     = TEXT("SCECOLUMNS:%d{");
   LPCTSTR pszColHead    = TEXT("{T:%d,I:%d,C:%d,");
   if(!bRead)
   {
       // Write columns.  Save the information in text format so that we will be
       // independent of sizeof stuff.
       pos = m_mapColumns.GetStartPosition();
       totalWrite = 0;
       if(pos)
       {
           char szWrite[256];
           // Write header.
           totalWrite += WriteSprintf(pStm, pszHeader, m_mapColumns.GetCount());
           while(pos)
           {
               m_mapColumns.GetNextAssoc(pos, fType, pData);
               if(pData)
               {
                   // write out the type.
                   totalWrite += WriteSprintf(pStm, pszColHead, fType, g_columnInfo[pData->iIndex - 1].colID, pData->nCols);

                   // write out each column width.
                   for(i = 0; i < pData->nCols; i++)
                   {
                       if( i + 1 < pData->nCols)
                       {
                            totalWrite += WriteSprintf(pStm, TEXT("W:%d,"), pData->nWidth[i]);
                       } 
                       else 
                       {
                            totalWrite += WriteSprintf(pStm, TEXT("W:%d}"), pData->nWidth[i]);
                       }
                   }
               }
           }
           totalWrite += WriteSprintf(pStm, TEXT("}"));
       }

       if(pTotalWrite)
       {
           *pTotalWrite = totalWrite;
       }
   } 
   else 
   {
       int iTotalTypes = 0;
       int iIndex = 0;
       int nCols = 0;

       if( ReadSprintf( pStm, pszHeader, &iTotalTypes) != -1)
       {
           for( i = 0; i < iTotalTypes; i++)
           {
               if( ReadSprintf(pStm, pszColHead, &fType, &iIndex, &nCols) == - 1)
               {
                   break;
               }

               // find index of column information.
               for(int k = 0; k < sizeof(g_columnInfo)/sizeof(SCE_COLUMNINFO); k++)
               {
                   if( g_columnInfo[k].colID == iIndex )
                   {
                       iIndex = k + 1;
                       break;
                   }
               }

               pData = (PSCE_COLINFOARRAY)LocalAlloc(0, sizeof(SCE_COLINFOARRAY) + (sizeof(int) * nCols) );

               if(pData)
               {
                   pData->iIndex = iIndex;
                   pData->nCols = nCols;

                   for( iIndex = 0; iIndex < nCols; iIndex++)
                   {
                       if( iIndex + 1 < nCols)
                            ReadSprintf(pStm, TEXT("W:%d,"), &(pData->nWidth[ iIndex ]) );
                       else 
                            ReadSprintf(pStm, TEXT("W:%d}"), &(pData->nWidth[ iIndex ]) );
                   }

                   SetColumnInfo( fType, pData );
               } 
               else
                   return (DWORD)E_OUTOFMEMORY;
           }
           ReadSprintf(pStm, TEXT("}"));
       }
   }

   return ERROR_SUCCESS;
}
//+--------------------------------------------------------------------------
//
//  Method:     EnumerateResultPane
//
//  Synopsis:   Create the result pane items for the result pane that MMC
//              is displaying
//
//  Arguments:  [cookie]   - The cookie representing the node's who we
//                           are enumerating
//              [pParent]  - The scope node whose result pane we are showing
//              [pDataObj] - The data object for the scope node we are showing
//
//  Returns:    none
//
//  Modifies:   m_resultItemList
//
//  History:    12-15-1997   Robcap
//
//---------------------------------------------------------------------------
void CSnapin::EnumerateResultPane(MMC_COOKIE cookie, HSCOPEITEM pParent, LPDATAOBJECT pDataObj)
{
   PEDITTEMPLATE pTemplateInfo = 0;
   PEDITTEMPLATE pProfileTemplate = 0;
   PEDITTEMPLATE pBaseTemplate = 0;
   PSCE_PROFILE_INFO pProfileInfo = 0;
   PSCE_PROFILE_INFO pBaseInfo = 0;
   DWORD idErr = 0;
   CComponentDataImpl *pccDataImpl = 0;

   ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
   ASSERT(m_pComponentData != NULL);

   pccDataImpl = (CComponentDataImpl *)m_pComponentData;
   //
   // This may take a while; let the user have some warning rather than
   // just going blank on them
   //
   CWaitCursor wc;

   //
   // cookie is the scope pane item for which to enumerate.
   // for safety, we should find the object in m_pComponentData
   //   CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie, NULL);
   // but for performance (and hopes nothing mess up), we could
   // cast the cookie to scope item type (CFolder)
   //

   CFolder* pFolder = 0;
   CString sErr;
   SCESTATUS rc = 0;

   PSCE_ERROR_LOG_INFO ErrBuf=NULL;
   AREA_INFORMATION area=0;
   CString StrErr;
   PVOID pHandle=NULL;

   if ( cookie ) 
      pFolder = (CFolder *)cookie;
   else
      pFolder = ((CComponentDataImpl *)m_pComponentData)->FindObject(cookie, NULL);
   

   //
   // pFolder could be NULL for the root.
   //
   if ( pFolder == NULL ) 
      return;
   
   FOLDER_TYPES type = pFolder->GetType();
   if( pFolder == m_pSelectedFolder &&
      m_pSelectedFolder &&
      m_pSelectedFolder->GetResultListCount() ) 
   {
      //
      // Do nothing.
      return;
   } 
   else 
   {
      if( m_pSelectedFolder && m_resultItemHandle )
      {
         m_pSelectedFolder->ReleaseResultItemHandle( m_resultItemHandle );
      }

      pFolder->GetResultItemHandle( &m_resultItemHandle );
      m_pSelectedFolder = pFolder;
      if( pFolder->GetResultListCount() )
      {
         goto AddToResultPane;
      }
   }
   //
   // If this is the top Analysis folder and it hasn't been enumerated yet then
   // Make sure we do so and put back any folders that we've removed from there,
   // Since MMC won't give us a second expand event to do it on
   //

   //
   // The Analysis Pane isn't available now; let the user know why
   //
   if (type == ANALYSIS) 
   {
      if (((CComponentDataImpl *) m_pComponentData)->m_bIsLocked) 
      {
         //
         // should print more informative messages as to why the info isn't available
         //
         AddResultItem(IDS_ERROR_ANALYSIS_LOCKED, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      if (!(((CComponentDataImpl *) m_pComponentData)->SadHandle)) 
      {
         //
         // should print more informative messages as to why the info isn't available
         //
         FormatDBErrorMessage(
               ((CComponentDataImpl *)m_pComponentData)->SadErrored,
               ((CComponentDataImpl *)m_pComponentData)->SadName,
               sErr);

         sErr.TrimLeft();
         sErr.TrimRight();

         AddResultItem(sErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);

         goto AddToResultPane;
      }
   }
   if (type == ANALYSIS ||
       (type >= AREA_POLICY_ANALYSIS && type <= REG_OBJECTS)) 
   {
      CString strDBName;
      CString strDBFmt;
      CString strDB;
      LPTSTR szDBName;
      strDB = ((CComponentDataImpl *)m_pComponentData)->SadName;
      if (strDB.IsEmpty() || IsSystemDatabase(strDB)) 
         strDBFmt.LoadString(IDS_SYSTEM_DB_NAME_FMT);
      else 
         strDBFmt.LoadString(IDS_PRIVATE_DB_NAME_FMT);
      
      strDBName.Format(strDBFmt,strDB);
      szDBName = strDBName.GetBuffer(1);
      m_pResult->SetDescBarText(szDBName);
      //AddResultItem(strDBFmt,NULL,NULL,ITEM_OTHER,SCE_STATUS_GOOD,cookie);
   }

   if (type >= CONFIGURATION && type <= AREA_FILESTORE) 
   {
      //
      // We're in the Profile area, so we don't need to keep the Analysis area
      // open.  Close it to save memory:
      //
      ((CComponentDataImpl *)m_pComponentData)->CloseAnalysisPane();
   }

   if ( type == PROFILE ) 
   {
      //
      // Do not display the error message if we do not implement native modes.
      //
      if( pFolder->GetState() & CFolder::state_InvalidTemplate &&
         !(pFolder->GetMode() & MB_NO_NATIVE_NODES ))
      {
         StrErr.LoadString( IDS_ERROR_CANT_OPEN_PROFILE );
            AddResultItem(StrErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      } 
      else if (pFolder->GetMode() == SCE_MODE_DOMAIN_COMPUTER_ERROR) 
      {
         StrErr.LoadString( IDS_ERROR_NOT_ON_PDC );
            AddResultItem(StrErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
   }

   if ( (type < AREA_POLICY) ||
        (type > AREA_LAST)) 
   {
      return;
   }


   switch (type) 
   {
      case AREA_PRIVILEGE:
      case AREA_PRIVILEGE_ANALYSIS:
      case LOCALPOL_PRIVILEGE:
         area = AREA_PRIVILEGES;
         break;

      case AREA_GROUPS:
      case AREA_GROUPS_ANALYSIS:
         area = AREA_GROUP_MEMBERSHIP;
         break;

      case AREA_SERVICE:
      case AREA_SERVICE_ANALYSIS:
         area = AREA_SYSTEM_SERVICE;
         break;

      case AREA_REGISTRY:
      case AREA_REGISTRY_ANALYSIS:
      case REG_OBJECTS:
         area = AREA_REGISTRY_SECURITY;
         break;

      case AREA_FILESTORE:
      case AREA_FILESTORE_ANALYSIS:
      case FILE_OBJECTS:
         area = AREA_FILE_SECURITY;
         break;

      default:
         // case AREA_POLICY:
         // case AREA_POLICY_ANALYSIS:
         // case AREA_LOCALPOL_POLICY:
         area = AREA_SECURITY_POLICY;
         break;
   }

   if ( type >= AREA_POLICY &&
        type <= AREA_FILESTORE ) 
   {
      //
      // inf profiles
      //
      ASSERT(pFolder->GetInfFile());
      if ( pFolder->GetInfFile() == NULL ) 
         return;

      //
      // Get the Profile info from the cache
      //
      pTemplateInfo = GetTemplate(pFolder->GetInfFile(),AREA_ALL,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr,NULL,NULL,ITEM_OTHER,SCE_STATUS_ERROR_NOT_AVAILABLE,cookie);
      } 
      else 
      {
         CreateProfileResultList(cookie,
                                 type,
                                 pTemplateInfo,
                                 pDataObj);
      }
   } 
   else if ((type >= LOCALPOL_ACCOUNT) &&
              (type <= LOCALPOL_LAST)) 
   {
      if (!((CComponentDataImpl*)m_pComponentData)->SadHandle &&
          (ERROR_SUCCESS != ((CComponentDataImpl*)m_pComponentData)->SadErrored)) 
      {
         ((CComponentDataImpl*)m_pComponentData)->LoadSadInfo(FALSE);
      }
      pHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
      //
      // Get the Computer and Last Inspection Templates
      //
      pTemplateInfo = GetTemplate(GT_EFFECTIVE_POLICY,area,&idErr);

      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pBaseTemplate = pTemplateInfo;

      pTemplateInfo = GetTemplate(GT_LOCAL_POLICY,area,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pProfileTemplate = pTemplateInfo;

      CreateLocalPolicyResultList(cookie, type, pProfileTemplate, pBaseTemplate, pDataObj);
   } 
   else if ( area != AREA_REGISTRY_SECURITY &&
               area != AREA_FILE_SECURITY &&
               area != AREA_DS_OBJECTS ) 
   {
      //
      // SadName and SadHandle should already been populated
      //
      if (!((CComponentDataImpl*)m_pComponentData)->SadHandle &&
         ((CComponentDataImpl*)m_pComponentData)->SadErrored != SCESTATUS_SUCCESS) 
      {
         ((CComponentDataImpl*)m_pComponentData)->LoadSadInfo(TRUE);
      }
      pHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
      if ( NULL == pHandle ) 
      {
         AddResultItem(IDS_ERROR_NO_ANALYSIS_INFO, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      //
      // Get the Computer and Last Inspection Templates
      //
      pTemplateInfo = GetTemplate(GT_COMPUTER_TEMPLATE,area,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pBaseTemplate = pTemplateInfo;

      pTemplateInfo = GetTemplate(GT_LAST_INSPECTION,area,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pProfileTemplate = pTemplateInfo;

      CreateAnalysisResultList(cookie, type, pProfileTemplate, pBaseTemplate,pDataObj);
   } 
   else if (AREA_FILE_SECURITY == area) 
   {
      // registry and file objects
      // SadName and SadHandle should already been populated
      pHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
      if ( NULL == pHandle ) 
      {
         return;
      }
      PSCE_OBJECT_CHILDREN ObjectList=NULL;

      if ( type == FILE_OBJECTS ) 
      {
         // get next level objects
         rc = SceGetObjectChildren(pHandle,
                                   SCE_ENGINE_SAP,
                                   area,
                                   pFolder->GetName(),
                                   &ObjectList,
                                   &ErrBuf);
      }

      CreateObjectResultList(cookie, type, area, ObjectList, pHandle, pDataObj);

      if ( (type == REG_OBJECTS || type == FILE_OBJECTS) && ObjectList ) 
      {
         SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN);
      }

   }

   // free memory buffers
   if ( ErrBuf ) 
      SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
   

AddToResultPane:
   if (m_pResult)
   {
       //
       // Prepare the result window.
       //
       m_pResult->SetItemCount(
                        m_pSelectedFolder->GetResultListCount( ),
                        MMCLV_UPDATE_NOINVALIDATEALL);

      RESULTDATAITEM resultItem;

      ZeroMemory(&resultItem,sizeof(resultItem));
      resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
      resultItem.str = MMC_CALLBACK;
      resultItem.nImage = -1; // equivalent to: MMC_CALLBACK;


      // Set the result as the cookie
      POSITION pos = NULL;
      do {
         if( m_pSelectedFolder->GetResultItem(
                           m_resultItemHandle,
                           pos,
                           (CResult **)&(resultItem.lParam)
                           ) == ERROR_SUCCESS)
        {
           if(resultItem.lParam)
           {
               m_pResult->InsertItem(&resultItem);
           }
        } 
        else
           break;
      } while(pos);
      m_pResult->Sort(0, 0, 0);
   }
}

void ConvertNameListToString(PSCE_NAME_LIST pList, LPTSTR *sz)
{
   LPTSTR pszNew;
   if (NULL == sz)
      return;
   

   if (NULL == pList)
      return;
   
   //
   // Get Total size for buffer.
   //
   int iSize = 0;
   PSCE_NAME_LIST pTemp = 0;
   for( pTemp=pList;pTemp != NULL; pTemp=pTemp->Next) 
   {
       if ( !(pTemp->Name) )
           continue;
       
       iSize += lstrlen(pTemp->Name) + 1;
   }

   //
   // Allocate buffer.
   //
   pszNew = new TCHAR[iSize + 1];
   if (!pszNew)
       return;
   

   *sz = pszNew;
   //
   // Copy the strings.
   //
   for (pTemp=pList; pTemp != NULL; pTemp=pTemp->Next) 
   {
        if (!(pTemp->Name))
            continue;
        
        iSize = lstrlen(pTemp->Name);
        memcpy(pszNew, pTemp->Name, iSize * sizeof(TCHAR));
        pszNew += iSize;
        *pszNew = L',';
        pszNew++;
   }
   *(pszNew - 1) = 0;
}


//+--------------------------------------------------------------------------
//
//  Method:     CreateProfileResultList
//
//  Synopsis:   Create the result pane items for profile section
//
//  Arguments:  [cookie]   - The cookie representing the folder which we
//                           are enumerating
//              [type]     - The type of the folder we are enumerating
//              [pSceInfo] - The overall template that we are enumerating
//              [pDataObj] - The data object for this folder
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void
CSnapin::CreateProfileResultList(MMC_COOKIE cookie,
                                 FOLDER_TYPES type,
                                 PEDITTEMPLATE pSceInfo,
                                 LPDATAOBJECT pDataObj)
{
   bool     bVerify=false;
   CString  listStr;
   PSCE_PRIVILEGE_ASSIGNMENT pPriv=NULL;
   PSCE_GROUP_MEMBERSHIP pGroup=NULL;
   PSCE_OBJECT_ARRAY pObject = 0;
   UINT i  = 0;

   switch (type) 
   {
      case POLICY_KERBEROS:
      case POLICY_PASSWORD:
      case POLICY_LOCKOUT:
      case POLICY_AUDIT:
      case POLICY_OTHER:
      case POLICY_LOG:
         CreateProfilePolicyResultList(cookie,
                                       type,
                                       pSceInfo,
                                       pDataObj);
         break;

      case AREA_POLICY:
         //
         // Policy folder only contains other folders, no actual result items
         //
         break;

      case AREA_PRIVILEGE: 
         {
            CString strDisp;
            LPTSTR szDisp;
            DWORD cbDisp;
            szDisp = new TCHAR [255];

            if (!szDisp) 
               break;

            LPTSTR szPriv = new TCHAR [255];
            if ( !szPriv )
            {
                delete[] szDisp;
                break;
            }

            for ( int i2=0; i2<cPrivCnt; i2++ ) 
            {
                cbDisp = 255;
                if ( SCESTATUS_SUCCESS == SceLookupPrivRightName(i2,szPriv, (PINT)&cbDisp) ) 
                {
                    for (pPriv=pSceInfo->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
                         pPriv!=NULL;
                         pPriv=pPriv->Next) 
                    {
                        if ( _wcsicmp(szPriv, pPriv->Name) == 0 ) 
                            break;
                    }

                    cbDisp = 255;
                    if ( pPriv ) 
                    {
                        //
                        // find it in the template
                        //
                        GetRightDisplayName(NULL,(LPCTSTR)pPriv->Name,szDisp,&cbDisp);

                        AddResultItem(szDisp,                    // The name of the attribute being added
                                      (LONG_PTR)(i2>=cPrivW2k),  // Raid #382263, The last inspected setting of the attribute
                                      (LONG_PTR)pPriv->AssignedTo,  // The template setting of the attribute
                                      ITEM_PROF_PRIVS,           // The type of of the attribute's data
                                      -1,                        // The mismatch status of the attribute
                                      cookie,                    // The cookie for the result item pane
                                      FALSE,                     // Copy last inspected from template
                                      NULL,                      // The units the attribute is set in
                                      (LONG_PTR) pPriv,          // An id to let us know where to save this attribute
                                      pSceInfo,                  // The template to save this attribute in
                                      pDataObj                   // The data object for the scope note who owns the result pane
                                      );
                    } 
                    else 
                    {
                        //
                        // a not configured privilege
                        //
                        GetRightDisplayName(NULL,(LPCTSTR)szPriv,szDisp,&cbDisp);

                        AddResultItem(szDisp,                    // The name of the attribute being added
                                      (LONG_PTR)(i2>=cPrivW2k),  // Raid #382263, The last inspected setting of the attribute
                                      (LONG_PTR)ULongToPtr(SCE_NO_VALUE),  // The template setting of the attribute
                                      ITEM_PROF_PRIVS,           // The type of of the attribute's data
                                      -1,                        // The mismatch status of the attribute
                                      cookie,                    // The cookie for the result item pane
                                      FALSE,                     // Copy last inspected from template
                                      szPriv,                    // Save the privilege name in this buffer
                                      0,                         // An id to let us know where to save this attribute
                                      pSceInfo,                  // The template to save this attribute in
                                      pDataObj                   // The data object for the scope note who owns the result pane
                                      );
                    }
                } 
                else 
                {
                    // impossible, just continue
                }

            }

            delete[] szDisp;
            delete[] szPriv;
         }
         break;

      case AREA_GROUPS:
         for (pGroup=pSceInfo->pTemplate->pGroupMembership;
              pGroup!=NULL;
              pGroup=pGroup->Next) 
         {
            AddResultItem((LPCTSTR)pGroup->GroupName,    // The name of the attribute being added
                          0,                             // The last inspection
                          (LONG_PTR)pGroup,              // The template info
                          ITEM_PROF_GROUP,               // The type of of the attribute's data
                          -1,                            // The mismatch status of the attribute
                          cookie,                        // The cookie for the result item pane
                          FALSE,                         // Copy last inspected from template
                          NULL,                          // The units the attribute is set in
                          (LONG_PTR)pGroup,              // An id to let us know where to save this attribute
                          pSceInfo,                      // The template to save this attribute in
                          pDataObj);                     // The data object for the scope note who owns the result pane
         }
         break;

      case AREA_SERVICE:
         CreateProfServiceResultList(cookie,
                                     type,
                                     pSceInfo,
                                     pDataObj);
         break;

      case AREA_REGISTRY:
         pObject = pSceInfo->pTemplate->pRegistryKeys.pAllNodes;
         if ( pObject!=NULL ) 
         {
            for (i=0; i<pObject->Count; i++) 
            {

               AddResultItem(pObject->pObjectArray[i]->Name,                        // The name of the attribute being added
                             NULL,                                                  // The last inspected setting of the attribute
                             (LONG_PTR)pObject->pObjectArray[i]->pSecurityDescriptor,  // The template setting of the attribute
                             ITEM_PROF_REGSD,                                       // The type of of the attribute's data
                             pObject->pObjectArray[i]->Status,                      // The mismatch status of the attribute
                             cookie,                                                // The cookie for the result item pane
                             FALSE,                                                 // Copy last inspected from template
                             NULL,                                                  // The units the attribute is set in
                             (LONG_PTR)pObject->pObjectArray[i],                       // An id to let us know where to save this attribute
                             pSceInfo,                                              // The template to save this attribute in
                             pDataObj);                                             // The data object for the scope note who owns the result pane
            }
         }
         break;

      case AREA_FILESTORE:
         pObject = pSceInfo->pTemplate->pFiles.pAllNodes;
         if ( pObject!=NULL ) 
         {
            for (i=0; i<pObject->Count; i++) 
            {

               AddResultItem(pObject->pObjectArray[i]->Name,                        // The name of the attribute being added
                             NULL,                                                  // The last inspected setting of the attribute
                             (LONG_PTR)pObject->pObjectArray[i]->pSecurityDescriptor,  // The template setting of the attribute
                             ITEM_PROF_FILESD,                                      // The type of of the attribute's data
                             pObject->pObjectArray[i]->Status,                      // The mismatch status of the attribute
                             cookie,                                                // The cookie for the result item pane
                             FALSE,                                                 // Copy last inspected from template
                             NULL,                                                  // The units the attribute is set in
                             (LONG_PTR)pObject->pObjectArray[i],                       // An id to let us know where to save this attribute
                             pSceInfo,                                              // The template to save this attribute in
                             pDataObj                                               // The data object for the scope note who owns the result pane
                             );
            }
         }
         break;

      default:
         break;
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     CreateAnalysisResultList
//
//  Synopsis:   Create the result pane items for the analysis section
//
//  Arguments:  [cookie]   - The cookie representing the folder which we
//                           are enumerating
//              [type]     - The type of the folder we are enumerating
//              [pSceInfo] - The last inspection template that we are enumerating
//              [pSceBase] - The computer template that we are enumerating
//              [pDataObj] - The data object for this folder
//
//  Returns:    none
//
//---------------------------------------------------------------------------

void CSnapin::CreateAnalysisResultList(MMC_COOKIE cookie,
                                  FOLDER_TYPES type,
                                  PEDITTEMPLATE pSceInfo,
                                  PEDITTEMPLATE pBase,
                                  LPDATAOBJECT pDataObj )
{
   bool     bVerify=true;
   CString  listStr;
   CString  listBase;
   PSCE_PRIVILEGE_ASSIGNMENT pPriv = 0;
   PSCE_PRIVILEGE_ASSIGNMENT pPrivBase = 0;
   UINT i = 0;

   switch (type) 
   {
      case POLICY_KERBEROS_ANALYSIS:
      case POLICY_PASSWORD_ANALYSIS:
      case POLICY_LOCKOUT_ANALYSIS:
      case POLICY_AUDIT_ANALYSIS:
      case POLICY_OTHER_ANALYSIS:
      case POLICY_LOG_ANALYSIS:
         CreateAnalysisPolicyResultList(cookie,
                                        type,
                                        pSceInfo,
                                        pBase,
                                        pDataObj);
         break;

      case AREA_POLICY_ANALYSIS:
         break;

      case AREA_PRIVILEGE_ANALYSIS: 
         {
            // find in the current setting list
            TCHAR szDisp[255];
            DWORD cbDisp = 0;
            for (pPriv=pSceInfo->pTemplate->OtherInfo.sap.pPrivilegeAssignedTo;
                pPriv!=NULL;
                pPriv=pPriv->Next) 
            {

               // find in the base setting list
               for (pPrivBase=pBase->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
                   pPrivBase!=NULL;
                   pPrivBase=pPrivBase->Next) 
               {

                  if ( pPrivBase->Value == pPriv->Value )
                     break;
               }


               cbDisp = 255;
               GetRightDisplayName(NULL,(LPCTSTR)pPriv->Name,szDisp,&cbDisp);

               if (pPrivBase == NULL)
               {
                   pPrivBase = (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE);
               }
               AddResultItem(szDisp,              // The name of the attribute being added
                             (LONG_PTR)pPriv,        // The last inspected setting of the attribute
                             (LONG_PTR)pPrivBase,    // The template setting of the attribute
                             ITEM_PRIVS,          // The type of of the attribute's data
                             pPriv->Status,       // The mismatch status of the attribute
                             cookie,              // The cookie for the result item pane
                             FALSE,               // True if the setting is set only if it differs from base (so copy the data)
                             NULL,                // The units the attribute is set in
                             0,                   // An id to let us know where to save this attribute
                             pBase,               // The template to save this attribute in
                             pDataObj);           // The data object for the scope note who owns the result pane
            }
         }
         break;

      case AREA_GROUPS_ANALYSIS: 
         {
            PSCE_GROUP_MEMBERSHIP pGroup = 0;
            PSCE_GROUP_MEMBERSHIP grpBase = 0;

            //
            // it is OK to start with pSceInfo because each group at least has
            // PrivilegesHeld field not null.
            //
            bVerify = FALSE;
            for (pGroup=pSceInfo->pTemplate->pGroupMembership; pGroup!=NULL; pGroup=pGroup->Next) 
            {
               //
               // find the base to compare with
               //

               if ( NULL == pGroup->GroupName )
                   continue;

               for (grpBase=pBase->pTemplate->pGroupMembership; grpBase!=NULL;
                   grpBase=grpBase->Next) 
               {
                  if ( grpBase->GroupName &&
                       _wcsicmp(pGroup->GroupName, grpBase->GroupName) == 0 ) 
                  {
                     break;
                  }
               }

               AddResultItem((LPCTSTR)pGroup->GroupName,    // The name of the attribute being added
                             GetGroupStatus(pGroup->Status, STATUS_GROUP_MEMBEROF), // The last inspected setting of the attribute
                             GetGroupStatus(pGroup->Status, STATUS_GROUP_MEMBERS), // The template setting of the attribute
                             ITEM_GROUP,                    // The type of of the attribute's data
                             GetGroupStatus(pGroup->Status, STATUS_GROUP_RECORD),  // status             // The mismatch status of the attribute
                             cookie,                        // The cookie for the result item pane
                             FALSE,                         // Copy last inspected from template
                             (LPTSTR)grpBase, //NULL,        // The units the attribute is set in
                             (LONG_PTR)pGroup,                 // An id to let us know where to save this attribute
                             pBase, //pSceInfo,                      // The template to save this attribute in
                             pDataObj);                     // The data object for the scope note who owns the result pane
            }
         }
         break;

      case AREA_SERVICE_ANALYSIS:
         //         AddResultItem(L"Not Implemented", NULL, NULL, ITEM_OTHER, -1, cookie);
         CreateAnalysisServiceResultList(cookie,
                                         type,
                                         pSceInfo,
                                         pBase,
                                         pDataObj);

         break;

      default:
         break;
   }

}

//+--------------------------------------------------------------------------
//
//  Method:     CreateObjectResultList
//
//  Synopsis:   Create the result pane items for an Object section
//
//  Arguments:  [cookie]   - The cookie representing the folder which we
//                           are enumerating
//              [type]     - The type of the folder we are enumerating
//              [Area]     - The SCE Area we're enumerating
//              [pObjList] - The array of object to enumerate
//              [pHandle]  -
//              [pDataObj] - The data object for the folder we're enumerating
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void CSnapin::CreateObjectResultList(MMC_COOKIE cookie,
                                     FOLDER_TYPES type,
                                     AREA_INFORMATION Area,
                                     PSCE_OBJECT_CHILDREN pObjList,
                                     PVOID pHandle,
                                     LPDATAOBJECT pDataObj )
{
   if ( pObjList == NULL ) 
   {
       //
       // no object to add
       //
       return;
   }

   PWSTR ObjSetting=NULL;
   PWSTR ObjBase=NULL;
   CString tmpstr;
   LPTSTR szPath = NULL;

   RESULT_TYPES rsltType;
   if ( Area == AREA_REGISTRY_SECURITY)
      rsltType = ITEM_REGSD;
   else if ( Area == AREA_FILE_SECURITY )
      rsltType = ITEM_FILESD;
   else 
   {
      ASSERT(FALSE);
      return;
   }

   PSCE_OBJECT_CHILDREN_NODE *pObjNode=&(pObjList->arrObject);

   for (DWORD i=0; i<pObjList->nCount; i++) 
   {
      BOOL bContainer = FALSE;
      CString strName;

      if ( pObjNode[i] == NULL ||
           pObjNode[i]->Name == NULL ) 
      {
          continue;
      }

      if (AREA_FILE_SECURITY == Area) 
      {
         DWORD dw = (DWORD)-1;

         strName = ((CFolder *)cookie)->GetName();
         if (strName.Right(1) != L"\\") 
         {
            strName += L"\\";
         }
         strName += pObjNode[i]->Name;
         dw = GetFileAttributes(strName);
         if ((DWORD)-1 == dw) 
         {
            //
            // GetFileAttributes should never fail, but in case it does assume
            // that this isn't a container (this matches CreateFolderList)
            //
            bContainer = FALSE;
         }
         else 
         {
            bContainer = dw & FILE_ATTRIBUTE_DIRECTORY;
         }
      } 
      else 
      {
         bContainer = FALSE;
      }
      if ( !bContainer ) 
      {
         //
         // only add the leaf objects in result pane.
         // non-leaf objects are added to the scope pane already
         //
         PEDITTEMPLATE pBaseObject=NULL;

         if ( type == REG_OBJECTS ||
              type == FILE_OBJECTS ) 
         {
            tmpstr = ((CFolder*)cookie)->GetName();
            if (tmpstr.Right(1) != L"\\") 
            {
               tmpstr += L"\\";
            }
            tmpstr += pObjNode[i]->Name;

         } 
         else 
         {
            //
            // shouldn't get here
            //
            tmpstr = TEXT("");
         }

         szPath = (LPTSTR) malloc((tmpstr.GetLength()+1) * sizeof(TCHAR));
         if (szPath) 
         {
            lstrcpy(szPath,tmpstr.GetBuffer(2));

            AddResultItem(pObjNode[i]->Name,  //   The name of the attribute being added
                          NULL,           //   The last inspected setting of the attribute
                          NULL,           //   The template setting of the attribute
                          rsltType,       //   The type of of the attribute's data
                          pObjNode[i]->Status,//   The mismatch status of the attribute
                          cookie,         //   The cookie for the result item pane
                          FALSE,          //   True if the setting is set only if it differs from base (so copy the data)
                          szPath,         //   The units the attribute is set in
                          (LONG_PTR)pHandle, //   An id to let us know where to save this attribute
                          pBaseObject,    //   The template to save this attribute in
                          pDataObj);      //   The data object for the scope note who owns the result pane
         } 
         else 
         {
            // Out of memory
         }
      }
   }
}


//+--------------------------------------------------------------------------
//
//  Method:    AddResultItem
//
//  Synopsis:  Add an item to the result pane from a string resource
//
//  Arguments: [rID]       - The resource id of name of the attribute being added
//             [setting]   - The last inspected setting of the attribute
//             [base]      - The template setting of the attribute
//             [type]      - The type of of the attribute's data
//             [status]    - The mismatch status of the attribute
//             [cookie]    - The cookie for the result item pane
//             [bVerify]   - True if the setting is set only if it differs
//                           from base (so copy the data)
//             [pBaseInfo] - The template to save this attribute in
//             [pDataObj]  - The data object for the scope note who owns the result pane
//
//  Returns:   a pointer to the CResult created to hold the item
//
//  History:
//
//---------------------------------------------------------------------------
CResult* CSnapin::AddResultItem(UINT rID,
                       LONG_PTR setting,
                       LONG_PTR base,
                       RESULT_TYPES type,
                       int status,
                       MMC_COOKIE cookie,
                       BOOL bVerify,
                       PEDITTEMPLATE pBaseInfo,
                       LPDATAOBJECT pDataObj)
{
   CString strRes;
   strRes.LoadString(rID);

   if (!strRes)
      return NULL;


   LPCTSTR Attrib = 0;
   LPCTSTR unit=NULL;

   //
   // The unit for the attribute is stored in the resource after a \n
   //
   int npos = strRes.ReverseFind(L'\n');
   if ( npos > 0 ) 
   {
      Attrib = strRes.GetBufferSetLength(npos);
      unit = (LPCTSTR)strRes+npos+1;
   } 
   else 
   {
      Attrib = (LPCTSTR)strRes;
   }

   return AddResultItem(Attrib,setting,base,type,status,cookie,bVerify,unit,rID,pBaseInfo,pDataObj);
}


//+--------------------------------------------------------------------------
//
//  Method:    AddResultItem
//
//  Synopsis:  Add an item to the result pane
//
//  Arguments: [Attrib]    - The name of the attribute being added
//             [setting]   - The last inspected setting of the attribute
//             [base]      - The template setting of the attribute
//             [type]      - The type of of the attribute's data
//             [status]    - The mismatch status of the attribute
//             [cookie]    - The cookie for the result item pane
//             [bVerify]   - True if the setting is set only if it differs
//                           from base (so copy the data)
//             [unit]      - The units the attribute is set in
//             [nID]       - An id to let us know where to save this attribute
//             [pBaseInfo] - The template to save this attribute in
//             [pDataObj]  - The data object for the scope note who owns the result pane
//
//  Returns:   a pointer to the CResult created to hold the item
//
//  History:
//
//---------------------------------------------------------------------------
CResult* CSnapin::AddResultItem(LPCTSTR Attrib,
                       LONG_PTR setting,
                       LONG_PTR base,
                       RESULT_TYPES type,
                       int status,
                       MMC_COOKIE cookie,
                       BOOL bVerify,
                       LPCTSTR unit,
                       LONG_PTR nID,
                       PEDITTEMPLATE pBaseInfo,
                       LPDATAOBJECT pDataObj,
                       CResult *pResult)
{
   if ( bVerify ) 
   {
      if ( (LONG_PTR)SCE_NOT_ANALYZED_VALUE == setting ) 
      {
         //
         // The setting was changed but has not been analyzed.
         //
         status = SCE_STATUS_NOT_ANALYZED;
      } 
      else if ( base == (LONG_PTR)ULongToPtr(SCE_NO_VALUE) ||
           (BYTE)base == (BYTE)SCE_NO_VALUE ) 
      {
         //
         // The setting is no longer configured.
         //
         status = SCE_STATUS_NOT_CONFIGURED;

      } 
      else if ( !(m_pSelectedFolder->GetModeBits() &  MB_LOCAL_POLICY) &&
                  (setting == (LONG_PTR)ULongToPtr(SCE_NO_VALUE) ||
                  (BYTE)setting == (BYTE)SCE_NO_VALUE )) 
      {
         // add the base for current setting
         setting = base;
         status = SCE_STATUS_GOOD;  // a good item

      } 
      else if ( setting != base ) 
         status = SCE_STATUS_MISMATCH;
      else
         status = SCE_STATUS_GOOD;
   }

   CResult* pNewResult = pResult;
   if (!pNewResult)
   {
       pNewResult = new CResult();
       // refCount is already 1 // result->AddRef();
   }

   ASSERT(pNewResult);

   if ( pNewResult ) 
   {
      pNewResult->Create(Attrib,
                     base,
                     setting,
                     type,
                     status,
                     cookie,
                     unit,
                     nID,
                     pBaseInfo,
                     pDataObj,
                     m_pNotifier,
                     this);

      if (!pResult)
      {
         m_pSelectedFolder->AddResultItem (
                        m_resultItemHandle,
                        pNewResult);
      }
   }
   return pNewResult;
}



//+--------------------------------------------------------------------------
//
//  Method:    AddResultItem
//
//  Synopsis:  Add a group item to the analysis section result pane.
//             This adds three actual result pane items:
//                1) The actual name of the group
//                2) The members of the group
//                3) The groups this group is a member of
//
//  Arguments: [szName]      - The name of the group being added
//             [grpTemplate] - The last inspected setting of the attribute
//             [grpInspecte] - The template setting of the attribute
//             [cookie]      - The cookie IDing the result pane item
//             [pDataObj]    - The data object for the scope pane item
//
//  History:
//
//---------------------------------------------------------------------------
void CSnapin::AddResultItem(LPCTSTR szName,
                       PSCE_GROUP_MEMBERSHIP grpTemplate,
                       PSCE_GROUP_MEMBERSHIP grpInspect,
                       MMC_COOKIE cookie,
                       LPDATAOBJECT pDataObj)
{
   //
   // This area contains MAX_ITEM_ID_INDEX(3) linked result lines:
   //    Group Name
   //        Members:       Template    Last Inspected
   //        Membership:    Template    Last Inspected
   //comment out        Privileges:    Template    Last Inspected
   //
   if ( !grpInspect || !szName || !cookie ) 
   {
      ASSERT(FALSE);
      return;
   }

   //
   // pResults & hResultItems are needed to link the lines together
   //
   typedef CResult *PRESULT;
   PRESULT pResults[3];
   HRESULTITEM hResultItems[3];
   int status = 0;


   //
   // add one entry for the group name
   //
   if ( grpInspect->Status & SCE_GROUP_STATUS_NOT_ANALYZED ) 
      status = SCE_STATUS_NOT_CONFIGURED;
   else
      status = -1;
   
   pResults[0]= AddResultItem(szName,                  // The name of the attribute being added
                              (LONG_PTR)grpInspect,       // The last inspected setting of the attribute
                              (LONG_PTR)grpTemplate,      // The template setting of the attribute
                              ITEM_GROUP,              // The type of of the attribute's data
                              status,                  // The mismatch status of the attribute
                              cookie,                  // The cookie for the result item pane
                              FALSE,                   // True if the setting is set only if it differs from base (so copy the data)
                              NULL,                    // The units the attribute is set in
                              NULL,                    // An id to let us know where to save this attribute
                              (CEditTemplate *)szName, // The template to save this attribute in
                              pDataObj);               // The data object for the scope note who owns the result pane

   //
   // L"    -- Members"
   //
   status = grpInspect->Status;
   if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ||
        status & SCE_GROUP_STATUS_NC_MEMBERS ) 
   {
      status = SCE_STATUS_NOT_CONFIGURED;
   } 
   else if ( status & SCE_GROUP_STATUS_MEMBERS_MISMATCH ) 
   {
      status = SCE_STATUS_MISMATCH;
   } 
   else
      status = SCE_STATUS_GOOD;

   pResults[1] = AddResultItem(IDS_GRP_MEMBERS,
                               (LONG_PTR)grpInspect,
                               (LONG_PTR)grpTemplate,
                               ITEM_GROUP_MEMBERS,
                               status,
                               cookie,
                               false,
                               (PEDITTEMPLATE)szName,
                               pDataObj);

   //
   // L"    -- Membership"
   //
   status = grpInspect->Status;
   if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ||
        status & SCE_GROUP_STATUS_NC_MEMBEROF ) 
   {
      status = SCE_STATUS_NOT_CONFIGURED;
   } 
   else if ( status & SCE_GROUP_STATUS_MEMBEROF_MISMATCH ) 
   {
      status = SCE_STATUS_MISMATCH;
   } 
   else
      status = SCE_STATUS_GOOD;

   pResults[2] = AddResultItem(IDS_GRP_MEMBEROF,
                               (LONG_PTR)grpInspect,
                               (LONG_PTR)grpTemplate,
                               ITEM_GROUP_MEMBEROF,
                               status,
                               cookie,
                               false,
                               (PEDITTEMPLATE)szName,
                               pDataObj);
   //
   // save the relative cookies
   //
   if ( pResults[0] )
      pResults[0]->SetRelativeCookies((MMC_COOKIE)pResults[1], (MMC_COOKIE)pResults[2]);

   if ( pResults[1] )
      pResults[1]->SetRelativeCookies((MMC_COOKIE)pResults[0], (MMC_COOKIE)pResults[2]);

   if ( pResults[2] )
      pResults[2]->SetRelativeCookies((MMC_COOKIE)pResults[0], (MMC_COOKIE)pResults[1]);

}

void CSnapin::DeleteList (BOOL bDeleteResultItem)
{
   POSITION pos = NULL;
   if (m_pSelectedFolder && m_resultItemHandle)
   {
      CResult *pResult = 0;

      do {
         if( m_pSelectedFolder->GetResultItem(
                     m_resultItemHandle,
                     pos,
                     &pResult) != ERROR_SUCCESS) 
         {
            break;
         }

         if ( pResult ) 
         {
            if ( bDeleteResultItem ) 
            {
               HRESULTITEM hItem = NULL;
               if( S_OK == m_pResult->FindItemByLParam((LPARAM)m_pResult, &hItem ))
               {
                  if(hItem)
                  {
                     m_pResult->DeleteItem(hItem, 0);
                  }
               }
            }
         } 
         else
            break;
      } while( pos );

      //
      // Release the hold on this object.
      //
      m_pSelectedFolder->ReleaseResultItemHandle( m_resultItemHandle );
      m_resultItemHandle = NULL;
      m_pSelectedFolder = NULL;
   }
}


//+--------------------------------------------------------------------------
//
//  Function:   OnUpdateView
//
//  Synopsis:   If the updated view is being shown by this CSnapin then
//              clear out the old view and redisplay it with the new info
//
//  Arguments:  [lpDataObject] - unused
//              [data] - the cookie for the folder being updated
//              [hint] - unused
//
//
//---------------------------------------------------------------------------
HRESULT
CSnapin::OnUpdateView(LPDATAOBJECT lpDataObject,LPARAM data, LPARAM hint )
{
   if (lpDataObject == (LPDATAOBJECT)this) 
      return S_OK;

   CResult *pResult = (CResult *)data;
   HRESULTITEM hRItem = NULL;
   RESULTDATAITEM resultItem;
   HRESULT hr = m_pResult->FindItemByLParam( (LPARAM)pResult, &hRItem );
   POSITION pos = NULL;

   switch(hint)
   {
   case UAV_RESULTITEM_UPDATEALL:
       //
       // The caller is responsible for clearing the result items from this
       //  this will invalidate all references to the folder object.  Because of
       //  this we have to make sure the reference counter is updated correctly,
       //  so for every CSnapin object GetResultITemHandle is called so that we
       //  don't delete the list when it is still needed.
       //
       if(data != (LPARAM)m_pSelectedFolder && (CFolder*)data != NULL)
       {
           //Raid #258237, 4/12/2001
           CFolder* pCurFolder = (CFolder*)data;
           if( !pCurFolder->GetViewUpdate() )
                return S_OK;
           CFolder* pOldFolder = m_pSelectedFolder;
           pCurFolder->SetViewUpdate(FALSE);
           if( !pCurFolder->GetResultListCount() )
           {
               EnumerateResultPane(
                    (MMC_COOKIE)pCurFolder,
                    pCurFolder->GetScopeItem()->ID,
                    NULL
                    );
               m_pSelectedFolder = pOldFolder;
           }
       }
       if( m_pSelectedFolder->GetViewUpdate() )
           m_pSelectedFolder->SetViewUpdate(FALSE); 

       m_pResult->DeleteAllRsltItems();

       if( !m_pSelectedFolder->GetResultListCount() )
       {
           //
           // This should only be called by the first CSnapin who recieves this message.
           //
           EnumerateResultPane(
               (MMC_COOKIE)m_pSelectedFolder,
               m_pSelectedFolder->GetScopeItem()->ID,
               NULL
               );
         break;
       } 
       else 
       {
           m_pSelectedFolder->GetResultItemHandle(
                                &m_resultItemHandle);
      }
      break;

   case UAV_RESULTITEM_REDRAWALL:
      if( data != (LPARAM)m_pSelectedFolder )
      {
         return S_OK;
      }

      m_pResult->DeleteAllRsltItems();

        ZeroMemory(&resultItem,sizeof(resultItem));
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.str = MMC_CALLBACK;
        resultItem.nImage = -1; // equivalent to: MMC_CALLBACK;

        pos = NULL;

        m_pResult->SetItemCount(
                        m_pSelectedFolder->GetResultListCount( ),
                        MMCLV_UPDATE_NOINVALIDATEALL);

        do {
            m_pSelectedFolder->GetResultItem(
                m_resultItemHandle,
                pos,
                (CResult **)&(resultItem.lParam));
            if(resultItem.lParam)
            {
                m_pResult->InsertItem( &resultItem );
            }
        } while(pos);

        m_pResult->Sort(0, 0, 0);
        break;

    case UAV_RESULTITEM_ADD:
        //
        // This adds a CResult item to the result pane, if and only if the item
        //  does not already exist withen the pane.
        //
        if(!m_pSelectedFolder ||
           !m_pSelectedFolder->GetResultItemPosition(
                m_resultItemHandle,
                pResult) ||
            hRItem ) 
        {
            return S_OK;
        }

       ZeroMemory(&resultItem,sizeof(resultItem));
       resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
       resultItem.str = MMC_CALLBACK;
       resultItem.nImage = -1; // equivalent to: MMC_CALLBACK;

       resultItem.lParam = (LPARAM)pResult;
       m_pResult->InsertItem( &resultItem );
       m_pResult->Sort(0, 0, 0);
        break;

    case UAV_RESULTITEM_REMOVE:
        //
        // This removes the HRESULTITEM associated with the CResult item passed in
        // through the data member.
        //
        if(hRItem)
            m_pResult->DeleteItem( hRItem, 0 );
        break;

    default:
        //
        // By default we just repaint the item.
        //
         m_pResult->UpdateItem( hRItem );
         break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\genserv.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       genserv.cpp
//
//  Contents:   Functions for handling the services within SCE
//
//  History:
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "cservice.h"
#include "aservice.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

void CSnapin::CreateProfServiceResultList(MMC_COOKIE cookie,
                                          FOLDER_TYPES type,
                                          PEDITTEMPLATE pSceInfo,
                                          LPDATAOBJECT pDataObj
                                          )
{
   if ( pSceInfo == NULL || pSceInfo->pTemplate == NULL ) {
      return;
   }
   PSCE_SERVICES pAllServices=NULL, pConfigService;
   DWORD         rc;

   rc = SceEnumerateServices(
                            &pAllServices,
                            TRUE//FALSE
                            );

   if ( rc == NO_ERROR ) {

      for ( PSCE_SERVICES pThisService=pAllServices;
          pThisService != NULL; pThisService = pThisService->Next ) {
         for ( pConfigService=pSceInfo->pTemplate->pServices;
             pConfigService != NULL; pConfigService = pConfigService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 ) {
               break;
            }
         }
         //
         // no matter if config exist for the service, add it
         //
         PWSTR DisplayName=pThisService->DisplayName;
         if ( DisplayName == NULL && pConfigService != NULL ) {
            DisplayName = pConfigService->DisplayName;
         }
         if ( DisplayName == NULL ) {
            DisplayName = pThisService->ServiceName;
         }
         AddResultItem(DisplayName,
                       (LONG_PTR)pThisService,
                       (LONG_PTR)pConfigService,
                       ITEM_PROF_SERV,
                       -1,
                       cookie,
                       FALSE,
                       pThisService->ServiceName,
                       (LONG_PTR)pAllServices,
                       pSceInfo,
                       pDataObj);
      }

      //
      // add the ones not exist in the current system
      //
      for ( pConfigService=pSceInfo->pTemplate->pServices;
          pConfigService != NULL; pConfigService = pConfigService->Next ) {

         for ( pThisService=pAllServices;
             pThisService != NULL; pThisService = pThisService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 )
               break;
         }

         if ( pThisService == NULL ) {
            //
            // the configuration does not exist on local system
            //
            PWSTR DisplayName=pConfigService->DisplayName;
            if ( DisplayName == NULL ) {
               DisplayName = pConfigService->ServiceName;
            }

            AddResultItem( DisplayName,
                           0,
                           (LONG_PTR)pConfigService,
                           ITEM_PROF_SERV,
                           -1,
                           cookie,
                           FALSE,
                           pConfigService->ServiceName,
                           (LONG_PTR)pAllServices,
                           pSceInfo,
                           pDataObj);

         }
      }
   }

}


void CSnapin::DeleteServiceResultList(MMC_COOKIE cookie)
{
   CFolder* pFolder = (CFolder *)cookie;
   // pFolder could be NULL for the root.
   if ( pFolder == NULL )
      return;

   FOLDER_TYPES type = pFolder->GetType();

   if ( type != AREA_SERVICE &&
         type != AREA_SERVICE_ANALYSIS )
      return;


   if ( m_pSelectedFolder == pFolder && m_resultItemHandle )
   {
      POSITION pos = NULL;
      CResult *pResult = NULL;
      if (m_pSelectedFolder->GetResultItem( 
            m_resultItemHandle, 
            pos, 
            &pResult) != ERROR_SUCCESS) 
      {
         if ( pResult != NULL ) 
         {
            PSCE_SERVICES pAllServices = (PSCE_SERVICES)(pResult->GetID());

            SceFreeMemory(pAllServices, SCE_STRUCT_SERVICES);
         }
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     CreateAnalysisServiceResultList
//
//  Synopsis:   Create the list of items to display in the result pane
//              when in the Analysis/Service section
//
//
//  Arguments:  [cookie]   -
//              [type]     -
//              [pSceInfo] -
//              [pBase]    -
//              [pDataObj] -
//
//  Returns:    none
//
//---------------------------------------------------------------------------

void
CSnapin::CreateAnalysisServiceResultList(MMC_COOKIE cookie,
                                         FOLDER_TYPES type,
                                         PEDITTEMPLATE pSceInfo,
                                         PEDITTEMPLATE pBase,
                                         LPDATAOBJECT pDataObj )
{

   if ( pSceInfo == NULL || pBase == NULL ) {
      return;
   }

   PSCE_SERVICES pAllServices=NULL, pConfigService, pAnalService;
   DWORD         rc;

   rc = SceEnumerateServices(
                            &pAllServices,
                            FALSE
                            );

   if ( rc == NO_ERROR ) {

      for ( PSCE_SERVICES pThisService=pAllServices;
          pThisService != NULL; pThisService = pThisService->Next ) {
         //
         // look for base setting on this service
         //
         for ( pConfigService=pBase->pTemplate->pServices;
              pConfigService != NULL;
             pConfigService = pConfigService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 ) {
               break;
            }
         }
         //
         // look for current setting on this service
         //
         for ( pAnalService=pSceInfo->pTemplate->pServices;
              pAnalService != NULL;
             pAnalService = pAnalService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pAnalService->ServiceName) == 0 ) {
               break;
            }
         }
         if ( NULL == pAnalService ) {
            if ( NULL != pConfigService ) {
               //
               // a matched item, use base info as the analysis info
               //
               PWSTR DisplayName=pThisService->DisplayName;
               if ( NULL == DisplayName )
                  DisplayName = pConfigService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pConfigService, // use the same base info
                             (LONG_PTR)pConfigService,
                             ITEM_ANAL_SERV,
                             0,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj);
            } else {
               //
               // a new service
               //
               PWSTR DisplayName=pThisService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pConfigService, // use the same base info
                             (LONG_PTR)pConfigService,
                             ITEM_ANAL_SERV,
                             SCE_STATUS_NEW_SERVICE,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj);
            }
         } else {
            if ( NULL != pConfigService ) {
               //
               // a matched or mismatched item, depending on status
               //
               PWSTR DisplayName=pThisService->DisplayName;
               if ( NULL == DisplayName )
                  DisplayName = pConfigService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pAnalService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pAnalService,
                             (LONG_PTR)pConfigService,
                             ITEM_ANAL_SERV,
                             pAnalService->Status,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj);
            } else {
               //
               // a not configured service, use last analysis as default
               //
               PWSTR DisplayName=pThisService->DisplayName;
               if ( NULL == DisplayName )
                  DisplayName = pAnalService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pAnalService,
                             0,
                             ITEM_ANAL_SERV,
                             SCE_STATUS_NOT_CONFIGURED,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj);
            }
         }
      }

      //
      // ignore the services not existing on the current system
      //
      /*
              for ( pConfigService=pSceInfo->pTemplate->pServices;
                    pConfigService != NULL; pConfigService = pConfigService->Next ) {

                  for ( pThisService=pAllServices;
                        pThisService != NULL; pThisService = pThisService->Next ) {

                      if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 )
                          break;
                  }

                  if ( pThisService == NULL ) {
                      //
                      // the configuration does not exist on local system
                      //
                      PWSTR DisplayName=pConfigService->DisplayName;
                      if ( DisplayName == NULL ) {
                          DisplayName = pConfigService->ServiceName;
                      }

                      AddResultItem( DisplayName, 0, (DWORD)pConfigService,
                                    ITEM_PROF_SERV, -1, cookie,false,
                                    pConfigService->ServiceName,(DWORD)pAllServices,pSceInfo);

                  }
              }
      */
   }
}


HRESULT CSnapin::GetDisplayInfoForServiceNode(RESULTDATAITEM *pResult,
                                              CFolder *pFolder,
                                              CResult *pData)
{
   if ( NULL == pResult || NULL == pFolder || NULL == pData ) {
      return E_INVALIDARG;
   }

   // get display info for columns 1,2, and 3
   PSCE_SERVICES pService = (PSCE_SERVICES)(pData->GetBase());
   PSCE_SERVICES pSetting = (PSCE_SERVICES)(pData->GetSetting());

   if ( pResult->nCol > 3 ) {
      m_strDisplay = L"";
   } else if ((pResult->nCol == 3) && 
              ((GetModeBits() & MB_RSOP) == MB_RSOP)) {
      m_strDisplay = pData->GetSourceGPOString();
   } else if ( NULL == pService ) {
      if ( pFolder->GetType() == AREA_SERVICE_ANALYSIS &&
           NULL != pSetting ) {
         m_strDisplay.LoadString(IDS_NOT_CONFIGURED); //(IDS_INSPECTED);
      } else {
         m_strDisplay.LoadString(IDS_NOT_CONFIGURED);
      }
   } else if ( pFolder->GetType() == AREA_SERVICE_ANALYSIS &&
               (NULL == pSetting ||
                NULL == pSetting->General.pSecurityDescriptor )) {
      m_strDisplay.LoadString(IDS_CONFIGURED);
   } else if (pResult->nCol == 1) {  // both pService and pSetting exist
      // startup value
      if ( pFolder->GetType() == AREA_SERVICE ) {
         switch ( pService->Startup ) {
            case SCE_STARTUP_AUTOMATIC:
               m_strDisplay.LoadString(IDS_AUTOMATIC);
               break;
            case SCE_STARTUP_MANUAL:
               m_strDisplay.LoadString(IDS_MANUAL);
               break;
            default:
               m_strDisplay.LoadString(IDS_DISABLED);
         }
      } else {
         // analysis area
         if ( pService->Startup == pSetting->Startup ) {
            m_strDisplay.LoadString(IDS_OK);
         } else {
            m_strDisplay.LoadString(IDS_INVESTIGATE);
         }
      }

   } else if ( pResult->nCol == 2 ) {
      // column 2 - permission
      if ( pService->SeInfo & DACL_SECURITY_INFORMATION ) {

         if ( pFolder->GetType() == AREA_SERVICE ) {
            m_strDisplay.LoadString(IDS_CONFIGURED);
         } else {
            // analysis area
            if ( pService == pSetting || pSetting->Status == 0 ) {
               m_strDisplay.LoadString(IDS_OK);
            } else {
               m_strDisplay.LoadString(IDS_INVESTIGATE);
            }
         }
      } else {// permission is not configured
         m_strDisplay.LoadString(IDS_NOT_CONFIGURED);
      }

   }

   pResult->str = (LPOLESTR)(LPCTSTR)m_strDisplay;
   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method:     SetupLinkServiceNodeToBase
//
//  Synopsis:
//
//
//
//  Arguments:  [bAdd]   -
//              [theNode]     -
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void
CSnapin::SetupLinkServiceNodeToBase(BOOL bAdd, LONG_PTR theNode)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pBaseInfo;

   //
   // look for the address stored in m_pData->GetBase()
   // if found it, delete it.
   //
   if (0 == theNode) {
      return;
   }

   pet = GetTemplate(GT_COMPUTER_TEMPLATE, AREA_SYSTEM_SERVICE);
   if (NULL == pet) {
      return;
   }
   pBaseInfo = pet->pTemplate;

   PSCE_SERVICES pServParent, pService;

   for ( pService=pBaseInfo->pServices, pServParent=NULL;
       pService != NULL; pServParent=pService, pService=pService->Next ) {

      if ( theNode == (LPARAM)pService ) {
         //
         // find the service node
         //
         if ( !bAdd ) {
            //
            // unlink
            //
            if ( pServParent == NULL ) {
               //
               // the first service
               //
               pBaseInfo->pServices = pService->Next;

            } else {
               pServParent->Next = pService->Next;
            }

            pService->Next = NULL;
         }
         break;
      }
   }
   if ( bAdd && NULL == pService ) {
      //
      // need to add this one
      //
      pService = (PSCE_SERVICES)theNode;
      pService->Next = pBaseInfo->pServices;
      pBaseInfo->pServices = pService;
   }
   return;

}

void CSnapin::AddServiceNodeToProfile(PSCE_SERVICES pNode)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;

   if ( pNode ) {
      pet = GetTemplate(GT_LAST_INSPECTION, AREA_SYSTEM_SERVICE);
      if (!pet) {
         return;
      }
      pProfileInfo = pet->pTemplate;
      pNode->Next = pProfileInfo->pServices;
      pProfileInfo->pServices = pNode;
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\helpdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       helpdlg.h
//
//  Contents:   definition of CHelpDialog
//                              
//----------------------------------------------------------------------------

#if !defined(AFX_HELPDLG_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_HELPDLG_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CHelpDialog : public CDialog
{
public:
    CHelpDialog(const DWORD* pHelpIDs, UINT nIDTemplate, CWnd* pParentWnd)
        : m_pHelpIDs(pHelpIDs), CDialog(nIDTemplate, pParentWnd)
    {
    }

protected:
    afx_msg BOOL    OnHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

private:
    const DWORD*    m_pHelpIDs;
};

#endif  // !defined(AFX_HELPDLG_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\hidwnd.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hidwnd.h
//
//  Contents:   definition of CHiddenWnd
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_HIDWND_H__9C4F7D75_B77E_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
#define AFX_HIDWND_H__9C4F7D75_B77E_11D1_AB7B_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma warning(push,3)
#include <gpedit.h>
#pragma warning(pop)

class CSnapin;
class CFolder;
class CResult;
class CComponentDataImpl;


typedef struct {
   LPDATAOBJECT pDataObject;
   LPARAM       data;
   LPARAM       hint;
} UpdateViewData,*PUPDATEVIEWDATA;


/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd window

class CHiddenWnd : public CWnd
{
// Construction
public:
   CHiddenWnd();
   virtual ~CHiddenWnd();

// Attributes
public:

// Operations
public:

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CHiddenWnd)
   //}}AFX_VIRTUAL

// Implementation
public:
   HRESULT UpdateAllViews(LPDATAOBJECT pDO, LPARAM data, LPARAM hint);
   HRESULT UpdateItem(LPRESULTDATA pRD,HRESULTITEM hri);
   HRESULT RefreshPolicy();
   HRESULT ReloadLocation(CFolder *pFolder, CComponentDataImpl *pCDI);
   HRESULT LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg = TRUE);
   HRESULT SetProfileDescription(CString *strFile, CString *strDescription);
   void SetConsole(LPCONSOLE pConsole);
   void SetComponentDataImpl(CComponentDataImpl *pCDI) { m_pCDI = pCDI; };
   void SetGPTInformation(LPGPEINFORMATION GPTInfo);
   void CloseAnalysisPane();
   void SelectScopeItem(HSCOPEITEM ID);


   HRESULT
   UpdateAllViews(
      LPDATAOBJECT pDO,
      CSnapin *pSnapin,
      CFolder *pFolder,
      CResult *pResult,
      UINT uAction
      );

   //virtual ~CHiddenWnd();

   // Generated message map functions
protected:
   //{{AFX_MSG(CHiddenWnd)
      // NOTE - the ClassWizard will add and remove member functions here.
   //}}AFX_MSG
   afx_msg void OnUpdateAllViews( WPARAM, LPARAM);
   afx_msg void OnUpdateItem( WPARAM, LPARAM);
   afx_msg void OnRefreshPolicy( WPARAM, LPARAM);
   afx_msg void OnReloadLocation( WPARAM, LPARAM);
   afx_msg void OnLockAnalysisPane( WPARAM, LPARAM);
   afx_msg void OnCloseAnalysisPane( WPARAM, LPARAM);
   afx_msg void OnSelectScopeItem( WPARAM, LPARAM);

   DECLARE_MESSAGE_MAP()


private:
   LPCONSOLE m_pConsole;
   CComponentDataImpl *m_pCDI;
   LPGPEINFORMATION m_GPTInfo;

};

typedef CHiddenWnd *LPNOTIFY;

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HIDWND_H__9C4F7D75_B77E_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\hlpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hlpids.h
//
//----------------------------------------------------------------------------
#define IDH_199_323	21168327	// Analyzing System Security: "g" (Static)
#define IDH_170_301	19726506	// Audit File Access : "" (Edit)
#define IDH_199_324	21233863	// Analyzing System Security: "g" (Static)
#define IDH_189_301	19726525	// System Log Retention Method: "Static" (Static)
#define IDH_229_301	19726565	// System Log Retention Method: "Static" (Static)
#define IDH_226_301	19726562	// Audit File Access : "" (Edit)
#define IDH_199_325	21299399	// Analyzing System Security: "g" (Static)
#define IDH_190_302	19792062	// System Log Retention Method: "Overwrite events by &days" (Button)
#define IDH_189_302	19792061	// System Log Retention Method: "Overwrite events by &days" (Button)
#define IDH_168_233	15270056	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
#define IDH_229_302	19792101	// System Log Retention Method: "Overwrite events by &days" (Button)
#define IDH_181_233	15270069	// Lockout Account: "Spin2" (msctls_updown32)
#define IDH_228_233	15270116	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
#define IDH_167_349	22872231	// Rename Administrator Account: "Analyzed Computer Setting" (Button)
#define IDH_199_326	21364935	// Analyzing System Security: "g" (Static)
#define IDH_190_303	19857598	// System Log Retention Method: "Retain log:" (Static)
#define IDH_189_303	19857597	// System Log Retention Method: "Retain log:" (Static)
#define IDH_195_303	19857603	// Logical Disk Manager: "Service startup mode:" (Static)
#define IDH_194_303	19857602	// Directory Replicator: "Service startup mode:" (Static)
#define IDH_173_257	16842925	// Untitled: "Apply" (Button)
#define IDH_168_234	15335592	// Edit Numeric Attribute: "" (Edit)
#define IDH_167_234	15335591	// Rename Administrator Account: "" (Edit)
#define IDH_229_303	19857637	// System Log Retention Method: "Retain log:" (Static)
#define IDH_230_234	15335654	// Rename Administrator Account: "" (Edit)
#define IDH_228_234	15335652	// Edit Numeric Attribute: "" (Edit)
#define IDH_170_350	22937770	// Audit File Access : "Change template setting in database to" (Button)
#define IDH_169_350	22937769	// Secure System Objects: "Change template setting in database to" (Button)
#define IDH_167_350	22937767	// Rename Administrator Account: "C&hange template setting in database to" (Button)
#define IDH_190_350	22937790	// System Log Retention Method: "Change computer template setting to" (Button)
#define IDH_189_350	22937789	// System Log Retention Method: "Change computer template setting to" (Button)
#define IDH_183_350	22937783	// Rename Administrator Account: "C&hange template setting to" (Button)
#define IDH_182_350	22937782	// Edit Enable/Disable Attribute: "Change template setting to" (Button)
#define IDH_181_350	22937781	// Lockout Account: "C&hange template setting to" (Button)
#define IDH_180_350	22937780	// Audit File Access: "Change template setting to" (Button)
#define IDH_198_350	22937798	// Analysis Areas: "Change template setting in database to" (Button)
#define IDH_197_350	22937797	// File and Registry Object Configuration: "Change Template setting to" (Button)
#define IDH_195_350	22937795	// Logical Disk Manager: "Change template setting to" (Button)
#define IDH_194_350	22937794	// Directory Replicator: "Change template setting in database to" (Button)
#define IDH_170_304	19923114	// Audit File Access : "E&xclude from future configurations and analyses" (Button)
#define IDH_169_304	19923113	// Secure System Objects: "E&xclude from future configurations and analyses" (Button)
#define IDH_168_304	19923112	// Edit Numeric Attribute: "E&xclude from future configurations and analyses" (Button)
#define IDH_167_304	19923111	// Rename Administrator Account: "E&xclude from future configurations and analyses" (Button)
#define IDH_199_327	21430471	// Analyzing System Security: "g" (Static)
#define IDH_190_304	19923134	// System Log Retention Method: "E&xclude this setting from configuration" (Button)
#define IDH_189_304	19923133	// System Log Retention Method: "E&xclude from future configurations and analyses" (Button)
#define IDH_183_304	19923127	// Rename Administrator Account: "E&xclude this setting from configuration" (Button)
#define IDH_182_304	19923126	// Edit Enable/Disable Attribute: "E&xclude this setting from configuration" (Button)
#define IDH_181_304	19923125	// Lockout Account: "E&xclude this setting from configuration" (Button)
#define IDH_180_304	19923124	// Audit File Access: "E&xclude this setting from configuration" (Button)
#define IDH_237_350	22937837	// Dialog: "C&hange template setting in database to" (Button)
#define IDH_236_350	22937836	// Dialog: "C&hange template setting to" (Button)
#define IDH_198_304	19923142	// Analysis Areas: "E&xclude from future configurations and analyses" (Button)
#define IDH_197_304	19923141	// File and Registry Object Configuration: "E&xclude this setting from configuration" (Button)
#define IDH_195_304	19923139	// Logical Disk Manager: "E&xclude this setting from configuration" (Button)
#define IDH_194_304	19923138	// Directory Replicator: "E&xclude from future configurations and analyses" (Button)
#define IDH_168_235	15401128	// Edit Numeric Attribute: "failed attempts" (Static)
#define IDH_237_304	19923181	// Dialog: "E&xclude from future configurations and analyses" (Button)
#define IDH_236_304	19923180	// Dialog: "E&xclude this setting from configuration" (Button)
#define IDH_235_304	19923179	// Dialog: "E&xclude from local policy" (Button)
#define IDH_230_304	19923174	// Rename Administrator Account: "E&xclude from local policy" (Button)
#define IDH_229_304	19923173	// System Log Retention Method: "E&xclude from local policy" (Button)
#define IDH_228_304	19923172	// Edit Numeric Attribute: "E&xclude from local policy" (Button)
#define IDH_227_304	19923171	// Secure System Objects: "E&xclude from local policy" (Button)
#define IDH_226_304	19923170	// Audit File Access : "E&xclude from local policy" (Button)
#define IDH_181_235	15401141	// Lockout Account: "failed attempts" (Static)
#define IDH_228_235	15401188	// Edit Numeric Attribute: "failed attempts" (Static)
#define IDH_170_351	23003306	// Audit File Access : "Analyzed Computer Setting" (Button)
#define IDH_169_351	23003305	// Secure System Objects: "Analyzed Computer Setting" (Button)
#define IDH_168_351	23003304	// Edit Numeric Attribute: "Analyzed Computer Setting" (Button)
#define IDH_198_351	23003334	// Analysis Areas: "Analyzed Computer Setting" (Button)
#define IDH_194_351	23003330	// Directory Replicator: "Analyzed Computer Setting" (Button)
#define IDH_199_328	21496007	// Analyzing System Security: "f" (Static)
#define IDH_191_305	19988671	// Untitled: "CheckList" (CHECKLIST_SCE)
#define IDH_237_351	23003373	// Dialog: "Analyzed Computer Setting" (Button)
#define IDH_231_305	19988711	// Untitled: "CheckList" (CHECKLIST_SCE)
#define IDH_195_236	15466691	// Logical Disk Manager: "&Manual" (Button)
#define IDH_194_236	15466690	// Directory Replicator: "&Manual" (Button)
#define IDH_177_352	23068849	// Select Registry Key: "&Registry:" (Static)
#define IDH_183_283	18546871	// Rename Administrator Account: "" (Edit)
#define IDH_173_260	17039533	// Untitled: "&View..." (Button)
#define IDH_212_306	20054228	// Configure System: "Error log file path" (Button)
#define IDH_169_237	15532201	// Secure System Objects: "&Enabled" (Button)
#define IDH_182_237	15532214	// Edit Enable/Disable Attribute: "&Enabled" (Button)
#define IDH_195_237	15532227	// Logical Disk Manager: "&Automatic" (Button)
#define IDH_194_237	15532226	// Directory Replicator: "&Automatic" (Button)
#define IDH_227_237	15532259	// Secure System Objects: "&Enabled" (Button)
#define IDH_186_353	23134394	// Save Computer Templates: "&Select to save:" (Static)
#define IDH_199_330	21627079	// Analyzing System Security: "Account policies" (Static)
#define IDH_198_307	20119750	// Analysis Areas: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
#define IDH_197_307	20119749	// File and Registry Object Configuration: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
#define IDH_195_307	20119747	// Logical Disk Manager: "&Edit Security..." (Button)
#define IDH_194_307	20119746	// Directory Replicator: "&Edit Security..." (Button)
#define IDH_173_261	17105069	// Untitled: "View/&Edit..." (Button)
#define IDH_169_238	15597737	// Secure System Objects: "&Disabled" (Button)
#define IDH_182_238	15597750	// Edit Enable/Disable Attribute: "&Disabled" (Button)
#define IDH_195_238	15597763	// Logical Disk Manager: "&Disabled" (Button)
#define IDH_194_238	15597762	// Directory Replicator: "&Disabled" (Button)
#define IDH_227_238	15597795	// Secure System Objects: "&Disabled" (Button)
#define IDH_218_215	14090458	// Template Description: "" (Edit)
#define IDH_225_215	14090465	// New Template: "" (Edit)
#define IDH_189_354	23199933	// System Log Retention Method: "Last inspected setting" (Button)
#define IDH_168_331	21692584	// Edit Numeric Attribute: "Lockout account after:" (Static)
#define IDH_199_331	21692615	// Analyzing System Security: "Local policies" (Static)
#define IDH_190_308	20185278	// System Log Retention Method: "Overwrite events as &needed" (Button)
#define IDH_189_308	20185277	// System Log Retention Method: "Overwrite events as &needed" (Button)
#define IDH_194_308	20185282	// Directory Replicator: "&Service Security" (Button)
#define IDH_228_331	21692644	// Edit Numeric Attribute: "Lockout account after:" (Static)
#define IDH_229_308	20185317	// System Log Retention Method: "Overwrite events as &needed" (Button)
#define IDH_191_355	23265471	// Untitled: "Assigned to" (Static)
#define IDH_168_332	21758120	// Edit Numeric Attribute: "&Lockout account after:" (Static)
#define IDH_199_332	21758151	// Analyzing System Security: "Restricted groups" (Static)
#define IDH_190_309	20250814	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
#define IDH_189_309	20250813	// System Log Retention Method: "Do not overwrite events(clean log &manually)" (Button)
#define IDH_231_355	23265511	// Untitled: "Assigned to" (Static)
#define IDH_197_309	20250821	// File and Registry Object Configuration: "Igno&reDo not include this object and its child objects in any future configurations or analyses." (Button)
#define IDH_228_332	21758180	// Edit Numeric Attribute: "&Lockout account after:" (Static)
#define IDH_229_309	20250853	// System Log Retention Method: "Do not overwrite events(clean log &manually)" (Button)
#define IDH_106_287	18808938	// Configure Privilege Grant List: "" (ListBox)
#define IDH_191_356	23331007	// Untitled: "Configuration Setting" (Static)
#define IDH_199_333	21823687	// Analyzing System Security: "Registry" (Static)
#define IDH_173_241	15794349	// Untitled: "Change to recommended settings" (Button)
#define IDH_107_288	18874475	// Configure Membership for <group>: "" (ListBox)
#define IDH_191_357	23396543	// Untitled: "Analyzed Setting" (Static)
#define IDH_214_357	23396566	// Untitled: "Analyzed Setting" (Static)
#define IDH_199_334	21889223	// Analyzing System Security: "File systems" (Static)
#define IDH_217_334	21889241	// Untitled: "Overwrite existing template in database" (Button)
#define IDH_216_334	21889240	// Import Template: "&Overwrite existing template in database" (Button)
#define IDH_197_311	20381893	// File and Registry Object Configuration: "&Edit Security..." (Button)
#define IDH_173_242	15859885	// Untitled: "Accept current security settings" (Button)
#define IDH_194_358	23462082	// Directory Replicator: "Service startup mode:" (Static)
#define IDH_199_335	21954759	// Analyzing System Security: "System services" (Static)
#define IDH_216_335	21954776	// Import Template: "" (Edit)
#define IDH_215_335	21954775	// Perform Analysis: "" (Edit)
#define IDH_212_335	21954772	// Configure System: "" (Edit)
#define IDH_170_243	15925418	// Audit File Access : "Audit &successful attempts" (Button)
#define IDH_226_243	15925474	// Audit File Access : "Audit &successful attempts" (Button)
#define IDH_107_290	19005547	// Configure Membership for <group>: "" (ListBox)
#define IDH_214_359	23527638	// Untitled: "Template Setting" (Static)
#define IDH_199_336	22020295	// Analyzing System Security: "Directory service objects" (Static)
#define IDH_216_336	22020312	// Import Template: "&Browse ..." (Button)
#define IDH_215_336	22020311	// Perform Analysis: "&Browse ..." (Button)
#define IDH_212_336	22020308	// Configure System: "&Browse ..." (Button)
#define IDH_198_313	20512966	// Analysis Areas: "&Edit Security..." (Button)
#define IDH_170_244	15990954	// Audit File Access : "Audit &failed attempts" (Button)
#define IDH_214_290	19005654	// Untitled: "CheckList" (CHECKLIST_SCE)
#define IDH_226_244	15991010	// Audit File Access : "Audit &failed attempts" (Button)
#define IDH_106_337	22085738	// Configure Privilege Grant List: "E&xclude from future configurations and analyses" (Button)
#define IDH_107_291	19071083	// Configure Membership for <group>: "Members of this group" (Button)
#define IDH_191_337	22085823	// Untitled: "E&xclude from future configurations and analyses" (Button)
#define IDH_216_360	23593176	// Import Template: "Error log file path" (Button)
#define IDH_198_314	20578502	// Analysis Areas: "&View Security..." (Button)
#define IDH_231_337	22085863	// Untitled: "E&xclude from local policy" (Button)
#define IDH_107_292	19136619	// Configure Membership for <group>: "&Add" (Button)
#define IDH_106_246	16121962	// Configure Privilege Grant List: "A&dd" (Button)
#define IDH_218_361	23658714	// Template Description: "&Description:" (Static)
#define IDH_225_361	23658721	// New Template: "&Description" (Button)
#define IDH_215_338	22151383	// Perform Analysis: "" (Static)
#define IDH_212_338	22151380	// Configure System: "" (Static)
#define IDH_198_315	20644038	// Analysis Areas: "Static" (Static)
#define IDH_191_246	16122047	// Untitled: "&Add..." (Button)
#define IDH_214_246	16122070	// Untitled: "A&dd..." (Button)
#define IDH_231_246	16122087	// Untitled: "&Add..." (Button)
#define IDH_107_293	19202155	// Configure Membership for <group>: "&Remove" (Button)
#define IDH_106_247	16187498	// Configure Privilege Grant List: "&Remove" (Button)
#define IDH_177_339	22216881	// Select Registry Key: "" (Edit)
#define IDH_181_316	20709557	// Lockout Account: "&Lockout account after:" (Static)
#define IDH_225_362	23724257	// New Template: "&Template Name:" (Button)
#define IDH_214_316	20709590	// Untitled: "Members" (Static)
#define IDH_107_248	16253035	// Configure Membership for <group>: "A&dd" (Button)
#define IDH_199_340	22282439	// Analyzing System Security: "Analyzing:" (Static)
#define IDH_235_363	23789803	// Dialog: "Effective Policy Setting" (Button)
#define IDH_230_363	23789798	// Rename Administrator Account: "Effective Policy Setting" (Button)
#define IDH_229_363	23789797	// System Log Retention Method: "Effective Policy Setting" (Button)
#define IDH_228_363	23789796	// Edit Numeric Attribute: "Effective Policy Setting" (Button)
#define IDH_227_363	23789795	// Secure System Objects: "Effective Policy Setting" (Button)
#define IDH_226_363	23789794	// Audit File Access : "Effective Policy Setting" (Button)
#define IDH_177_294	19267761	// Select Registry Key: "Tree1" (SysTreeView32)
#define IDH_180_271	17760436	// Audit File Access: "Audit &successful attempts" (Button)
#define IDH_209_202	13238481	// Untitled: "Security Configuration & Analysis is an administrative tool to secure a computer and analyze security aspects. You can create or edit a security template, apply the security template, perform analysis based on a template, and display analysis results." (Static)
#define IDH_107_249	16318571	// Configure Membership for <group>: "Re&move" (Button)
#define IDH_235_364	23855339	// Dialog: "C&hange Local Policy to" (Button)
#define IDH_230_364	23855334	// Rename Administrator Account: "C&hange Local Policy to" (Button)
#define IDH_229_364	23855333	// System Log Retention Method: "Change Local Policy to" (Button)
#define IDH_228_364	23855332	// Edit Numeric Attribute: "C&hange Local Policy to" (Button)
#define IDH_227_364	23855331	// Secure System Objects: "Change Local Policy to" (Button)
#define IDH_226_364	23855330	// Audit File Access : "Change Local Policy to" (Button)
#define IDH_198_318	20840646	// Analysis Areas: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
#define IDH_186_295	19333306	// Save Computer Templates: "" (ListBox)
#define IDH_225_341	22348001	// New Template: "" (Edit)
#define IDH_180_272	17825972	// Audit File Access: "Audit &failed attempts" (Button)
#define IDH_209_203	13304017	// Untitled: "Security Configuration & Analysis v1.0" (Static)
#define IDH_231_365	23920871	// Untitled: "Local Policy" (Static)
#define IDH_198_319	20906182	// Analysis Areas: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
#define IDH_106_228	14942314	// Configure Privilege Grant List: "User rights" (Button)
#define IDH_231_366	23986407	// Untitled: "Effective Policy" (Static)
#define IDH_197_320	20971717	// File and Registry Object Configuration: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
#define IDH_237_343	22479085	// Dialog: "" (ComboBox)
#define IDH_236_343	22479084	// Dialog: "" (ComboBox)
#define IDH_235_343	22479083	// Dialog: "" (ComboBox)
#define IDH_215_228	14942423	// Perform Analysis: "Error log file path" (Button)
#define IDH_107_229	15007851	// Configure Membership for <group>: "Group is a member of" (Button)
#define IDH_199_321	21037255	// Analyzing System Security: "Progress1" (msctls_progress32)
#define IDH_238_344	22544622	// Dependency failed on %s: "List1" (SysListView32)
#define IDH_181_275	18022581	// Lockout Account: "" (Edit)
#define IDH_169_229	15007913	// Secure System Objects: "" (Edit)
#define IDH_168_229	15007912	// Edit Numeric Attribute: "" (Edit)
#define IDH_167_229	15007911	// Rename Administrator Account: "" (Edit)
#define IDH_194_229	15007938	// Directory Replicator: "Static" (Static)
#define IDH_237_229	15007981	// Dialog: "" (Edit)
#define IDH_235_229	15007979	// Dialog: "" (Edit)
#define IDH_230_229	15007974	// Rename Administrator Account: "" (Edit)
#define IDH_228_229	15007972	// Edit Numeric Attribute: "" (Edit)
#define IDH_227_229	15007971	// Secure System Objects: "" (Edit)
#define IDH_199_322	21102791	// Analyzing System Security: "g" (Static)
#define IDH_238_345	22610158	// Dependency failed on %s: "Warning: By changing '%s' to '%s' you must configure the following items to at least the suggested values." (Static)
#define IDH_239_391	22610100	// Precedency list for RSop result.(SysListView32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\hidwnd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hidwnd.cpp
//
//  Contents:   implementation of CHiddenWnd
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <mmc.h>
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "HidWnd.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SCEM_UPDATE_ALL_VIEWS         (WM_APP+101)
#define SCEM_UPDATE_ITEM              (WM_APP+102)
#define SCEM_REFRESH_POLICY           (WM_APP+103)
#define SCEM_RELOAD_LOCATION          (WM_APP+104)
#define SCEM_SET_PROFILE_DESC         (WM_APP+105)
#define SCEM_LOCK_ANAL_PANE           (WM_APP+106)
#define SCEM_CLOSE_ANAL_PANE          (WM_APP+107)
#define SCEM_SELECT_SCOPE_ITEM        (WM_APP+108)

/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd

CHiddenWnd::CHiddenWnd()
{
   m_GPTInfo = NULL;

   m_pConsole = NULL;
}


CHiddenWnd::~CHiddenWnd()
{
   DestroyWindow(); //Memory leak, 4/27/2001
   if (m_pConsole) {
      m_pConsole->Release();
   }
   if (m_GPTInfo) {
      m_GPTInfo->Release();
   }
}

BEGIN_MESSAGE_MAP(CHiddenWnd, CWnd)
   //{{AFX_MSG_MAP(CHiddenWnd)
      // NOTE - the ClassWizard will add and remove mapping macros here.
   //}}AFX_MSG_MAP
   ON_MESSAGE(SCEM_UPDATE_ALL_VIEWS,OnUpdateAllViews)
   ON_MESSAGE(SCEM_UPDATE_ITEM,OnUpdateItem)
   ON_MESSAGE(SCEM_REFRESH_POLICY,OnRefreshPolicy)
   ON_MESSAGE(SCEM_RELOAD_LOCATION,OnReloadLocation)
   ON_MESSAGE(SCEM_LOCK_ANAL_PANE,OnLockAnalysisPane)
   ON_MESSAGE(SCEM_CLOSE_ANAL_PANE,OnCloseAnalysisPane)
   ON_MESSAGE(SCEM_SELECT_SCOPE_ITEM,OnSelectScopeItem)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd message handlers

#define VOID_RET
void
CHiddenWnd::OnUpdateAllViews(WPARAM uParam, LPARAM lParam)
{


   PUPDATEVIEWDATA puvd;

   puvd = (PUPDATEVIEWDATA)uParam;


   if (!puvd) {
      return VOID_RET;
   }

   if (m_pConsole) {
      m_pConsole->UpdateAllViews(puvd->pDataObject,puvd->data,puvd->hint);
   }

   if( puvd->pDataObject && 1 == (int)lParam ) //Raid #357968, #354861, 4/25/2001
   {
       puvd->pDataObject->Release(); 
   }
   LocalFree(puvd);

   return VOID_RET;
}

void
CHiddenWnd::OnUpdateItem(WPARAM uParam, LPARAM lParam)
{

   LPRESULTDATA pResultPane;
   HRESULTITEM hResultItem;


   pResultPane = (LPRESULTDATA)uParam;
   hResultItem = (HRESULTITEM)lParam;

   if (!pResultPane) {
      return VOID_RET;
   }

   try {
      pResultPane->UpdateItem(hResultItem);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}

void
CHiddenWnd::OnRefreshPolicy(WPARAM uParam, LPARAM lParam)
{
   GUID guidExtension = { 0x827d319e, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a }};
   GUID guidSnapin = CLSID_Snapin;

   if (!m_GPTInfo) {
      return VOID_RET;
   }

   try {
      if (!SUCCEEDED(m_GPTInfo->PolicyChanged(TRUE, TRUE, &guidExtension, &guidSnapin))) {
         AfxMessageBox(IDS_ERROR_REFRESH_POLICY_FAILED);
      }
   } catch (...) {
      AfxMessageBox(IDS_ERROR_REFRESH_POLICY_FAILED);
      ASSERT(FALSE);
   }

   return VOID_RET;
}

void
CHiddenWnd::OnReloadLocation(WPARAM uParam, LPARAM lParam)
{
   CFolder *pFolder;
   CComponentDataImpl *pCDI;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   if (lParam) {
      pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   } else {
      pCDI = m_pCDI;
   }


   try {
      pCDI->ReloadLocation(pFolder);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}

HRESULT
CHiddenWnd::UpdateAllViews(
   LPDATAOBJECT pDO,
   CSnapin *pSnapin,
   CFolder *pFolder,
   CResult *pResult,
   UINT uAction
   )
{
   PUPDATEVIEWDATA puvd;
   if(!m_hWnd){
      return S_OK;
   }

   //
   // Notify item.
   //
   puvd = (UpdateViewData *)LocalAlloc(0, sizeof( UpdateViewData ));

   if (!puvd) {
      return E_FAIL;
   }

   puvd->pDataObject = (LPDATAOBJECT)pSnapin;
   puvd->data        = (LPARAM)pResult;
   puvd->hint        = uAction;

   if (!::PostMessage(m_hWnd, SCEM_UPDATE_ALL_VIEWS, (WPARAM)puvd, 0))
   {
      //
      // puvd will be freed by the SCEM_UPDATE_ALL_VIEWS handler,
      // but if somehow the PostMessage fails we need to free it ourselves.
      //
      LocalFree(puvd);
   }

   return S_OK;
}

HRESULT
CHiddenWnd::UpdateAllViews(LPDATAOBJECT pDO, LPARAM data, LPARAM hint)
{
   PUPDATEVIEWDATA puvd;


   puvd = (UpdateViewData *)LocalAlloc(0, sizeof(UpdateViewData));
   if (!puvd) {
      return E_FAIL;
   }

   puvd->pDataObject = pDO;
   puvd->data = data;
   puvd->hint = hint;

   if (!m_hWnd || !::PostMessage(m_hWnd,SCEM_UPDATE_ALL_VIEWS,(WPARAM)puvd,(LPARAM)1))
   {
      //
      // puvd will be freed by the SCEM_UPDATE_ALL_VIEWS handler,
      // but if somehow the PostMessage fails we need to free it ourselves.
      //
        if( puvd->pDataObject ) //Raid #357968, #354861, 4/25/2001
        {
            puvd->pDataObject->Release();   
        }
        LocalFree( puvd );
   }
   return S_OK;
}


HRESULT
CHiddenWnd::UpdateItem(LPRESULTDATA pResultPane,HRESULTITEM hResultItem)
{
   if (!pResultPane) {
      return E_INVALIDARG;
   }

   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_UPDATE_ITEM,(WPARAM)pResultPane,(LPARAM)hResultItem);
   }
   return S_OK;
}

HRESULT
CHiddenWnd::RefreshPolicy()
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_REFRESH_POLICY,0,0);
   }
   return S_OK;
}

void
CHiddenWnd::SetGPTInformation(LPGPEINFORMATION GPTInfo)
{
   if (m_GPTInfo) {
      m_GPTInfo->Release();
   }
   m_GPTInfo = GPTInfo;
   if (m_GPTInfo) {
      m_GPTInfo->AddRef();
   }
}

void
CHiddenWnd::SetConsole(LPCONSOLE pConsole)
{
   if (m_pConsole) {
      m_pConsole->Release();
   }
   m_pConsole = pConsole;
   if (m_pConsole) {
      m_pConsole->AddRef();
   }
}


HRESULT
CHiddenWnd::ReloadLocation(CFolder * pFolder,CComponentDataImpl * pCDI)
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_RELOAD_LOCATION, (WPARAM)pFolder, (LPARAM)pCDI);
   }
   return S_OK;
}

HRESULT
CHiddenWnd::SetProfileDescription(CString *strFile, CString *strDescription)
{
   LPTSTR szFile = NULL;
   LPTSTR szDescription = NULL;

   if (!strFile->IsEmpty()) {
      szFile = (LPTSTR)LocalAlloc(LPTR,(strFile->GetLength()+1)*sizeof(TCHAR));
      if (!szFile) {
         return E_OUTOFMEMORY;
      }
   }
   if (!strDescription->IsEmpty()) {
      szDescription = (LPTSTR)LocalAlloc(LPTR,(strDescription->GetLength()+1)*sizeof(TCHAR));
      if (!szDescription) {
         LocalFree(szFile);
         return E_OUTOFMEMORY;
      }
   }
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_RELOAD_LOCATION, (WPARAM)szFile, (LPARAM)szDescription);
   }
   return S_OK;
}


void
CHiddenWnd::OnLockAnalysisPane(WPARAM uParam, LPARAM lParam)
{
   try {
      m_pCDI->LockAnalysisPane((BOOL)uParam,(BOOL)lParam);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}


HRESULT
CHiddenWnd::LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg)
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_LOCK_ANAL_PANE, (WPARAM)bLock, (LPARAM)fRemoveAnalDlg);
   }
   return S_OK;
}

void
CHiddenWnd::OnCloseAnalysisPane(WPARAM uParam, LPARAM lParam)
{
   try {
      m_pCDI->CloseAnalysisPane();
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}


void
CHiddenWnd::CloseAnalysisPane()
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_CLOSE_ANAL_PANE, NULL, NULL);
   }
}


void
CHiddenWnd::OnSelectScopeItem(WPARAM uParam, LPARAM lParam)
{
   try {
      m_pCDI->GetConsole()->SelectScopeItem(uParam);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}


void
CHiddenWnd::SelectScopeItem(HSCOPEITEM ID)
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_SELECT_SCOPE_ITEM, (WPARAM) ID, NULL);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\helpdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       helpdlg.cpp
//
//  Contents:   implementation of CHelpDialog
//
//----------------------------------------------------------------------------

#include "StdAfx.h"

#include "HelpDlg.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog message handlers

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
    //{{AFX_MSG_MAP(CHelpDialog)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHelpDialog member functions

afx_msg
BOOL
CHelpDialog::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        if (!::WinHelp(
                (HWND)pHelpInfo->hItemHandle,
                GetSeceditHelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR)m_pHelpIDs))
        {
            ;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\laudit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       laudit.cpp
//
//  Contents:   implementation of CLocalPolAudit
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "laudit.h"
#include "util.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolAudit dialog


CLocalPolAudit::CLocalPolAudit()
: CConfigAudit(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolAudit)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a226HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolAudit message handlers

BOOL CLocalPolAudit::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      DWORD status = 0;

      UpdateData(TRUE);
      if (m_bConfigure) 
      {
         if (m_fSuccessful)
            dw |= AUDIT_SUCCESS;
         
         if (m_fFailed)
            dw |= AUDIT_FAILURE;

         m_pData->SetBase(dw);
         status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
         if (SCE_ERROR_VALUE != status) 
         {
            m_pData->SetStatus(status);
            m_pData->Update(m_pSnapin);
         }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\hlparray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hlparray.h
//
//----------------------------------------------------------------------------

const DWORD a106HelpIDs[]=
{
	IDC_GRANTLIST,	IDH_106_287,	// Configure Privilege Grant List: "" (ListBox)
	IDC_CONFIGURE,	IDH_106_337,	// Configure Privilege Grant List: "E&xclude from future configurations and analyses" (Button)
	IDC_ADD,	IDH_106_246,	// Configure Privilege Grant List: "A&dd" (Button)
	IDC_REMOVE,	IDH_106_247,	// Configure Privilege Grant List: "&Remove" (Button)
	IDC_NC_GROUPS,	IDH_106_228,	// Configure Privilege Grant List: "User rights" (Button)
	0, 0
};




const DWORD a107HelpIDs[]=
{
	IDC_MEMBEROF,	IDH_107_288,	// Configure Membership for <group>: "" (ListBox)
	IDC_MEMBERS,	IDH_107_290,	// Configure Membership for <group>: "" (ListBox)
	IDC_TITLE_MEMBERS,	IDH_107_291,	// Configure Membership for <group>: "Members of this group" (Button)
	IDC_ADD_MEMBER,	IDH_107_292,	// Configure Membership for <group>: "&Add" (Button)
	IDC_REMOVE_MEMBER,	IDH_107_293,	// Configure Membership for <group>: "&Remove" (Button)
	IDC_ADD_MEMBEROF,	IDH_107_248,	// Configure Membership for <group>: "A&dd" (Button)
	IDC_REMOVE_MEMBEROF,	IDH_107_249,	// Configure Membership for <group>: "Re&move" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_107_229,	// Configure Membership for <group>: "Group is a member of" (Button)
	0, 0
};




const DWORD a167HelpIDs[]=
{
	IDC_ANALYZED_COMPUTER_STRING_STATIC,	IDH_167_349,	// Rename Administrator Account: "Analyzed Computer Setting" (Button)
	IDC_NEW,	IDH_167_234,	// Rename Administrator Account: "" (Edit)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_167_350,	// Rename Administrator Account: "C&hange template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_167_304,	// Rename Administrator Account: "E&xclude from future configurations and analyses" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_167_229,	// Rename Administrator Account: "" (Edit)
	0, 0
};




const DWORD a168HelpIDs[]=
{
	IDC_NC_SERVICE,	IDH_168_233,	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
	IDC_NEW,	IDH_168_234,	// Edit Numeric Attribute: "" (Edit)
	IDC_CONFIGURE,	IDH_168_304,	// Edit Numeric Attribute: "E&xclude from future configurations and analyses" (Button)
	IDC_UNITS,	IDH_168_235,	// Edit Numeric Attribute: "failed attempts" (Static)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_168_351,	// Edit Numeric Attribute: "Analyzed Computer Setting" (Button)
	IDC_LI_TITLE,	IDH_168_331,	// Edit Numeric Attribute: "Lockout account after:" (Static)
	IDC_TEMPLATE_TITLE,	IDH_168_332,	// Edit Numeric Attribute: "&Lockout account after:" (Static)
	IDC_TITLE_MEMBER_OF,	IDH_168_229,	// Edit Numeric Attribute: "" (Edit)
	0, 0
};




const DWORD a169HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_169_350,	// Secure System Objects: "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_169_304,	// Secure System Objects: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_169_351,	// Secure System Objects: "Analyzed Computer Setting" (Button)
	IDC_ENABLED,	IDH_169_237,	// Secure System Objects: "&Enabled" (Button)
	IDC_DISABLED,	IDH_169_238,	// Secure System Objects: "&Disabled" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_169_229,	// Secure System Objects: "" (Edit)
	IDC_SETTING,   IDH_169_351, //Computer Setting
	0, 0
};




const DWORD a170HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_170_301,	// Audit File Access : "" (Edit)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_170_350,	// Audit File Access : "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_170_304,	// Audit File Access : "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_170_351,	// Audit File Access : "Analyzed Computer Setting" (Button)
	IDC_CHANGE_SUCCESS,	IDH_170_243,	// Audit File Access : "Audit &successful attempts" (Button)
	IDC_CURRENT_MEMBER_OF,	IDH_170_244,	// Audit File Access : "Audit &failed attempts" (Button)
	0, 0
};




const DWORD a173HelpIDs[]=
{
	IDC_APPLY,	IDH_173_257,	// Untitled: "Apply" (Button)
	IDC_VIEW,	IDH_173_260,	// Untitled: "&View..." (Button)
	IDC_VIEW_EDIT,	IDH_173_261,	// Untitled: "View/&Edit..." (Button)
	IDC_CHANGE,	IDH_173_241,	// Untitled: "Change to recommended settings" (Button)
	IDC_ACCEPT,	IDH_173_242,	// Untitled: "Accept current security settings" (Button)
	0, 0
};




const DWORD a177HelpIDs[]=
{
	IDC_REGISTRY_STATIC,	IDH_177_352,	// Select Registry Key: "&Registry:" (Static)
	IDC_REGKEY,	IDH_177_339,	// Select Registry Key: "" (Edit)
	IDC_REGTREE,	IDH_177_294,	// Select Registry Key: "Tree1" (SysTreeView32)
	0, 0
};




const DWORD a180HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_180_350,	// Audit File Access: "Change template setting to" (Button)
	IDC_CONFIGURE,	IDH_180_304,	// Audit File Access: "E&xclude this setting from configuration" (Button)
	IDC_SUCCESSFUL,	IDH_180_271,	// Audit File Access: "Audit &successful attempts" (Button)
	IDC_FAILED,	IDH_180_272,	// Audit File Access: "Audit &failed attempts" (Button)
	IDC_STATIC_DESCRIPTION2, IDH_180_350, //Audit 
	0, 0
};




const DWORD a181HelpIDs[]=
{
	IDC_NC_SERVICE,	IDH_181_233,	// Lockout Account: "Spin2" (msctls_updown32)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_181_350,	// Lockout Account: "C&hange template setting to" (Button)
	IDC_CONFIGURE,	IDH_181_304,	// Lockout Account: "E&xclude this setting from configuration" (Button)
	IDC_UNITS,	IDH_181_235,	// Lockout Account: "failed attempts" (Static)
	IDC_HEADER,	IDH_181_316,	// Lockout Account: "&Lockout account after:" (Static)
	IDC_VALUE,	IDH_181_275,	// Lockout Account: "" (Edit)
	0, 0
};




const DWORD a182HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_182_350,	// Edit Enable/Disable Attribute: "Change template setting to" (Button)
	IDC_CONFIGURE,	IDH_182_304,	// Edit Enable/Disable Attribute: "E&xclude this setting from configuration" (Button)
	IDC_ENABLED,	IDH_182_237,	// Edit Enable/Disable Attribute: "&Enabled" (Button)
	IDC_DISABLED,	IDH_182_238,	// Edit Enable/Disable Attribute: "&Disabled" (Button)
	0, 0
};




const DWORD a183HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_183_350,	// Rename Administrator Account: "C&hange template setting to" (Button)
	IDC_CONFIGURE,	IDH_183_304,	// Rename Administrator Account: "E&xclude this setting from configuration" (Button)
	IDC_NAME,	IDH_183_283,	// Rename Administrator Account: "" (Edit)
	0, 0
};




const DWORD a186HelpIDs[]=
{
	IDC_SELECT_TO_SAVE_STATIC,	IDH_186_353,	// Save Computer Templates: "&Select to save:" (Static)
	IDC_TEMPLATE_LIST,	IDH_186_295,	// Save Computer Templates: "" (ListBox)
	0, 0
};




const DWORD a189HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_189_301,	// System Log Retention Method: "Static" (Static)
	IDC_RETENTION,	IDH_189_302,	// System Log Retention Method: "Overwrite events by &days" (Button)
	IDC_ATTRIBUTE_NAME,	IDH_189_303,	// System Log Retention Method: "Retain log:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_189_350,	// System Log Retention Method: "Change computer template setting to" (Button)
	IDC_CONFIGURE,	IDH_189_304,	// System Log Retention Method: "E&xclude from future configurations and analyses" (Button)
	IDC_LAST_INSPECTED_STATICSTATIC,	IDH_189_354,	// System Log Retention Method: "Last inspected setting" (Button)
	IDC_RADIO2,	IDH_189_308,	// System Log Retention Method: "Overwrite events as &needed" (Button)
	IDC_RADIO3,	IDH_189_309,	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
	0, 0
};




const DWORD a190HelpIDs[]=
{
	IDC_RETENTION,	IDH_190_302,	// System Log Retention Method: "Overwrite events by &days" (Button)
	IDC_ATTRIBUTE_NAME,	IDH_190_303,	// System Log Retention Method: "Retain log:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_190_350,	// System Log Retention Method: "Change computer template setting to" (Button)
	IDC_CONFIGURE,	IDH_190_304,	// System Log Retention Method: "E&xclude this setting from configuration" (Button)
	IDC_RADIO2,	IDH_190_308,	// System Log Retention Method: "Overwrite events as &needed" (Button)
	IDC_RADIO3,	IDH_190_309,	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
	0, 0
};




const DWORD a191HelpIDs[]=
{
	IDC_RIGHTS,	IDH_191_305,	// Untitled: "CheckList" (CHECKLIST_SCE)
	IDC_ASSIGNED_TO_STATIC,	IDH_191_355,	// Untitled: "Assigned to" (Static)
	IDC_CONFIGURATION_SETTING_STATIC,	IDH_191_356,	// Untitled: "Configuration Setting" (Static)
	IDC_ANALYZED_SETTING_STATIC,	IDH_191_357,	// Untitled: "Analyzed Setting" (Static)
	IDC_CONFIGURE,	IDH_191_337,	// Untitled: "E&xclude from future configurations and analyses" (Button)
	IDC_ADD,	IDH_191_246,	// Untitled: "&Add..." (Button)
	0, 0
};




const DWORD a194HelpIDs[]=
{
	IDC_ATTRIBUTE_NAME,	IDH_194_303,	// Directory Replicator: "Service startup mode:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_194_350,	// Directory Replicator: "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_194_304,	// Directory Replicator: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_194_351,	// Directory Replicator: "Analyzed Computer Setting" (Button)
	IDC_IGNORE,	IDH_194_236,	// Directory Replicator: "&Manual" (Button)
	IDC_ENABLED,	IDH_194_237,	// Directory Replicator: "&Automatic" (Button)
	IDC_OVERWRITE,	IDH_194_307,	// Directory Replicator: "&Edit Security..." (Button)
	IDC_DISABLED,	IDH_194_238,	// Directory Replicator: "&Disabled" (Button)
	IDC_RADIO2,	IDH_194_308,	// Directory Replicator: "&Service Security" (Button)
	IDC_SERVICE_STARTUP_MODE_STATIC,	IDH_194_358,	// Directory Replicator: "Service startup mode:" (Static)
	IDC_TITLE_MEMBER_OF,	IDH_194_229,	// Directory Replicator: "Static" (Static)
	0, 0
};




const DWORD a195HelpIDs[]=
{
	IDC_ATTRIBUTE_NAME,	IDH_195_303,	// Logical Disk Manager: "Service startup mode:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_195_350,	// Logical Disk Manager: "Change template setting to" (Button)
	IDC_CONFIGURE,	IDH_195_304,	// Logical Disk Manager: "E&xclude this setting from configuration" (Button)
	IDC_IGNORE,	IDH_195_236,	// Logical Disk Manager: "&Manual" (Button)
	IDC_ENABLED,	IDH_195_237,	// Logical Disk Manager: "&Automatic" (Button)
	IDC_OVERWRITE,	IDH_195_307,	// Logical Disk Manager: "&Edit Security..." (Button)
	IDC_DISABLED,	IDH_195_238,	// Logical Disk Manager: "&Disabled" (Button)
	0, 0
};




const DWORD a197HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_197_350,	// File and Registry Object Configuration: "Change Template setting to" (Button)
	IDC_CONFIGURE,	IDH_197_304,	// File and Registry Object Configuration: "E&xclude this setting from configuration" (Button)
	IDC_OVERWRITE,	IDH_197_307,	// File and Registry Object Configuration: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
	IDC_RADIO3,	IDH_197_309,	// File and Registry Object Configuration: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	IDC_SECURITY,	IDH_197_311,	// File and Registry Object Configuration: "&Edit Security..." (Button)
	IDC_CHECK,	IDH_197_320,	// File and Registry Object Configuration: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_CONFIG, IDH_197_304, // File and Registry Object Configuration: "E&xclude this setting from configuration" (Button)
	IDC_INHERIT, IDH_197_320, // File and Registry Object Configuration: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_PREVENT, IDH_197_309, // File and Registry Object Configuration: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	0, 0
};




const DWORD a198HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_198_350,	// Analysis Areas: "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_198_304,	// Analysis Areas: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_198_351,	// Analysis Areas: "Analyzed Computer Setting" (Button)
	IDC_OVERWRITE,	IDH_198_307,	// Analysis Areas: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
	IDC_TEMPLATE_SECURITY,	IDH_198_313,	// Analysis Areas: "&Edit Security..." (Button)
	IDC_INSPECTED_SECURITY,	IDH_198_314,	// Analysis Areas: "&View Security..." (Button)
	IDC_INSPECTED,	IDH_198_315,	// Analysis Areas: "Static" (Static)
	IDC_AUTOINHERIT,	IDH_198_318,	// Analysis Areas: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_NOAUTOINHERIT,	IDH_198_319,	// Analysis Areas: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	IDC_CONFIG, IDH_198_304, // Analysis Areas: "E&xclude from future configurations and analyses" (Button)
	IDC_INHERIT, IDH_198_318, // Analysis Areas: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_PREVENT, IDH_198_319, // Analysis Areas: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	0, 0
};




const DWORD a199HelpIDs[]=
{
	IDC_ICON2,	IDH_199_323,	// Analyzing System Security: "g" (Static)
	IDC_ICON3,	IDH_199_324,	// Analyzing System Security: "g" (Static)
	IDC_ICON4,	IDH_199_325,	// Analyzing System Security: "g" (Static)
	IDC_ICON5,	IDH_199_326,	// Analyzing System Security: "g" (Static)
	IDC_ICON6,	IDH_199_327,	// Analyzing System Security: "g" (Static)
	IDC_ICON7,	IDH_199_328,	// Analyzing System Security: "f" (Static)
	IDC_AREA1,	IDH_199_330,	// Analyzing System Security: "Account policies" (Static)
	IDC_LI_TITLE,	IDH_199_331,	// Analyzing System Security: "Local policies" (Static)
	IDC_TEMPLATE_TITLE,	IDH_199_332,	// Analyzing System Security: "Restricted groups" (Static)
	IDC_CHECK1,	IDH_199_333,	// Analyzing System Security: "Registry" (Static)
	IDC_INCREMENTAL,	IDH_199_334,	// Analyzing System Security: "File systems" (Static)
	IDC_LOG_FILE,	IDH_199_335,	// Analyzing System Security: "System services" (Static)
	IDC_BROWSE,	IDH_199_336,	// Analyzing System Security: "Directory service objects" (Static)
	IDC_VERB,	IDH_199_340,	// Analyzing System Security: "Analyzing:" (Static)
	IDC_PROGRESS1,	IDH_199_321,	// Analyzing System Security: "Progress1" (msctls_progress32)
	IDC_ICON1,	IDH_199_322,	// Analyzing System Security: "g" (Static)
	0, 0
};




const DWORD a209HelpIDs[]=
{
	IDC_STATIC_DESC,	IDH_209_202,	// Untitled: "Security Configuration & Analysis is an administrative tool to secure a computer and analyze security aspects. You can create or edit a security template, apply the security template, perform analysis based on a template, and display analysis results." (Static)
	IDC_STATIC_TITLE,	IDH_209_203,	// Untitled: "Security Configuration & Analysis v1.0" (Static)
	0, 0
};




const DWORD a212HelpIDs[]=
{
	IDC_STATIC_FILENAME,	IDH_212_306,	// Configure System: "Error log file path" (Button)
	IDC_LOG_FILE,	IDH_212_335,	// Configure System: "" (Edit)
	IDC_BROWSE,	IDH_212_336,	// Configure System: "&Browse ..." (Button)
	IDC_ERROR,	IDH_212_338,	// Configure System: "" (Static)
	0, 0
};




const DWORD a214HelpIDs[]=
{
	IDC_ANALYZED_SETTING_STATIC,	IDH_214_357,	// Untitled: "Analyzed Setting" (Static)
	IDC_TEMPLATE_SETTING_STATIC,	IDH_214_359,	// Untitled: "Template Setting" (Static)
	IDC_MEMBERS,	IDH_214_290,	// Untitled: "CheckList" (CHECKLIST_SCE)
	IDC_ADD,	IDH_214_246,	// Untitled: "A&dd..." (Button)
	IDC_HEADER,	IDH_214_316,	// Untitled: "Members" (Static)
	0, 0
};




const DWORD a215HelpIDs[]=
{
	IDC_LOG_FILE,	IDH_215_335,	// Perform Analysis: "" (Edit)
	IDC_BROWSE,	IDH_215_336,	// Perform Analysis: "&Browse ..." (Button)
	IDC_ERROR,	IDH_215_338,	// Perform Analysis: "" (Static)
	IDC_NC_GROUPS,	IDH_215_228,	// Perform Analysis: "Error log file path" (Button)
	0, 0
};




const DWORD a216HelpIDs[]=
{
	IDC_INCREMENTAL,	IDH_216_334,	// Import Template: "&Overwrite existing template in database" (Button)
	IDC_LOG_FILE,	IDH_216_335,	// Import Template: "" (Edit)
	IDC_BROWSE,	IDH_216_336,	// Import Template: "&Browse ..." (Button)
	IDC_ERROR_LOG_PROFILE_PATH_STATIC,	IDH_216_360,	// Import Template: "Error log file path" (Button)
	0, 0
};




const DWORD a217HelpIDs[]=
{
	IDC_INCREMENTAL,	IDH_217_334,	// Untitled: "Overwrite existing template in database" (Button)
	0, 0
};




const DWORD a218HelpIDs[]=
{
	IDC_DESCRIPTION,	IDH_218_215,	// Template Description: "" (Edit)
	IDC_DESCRIPTION_STATIC,	IDH_218_361,	// Template Description: "&Description:" (Static)
	0, 0
};




const DWORD a225HelpIDs[]=
{
	IDC_DESCRIPTION,	IDH_225_215,	// New Template: "" (Edit)
	IDC_DESCRIPTION_STATIC,	IDH_225_361,	// New Template: "&Description" (Button)
	IDC_TEMPLATE_NAME_STATIC,	IDH_225_362,	// New Template: "&Template Name:" (Button)
	IDC_CONFIG_NAME,	IDH_225_341,	// New Template: "" (Edit)
	0, 0
};




const DWORD a226HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_226_301,	// Audit File Access : "" (Edit)
	IDC_CONFIGURE,	IDH_226_304,	// Audit File Access : "E&xclude from local policy" (Button)
	IDC_CHANGE_SUCCESS,	IDH_226_243,	// Audit File Access : "Audit &successful attempts" (Button)
	IDC_CURRENT_MEMBER_OF,	IDH_226_244,	// Audit File Access : "Audit &failed attempts" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_226_363,	// Audit File Access : "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_226_364,	// Audit File Access : "Change Local Policy to" (Button)
	IDC_STATIC_DESCRIPTION2, IDH_228_332, //Attribute: (Static)
	IDC_SUCCESSFUL, IDH_226_243, // Audit File Access : "Audit &successful attempts" (Button)
	IDC_FAILED, IDH_226_244, // Audit File Access : "Audit &failed attempts" (Button)
	0, 0
};




const DWORD a227HelpIDs[]=
{
	IDC_CONFIGURE,	IDH_227_304,	// Secure System Objects: "E&xclude from local policy" (Button)
	IDC_ENABLED,	IDH_227_237,	// Secure System Objects: "&Enabled" (Button)
	IDC_DISABLED,	IDH_227_238,	// Secure System Objects: "&Disabled" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_227_363,	// Secure System Objects: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_227_364,	// Secure System Objects: "Change Local Policy to" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_227_229,	// Secure System Objects: "" (Edit)
	0, 0
};




const DWORD a228HelpIDs[]=
{
	IDC_NC_SERVICE,	IDH_228_233,	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
	IDC_NEW,	IDH_228_234,	// Edit Numeric Attribute: "" (Edit)
	IDC_CONFIGURE,	IDH_228_304,	// Edit Numeric Attribute: "E&xclude from local policy" (Button)
	IDC_UNITS,	IDH_228_235,	// Edit Numeric Attribute: "failed attempts" (Static)
	IDC_LI_TITLE,	IDH_228_331,	// Edit Numeric Attribute: "Lockout account after:" (Static)
	IDC_TEMPLATE_TITLE,	IDH_228_332,	// Edit Numeric Attribute: "&Lockout account after:" (Static)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_228_363,	// Edit Numeric Attribute: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_228_364,	// Edit Numeric Attribute: "C&hange Local Policy to" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_228_229,	// Edit Numeric Attribute: "" (Edit)
	IDC_VALUE,	IDH_228_229, // Lockout Account: "" (Edit)
	IDC_HEADER, IDH_228_332,  // Edit Numeric Attribute: "&Lockout account after:" (Static)
	0, 0
};




const DWORD a229HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_229_301,	// System Log Retention Method: "Static" (Static)
	IDC_RETENTION,	IDH_229_302,	// System Log Retention Method: "Overwrite events by &days" (Button)
	IDC_ATTRIBUTE_NAME,	IDH_229_303,	// System Log Retention Method: "Retain log:" (Static)
	IDC_CONFIGURE,	IDH_229_304,	// System Log Retention Method: "E&xclude from local policy" (Button)
	IDC_RADIO2,	IDH_229_308,	// System Log Retention Method: "Overwrite events as &needed" (Button)
	IDC_RADIO3,	IDH_229_309,	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_229_363,	// System Log Retention Method: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_229_364,	// System Log Retention Method: "Change Local Policy to" (Button)
	0, 0
};




const DWORD a230HelpIDs[]=
{
	IDC_NEW,	IDH_230_234,	// Rename Administrator Account: "" (Edit)
	IDC_CONFIGURE,	IDH_230_304,	// Rename Administrator Account: "E&xclude from local policy" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_230_363,	// Rename Administrator Account: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_230_364,	// Rename Administrator Account: "C&hange Local Policy to" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_230_229,	// Rename Administrator Account: "" (Edit)
	IDC_NAME, IDH_230_229, // Rename Administrator Account: "" (Edit)
	0, 0
};




const DWORD a231HelpIDs[]=
{
	IDC_RIGHTS,	IDH_231_305,	// Untitled: "CheckList" (CHECKLIST_SCE)
	IDC_ASSIGNED_TO_STATIC,	IDH_231_355,	// Untitled: "Assigned to" (Static)
	IDC_CONFIGURE,	IDH_231_337,	// Untitled: "E&xclude from local policy" (Button)
	IDC_ADD,	IDH_231_246,	// Untitled: "&Add..." (Button)
	IDC_REMOVE,	IDH_106_247,	// Configure Privilege Grant List: "&Remove" (Button)
	IDC_LOCAL_POLICY_STATIC,	IDH_231_365,	// Untitled: "Local Policy" (Static)
	IDC_EFFECTIVE_POLICY_STATIC,	IDH_231_366,	// Untitled: "Effective Policy" (Static)
	IDC_GRANTLIST,	IDH_106_287,	// Configure Privilege Grant List: "" (ListBox)
	0, 0
};




const DWORD a235HelpIDs[]=
{
	IDC_CONFIGURE,	IDH_235_304,	// Dialog: "E&xclude from local policy" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_235_363,	// Dialog: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_235_364,	// Dialog: "C&hange Local Policy to" (Button)
	IDC_CHOICES,	IDH_235_343,	// Dialog: "" (ComboBox)
	IDC_TITLE_MEMBER_OF,	IDH_235_229,	// Dialog: "" (Edit)
	IDC_CHECKBOX,   IDH_235_343, // Dialog: "" (CHECKLIST_SCE)
	0, 0
};




const DWORD a236HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_236_350,	// Dialog: "C&hange template setting to" (Button)
	IDC_CONFIGURE,	IDH_236_304,	// Dialog: "E&xclude this setting from configuration" (Button)
	IDC_CHOICES,	IDH_236_343,	// Dialog: "" (ComboBox)
	IDC_CHECKBOX,  IDH_236_343,	// Dialog: "" (CHECKLIST_SCE)
	0, 0
};




const DWORD a237HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_237_350,	// Dialog: "C&hange template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_237_304,	// Dialog: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_237_351,	// Dialog: "Analyzed Computer Setting" (Button)
	IDC_CHOICES,	IDH_237_343,	// Dialog: "" (ComboBox)
	IDC_TITLE_MEMBER_OF,	IDH_237_229,	// Dialog: "" (Edit)
	0, 0
};




const DWORD a238HelpIDs[]=
{
	IDC_FAILEDLIST,	IDH_238_344,	// Dependency failed on %s: "List1" (SysListView32)
	IDC_WARNING,	IDH_238_345,	// Dependency failed on %s: "Warning: By changing '%s' to '%s' you must configure the following items to at least the suggested values." (Static)
	0, 0
};

const DWORD a239HelpIDs[]=
{
	IDC_PRECEDENCE_LIST,	IDH_239_391,	// Precedency list for RSop result.(SysListView32)
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lchoice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lchoice.cpp
//
//  Contents:   implementation of CLocalPolChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "LChoice.h"
#include "util.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolChoice dialog


CLocalPolChoice::CLocalPolChoice()
: CConfigChoice(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolChoice)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a235HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolChoice message handlers

BOOL CLocalPolChoice::OnInitDialog()
{
   CConfigChoice::OnInitDialog();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   if (!prv ) //Raid 372939, 4/20/2001
   {
      m_cbChoices.SetCurSel(-1);
   }
   OnSelchangeChoices();
   return TRUE;
}

BOOL CLocalPolChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int nIndex = 0;

      UpdateData(TRUE);
      if (m_bConfigure) 
      {
         nIndex = m_cbChoices.GetCurSel();
         if (CB_ERR != nIndex) 
            dw = (DWORD) m_cbChoices.GetItemData(nIndex);
         
         PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

         //
         // this address should never be NULL
         //
         if ( prv ) 
         {
            PWSTR pTmp=NULL;

            if ( dw != SCE_NO_VALUE ) 
            {
               CString strTmp;
               // allocate buffer
               strTmp.Format(TEXT("%d"), dw);
               pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

               if ( pTmp )
                  wcscpy(pTmp,(LPCTSTR)strTmp);
               else 
               {
                  // can't allocate buffer, error!!
                  return FALSE;
               }
            }

            if ( prv->Value )
               LocalFree(prv->Value);
            
            prv->Value = pTmp;

            m_pSnapin->UpdateLocalPolRegValue(m_pData);
         }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lenable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lenable.h
//
//  Contents:   definition of CLocalPolEnable
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LENABLE_H__2B949F0C_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LENABLE_H__2B949F0C_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolEnable dialog
#include "cenable.h"

class CLocalPolEnable : public CConfigEnable
{
// Construction
public:
   CLocalPolEnable();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolEnable)
   enum { IDD = IDD_LOCALPOL_ENABLE };
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolEnable)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolEnable)
   virtual BOOL OnApply();
   //}}AFX_MSG

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LENABLE_H__2B949F0C_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\laudit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       laudit.h
//
//  Contents:   definition of CLocalPolAudit
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LAUDIT_H__2B949F0A_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LAUDIT_H__2B949F0A_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "caudit.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalPolAudit dialog

class CLocalPolAudit : public CConfigAudit
{
// Construction
public:
   CLocalPolAudit();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolAudit)
	enum { IDD = IDD_LOCALPOL_AUDIT };
	//}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolAudit)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolAudit)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LAUDIT_H__2B949F0A_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lflags.h
//
//  Contents:   definition of CLocalPolRegFlags
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_Lflags_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_Lflags_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_
#include "cflags.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolflags dialog

class CLocalPolRegFlags : public CConfigRegFlags
{
// Construction
public:
   CLocalPolRegFlags();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolRegflags)
        enum { IDD = IDD_LOCALPOL_REGFLAGS };
        //}}AFX_DATA

   virtual void Initialize(CResult *pResult);


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolRegFlags)
   protected:
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolFlags)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_Lflags_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lflags.cpp
//
//  Contents:   implementation of CLocalPolRegFlags
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "LFlags.h"
#include "util.h"
#include "chklist.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegFlags dialog


CLocalPolRegFlags::CLocalPolRegFlags()
: CConfigRegFlags(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolRegFlags)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR) a235HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegFlags message handlers

BOOL CLocalPolRegFlags::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      CWnd *wndCL = NULL;
      DWORD fFlags = 0;

      UpdateData(TRUE);

      wndCL = GetDlgItem(IDC_CHECKBOX);
      ASSERT(wndCL != NULL);

      if (!m_bConfigure || !wndCL) 
         dw = SCE_NO_VALUE;
      else 
      {
         int nItems = (int) wndCL->SendMessage(CLM_GETITEMCOUNT,0,0);
         for (int i=0;i<nItems;i++) 
         {
            dw = (DWORD) wndCL->SendMessage(CLM_GETSTATE,MAKELONG(i,1));
            if (CLST_CHECKED == dw)
               fFlags |= (DWORD)wndCL->SendMessage(CLM_GETITEMDATA,i);
         }
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv);
      if ( prv ) 
      {
         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = NULL;

         if ( fFlags != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), fFlags);
            prv->Value = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( prv->Value )
               lstrcpy(prv->Value,(LPCTSTR)strTmp);
            else
               return FALSE;
         }

         m_pSnapin->UpdateLocalPolRegValue(m_pData);
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CLocalPolRegFlags::Initialize(CResult * pResult)
{
   CConfigRegFlags::Initialize(pResult);
   if (!m_bConfigure) {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lchoice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lchoice.h
//
//  Contents:   definition of CLocalPolChoice
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LCHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_LCHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_
#include "cchoice.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolChoice dialog

class CLocalPolChoice : public CConfigChoice
{
// Construction
public:
   CLocalPolChoice();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolChoice)
	enum { IDD = IDD_LOCALPOL_REGCHOICES };
	//}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolChoice)
   protected:
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolChoice)
   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lenable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lenable.cpp
//
//  Contents:   implementation of CLocalPolEnable
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "snapmgr.h"
#include "lenable.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolEnable dialog


CLocalPolEnable::CLocalPolEnable()
: CConfigEnable(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolEnable)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a227HelpIDs;
   m_uTemplateResID = IDD;
}

BOOL CLocalPolEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int status = 0;
      UpdateData(TRUE);

      if (m_bConfigure) 
      {
         if ( 0 == m_nEnabledRadio ) 
         {
            // ENABLED
            dw = 1;
         }
         else
         {
            // DISABLED
            dw = 0;
         }

         status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
         if (SCE_ERROR_VALUE != status)
         {
            m_pData->SetBase(dw); //Bug211219, Yanggao, 3/15/2001
            m_pData->SetStatus(status);
            m_pData->Update(m_pSnapin);
         }
      }
   }
   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lnumber.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lnumber.cpp
//
//  Contents:   implementation of CLocalPolNumber
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "anumber.h"
#include "lnumber.h"
#include "DDWarn.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolNumber dialog


CLocalPolNumber::CLocalPolNumber()
: CConfigNumber(IDD)
{
    m_pHelpIDs = (DWORD_PTR)a228HelpIDs;
    m_uTemplateResID = IDD;
}

BOOL CLocalPolNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      BOOL bUpdateAll = FALSE;
      DWORD dw = 0;
      CString strForever,strOff;
      int status = 0;

      UpdateData(TRUE);

      if (m_bConfigure) 
      {
         dw = CurrentEditValue();

         bUpdateAll = FALSE;


         PEDITTEMPLATE pLocalDeltaTemplate = m_pSnapin->GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
         if (pLocalDeltaTemplate)
            pLocalDeltaTemplate->LockWriteThrough();

         //
         // Check dependencies for the item.
         //
         if (DDWarn.CheckDependencies (dw) == ERROR_MORE_DATA ) 
         {
            //
            // If the user presses cancel then we will not allow them to set the item and let
            // them press cancel.
            //
            CThemeContextActivator activator;
            if ( DDWarn.DoModal() != IDOK)
               return FALSE;

            //
            // The user is giving us the go ahead to set the items to the suggested 
            // configuration.
            //
            for (int i = 0; i < DDWarn.GetFailedCount(); i++) 
            {
               PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
               if (pItem && pItem->pResult ) 
               {
                  //
                  // Update local policy for each item that failed the dependency.
                  // The suggested values are relative to the item we are configuring.
                  //
                  status = m_pSnapin->SetLocalPolInfo(
                                                     pItem->pResult->GetID(), 
                                                     pItem->dwSuggested);
                  if (SCE_ERROR_VALUE != status) 
                  {
                     pItem->pResult->SetBase( pItem->dwSuggested );
                     pItem->pResult->SetStatus( status );
                     pItem->pResult->Update(m_pSnapin, FALSE);
                  }
               }
            }

         }

         //
         // Update local policy for this item.
         //
         status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
         if (pLocalDeltaTemplate) 
            pLocalDeltaTemplate->UnLockWriteThrough();
      
         if (SCE_ERROR_VALUE != status) 
         {
            m_pData->SetBase(dw);
            m_pData->SetStatus(status);

            //
            // Update the entire pane, not just this particular item, since
            // many of these changes will effect a second item in the pane
            //
            switch (m_pData->GetID()) 
            {
               case IDS_SEC_LOG_DAYS:
               case IDS_APP_LOG_DAYS:
               case IDS_SYS_LOG_DAYS:
                  bUpdateAll = TRUE;
                  break;

               default:
                  break;
            }
         }

         //
         // Redraw the result pane.
         //
         if (SCE_ERROR_VALUE != status || bUpdateAll)
            m_pData->Update(m_pSnapin, bUpdateAll);
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lnumber.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lnumber.h
//
//  Contents:   definition of CLocalPolNumber
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LNUMBER_H__2B949F0D_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LNUMBER_H__2B949F0D_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "cnumber.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalPolNumber dialog

class CLocalPolNumber : public CConfigNumber
{
// Construction
public:
   CLocalPolNumber();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolNumber)
   enum { IDD = IDD_LOCALPOL_NUMBER };
   //}}AFX_DATA

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolNumber)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LNUMBER_H__2B949F0D_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\locdesc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       locdesc.h
//
//  Contents:   definition of CSetLocationDescription
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_SETLOCATIONDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
#define AFX_SETLOCATIONDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SetLocationDescription.h : header file
//

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSetLocationDescription dialog

class CSetLocationDescription : public CHelpDialog
{
// Construction
public:
   CSetLocationDescription(CWnd* pParent = NULL);   // standard constructor

   void Initialize(CFolder *pFolder, CComponentDataImpl *pCDI);

// Dialog Data
   //{{AFX_DATA(CSetLocationDescription)
   enum { IDD = IDD_SET_DESCRIPTION };
   CString  m_strDesc;
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CSetLocationDescription)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CSetLocationDescription)
   virtual void OnOK();
   virtual void OnCancel();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CFolder *m_pFolder;
   CComponentDataImpl *m_pCDI;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SETLOCATIONDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\locdesc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       locdesc.cpp
//
//  Contents:   implementation of CSetLocationDescription
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "cookie.h"
#include "LocDesc.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSetLocationDescription dialog


CSetLocationDescription::CSetLocationDescription(CWnd* pParent /*=NULL*/)
   : CHelpDialog(a218HelpIDs, IDD, pParent)
{
   //{{AFX_DATA_INIT(CSetLocationDescription)
   m_strDesc = _T("");
   //}}AFX_DATA_INIT
}


void CSetLocationDescription::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSetLocationDescription)
   DDX_Text(pDX, IDC_DESCRIPTION, m_strDesc);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetLocationDescription, CHelpDialog)
   //{{AFX_MSG_MAP(CSetLocationDescription)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSetLocationDescription::Initialize(CFolder *pFolder, CComponentDataImpl *pCDI) {
   m_pFolder = pFolder;
   m_pCDI = pCDI;
   m_strDesc = pFolder->GetDesc();
}

/////////////////////////////////////////////////////////////////////////////
// CSetLocationDescription message handlers
DWORD 
SetDescHelper(HKEY hKey,CFolder *pFolder,CString strDesc) {
   DWORD status = RegSetValueEx(hKey,
                          L"Description", // Value name (not localized)
                          0,              // Reserved
                          REG_SZ,
                          (CONST BYTE *)(LPCTSTR)strDesc,
                          (strDesc.GetLength()+1)*sizeof(TCHAR));
   if (NO_ERROR == status) {
      pFolder->SetDesc(strDesc);
   } else {
      // Couldn't set a value
   }

   RegCloseKey(hKey);
   return status;
}

void CSetLocationDescription::OnOK()
{
   DWORD status = 0;
   HKEY hKey = 0;
   CString strLocKey;
   CString strErr;
   LPTSTR szName = 0;
   LPTSTR sz = 0;

   UpdateData(TRUE);

   strLocKey.LoadString(IDS_TEMPLATE_LOCATION_KEY);
   strLocKey += L'\\';
   szName = m_pFolder->GetName();
   // replace '\' with '/' because Registry does not
   // take '/' in a single key
   //
   sz = wcschr(szName, L'\\');
   while (sz) {
      *sz = L'/';
      sz = wcschr(sz, L'\\');
   }
   strLocKey += szName;

   status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         strLocKey,
                         0,
                         KEY_SET_VALUE,
                         &hKey);

   if (NO_ERROR == status) {
      status = SetDescHelper(hKey,m_pFolder,m_strDesc);
   } else {
      //
      // Only display an error if we can read (and thus displayed)
      // this key
      //
      if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   strLocKey,
                                   0,
                                   KEY_READ,
                                   &hKey)) {
         strErr.LoadString(IDS_ERR_GLOBAL_LOC_DESC);
         MessageBox(strErr);
         RegCloseKey(hKey);
      }
   }

   if (NO_ERROR != status) {
      //
      // Bug 375324: if we can't succeed under HKLM try under HKCU
      //
      status = RegOpenKeyEx(HKEY_CURRENT_USER,
                            strLocKey,
                            0,
                            KEY_SET_VALUE,
                            &hKey);
   
      if (NO_ERROR == status) {
         status = SetDescHelper(hKey,m_pFolder,m_strDesc);
      } else {
      //
      // Only display an error if we can read (and thus displayed) 
      // this key
      //
         if (NO_ERROR == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      strLocKey,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
            strErr.LoadString(IDS_ERR_LOCAL_LOC_DESC);
            MessageBox(strErr);
            RegCloseKey(hKey);
         }
      } 
   }

   szName = m_pFolder->GetName();
   // replace '/' with '\' because Registry does not
   sz = wcschr(szName, L'/');
   while (sz) {
      *sz = L'\\';
      sz = wcschr(sz, L'/');
   }

   LPCONSOLENAMESPACE tempnamespace = m_pCDI->GetNameSpace(); //Raid #252638, 5/2/2001
   if( tempnamespace )
   {
       tempnamespace->SetItem(m_pFolder->GetScopeItem());
   }

   DestroyWindow();
}

void CSetLocationDescription::OnCancel()
{
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lstring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lstring.cpp
//
//  Contents:   implementation of CLocalPolString
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "wsecmgr.h"
#include "lstring.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolString dialog


CLocalPolString::CLocalPolString()
: CConfigName(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolString)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a230HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolString message handlers

BOOL CLocalPolString::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      UpdateData(TRUE);

      BOOL bChanged=TRUE;

      m_strName.TrimLeft();
      m_strName.TrimRight();

      if (m_bConfigure) 
      {
         dw = (LONG_PTR)(LPCTSTR)m_strName;
         if ( m_pData->GetBase() && dw &&
              _wcsicmp((LPTSTR)(m_pData->GetBase()), (LPTSTR)dw) == 0 ) 
         {
             bChanged = FALSE;
         }

         if ( bChanged ) 
         {
             if ( m_pData->GetSetting() == m_pData->GetBase() &&
                  m_pData->GetSetting() ) 
             {
                 // a good item, need take the base into setting
                 m_pSnapin->TransferAnalysisName(m_pData->GetID());
             }

             m_pData->SetBase(dw);

             DWORD dwStatus = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
             //Yanggao 1/31/2001 Bug211219.
             if( SCE_STATUS_MISMATCH == dwStatus )
             {
                m_pData->SetStatus(dwStatus);
                m_pData->Update(m_pSnapin,TRUE);
             }
             else if (SCE_ERROR_VALUE != dwStatus)
             {
                m_pData->SetStatus(dwStatus);
                m_pData->Update(m_pSnapin);
             }
         }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lret.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lret.cpp
//
//  Contents:   implementation of CLocalPolRight
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "lret.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRet dialog


CLocalPolRet::CLocalPolRet()
: CConfigRet(IDD)
{
    //{{AFX_DATA_INIT(CLocalPolRet)
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a229HelpIDs;
    m_uTemplateResID = IDD;
}

BOOL CLocalPolRet::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      int status = 0;

      UpdateData(TRUE);

      if (!m_bConfigure) 
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_rabRetention) 
         {
         case RADIO_RETAIN_BY_DAYS:
            dw = SCE_RETAIN_BY_DAYS;
            break;

         case RADIO_RETAIN_AS_NEEDED:
            dw = SCE_RETAIN_AS_NEEDED;
            break;

         case RADIO_RETAIN_MANUALLY:
            dw = SCE_RETAIN_MANUALLY;
            break;

         default:
            break;
         }
      }


      PEDITTEMPLATE pLocalDeltaTemplate = m_pSnapin->GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
      if (pLocalDeltaTemplate) 
         pLocalDeltaTemplate->LockWriteThrough();

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw) == ERROR_MORE_DATA )
      {
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               status = m_pSnapin->SetLocalPolInfo(pItem->pResult->GetID(),
                                                   pItem->dwSuggested);
               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }
      m_pData->SetBase(dw);
      status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
      if (SCE_ERROR_VALUE != status) 
      {
         m_pData->SetStatus(status);
         m_pData->Update(m_pSnapin, TRUE);
      }

      if (pLocalDeltaTemplate)
         pLocalDeltaTemplate->UnLockWriteThrough();
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lright.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lright.cpp
//
//  Contents:   implementation of CLocalPolRight
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "util.h"
#include "chklist.h"
#include "getuser.h"
#include "lright.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRight dialog


CLocalPolRight::CLocalPolRight()
: CConfigPrivs(IDD)
{
    m_pHelpIDs = (DWORD_PTR)a231HelpIDs;
    m_uTemplateResID = IDD;
}


BEGIN_MESSAGE_MAP(CLocalPolRight, CConfigPrivs)
    //{{AFX_MSG_MAP(CConfigPrivs)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


PSCE_PRIVILEGE_ASSIGNMENT
CLocalPolRight::GetPrivData() {
   ASSERT(m_pData);
   if (m_pData) {
      return (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetBase();
   }
   return NULL;
}

void
CLocalPolRight::SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa) {
   ASSERT(m_pData);
   if (m_pData) {
      m_pSnapin->UpdateLocalPolInfo(m_pData,
                                    FALSE,
                                    &ppa,
                                    m_pData->GetUnits()
                                    );
      m_pData->SetBase((LONG_PTR)ppa);
   }
}

void CLocalPolRight::OnAdd() {
   CGetUser gu;

   if (gu.Create( GetSafeHwnd(), 
                  SCE_SHOW_USERS | 
                  SCE_SHOW_LOCALGROUPS | 
                  SCE_SHOW_GLOBAL | 
                  SCE_SHOW_WELLKNOWN | 
                  SCE_SHOW_BUILTIN |
                  SCE_SHOW_SCOPE_ALL | 
                  SCE_SHOW_DIFF_MODE_OFF_DC)) {
      PSCE_NAME_LIST pName = gu.GetUsers();
      CListBox *plbGrant = (CListBox*)GetDlgItem(IDC_GRANTLIST);
      while(pName)
      {
         if (plbGrant && 
             (LB_ERR == plbGrant->FindStringExact(-1,pName->Name)))
         {
            plbGrant->AddString(pName->Name);
            m_fDirty = true;
            SetModified(TRUE); //Raid #389890, 5/11/2001
         }
         pName = pName->Next;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lret.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lret.h
//
//  Contents:   definition of CLocalPolRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LRET_H__2B949F0E_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LRET_H__2B949F0E_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRet dialog
#include "cret.h"

class CLocalPolRet : public CConfigRet
{
// Construction
public:
   CLocalPolRet();   // standard constructor
// Dialog Data
   //{{AFX_DATA(CLocalPolRet)
   enum { IDD = IDD_LOCALPOL_RET };
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolRet)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolRet)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LRET_H__2B949F0E_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lstring.h
//
//  Contents:   definition of CLocalPolString
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LSTRING_H__2B949F10_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LSTRING_H__2B949F10_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"
#include "attr.h"
#include "snapmgr.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalPolString dialog
#include "cname.h"

class CLocalPolString : public CConfigName
{
// Construction
public:
   CLocalPolString();   // standard constructor
// Dialog Data
   //{{AFX_DATA(CLocalPolString)
   enum { IDD = IDD_LOCALPOL_STRING };
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolString)
   protected:
   //}}AFX_VIRTUAL


// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolString)
	virtual BOOL OnApply();
	//}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LSTRING_H__2B949F10_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\lright.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lright.h
//
//  Contents:   definition of CLocalPolRight
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LRIGHT_H__2B949F0F_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LRIGHT_H__2B949F0F_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRight dialog
#include "cprivs.h"

class CLocalPolRight : public CConfigPrivs
{
// Construction
public:
//	virtual void Initialize(CResult *pResult);
   CLocalPolRight();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolRight)
   enum { IDD = IDD_LOCALPOL_RIGHT };
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolRight)
   protected:
   //}}AFX_VIRTUAL

// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CLocalPolRight)
	afx_msg void OnAdd();
   //}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   virtual PSCE_PRIVILEGE_ASSIGNMENT GetPrivData();
   virtual void SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LRIGHT_H__2B949F0F_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\multisz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       multisz.h
//
//  Contents:   definition of CDomainRegMultiSZ
//                              CAttrRegMultiSZ
//                              CLocalPolRegMultiSZ
//                              CConfigRegMultiSZ
//                              
//----------------------------------------------------------------------------
#include "regvldlg.h"

class CDomainRegMultiSZ : public CDomainRegString 
{
public:
   enum { IDD =IDD_DOMAIN_REGMULTISZ };
   CDomainRegMultiSZ() : CDomainRegString(IDD) //Raid #381309, 4/31/2001
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }

protected:
    virtual BOOL OnInitDialog ()
    {
        CDomainRegString::OnInitDialog ();

        SendDlgItemMessage (IDC_NAME, EM_LIMITTEXT, 4096);
	    return TRUE;
    }
};

class CAttrRegMultiSZ : public CAttrRegString 
{
public:
   enum { IDD =IDD_ATTR_REGMULTISZ };
   CAttrRegMultiSZ() : CAttrRegString(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }
};

class CLocalPolRegMultiSZ : public CLocalPolRegString 
{
public:
   enum { IDD =IDD_LOCALPOL_REGMULTISZ };
   CLocalPolRegMultiSZ() : CLocalPolRegString(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }
};


class CConfigRegMultiSZ : public CConfigRegString 
{
public:
   enum { IDD =IDD_CONFIG_REGMULTISZ };
   CConfigRegMultiSZ() : CConfigRegString(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }


protected:
    virtual BOOL OnInitDialog ()
    {
        CConfigRegString::OnInitDialog ();

        SendDlgItemMessage (IDC_NAME, EM_LIMITTEXT, 4096);
	    return TRUE;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\newprof.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       newprof.cpp
//
//  Contents:   implementation of CNewProfile
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "cookie.h"
#include "snapmgr.h"
#include "NewProf.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewProfile dialog


CNewProfile::CNewProfile(CWnd* pParent /*=NULL*/)
    : CHelpDialog(a225HelpIDs, IDD, pParent)
{
   //{{AFX_DATA_INIT(CNewProfile)
   m_strNewFile = _T("");
   m_strDescription = _T("");
   //}}AFX_DATA_INIT
}


void CNewProfile::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CNewProfile)
   DDX_Control(pDX, IDOK, m_btnOK);
   DDX_Text(pDX, IDC_CONFIG_NAME, m_strNewFile);
   DDX_Text(pDX, IDC_DESCRIPTION, m_strDescription);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewProfile, CHelpDialog)
    //{{AFX_MSG_MAP(CNewProfile)
    ON_EN_CHANGE(IDC_CONFIG_NAME, OnChangeConfigName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CNewProfile::Initialize(CFolder *pFolder, CComponentDataImpl *pCDI) {
   m_pFolder = pFolder;
   m_pCDI = pCDI;
   m_strDescription.Empty();
   m_strNewFile.Empty(); //Raid #401939.
}


/////////////////////////////////////////////////////////////////////////////
// CNewProfile message handlers


void CNewProfile::OnChangeConfigName()
{
   UpdateData(TRUE);
   m_btnOK.EnableWindow(!m_strNewFile.IsEmpty());
}

void CNewProfile::OnOK()
{
   CString strExt;
   CString strFile;
   int i = 0;

   UpdateData(TRUE);
   //
   // Make sure the file name is correct.
   //
   i = m_strNewFile.ReverseFind( L'.' );
   if ( i >= 0 ) {
      //
      // If they provided an extension then replace it
      //
      strFile = m_strNewFile.Left(i);
   } else {
      //
      // Otherwise add our own
      //
      strFile = m_strNewFile;
   }
   strExt.LoadString(IDS_PROFILE_DEF_EXT);
   strExt = strFile + TEXT(".") + strExt;

   strFile = m_pFolder->GetName();
   strFile += TEXT("\\") + strExt;

   CString strMsg;

   //
   // Make sure we can create the file
   //
   HANDLE hFile;
   hFile = ExpandAndCreateFile(
                             strFile,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_NEW,
                             FILE_ATTRIBUTE_ARCHIVE,
                             NULL
                             );
   if (hFile == INVALID_HANDLE_VALUE) {
      LPTSTR pszErr;
      CString strMsg;

      FormatMessage(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   0,
                   (LPTSTR)&pszErr,
                   0,
                   NULL
                   );

      strMsg = pszErr + strFile;
      AfxMessageBox(strMsg, MB_OK);
      strFile.Empty();
      return;
   } else {
      //
      // Successfully Created the File
      //
      if (hFile) {
         ::CloseHandle( hFile );
      }
      //
      // Delete it so we can create a new one in its place
      //
      DeleteFile( strFile );
      CreateNewProfile(strFile);


      LPNOTIFY pNotifier = NULL;
      if (m_pCDI) {
         pNotifier = m_pCDI->GetNotifier();
      }

      //
      // Save the description in the template
      //
      if (!m_strDescription.IsEmpty()) {

         CEditTemplate *pet;
         if (m_pCDI) {
            pet = m_pCDI->GetTemplate(strFile);
            if (pet) {
               pet->SetDescription(m_strDescription);
               pet->Save();
            }
         }
      }

      if( LOCATIONS == m_pFolder->GetType() && !m_pFolder->IsEnumerated() ) //Raid #191582, 4/26/2001
      {
         DestroyWindow();
         return;
      }

      if (pNotifier) {
         pNotifier->ReloadLocation(m_pFolder,m_pCDI);
      }
   }

   DestroyWindow();
}


BOOL CNewProfile::OnInitDialog()
{
   CDialog::OnInitDialog();
   m_btnOK.EnableWindow(!m_strNewFile.IsEmpty());

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewProfile::OnCancel()
{
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\newprof.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       newprof.h
//
//  Contents:   definition of CNewProfile
//
//----------------------------------------------------------------------------
#if !defined(AFX_NEWPROFILE_H__BFAC7E70_3C50_11D2_93B4_00C04FD92F7B__INCLUDED_)
#define AFX_NEWPROFILE_H__BFAC7E70_3C50_11D2_93B4_00C04FD92F7B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CNewProfile dialog

class CNewProfile : public CHelpDialog
{
// Construction
public:
   CNewProfile(CWnd* pParent = NULL);   // standard constructor

   void Initialize(CFolder *pFolder, CComponentDataImpl *pCDI);

// Dialog Data
   //{{AFX_DATA(CNewProfile)
   enum { IDD = IDD_NEW_PROFILE };
   CButton  m_btnOK;
   CString  m_strNewFile;
   CString  m_strDescription;
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CNewProfile)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation

protected:

   // Generated message map functions
   //{{AFX_MSG(CNewProfile)
   afx_msg void OnChangeConfigName();
   virtual void OnOK();
   virtual BOOL OnInitDialog();
   virtual void OnCancel();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CFolder *m_pFolder;
   CComponentDataImpl *m_pCDI;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROFILE_H__BFAC7E70_3C50_11D2_93B4_00C04FD92F7B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\perfanal.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       perfanal.h
//
//  Contents:   definition of CPerformAnalysis
//
//----------------------------------------------------------------------------
#if !defined(AFX_PERFANAL_H__69D140AD_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
#define AFX_PERFANAL_H__69D140AD_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CPerformAnalysis dialog

class CPerformAnalysis : public CHelpDialog
{
// Construction
public:
   CPerformAnalysis(CWnd * pParent, UINT nTemplateID);   // standard constructor

// Dialog Data
   //{{AFX_DATA(CPerformAnalysis)
   enum { IDD = IDD_PERFORM_ANALYSIS };
   CButton  m_ctlOK;
   CString  m_strError;
   CString  m_strLogFile;
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CPerformAnalysis)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CPerformAnalysis)
   afx_msg void OnBrowse();
   afx_msg void OnOK();
   afx_msg void OnCancel();
   afx_msg BOOL OnInitDialog();
   afx_msg void OnChangeLogFile();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   virtual DWORD DoIt();

   CString m_strOriginalLogFile;
   CComponentDataImpl *m_pComponentData;

public:
   CString m_strDataBase;

   void SetComponentData(CComponentDataImpl *pCD) { m_pComponentData = pCD; }

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERFANAL_H__69D140AD_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\precdisp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precdisp.h
//
//  Contents:   definition of PrecedenceDisplay
//
//----------------------------------------------------------------------------
#ifndef PRECDISP_H
#define PRECDISP_H

#include "wmihooks.h"

class PrecedenceDisplay 
{
public:
   PrecedenceDisplay (LPTSTR GPOName, LPTSTR Value, ULONG Status, ULONG Error, LPTSTR Value2 = L"") :
      m_szGPO(GPOName),
      m_szValue(Value),
      m_uStatus(Status),
      m_uError(Error),
      m_szValue2(Value2)
   {
   }
   virtual ~PrecedenceDisplay() 
   {
   }

   CString m_szGPO;
   CString m_szValue;
   CString m_szValue2;
   ULONG m_uStatus;
   ULONG m_uError;
};

typedef PrecedenceDisplay *PPRECEDENCEDISPLAY;



#endif // PRECDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\precdisp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precdisp.cpp
//
//  Contents:   implementation of PRECEDENCEDISPLAY
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "wmihooks.h"
#include "snapmgr.h"
#include "cookie.h"
#include "util.h"

vector<PPRECEDENCEDISPLAY>* CResult::GetPrecedenceDisplays() 
{
   if (m_pvecPrecedenceDisplays) 
      return m_pvecPrecedenceDisplays;

   switch(GetType()) 
   {
      case ITEM_PROF_BOOL:
      case ITEM_PROF_DW:
      case ITEM_PROF_SZ:
      case ITEM_PROF_RET:
      case ITEM_PROF_BON:
      case ITEM_PROF_B2ON:
         m_pvecPrecedenceDisplays = GetPolicyPrecedenceDisplays();
         break;

      case ITEM_PROF_REGVALUE:
         m_pvecPrecedenceDisplays = GetRegValuePrecedenceDisplays();
         break;

      case ITEM_PROF_PRIVS:
         m_pvecPrecedenceDisplays = GetPrivilegePrecedenceDisplays();
         break;

      case ITEM_PROF_GROUP:
         m_pvecPrecedenceDisplays = GetGroupPrecedenceDisplays();
         break;

      case ITEM_PROF_REGSD:
         m_pvecPrecedenceDisplays = GetRegistryPrecedenceDisplays();
         break;

      case ITEM_PROF_FILESD:
         m_pvecPrecedenceDisplays = GetFilePrecedenceDisplays();
         break;

      case ITEM_PROF_SERV:
         m_pvecPrecedenceDisplays = GetServicePrecedenceDisplays();
         break;

      default:
//         _ASSERT(0);
         break;
   }

   return m_pvecPrecedenceDisplays;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetPolicyPrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;

   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;

      ASSERT(pspi);
      if (!pspi) 
         continue;

      LPTSTR szValue = NULL;
      LPTSTR szGPO = NULL;

#define HANDLE_PROFILE_CASE(Y,X) \
         case Y: { \
            if (pspi->X == SCE_NO_VALUE) \
               continue; \
            else { \
               szValue = NULL; \
               szGPO = NULL; \
               TranslateSettingToString(pspi->X, GetUnits(), GetType(), &szValue); \
               if (szValue) \
               { \
                  if (pspi->pRI##X && \
                      SUCCEEDED(pWMI->GetGPOFriendlyName(pspi->pRI##X->pszGPOID,&szGPO))) \
                  { \
                     ULONG uStatus = pspi->pRI##X->status; \
                     ULONG uError = pspi->pRI##X->error; \
                     ppd = new PrecedenceDisplay(szGPO, \
                                                 szValue, \
                                                 uStatus, \
                                                 uError); \
                     if (ppd) \
                        pvecDisplay->push_back(ppd); \
                     LocalFree(szGPO); \
                  } \
                  delete [] szValue; \
               } \
            } \
            break; \
        }

#define HANDLE_PROFILE_STRING_CASE(Y,X) \
         case Y: { \
            if (pspi->X == 0) {  \
               continue; \
            } else { \
               szGPO = NULL; \
               if (pspi->pRI##X && \
                   SUCCEEDED(pWMI->GetGPOFriendlyName(pspi->pRI##X->pszGPOID,&szGPO))) { \
                  ULONG uStatus = pspi->pRI##X->status; \
                  ULONG uError = pspi->pRI##X->error; \
                  ppd = new PrecedenceDisplay(szGPO, \
                                              pspi->X, \
                                              uStatus, \
                                              uError); \
                  if (ppd) \
                     pvecDisplay->push_back(ppd); \
                  LocalFree(szGPO); \
               } \
            } \
            break; \
        }

	LONG_PTR id = GetID ();
	switch (id) 
	{
      // L"Maximum passage age", L"Days"
      HANDLE_PROFILE_CASE(IDS_MAX_PAS_AGE,MaximumPasswordAge);

      // L"Minimum passage age", L"Days"
      HANDLE_PROFILE_CASE(IDS_MIN_PAS_AGE,MinimumPasswordAge);

      // L"Minimum passage length", L"Characters"
      HANDLE_PROFILE_CASE(IDS_MIN_PAS_LEN,MinimumPasswordLength);

      // L"Password history size", L"Passwords"
      HANDLE_PROFILE_CASE(IDS_PAS_UNIQUENESS,PasswordHistorySize);

      // L"Password complexity", L""
      HANDLE_PROFILE_CASE(IDS_PAS_COMPLEX,PasswordComplexity);

      // L"Clear Text Password", L""
      HANDLE_PROFILE_CASE(IDS_CLEAR_PASSWORD,ClearTextPassword);

      // L"Require logon to change password", L""
      HANDLE_PROFILE_CASE(IDS_REQ_LOGON,RequireLogonToChangePassword);

     // L"Account lockout count", L"Attempts"
     HANDLE_PROFILE_CASE(IDS_LOCK_COUNT,LockoutBadCount);

     // L"Reset lockout count after", L"Minutes"
     HANDLE_PROFILE_CASE(IDS_LOCK_RESET_COUNT,ResetLockoutCount);

     // L"Lockout duration", L"Minutes"
     HANDLE_PROFILE_CASE(IDS_LOCK_DURATION,LockoutDuration);

     // L"Audit system events"
     HANDLE_PROFILE_CASE(IDS_SYSTEM_EVENT,AuditSystemEvents);

     // L"Audit logon events"
     HANDLE_PROFILE_CASE(IDS_LOGON_EVENT,AuditLogonEvents);

     // L"Audit Object Access"
     HANDLE_PROFILE_CASE(IDS_OBJECT_ACCESS,AuditObjectAccess);

     // L"Audit Privilege Use"
     HANDLE_PROFILE_CASE(IDS_PRIVILEGE_USE,AuditPrivilegeUse);

     // L"Audit policy change"
     HANDLE_PROFILE_CASE(IDS_POLICY_CHANGE,AuditPolicyChange);

     // L"Audit Account Manage"
     HANDLE_PROFILE_CASE(IDS_ACCOUNT_MANAGE,AuditAccountManage);

     // L"Audit process tracking"
     HANDLE_PROFILE_CASE(IDS_PROCESS_TRACK,AuditProcessTracking);

     // L"Audit directory service access"
     HANDLE_PROFILE_CASE(IDS_DIRECTORY_ACCESS,AuditDSAccess);

     // L"Audit Account Logon"
     HANDLE_PROFILE_CASE(IDS_ACCOUNT_LOGON,AuditAccountLogon);

     // L"Force logoff when logon hour expire", L""
     HANDLE_PROFILE_CASE(IDS_FORCE_LOGOFF,ForceLogoffWhenHourExpire);

     // L"Network access: Allow anonymous SID/Name translation"
     HANDLE_PROFILE_CASE(IDS_LSA_ANON_LOOKUP,LSAAnonymousNameLookup);

     // L"Accounts: Administrator account status", L""
     HANDLE_PROFILE_CASE(IDS_ENABLE_ADMIN,EnableAdminAccount);

     // L"Accounts: Guest account status", L""
     HANDLE_PROFILE_CASE(IDS_ENABLE_GUEST,EnableGuestAccount);

      // "Maximum application log size"
      HANDLE_PROFILE_CASE(IDS_APP_LOG_MAX, MaximumLogSize[0]);

      // "Maximum security log size"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_MAX, MaximumLogSize[1]);

      // "Maximum system log size"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_MAX, MaximumLogSize[2]);

      // "Prevent local guests group from accessing application log"
      HANDLE_PROFILE_CASE(IDS_APP_LOG_GUEST, RestrictGuestAccess[0]);

      // "Prevent local guests group from accessing security log"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_GUEST, RestrictGuestAccess[1]);

      // "Prevent local guests group from accessing system log"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_GUEST, RestrictGuestAccess[2]);

      // "Retain application log"
      HANDLE_PROFILE_CASE(IDS_APP_LOG_DAYS, RetentionDays[0]);

      // "Retain security log"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_DAYS, RetentionDays[1]);

      // "Retain system log"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_DAYS, RetentionDays[2]);

      // "Retention method for application log""
      HANDLE_PROFILE_CASE(IDS_APP_LOG_RET, AuditLogRetentionPeriod[0]);

      // "Retention method for security log"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_RET , AuditLogRetentionPeriod[1]);

      // "Retention method for system log"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_RET, AuditLogRetentionPeriod[2]);

	  // "Accounts: Rename administrator account"
      HANDLE_PROFILE_STRING_CASE(IDS_NEW_ADMIN, NewAdministratorName);

      // "Accounts: Rename guest account"
      HANDLE_PROFILE_STRING_CASE(IDS_NEW_GUEST, NewGuestName);

   default:
//      _ASSERT (0);
      break;
      }
   }
#undef HANDLE_PROFILE_CASE
#undef HANDLE_PROFILE_STRING_CASE

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetGroupPrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;
   
   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_GROUP_MEMBERSHIP pGroup = pspi->pGroupMembership;
      list<PRSOP_INFO>::iterator pRIGroup = pspi->listRIGroupMemebership.begin();
      while(pGroup) 
      {
         if (0 == lstrcmp(pGroup->GroupName,GetAttr())) 
         {
            //
            // found our group
            //
            LPTSTR szValue1 = NULL;
            LPTSTR szValue2 = NULL;
            LPTSTR szGPO = NULL;

            ConvertNameListToString(pGroup->pMembers,&szValue1);
            ConvertNameListToString(pGroup->pMemberOf,&szValue2);
            //
            // szValue1 & szValue2 may legitimately be NULL
            //
            if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIGroup)->pszGPOID,&szGPO))) 
            {
               ULONG uError = (*pRIGroup)->error;
               ULONG uStatus = (*pRIGroup)->status;
               ppd = new PrecedenceDisplay(szGPO,
                                           szValue1,
                                           uStatus,
                                           uError,
                                           szValue2);
               if (ppd) 
                  pvecDisplay->push_back(ppd);

               LocalFree(szGPO);
            } 
            if (szValue1) 
               delete [] szValue1;
            if (szValue2) 
               delete [] szValue2;
            break;
         }
         pGroup = pGroup->Next;
         ++pRIGroup;
      }

   }
   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetPrivilegePrecedenceDisplays() 
{
    //
    // Get all of the RSOP info and loop through, collecting
    // the display info for the policy we care about.
    //
    CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
    ASSERT(pWMI);
    if (!pWMI)
        return NULL;
    
    vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
    if (!pvecDisplay)
        return NULL;
    
    PPRECEDENCEDISPLAY ppd = NULL;

    vector<PWMI_SCE_PROFILE_INFO> vecInfo;
    if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
    {
       delete pvecDisplay;
       return NULL;
    }

    if (GetID() <= 0)
    {
        return pvecDisplay;
    }

    PWSTR pName = ((PSCE_PRIVILEGE_ASSIGNMENT)GetID())->Name;

    if (NULL == pName)
    {
        return pvecDisplay;
    }

    for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
        i != vecInfo.end();
        ++i)
    {
        PWMI_SCE_PROFILE_INFO pspi = *i;
        //
        // Find this group in pspi
        //
        PSCE_PRIVILEGE_ASSIGNMENT pPriv = pspi->OtherInfo.smp.pPrivilegeAssignedTo;
        list<PRSOP_INFO>::iterator pRIPriv = pspi->listRIInfPrivilegeAssignedTo.begin();
        while (pPriv)
        {
            if (0 == lstrcmp(pPriv->Name, pName))
            {
                //
                // found our privilege
                //
                LPTSTR szValue = NULL;
                LPTSTR szGPO = NULL;

                ConvertNameListToString(pPriv->AssignedTo,&szValue);
                //
                // szValue may legitimately be NULL
                //
                if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIPriv)->pszGPOID,&szGPO))) 
                {
                   ULONG uStatus = (*pRIPriv)->status;
                   ULONG uError = (*pRIPriv)->error;
                   ppd = new PrecedenceDisplay(szGPO,
                                               szValue,
                                               uStatus,
                                               uError);
                   if (ppd)
                       pvecDisplay->push_back(ppd);

                   LocalFree(szGPO);
                } 
                 if (szValue) 
                    delete [] szValue;
                break;
            }

            pPriv = pPriv->Next;
            ++pRIPriv;
        }
    }

    return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetFilePrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;
   
   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_OBJECT_ARRAY pFiles = pspi->pFiles.pAllNodes;
      if (pFiles) 
      {
         for(DWORD j=0;j<pFiles->Count;j++) 
         {
            if (0 == lstrcmp(pFiles->pObjectArray[j]->Name,GetAttr())) 
            {
               //
               // Found our file
               //

               //
               // Just get the GPO name.  Files don't have displayable settings
               //
               LPTSTR szGPO = NULL;

               vector<PRSOP_INFO>::reference pRIFiles = pspi->vecRIFiles[j];
               if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIFiles).pszGPOID,&szGPO))) 
               {
                  ULONG uStatus = (*pRIFiles).status;
                  ULONG uError = (*pRIFiles).error;
                  ppd = new PrecedenceDisplay(szGPO,
                                              L"",
                                              uStatus,
                                              uError);
                  if (ppd)
                     pvecDisplay->push_back(ppd);
               }
               break;
            }
         }
      }
   }

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetRegistryPrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;
   
   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_OBJECT_ARRAY pRegistryKeys = pspi->pRegistryKeys.pAllNodes;
      if (pRegistryKeys) 
      {
         for(DWORD j=0;j<pRegistryKeys->Count;j++) 
         {
            if (0 == lstrcmp(pRegistryKeys->pObjectArray[j]->Name,GetAttr())) 
            {
               //
               // Found our RegistryKey
               //

               //
               // Just get the GPO name.  RegistryKeys don't have displayable settings
               //
               LPTSTR szGPO = NULL;

               vector<PRSOP_INFO>::reference pRIReg = pspi->vecRIReg[j];
               if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIReg).pszGPOID,&szGPO))) 
               {
                  ULONG uStatus = (*pRIReg).status;
                  ULONG uError = (*pRIReg).error;
                  ppd = new PrecedenceDisplay(szGPO,
                                              L"",
                                              uStatus,
                                              uError);
                  if (ppd) 
                     pvecDisplay->push_back(ppd);

                  LocalFree(szGPO);
               }
               break;
            }
         }

      }
   }

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetServicePrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;

   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_SERVICES pServices = pspi->pServices;
      list<PRSOP_INFO>::iterator pRIServices = pspi->listRIServices.begin();
      while(pServices) 
      {
         if (0 == lstrcmp(pServices->ServiceName,GetUnits())) 
         {
            //
            // found our Servicesilege
            //
            LPTSTR szGPO = NULL;

            //
            // Just get the GPO name.  Services don't have displayable settings
            //
            if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIServices)->pszGPOID,&szGPO))) 
            {
               ULONG uStatus = (*pRIServices)->status;
               ULONG uError = (*pRIServices)->error;
               ppd = new PrecedenceDisplay(szGPO,
                                           L"",
                                           uStatus,
                                           uError);
               if (ppd)
                  pvecDisplay->push_back(ppd);

               LocalFree(szGPO);
               szGPO = NULL;
            }
            break;
         }
         pServices = pServices->Next;
         ++pRIServices;
      }
   }

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetRegValuePrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;

   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      for(DWORD j=0;j < pspi->RegValueCount;j++) 
      {
         if (0 == lstrcmp(pspi->aRegValues[j].FullValueName,((PSCE_REGISTRY_VALUE_INFO)GetBase())->FullValueName)) 
         {
            //
            // Found our Registry Value
            //
            LPTSTR pDisplayName=NULL;
            DWORD displayType = 0;
            LPTSTR szUnits=NULL;
            PREGCHOICE pChoices=NULL;
            PREGFLAGS pFlags=NULL;
            LPTSTR szValue = NULL;

            PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO) GetBase();
            if (LookupRegValueProperty(prv->FullValueName,
                                       &pDisplayName,
                                       &displayType,
                                       &szUnits,
                                       &pChoices,
                                       &pFlags) ) 
            {
               //
               // Determine string by the item value.
               //
               switch ( GetID() ) 
               {
                  case SCE_REG_DISPLAY_NUMBER:
                     if ( prv->Value ) 
                     {
                        TranslateSettingToString(
                                                _wtol(prv->Value),
                                                GetUnits(),
                                                ITEM_DW,
                                                &szValue);
                     }
                     break;

                  case SCE_REG_DISPLAY_CHOICE:
                     if ( prv->Value ) 
                     {
                        TranslateSettingToString(_wtol(prv->Value),
                                                 NULL,
                                                 ITEM_REGCHOICE,
                                                 &szValue);
                     }
                     break;

                  case SCE_REG_DISPLAY_FLAGS:
                     if ( prv->Value ) 
                     {
                        TranslateSettingToString(_wtol(prv->Value),
                                                 NULL,
                                                 ITEM_REGFLAGS,
                                                 &szValue);
                     }
                     break;

                  case SCE_REG_DISPLAY_MULTISZ:
                  case SCE_REG_DISPLAY_STRING:
                     if (prv && prv->Value) 
                     {
                        szValue = new TCHAR[lstrlen(prv->Value)+1];
                        if (szValue)
                           lstrcpy(szValue,prv->Value);
                     }
                     break;

                  default: // boolean
                     if ( prv->Value ) 
                     {
                        long val = _wtol(prv->Value);
                        TranslateSettingToString( val,
                                                  NULL,
                                                  ITEM_BOOL,
                                                  &szValue);
                     }
                     break;
               }
            }

            LPTSTR szGPO = NULL;
            vector<PRSOP_INFO>::reference pRIReg = pspi->vecRIRegValues[j];

            if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIReg).pszGPOID,&szGPO))) 
            {
               ULONG uStatus = (*pRIReg).status;
               ULONG uError = (*pRIReg).error;
               ppd = new PrecedenceDisplay(szGPO,
                                           szValue,
                                           uStatus,
                                           uError);
               if (ppd) 
               {
                  pvecDisplay->push_back(ppd);
                  szGPO = NULL;
                  szValue = NULL;
               } 
            }

            if ( szGPO )
                LocalFree(szGPO);

            if ( szValue ) 
                delete [] szValue;
            //
            // no need to keep looking once we've found the one we're looking for
            //
            break;
         }
      }
   }

   return pvecDisplay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\precpage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precpage.cpp
//
//  Contents:   implementation of CPrecedencePage
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <secedit.h>
#include "wsecmgr.h"
#include "precpage.h"
#include "snapmgr.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define PRECEDENCE_STATUS_SUCCESS 1
#define PRECEDENCE_STATUS_NO_CONFIG 0
#define PRECEDENCE_STATUS_INVALID 2
#define PRECEDENCE_STATUS_ERROR 3
#define PRECEDENCE_STATUS_CHILD_ERROR 4

/////////////////////////////////////////////////////////////////////////////
// CPrecedencePage property page

IMPLEMENT_DYNCREATE(CPrecedencePage, CSelfDeletingPropertyPage)

CPrecedencePage::CPrecedencePage() : CSelfDeletingPropertyPage(IDD)
{
        //{{AFX_DATA_INIT(CPrecedencePage)
        m_strSuccess = _T("");
        m_strTitle = _T("");
        m_strError = _T("");
        //}}AFX_DATA_INIT

   m_pResult = NULL;
   m_pWMI = NULL;
   m_pHelpIDs = (DWORD_PTR)a239HelpIDs;
}

CPrecedencePage::~CPrecedencePage()
{
}

void CPrecedencePage::DoDataExchange(CDataExchange* pDX)
{
        CSelfDeletingPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPrecedencePage)
        DDX_Control(pDX, IDC_PRECEDENCE_LIST, m_PrecedenceList);
        DDX_Control(pDX, IDC_ERROR_ICON, m_iconError);
        DDX_Text(pDX, IDC_SUCCESS_TEXT, m_strSuccess);
        DDX_Text(pDX, IDC_TITLE, m_strTitle);
        DDX_Text(pDX, IDC_ERROR_TEXT, m_strError);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrecedencePage, CSelfDeletingPropertyPage)
        //{{AFX_MSG_MAP(CPrecedencePage)
        //}}AFX_MSG_MAP
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp) //Bug 139470, 4/19/2001
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrecedencePage message handlers

BOOL CPrecedencePage::OnInitDialog()
{
   CSelfDeletingPropertyPage::OnInitDialog();

   CString strColumn;

#define COL_WIDTH 200

   strColumn.LoadString(IDS_PRECEDENCE_GPO_HEADER);
   m_PrecedenceList.InsertColumn(0,strColumn,LVCFMT_LEFT,COL_WIDTH,0);

   switch(m_pResult->GetType()) 
   {
      case ITEM_PROF_GROUP:
         //
         // Two value columns for groups
         //
         strColumn.LoadString(IDS_COL_MEMBERSHIP);
         m_PrecedenceList.InsertColumn(1,strColumn,LVCFMT_LEFT,COL_WIDTH,1);
         strColumn.LoadString(IDS_COL_MEMBEROF);
         m_PrecedenceList.InsertColumn(2,strColumn,LVCFMT_LEFT,COL_WIDTH,1);
         break;

      case ITEM_PROF_REGSD:
      case ITEM_PROF_FILESD:
      case ITEM_PROF_SERV:
         //
         // No value columns for files, reg keys, or services
         //
         break;

      default:
         //
         // One value column for everything else
         //
         strColumn.LoadString(IDS_PRECEDENCE_VALUE_HEADER);
         m_PrecedenceList.InsertColumn(1,strColumn,LVCFMT_LEFT,COL_WIDTH,1);
         break;
   }

   vector<PPRECEDENCEDISPLAY>* pvecDisplay = m_pResult->GetPrecedenceDisplays();
   ASSERT(pvecDisplay);
   if (!pvecDisplay || pvecDisplay->empty()) 
   {
      return TRUE;
   }

   int nItem = 0;
   for(vector<PPRECEDENCEDISPLAY>::iterator i = pvecDisplay->begin();
       i != pvecDisplay->end();
       ++i ) 
   {
      PPRECEDENCEDISPLAY ppd = *i;

      if ( ppd->m_szGPO.IsEmpty ()) 
      {
         ASSERT(!ppd->m_szGPO.IsEmpty ());
         continue;
      }

      //
      // CListCtrl will make a copy of the string passed in so
      // there is no point allocating buffer
      // (and not free it)
      //
      nItem = m_PrecedenceList.InsertItem (nItem,
                                         (PCWSTR) ppd->m_szGPO);

      if (nItem != -1) 
      {
         if ( !ppd->m_szValue.IsEmpty () ) 
         {
            m_PrecedenceList.SetItem(nItem,
                                 1,
                                 LVIF_TEXT,
                                 (PCWSTR) ppd->m_szValue,
                                 0,
                                 0,
                                 0,
                                 0);
         }
         if ( !ppd->m_szValue2.IsEmpty () ) 
         {
            m_PrecedenceList.SetItem(nItem,
                                 2,
                                 LVIF_TEXT,
                                 (PCWSTR) ppd->m_szValue2,
                                 0,
                                 0,
                                 0,
                                 0);
         }
      }
      nItem++;
   }

   vector<PPRECEDENCEDISPLAY>::reference ppd = pvecDisplay->front();
   if (ppd) 
   {
      if (ppd->m_uStatus == PRECEDENCE_STATUS_SUCCESS) 
      {
         GetDlgItem(IDC_ERROR_TEXT)->SetWindowPos(NULL,0,0,0,0,SWP_HIDEWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
         GetDlgItem(IDC_ERROR_ICON)->SetWindowPos(NULL,0,0,0,0,SWP_HIDEWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
      } 
      else 
      {
         GetDlgItem(IDC_SUCCESS_TEXT)->SetWindowPos(NULL,0,0,0,0,SWP_HIDEWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
      }

      CImageList il;
      HICON icon = NULL;
      il.Create(IDB_ICON16,16,1,RGB(255,0,255));
      if (ppd->m_uStatus != PRECEDENCE_STATUS_SUCCESS) 
      {
         icon = m_iconError.SetIcon(il.ExtractIcon(SCE_CRITICAL_IDX));
         if (icon) 
         {
            DestroyIcon(icon);
         }
      }
   }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CPrecedencePage::Initialize(CResult *pResult, CWMIRsop *pWMI) 
{
   m_pResult = pResult;
   m_pWMI = pWMI;

   vector<PPRECEDENCEDISPLAY>* pvecDisplay = m_pResult->GetPrecedenceDisplays();
   ASSERT(pvecDisplay);
   if (pvecDisplay && !pvecDisplay->empty()) 
   {
      vector<PPRECEDENCEDISPLAY>::reference ppd = pvecDisplay->front();
      if (ppd) 
      {
         switch (ppd->m_uStatus) 
         {
            case PRECEDENCE_STATUS_NO_CONFIG:
               m_strError.LoadString(IDS_PRECEDENCE_NO_CONFIG);
               break;

            case PRECEDENCE_STATUS_INVALID:
               AfxFormatString1 (m_strError, IDS_PRECEDENCE_INVALID,
                     (PCWSTR) ppd->m_szGPO);
               break;

            case PRECEDENCE_STATUS_ERROR: 
               {
                  CString strErr;
                  if (SCESTATUS_SUCCESS != FormatDBErrorMessage (ppd->m_uError,
                        NULL, strErr)) 
                  {
                     strErr.LoadString(IDS_UNKNOWN_ERROR);
                  }
                  AfxFormatString2 (m_strError, IDS_PRECEDENCE_ERROR, 
                        (PCWSTR) ppd->m_szGPO, strErr);
               }
               break;
               
            case PRECEDENCE_STATUS_SUCCESS:
               AfxFormatString1 (m_strSuccess, IDS_PRECEDENCE_SUCCESS, 
                     (PCWSTR) ppd->m_szGPO);
               break;

            case PRECEDENCE_STATUS_CHILD_ERROR:
               m_strError.LoadString(IDS_PRECEDENCE_CHILD_ERROR);
               break;

            default:
               break;
         }
      }
   }
}


BOOL CPrecedencePage::OnHelp(WPARAM wParam, LPARAM lParam) //Bug 316461, Yanggao, 3/14/2001
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        if(pHelpInfo->iCtrlId != -1)
            this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CPrecedencePage::DoContextHelp(HWND hWndControl) //Bug 316461, Yanggao, 3/14/2001
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetGpeditHelpFilename(),
            HELP_WM_HELP,
            m_pHelpIDs))
    {

    }
}

BOOL CPrecedencePage::OnContextHelp(WPARAM wParam, LPARAM lParam)
{
HMENU hMenu = CreatePopupMenu();

    if( hMenu )
    {
        CString str;
        str.LoadString(IDS_WHAT_ISTHIS); 
        if( AppendMenu(hMenu, MF_STRING, IDM_WHAT_ISTHIS, str) )
        {
            int itemID = TrackPopupMenu(hMenu, 
                                TPM_LEFTALIGN|TPM_TOPALIGN|TPM_RETURNCMD|
                                TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                                LOWORD(lParam), HIWORD(lParam), 0, (HWND)wParam, NULL);
            if( itemID == IDM_WHAT_ISTHIS ) //Raid #139470, 4/11/2001
            {
                if( ((HWND)wParam) != this->m_hWnd )
                {
                    ::WinHelp((HWND)wParam,
                        GetGpeditHelpFilename(),
                        HELP_WM_HELP,
                        m_pHelpIDs);
                }
                else
                {
                    POINT pos;
                    pos.x = LOWORD(lParam);
                    pos.y = HIWORD(lParam);
                    ScreenToClient( &pos );
                    CWnd* pWnd = ChildWindowFromPoint(pos, CWP_SKIPINVISIBLE);
                    if( pWnd )
                    {
				        ::WinHelp(pWnd->m_hWnd,
                            GetGpeditHelpFilename(),
                            HELP_WM_HELP,
                            m_pHelpIDs);
                    }
                    else
                    {
                        ::WinHelp((HWND)wParam,
                            GetGpeditHelpFilename(),
                            HELP_WM_HELP,
                            m_pHelpIDs);
                    }
                }
            }
        }
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\perfanal.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       perfanal.cpp
//
//  Contents:   implementation of CPerformAnalysis
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "PerfAnal.h"
#include "wrapper.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPerformAnalysis dialog


CPerformAnalysis::CPerformAnalysis(CWnd * pParent, UINT nTemplateID)
: CHelpDialog(a215HelpIDs, nTemplateID ? nTemplateID : IDD, pParent)
{
   //{{AFX_DATA_INIT(CPerformAnalysis)
   m_strLogFile = _T("");
   //}}AFX_DATA_INIT
}


void CPerformAnalysis::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPerformAnalysis)
   DDX_Control(pDX, IDOK, m_ctlOK);
   DDX_Text(pDX, IDC_ERROR, m_strError);
   DDX_Text(pDX, IDC_LOG_FILE, m_strLogFile);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPerformAnalysis, CHelpDialog)
   //{{AFX_MSG_MAP(CPerformAnalysis)
   ON_BN_CLICKED(IDOK, OnOK)
   ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
   ON_EN_CHANGE(IDC_LOG_FILE, OnChangeLogFile)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPerformAnalysis message handlers

void CPerformAnalysis::OnBrowse()
{
   CString strLogFileExt;
   CString strLogFileFilter;
   CString strTitle;

   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);

   UpdateData(TRUE);

   strLogFileExt.LoadString(IDS_LOGFILE_DEF_EXT);
   strLogFileFilter.LoadString(IDS_LOGFILE_FILTER);
   strTitle.LoadString(IDS_LOGFILE_PICKER_TITLE);

   // Translate filter into commdlg format (lots of \0)
   LPTSTR szFilter = strLogFileFilter.GetBuffer(0); // modify the buffer in place
   // MFC delimits with '|' not '\0'

   LPTSTR pch = szFilter;
   while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
   // do not call ReleaseBuffer() since the string contains '\0' characters

   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = m_strLogFile.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strLogFileExt,
   ofn.hwndOwner = m_hWnd;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT|
               OFN_NOREADONLYRETURN,
   ofn.lpstrTitle = strTitle;

   //
   // Default to the currently picked log file
   //

   if (GetOpenFileName(&ofn)) {
      m_strLogFile.ReleaseBuffer();
      UpdateData(FALSE);
   } else {
      m_strLogFile.ReleaseBuffer();
   }

}

//+--------------------------------------------------------------------------
//
//  Method:     DoIt
//
//  Synopsis:   Actually Analyzes the system (separated from OnOK so it can
//              be overridden to Configure the system, etc. while still using
//              the same OnOK shell code
//
//---------------------------------------------------------------------------
DWORD CPerformAnalysis::DoIt() {
   //
   // Store the log file we're using for next time
   //
   LPTSTR szLogFile = m_strLogFile.GetBuffer(0);
   m_pComponentData->GetWorkingDir(GWD_ANALYSIS_LOG,&szLogFile,TRUE,TRUE);
   m_strLogFile.ReleaseBuffer();
   //
   // InspectSystem will handle multi-threading and progress UI so
   // SCE doesn't get wierd on the user
   //
   return InspectSystem(
              NULL, // Always use the configuration assigned to the DB
              m_strDataBase.IsEmpty() ? NULL: (LPCTSTR)m_strDataBase,
              (LPCTSTR)m_strLogFile,
              AREA_ALL
              );
}

//+--------------------------------------------------------------------------
//
//  Method:     OnOK
//
//  Synopsis:   Analyzes the system
//
//---------------------------------------------------------------------------
afx_msg void CPerformAnalysis::OnOK()
{
   CWnd *cwnd;
   HANDLE hLogFile;

   UpdateData(TRUE);

   //
   // We require a log file that we can write to
   //
   if (m_strLogFile.IsEmpty()) {
      return;
   }
   else {
      m_strLogFile = ExpandEnvironmentStringWrapper(m_strLogFile);
   }

   LONG dwPosLow = 0, dwPosHigh = 0;
   hLogFile = CreateFile(m_strLogFile,  // pointer to name of the file
                        GENERIC_WRITE, // access (read-write) mode
                        0,             // share mode
                        NULL,          // pointer to security attributes
                        OPEN_ALWAYS,   // how to create
                        FILE_ATTRIBUTE_NORMAL, // file attributes
                        NULL           // handle to file with attributes to copy
                        );

   if (INVALID_HANDLE_VALUE == hLogFile) {
      CString strFormat;
      CString strError;
      CString strTitle;

      strFormat.LoadString(IDS_CANT_OPEN_LOG_FILE);
      strError.Format(strFormat,m_strLogFile);
      strTitle.LoadString(IDS_ANALYSIS_VIEWER_NAME);

      MessageBox(strError,strTitle,MB_OK);

      return;
   }

   dwPosLow = SetFilePointer(hLogFile, 0, &dwPosHigh, FILE_END );
   CloseHandle(hLogFile);


   CWaitCursor wc;

   DWORD smstatus = ERROR_SUCCESS;

   LPNOTIFY pNotify = m_pComponentData->GetNotifier();
   ASSERT(pNotify);

   //
   // Lock the analysis pane since its data is invalid while we're inspecting
   //
   if (pNotify) {
      pNotify->LockAnalysisPane(TRUE);
   }
   CFolder *pFolder = m_pComponentData->GetAnalFolder();

   //
   // Force the Analysis root node to be selected so that we display
   // the generating information message.  If we forse this repaint to happen
   // now then we don't seem to have that AV problem.
   //
   if(pFolder && pNotify){
      pNotify->SelectScopeItem(pFolder->GetScopeItem()->ID);
   }
   //
   // Make sure we don't have the database open.  That'll prevent us
   // from being able to configure.
   //
   m_pComponentData->UnloadSadInfo();


   //
   // Disable the child windows so they don't respond to input while we're
   // performing the inspection
   //
   cwnd = GetWindow(GW_CHILD);
   while(cwnd) {
      cwnd->EnableWindow(FALSE);
      cwnd = cwnd->GetNextWindow();
   }

   //Raid #358503, 4/17/2001
   HWND framehwnd = NULL; 
   LPCONSOLE pconsole = m_pComponentData->GetConsole();
   if( pconsole )
   {
       pconsole->GetMainWindow(&framehwnd);
       if( framehwnd )
       {
           ::EnableWindow(framehwnd, FALSE);
       }
   }

   smstatus = DoIt();

   //Raid #358503, 4/17/2001
   if( framehwnd )
   {
       ::EnableWindow(framehwnd, TRUE);
   }
   //
   // The inspection data is valid now, so let people back at it
   //
   if (pNotify) {
      pNotify->LockAnalysisPane(false, false);
   }
   m_pComponentData->SetErroredLogFile(m_strLogFile, dwPosLow );
   //
   // There was an error so display the log file (if any)
   //
   if (ERROR_SUCCESS != smstatus) {
      m_pComponentData->SetFlags( CComponentDataImpl::flag_showLogFile );
   }


   //
   // We're done inspecting so reenable input to the child windows
   //
   cwnd = GetWindow(GW_CHILD);
   while(cwnd) {
      cwnd->EnableWindow(TRUE);
      cwnd = cwnd->GetNextWindow();
   }

   //CDialog::OnOK();
   UpdateData();
   DestroyWindow();
}

BOOL CPerformAnalysis::OnInitDialog()
{
   CDialog::OnInitDialog();

   UpdateData(FALSE);
   if (m_strLogFile.IsEmpty()) {
      m_ctlOK.EnableWindow(FALSE);
   }

   m_strOriginalLogFile = m_strLogFile;

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CPerformAnalysis::OnChangeLogFile()
{
   UpdateData(TRUE);
   if (m_strLogFile.IsEmpty()) 
      m_ctlOK.EnableWindow(FALSE);
   else
      m_ctlOK.EnableWindow(TRUE);
   
   m_strError.Empty();
   UpdateData(FALSE);
}


void CPerformAnalysis::OnCancel() {
//   CDialog::OnCancel();

   m_strLogFile = m_strOriginalLogFile;
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\precpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precpage.h
//
//  Contents:   definition of CPrecedencePage
//
//----------------------------------------------------------------------------
#if !defined(AFX_PRECPAGE_H__CE5002B0_6D67_4DB3_98C9_17D31A493E85__INCLUDED_)
#define AFX_PRECPAGE_H__CE5002B0_6D67_4DB3_98C9_17D31A493E85__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "cookie.h"
#include "wmihooks.h"
#include "SelfDeletingPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CPrecedencePage dialog

class CPrecedencePage : public CSelfDeletingPropertyPage
{
	DECLARE_DYNCREATE(CPrecedencePage)

// Construction
public:
	CPrecedencePage();
	virtual ~CPrecedencePage();

   virtual void SetTitle(LPCTSTR sz) { m_strTitle = sz; };
   virtual void Initialize(CResult *pResult,CWMIRsop *pWMI);

// Dialog Data
	//{{AFX_DATA(CPrecedencePage)
	enum { IDD = IDD_PRECEDENCE };
	CListCtrl	m_PrecedenceList;
	CStatic	m_iconError;
	CString	m_strSuccess;
	CString	m_strTitle;
	CString	m_strError;
	//}}AFX_DATA



// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPrecedencePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DWORD_PTR m_pHelpIDs;
	void DoContextHelp(HWND hWndControl);
	// Generated message map functions
	//{{AFX_MSG(CPrecedencePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg	BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
   CResult *m_pResult;
   CWMIRsop *m_pWMI;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRECPAGE_H__CE5002B0_6D67_4DB3_98C9_17D31A493E85__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\profdesc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       profdesc.cpp
//
//  Contents:   implementation of CSetProfileDescription
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "cookie.h"
#include "snapmgr.h"
#include "profdesc.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSetProfileDescription dialog


CSetProfileDescription::CSetProfileDescription()
: CHelpDialog(a218HelpIDs, IDD, 0)
{
   //{{AFX_DATA_INIT(CSetProfileDescription)
   m_strDesc = _T("");
   //}}AFX_DATA_INIT
}


void CSetProfileDescription::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSetProfileDescription)
   DDX_Text(pDX, IDC_DESCRIPTION, m_strDesc);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetProfileDescription, CHelpDialog)
    //{{AFX_MSG_MAP(CSetProfileDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSetProfileDescription message handlers

void CSetProfileDescription::OnOK()
{
   UpdateData(TRUE);

   //
   // empty the description section first.
   //

   CEditTemplate *pet;
   LPCTSTR szInfFile;
   szInfFile = m_pFolder->GetInfFile();
   if (szInfFile) {
      pet = m_pCDI->GetTemplate(szInfFile);
      pet->SetDescription(m_strDesc);
   }
   m_pFolder->SetDesc(m_strDesc);
   DestroyWindow();
}

void CSetProfileDescription::OnCancel()
{
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\regdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regdlg.cpp
//
//  Contents:   implementation of CRegistryDialog
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "util.h"
#include "servperm.h"
#include "addobj.h"
#include "RegDlg.h"

#include <accctrl.h>
#include <aclapi.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegistryDialog dialog


CRegistryDialog::CRegistryDialog()
: CHelpDialog(a177HelpIDs, IDD, 0)
{
    //{{AFX_DATA_INIT(CRegistryDialog)
    m_strReg = _T("");
    //}}AFX_DATA_INIT

   m_pConsole = NULL;
   m_pTemplate = NULL;
   m_dbHandle = NULL;
   m_cookie = 0;
   m_pIl = NULL;
   m_pDataObj = NULL;
   m_bNoUpdate = FALSE;
}

void CRegistryDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRegistryDialog)
    DDX_Control(pDX, IDC_REGTREE, m_tcReg);
    DDX_Text(pDX, IDC_REGKEY, m_strReg);
    //}}AFX_DATA_MAP
}

/*-------------------------------------------------------------------------------------------
    Method:     CreateKeyInfo

    Synopsis:   Create a new TI_KEYINFO structure and optionaly set its members

    Arguments:  [hKey]      - Optional value to set the hKey member of TI_KEYINFO
                                default is zero
                [Enum]      - Optional value to set the Enum member of TI_KEYINFO
                                default is zero
    Returns:    a LPTI_KEYINFO pointer
---------------------------------------------------------------------------------------------*/
LPTI_KEYINFO CRegistryDialog::CreateKeyInfo(HKEY hKey, bool Enum)
{

    LPTI_KEYINFO pInfo = NULL;
    pInfo = new TI_KEYINFO;

    if(pInfo){
        pInfo->hKey = hKey;
        pInfo->Enum = Enum;
    }
    return pInfo;
}

/*-------------------------------------------------------------------------------------------
    Method:     IsValidRegPath

    Synopsis:   Returns true if strReg path.  We can't assume that this
                HKEY exists in the current registry.  We will only make
                sure that the root node exists and each string in
                between '\'s isn't blank.

    Arguments:  [strReg]    - A string represending a registry path
                                subkeys are seperated by '\'s

    Returns:    TRUE if strReg is a valid path.
---------------------------------------------------------------------------------------------*/
BOOL CRegistryDialog::IsValidRegPath(LPCTSTR strReg)
{
    ASSERT(this);
    ASSERT(m_tcReg);

    if(!strReg) return FALSE;

    int iStr = 0;           // Current position in strReg
    CString strCheck;       // String to check
    LPTI_KEYINFO pkInfo;    // Tree item key info.

    //
    // Find which root node this registry value is in.
    //

    while(strReg[iStr] && strReg[iStr] != _T('\\')) iStr++;
    strCheck = strReg;
    strCheck = strCheck.Left(iStr);
    strCheck.MakeUpper();

    // Get the HKEY value from the tree ctrl
    HTREEITEM hTi = m_tcReg.GetRootItem();
    while(hTi){
        if(m_tcReg.GetItemText(hTi) == strCheck)
            break;

        hTi = m_tcReg.GetNextItem(hTi, TVGN_NEXT);
    }
    if(hTi == NULL) return FALSE;

    // Get TI_KEYINFO for this root node
    pkInfo = (LPTI_KEYINFO)m_tcReg.GetItemData(hTi);

    // This value should never be NULL.
    if(!pkInfo){
        TRACE(TEXT("Tree item TI_KEYINFO is NULL for root node '%s'"), (LPCTSTR)strCheck);
        return FALSE;
    }

    //
    // Check the rest of the string to make sure that string's
    //  in between '\'s aren't blank
    //
    while(strReg[iStr]){

        // Check to make sure that the string item before
        //  and after the '\' aren't spaces.
        if(strReg[iStr] == _T('\\')){
            if( strReg[iStr + 1] == _T(' ') ||
                strReg[iStr + 1] == _T('\t') ||
                //strReg[iStr + 1] == 0 ||

                iStr > 0 &&
                (
                  strReg[iStr - 1] == _T(' ') ||
                  strReg[iStr - 1] == _T('\t')
                )
               )
                return FALSE;
        }
        iStr++;
    }

    return TRUE;
}


/*-------------------------------------------------------------------------------------------
    Method:     MakePathVisible

    Synopsis:
    Arguments:  [strReg]    - A string represending a registry path
                                subkeys are seperated by '\'s

    Returns:    TRUE if strReg is a valid path.
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::MakePathVisible(LPCTSTR strReg)
{
    ASSERT(this);
    ASSERT(m_tcReg);

    if(!strReg) return;

    int iStr = 0;           // Current position in strReg
    CString strCheck;       // String to check
    LPTI_KEYINFO pkInfo;    // Tree item key info.

    //
    // Find which root node this registry value is in.
    //

    while(strReg[iStr] && strReg[iStr] != _T('\\')) iStr++;
    strCheck = strReg;
    strCheck = strCheck.Left(iStr);
    strCheck.MakeUpper();

    // Get the HKEY value from the tree ctrl
    HTREEITEM hTi = m_tcReg.GetRootItem();
    while(hTi){
        if(m_tcReg.GetItemText(hTi) == strCheck)
            break;

        hTi = m_tcReg.GetNextItem(hTi, TVGN_NEXT);
    }
    if(hTi == NULL) return;

    // Get TI_KEYINFO for this root node
    pkInfo = (LPTI_KEYINFO)m_tcReg.GetItemData(hTi);

    // This value should never be NULL.
    if(!pkInfo){
        TRACE(TEXT("Tree item TI_KEYINFO is NULL for root node '%s'"), (LPCTSTR)strCheck);
        return;
    }

    //
    // Step through each sub item to see if it exists in the tree control
    //
    int iBegin = iStr + 1;
    int iNotFound = -1;

    while(strReg[iStr] && hTi){
        iStr++;
        if(strReg[iStr] == _T('\\') || strReg[iStr] == 0){
            CString strItem;
            //
            // Make sure we have tree items we can use.
            //
            EnumerateChildren(hTi);

            if(strReg[iStr] == 0 && strReg[iStr - 1] == _T('\\'))
                m_tcReg.Expand(hTi, TVE_EXPAND);

            //
            // Parse out the subkeys name.
            strCheck = strReg;
            strCheck = strCheck.Mid(iBegin, iStr - iBegin);

            strCheck.MakeUpper();
            iBegin = iStr + 1;

            //
            // Find child item with this name.
            //

            hTi = m_tcReg.GetNextItem(hTi, TVGN_CHILD);
            while(hTi){
                strItem = m_tcReg.GetItemText(hTi);
                strItem.MakeUpper();

                iNotFound = lstrcmpiW(strItem, strCheck);
                if(iNotFound >= 0)
                    break;

                hTi = m_tcReg.GetNextItem(hTi, TVGN_NEXT);
            }
            if(strReg[iStr] != 0 && iNotFound != 0){
                hTi = NULL;
                break;
            }
        }
    }

    //
    // Select and ensure visibility if the path was found
    //
    if(hTi){
        if(strReg[iStr - 1] != _T('\\'))
            m_tcReg.Expand(hTi, TVE_COLLAPSE);
        if(!iNotFound){
            m_tcReg.SelectItem(hTi);
        }

        m_tcReg.EnsureVisible(hTi);
    }

}

/*-------------------------------------------------------------------------------------------
    Method:     EnumerateChildren

    Synopsis:   Enumerates a HKEY subkey and places them as children of 'hParent'

    Arguments:  [hParent]   - HTREEITEM to enumerate.

    Returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::EnumerateChildren(HTREEITEM hParent)
{
    ASSERT(this);
    ASSERT(m_tcReg);

    //
    // We won't enumerate for the root.
    //
    if(!hParent || hParent == TVI_ROOT) return;

    LPTI_KEYINFO hkeyParent;    // Used if the item being expanded has an invalid HKEY value
    LPTI_KEYINFO hkeyThis;      // HKEY value of item expanding
    int n = 0;                  // Counter
    LPTSTR szName;              // Used to acquire the name of a HKEY item
    DWORD cchName;              // Buffer size of szName
    HTREEITEM hti;
    TV_INSERTSTRUCT tvii;
    TV_ITEM tviNew;             // Expanding tree item
    TV_ITEM tvi;                // Used to add children to the expanding HTREEITEM


    // pNMTreeView->itemNew is the TV_ITEM we're expanding.
    hkeyThis = (LPTI_KEYINFO)m_tcReg.GetItemData(hParent);

    // Exit if we have an invalid pointer.
    if(!hkeyThis) return;

    //
    //  Allocate buffer for HKEY name
    //
    szName = new TCHAR [200];
    if(!szName) return;
    cchName = 200;

    //
    // Get item text
    //
    ZeroMemory(&tviNew,sizeof(tviNew));
    tviNew.hItem = hParent;
    tviNew.mask = TVIF_TEXT;
    tviNew.pszText = szName;
    tviNew.cchTextMax = cchName;
    m_tcReg.GetItem(&tviNew);

    //
    // Do we have an invalid HKEY value?
    //
    if (!hkeyThis->hKey) {

        // Get HKEY value of parent
        hti = m_tcReg.GetParentItem(hParent);
        ZeroMemory(&tvi,sizeof(tvi));
        tvi.hItem = hti;
        tvi.mask = TVIF_PARAM;
        m_tcReg.GetItem(&tvi);
        hkeyParent = (LPTI_KEYINFO)tvi.lParam;

        if(!hkeyParent){
            TRACE(TEXT("Parent of %s has an does not have a valid TI_KEYINFO struct"), (LPCTSTR)tviNew.pszText);
            delete [] szName;
            return;
        }

        //
        // If we can't open this key then set the parent item
        //  to have no children.
        //
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyParent->hKey,tviNew.pszText,0,KEY_ALL_ACCESS,&(hkeyThis->hKey))) {
            tvi.mask = TVIF_CHILDREN;
            tvi.cChildren = 0;
            m_tcReg.SetItem(&tvi);

            delete [] szName;
            return;
        }
        //
        // Set the HKEY value for the item
        //
        tvi.hItem = hParent;
        tvi.lParam = (LPARAM) hkeyThis;
        m_tcReg.SetItem(&tvi);
    }

    //
    // Don't do anything if this item has already been enumerated or
    //  does not have a valid TI_KEYINFO structure
    //
    if( !hkeyThis->Enum ){
        hkeyThis->Enum = true;

        DWORD cSubKeys;             // Used when quering for number of children.
        HKEY hKey;                  // Used To querry sub keys.

        //
        // Prepare the TV_INSERTSTRUCT
        //
        ZeroMemory(&tvii, sizeof(TV_INSERTSTRUCT));
        tvii.hParent = hParent;
        tvii.hInsertAfter = TVI_LAST;
        tvii.item.mask = TVIF_CHILDREN | TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvii.item.cChildren = 0;
        tvii.item.iImage = CONFIG_REG_IDX;
        tvii.item.iSelectedImage = CONFIG_REG_IDX;

        //
        // Add subkeys
        //
        while(ERROR_SUCCESS == RegEnumKeyEx(hkeyThis->hKey,n++, szName,&cchName,NULL,NULL,0,NULL)) {

            // Open the key so we can query it for the count of children
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyThis->hKey, szName, 0, KEY_ALL_ACCESS, &(hKey))) {
                if(ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
                    tvii.item.cChildren = cSubKeys;
                RegCloseKey(hKey);
            }
            else
                tvii.item.cChildren = 0;

            tvii.item.cchTextMax = cchName;
            tvii.item.pszText = szName;
            tvii.item.lParam = (LPARAM)CreateKeyInfo(0, false);

            m_tcReg.InsertItem(&tvii);
            cchName = 200;
        }

        //
        // Sort children
        //
        m_tcReg.SortChildren(hParent);
    }

    delete [] szName;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetProfileInfo

    Synopsis:   Sets either m_pTemplate;

    Arguments:  [pspi]      - the PEDITTEMPLATE to save the results in
                [ft]        - Type of pointer 'pspi' is (unused)
    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetProfileInfo(PEDITTEMPLATE pspi, FOLDER_TYPES ft)
{
   m_pTemplate = (PEDITTEMPLATE)pspi;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetConsole

    Synopsis:   Sets class variable 'm_pConsole'

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetConsole(LPCONSOLE pConsole)
{
   m_pConsole = pConsole;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetComponentData

    Synopsis:   Sets class varaible 'm_pComponentData'

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetComponentData(CComponentDataImpl *pComponentData)
{
   m_pComponentData = pComponentData;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetCookie

    Synopsis:   Sets class variable 'm_cookie'

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetCookie(MMC_COOKIE cookie)
{
   m_cookie = cookie;
}


BEGIN_MESSAGE_MAP(CRegistryDialog, CHelpDialog)
    //{{AFX_MSG_MAP(CRegistryDialog)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_REGTREE, OnItemexpandingRegtree)
    ON_NOTIFY(TVN_DELETEITEM, IDC_REGTREE, OnDeleteitemRegtree)
    ON_NOTIFY(TVN_SELCHANGED, IDC_REGTREE, OnSelchangedRegtree)
    ON_EN_CHANGE(IDC_REGKEY, OnChangeRegkey)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegistryDialog message handlers

/*-------------------------------------------------------------------------------------------
    Method:     OnOK

    Synopsis:   Message handler for the IDOK button,

    **BUG**     Creating the new configuration item should happen outside of
                the dialog.

    Returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnOK()
{
   UpdateData(TRUE);


   if (!m_strReg.IsEmpty()) {

      int nCont=0;
      CFolder *pFolder = (CFolder *)m_cookie;

      if ( m_cookie && AREA_REGISTRY_ANALYSIS == pFolder->GetType() ) {
         //
         // add a key to analysis area
         //
         if ( m_dbHandle ) {
            nCont = 1;
         }

      } else if ( m_pTemplate && m_pTemplate->pTemplate ) {

         nCont = 2;
         //
         // if no object is in the buffer, create it with count = 0
         // this buffer will be freed when the template is freed
         //
         if ( !m_pTemplate->pTemplate->pRegistryKeys.pAllNodes ) {

            PSCE_OBJECT_ARRAY pTemp = (PSCE_OBJECT_ARRAY)LocalAlloc(0, sizeof(SCE_OBJECT_ARRAY));
            if ( pTemp ) {
               pTemp->Count = 0;
               pTemp->pObjectArray = NULL;
               m_pTemplate->pTemplate->pRegistryKeys.pAllNodes = pTemp;
            } else
               nCont = 0;
         }
      }

      HRESULT hr=E_FAIL;

      if ( nCont ) {
         PSECURITY_DESCRIPTOR pSelSD=NULL;
         SECURITY_INFORMATION SelSeInfo = 0;
         BYTE ConfigStatus = 0;

         if (m_pComponentData) {
            if ( m_pComponentData->GetAddObjectSecurity(
                                                       GetSafeHwnd(),
                                                       m_strReg,
                                                       TRUE,
                                                       SE_REGISTRY_KEY,
                                                       pSelSD,
                                                       SelSeInfo,
                                                       ConfigStatus
                                                       ) == E_FAIL ) {
               return;
            }
         } else {
            return;
         }

         hr = S_OK;

         if ( pSelSD && SelSeInfo ) {

            if ( 1 == nCont ) {
               //
               // add to the engine directly
               //
               SCESTATUS sceStatus=SCESTATUS_SUCCESS;
               BYTE AnalStatus;

               //
               // start the transaction if it's not started
               //
               if ( m_pComponentData->EngineTransactionStarted() ) {

                  sceStatus =  SceUpdateObjectInfo(
                                                  m_dbHandle,
                                                  AREA_REGISTRY_SECURITY,
                                                  (LPTSTR)(LPCTSTR)m_strReg,
                                                  m_strReg.GetLength(), // number of characters
                                                  ConfigStatus,
                                                  TRUE,
                                                  pSelSD,
                                                  SelSeInfo,
                                                  &AnalStatus
                                                  );
                  if ( SCESTATUS_SUCCESS == sceStatus ) {

                     hr = m_pComponentData->UpdateScopeResultObject(m_pDataObj,
                                                                    m_cookie,
                                                                    AREA_REGISTRY_SECURITY);

                     m_pTemplate->SetDirty(AREA_REGISTRY_SECURITY);

                  }
               } else {
                  //
                  // can't start transaction
                  //
                  hr = E_FAIL;
               }

            } else {
               //
               // add to configuration template
               //

               PSCE_OBJECT_ARRAY poa;
               unsigned int i;

               poa = m_pTemplate->pTemplate->pRegistryKeys.pAllNodes;

               // Make sure this key isn't already in the list:
               for (i=0;i < poa->Count;i++) {
                  if (lstrcmpi(poa->pObjectArray[i]->Name,m_strReg) == 0) {
                     LocalFree(pSelSD);
                     return;
                  }
               }

               PSCE_OBJECT_SECURITY *pCopy;

               // For some reason the LocalReAlloc version of this keeps giving out of memory
               // errors, but allocing & copying everything works fine.
               pCopy = (PSCE_OBJECT_SECURITY *)LocalAlloc(LPTR,(poa->Count+1)*sizeof(PSCE_OBJECT_SECURITY));
               if (pCopy) {

                  for (i=0; i<poa->Count; i++) {
                     pCopy[i] = poa->pObjectArray[i];
                  }

                  pCopy[poa->Count] = (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
                  if ( pCopy[poa->Count] ) {
                     pCopy[poa->Count]->Name = (PWSTR) LocalAlloc(LPTR,(m_strReg.GetLength()+1)*sizeof(TCHAR));

                     if ( pCopy[poa->Count]->Name ) {

                        lstrcpy(pCopy[poa->Count]->Name,m_strReg);
                        pCopy[poa->Count]->pSecurityDescriptor = pSelSD;
                        pCopy[poa->Count]->SeInfo = SelSeInfo;
                        pCopy[poa->Count]->Status = ConfigStatus;
                        pCopy[poa->Count]->IsContainer = TRUE;

                        pSelSD = NULL;

                        poa->Count++;

                        if ( poa->pObjectArray ) {
                           LocalFree(poa->pObjectArray);
                        }
                        poa->pObjectArray = pCopy;

                        m_pTemplate->SetDirty(AREA_REGISTRY_SECURITY);

                        ((CFolder *)m_cookie)->RemoveAllResultItems();
                        m_pConsole->UpdateAllViews(NULL ,m_cookie, UAV_RESULTITEM_UPDATEALL);

                        hr = S_OK;

                     } else {
                        LocalFree(pCopy[poa->Count]);
                        LocalFree(pCopy);
                     }
                  } else
                     LocalFree(pCopy);
               }
            }
            if ( pSelSD ) {
               LocalFree(pSelSD);
            }
         }
      }

      if ( FAILED(hr) ) {
         CString str;
         str.LoadString(IDS_CANT_ADD_KEY);
         AfxMessageBox(str);
      }
   }

   CDialog::OnOK();
}

/*-------------------------------------------------------------------------------------------
    Method:     OnInitDialog

    Synopsis:   Create root HKEY entries HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT,
                and HKEY_USERS in the tree control.

    Returns:    return TRUE
---------------------------------------------------------------------------------------------*/
BOOL CRegistryDialog::OnInitDialog()
{
    CString strRegKeyName;          // Used to load string resources
                                    //  for name of the HTREEITEM
    HTREEITEM hti;
    TV_INSERTSTRUCT tvi;

    CDialog::OnInitDialog();

    //
    // Create image list for tree control
    //
    CThemeContextActivator activator; //Bug 424909, Yanggao, 6/29/2001
    m_pIl.Create(IDB_ICON16,16,1,RGB(255,0,255));
    m_tcReg.SetImageList (CImageList::FromHandle (m_pIl), TVSIL_NORMAL);

    //
    // Add Root HKEY items.
    //
    ZeroMemory(&tvi,sizeof(tvi));
    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_CHILDREN | TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvi.item.cChildren = 1;         // Initial UI +
    tvi.item.iImage = CONFIG_REG_IDX;
    tvi.item.iSelectedImage = CONFIG_REG_IDX;

    // Insert HKEY_CLASSES_ROOT
    strRegKeyName.LoadString(IDS_HKCR);
    tvi.item.cchTextMax = strRegKeyName.GetLength()+1;
    tvi.item.pszText = strRegKeyName.LockBuffer();
    tvi.item.lParam = (LPARAM)CreateKeyInfo(HKEY_CLASSES_ROOT, false);
    hti = m_tcReg.InsertItem(&tvi);
    strRegKeyName.UnlockBuffer();

    // Insert HKEY_LOCAL_MACHINE
    strRegKeyName.LoadString(IDS_HKLM);
    tvi.item.cchTextMax = strRegKeyName.GetLength()+1;
    tvi.item.pszText = strRegKeyName.LockBuffer();
    tvi.item.lParam = (LPARAM)CreateKeyInfo(HKEY_LOCAL_MACHINE, false);
    hti = m_tcReg.InsertItem(&tvi);
    strRegKeyName.UnlockBuffer();

    // Insert HKEY_USERS
    strRegKeyName.LoadString(IDS_HKU);
    tvi.item.cchTextMax = strRegKeyName.GetLength()+1;
    tvi.item.pszText = strRegKeyName.LockBuffer();
    tvi.item.lParam = (LPARAM)CreateKeyInfo(HKEY_USERS, false);
    hti = m_tcReg.InsertItem(&tvi);
    strRegKeyName.UnlockBuffer();

    // Sort the tree control
    m_tcReg.SortChildren(NULL);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/*-------------------------------------------------------------------------------------------
    Method:     OnItemexpandingRegtree

    Synopsis:   MFC OnNotify TVN_ITEMEXPANDING message handler. The lParam member of
                the HTREEITEM is a pointer to a TI_KEYINFO structure.  When
                a tree item is expanded for the first time, we must enumerate all
                its children. The function will set the TI_KEYINFO.Enum = true after
                enumeration.

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnItemexpandingRegtree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    *pResult = 0;
    EnumerateChildren(pNMTreeView->itemNew.hItem);
}

/*-------------------------------------------------------------------------------------------
    Method:     OnDeleteitemRegtree

    Synopsis:   MFC OnNotify TVN_DELETEITEM message handler.  Delete the TI_KEYINFO
                structure associated with 'itemOld' and close
                the regestry key.

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnDeleteitemRegtree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    LPTI_KEYINFO pInfo = (LPTI_KEYINFO)pNMTreeView->itemOld.lParam;
    if(pInfo){

        // Close registry key
        if(pInfo->hKey && (INT_PTR)(pInfo->hKey) != -1)
            RegCloseKey(pInfo->hKey);

        // delete the TI_KEYINFO
        delete pInfo;
    }
    *pResult = 0;
}

/*-------------------------------------------------------------------------------------------
    Method:     ~CRegistryDialog

    Synopsis:   Release memory used by this class

    returns:    void
---------------------------------------------------------------------------------------------*/
CRegistryDialog::~CRegistryDialog()
{
   m_pIl.Destroy(); //Bug 424909, Yanggao, 6/29/2001
}

/*-------------------------------------------------------------------------------------------
    Method:     OnSelchangedRegtree

    Synopsis:   MFC OnNotify TVN_SELCHANGED message handler.  Updates 'm_strReg' to
                the full path of the HKEY item

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnSelchangedRegtree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    *pResult = 0;

    //
    // Sometime we don't want to be updated.
    //
    if(m_bNoUpdate) return;

    TV_ITEM tvi;        // Used to get information about tree items

    CString strSel;     // Used to build the path to the selected item
    LPTSTR szBuf;       // Name of tree item
    DWORD cchBuf;       // size of szBuf

    cchBuf = 500;
    szBuf = new TCHAR [ cchBuf ];
    if(!szBuf) return;

    // Get the selected items text
    tvi.hItem = pNMTreeView->itemNew.hItem;
    tvi.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.pszText = szBuf;
    tvi.cchTextMax = cchBuf;
    m_tcReg.GetItem(&tvi);

    strSel = tvi.pszText;

    // Retrieve text of all parent items.
    while(tvi.hItem = m_tcReg.GetParentItem(tvi.hItem)) {
        m_tcReg.GetItem(&tvi);
        strSel = L"\\" + strSel;
        strSel = tvi.pszText + strSel;
    }

    m_strReg = strSel;
    UpdateData(FALSE);
    delete[] szBuf;

    // Enable the OK button
    if(GetDlgItem(IDOK)) GetDlgItem(IDOK)->EnableWindow(TRUE);
}

/*-------------------------------------------------------------------------------------------
    Method:     OnChangeRegkey

    Synopsis:   IDC_REGKEY edit control EN_CHANGE handler.

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnChangeRegkey()
{
    UpdateData(TRUE);

    if(IsValidRegPath(m_strReg) && GetDlgItem(IDOK)) {
        GetDlgItem(IDOK)->EnableWindow(TRUE);

        m_bNoUpdate = TRUE;
        MakePathVisible(m_strReg);
        m_bNoUpdate = FALSE;
    }
    else {
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\profdesc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       profdesc.h
//
//  Contents:   definition of CSetProfileDescription
//
//----------------------------------------------------------------------------
#if !defined(AFX_SETProfileDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
#define AFX_SETProfileDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSetProfileDescription dialog

class CSetProfileDescription : public CHelpDialog
{
// Construction
public:
    CSetProfileDescription();   // standard constructor

// Dialog Data
    //{{AFX_DATA(CSetProfileDescription)
    enum { IDD = IDD_SET_DESCRIPTION };
    CString  m_strDesc;
    //}}AFX_DATA

    void Initialize(CFolder *pFolder,CComponentDataImpl *pCDI) {
        m_pFolder = pFolder; m_pCDI = pCDI;
    }
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSetProfileDescription)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSetProfileDescription)
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CFolder *m_pFolder;
    CComponentDataImpl *m_pCDI;
};

//{{AFX_INSERT_Profile}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SETProfileDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\regdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regdlg.h
//
//  Contents:   definition of CRegistryDialog
//
//----------------------------------------------------------------------------
#if !defined(AFX_REGISTRYDIALOG_H__C84DDDBB_D7CA_11D0_9C69_00C04FB6C6FA__INCLUDED_)
#define AFX_REGISTRYDIALOG_H__C84DDDBB_D7CA_11D0_9C69_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "snapmgr.h"
#include "HelpDlg.h"

// This structure is used by CResistryDialog to save the HKEY value
// and enumeration state of a HTREEITEM
typedef struct _tag_TI_KEYINFO
{
   HKEY hKey;  // HKEY value of this tree item
   bool Enum;  // true if the item has already been enumerated
} TI_KEYINFO, *LPTI_KEYINFO;


/////////////////////////////////////////////////////////////////////////////
// CRegistryDialog dialog
// Used to select a registry item.  If the dialog returns IDOK
// 'm_strReg' will contain the full path of the registry item.
/////////////////////////////////////////////////////////////////////////////
class CRegistryDialog : public CHelpDialog
{
// Construction
public:
    void SetCookie(MMC_COOKIE cookie);
    void SetConsole(LPCONSOLE pConsole);
    void SetComponentData(CComponentDataImpl *pComponentData);
    void SetDataObj(LPDATAOBJECT pDataObj) { m_pDataObj = pDataObj; }
    void SetProfileInfo(PEDITTEMPLATE pspi, FOLDER_TYPES ft);
    void SetHandle(PVOID hDB) { m_dbHandle = hDB; };

   virtual ~CRegistryDialog();
    CRegistryDialog();   // standard constructor

      // Create a new TI_KEYINFO structure
   static LPTI_KEYINFO CreateKeyInfo(HKEY hKey = 0, bool Enum = 0);

      // Checks to see if strReg is a valid registry key
   BOOL IsValidRegPath(LPCTSTR strReg);

        // Add subkeys to a tree item as children.
    void EnumerateChildren(HTREEITEM hParent);

        // Makes the last item in the path visible.
    void MakePathVisible(LPCTSTR strReg);

// Dialog Data
    //{{AFX_DATA(CRegistryDialog)
    enum { IDD = IDD_REGISTRY_DIALOG };
    CTreeCtrl   m_tcReg;
    CString m_strReg;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRegistryDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CRegistryDialog)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnItemexpandingRegtree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDeleteitemRegtree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangedRegtree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeRegkey();
   //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Public data members
public:
    PEDITTEMPLATE m_pTemplate;
    PVOID m_dbHandle;

private:
    MMC_COOKIE m_cookie;
    CComponentDataImpl * m_pComponentData;
    LPCONSOLE m_pConsole;
    WTL::CImageList m_pIl;                   // The image list used
                                    // by the tree ctrl.
    LPDATAOBJECT m_pDataObj;
    BOOL m_bNoUpdate;                           // When we don't want the edit
                                                //  control to be updated because
                                                //  of a selection
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGISTRYDIALOG_H__C84DDDBB_D7CA_11D0_9C69_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\regvldlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regvldlg.cpp
//
//  Contents:   implementation of CSceRegistryValueInfo, CConfigRegEnable,
//              CAttrRegEnable, CLocalPolRegEnable, CConfigRegNumber, 
//              CAttrRegNumber, CLocalPolRegNumber, CConfigRegString, 
//              CAttrRegString, CLocalPolRegString, CConfigRegChoice
//              CAttrRegChoice, CLocalPolRegChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "regvldlg.h"
#include "util.h"
#include "snapmgr.h"
#include "defaults.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



extern PCWSTR g_pcszNEWLINE;

/*-----------------------------------------------------------------------------------------
Method:     CRegistryValueInfo::CRegistryValueInfo

Synopsis:   Constructor for CRegistryValueInfo, sets m_pRegInfo.

Arguments:  [pInfo]     - A pointer toa SCE_REGISTRY_VALUE_INFO struct.

-----------------------------------------------------------------------------------------*/
CSceRegistryValueInfo::CSceRegistryValueInfo(
   PSCE_REGISTRY_VALUE_INFO pInfo)
{
   m_pRegInfo = pInfo;
}

/*-----------------------------------------------------------------------------------------
Method:     CRegistryValueInfo::GetBoolValue

Synopsis:   Returns a boolean TRUE or false depending on the data and data type of this
         object

Returns: TRUE if the data is equal to a TRUE value, FALSE otherwise.
-----------------------------------------------------------------------------------------*/
DWORD CSceRegistryValueInfo::GetBoolValue()
{
   if (GetValue() == NULL)
      return SCE_NO_VALUE;
   

   return GetValue()[0] == L'1';
}


/*-----------------------------------------------------------------------------------------
Method:     CRegistryValueInfo::SetValueBool

Synopsis:   Sets the value to the types equivalent boolean value, SCE_NO_VALUE if
         [dwVal] is equal to SCE_NO_VALUE.

Arguments:  [bVal]      - TRUE or FALSE.

Returns: ERROR_SUCCESS     - Successfull
         E_OUTOFMEMORY     - Out of memory.
-----------------------------------------------------------------------------------------*/
DWORD
CSceRegistryValueInfo::SetBoolValue(
   DWORD dwVal)
{

   if(dwVal == SCE_NO_VALUE)
   {
      if(m_pRegInfo->Value)
	  {
         LocalFree( m_pRegInfo->Value );
      }
      m_pRegInfo->Value = NULL;
      return ERROR_SUCCESS;
   }

   //
   // Set the length of the string.
   //
   int nLen = 2;

   if ( m_pRegInfo->Value == NULL ) 
   {
       // allocate buffer
       m_pRegInfo->Value = (PWSTR)LocalAlloc(0, nLen*sizeof(WCHAR));
       if(m_pRegInfo->Value == NULL)
          return (DWORD)E_OUTOFMEMORY;
   }

   if ( m_pRegInfo->Value ) 
   {
      //
      // Convert and set the data.
      //
      m_pRegInfo->Value[0] = (int)dwVal + L'0';
      m_pRegInfo->Value[nLen-1] = L'\0';
   }
   return ERROR_SUCCESS;
}




/////////////////////////////////////////////////////////////////////////////
// CConfigRegEnable message handlers
void CConfigRegEnable::Initialize(CResult *pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   CSceRegistryValueInfo prv( (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase() );

   DWORD dw = prv.GetBoolValue();

   if ( dw != SCE_NO_VALUE ) 
   {
      m_bConfigure = TRUE;
      SetInitialValue(dw);

   }
   else
      m_bConfigure = FALSE;
}

BOOL CConfigRegEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      UpdateData(TRUE);
      DWORD dw = 0;

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_nEnabledRadio) 
	     {
         // ENABLED
         case 0:
            dw = 1;
            break;
         // DISABLED
         case 1:
            dw = 0;
            break;
		    
         // Not really configured
         default:
            dw = -1;
            break;
         }
      }

      CSceRegistryValueInfo prv( (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase()) );
      DWORD prvdw = prv.GetBoolValue();  //Bug211219, Yanggao, 3/15/2001

      prv.SetBoolValue(dw);

      if(!UpdateProfile())
         prv.SetBoolValue(prvdw);
   }
   // Class hieirarchy is bad - call CAttribute base method directly

   return CAttribute::OnApply();
}


BOOL CConfigRegEnable::UpdateProfile()
{
   if ( m_pData->GetBaseProfile() ) //Bug211219, Yanggao, 3/15/2001
   {
      if( !(m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY)) )
      {
          m_pData->Update(m_pSnapin);
          return FALSE;
      }
      else
      {
          m_pData->Update(m_pSnapin);
          return TRUE;
      }
   }
   
   m_pData->Update(m_pSnapin);
   return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAttrRegEnable message handlers

void CAttrRegEnable::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);
   CSceRegistryValueInfo prv(NULL);

   //
   // Edit template settings.
   //
   prv.Attach( (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase() );

   DWORD dw = prv.GetBoolValue();
   if(dw != SCE_NO_VALUE)
   {
      m_bConfigure = TRUE;
      m_EnabledRadio = !dw;
   }
   else
      m_bConfigure = FALSE;

   pResult->GetDisplayName( NULL, m_Current, 2 );
}

BOOL CAttrRegEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      UpdateData(TRUE);
      DWORD dw = 0;

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_EnabledRadio) 
	     {
            // ENABLED
            case 0:
               dw = 1;
               break;
            // DISABLED
            case 1:
               dw = 0;
               break;
            // Not really configured
            default:
               dw = -1;
               break;
         }
      }

      CSceRegistryValueInfo prv( (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase()) );

      prv.SetBoolValue(dw);
      //
      // this address should never be NULL
      //
      int status = CEditTemplate::ComputeStatus(
                                    (PSCE_REGISTRY_VALUE_INFO)m_pData->GetBase(),
                                    (PSCE_REGISTRY_VALUE_INFO)m_pData->GetSetting()
                                    );
      UpdateProfile( status );
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();

}

void CAttrRegEnable::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() ) 
      m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegEnable message handlers
BOOL CLocalPolRegEnable::UpdateProfile( )
{
   return m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegEnable::Initialize(CResult * pResult)
{
   CConfigRegEnable::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_nEnabledRadio = -1;
      m_fNotDefine = FALSE; //Raid #413225, 6/11/2001, Yanggao
   }
}


////////////////////////////////////////////////////////////
// CConfigRegNumber message handlers
//
CConfigRegNumber::CConfigRegNumber(UINT nTemplateID) : 
CConfigNumber(nTemplateID ? nTemplateID : IDD) 
{ 
};

void CConfigRegNumber::Initialize(CResult * pResult)
{
   LONG_PTR dw = 0;

   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);
   m_strUnits = pResult->GetUnits();

   m_cMinutes = 0;
   m_nLow = 0;
   m_nHigh = 999;
   m_nSave = 0;
   m_iNeverId = 0;
   m_iAccRate = 1;
   m_iStaticId = 0;

   m_strStatic = _T("");
   dw = pResult->GetBase();
   PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)dw;

   //
   // HACKHACK: since we don't have a way to specify these values
   // in the inf file to get them to the registry where we could
   // read and use them here we need to hard code the limits and
   // strings for the values we know about.
   //
   // For the next version we really need this in the inf file &
   // registry
   //

   if (0 == lstrcmpi(prv->FullValueName,RNH_AUTODISCONNECT_NAME)) 
   {
      m_nLow = RNH_AUTODISCONNECT_LOW;
      m_nHigh = RNH_AUTODISCONNECT_HIGH;
      m_cMinutes = RNH_AUTODISCONNECT_FLAGS;
      m_iNeverId = RNH_AUTODISCONNECT_SPECIAL_STRING;
      m_iStaticId = RNH_AUTODISCONNECT_STATIC_STRING;
   }
   if (0 == lstrcmpi(prv->FullValueName,RNH_CACHED_LOGONS_NAME)) 
   {
      m_nLow = RNH_CACHED_LOGONS_LOW;
      m_nHigh = RNH_CACHED_LOGONS_HIGH;
      m_cMinutes = RNH_CACHED_LOGONS_FLAGS;
      m_iNeverId = RNH_CACHED_LOGONS_SPECIAL_STRING;
      m_iStaticId = RNH_CACHED_LOGONS_STATIC_STRING;
   }
   if (0 == lstrcmpi(prv->FullValueName,RNH_PASSWORD_WARNINGS_NAME)) 
   {
      m_nLow = RNH_PASSWORD_WARNINGS_LOW;
      m_nHigh = RNH_PASSWORD_WARNINGS_HIGH;
      m_cMinutes = RNH_PASSWORD_WARNINGS_FLAGS;
      m_iNeverId = RNH_PASSWORD_WARNINGS_SPECIAL_STRING;
      m_iStaticId = RNH_PASSWORD_WARNINGS_STATIC_STRING;
   }
   //
   // End HACKHACK
   //
   dw = (DWORD)pResult->GetBase();

   if ( prv && prv->Value ) 
   {
      m_bConfigure = TRUE;
      m_nSave = _wtol(prv->Value);

      SetInitialValue(m_nSave);

   } 
   else
      m_bConfigure = FALSE;
}

BOOL CConfigRegNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      UpdateData(TRUE);
      DWORD dw = 0;
      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else
         dw = CurrentEditValue();

      PWSTR sz = NULL;
      if ( dw != SCE_NO_VALUE ) 
      {
         CString strTmp;
         // allocate buffer
         strTmp.Format(TEXT("%d"), dw);
         sz = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(WCHAR));
         if (!sz) 
	     {
            //
            // Display a message?
            //
            return FALSE;
         }
         lstrcpy(sz,strTmp);
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      //
      // this address should never be NULL
      //
      ASSERT(prv);
      if (prv) 
      {
         if ( prv->Value )
             LocalFree(prv->Value);

         prv->Value = sz;
      } 
      else if (sz)
         LocalFree(sz);

      UpdateProfile();
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CConfigRegNumber::UpdateProfile()
{
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CAttrRegNumber message handlers
CAttrRegNumber::CAttrRegNumber() : 
CAttrNumber(IDD) 
{ 
};

void CAttrRegNumber::Initialize(CResult * pResult)
{
    // Class hieirarchy is bad - call CAttribute base method directly
    CAttribute::Initialize(pResult);
    m_strUnits = pResult->GetUnits();

    m_strTemplateTitle = _T("");
    m_strLastInspectTitle = _T("");

    m_cMinutes = 0;
    m_nLow = 0;
    m_nHigh = 999;
    m_nSave = 0;
    m_iNeverId = 0;
    m_iAccRate = 1;
    m_iStaticId = 0;

    LONG_PTR dw = pResult->GetBase();
    PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)dw;

    //
    // HACKHACK: since we don't have a way to specify these values
    // in the inf file to get them to the registry where we could
    // read and use them here we need to hard code the limits and
    // strings for the values we know about.
    //
    // For the next version we really need this in the inf file &
    // registry
    //
    if (0 == lstrcmpi(prv->FullValueName,RNH_AUTODISCONNECT_NAME)) 
	{
       m_nLow = RNH_AUTODISCONNECT_LOW;
       m_nHigh = RNH_AUTODISCONNECT_HIGH;
       m_cMinutes = RNH_AUTODISCONNECT_FLAGS;
       m_iNeverId = RNH_AUTODISCONNECT_SPECIAL_STRING;
       m_iStaticId = RNH_AUTODISCONNECT_STATIC_STRING;
    }
    if (0 == lstrcmpi(prv->FullValueName,RNH_CACHED_LOGONS_NAME)) 
	{
       m_nLow = RNH_CACHED_LOGONS_LOW;
       m_nHigh = RNH_CACHED_LOGONS_HIGH;
       m_cMinutes = RNH_CACHED_LOGONS_FLAGS;
       m_iNeverId = RNH_CACHED_LOGONS_SPECIAL_STRING;
       m_iStaticId = RNH_CACHED_LOGONS_STATIC_STRING;
    }
    if (0 == lstrcmpi(prv->FullValueName,RNH_PASSWORD_WARNINGS_NAME)) 
	{
       m_nLow = RNH_PASSWORD_WARNINGS_LOW;
       m_nHigh = RNH_PASSWORD_WARNINGS_HIGH;
       m_cMinutes = RNH_PASSWORD_WARNINGS_FLAGS;
       m_iNeverId = RNH_PASSWORD_WARNINGS_SPECIAL_STRING;
       m_iStaticId = RNH_PASSWORD_WARNINGS_STATIC_STRING;
    }
    //
    // End HACKHACK
    //

    if ( prv && prv->Value ) 
	{
       m_bConfigure = TRUE;

       m_nSave = _wtol(prv->Value);
       SetInitialValue(m_nSave);
    } 
	else
       m_bConfigure = FALSE;

    pResult->GetDisplayName( NULL, m_strSetting, 2 );
}

BOOL CAttrRegNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int status = 0;

      UpdateData(TRUE);

   if (!m_bConfigure)
   {
      dw = SCE_NO_VALUE;
   }
   else
   {
      dw = CurrentEditValue();
   }

      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      PSCE_REGISTRY_VALUE_INFO prv2=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());

      //
      // this address should never be NULL
      //
      if ( prv ) 
      {
          DWORD dw2=SCE_NO_VALUE;
          if ( prv2 ) 
	      {
              //
              // if there is analysis setting (should always have)
              //
              if (prv2->Value ) 
		      {
                  dw2 = _wtol(prv2->Value);
              } 
		      else 
		      {
                  dw2 = SCE_NO_VALUE;
              }
          }


          if ( prv->Value )
              LocalFree(prv->Value);
          prv->Value = NULL;

          if ( dw != SCE_NO_VALUE ) 
	      {
              CString strTmp;

              // allocate buffer
              strTmp.Format(TEXT("%d"), dw);
              prv->Value = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

              if ( prv->Value )
                  wcscpy(prv->Value,(LPCTSTR)strTmp);
              else 
		        {
                  // can't allocate buffer, error!!
              }
          }

          status = CEditTemplate::ComputeStatus (prv, prv2);


          UpdateProfile( status );
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CAttrRegNumber::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() )
     m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegNumber message handlers
CLocalPolRegNumber::CLocalPolRegNumber() : 
CConfigRegNumber(IDD), m_bInitialValueSet(FALSE)

{
   m_pHelpIDs = (DWORD_PTR)a228HelpIDs;
   m_uTemplateResID = IDD;
}

void CLocalPolRegNumber::UpdateProfile()
{
   m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegNumber::Initialize(CResult * pResult)
{
   CConfigRegNumber::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_bInitialValueSet = TRUE;
      m_nSave = 0;
   }
}
void CLocalPolRegNumber::SetInitialValue(DWORD_PTR dw) 
{
   if (m_bConfigure && !m_bInitialValueSet) 
   {
      CConfigRegNumber::SetInitialValue(dw);
      m_bInitialValueSet = TRUE;
   }
}


/////////////////////////////////////////////////////////////////////////////
// CConfigRegString message handlers

void CConfigRegString::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) 
   {

       m_bConfigure = TRUE;

       if (QueryMultiSZ()) 
       {
          LPTSTR sz = SZToMultiSZ(prv->Value);
          m_strName = sz;
          LocalFree(sz);
          if( REG_SZ == prv->ValueType ) //Raid #376218, 4/25/2001
          {
              prv->ValueType = REG_MULTI_SZ;
          }
       } 
       else
       {
          m_strName = (LPTSTR) prv->Value;
       }
   } 
   else 
   {
       m_strName = _T("");
       m_bConfigure = FALSE;
   }
}



BOOL CConfigRegString::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      UpdateData(TRUE);

      m_strName.TrimRight();

      // 249188 SCE UI: allows adding empty lines to REG_MULTI_SZ fields
      // Replace all double newlines with single newlines.  This has the effect
      // of deleting empty lines.
      CString  szDoubleNewLine (g_pcszNEWLINE);
      szDoubleNewLine += g_pcszNEWLINE;
      while (m_strName.Replace (szDoubleNewLine, g_pcszNEWLINE) != 0);

      UpdateData (FALSE);  // put the corrected string back in the control

      PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      if ( prv ) 
      {
        if (!m_bConfigure) 
        {
            if ( prv->Value )
                LocalFree(prv->Value);
            prv->Value = NULL;
            this->UpdateProfile();
        } 
        else 
        {
           LPTSTR prvpt = NULL;
           LPTSTR pt = 0;
           if (QueryMultiSZ()) 
              pt = MultiSZToSZ(m_strName);
	        else 
           {
              pt = (PWSTR)LocalAlloc(0, (m_strName.GetLength()+1)*sizeof(TCHAR));
              if ( pt ) 
                 wcscpy(pt, (LPCTSTR)m_strName);
           }

           if ( pt ) 
           {
              if ( prv->Value ) 
                 prvpt = prv->Value;
              prv->Value = pt;
           } 
	        else 
           {
               // can't allocate buffer error!!
           }

           if( !(this->UpdateProfile()) )
           {
                if ( prv->Value ) 
                    LocalFree(prv->Value);
                prv->Value = prvpt;
           }
           else
           {
                if( prvpt)
                    LocalFree(prvpt);
           }
        }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}


BOOL CConfigRegString::UpdateProfile()
{
   if ( m_pData->GetBaseProfile() )
   {
      if( !(m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY)) )
      {
          m_pData->Update(m_pSnapin);
          return FALSE;
      }
      else
      {
          m_pData->Update(m_pSnapin);
          return TRUE;
      }
   }
   m_pData->Update(m_pSnapin);
   
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CAttrString message handlers

void CAttrRegString::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   m_strBase.Empty();
   m_strSetting.Empty();

   PSCE_REGISTRY_VALUE_INFO prv;
   prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetSetting());

   pResult->GetDisplayName( NULL, m_strSetting, 2 );

   prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());
   if ( prv && prv->Value ) 
   {
       m_bConfigure = TRUE;
       if (QueryMultiSZ()) 
	   {
          LPTSTR sz = SZToMultiSZ(prv->Value);
          m_strBase = sz;
          LocalFree(sz);
       } 
	   else 
	   {
          m_strBase = (LPTSTR) prv->Value;
       }
   } 
   else 
       m_bConfigure = FALSE;
}

BOOL CAttrRegString::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      UpdateData(TRUE);

      int status=SCE_STATUS_GOOD;

      PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      PSCE_REGISTRY_VALUE_INFO prv2 = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());

      m_strBase.TrimRight();

      if ( prv ) 
      {
           if (!m_bConfigure) 
		   {
               if ( prv->Value ) 
                   LocalFree(prv->Value);
               prv->Value = NULL;
           } 
		   else 
		   {
               LPTSTR pt = 0;
               if (QueryMultiSZ())
                  pt = MultiSZToSZ(m_strBase);
               else 
			   {
                  pt = (PWSTR)LocalAlloc(0, (m_strBase.GetLength()+1)*sizeof(TCHAR));
                  if ( pt )
                     wcscpy(pt, (LPCTSTR)m_strBase);
               }
               if ( pt ) 
			   {
                   if ( prv->Value )
                       LocalFree(prv->Value);
                   prv->Value = pt;
               } 
			   else 
			   {
                   // can't allocate buffer error!!
               }
           }

           status = CEditTemplate::ComputeStatus(prv, prv2);
           UpdateProfile( status );
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

//+----------------------------------------------------------------------------------------------
// CAttrRegString::UpdateProfile
//
// This function is called by OnApply after all the data has been retrieved from the dialog.
// Inherited classes can overload this function to update the data as needed.
//
// Arguments:  [status] - The status of [m_pData] from OnApply();
//
//----------------------------------------------------------------------------------------------
void CAttrRegString::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() )
      m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegString message handlers

//+----------------------------------------------------------------------------------------------
// CLocalPolRegString::UpdateProfile
//
// This function is called by OnApply after all the data has been retrieved from the dialog.
// Inherited classes can overload this function to update the data as needed.
//
// Arguments:  [status] - The status of [m_pData] from OnApply();
//
//----------------------------------------------------------------------------------------------
BOOL CLocalPolRegString::UpdateProfile(  )
{
   return m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegString::Initialize(CResult * pResult)
{
   CConfigRegString::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_strName = _T("");
   }
}

/////////////////////////////////////////////////////////////////////////////
// CConfigRegChoice message handlers
void CConfigRegChoice::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   m_strAttrName = pResult->GetAttrPretty();
   m_StartIds=IDS_LM_FULL;

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) 
   {
       m_bConfigure = TRUE;
       switch(_wtol(prv->Value)) 
	   {
       case SCE_RETAIN_ALWAYS:
          m_rabRetention = 0;
          break;
       case SCE_RETAIN_AS_REQUEST:
          m_rabRetention = 1;
          break;
       case SCE_RETAIN_NC:
          m_rabRetention = 2;
          break;
       }
   } 
   else 
      m_bConfigure = FALSE;
}

BOOL CConfigRegChoice::OnInitDialog()
{
   CConfigRet::OnInitDialog();

   //
   // load static text for the radio buttons
   //

    CString strText;
    strText.LoadString(m_StartIds);
    SetDlgItemText( IDC_RETENTION, strText );

    strText.LoadString(m_StartIds+1);
    SetDlgItemText( IDC_RADIO2, strText );

    strText.LoadString(m_StartIds+2);
    SetDlgItemText( IDC_RADIO3, strText );

   OnConfigure();

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigRegChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;

      UpdateData(TRUE);

      PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      if ( prv ) 
      {
          if (!m_bConfigure) 
	      {
               if ( prv->Value ) 
                   LocalFree(prv->Value);
               prv->Value = NULL;

          } 
	      else 
	      {
               switch(m_rabRetention) 
			   {
               case 0:
                  dw = SCE_RETAIN_ALWAYS;
                  break;
               case 1:
                  dw = SCE_RETAIN_AS_REQUEST;
                  break;
               case 2:
                  dw = SCE_RETAIN_NC;
                  break;
               }

               if ( prv->Value == NULL )
			   {
                   // allocate buffer
                   prv->Value = (PWSTR)LocalAlloc(0, 4);
			   }
               if ( prv->Value ) 
			   {
                   prv->Value[0] = (int)dw + L'0';
                   prv->Value[1] = L'\0';
               }
			   else 
			   {
                   // can't allocate buffer, error!!
               }
           }

          m_pData->Update(m_pSnapin);
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

/////////////////////////////////////////////////////////////////////////////
// CAttrRegChoice message handlers

void CAttrRegChoice::Initialize(CResult * pData)
{
   DWORD dw = 0;
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pData);

   // Display the last inspected setting in its static box
   pData->GetDisplayName( NULL, m_strLastInspect, 2 );

   // Set the template setting radio button appropriately
   m_strAttrName = pData->GetAttrPretty();
   m_StartIds=IDS_LM_FULL;

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pData->GetBase());

   if ( prv && prv->Value ) 
   {
       m_bConfigure = TRUE;

       switch(_wtol(prv->Value)) 
	   {
       case SCE_RETAIN_ALWAYS:
          m_rabRetention = 0;
          break;
       case SCE_RETAIN_AS_REQUEST:
          m_rabRetention = 1;
          break;
       case SCE_RETAIN_NC:
          m_rabRetention = 2;
          break;
       }
   } 
   else 
   {
      m_bConfigure = FALSE;
   }

}

BOOL CAttrRegChoice::OnInitDialog()
{

   CAttrRet::OnInitDialog();

   //
   // load static text for the radio buttons
   //

    CString strText;
    strText.LoadString(m_StartIds);
    SetDlgItemText( IDC_RETENTION, strText );

    strText.LoadString(m_StartIds+1);
    SetDlgItemText( IDC_RADIO2, strText );

    strText.LoadString(m_StartIds+2);
    SetDlgItemText( IDC_RADIO3, strText );

    CAttrRet::OnInitDialog();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRegChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD	dw = 0;
      int		status = 0;

      UpdateData(TRUE);

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_rabRetention) 
	     {
         case 0:
            dw = SCE_RETAIN_ALWAYS;
            break;
         case 1:
            dw = SCE_RETAIN_AS_REQUEST;
            break;
         case 2:
            dw = SCE_RETAIN_NC;
            break;
         }
      }

      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      PSCE_REGISTRY_VALUE_INFO prv2=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());

      //
      // this address should never be NULL
      //
      if ( prv ) 
      {
          DWORD dw2=SCE_NO_VALUE;
          if ( prv2 ) 
	      {
              //
              // if there is analysis setting (should always have)
              //
              if (prv2->Value ) 
                  dw2 = _wtol(prv2->Value);
		      else 
                  dw2 = SCE_NO_VALUE;
          }

          status = CEditTemplate::ComputeStatus (prv, prv2);
          if ( dw == SCE_NO_VALUE ) 
	      {
              if ( prv->Value )
                  LocalFree(prv->Value);
              prv->Value = NULL;
          } 
	      else 
	      {
              if ( prv->Value == NULL ) 
		      {
                  // allocate buffer
                  prv->Value = (PWSTR)LocalAlloc(0, 4);
              }
              if ( prv->Value ) 
		      {
                  prv->Value[0] = (int)dw + L'0';
                  prv->Value[1] = L'\0';
              } 
		      else 
		      {
                  // can't allocate buffer, error!!
              }
          }

          UpdateProfile( status );
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CAttrRegChoice::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() ) 
     m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegChoice message handlers
void CLocalPolRegChoice::UpdateProfile(DWORD status)
{
   m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegChoice::Initialize(CResult * pResult)
{
   CConfigRegChoice::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_rabRetention = 0;
   }
}

BOOL CSnapin::UpdateLocalPolRegValue( CResult *pResult ) {

   if ( !pResult)
      return FALSE;


   PEDITTEMPLATE pLocalDeltaTemplate = GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
   if (!pLocalDeltaTemplate) 
      return FALSE;
   
   PSCE_PROFILE_INFO pLocalDelta = pLocalDeltaTemplate->pTemplate;

   pLocalDelta->RegValueCount = 1;
   pLocalDelta->aRegValues = (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase();

   if( pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY) )
   {
      //
      // Set the status of the item.
      //
      PSCE_REGISTRY_VALUE_INFO pRviEffective = (PSCE_REGISTRY_VALUE_INFO)pResult->GetSetting();
      DWORD status = pResult->GetStatus();
      if(!pRviEffective || !pRviEffective->Value)
         status = SCE_STATUS_NOT_ANALYZED;
      else
         status = CEditTemplate::ComputeStatus( (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase(), pRviEffective );
      
      pResult->SetStatus(status);
      pResult->Update(this);
      return TRUE;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\savetemp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       savetemp.cpp
//
//  Contents:   implementation of CSaveTemplates
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "SaveTemp.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaveTemplates dialog


CSaveTemplates::CSaveTemplates(CWnd* pParent /*=NULL*/)
   : CHelpDialog(a186HelpIDs, IDD, pParent)
{
   //{{AFX_DATA_INIT(CSaveTemplates)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

void CSaveTemplates::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSaveTemplates)
   DDX_Control(pDX, IDC_TEMPLATE_LIST, m_lbTemplates);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaveTemplates, CHelpDialog)
   //{{AFX_MSG_MAP(CSaveTemplates)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaveTemplates message handlers

void CSaveTemplates::OnOK()
{
   CString strInfFile;
   CString strComputerTemplate;
   PEDITTEMPLATE pet = 0;


   int nCount = m_lbTemplates.GetCount();
   while(nCount--) 
   {
      if (m_lbTemplates.GetSel(nCount) == 0) 
      {
         //
         // Item isn't selected, so don't save it
         //
         continue;
      }

      pet = (PEDITTEMPLATE)m_lbTemplates.GetItemData( nCount );
      if (pet) {
         //
         // We found the template in our inf file cache
         // so save it
         //
         pet->Save();
      }
   }
   CDialog::OnOK();
}

void CSaveTemplates::OnCancel()
{
   CDialog::OnCancel();
}

/*
void CSaveTemplates::OnSaveSel()
{
   int nCount;
   CString strInfFile;
   PEDITTEMPLATE pet;

   nCount = m_lbTemplates.GetCount();
   while(nCount--) {
      if (m_lbTemplates.GetSel(nCount) > 0) {
         m_lbTemplates.GetText(nCount,strInfFile);
         //pet = (PEDITTEMPLATE) m_lbTemplates.GetItemDataPtr(nCount);
         m_Templates.Lookup(strInfFile,pet);
         pet->Save(strInfFile);
//         pet->bDirty = false;
//         SceWriteSecurityProfileInfo(strInfFile,AREA_ALL,pet->pTemplate,NULL);
         m_lbTemplates.DeleteString(nCount);
      }
   }
   CDialog::OnOK();
}

void CSaveTemplates::OnSelchangeTemplateList()
{
   if (m_lbTemplates.GetSelCount() > 0) {
      m_btnSaveSel.EnableWindow(TRUE);
   } else {
      m_btnSaveSel.EnableWindow(FALSE);
   }
}
*/

void CSaveTemplates::AddTemplate(LPCTSTR szInfFile, PEDITTEMPLATE pet)
{
   CString strInfFile;

   //
   // Special template.  Do not save.
   //
   if (pet->QueryNoSave()) {
      return;
   }

   //
   // Display the template's friendly name
   //
   CString strL = pet->GetFriendlyName();
   if (strL.IsEmpty()) {
      strL = szInfFile;
   }
   strL.MakeLower();
   m_Templates.SetAt(strL,pet);
}

BOOL CSaveTemplates::OnInitDialog()
{
   CDialog::OnInitDialog();


   POSITION pos = m_Templates.GetStartPosition();
   PEDITTEMPLATE pTemplate = 0;
   CString szKey;
   while(pos) 
   {
      m_Templates.GetNextAssoc(pos,szKey,pTemplate);
      int iIndex = m_lbTemplates.AddString( pTemplate->GetFriendlyName() );
      m_lbTemplates.SetItemData( iIndex, (LPARAM)pTemplate );
   }

   m_lbTemplates.SelItemRange(TRUE,0,m_lbTemplates.GetCount());
   
   RECT temprect; //HScroll to see full template name
   m_lbTemplates.GetWindowRect(&temprect);
   m_lbTemplates.SetHorizontalExtent((temprect.right-temprect.left)*6);

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\regvalue.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "snapmgr.h"
#include "util.h"
#include "regvldlg.h"
//#include <shlwapi.h>
//#include <shlwapip.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// create registry value list under configuration node
//
void CSnapin::CreateProfileRegValueList(MMC_COOKIE cookie,
                                        PEDITTEMPLATE pSceInfo,
                                        LPDATAOBJECT pDataObj)
{
    if ( !pSceInfo || !(pSceInfo->pTemplate) ) {
        return;
    }


    DWORD nCount = pSceInfo->pTemplate->RegValueCount;
    PSCE_REGISTRY_VALUE_INFO regArray = pSceInfo->pTemplate->aRegValues;

    CString strDisplayName;
    LPTSTR pDisplayName=NULL;
    DWORD displayType = 0;
    LPTSTR szUnits=NULL;
    PREGCHOICE pChoices=NULL;
    PREGFLAGS pFlags=NULL;
    CResult *pResult;

    for ( DWORD i=0; i<nCount; i++) {

         if ( !LookupRegValueProperty(regArray[i].FullValueName,
                                      &pDisplayName,
                                      &displayType,
                                      &szUnits,
                                      &pChoices,
                                      &pFlags) ) {
             continue;
         }

         if ( !pDisplayName ) {

             strDisplayName = regArray[i].FullValueName;

         } else {
             strDisplayName = pDisplayName;
             LocalFree(pDisplayName);
         }

         //
         // add this item
         //
         pResult = AddResultItem(strDisplayName,
                       NULL,
                       (LONG_PTR)&(regArray[i]),
                       ITEM_PROF_REGVALUE,
                       -1,
                       cookie,
                       false,
                       szUnits,
                       displayType,
                       pSceInfo,
                       pDataObj);

         if (pResult && pChoices) {
            pResult->SetRegChoices(pChoices);
         }
         if (pResult && pFlags) {
            pResult->SetRegFlags(pFlags);
         }

         if ( szUnits ) {
             LocalFree(szUnits);
         }
         szUnits = NULL;

    }

    return;
}

void
CSnapin::CreateAnalysisRegValueList(MMC_COOKIE cookie,
                                    PEDITTEMPLATE pAnalTemp,
                                    PEDITTEMPLATE pEditTemp,
                                    LPDATAOBJECT pDataObj,
                                    RESULT_TYPES type)
{
    if ( !pAnalTemp || !(pAnalTemp->pTemplate) ||
         !pEditTemp || !(pEditTemp->pTemplate) ) {

        return;
    }


    DWORD nEditCount = pEditTemp->pTemplate->RegValueCount;   // should be everything
    PSCE_REGISTRY_VALUE_INFO paEdit = pEditTemp->pTemplate->aRegValues;
    PSCE_REGISTRY_VALUE_INFO paAnal = pAnalTemp->pTemplate->aRegValues;

    CString strDisplayName;
    LPTSTR pDisplayName=NULL;
    DWORD displayType = 0;
    LPTSTR szUnits = NULL;
    PREGCHOICE pChoices = NULL;
    PREGFLAGS pFlags = NULL;
    CResult *pResult=NULL;

    for ( DWORD i=0; i<nEditCount; i++) {

        if ( !LookupRegValueProperty(paEdit[i].FullValueName,
                                     &pDisplayName,
                                     &displayType,
                                     &szUnits,
                                     &pChoices,
                                     &pFlags) ) {
            continue;
        }

        if ( !pDisplayName ) {

            strDisplayName = paEdit[i].FullValueName;

        } else {
            strDisplayName = pDisplayName;
            LocalFree(pDisplayName);
        }

         //
         // find the match in the analysis array
         // should always find a match because all existing reg values are
         // added to the array when getinfo is called
         //
         for ( DWORD j=0; j< pAnalTemp->pTemplate->RegValueCount; j++ ) {

            if ( pAnalTemp->pTemplate->aRegValues &&
                 pAnalTemp->pTemplate->aRegValues[j].FullValueName &&
                 _wcsicmp(pAnalTemp->pTemplate->aRegValues[j].FullValueName, paEdit[i].FullValueName) == 0 ) {

                 if( reinterpret_cast<CFolder *>(cookie)->GetModeBits() & MB_LOCAL_POLICY ){
                    break;
                 }

                 //
                 // find a analysis result - this item may be a mismatch (when Value is not NULL)
                 // SceEnumAllRegValues will set the status field to good if this item was not
                 // added because it did not exist when it was originally loaded from the SAP table.
                 // This tells us that this item is a MATCH and we should copy the value.
                 //
                 if ( !(paAnal[j].Value)  && paEdit[i].Value &&
                      paAnal[j].Status != SCE_STATUS_ERROR_NOT_AVAILABLE &&
                      paAnal[j].Status != SCE_STATUS_NOT_ANALYZED ) {

                     //
                     // this is a good item, copy the config info as the analysis info
                     //
                     paAnal[j].Value = (PWSTR)LocalAlloc(0,
                                           (wcslen(paEdit[i].Value)+1)*sizeof(WCHAR));

                     if ( paAnal[j].Value ) {
                         wcscpy(paAnal[j].Value, paEdit[i].Value);

                     } else {
                         // else out of memory
                         if ( szUnits ) {
                             LocalFree(szUnits);
                         }
                         szUnits = NULL;
                         return;
                     }
                 }
                 break;
            }
         }

         DWORD status = SCE_STATUS_GOOD;
         if ( j < pAnalTemp->pTemplate->RegValueCount ) {
            status = CEditTemplate::ComputeStatus( &paEdit[i], &pAnalTemp->pTemplate->aRegValues[j] );
         } else {
             //
             // did not find the analysis array, shouldn't happen
             //
             status = SCE_STATUS_NOT_CONFIGURED;
         }

         //
         // add this item
         //
         if ( j < pAnalTemp->pTemplate->RegValueCount) {

            pResult = AddResultItem(strDisplayName,
                          (LONG_PTR)&(pAnalTemp->pTemplate->aRegValues[j]),
                          (LONG_PTR)&(paEdit[i]),
                          type,
                          status,
                          cookie,
                          false,
                          szUnits,
                          displayType,
                          pEditTemp,
                          pDataObj);

            if (pResult && pChoices) {
               pResult->SetRegChoices(pChoices);
            }
            if (pResult && pFlags) {
               pResult->SetRegFlags(pFlags);
            }
         } else {
            //
            // a good/not configured item
            //
            pResult = AddResultItem(strDisplayName,
                          NULL,
                          (LONG_PTR)&(paEdit[i]),
                          type,
                          status,
                          cookie,
                          false,
                          szUnits,
                          displayType,
                          pEditTemp,
                          pDataObj);

            if (pResult && pChoices) {
               pResult->SetRegChoices(pChoices);
            }
         }

         if ( szUnits ) {
             LocalFree(szUnits);
         }
         szUnits = NULL;

    }

    return;
}


BOOL
LookupRegValueProperty(
    IN LPTSTR RegValueFullName,
    OUT LPTSTR *pDisplayName,
    OUT PDWORD displayType,
    OUT LPTSTR *pUnits OPTIONAL,
    OUT PREGCHOICE *pChoices OPTIONAL,
    OUT PREGFLAGS *pFlags OPTIONAL
    )
{
    if ( !RegValueFullName || !pDisplayName || !displayType ) {
       return FALSE;
    }

    CString strTmp = RegValueFullName;

    //
    // replace the \\ with / before search reg
    //
    int npos = strTmp.Find(L'\\');

    while (npos > 0) {
       *(strTmp.GetBuffer(1)+npos) = L'/';
       npos = strTmp.Find(L'\\');
    }

    //
    // query the values from registry
    //
    *pDisplayName = NULL;

    HKEY hKey=NULL;
    HKEY hKey2=NULL;
    DWORD rc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    SCE_ROOT_REGVALUE_PATH,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if (rc == ERROR_SUCCESS) {

        rc = RegOpenKeyEx(
                hKey,
                (PWSTR)(LPCTSTR)strTmp,
                0,
                KEY_READ,
                &hKey2
                );

    }

    BOOL bRet;

    if ( ERROR_SUCCESS == rc) {

        DWORD RegType = 0;
        PWSTR Value=NULL;
        HRESULT hr = S_OK;

        Value = (PWSTR) LocalAlloc(LPTR,MAX_PATH*sizeof(WCHAR));
        if (Value) {
           //
           // 126714 - shouldn't hard code display strings in the registry
           //          store them indirectly so they can support MUI
           //
           hr = SHLoadRegUIString(hKey2,
                                  SCE_REG_DISPLAY_NAME,
                                  Value,
                                  MAX_PATH);
           if (FAILED(hr)) {
              rc = MyRegQueryValue(
                       hKey,
                       (PWSTR)(LPCTSTR)strTmp,
                       SCE_REG_DISPLAY_NAME,
                       (PVOID *)&Value,
                       &RegType
                       );
           } else {
              rc = ERROR_SUCCESS;
           }
        }
        if ( rc == ERROR_SUCCESS ) {

            if (  Value ) {
                *pDisplayName = Value;
                Value = NULL;
            } else {
                //
                // did not find correct display name, use the reg name (outsize)
                //
                *pDisplayName = NULL;
            }
        }

        rc = MyRegQueryValue(
                    hKey,
                    (PWSTR)(LPCTSTR)strTmp,
                    SCE_REG_DISPLAY_TYPE,
                    (PVOID *)&displayType,
                    &RegType
                    );

        if ( Value ) {
            LocalFree(Value);
            Value = NULL;
        }

        if ( pUnits ) {
            //
            // query the units
            //
            rc = MyRegQueryValue(
                        hKey,
                        (PWSTR)(LPCTSTR)strTmp,
                        SCE_REG_DISPLAY_UNIT,
                        (PVOID *)&Value,
                        &RegType
                        );

            if ( rc == ERROR_SUCCESS ) {

                if ( RegType == REG_SZ && Value ) {
                    *pUnits = Value;
                    Value = NULL;
                } else {
                    //
                    // did not find units
                    //
                    *pUnits = NULL;
                }
            }
            if ( Value ) {
                LocalFree(Value);
                Value = NULL;
            }
        }

        //
        // find the registry key but may not find the display name
        //
        bRet = TRUE;

        if ( pChoices ) {
           //
           // query the choices
           //
           *pChoices = NULL;

           rc = MyRegQueryValue(hKey,
                                (PWSTR)(LPCTSTR)strTmp,
                                SCE_REG_DISPLAY_CHOICES,
                                (PVOID *)&Value,
                                &RegType
                               );
           if (ERROR_SUCCESS == rc) {
              if ((REG_MULTI_SZ == RegType) && Value) {
                 LPTSTR szChoice = NULL;
                 LPTSTR szLabel = NULL; // max field size for szChoice + dwVal
                 DWORD dwVal = -1;
                 PREGCHOICE pRegChoice = NULL;
                 PREGCHOICE pLast = NULL;

                 szChoice = Value;
                 do {
                    //
                    // Divide szChoice into dwValue and szLabel sections
                    //
                    szLabel = _tcschr(szChoice,L'|');
                    *szLabel = L'\0';
                    szLabel++;
                    dwVal = _ttoi(szChoice);

                    pRegChoice = (PREGCHOICE) LocalAlloc(LPTR,sizeof(REGCHOICE));
                    if (pRegChoice) {
                       //
                       // Fill in fields of new reg choice
                       //
                       pRegChoice->dwValue = dwVal;
                       pRegChoice->szName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(szLabel)+1)*sizeof(TCHAR));
                       if (NULL == pRegChoice->szName) {
                          //
                          // Out of memory.  Bummer.
                          //
                          LocalFree(pRegChoice);
                          pRegChoice = NULL;
                          break;
                       }
                       lstrcpy(pRegChoice->szName,szLabel);
                       //
                       // Attach new item to end of list
                       //
                       if (NULL == *pChoices) {
                          *pChoices = pRegChoice;
                       } else {
                          pLast->pNext = pRegChoice;
                       }
                       pLast = pRegChoice;
                    }
                    szChoice = _tcschr(szLabel,L'\0');
                    szChoice++;

                 } while (*szChoice);
              } else {
                 //
                 // Did not find choices
                 //
                 bRet = FALSE;
              }
           }

           if ( Value ) {
               LocalFree(Value);
               Value = NULL;
           }

        }

        if ( pFlags ) {
           //
           // query the Flags
           //
           *pFlags = NULL;

           rc = MyRegQueryValue(hKey,
                                (PWSTR)(LPCTSTR)strTmp,
                                SCE_REG_DISPLAY_FLAGLIST,
                                (PVOID *)&Value,
                                &RegType
                               );
           if (ERROR_SUCCESS == rc) {
              if ((REG_MULTI_SZ == RegType) && Value) {
                 LPTSTR szFlag = NULL;
                 LPTSTR szLabel = NULL; // max field size for szFlag + dwVal
                 DWORD dwVal = -1;
                 PREGFLAGS pRegFlag = NULL;
                 PREGFLAGS pLast = NULL;

                 szFlag = Value;
                 do {
                    //
                    // Divide szFlag into dwValue and szLabel sections
                    //
                    szLabel = _tcschr(szFlag,L'|');
                    *szLabel = L'\0';
                    szLabel++;
                    dwVal = _ttoi(szFlag);

                    pRegFlag = (PREGFLAGS) LocalAlloc(LPTR,sizeof(REGFLAGS));
                    if (pRegFlag) {
                       //
                       // Fill in fields of new reg Flag
                       //
                       pRegFlag->dwValue = dwVal;
                       pRegFlag->szName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(szLabel)+1)*sizeof(TCHAR));
                       if (NULL == pRegFlag->szName) {
                          //
                          // Out of memory.  Bummer.
                          //
                          LocalFree(pRegFlag);
                          pRegFlag = NULL;
                          break;
                       }
                       lstrcpy(pRegFlag->szName,szLabel);
                       //
                       // Attach new item to end of list
                       //
                       if (NULL == *pFlags) {
                          *pFlags = pRegFlag;
                       } else {
                          pLast->pNext = pRegFlag;
                       }
                       pLast = pRegFlag;
                    }
                    szFlag = wcschr(szLabel,L'\0');
                    szFlag++;

                 } while (*szFlag);
              } else {
                 //
                 // Did not find Flags
                 //
                 bRet = FALSE;
              }
           }

           if ( Value ) {
               LocalFree(Value);
               Value = NULL;
           }

        }
    } else {
        //
        // did not find the registry key
        //
        bRet = FALSE;
    }

    if ( hKey ) {
        RegCloseKey(hKey);
    }
    if ( hKey2 ) {
        RegCloseKey(hKey2);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wsecmgr.rc
//
#define IDS_EXTENSION_DESC              1
#define IDS_NAME                        2
#define IDS_DESC                        3
#define IDOK2                           3
#define IDS_ATTR                        4
#define IDCANCEL2                       4
#define IDS_BASE_ANALYSIS               5
#define IDS_SETTING                     6
#define IDS_NODENAME                    7
#define IDS_CONFIGURE                   8
#define IDS_ANALYZE                     9
#define IDS_CONFIGURE_DESC              10
#define IDS_ANALYZE_DESC                11
#define IDS_POLICY                      12
#define IDS_PRIVILEGE                   13
#define IDS_GROUPS                      14
#define IDS_SERVICE                     15
#define IDS_REGISTRY                    16
#define IDS_FILESTORE                   17
#define IDS_POLICY_DESC                 18
#define IDS_PRIVILEGE_DESC              19
#define IDS_GROUPS_DESC                 20
#define IDS_SERVICE_DESC                21
#define IDS_REGISTRY_DESC               22
#define IDS_FILESTORE_DESC              23
#define IDS_TEMPLATE_EDITOR_NAME        24
#define IDS_NOT_SAVED_SUFFIX            25
#define IDS_EXTENSION_NAME              26
#define IDS_SCE_DESC                    27
#define IDS_SAV_DESC                    28
#define IDS_DELETE_CONFIRM              29
#define IDS_ABOUT_SECMGR                30
#define IDS_DELETE_ALL_ITEMS            30
#define IDS_ANALYZE_PROFILE             31
#define IDS_REAPPLY_PROFILE             32
#define IDS_PROFILE_SUMMARY             33
#define IDS_GENERATE_PROFILE            34
#define IDS_ADD_ENTRY                   35
#define IDS_ADD_FILES                   35
#define IDS_ADD_LOCATION                36
#define IDS_NEW_PROFILE                 37
#define IDS_REMOVE_LOCATION             38
#define IDS_RELOAD_LOCATION             39
#define IDS_APPLY_PROFILE               40
#define IDS_DELETE_PROFILE              41
#define IDS_IMPORT_POLICY_FAIL          42
#define IDS_SAVEAS_PROFILE              43
#define IDS_COPY_PROFILE                44
#define IDS_PASTE_PROFILE               45
#define IDS_RSOP_GPO                    46
#define IDS_REFRESH_AREA                47
#define IDS_SECURITY_REQUIRED           48
#define IDS_CANT_ASSIGN_SECURITY        49
#define IDS_PASSWORD_CATEGORY           50
#define IDS_MAX_PAS_AGE                 51
#define IDS_MIN_PAS_AGE                 52
#define IDS_MIN_PAS_LEN                 53
#define IDS_PAS_UNIQUENESS              54
#define IDS_PAS_COMPLEX                 55
#define IDS_REQ_LOGON                   56
#define IDS_LOCKOUT_CATEGORY            57
#define IDS_LOCK_COUNT                  58
#define IDS_LOCK_RESET_COUNT            59
#define IDS_LOCK_DURATION               60
#define IDS_LOGON_CATEGORY              61
#define IDS_CONFIRM_DELETE_TEMPLATE     61
#define IDS_NO_DISP_NAME                62
#define IDS_ANALYZE_NT4                 62
#define IDS_FORCE_LOGOFF                63
#define IDS_RENAME_ADMIN                64
#define IDS_NEW_ADMIN                   65
#define IDS_RENAME_GUEST                66
#define IDS_NEW_GUEST                   67
#define IDS_ALLOC_FLOPPY                68
#define IDS_REFRESH_LOCALPOL            68
#define IDS_ALLOC_CDROM                 69
#define IDS_GROUP_NAME                  69
#define IDS_EVENT_LOG                   70
#define IDS_SYS_LOG_MAX                 71
#define IDS_SYS_LOG_RET                 72
#define IDS_SYS_LOG_DAYS                73
#define IDS_SEC_LOG_MAX                 74
#define IDS_SEC_LOG_RET                 75
#define IDS_SEC_LOG_DAYS                76
#define IDS_APP_LOG_MAX                 77
#define IDS_APP_LOG_RET                 78
#define IDS_APP_LOG_DAYS                79
#define IDS_CRASH_LOG_FULL              80
#define IDS_EVENT_AUDIT                 81
#define IDS_EVENT_ON                    82
#define IDS_SYSTEM_EVENT                83
#define IDS_LOGON_EVENT                 84
#define IDS_OBJECT_ACCESS               85
#define IDS_PRIVILEGE_USE               86
#define IDS_POLICY_CHANGE               87
#define IDS_ACCOUNT_MANAGE              88
#define IDS_PROCESS_TRACK               89
#define IDS_OTHER_CATEGORY              90
#define IDS_PROTECT_BASE                91
#define IDS_EVENT_AUDIT_DESC            91
#define IDS_NO_POLICY                   92
#define IDS_ADMIN_RENAMED               93
#define IDS_GUEST_RENAMED               94
#define IDS_CANT_ADD_MEMBER             95
#define IDS_CANT_SHOW_SECURITY          96
#define IDS_CANT_ADD_USER               97
#define IDS_CANT_ADD_DSOBJECT           98
#define IDS_CANT_ADD_FOLDER             99
#define IDS_GRP_MEMBERS                 100
#define IDS_GRP_MEMBEROF                101
#define IDS_DEFDATABASENAME             101
#define IDS_NO_DBCS                     102
#define IDS_PERMISSION                  103
#define IDS_AUDITING                    104
#define IDS_NO_ACL_SUPPORT              105
#define IDD_CONFIG_PRIVS                106
#define IDS_CANT_ADD_FILE               106
#define IDD_CONFIG_MEMBERSHIP           107
#define IDS_INVALID_NAME                107
#define IDS_ERROR_GENERATE              108
#define IDS_CANT_ADD_KEY                109
#define IDS_FILE_GEN_ALL                110
#define IDS_FILE_GEN_MODIFY             111
#define IDS_FILE_GEN_READ               112
#define IDS_FILE_GEN_LIST               113
#define IDS_FILE_SPEC_READ              114
#define IDS_FILE_SPEC_WRITE             115
#define IDS_FILE_SPEC_EXECUTE           116
#define IDS_FILE_SPEC_DELETE            117
#define IDS_FILE_SPEC_CHANGE_PERM       118
#define IDS_FILE_SPEC_CHANGE_OWNER      119
#define IDS_NONE                        120
#define IDS_KEY_ALL_ACCESS              121
#define IDS_KEY_READ                    122
#define IDS_KEY_WRITE                   123
#define IDS_KEY_QUERY_VALUE             124
#define IDS_KEY_SET_VALUE               125
#define IDS_KEY_CREATE_SUB_KEY          126
#define IDS_KEY_ENUMERATE_SUB_KEYS      127
#define IDS_KEY_NOTIFY                  128
#define IDS_KEY_CREATE_LINK             129
#define IDS_KEY_EXECUTE                 130
#define IDS_CANT_CREATE_THREAD          131
#define IDS_ERR_INVALIDACCOUNT          132
#define IDS_EVENT_OTHER_DESC            133
#define IDS_PASSWORD_DESC               134
#define IDS_STATIC_PROFILE_NAME         140
#define IDS_STATIC_LOG_NAME             141
#define IDS_APPLY_TITLE                 142
#define IDS_ANALYZE_TITLE               143
#define IDS_SECURITY_SETTING_DESC       144
#define IDS_SELECT_PROFILE              145
#define IDS_SECMGR_VERSION              146
#define IDS_SECMGR_DESC                 147
#define IDS_LAST_ANALYSIS               148
#define IDS_PROFILE_DESC                149
#define IDS_NO_ANALYSIS                 150
#define IDS_NEVER_ANALYSIS              151
#define IDS_TITLE_ABOUT_SECMGR          152
#define IDS_TITLE_ABOUT_ANALYSIS        153
#define IDS_ADDLOCATION_TITLE           154
#define IDS_NEWPROFILE_TITLE            155
#define IDS_ADDLOCATION_NAME            156
#define IDS_ADDLOCATION_HELP            157
#define IDS_ADDLOCATION_DESC            158
#define IDS_NEWPROFILE_NAME             159
#define IDS_NEWPROFILE_HELP             160
#define IDS_NEWPROFILE_DESC             161
#define IDS_NEWPROFILE_FULLPATH         162
#define IDS_REAPPLY_TITLE               163
#define IDS_SAVEAS_TITLE                164
#define IDS_COL_OBJECT                  165
#define IDD_ANALYSIS_ANALYZE            165
#define IDS_COL_BAD_COUNT               166
#define IDD_ANALYSIS_SUMMARY            166
#define IDS_COL_CHECK_STATUS            167
#define IDD_ATTR_STRING                 167
#define IDD_ATTR_NUMBER                 168
#define IDS_OPEN_PROFILE                168
#define IDD_ATTR_ENABLE                 169
#define IDS_PROFILE_FILTER              169
#define IDD_ATTR_AUDIT                  170
#define IDS_PROFILE_DEF_EXT             170
#define IDD_GROUP_ADD_MEMBERSHIP        171
#define IDS_OPEN_LOGFILE                171
#define IDD_PRIVELEGE_ADD               172
#define IDS_LOGFILE_DEF_EXT             172
#define IDD_ANALYZE_SECURITY            173
#define IDS_LOGFILE_FILTER              173
#define IDD_CONFIGURATION_CONFIGURE     174
#define IDS_INF_MIN_PAS_AGE             174
#define IDS_INF_MAX_PAS_AGE             175
#define IDS_INF_MIN_PAS_LEN             176
#define IDD_REGISTRY_DIALOG             177
#define IDS_INF_PAS_HIST                177
#define IDD_GROUP_ADD_MEMBEROF          178
#define IDS_INF_PAS_COMPLEX             178
#define IDS_INF_LOCKOUT_COUNT           179
#define IDS_INF_RESET_LOCKOUT           180
#define IDD_CONFIG_AUDIT                180
#define IDS_INF_LOCKOUT_DUR             181
#define IDD_CONFIG_NUMBER               181
#define IDS_PAS_REQUIRE_LOGON           182
#define IDD_CONFIG_ENABLE               182
#define IDS_INF_FORCE_LOGOFF            183
#define IDD_CONFIG_NAME                 183
#define IDS_INF_RENAME_ADMIN            184
#define IDS_INF_NEW_ADMIN               185
#define IDS_INF_RENAME_GUEST            186
#define IDD_SAVE_TEMPLATES              186
#define IDS_INF_NEW_GUEST               187
#define IDS_INF_PROTECT_BASE            188
#define IDD_SAVEAS                      188
#define IDS_INF_ALLOCATE_FLOPPIES       189
#define IDD_ATTR_RET                    189
#define IDS_INF_ALLOCATE_CD             190
#define IDD_CONFIG_RET                  190
#define IDS_DONT_DISP_USER_NAME         191
#define IDD_ATTR_RIGHT                  191
#define IDS_INF_SECURE_SYS_PARTITION    192
#define IDD_ATTR_PRIV                   192
#define IDS_TEMPLATE_LOCATION_KEY       193
#define IDD_ANALYSIS_GENERATE           193
#define IDS_ERROR_CANT_OPEN_PROFILE     194
#define IDD_ANALYSIS_SERVICE            194
#define IDS_ERROR_CANT_GET_PROFILE_INFO 195
#define IDD_CONFIG_SERVICE              195
#define IDS_ERROR_NO_ANALYSIS_INFO      196
#define IDS_FOREVER                     197
#define IDD_CONFIG_OBJECT               197
#define IDS_AS_NEEDED                   198
#define IDD_DIALOG1                     198
#define IDD_ATTR_OBJECT                 198
#define IDI_SCE                         199
#define IDS_BY_DAYS                     199
#define IDD_ANALYZE_PROGRESS            199
#define IDI_SCE_APP                     199
#define IDI_AREA_CHECKED                200
#define IDS_MANUALLY                    200
#define IDC_NEW_FOLDER                  201
#define IDS_ENABLED                     201
#define IDI_AREA_CURRENT                201
#define IDC_STATIC_DESC                 202
#define IDS_DISABLED                    202
#define IDC_STATIC_TITLE                203
#define IDS_ON                          203
#define IDC_PROGRESS                    204
#define IDS_OFF                         204
#define IDC_ProfileName                 205
#define IDS_NOT_CONFIGURED              205
#define IDB_ICON16                      205
#define IDC_LogName                     206
#define IDS_TIME_UNITS                  206
#define IDB_TOOLBAR1                    207
#define IDC_BtnBrowse                   207
#define IDS_ACCEPT_NUMBER_FMT           207
#define IDB_TOOLBAR2                    208
#define IDC_STATIC_PROGRESS             208
#define IDS_CHANGE_NUMBER_FMT           208
#define IDD_ABOUT_SECMGR                209
#define IDC_STATIC_PROFILE_NAME         209
#define IDS_INDENT                      209
#define IDD_APPLY                       210
#define IDC_PROFILE_NAME                210
#define IDS_COL_MEMBERSHIP              210
#define IDD_APPLY_ANALYZE               211
#define IDC_BTN_BROWSE                  211
#define IDS_COL_MEMBEROF                211
#define IDB_ICON32                      211
#define IDC_STATIC_LOG_NAME             212
#define IDD_MULTI_SZ                    212
#define IDS_TITLE_MEMBERS               212
#define IDD_APPLY_CONFIGURATION         212
#define IDC_LOG_NAME                    213
#define IDD_ANALYSIS_CONFIGURE          213
#define IDS_TITLE_MEMBEROF              213
#define IDS_HKCR                        214
#define IDD_ATTR_GROUP                  214
#define IDC_DESCRIPTION                 215
#define IDS_HKLM                        215
#define IDD_PERFORM_ANALYSIS            215
#define IDC_LIST_CURRENT                216
#define IDS_HKU                         216
#define IDD_ASSIGN_PROFILE              216
#define IDC_LIST_BASE                   217
#define IDS_SCESTATUS_SUCCESS           217
#define IDD_ASSIGN_CONFIG_CHECK         217
#define IDD_SET_DESCRIPTION             218
#define IDC_BTN_ADD                     218
#define IDS_SCESTATUS_INVALID_PARAMETER 218
#define IDC_BTN_REMOVE                  219
#define IDS_STRING219                   219
#define IDC_BTN_ACCEPT                  220
#define IDS_INVALID_DATA                220
#define IDB_ARROW                       220
#define IDC_STATIC_CURRENT              221
#define IDS_STRING221                   221
#define IDB_CHECK                       221
#define IDC_STATIC_BASE                 222
#define IDS_STRING222                   222
#define IDC_DATABASE_DIR                223
#define IDS_STRING223                   223
#define IDB_SCE_LARGE                   223
#define IDC_CHANGE_PROFILE              224
#define IDS_STRING224                   224
#define IDB_SCE_SMALL                   224
#define IDC_LAST_ANALYSIS_TIME          225
#define IDS_STRING225                   225
#define IDD_NEW_PROFILE                 225
#define IDC_PROFILE                     226
#define IDS_STRING226                   226
#define IDD_LOCALPOL_AUDIT              226
#define IDC_ERROR_LOG                   227
#define IDC_NC_POLICY                   227
#define IDS_STRING227                   227
#define IDD_LOCALPOL_ENABLE             227
#define IDC_CHANGE_DATABASE_DIR         228
#define IDC_TITLE                       228
#define IDC_NC_GROUPS                   228
#define IDS_STRING228                   228
#define IDD_LOCALPOL_NUMBER             228
#define IDC_CHANGE_ERROR_LOG            229
#define IDC_CURRENT                     229
#define IDC_NC_PRIVELEGES               229
#define IDC_TITLE_MEMBER_OF             229
#define IDS_UNKNOWN_ERROR               229
#define IDD_LOCALPOL_RET                229
#define IDC_NC_REGISTRY                 230
#define IDS_STRING230                   230
#define IDD_LOCALPOL_STRING             230
#define IDC_NC_FILESYSTEM               231
#define IDS_STRING231                   231
#define IDD_LOCALPOL_RIGHT              231
#define IDS_DEFAULT_TEMPLATE_DIR        232
#define IDC_LAST_CONFIG_TIME            232
#define IDC_SPIN                        233
#define IDS_SE_NETWORK_LOGON_RIGHT      233
#define IDC_NC_SERVICE                  233
#define IDC_NEW                         234
#define IDS_SE_INTERACTIVE_LOGON_RIGHT  234
#define IDC_UNITS                       235
#define IDS_SAVE_FAILED                 235
#define IDD_LOCALPOL_REGCHOICES         235
#define IDC_IGNORE                      236
#define IDS_SAVE_PROFILE                236
#define IDD_CONFIG_REGCHOICES           236
#define IDC_ENABLED                     237
#define IDS_SECEDIT_KEY                 237
#define IDD_ATTR_REGCHOICES             237
#define IDD_WARNING_DIALOG              238
#define IDC_DISABLED                    238
#define IDS_ADDFOLDER_TITLE             238
#define IDC_CURRENT_SUCCESS             239
#define IDS_ADD_FOLDER                  239
#define IDD_DOMAIN_AUDIT                239
#define IDC_CURRENT_FAILED              240
#define IDS_ADD_KEY                     240
#define IDD_DOMAIN_ENABLE               240
#define IDC_CHANGE                      241
#define IDS_ADD_GROUP                   241
#define IDB_BITMAP1                     241
#define IDD_DOMAIN_MEMBERSHIP           241
#define IDC_ACCEPT                      242
#define IDS_AUDIT_SUCCESS               242
#define IDB_TEMPLATE                    242
#define IDD_DOMAIN_NAME                 242
#define IDC_CHANGE_SUCCESS              243
#define IDS_NO_AUDIT_SUCCESS            243
#define IDB_ANALYSIS                    243
#define IDD_DOMAIN_NUMBER               243
#define IDC_CHANGE_FAILED               244
#define IDC_CURRENT_MEMBER_OF           244
#define IDS_AUDIT_FAILURE               244
#define IDI_TEMPLATE                    244
#define IDD_DOMAIN_OBJECT               244
#define IDC_RECC_MEMBER_OF              245
#define IDS_NO_AUDIT_FAILURE            245
#define IDI_LOCALPOLICY                 245
#define IDD_DOMAIN_PRIVS                245
#define IDC_ADD                         246
#define IDS_GENERATE_TEMPLATE           246
#define IDI_POLICY                      246
#define IDD_DOMAIN_REGCHOICES           246
#define IDC_REMOVE                      247
#define IDS_RECONFIGURE                 247
#define IDI_ANALYSIS                    247
#define IDD_DOMAIN_RET                  247
#define IDC_ADD_MEMBEROF                248
#define IDS_COL_SERVICE                 248
#define IDB_POLICY                      248
#define IDD_DOMAIN_SERVICE              248
#define IDC_ACCEPT_RECOMMENDED          249
#define IDC_REMOVE_MEMBEROF             249
#define IDS_STARTUP                     249
#define IDB_LOCALPOLICY                 249
#define IDC_ACCEPT_CURRENT              250
#define IDS_INSPECTED                   250
#define IDI_WARNING_INFORMATIONAL       250
#define IDS_CONFIGURED                  251
#define IDS_AUTOMATIC                   252
#define IDC_RECC_PRIV                   253
#define IDS_MANUAL                      253
#define IDD_CONFIG_REGMULTISZ           253
#define IDC_CURRENT_PRIV2               254
#define IDC_CURRENT_PRIV                254
#define IDS_OK                          254
#define IDD_ATTR_REGMULTISZ             254
#define IDS_INVESTIGATE                 255
#define IDD_LOCALPOL_REGMULTISZ         255
#define IDS_CONFIG_SECURITY_PAGE        256
#define IDD_DOMAIN_REGMULTISZ           256
#define IDC_APPLY                       257
#define IDS_ANALYSIS_SECURITY_PAGE      257
#define IDD_CONFIG_REGFLAGS             257
#define IDS_SECURITY_PAGE               258
#define IDD_ATTR_REGFLAGS               258
#define IDS_SERVICE_ALL                 259
#define IDD_LOCALPOL_REGFLAGS           259
#define IDC_VIEW                        260
#define IDS_SERVICE_READ                260
#define IDD_DOMAIN_REGFLAGS             260
#define IDD_ADD_OBJECT                  261
#define IDC_VIEW_EDIT                   261
#define IDS_SERVICE_MODIFY              261
#define IDS_SERVICE_WRITE               261
#define IDS_GROUP_MEMBER_OF_HEADER      262
#define IDD_PRECEDENCE                  262
#define IDS_GROUP_MEMBERS_HEADER        263
#define IDS_GROUP_MEMBER_OF_PAGE_TITLE  264
#define IDC_CURRENT_MEMBERS             265
#define IDS_GROUP_MEMBERS_PAGE_TITLE    265
#define IDC_RECC_MEMBERS                266
#define IDS_ACCOUNT_POLICY              266
#define IDS_ACCOUNT_DESC                267
#define IDS_LOCAL_POLICY                268
#define IDS_LOCAL_DESC                  269
#define IDS_EVENTLOG_POLICY             270
#define IDC_SUCCESSFUL                  271
#define IDS_EVENTLOG_DESC               271
#define IDC_FAILED                      272
#define IDS_UAS_REQUIRED                272
#define IDS_DIRECTORY_ACCESS            272
#define IDS_RESTRICT_ANONYMOUS          273
#define IDS_ACCOUNT_LOGON               273
#define IDS_LMCOMPAT_LEVEL              274
#define IDC_VALUE                       275
#define IDS_SYS_LOG_GUEST               275
#define IDC_VALSPIN                     276
#define IDS_SEC_LOG_GUEST               276
#define IDS_APP_LOG_GUEST               277
#define IDS_LM_FULL                     278
#define IDS_LM_NEEDED                   279
#define IDS_LM_NEVER                    280
#define IDS_OBJECT_IGNORE               281
#define IDS_OBJECT_AUTO_INHERIT         282
#define IDC_NAME                        283
#define IDS_OBJECT_NO_AUTO_INHERIT      283
#define IDC_CBUNITS                     284
#define IDS_OBJECT_OVERWRITE            284
#define IDS_GENERIC_ERROR               285
#define IDS_SE_BATCH_LOGON_RIGHT        286
#define IDC_GRANTLIST                   287
#define IDS_SE_SERVICE_LOGON_RIGHT      287
#define IDC_MEMBEROF                    288
#define IDS_DSOBJECT                    288
#define IDS_DSOBJECT_DESC               289
#define IDC_MEMBERS                     290
#define IDS_ADD_DSOBJECT                290
#define IDC_TITLE_MEMBERS               291
#define IDS_FILE_GENERIC_READ           291
#define IDC_ADD_MEMBER                  292
#define IDS_FILE_GENERIC_WRITE          292
#define IDC_REMOVE_MEMBER               293
#define IDS_FILE_SPEC_READ_DATA         293
#define IDC_REGTREE                     294
#define IDS_FILE_SPEC_READ_ATTR         294
#define IDC_TEMPLATE_LIST               295
#define IDS_FILE_SPEC_READ_EA           295
#define IDC_SAVE_SEL                    296
#define IDS_FILE_SPEC_WRITE_DATA        296
#define IDS_FILE_SPEC_APPEND_DATA       297
#define IDS_FILE_SPEC_WRITE_ATTR        298
#define IDS_FILE_SPEC_WRITE_EA          299
#define IDC_TEMPLATENAME                300
#define IDS_FILE_SPEC_DELETE_CHILD      300
#define IDC_LAST_INSPECT                301
#define IDS_STD_DELETE                  301
#define IDC_RETENTION                   302
#define IDS_STD_READ_CONTROL            302
#define IDC_ATTRIBUTE_NAME              303
#define IDS_STD_WRITE_DAC               303
#define IDC_CONFIGURE                   304
#define IDS_STD_WRITE_OWNER             304
#define IDC_RIGHTS                      305
#define IDS_STD_SYNCHRONIZE             305
#define IDC_STATIC_FILENAME             306
#define IDS_FILE_GENERAL_PUBLISH        306
#define IDC_BASESD                      307
#define IDC_OVERWRITE                   307
#define IDS_FILE_GENERAL_DEPOSIT        307
#define IDC_CURRENTSD                   308
#define IDC_RADIO2                      308
#define IDS_FILE_GENERAL_EXECUTE        308
#define IDS_FILE_GENERIC_EXECUTE        308
#define IDC_RADIO3                      309
#define IDS_FILE_FOLDER                 309
#define IDS_FILE_FOLDER_SUBITEMS        310
#define IDC_SECURITY                    311
#define IDS_FILE_FOLDER_SUBFOLDER       311
#define IDS_FILE_FOLDER_FILE            312
#define IDC_TEMPLATE_SECURITY           313
#define IDS_FILE_SUBITEMS_ONLY          313
#define IDC_INSPECTED_SECURITY2         314
#define IDC_INSPECTED_SECURITY          314
#define IDS_FILE_SUBFOLDER_ONLY         314
#define IDC_INSPECTED                   315
#define IDS_FILE_FILE_ONLY              315
#define IDC_HEADER                      316
#define IDS_KEY_FOLDER                  316
#define IDS_KEY_FOLDER_SUBFOLDER        317
#define IDC_AUTOINHERIT                 318
#define IDS_KEY_SUBFOLDER_ONLY          318
#define IDC_NOAUTOINHERIT               319
#define IDS_KEY_FOLDER_SUBITEMS         319
#define IDS_KEY_SUBITEMS_ONLY           320
#define IDC_CHECK                       320
#define IDS_SERVICE_EXECUTE             321
#define IDC_PROGRESS1                   321
#define IDS_SERVICE_QUERY_CONFIG        322
#define IDC_ICON1                       322
#define IDS_SERVICE_CHANGE_CONFIG       323
#define IDC_ICON2                       323
#define IDS_SERVICE_QUERY_STATUS        324
#define IDC_ICON3                       324
#define IDS_SERVICE_ENUMERATE           325
#define IDC_ICON4                       325
#define IDS_SERVICE_START               326
#define IDC_ICON5                       326
#define IDS_SERVICE_STOP                327
#define IDC_ICON6                       327
#define IDS_SERVICE_PAUSE               328
#define IDC_ICON7                       328
#define IDS_SERVICE_INTERROGATE         329
#define IDC_ICON8                       329
#define IDS_SERVICE_USER_CONTROL        330
#define IDC_AREA1                       330
#define IDS_DS_ALL                      331
#define IDC_AREA2                       331
#define IDC_LI_TITLE                    331
#define IDS_DS_READ                     332
#define IDC_AREA3                       332
#define IDC_TEMPLATE_TITLE              332
#define IDS_DS_WRITE                    333
#define IDC_AREA4                       333
#define IDC_CHECK1                      333
#define IDS_DS_ACTRL_OPEN               334
#define IDC_AREA5                       334
#define IDC_INCREMENTAL                 334
#define IDS_DS_ACTRL_CREATE             335
#define IDC_AREA6                       335
#define IDC_LOG_FILE                    335
#define IDS_DS_ACTRL_DELETE             336
#define IDC_AREA7                       336
#define IDC_BROWSE                      336
#define IDS_DS_ACTRL_LIST               337
#define IDC_AREA8                       337
#define IDS_DS_ACTRL_SELF               338
#define IDC_ERROR                       338
#define IDC_REGKEY                      339
#define IDS_DS_ACTRL_READ_PROP          339
#define IDS_DS_ACTRL_WRITE_PROP         340
#define IDC_VERB                        340
#define IDS_DS_FOLDER                   341
#define IDC_EDIT1                       341
#define IDC_CONFIG_NAME                 341
#define IDS_DS_FOLDER_SUBFOLDER         342
#define IDC_EFFECTIVE_POLICY            342
#define IDS_DS_SUBFOLDER_ONLY           343
#define IDC_CHOICES                     343
#define IDS_COMPUTER_TEMPLATE           344
#define IDC_FAILEDLIST                  344
#define IDS_NO_LOCKOUT                  345
#define IDC_WARNING                     345
#define IDS_CHANGE_IMMEDIATELY          346
#define IDS_PERMIT_BLANK                347
#define IDS_NO_HISTORY                  348
#define IDS_PASSWORD_EXPIRE             349
#define IDC_ANALYZED_COMPUTER_STRING_STATIC 349
#define IDS_PASSWORD_CHANGE             350
#define IDC_CHANGE_TEMPLATE_SETTING_STATIC 350
#define IDS_PASSWORD_LEN                351
#define IDC_ANALYZED_COMPUTER_SETTING_STATIC 351
#define IDS_PASSWORD_REMEMBER           352
#define IDC_REGISTRY_STATIC             352
#define IDS_LOCKOUT_AFTER               353
#define IDC_SELECT_TO_SAVE_STATIC       353
#define IDS_DURATION                    354
#define IDC_LAST_INSPECTED_STATICSTATIC 354
#define IDS_OVERWRITE_EVENT             355
#define IDC_ASSIGNED_TO_STATIC          355
#define IDS_PASSWORD_FOREVER            356
#define IDC_CONFIGURATION_SETTING_STATIC 356
#define IDS_LOCKOUT_FOREVER             357
#define IDC_ANALYZED_SETTING_STATIC     357
#define IDS_NEW_TEMPLATE_NAME           358
#define IDC_SERVICE_STARTUP_MODE_STATIC 358
#define IDS_CLEAR_PASSWORD              359
#define IDC_TEMPLATE_SETTING_STATIC     359
#define IDS_KERBEROS_CATEGORY           360
#define IDC_ERROR_LOG_PROFILE_PATH_STATIC 360
#define IDS_KERBEROS_VALIDATE_CLIENT    361
#define IDC_DESCRIPTION_STATIC          361
#define IDS_KERBEROS_MAX_CLOCK          362
#define IDC_TEMPLATE_NAME_STATIC        362
#define IDS_KERBEROS_MAX_SERVICE        363
#define IDC_EFFECTIVE_POLICY_SETTING_STATIC 363
#define IDS_KERBEROS_MAX_AGE            364
#define IDC_CHANGE_LOCAL_POLICY_TO_STATIC 364
#define IDS_KERBEROS_RENEWAL            365
#define IDC_LOCAL_POLICY_STATIC         365
#define IDS_ADDMEMBER                   366
#define IDC_EFFECTIVE_POLICY_STATIC     366
#define IDC_CHANGE_TEMPLATE_SETTINGS    367
#define IDS_KERBEROS_DESC               367
#define IDS_CANT_DISPLAY_ERROR_OOM      368
#define IDC_SELECTED_KEY                368
#define IDS_ERROR_GETTING_LAST_ANALYSIS 369
#define IDC_DEFINE_GROUP                369
#define IDS_ERROR_CANT_SAVE             370
#define IDC_STATIC_DESCRIPTION          370
#define IDS_QUERY_DELETE                371
#define IDC_LOCALPOLICY_LABEL           371
#define IDS_ANALYSIS_VIEWER_NAME        372
#define IDC_STATIC_LABEL                372
#define IDC_STATIC_DESCRIPTION2         372
#define IDS_MISMATCH                    373
#define IDC_LOCAL_STATIC                373
#define IDS_ASSIGN_CONFIGURATION        374
#define IDS_SET_DB                      375
#define IDS_CANT_OPEN_LOG_FILE          376
#define IDS_LOGFILE_PICKER_TITLE        377
#define IDS_DEFAULT_DB_EXTENSION        378
#define IDS_DB_FILTER                   379
#define IDC_RADIO1                      379
#define IDS_APPLY_CONFIGURATION         380
#define IDS_LOG_FILE_FOR_APPLY          381
#define IDC_SETTING                     381
#define IDS_SECURITY_MENU_ITEM          382
#define IDC_CONFIG                      382
#define IDS_SECURITY_MENU_ITEM_DESC     383
#define IDC_PREVENT                     383
#define IDS_CONFIGURATION_KEY           384
#define IDC_INHERIT                     384
#define IDS_SECURITY_MENU               385
#define IDS_ENV_VARS_REG_VALUE          386
#define IDC_NO_MEMBERS                  386
#define IDS_DEF_ENV_VARS                387
#define IDC_NO_MEMBER_OF                387
#define IDS_OPEN_DB                     388
#define IDS_NEW_DB                      389
#define IDC_CHECKBOX                    389
#define IDS_DESCRIBE                    390
#define IDC_MULTISZ                     390
#define IDS_NO_WRITE_ACCESS             391
#define IDC_PRECEDENCE_LIST             391
#define IDS_HELPFILE                    392
#define IDC_ERROR_ICON                  392
#define IDS_CONFIG_WARNING              393
#define IDC_ERROR_TEXT                  393
#define IDS_DB_ERR_OPEN1                394
#define IDC_SUCCESS_TEXT                394
#define IDS_ADD_FILE_FILTER             395
#define IDC_WARNING_ICON                395
#define IDS_SAM_NAME                    396
#define IDC_RANGEERROR                  396
#define IDS_DBERR_OTHER_ERROR           397
#define IDS_DBERR_INVALID_DATA          398
#define IDS_DBERR_PROFILE_NOT_FOUND     399
#define IDS_DBERR_BAD_FORMAT            400
#define IDS_DBERR_NOT_ENOUGH_RESOURCE   401
#define IDS_DBERR_ACCESS_DENIED         402
#define IDS_DB_DEFAULT                  403
#define IDS_PROFILE_DIRTY_SAVE          404
#define IDS_IMPORT_EXISTS               405
#define IDS_ALL_SELECTED_FILES          406
#define IDS_DENY_LOGON_LOCALLY          407
#define IDS_DENY_LOGON_NETWORK          408
#define IDS_DENY_LOGON_SERVICE          409
#define IDS_DENY_LOGON_BATCH            410
#define IDS_ADDGROUP_TITLE              411
#define IDS_ADDGROUP_GROUP              412
#define IDS_NOT_ANALYZED                413
#define IDS_ERROR_VALUE                 414
#define IDS_NOT_DEFINED                 415
#define IDS_SUGGESTSETTING              416
#define IDS_EXPORT_LOCAL                417
#define IDS_EXPORT_EFFECTIVE            418
#define IDS_HTML_OPENDATABASE           419
#define IDS_HTMLERR_HEADER              420
#define IDS_HTMLERR_END                 421
#define IDS_DBERR5_PROFILE_NOT_FOUND    422
#define IDS_LCERR5_NOTFOUND_RESOLVE     423
#define IDS_DBERR5_ACCESS_DENIED        424
#define IDS_VIEW_LOGFILE                425
#define IDS_DBERR5_NO_ANALYSIS          426
#define IDS_BAD_LOCATION                427
#define IDS_BASE_TEMPLATE               428
#define IDS_POLICY_SETTING              429
#define IDS_SECURE_WIZARD               430
#define IDS_IMPORT_POLICY_INVALID       431
#define IDS_ENABLE_ADMIN                432
#define IDS_ENABLE_GUEST                433
#define IDS_SECURITY_PROPERTIES         434  
#define IDS_EMPTY_NAME_STRING           435
#define IDS_NO_MIN                      436
#define IDS_INVALID_STRING              437
#define IDS_IMPORT_WARNING              57345
#define IDS_CONFIGURE_PROGRESS_TITLE    57346
#define IDS_OPEN_SYSTEM_DB              57347
#define IDS_OPEN_PRIVATE_DB             57348
#define IDS_NEW_DATABASE                57349
#define IDS_SYSTEM_DB_NAME_FMT          57350
#define IDS_PRIVATE_DB_NAME_FMT         57351
#define IDS_ERROR_ANALYSIS_LOCKED       57352
#define IDS_IMPORT_FAILED               57353
#define IDS_CHILDREN_CONFIGURED         57354
#define IDS_NOT_AVAILABLE               57355
#define IDS_NEW_SERVICE                 57356
#define IDS_CONFIGURE_PROGRESS_VERB     57357
#define IDS_ADD_FILES_AND_FOLDERS       57358
#define IDS_ADDFILESANDFOLDERS_TITLE    57359
#define IDS_FILEFOLDER_BROWSE_TITLE     57360
#define IDS_SNAPINABOUT_PROVIDER        57361
#define IDS_SNAPINABOUT_VERSION         57362
#define IDS_SCEABOUT_DESCRIPTION        57363
#define IDS_SCMABOUT_DESCRIPTION        57364
#define IDS_SSABOUT_DESCRIPTION         57365
#define IDS_IMPORT_POLICY               57366
#define IDS_EXPORT_POLICY               57367
#define IDS_FILE_EXISTS_FMT             57368
#define IDS_SUCCESS                     57369
#define IDS_FAILURE                     57370
#define IDS_DO_NOT_AUDIT                57371
#define IDS_ERROR_REFRESH_POLICY_FAILED 57372
#define IDS_COPY_FAILED                 57373
#define IDS_ADD_FILES_OFN_TITLE         57374
#define IDS_OPEN_DB_OFN_TITLE           57375
#define IDS_NEW_DB_OFN_TITLE            57376
#define IDS_EXPORT_POLICY_OFN_TITLE     57377
#define IDS_IMPORT_POLICY_OFN_TITLE     57378
#define IDS_LOGFILE_OFN_TITLE           57379
#define IDS_ASSIGN_CONFIG_OFN_TITLE     57380
#define IDS_EXPORT_CONFIG_OFN_TITLE     57381
#define IDS_LOCAL_POLICY_COLUMN         57382
#define IDS_EFFECTIVE_POLICY_COLUMN     57383
#define IDS_ERROR_NO_LOCAL_POLICY_INFO  57384
#define IDS_LOCAL_POLICY_FRIENDLY_NAME  57385
#define IDS_CANT_OPEN_SYSTEM_DB         57386
#define IDS_HELPFILE_SCE                57387
#define IDS_HELPFILE_SAV                57388
#define IDS_HELPFILE_EXTENSION          57389
#define IDS_HTMLHELP_SCE_TOPIC          57390
#define IDS_HTMLHELP_SCM_TOPIC          57391
#define IDS_HTMLHELP_POLICY_TOPIC       57392
#define IDS_REG_CHOICE_FIELD_FORMAT     57393
#define IDS_EFFPOL_UPDATED              57394
#define IDS_ANALTIMESTAMP               57395
#define IDS_DBERR_NO_TEMPLATE_GIVEN     57396
#define IDS_REGISTRY_APPLY              57397
#define IDS_REGISTRY_INHERIT            57398
#define IDS_REGISTRY_PREVENT            57399
#define IDS_GROUP_TITLE                 57400
#define IDS_TICKET_EXPIRE               57401
#define IDS_TICKET_FOREVER              57402
#define IDS_TICKET_RENEWAL_EXPIRE       57403
#define IDS_TICKET_RENEWAL_FOREVER      57404
#define IDS_MAX_TOLERANCE               57405
#define IDS_NO_MAX_TOLERANCE            57406
#define IDS_NOT_APPLICABLE              57407
#define IDS_NO_MEMBERS                  57408
#define IDS_NO_MEMBER_OF                57409
#define IDS_ADD_USERGROUP               57410
#define IDS_ADD_TITLE                   57411
#define IDS_RNH_AUTODISCONNECT_SPECIAL  57412
#define IDS_RNH_AUTODISCONNECT_STATIC   57413
#define IDS_RNH_CACHED_LOGONS_SPECIAL   57414
#define IDS_RNH_CACHED_LOGONS_STATIC    57415
#define IDS_RNH_PASSWORD_WARNINGS_STATIC 57416
#define IDS_RNH_PASSWORD_WARNINGS_SPECIAL 57417
#define IDS_REGISTRY_CONFIGURE          57418
#define IDS_ERR_GLOBAL_LOC_DESC         57419
#define IDS_ERR_LOCAL_LOC_DESC          57420
#define IDS_REFRESH_TEMPLATE            57421
#define IDS_SAVE_P                      57422
#define IDS_LOCAL_SECURITY_NAME         57423
#define IDS_SS_DESC                     57424
#define IDS_LS_DESC                     57425
#define IDS_HTMLHELP_LS_TOPIC           57426
#define IDS_HELPFILE_LS                 57427
#define IDS_LSABOUT_DESCRIPTION         57428
#define IDS_HELPFILE_RSOP               57429
#define IDS_RSOP_DESC                   57430
#define IDS_RSOPABOUT_DESCRIPTION       57431
#define IDS_HTMLHELP_RSOP_TOPIC         57432
#define IDS_TABNAME                     57433
#define IDS_CANCEL                      57434
#define IDS_APPLY                       57435
#define IDS_ADMIN_NO_GPO                57436
#define IDS_NON_ADMIN_NO_GPO            57437
#define IDS_VIEW_LOGFILE_TITLE          57438
#define IDS_PRECEDENCE_GPO_HEADER       57439
#define IDS_PRECEDENCE_VALUE_HEADER     57440
#define IDS_PRECEDENCE_SUCCESS          57441
#define IDS_PRECEDENCE_CHILD_ERROR      57442
#define IDS_PRECEDENCE_ERROR            57443
#define IDS_PRECEDENCE_INVALID          57444
#define IDS_PRECEDENCE_NO_CONFIG        57445
#define IDS_VIEW_SECURITY               57446
#define IDS_EXPORT_FAILED               57447
#define IDS_SAVE_DATABASE               57448
#define IDS_DENY_REMOTE_INTERACTIVE_LOGON 57449
#define IDS_REMOTE_INTERACTIVE_LOGON    57450
#define IDS_ADD_LOC_FAILED              57451
#define IDS_DEFAULT_LOCATION            57452
#define IDS_LOGFILE_DEFAULT             57453
#define IDS_ERROR_NOT_ON_PDC            57454
#define IDS_PRIV_WARNING                57455
#define IDS_CLOSE_PAGES                 57456
#define IDS_RANGE                       57457
#define IDS_LSA_ANON_LOOKUP             57458
#define IDS_PRIV_WARNING_LOCAL_LOGON    57459
#define IDS_PRIV_WARNING_DENYLOCAL_LOGON 57460
#define IDS_PRIV_WARNING_ACCOUNT_TRANSLATION  57461
#define IDS_CLOSESUBSHEET_BEFORE_APPLY  57462
#define IDS_FAIL_CREATE_UITHREAD        57463
#define IDS_HTMLHELP_LPPOLICY_TOPIC     57464
#define IDS_WHAT_ISTHIS                 57465
#define IDS_TEMP_FILENAME               57466
#define IDS_HELPFILE_LOCAL_EXTENSION    57467

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        438
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         397
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\regvldlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regvldlg.h
//
//  Contents:   definition of CSceRegistryValueInfo
//                              CConfigRegEnable
//                              CAttrRegEnable
//                              CLocalPolRegEnable
//                              CConfigRegNumber
//                              CAttrRegNumber
//                              CLocalPolRegNumber
//                              CConfigRegString
//                              CAttrRegString
//                              CLocalPolRegString
//                              CConfigRegChoice
//                              CAttrRegChoice
//                              CLocalPolRegChoice
//
//----------------------------------------------------------------------------
#if !defined(AFX_REGVLDLG_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_REGVLDLG_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "cenable.h"
#include "aenable.h"
#include "lenable.h"
#include "cnumber.h"
#include "anumber.h"
#include "lnumber.h"
#include "cname.h"
#include "astring.h"
#include "lstring.h"
#include "cret.h"
#include "aret.h"
#include "lret.h"


//
// Class to encapsulate the SCE_REGISTRY_VALUE_INFO structure.
class CSceRegistryValueInfo
{
public:
   CSceRegistryValueInfo(
      PSCE_REGISTRY_VALUE_INFO pInfo
      );
   BOOL Attach(
      PSCE_REGISTRY_VALUE_INFO pInfo
      )
      { if(pInfo) {m_pRegInfo = pInfo; return TRUE;} return FALSE; };


   DWORD
   GetBoolValue();               // Returns a boolean type.


   DWORD
   SetBoolValue(              // Sets the boolean value.
      DWORD dwVal
      );

   LPCTSTR
   GetValue()                 // Returns the string pointer of the value
      { return ((m_pRegInfo && m_pRegInfo->Value) ? m_pRegInfo->Value:NULL); };

   DWORD
   GetType()                  // Returns the type reg type of the object.
      { return (m_pRegInfo ? m_pRegInfo->ValueType:0); };

   void
   SetType(DWORD dwType)         // Sets the type of this object.
      { if(m_pRegInfo) m_pRegInfo->ValueType = dwType; };

   LPCTSTR
   GetName()                  // Returns the name of this object.
      { return (m_pRegInfo ? m_pRegInfo->FullValueName:NULL); };

   DWORD
   GetStatus()                // Return status member of this object.
      { return (m_pRegInfo ? m_pRegInfo->Status:ERROR_INVALID_PARAMETER); };
protected:
   PSCE_REGISTRY_VALUE_INFO m_pRegInfo;

};



#define SCE_RETAIN_ALWAYS     0
#define SCE_RETAIN_AS_REQUEST 1
#define SCE_RETAIN_NC         2

/////////////////////////////////////////////////////////////////////////////
// CConfigEnable dialog

class CConfigRegEnable : public CConfigEnable
{
// Construction
public:
   CConfigRegEnable (UINT nTemplateID) :
      CConfigEnable (nTemplateID ? nTemplateID : IDD)
      {
      }
// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRegEnable)
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual BOOL UpdateProfile(  );

public:
    virtual void Initialize(CResult *pdata);

};

class CAttrRegEnable : public CAttrEnable
{
// Construction
public:
   CAttrRegEnable () : CAttrEnable (IDD)
   {
   }
    virtual void Initialize(CResult *pResult);
    virtual void UpdateProfile( DWORD dwStatus );

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRegEnable)
    virtual BOOL OnApply();
    //}}AFX_MSG
};


class CLocalPolRegEnable : public CConfigRegEnable
{
// Construction
public:

   enum { IDD = IDD_LOCALPOL_ENABLE };
   CLocalPolRegEnable() : CConfigRegEnable(IDD)
   {
       m_pHelpIDs = (DWORD_PTR)a227HelpIDs;
       m_uTemplateResID = IDD;
   }
   virtual void Initialize(CResult *pResult);
   virtual BOOL UpdateProfile(  );
};

/////////////////////////////////////////////////////////////////////////////
// CConfigRegNumber dialog

class CConfigRegNumber : public CConfigNumber
{
// Construction
public:
   CConfigRegNumber(UINT nTemplateID);
   // Generated message map functions
   //{{AFX_MSG(CConfigRegNumber)
   virtual BOOL OnApply();
   //}}AFX_MSG
   virtual void UpdateProfile();

public:
   virtual void Initialize(CResult *pResult);
};


/////////////////////////////////////////////////////////////////////////////
// CAttrRegNumber dialog

class CAttrRegNumber : public CAttrNumber
{
// Construction
public:
   CAttrRegNumber();
   virtual void UpdateProfile( DWORD status );
   virtual void Initialize(CResult * pResult);

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRegNumber)
    virtual BOOL OnApply();
    //}}AFX_MSG
};


/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegNumber dialog

class CLocalPolRegNumber : public CConfigRegNumber
{
// Construction
public:
        enum { IDD = IDD_LOCALPOL_NUMBER };
   CLocalPolRegNumber();
   virtual void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
   virtual void UpdateProfile();


private:
   BOOL m_bInitialValueSet;
};


/////////////////////////////////////////////////////////////////////////////
// CConfigRegString dialog

class CConfigRegString : public CConfigName
{
// Construction
public:
   CConfigRegString (UINT nTemplateID) :
      CConfigName (nTemplateID ? nTemplateID : IDD)
      {
      }

      virtual void Initialize(CResult * pResult);
// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRegString)
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual BOOL UpdateProfile( );
    virtual BOOL QueryMultiSZ() { return FALSE; }
};


/////////////////////////////////////////////////////////////////////////////
// CAttrString dialog

class CAttrRegString : public CAttrString
{
// Construction
public:
   CAttrRegString (UINT nTemplateID) :
      CAttrString (nTemplateID ? nTemplateID : IDD)
      {
      }
   virtual void Initialize(CResult * pResult);
   virtual void UpdateProfile( DWORD status );

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRegString)
        // NOTE: the ClassWizard will add member functions here
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual BOOL QueryMultiSZ() { return FALSE; }
};


/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegString dialog

class CLocalPolRegString : public CConfigRegString
{
public:
        enum { IDD = IDD_LOCALPOL_STRING };
   CLocalPolRegString(UINT nTemplateID) : 
        CConfigRegString(nTemplateID ? nTemplateID : IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL UpdateProfile(  );
   virtual void Initialize(CResult *pResult);


// Implementation
protected:
};


/////////////////////////////////////////////////////////////////////////////
// CConfigRet dialog

class CConfigRegChoice : public CConfigRet
{
// Construction
public:
   CConfigRegChoice (UINT nTemplateID) :
      CConfigRet (nTemplateID ? nTemplateID : IDD)
      {
      }
    void Initialize(CResult * pResult);

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRegChoice)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual void UpdateProfile( DWORD status );
};


/////////////////////////////////////////////////////////////////////////////
// CAttrRegChoice dialog

class CAttrRegChoice : public CAttrRet
{
// construction
public:
    virtual void Initialize(CResult * pResult);
    virtual void UpdateProfile( DWORD status );

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAttrRegChoice)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    //}}AFX_MSG
};

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegChoice dialog

class CLocalPolRegChoice : public CConfigRegChoice
{
   enum { IDD = IDD_LOCALPOL_REGCHOICES };
// construction
public:
    CLocalPolRegChoice(UINT nTemplateID) : 
      CConfigRegChoice(nTemplateID ? nTemplateID : IDD)
    {
        m_uTemplateResID = IDD;
    }
   virtual void UpdateProfile( DWORD status );
   virtual void Initialize(CResult *pResult);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGVLDLG_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\savetemp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       SaveTemp.h
//
//  Contents:   definition of CSaveTemplates
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAVETEMP_H__E6815F79_0579_11D1_9C70_00C04FB6C6FA__INCLUDED_)
#define AFX_SAVETEMP_H__E6815F79_0579_11D1_9C70_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSaveTemplates dialog

class CSaveTemplates : public CHelpDialog
{
// Construction
public:
	void AddTemplate(LPCTSTR szInfFile,PEDITTEMPLATE pet);

	CSaveTemplates(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSaveTemplates)
	enum { IDD = IDD_SAVE_TEMPLATES };
	CButton	m_btnSaveSel;
	CListBox	m_lbTemplates;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSaveTemplates)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSaveTemplates)
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnSaveSel();
	afx_msg void OnSelchangeTemplateList();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   CMap<CString, LPCTSTR, PEDITTEMPLATE, PEDITTEMPLATE&> m_Templates;
private:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAVETEMP_H__E6815F79_0579_11D1_9C70_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\selfdeletingpropertypage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       SelfDeletingPropertyPage.h
//
//--------------------------------------------------------------------------
#ifndef __SELFDELETINGPROPERTYPAGE_H
#define __SELFDELETINGPROPERTYPAGE_H

class CSelfDeletingPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CSelfDeletingPropertyPage)

public:
    CSelfDeletingPropertyPage ();
    CSelfDeletingPropertyPage (UINT nIDTemplate, UINT nIDCaption = 0);
    CSelfDeletingPropertyPage (LPCTSTR lpszTemplateName, UINT nIDCaption = 0);
	virtual ~CSelfDeletingPropertyPage ();

private:
    static UINT CALLBACK PropSheetPageProc(
        HWND hwnd,	
        UINT uMsg,	
        LPPROPSHEETPAGE ppsp);

    // hook up the callback for C++ object destruction
    LPFNPSPCALLBACK m_pfnOldPropCallback;
};

#endif // __SELFDELETINGPROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\selfdeletingpropertypage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       SelfDeletingPropertyPage.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "SelfDeletingPropertyPage.h"

IMPLEMENT_DYNCREATE(CSelfDeletingPropertyPage, CPropertyPage)

CSelfDeletingPropertyPage::CSelfDeletingPropertyPage () 
    : CPropertyPage ()
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}

CSelfDeletingPropertyPage::CSelfDeletingPropertyPage (UINT nIDTemplate, UINT nIDCaption) 
    : CPropertyPage (nIDTemplate, nIDCaption)
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}

CSelfDeletingPropertyPage::CSelfDeletingPropertyPage (LPCTSTR lpszTemplateName, UINT nIDCaption)
    : CPropertyPage (lpszTemplateName, nIDCaption)
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}

CSelfDeletingPropertyPage::~CSelfDeletingPropertyPage ()
{
}

UINT CALLBACK CSelfDeletingPropertyPage::PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp)
{
    CSelfDeletingPropertyPage* pPage = (CSelfDeletingPropertyPage*)(ppsp->lParam);
    ASSERT(pPage != NULL);

    UINT nResult = (*(pPage->m_pfnOldPropCallback))(hwnd, uMsg, ppsp);
    if (uMsg == PSPCB_RELEASE)
    {
        delete pPage;
    }
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\servperm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       servperm.cpp
//
//  Contents:   implementation of CSecurityInfo
//
//----------------------------------------------------------------------------
#include "stdafx.h"

extern "C"
{
    #include <seopaque.h>   // RtlObjectAceSid, etc.
}
#include "resource.h"
#include "initguid.h"
#include "ServPerm.h"
#include "util.h"
#include "uithread.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//extern "C"
//STDAPI
//DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
//                            LPCWSTR pwszObjectClass,
//                            DWORD dwFlags,
//                            LPSECURITYINFO *ppSI,
//                            PFNREADOBJECTSECURITY pfnReadSD,
//                            PFNWRITEOBJECTSECURITY pfnWriteSD,
//                            LPARAM lpContext);
//

/*
HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
*/
static HINSTANCE        g_hAclUiDll = NULL;
typedef HPROPSHEETPAGE  (WINAPI *PFNCSECPAGE)(LPSECURITYINFO);

#ifndef PERM_HEADER_DEFINED
#define PERM_HEADER_DEFINED

#define INHERIT_FULL        (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//For ntfs
//
// Treat SYNCHRONIZE specially. In particular, always allow SYNCHRONIZE and
// never Deny SYNCHRONIZE. Do this by removing it from the Generic Mapping,
// turning it off in all ACEs and SI_ACCESS entries, and then adding it to
// all Allow ACEs before saving a new ACL.
//Keep this in sync with ISecurityInfromation impl for FileSystem
#define FILE_GENERIC_READ_      (FILE_GENERIC_READ    & ~SYNCHRONIZE)
#define FILE_GENERIC_WRITE_     (FILE_GENERIC_WRITE   & ~(SYNCHRONIZE | READ_CONTROL))
#define FILE_GENERIC_EXECUTE_   (FILE_GENERIC_EXECUTE & ~SYNCHRONIZE)
#define FILE_GENERIC_ALL_       (FILE_ALL_ACCESS      & ~SYNCHRONIZE)

#define FILE_GENERAL_MODIFY     (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_ | DELETE)
#define FILE_GENERAL_PUBLISH    (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_DEPOSIT    (FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_READ_EX    (FILE_GENERIC_READ_  | FILE_GENERIC_EXECUTE_)



#define iFileDefAccess      2   // FILE_GEN_READ
#define iKeyDefAccess       2   // KEY_READ

#endif

#include <initguid.h>
DEFINE_GUID(GUID_A_NT_GROUP_MEMBERS,  0xbf9679df,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2);
//
// define all access rights for files on general page and/or specific page
//
static SI_ACCESS siFileAccesses[] =
{
    { &GUID_NULL, FILE_GENERIC_ALL_,        MAKEINTRESOURCE(IDS_FILE_GEN_ALL),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_MODIFY,      MAKEINTRESOURCE(IDS_FILE_GEN_MODIFY),       SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX,     MAKEINTRESOURCE(IDS_FILE_GEN_READ),         SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX,     MAKEINTRESOURCE(IDS_FILE_GEN_LIST),         SI_ACCESS_CONTAINER | CONTAINER_INHERIT_ACE },
    { &GUID_NULL, FILE_GENERIC_READ_,       MAKEINTRESOURCE(IDS_FILE_GENERIC_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERIC_WRITE_,      MAKEINTRESOURCE(IDS_FILE_GENERIC_WRITE),    SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_EXECUTE,             MAKEINTRESOURCE(IDS_FILE_SPEC_EXECUTE),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_DATA,           MAKEINTRESOURCE(IDS_FILE_SPEC_READ_DATA),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_ATTRIBUTES,     MAKEINTRESOURCE(IDS_FILE_SPEC_READ_ATTR),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_EA,             MAKEINTRESOURCE(IDS_FILE_SPEC_READ_EA),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_DATA,          MAKEINTRESOURCE(IDS_FILE_SPEC_WRITE_DATA),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_APPEND_DATA,         MAKEINTRESOURCE(IDS_FILE_SPEC_APPEND_DATA), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_ATTRIBUTES,    MAKEINTRESOURCE(IDS_FILE_SPEC_WRITE_ATTR),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_EA,            MAKEINTRESOURCE(IDS_FILE_SPEC_WRITE_EA),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_DELETE_CHILD,        MAKEINTRESOURCE(IDS_FILE_SPEC_DELETE_CHILD),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,                   MAKEINTRESOURCE(IDS_STD_DELETE),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_STD_READ_CONTROL),      SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_STD_WRITE_DAC),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),       SI_ACCESS_SPECIFIC },
//    { &GUID_NULL, SYNCHRONIZE,            MAKEINTRESOURCE(IDS_STD_SYNCHRONIZE),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                        MAKEINTRESOURCE(IDS_NONE),                  0 },
    { &GUID_NULL, FILE_GENERIC_EXECUTE_,    MAKEINTRESOURCE(IDS_FILE_GENERIC_EXECUTE),  0 },
    { &GUID_NULL, FILE_GENERAL_DEPOSIT,     MAKEINTRESOURCE(IDS_FILE_GENERAL_DEPOSIT),  0 },
    { &GUID_NULL, FILE_GENERAL_PUBLISH,     MAKEINTRESOURCE(IDS_FILE_GENERAL_PUBLISH),  0 },
};
//
// define all access rights for keys on general page and/or specific page
//
static SI_ACCESS siKeyAccesses[] =
{
   { &GUID_NULL, KEY_ALL_ACCESS,     MAKEINTRESOURCE(IDS_KEY_ALL_ACCESS),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE},
   { &GUID_NULL, KEY_READ,           MAKEINTRESOURCE(IDS_KEY_READ),                 SI_ACCESS_GENERAL | CONTAINER_INHERIT_ACE},   
   { &GUID_NULL, KEY_QUERY_VALUE,    MAKEINTRESOURCE(IDS_KEY_QUERY_VALUE),          SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_SET_VALUE,      MAKEINTRESOURCE(IDS_KEY_SET_VALUE),            SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_CREATE_SUB_KEY, MAKEINTRESOURCE(IDS_KEY_CREATE_SUB_KEY),       SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_ENUMERATE_SUB_KEYS,MAKEINTRESOURCE(IDS_KEY_ENUMERATE_SUB_KEYS),SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_NOTIFY,         MAKEINTRESOURCE(IDS_KEY_NOTIFY),               SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_CREATE_LINK,    MAKEINTRESOURCE(IDS_KEY_CREATE_LINK),          SI_ACCESS_SPECIFIC},
   { &GUID_NULL, DELETE,             MAKEINTRESOURCE(IDS_STD_DELETE),               SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE},
   { &GUID_NULL, READ_CONTROL,       MAKEINTRESOURCE(IDS_STD_READ_CONTROL),         SI_ACCESS_SPECIFIC },
   { &GUID_NULL, WRITE_DAC,          MAKEINTRESOURCE(IDS_STD_WRITE_DAC),            SI_ACCESS_SPECIFIC },
   { &GUID_NULL, WRITE_OWNER,        MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),          SI_ACCESS_SPECIFIC },
   { &GUID_NULL, 0,                  MAKEINTRESOURCE(IDS_NONE),                     0}
};
//
// define generic mapping for files
// This is consistent with the NETUI code
//
static GENERIC_MAPPING FileMap =
{
    FILE_GENERIC_READ_,
    FILE_GENERIC_WRITE_,
    FILE_GENERIC_EXECUTE_,
    FILE_GENERIC_ALL_
};
//
// define generic mapping for keys
//
static GENERIC_MAPPING KeyMap =
{
//    STANDARD_RIGHTS_READ     | 0x1,
//    STANDARD_RIGHTS_WRITE    | 0x2,
//    STANDARD_RIGHTS_EXECUTE  | 0x4,
//    STANDARD_RIGHTS_REQUIRED | 0x7F
    KEY_READ,
    KEY_WRITE,
    KEY_EXECUTE,
    KEY_ALL_ACCESS
};
//
// The following array defines the inheritance types for NTFS.
//
static SI_INHERIT_TYPE siFileInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_FILE_FOLDER),
    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_FILE_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_FILE_FOLDER_SUBFOLDER),
    &GUID_NULL, OBJECT_INHERIT_ACE,                                            MAKEINTRESOURCE(IDS_FILE_FOLDER_FILE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_FILE_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_FILE_SUBFOLDER_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,                         MAKEINTRESOURCE(IDS_FILE_FILE_ONLY)
};
//
// The following array defines the inheritance types for Registry.
//
//
// For Keys, objects and containers are the same, so no need for OBJECT_INHERIT_ACE
//
static SI_INHERIT_TYPE siKeyInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_KEY_FOLDER),
//    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_KEY_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_KEY_FOLDER_SUBFOLDER),
//    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_KEY_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_KEY_SUBFOLDER_ONLY)
};
//
// constants for services
//
#define SERVICE_GENERIC_READ        (STANDARD_RIGHTS_READ |\
                                     SERVICE_QUERY_CONFIG |\
                                     SERVICE_QUERY_STATUS |\
                                     SERVICE_ENUMERATE_DEPENDENTS |\
                                     SERVICE_INTERROGATE |\
                                     SERVICE_USER_DEFINED_CONTROL)

#define SERVICE_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE |\
                                     SERVICE_START |\
                                     SERVICE_STOP |\
                                     SERVICE_PAUSE_CONTINUE)
//                                     SERVICE_INTERROGATE |\
//                                     SERVICE_USER_DEFINED_CONTROL)

#define SERVICE_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE |\
                                     SERVICE_CHANGE_CONFIG )
//
// access rights for services
//
static SI_ACCESS siServiceAccesses[] =
{
    { &GUID_NULL, SERVICE_ALL_ACCESS,        MAKEINTRESOURCE(IDS_SERVICE_ALL),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_GENERIC_READ,      MAKEINTRESOURCE(IDS_SERVICE_READ),         SI_ACCESS_GENERAL },
    { &GUID_NULL, SERVICE_GENERIC_EXECUTE,   MAKEINTRESOURCE(IDS_SERVICE_EXECUTE),      SI_ACCESS_GENERAL },
    { &GUID_NULL, SERVICE_GENERIC_WRITE,     MAKEINTRESOURCE(IDS_SERVICE_WRITE),        SI_ACCESS_GENERAL },
    { &GUID_NULL, SERVICE_QUERY_CONFIG,      MAKEINTRESOURCE(IDS_SERVICE_QUERY_CONFIG), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_CHANGE_CONFIG,     MAKEINTRESOURCE(IDS_SERVICE_CHANGE_CONFIG),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_QUERY_STATUS,      MAKEINTRESOURCE(IDS_SERVICE_QUERY_STATUS), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_ENUMERATE_DEPENDENTS,MAKEINTRESOURCE(IDS_SERVICE_ENUMERATE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_START,             MAKEINTRESOURCE(IDS_SERVICE_START),        SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_STOP,              MAKEINTRESOURCE(IDS_SERVICE_STOP),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_PAUSE_CONTINUE,    MAKEINTRESOURCE(IDS_SERVICE_PAUSE),        SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_INTERROGATE,       MAKEINTRESOURCE(IDS_SERVICE_INTERROGATE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_USER_DEFINED_CONTROL,MAKEINTRESOURCE(IDS_SERVICE_USER_CONTROL),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,               MAKEINTRESOURCE(IDS_STD_DELETE),            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,         MAKEINTRESOURCE(IDS_STD_READ_CONTROL),      SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,            MAKEINTRESOURCE(IDS_STD_WRITE_DAC),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,          MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                    MAKEINTRESOURCE(IDS_NONE),                  0 },
};
#define iServiceDefAccess   2   // SERVICE_GEN_EXECUTE
//
// generic mapping for services
//
static GENERIC_MAPPING ServiceMap =
{
    SERVICE_GENERIC_READ,
    SERVICE_GENERIC_WRITE,
    SERVICE_GENERIC_EXECUTE,
    SERVICE_ALL_ACCESS
};

/*
// No need to define inherit type for service because there is no subfolders/items

#define DS_ACC_READ                 (STANDARD_RIGHTS_READ |\
                                     ACTRL_DS_LIST |\
                                     ACTRL_DS_READ_PROP )

#define DS_ACC_WRITE                (STANDARD_RIGHTS_WRITE    |\
                                     ACTRL_DS_WRITE_PROP |\
                                     ACTRL_DS_SELF)

#define DS_ACC_EXECUTE              (STANDARD_RIGHTS_EXECUTE  |\
                                     ACTRL_DS_LIST )

// generic all
#define DS_ACC_ALL                  ((STANDARD_RIGHTS_REQUIRED) |\
                                     (ACTRL_DS_CREATE_CHILD) |\
                                     (ACTRL_DS_DELETE_CHILD) |\
                                     (ACTRL_DS_READ_PROP) |\
                                     (ACTRL_DS_WRITE_PROP) |\
                                     (ACTRL_DS_LIST) |\
                                     (ACTRL_DS_SELF))

static SI_ACCESS siDsAccesses[] =
{
    { &GUID_NULL, DS_ACC_ALL,               MAKEINTRESOURCE(IDS_DS_ALL),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DS_ACC_READ,              MAKEINTRESOURCE(IDS_DS_READ),       SI_ACCESS_GENERAL },
    { &GUID_NULL, DS_ACC_WRITE,             MAKEINTRESOURCE(IDS_DS_WRITE),      SI_ACCESS_GENERAL },
    { &GUID_NULL, ACTRL_DS_LIST,            MAKEINTRESOURCE(IDS_DS_ACTRL_LIST),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_READ_PROP,       MAKEINTRESOURCE(IDS_DS_ACTRL_READ_PROP),    SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_NULL, ACTRL_DS_WRITE_PROP,      MAKEINTRESOURCE(IDS_DS_ACTRL_WRITE_PROP),   SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_A_NT_GROUP_MEMBERS,ACTRL_DS_SELF,MAKEINTRESOURCE(IDS_DS_ACTRL_SELF),        SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,                   MAKEINTRESOURCE(IDS_STD_DELETE),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_STD_READ_CONTROL),      SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_STD_WRITE_DAC),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_DS_ACTRL_CREATE),       SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_CHILD,    MAKEINTRESOURCE(IDS_DS_ACTRL_DELETE),       SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                        MAKEINTRESOURCE(IDS_NONE),                  0 },

};
#define iDsDefAccess   1   // DS_ACC_READ
#define iDSProperties  4   // Read/Write properties


//
// Standard DS generic access rights mapping
//
static GENERIC_MAPPING DsMap =
{
    DS_ACC_READ,
    DS_ACC_WRITE,
    DS_ACC_EXECUTE,
    DS_ACC_ALL
};

// The following array defines the inheritance types common to all DS containers.
SI_INHERIT_TYPE siDsInheritTypes[] =
{
    { &GUID_NULL, 0,                                        MAKEINTRESOURCE(IDS_DS_FOLDER)     },
    { &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_DS_FOLDER_SUBFOLDER) },
    { &GUID_NULL, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, MAKEINTRESOURCE(IDS_DS_SUBFOLDER_ONLY)      },
};
*/
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif


void CSecurityInfo::SetMachineName( LPCTSTR pszMachineName )
{
    if ( pszMachineName == NULL )
        m_strMachineName.Empty();
    else
        m_strMachineName = pszMachineName;
}

STDMETHODIMP
CSecurityInfo::GetAccessRights (
    IN const GUID* pguidObjectType,
    IN DWORD dwFlags,
    OUT PSI_ACCESS *ppAccess,
    OUT ULONG *pcAccesses,
    OUT ULONG *piDefaultAccess )
/*
Retrieve access rights array and the default element
*/
{
    ASSERT(ppAccess != NULL);
    ASSERT(pcAccesses != NULL);
    ASSERT(piDefaultAccess != NULL);

    if ( ppAccess == NULL || pcAccesses == NULL || piDefaultAccess == NULL ) {
        return E_FAIL;
    }

    switch (m_SeType ) {
    case SE_FILE_OBJECT:
        *ppAccess = siFileAccesses;
        *pcAccesses = ARRAYSIZE(siFileAccesses);
        *piDefaultAccess = iFileDefAccess;
        break;
    case SE_REGISTRY_KEY:
        *ppAccess = siKeyAccesses;
        *pcAccesses = ARRAYSIZE(siKeyAccesses);
        *piDefaultAccess = iKeyDefAccess;
        break;
    case SE_SERVICE:
        *ppAccess = siServiceAccesses;
        *pcAccesses = ARRAYSIZE(siServiceAccesses);
        *piDefaultAccess = iServiceDefAccess;
        break;
//    case SE_DS_OBJECT:
//        *ppAccess = siDsAccesses;
//        *pcAccesses = ARRAYSIZE(siDsAccesses);
//        *piDefaultAccess = iDsDefAccess;
        break;
    }
/*
    if (dwFlags & SI_EDIT_AUDITS) {
    } else {
    }
*/
    return S_OK;
}

STDMETHODIMP
CSecurityInfo::MapGeneric (
    IN const GUID *pguidObjectType,
    OUT UCHAR *pAceFlags,
    OUT ACCESS_MASK *pMask)
/*
Map generic rights to specific rights based on object type
*/
{
    ASSERT(pMask != NULL);

    if ( pMask == NULL ) {
        return E_FAIL;
    }

    switch(m_SeType) {
    case SE_FILE_OBJECT:
        MapGenericMask(pMask, &FileMap);
        *pMask = *pMask & (~SYNCHRONIZE); //Raid #340750, 4/12/2001
        break;
    case SE_REGISTRY_KEY:
        MapGenericMask(pMask, &KeyMap);
        break;
    case SE_SERVICE:
        MapGenericMask(pMask, &ServiceMap);
        break;
//    case SE_DS_OBJECT:
//        MapGenericMask(pMask, &DsMap);
        break;
    }

    return S_OK;
}

STDMETHODIMP
CSecurityInfo::GetInheritTypes (
    OUT PSI_INHERIT_TYPE *ppInheritTypes,
    OUT ULONG *pcInheritTypes )
/*
Retrieve inherit type array based on the object type
*/
{
    ASSERT(ppInheritTypes != NULL);
    ASSERT(pcInheritTypes != NULL);

    if ( !ppInheritTypes || !pcInheritTypes ) {
        return E_FAIL;
    }

    switch (m_SeType ) {
    case SE_FILE_OBJECT:
        *ppInheritTypes = siFileInheritTypes;
        *pcInheritTypes = ARRAYSIZE(siFileInheritTypes);
        break;
    case SE_REGISTRY_KEY:
        *ppInheritTypes = siKeyInheritTypes;
        *pcInheritTypes = ARRAYSIZE(siKeyInheritTypes);
        break;
//    case SE_DS_OBJECT:
//        *ppInheritTypes = siDsInheritTypes;
//        *pcInheritTypes = ARRAYSIZE(siDsInheritTypes);
//        break;
    case SE_SERVICE:
       *ppInheritTypes = NULL;
       *pcInheritTypes = NULL;

        break;
    }

    return S_OK;
}

STDMETHODIMP
CSecurityInfo::PropertySheetPageCallback(
    HWND hwnd,
    UINT uMsg,
    SI_PAGE_TYPE uPage )
{
    return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP
CSecurityInfo::GetObjectInformation (
    IN OUT PSI_OBJECT_INFO pObjectInfo )
/*
Retrieve information for the object to display
*/
{
    ASSERT(pObjectInfo != NULL &&
           !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    if ( pObjectInfo == NULL ) {
        return E_FAIL;
    }
    //
    // query the edit flag dwFlags
    //
    pObjectInfo->dwFlags = SI_ADVANCED;

    switch ( m_SeType ) {
    case SE_FILE_OBJECT:
//        if ( m_pData->GetID() &&
//             ((PSCE_OBJECT_SECURITY)(m_pData->GetID()))->IsContainer )
//            pObjectInfo->dwFlags |= SI_CONTAINER;
        if ( m_bIsContainer ) {
            pObjectInfo->dwFlags |= SI_CONTAINER;
        }

        break;

    case SE_SERVICE:
        break;
    default:
        pObjectInfo->dwFlags |= SI_CONTAINER;
        break;
    }

    switch ( m_flag ) {
    case SECURITY_PAGE_READ_ONLY:
    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
    case CONFIG_SECURITY_PAGE_READ_ONLY:
        pObjectInfo->dwFlags |= SI_READONLY;
        break;
    case SECURITY_PAGE_RO_NP:
    case CONFIG_SECURITY_PAGE_RO_NP:
    case ANALYSIS_SECURITY_PAGE_RO_NP:
        pObjectInfo->dwFlags |= (SI_READONLY | SI_NO_ACL_PROTECT);
        break;
    case CONFIG_SECURITY_PAGE_NO_PROTECT:
    case ANALYSIS_SECURITY_PAGE_NO_PROTECT:
    case SECURITY_PAGE_NO_PROTECT:
        if ( SE_SERVICE == m_SeType ) {
//           pObjectInfo->dwFlags |= (SI_EDIT_PERMS | SI_NO_ACL_PROTECT );
            pObjectInfo->dwFlags |= (SI_EDIT_PERMS | SI_EDIT_AUDITS | SI_NO_ACL_PROTECT );
        } else {
            pObjectInfo->dwFlags |= (SI_EDIT_ALL | SI_NO_ACL_PROTECT);
        }

        break;
    default:
        if ( SE_SERVICE == m_SeType ) {
            pObjectInfo->dwFlags |= (SI_EDIT_PERMS | SI_EDIT_AUDITS );
        } else {
            pObjectInfo->dwFlags |= SI_EDIT_ALL;
        }
    }

    pObjectInfo->hInstance = m_hInstance;
    pObjectInfo->pszServerName = QueryMachineName();
    pObjectInfo->pszObjectName = QueryObjectName();
    return S_OK;
}

STDMETHODIMP
CSecurityInfo::GetSecurity(
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    IN BOOL fDefault )
/*
Retrieve security descriptor for the requested security information to display
*/
{
    if (0 == RequestedInformation ) 
	{
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if (fDefault)
        return E_NOTIMPL;

    if ( NULL == ppSecurityDescriptor ) 
	{
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    // should also check for SeInfo
    if ( m_ppSD != NULL && *m_ppSD != NULL ) 
	{
		// Added check for SECURITY_PAGE_RO_NP (read-only) because it was
		// preventing viewing of security information in RSOP
         if ( m_pSeInfo && SECURITY_PAGE_RO_NP != m_flag &&
              ( 0 == (RequestedInformation & (*m_pSeInfo)) ) ) 
		 {
             *ppSecurityDescriptor = NULL;
         } 
		 else 
		 {
            if ( !IsValidSecurityDescriptor(*m_ppSD)) 
			{
               ASSERT(FALSE);
               return E_INVALIDARG;
            }

            MyMakeSelfRelativeSD(*m_ppSD,ppSecurityDescriptor);
         }

    } 
	else 
	{
        *ppSecurityDescriptor = NULL;
    }

    return S_OK;

}

void
FixSynchronizeAccess(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    if (NULL != pSD && 0 != (si & DACL_SECURITY_INFORMATION))
    {
        BOOL bPresent;
        BOOL bDefault;
        PACL pDacl = NULL;

        GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);

        if (pDacl)
        {
            PACE_HEADER pAce;
            int i;

            for (i = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
                 i < pDacl->AceCount;
                 i++, pAce = (PACE_HEADER)NextAce(pAce))
            {
                if (ACCESS_ALLOWED_ACE_TYPE == pAce->AceType)
                    ((PKNOWN_ACE)pAce)->Mask |= SYNCHRONIZE;
            }
        }
    }
}


STDMETHODIMP CSecurityInfo::SetSecurity (
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor )
/*
Save security descriptor for the SecurityInformation to your own storage

This method can be called multiple times for different security inforamtion.
Since SCE is saving the final security descriptor (combined) in m_ppSD,
this method must handle each component (Owner, Dacl, and Sacl) without overwritting
other components.
*/
{

   if ( pSecurityDescriptor == NULL || SecurityInformation == 0 )
      return S_OK;

   if ( m_flag == CONFIG_SECURITY_PAGE_READ_ONLY ||
        m_flag == ANALYSIS_SECURITY_PAGE_READ_ONLY ||
        m_flag == SECURITY_PAGE_READ_ONLY )
      return S_OK;

   if ( m_ppSD != NULL ) {
      //
      // only replace "SecurityInformation" part in m_ppSD
      //
      if ( m_pSeInfo && (SecurityInformation == *m_pSeInfo) ) {
         //
         // exactly same component
         //
         if ( *m_ppSD != NULL )
            LocalFree(*m_ppSD);

         MyMakeSelfRelativeSD(pSecurityDescriptor, m_ppSD);

      } else {

         SECURITY_INFORMATION TempSeInfo;
         SECURITY_DESCRIPTOR_CONTROL sdcControl = 0;

         if ( m_pSeInfo )
            TempSeInfo = (*m_pSeInfo) & ~SecurityInformation;
         else
            TempSeInfo = 0x0F & ~SecurityInformation;

         PSID pOwner=NULL, pOwnerNew=NULL;
         PACL pDacl=NULL, pDaclNew=NULL;
         PACL pSacl=NULL, pSaclNew=NULL;
         BOOL bDefault, bPresent;

         //
         // save the other components first
         //
         SECURITY_DESCRIPTOR_CONTROL sdc = 0;
         DWORD dwRevision = 0;
         if ( *m_ppSD ) {
            GetSecurityDescriptorControl( *m_ppSD, &sdc, &dwRevision );                
            if ( TempSeInfo & OWNER_SECURITY_INFORMATION ) {
               bDefault = FALSE;
               if ( !GetSecurityDescriptorOwner (
                                                *m_ppSD,
                                                &pOwner,
                                                &bDefault
                                                ) || bDefault )
                  pOwner = NULL;
               sdcControl |= (sdc & SE_OWNER_DEFAULTED);
            }
            if ( TempSeInfo & DACL_SECURITY_INFORMATION ) {
               bDefault = FALSE;
               bPresent = FALSE;

               if ( !GetSecurityDescriptorDacl (
                                               *m_ppSD,
                                               &bPresent,
                                               &pDacl,
                                               &bDefault
                                               ) || !bPresent || bDefault )
                  pDacl = NULL;
               sdcControl |= (sdc & (SE_DACL_AUTO_INHERIT_REQ | 
                                     SE_DACL_AUTO_INHERITED | 
                                     SE_DACL_PROTECTED
                                    ));
            }

            if ( TempSeInfo & SACL_SECURITY_INFORMATION ) {
               bDefault = FALSE;
               bPresent = FALSE;

               if ( !GetSecurityDescriptorSacl (
                                               *m_ppSD,
                                               &bPresent,
                                               &pSacl,
                                               &bDefault
                                               ) || !bPresent || bDefault )
                  pSacl = NULL;
               sdcControl |= (sdc & (SE_SACL_AUTO_INHERIT_REQ | 
                                     SE_SACL_AUTO_INHERITED | 
                                     SE_SACL_PROTECTED
                                    ));
            }
         }

         //
         // check the new components
         //
         sdc = 0;
         dwRevision = 0;
         GetSecurityDescriptorControl( pSecurityDescriptor, &sdc, &dwRevision );
         if ( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            bDefault = FALSE;
            if ( !GetSecurityDescriptorOwner (
                                             pSecurityDescriptor,
                                             &pOwnerNew,
                                             &bDefault
                                             ) || bDefault )
               pOwnerNew = NULL;
            pOwner = pOwnerNew;
            sdcControl |= (sdc & SE_OWNER_DEFAULTED);
         }
         if ( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            bDefault = FALSE;
            bPresent = FALSE;
            if ( !GetSecurityDescriptorDacl (
                                            pSecurityDescriptor,
                                            &bPresent,
                                            &pDaclNew,
                                            &bDefault
                                            ) || !bPresent || bDefault )
               pDaclNew = NULL;
            pDacl = pDaclNew;
            sdcControl |= (sdc & (SE_DACL_AUTO_INHERIT_REQ | 
                                  SE_DACL_AUTO_INHERITED | 
                                  SE_DACL_PROTECTED
                                 ));
         }

         if ( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            bDefault = FALSE;
            bPresent = FALSE;

            if ( !GetSecurityDescriptorSacl (
                                            pSecurityDescriptor,
                                            &bPresent,
                                            &pSaclNew,
                                            &bDefault
                                            ) || !bPresent || bDefault )
               pSaclNew = NULL;
            pSacl = pSaclNew;
            sdcControl |= (sdc & (SE_SACL_AUTO_INHERIT_REQ | 
                                  SE_SACL_AUTO_INHERITED | 
                                  SE_SACL_PROTECTED
                                 ));
         }

         if ( m_pSeInfo )
            *m_pSeInfo |= SecurityInformation;

         //
         // build a temp security descriptor
         //
         SECURITY_DESCRIPTOR sd;

         InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);

         if ( pOwner )
            SetSecurityDescriptorOwner (&sd, pOwner, FALSE);

         if ( pDacl )
            SetSecurityDescriptorDacl (&sd, TRUE, pDacl, FALSE);

         if ( pSacl )
            SetSecurityDescriptorSacl (&sd, TRUE, pSacl, FALSE);

         sd.Control |= sdcControl;
         //
         // re-create the final security descriptor
         //
         PSECURITY_DESCRIPTOR pTempSD=NULL;

         MyMakeSelfRelativeSD(&sd, &pTempSD);
         //
         // must free this after pTempSD is made, because sd is in absolute format
         //
         if ( *m_ppSD != NULL )
            LocalFree(*m_ppSD);

         *m_ppSD = pTempSD;
      }
         //Treat Synchronize Specially
         if( m_SeType == SE_FILE_OBJECT )
         {
            FixSynchronizeAccess(SecurityInformation,*m_ppSD);
         }            

   } else {
      return E_INVALIDARG;
   }
   return S_OK;
}

//
// original code from \\marsslm\backup\src\ncpmgr\ncpmgr\shareacl.cxx
// ACL-wrangling templated from \net\ui\common\src\lmobj\lmobj\security.cxx
//
// caller must free using "release"
//
HRESULT CSecurityInfo::NewDefaultDescriptor(
    PSECURITY_DESCRIPTOR* ppsd,
    SECURITY_INFORMATION RequestedInformation
    )
{
    *ppsd = NULL;
    PSID psidWorld = NULL;
    PSID psidAdmins = NULL;
    ACCESS_ALLOWED_ACE* pace = NULL;
    ACL* pacl = NULL;
    SECURITY_DESCRIPTOR sd;
    HRESULT hr = S_OK;
    do { // false loop
        // build World SID
        SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
        if ( !::AllocateAndInitializeSid(
            &IDAuthorityWorld,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &psidWorld ) )
        {
            ASSERT( FALSE );
            break;
        }

        // build Admins SID
        SID_IDENTIFIER_AUTHORITY IDAuthorityNT = SECURITY_NT_AUTHORITY;
        if ( !::AllocateAndInitializeSid(
            &IDAuthorityNT,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,0,0,0,0,0,
            &psidAdmins ) )
        {
            ASSERT( FALSE );
            break;
        }

        // build ACE
        DWORD cbSid = ::GetLengthSid(psidWorld);
        if ( 0 == cbSid )
        {
            ASSERT( FALSE );
            hr = E_UNEXPECTED;
            break;
        }
        INT cbAce = sizeof(ACCESS_ALLOWED_ACE) + cbSid;
        pace = reinterpret_cast<ACCESS_ALLOWED_ACE*>(new BYTE[ cbAce+10 ]);

        if ( pace ) {

            ::memset((BYTE*)pace,0,cbAce+10);
            pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;   // SetType()
            pace->Header.AceFlags = 0;                        // SetInheritFlags()
            pace->Header.AceSize = (WORD)cbAce;               // SetSize() (in SetSID())
            pace->Mask = GENERIC_ALL;                         // SetAccessMask()
            ::memcpy( &(pace->SidStart), psidWorld, cbSid );  // SetSID()
        } else {
            ASSERT ( FALSE );
            hr = E_OUTOFMEMORY;
            break;
        }

        // build ACL
        DWORD cbAcl = sizeof(ACL) + cbAce + 10;
        pacl = reinterpret_cast<ACL*>(new BYTE[ cbAcl ]);

        if ( pacl ) {

            ::memset((BYTE*)pacl,0,cbAcl);
            if ( !::InitializeAcl( pacl, cbAcl, ACL_REVISION2 ) )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }
            if ( !::AddAce( pacl, ACL_REVISION2, 0, pace, cbAce ) )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            // build security descriptor in absolute format
            if ( !::InitializeSecurityDescriptor(
                &sd,
                SECURITY_DESCRIPTOR_REVISION ) )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }
            if (   !::SetSecurityDescriptorOwner( &sd, psidAdmins, FALSE )
                || !::SetSecurityDescriptorGroup( &sd, psidAdmins, FALSE )
                || !::SetSecurityDescriptorDacl(  &sd, TRUE, pacl, FALSE )
               )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            // convert security descriptor to self-relative format
            DWORD cbSD = 0;
            // this call should fail and set cbSD to the correct size
            if ( ::MakeSelfRelativeSD( &sd, NULL, &cbSD ) || 0 == cbSD )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            *ppsd = reinterpret_cast<PSECURITY_DESCRIPTOR>(new BYTE[ cbSD + 20 ]);

            if ( *ppsd ) {

                ::memset( (BYTE*)*ppsd, 0, cbSD + 20 );
                if ( !::MakeSelfRelativeSD( &sd, *ppsd, &cbSD ) )
                {
                    ASSERT( FALSE );
                    hr = E_UNEXPECTED;
                    break;
                }
            } else {

                ASSERT ( FALSE );
                hr = E_OUTOFMEMORY;
                break;
            }
        } else {

            ASSERT ( FALSE );
            hr = E_OUTOFMEMORY;
            break;
        }

    } while (FALSE); // false loop

    // clean up
    if ( NULL != psidWorld ) {
        (void)::FreeSid( psidWorld );
    }
    if ( NULL != psidAdmins ) {
        (void)::FreeSid( psidAdmins );
    }

    if ( pace )
        delete pace;

    if ( pacl )
        delete pacl;

    if ( FAILED(hr) && *ppsd ) {
        delete *ppsd;
        *ppsd = NULL;
    }

    return hr;
}

void CSecurityInfo::Initialize(BOOL bIsContainer,  //CResult *pData,
                               PSECURITY_DESCRIPTOR *ppSeDescriptor,
                               SECURITY_INFORMATION *pSeInfo,
                               int flag)
{
//    m_pData = pData;
    m_bIsContainer = bIsContainer;
    m_ppSD = ppSeDescriptor;
    m_pSeInfo = pSeInfo;
    m_flag = flag;
}


STDMETHODIMP CDsSecInfo::GetSecurity(
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
    if ( NULL == ppSecurityDescriptor ) {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    *ppSecurityDescriptor = NULL;
    if (0 == RequestedInformation ) {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
   if (fDefault)
        return E_NOTIMPL;

   HRESULT hr = S_OK;
    if ( m_ppSD != NULL && *m_ppSD != NULL ) {

        if ( !IsValidSecurityDescriptor(*m_ppSD)) {
           ASSERT(FALSE);
            hr = E_INVALIDARG;
        }
        else
            hr = MyMakeSelfRelativeSD(*m_ppSD,ppSecurityDescriptor);
    } else {
        hr = E_UNEXPECTED;
    }

    return hr;

}

STDMETHODIMP CDsSecInfo::SetSecurity (
                        SECURITY_INFORMATION SecurityInformation,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{

    if ( pSecurityDescriptor == NULL || SecurityInformation == 0 )
        return S_OK;

    if ( m_flag == CONFIG_SECURITY_PAGE_READ_ONLY ||
         m_flag == ANALYSIS_SECURITY_PAGE_READ_ONLY ||
         m_flag == SECURITY_PAGE_READ_ONLY )
        return S_OK;

    HRESULT hr = S_OK;
    if ( m_ppSD != NULL ) {

        if ( *m_ppSD != NULL )
            LocalFree(*m_ppSD);

        hr = MyMakeSelfRelativeSD(pSecurityDescriptor, m_ppSD);
        if (SUCCEEDED(hr) && m_pSeInfo )
            *m_pSeInfo = SecurityInformation;

    } else {
        hr = E_INVALIDARG;
    }

    return hr;

}

HRESULT CDsSecInfo::Initialize(
                           LPTSTR LdapName,
                           PFNDSCREATEISECINFO pfnCreateDsPage,
                           PSECURITY_DESCRIPTOR *ppSeDescriptor,
                           SECURITY_INFORMATION *pSeInfo,
                           int flag)
{
    if ( !LdapName || !pfnCreateDsPage ) {
        return E_INVALIDARG;
    }

    m_ppSD = ppSeDescriptor;
    m_pSeInfo = pSeInfo;
    m_flag = flag;

    BOOL bReadOnly;

    switch (flag ) {
       case SECURITY_PAGE_RO_NP:
    case SECURITY_PAGE_READ_ONLY:
    case CONFIG_SECURITY_PAGE_READ_ONLY:
    case CONFIG_SECURITY_PAGE_RO_NP:
    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
    case ANALYSIS_SECURITY_PAGE_RO_NP:
        bReadOnly = TRUE;
        break;
    default:
        bReadOnly = FALSE;
        break;
    }

    HRESULT hr=(*pfnCreateDsPage)(
                            LdapName,  //ObjectName,
                            NULL,
                            bReadOnly,
                            &m_pISecInfo,
                            NULL,
                            NULL,
                            0);
    return hr;

}

//-----------------------------------------------------------------------
// this function creates a SCE editor property page. If a modeless
// property sheet is desired, make sure that the creation code originates
// from your own thread. Search for usage of the function for sample.
//-----------------------------------------------------------------------
INT_PTR
MyCreateSecurityPage2(BOOL bIsContainer, //CResult *pData,
                      PSECURITY_DESCRIPTOR *ppSeDescriptor,
                      SECURITY_INFORMATION *pSeInfo,
                      LPCTSTR ObjectName,
                      SE_OBJECT_TYPE SeType,
                      int flag,
                      HWND hwndParent,
                      BOOL bModeless)
{

    INT_PTR nRet=-1;
    HRESULT hr;

    if (!g_hAclUiDll) {
        g_hAclUiDll = LoadLibrary(TEXT("aclui.dll"));
    }

    if (!*ppSeDescriptor) {
       DWORD SDSize;

       if (SE_REGISTRY_KEY == SeType) {
          hr = GetDefaultRegKeySecurity(ppSeDescriptor,pSeInfo);
       } else {
          hr = GetDefaultFileSecurity(ppSeDescriptor,pSeInfo);
       }
       if (FAILED(hr))  // if access denied, return the invalid handle
           return nRet;
    }

    PFNCSECPAGE pfnCSecPage=NULL;
    if ( g_hAclUiDll) {
        pfnCSecPage = (PFNCSECPAGE)GetProcAddress(g_hAclUiDll,
                                                       "CreateSecurityPage");
        if ( pfnCSecPage ) {

            CComObject<CSecurityInfo>* psi = NULL;
            HPROPSHEETPAGE hPage=NULL;

            hr = CComObject<CSecurityInfo>::CreateInstance(&psi);

            if ( SUCCEEDED(hr) ) {
                psi->AddRef();

                psi->SetMachineName( NULL );
                psi->SetObjectName( ObjectName );
                psi->SetTypeInstance(SeType, AfxGetInstanceHandle() );

                psi->Initialize(bIsContainer, ppSeDescriptor, pSeInfo, flag);

                psi->AddRef();
                HPROPSHEETPAGE hPage = (*pfnCSecPage)((LPSECURITYINFO)psi); // in aclui.h
                psi->Release();

                if ( hPage ) {

                    // display this one
                    PROPSHEETHEADER psh;
                    HPROPSHEETPAGE hpsp[1];

                    hpsp[0] = hPage;

                    ZeroMemory(&psh,sizeof(psh));

                    psh.dwSize = sizeof(psh);
                    psh.dwFlags = PSH_DEFAULT;
                    if (bModeless) {
                       psh.dwFlags |= PSH_MODELESS;
                    }
                    psh.nPages = 1;
                    psh.phpage = hpsp;

                    CString str=_T("");

                    switch (flag) {

                    case CONFIG_SECURITY_PAGE_READ_ONLY:
                    case CONFIG_SECURITY_PAGE_NO_PROTECT:
                    case CONFIG_SECURITY_PAGE:
                    case CONFIG_SECURITY_PAGE_RO_NP:
                        str.LoadString(IDS_CONFIG_SECURITY_PAGE);
                        break;

                    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
                    case ANALYSIS_SECURITY_PAGE_NO_PROTECT:
                    case ANALYSIS_SECURITY_PAGE:
                    case ANALYSIS_SECURITY_PAGE_RO_NP:
                        str.LoadString(IDS_ANALYSIS_SECURITY_PAGE);
                        break;

                    default:
                        str.LoadString(IDS_SECURITY_PAGE);
                        break;
                    }

                    str+= ObjectName;
                    psh.pszCaption = (LPCTSTR)str;

                    psh.hwndParent = hwndParent;

                    if (bModeless) {
                       nRet = PropertySheet(&psh);

                    } else {
                       nRet = PropertySheet(&psh);
                       if (-1 == nRet) {
                          ErrorHandler();
                       }
                    }

                }
                psi->Release();
            }
        }
    }

    return nRet;
}


INT_PTR
MyCreateDsSecurityPage(
             LPDSSECINFO *ppSI,
             PFNDSCREATEISECINFO pfnCreateDsPage,
             PSECURITY_DESCRIPTOR *ppSeDescriptor,
             SECURITY_INFORMATION *pSeInfo,
             LPCTSTR ObjectName,
             int flag,
             HWND hwndParent)
{
    if ( !ObjectName || !ppSeDescriptor || !pfnCreateDsPage || !ppSI ) {
        // invalid parameter
        return -1;
    }

    INT_PTR nRet=-1;

    if (!g_hAclUiDll)
        g_hAclUiDll = LoadLibrary(TEXT("aclui.dll"));

    PFNCSECPAGE pfnCSecPage=NULL;
    if ( g_hAclUiDll) {
        pfnCSecPage = (PFNCSECPAGE)GetProcAddress(g_hAclUiDll,
                                                       "CreateSecurityPage");
        if ( pfnCSecPage ) {
            //
            // get the address of CreateSecurityPage
            //
            HRESULT hr=S_OK;
            LPTSTR LdapName=NULL;

            if ( NULL == *ppSI ) {

                DWORD nLen = 8+wcslen(ObjectName);
                LdapName = (LPTSTR)LocalAlloc(0, nLen*sizeof(WCHAR));
                if ( LdapName ) {
                   swprintf(LdapName, L"LDAP://%s", ObjectName);
                } else
                    return -1;


                hr = CComObject<CDsSecInfo>::CreateInstance((CComObject<CDsSecInfo>**)ppSI);

                if ( SUCCEEDED(hr) ) {

                    (*ppSI)->AddRef();

                    hr = (*ppSI)->Initialize(LdapName, pfnCreateDsPage, ppSeDescriptor, pSeInfo, flag);
                }
            }
            if ( SUCCEEDED(hr) ) {
                (*ppSI)->AddRef();
                HPROPSHEETPAGE hPage = (*pfnCSecPage)((LPSECURITYINFO)(*ppSI));  // in aclui.h
                (*ppSI)->Release();

                if ( hPage ) {

                    // display this one
                    PROPSHEETHEADER psh;
                    HPROPSHEETPAGE hpsp[1];

                    hpsp[0] = hPage;

                    ZeroMemory(&psh,sizeof(psh));

                    psh.dwSize = sizeof(psh);
                    psh.dwFlags = PSH_DEFAULT;
                    psh.nPages = 1;
                    psh.phpage = hpsp;

                    CString str=_T("");

                    switch (flag) {

                    case CONFIG_SECURITY_PAGE_READ_ONLY:
                    case CONFIG_SECURITY_PAGE_NO_PROTECT:
                    case CONFIG_SECURITY_PAGE:
                        str.LoadString(IDS_CONFIG_SECURITY_PAGE);
                        break;

                    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
                    case ANALYSIS_SECURITY_PAGE_NO_PROTECT:
                    case ANALYSIS_SECURITY_PAGE:
                        str.LoadString(IDS_ANALYSIS_SECURITY_PAGE);
                        break;

                    default:
                        str.LoadString(IDS_SECURITY_PAGE);
                        break;
                    }

                    str+= ObjectName;
                    psh.pszCaption = (LPCTSTR)str;

                    psh.hwndParent = hwndParent;

                    nRet = PropertySheet(&psh);

                    if (-1 == nRet) {
                       ErrorHandler();
                    }
                } else
                    hr = E_FAIL;
            }

            if ( LdapName )
                LocalFree(LdapName);
        }
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\servperm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ServPerm.h
//
//  Contents:   definition of CSecurityInfo
//
//----------------------------------------------------------------------------

#ifndef __SERVPERM_H_INCLUDED__
#define __SERVPERM_H_INCLUDED__

// #include "cookie.h"

#define CONFIG_SECURITY_PAGE_READ_ONLY      1
#define CONFIG_SECURITY_PAGE_NO_PROTECT     2
#define CONFIG_SECURITY_PAGE                3
#define CONFIG_SECURITY_PAGE_RO_NP          4
#define ANALYSIS_SECURITY_PAGE_READ_ONLY    5
#define ANALYSIS_SECURITY_PAGE_NO_PROTECT   6
#define ANALYSIS_SECURITY_PAGE              7
#define ANALYSIS_SECURITY_PAGE_RO_NP        8
#define SECURITY_PAGE                       9
#define SECURITY_PAGE_NO_PROTECT            10
#define SECURITY_PAGE_READ_ONLY             11 
#define SECURITY_PAGE_RO_NP                 12 

//Bug 424909, Yanggao, 6/29/2001
struct __declspec(uuid("965FC360-16FF-11d0-91CB-00AA00BBB723")) ISecurityInformation;

#ifdef _ATL_DEBUG
#define END_SEC_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} 
#else
#define END_SEC_COM_MAP() {NULL, 0, 0}}; return _entries;} 
#endif // _ATL_DEBUG

class CSecurityInfo : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInfo)
    BEGIN_COM_MAP(CSecurityInfo)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

private:
    CString m_strMachineName;
    CString m_strObjectName;
    SE_OBJECT_TYPE m_SeType;
    HINSTANCE m_hInstance;

protected:
//    CResult * m_pData;
    BOOL m_bIsContainer;
    int m_flag;
    PSECURITY_DESCRIPTOR *m_ppSD;
    SECURITY_INFORMATION *m_pSeInfo;

    HRESULT NewDefaultDescriptor(
        PSECURITY_DESCRIPTOR* ppsd,
        SECURITY_INFORMATION RequestedInformation);

    // this will throw a memory exception where appropriate
//    HRESULT MakeSelfRelativeCopy(
//        PSECURITY_DESCRIPTOR  psdOriginal,
//        PSECURITY_DESCRIPTOR* ppsdNew );

public:
//    void Initialize(CResult *pData, int flag);
//    void Initialize(CResult *pData, PSECURITY_DESCRIPTOR *ppSeDescriptor=NULL, SECURITY_INFORMATION *pSeInfo=NULL, int flag=0);
    void Initialize(BOOL bIsContainer, PSECURITY_DESCRIPTOR *ppSeDescriptor=NULL, SECURITY_INFORMATION *pSeInfo=NULL, int flag=0);
    void SetMachineName( LPCTSTR pszMachineName );
    void SetObjectName( LPCTSTR pszObjectName ) { m_strObjectName = pszObjectName; }
    void SetTypeInstance(SE_OBJECT_TYPE SeType, HINSTANCE hInstance)
    { m_SeType = SeType; m_hInstance = hInstance; }

    LPTSTR QueryMachineName()
    {
        return (m_strMachineName.IsEmpty())
            ? NULL
            : const_cast<LPTSTR>((LPCTSTR)m_strMachineName);
    }
    LPTSTR QueryObjectName()
    {
        return const_cast<LPTSTR>((LPCTSTR)m_strObjectName);
    }
};

class CDsSecInfo : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CDsSecInfo)
    BEGIN_COM_MAP(CDsSecInfo)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_SEC_COM_MAP()

public:
    CDsSecInfo()
    {
        m_dwRefCount = 0;
        m_pISecInfo = NULL;
    }
    virtual ~CDsSecInfo()
    {
        ASSERT(m_dwRefCount == 0);
        if (m_pISecInfo != NULL)
            m_pISecInfo->Release();
    }
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj)
    {
        return m_pISecInfo->QueryInterface(riid, ppvObj);
    }
    STDMETHOD_(ULONG,AddRef) ()
    {
        m_dwRefCount++;
        return m_pISecInfo->AddRef();
    }
    STDMETHOD_(ULONG,Release) ()
    {
        m_dwRefCount--;
        // this might be the last release on the page holder
        // which would cause the holder to delete itself and
        // "this" in the process (i.e. "this" no more valid when
        // returning from the m_pPageHolder->Release() call
        ISecurityInformation* pISecInfo = m_pISecInfo;

        return pISecInfo->Release();
    }

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo )
    {
        return m_pISecInfo->GetObjectInformation(pObjectInfo);
    }
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess )
    {
        return m_pISecInfo->GetAccessRights(pguidObjectType,
                                            dwFlags,
                                            ppAccess,
                                            pcAccesses,
                                            piDefaultAccess);
    }
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask)
    {
        return m_pISecInfo->MapGeneric(pguidObjectType,
                                        pAceFlags,
                                        pMask);
    }
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes )
    {
        return m_pISecInfo->GetInheritTypes(ppInheritTypes,
                                            pcInheritTypes);
    }
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
    {
        return m_pISecInfo->PropertySheetPageCallback(hwnd, uMsg, uPage);
    }

    // *** ISecurityInformation methods ***
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );

private:
    DWORD m_dwRefCount;
    ISecurityInformation* m_pISecInfo;  // interface pointer to the wrapped interface

protected:
    int m_flag;
    PSECURITY_DESCRIPTOR *m_ppSD;
    SECURITY_INFORMATION *m_pSeInfo;

public:
//    void Initialize(CResult *pData, int flag);
    HRESULT Initialize(LPTSTR LdapName, PFNDSCREATEISECINFO pfnCreateDsPage,
                    PSECURITY_DESCRIPTOR *ppSeDescriptor=NULL, SECURITY_INFORMATION *pSeInfo=NULL, int flag=0);
};

typedef CDsSecInfo *LPDSSECINFO;

INT_PTR MyCreateSecurityPage2(
    BOOL bIsContainer, //CResult *pData,
    PSECURITY_DESCRIPTOR *ppSeDescriptor,
    SECURITY_INFORMATION *pSeInfo,
    LPCTSTR ObjectName,
    SE_OBJECT_TYPE SeType,
    int flag,
    HWND hwndParent,
    BOOL bModeless);

INT_PTR MyCreateDsSecurityPage(
    LPDSSECINFO *ppSI,
    PFNDSCREATEISECINFO pfnCreateDsPage,
    PSECURITY_DESCRIPTOR *ppSeDescriptor,
    SECURITY_INFORMATION *pSeInfo,
    LPCTSTR ObjectName,
    int flag,
    HWND hwndParent);

#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\scopane.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       scopane.cpp
//
//  Contents:   Functions for handling the scope pane folder structure
//
//  History:    12-12-1997   RobCap   Split out from snapmgr.cpp
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"
#include "snapmgr.h"
#include "resource.h"
#include "wrapper.h"
#include "util.h"
#include <sceattch.h>
#include <io.h>

#ifdef INITGUID
#undef INITGUID
#include <gpedit.h>
#define INITGUID
#include "userenv.h"
#endif


//
// Array of folders to list in the scope pane
// The order of this array is important:
//   All folders which appear at the same level must be adjacent
//   to each other and the array and #defines need to be kept in
//   sync
//
//
#define USE_KERBEROS    1

//
// Top level folders
//
#define ANALYSIS_FOLDER 0
#define CONFIGURATION_FOLDER (ANALYSIS_FOLDER +1)

//
// Profile level folders
//
#define PROFILE_ACCOUNT_FOLDER (CONFIGURATION_FOLDER +1)
#define PROFILE_LOCAL_FOLDER (PROFILE_ACCOUNT_FOLDER +1)
#define PROFILE_EVENTLOG_FOLDER (PROFILE_LOCAL_FOLDER +1)
#define PROFILE_GROUPS_FOLDER (PROFILE_EVENTLOG_FOLDER +1)
#define PROFILE_SERVICE_FOLDER (PROFILE_GROUPS_FOLDER +1)
#define PROFILE_REGISTRY_FOLDER (PROFILE_SERVICE_FOLDER +1)
#define PROFILE_FILESTORE_FOLDER (PROFILE_REGISTRY_FOLDER +1)

//
// Profile/Account level folders
//
#define ACCOUNT_PASSWORD_FOLDER (PROFILE_FILESTORE_FOLDER +1)
#define ACCOUNT_LOCKOUT_FOLDER (ACCOUNT_PASSWORD_FOLDER +1)
#define ACCOUNT_KERBEROS_FOLDER (ACCOUNT_LOCKOUT_FOLDER +1)

//
// Profile/Local level folders
//
#define LOCAL_AUDIT_FOLDER (ACCOUNT_KERBEROS_FOLDER +1)
#define LOCAL_PRIVILEGE_FOLDER (LOCAL_AUDIT_FOLDER +1)
#define LOCAL_OTHER_FOLDER (LOCAL_PRIVILEGE_FOLDER +1)

//
// Profile/Eventlog level folders
//
#define EVENTLOG_LOG_FOLDER (LOCAL_OTHER_FOLDER +1)


#define NUM_FOLDERS (LOCAL_OTHER_FOLDER +1)
//#define NUM_FOLDERS (EVENTLOG_LOG_FOLDER +1)

//
// #defines to identify which folders belong in which sections
//
#define FIRST_STATIC_FOLDER ANALYSIS_FOLDER
#define LAST_STATIC_FOLDER CONFIGURATION_FOLDER
#define FIRST_PROFILE_FOLDER PROFILE_ACCOUNT_FOLDER
#define LAST_PROFILE_FOLDER PROFILE_DSOBJECT_FOLDER
#define LAST_PROFILE_NODS_FOLDER PROFILE_FILESTORE_FOLDER
#define LAST_LOCALPOL_FOLDER PROFILE_LOCAL_FOLDER
#define FIRST_ACCOUNT_FOLDER ACCOUNT_PASSWORD_FOLDER
#define LAST_ACCOUNT_NODS_FOLDER ACCOUNT_LOCKOUT_FOLDER
//
// remove kerberos section from NT5 for now
//
#if defined(_NT4BACK_PORT) || !defined(USE_KERBEROS)
#define LAST_ACCOUNT_FOLDER ACCOUNT_LOCKOUT_FOLDER
#else
#define LAST_ACCOUNT_FOLDER ACCOUNT_KERBEROS_FOLDER
#endif
#define FIRST_LOCAL_FOLDER LOCAL_AUDIT_FOLDER
#define LAST_LOCAL_FOLDER LOCAL_OTHER_FOLDER
#define FIRST_EVENTLOG_FOLDER EVENTLOG_LOG_FOLDER
#define LAST_EVENTLOG_FOLDER EVENTLOG_LOG_FOLDER

//
// The actual folder data
// This must be kept in sync with the above #defines
//         should be initialized based on the #defines rather than
//         independantly on them.  Let the compiler keep things
//         accurate for us
//
FOLDER_DATA SecmgrFolders[NUM_FOLDERS] =
{
   { IDS_ANALYZE, IDS_ANALYZE_DESC, ANALYSIS},
   { IDS_CONFIGURE, IDS_CONFIGURE_DESC, CONFIGURATION},
   { IDS_ACCOUNT_POLICY, IDS_ACCOUNT_DESC, POLICY_ACCOUNT},
   { IDS_LOCAL_POLICY, IDS_LOCAL_DESC, POLICY_LOCAL},
   { IDS_EVENT_LOG, IDS_EVENT_LOG, POLICY_LOG},
   { IDS_GROUPS, IDS_GROUPS_DESC, AREA_GROUPS},
   { IDS_SERVICE, IDS_SERVICE_DESC, AREA_SERVICE},
   { IDS_REGISTRY, IDS_REGISTRY_DESC, AREA_REGISTRY},
   { IDS_FILESTORE, IDS_FILESTORE_DESC, AREA_FILESTORE},
   { IDS_PASSWORD_CATEGORY, IDS_PASSWORD_CATEGORY, POLICY_PASSWORD},
   { IDS_LOCKOUT_CATEGORY,  IDS_LOCKOUT_CATEGORY, POLICY_LOCKOUT},
   { IDS_KERBEROS_CATEGORY,  IDS_KERBEROS_CATEGORY, POLICY_KERBEROS},
   { IDS_EVENT_AUDIT, IDS_EVENT_AUDIT, POLICY_AUDIT},
   { IDS_PRIVILEGE, IDS_PRIVILEGE_DESC, AREA_PRIVILEGE},
   { IDS_OTHER_CATEGORY, IDS_OTHER_CATEGORY, POLICY_OTHER},
};

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))


//+--------------------------------------------------------------------------
//
//  Function:   AddLocationsToFolderList
//
//  Synopsis:   Adds the locations from a given registry key to the
//              folder list.  Returns the number of locations added.
//              Helper function for CreateFolderList
//
//  Arguments:  [hKey]           - the key holding the locations
//              [dwMode]         - the mode SCAT is running in
//              [bCheckForDupes] - TRUE to check for duplicates before adding
//              [pPos]           - output only
//
//  Returns:    *[pPos]  - the position in m_pScopeItemList of the first
//                         folder created
//              the number of child folders created
//
//  Modifies:   CComponentDataImpl::m_pScopeItemList
//
//  History:    7-26-l999  RobCap  broken out from CreateFolderList
//
//---------------------------------------------------------------------------
INT
CComponentDataImpl::AddLocationsToFolderList(HKEY hKey,
                                             DWORD dwMode,
                                             BOOL bCheckForDupes,
                                             POSITION *pPos) {
   LPTSTR  tmpstr=NULL;
   WCHAR   pBuf[MAX_PATH];
   DWORD   BufSize = MAX_PATH;
   WCHAR   pExpanded[MAX_PATH];
   FILETIME    LastWriteTime;
   PWSTR       Desc=NULL;
   CFolder *folder =NULL;
   INT nCount = 0;
   DWORD status = 0;
   HRESULT hr = S_OK;
   //
   // enumerate all subkeys of the key
   //
   int iTotal = 0;
   do {
      memset(pBuf, '\0', MAX_PATH*sizeof(WCHAR));
      BufSize = MAX_PATH;

      status = RegEnumKeyEx(hKey,
                            nCount,
                            pBuf,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            &LastWriteTime);

      if ( NO_ERROR == status ) {
         //
         // get description of this location (subkey)
         //
         MyRegQueryValue( hKey,
                          pBuf,
                          L"Description",  // Value name (not localized)
                          (PVOID*)&Desc,
                          &BufSize );

         //
         // replace '/' with '\' because Registry does not
         // take '\' in a single key
         //
         tmpstr = wcschr(pBuf, L'/');
         while (tmpstr) {
            *tmpstr = L'\\';
            tmpstr = wcschr(tmpstr, L'/');
         }

         if (!ExpandEnvironmentStrings(pBuf,pExpanded,MAX_PATH)) {
            wcsncpy(pExpanded,pBuf,BufSize);
         }

         if (bCheckForDupes) {
            //
            // Make sure we haven't already added this directory
            //
            POSITION pos;
            BOOL bDuplicate = FALSE;
            pos = m_scopeItemList.GetHeadPosition();
            for (int i=0;i < m_scopeItemList.GetCount(); i++) {
               folder = m_scopeItemList.GetAt(pos);
               if (folder && (0 == lstrcmp(folder->GetName(),pExpanded))) {
                  bDuplicate = TRUE;
                  break;
               }
            }

            if (bDuplicate) {
               if ( Desc )
                   LocalFree(Desc);
               Desc = NULL;
               continue;
            }
         }

         folder = new CFolder();

         if (folder) {
            if( _wchdir( pExpanded ) ){
               folder->SetState( CFolder::state_InvalidTemplate );
            }
            //
            // Create the folder objects with static data
            //
            hr = folder->Create(pExpanded,                   // Name
                                Desc,                   // Description
                                NULL,                   // inf file name
                                CONFIG_FOLDER_IDX,      // closed icon index
                                CONFIG_FOLDER_IDX,      // open icon index
                                LOCATIONS,              // folder type
                                TRUE,                   // has children
                                dwMode,                 // SCE mode
                                NULL);                  // Extra Data
            if (SUCCEEDED(hr)) {
               m_scopeItemList.AddTail(folder);

               if ( iTotal == 0 && NULL != pPos && !bCheckForDupes) {
                  *pPos = m_scopeItemList.GetTailPosition();
               }
            } else {    // if can't create, then quit doing it anymore, no more reason to continue
               delete folder;
               if ( Desc )
                   LocalFree(Desc);
               Desc = NULL;
               break;
            }

         } else {
            hr = E_OUTOFMEMORY;
            if ( Desc )
               LocalFree(Desc);
            Desc = NULL;
            break;
         }

         if ( Desc ) {
            LocalFree(Desc);
         }
         Desc = NULL;

         nCount++;
         iTotal++;
      }
   } while ( status != ERROR_NO_MORE_ITEMS );

   return nCount;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateFolderList
//
//  Synopsis:   Adds the children folders of pFolder to m_pScopeItemList
//              and returns the location of the first such folder and the
//              number added
//
//  Arguments:  [pFolder] - the folder whose children we want to find
//              [type]    - the type of that folder
//              [pPos]    - output only
//              [Count]   - output only
//
//  Returns:    *[pPos]  - the position in m_pScopeItemList of the first
//                         folder created
//              *[Count] - the number of child folders created
//
//  Modifies:   CComponentDataImpl::m_pScopeItemList
//
//  History:    12-15-1997  RobCap  made dynamic based on mode
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::CreateFolderList(CFolder *pFolder,   // Optional, In
                                     FOLDER_TYPES type,  // In
                                     POSITION *pPos,     // Optional, Out
                                     INT *Count)         // Optional, Out,
{
   CFolder* folder = 0;

   INT     nStart = 0;
   INT     nCount = 0;
   BOOL    bHasChildren = FALSE;
   struct _wfinddata_t findData;
   intptr_t hFile = 0;
   WCHAR   pBuf[MAX_PATH];
   HKEY    hKey = 0;
   DWORD       BufSize = 0;
   DWORD       status = 0;
   PWSTR       Desc=NULL;
   LPTSTR      tmpstr=NULL;
   HRESULT     hr = S_OK;
   DWORD   dwErr = 0;

   SCESTATUS            rc = 0;
   PSCE_OBJECT_CHILDREN ObjectList=NULL;
   PSCE_OBJECT_LIST     pObject = 0;
   PSCE_ERROR_LOG_INFO  ErrBuf=NULL;
   CString              StrErr;
   PSCE_PROFILE_INFO    pProfileInfo=NULL;
   FOLDER_TYPES         newType;
   PEDITTEMPLATE        pet = 0;

   //
   // initialize dwMode and ModeBits
   //

   DWORD dwMode=0;
   DWORD ModeBits=0;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (Count)
      *Count = 0;

   if (pFolder) 
   {
      dwMode = pFolder->GetMode();
      ModeBits = pFolder->GetModeBits();
   }

   //
   // This could take some time, so create a wait curser
   //
   CWaitCursor wc;

   switch ( type ) 
   {
   case ROOT:
         //
         // Initial standalone mode root mode
         //

         folder = new CFolder();

         if (!folder)
            return E_OUTOFMEMORY;
         
         if ( GetImplType() == SCE_IMPL_TYPE_SAV ) 
         {
             dwMode = SCE_MODE_VIEWER;
             newType = ANALYSIS;
         } 
         else if ( GetImplType() == SCE_IMPL_TYPE_SCE ) 
         {
             dwMode = SCE_MODE_EDITOR;
             newType = CONFIGURATION;
         } 
         else if ( GetImplType() == SCE_IMPL_TYPE_LS) 
         {
            dwMode = SCE_MODE_LOCALSEC;
            newType = LOCALPOL;
         } 
         else 
         {
             dwMode = 0;
             newType = CONFIGURATION;
         }
         //
         // Create the folder objects with static data
         // MMC pulls in the name from the data object
         //
         hr = folder->Create(L"",              // Name
                             L"",              // Description
                             NULL,             // inf file name
                             SCE_IMAGE_IDX,    // closed icon index
                             SCE_IMAGE_IDX,    // open icon index
                             newType,          // folder type
                             TRUE,             // has children
                             dwMode,           // SCE Mode
                             NULL);            // Extra Data
         if (SUCCEEDED(hr)) 
         {
            folder->SetCookie(NULL);
            switch (m_Mode)
            {
               case SCE_MODE_DOMAIN_COMPUTER:
               case SCE_MODE_OU_COMPUTER:
               case SCE_MODE_LOCAL_COMPUTER:
               case SCE_MODE_REMOTE_COMPUTER:
                  m_computerModeBits = folder->GetModeBits();
                  break;

               case SCE_MODE_REMOTE_USER:
               case SCE_MODE_LOCAL_USER:
               case SCE_MODE_DOMAIN_USER:
               case SCE_MODE_OU_USER:
                  m_userModeBits = folder->GetModeBits();
                  break;

               default:
                  m_computerModeBits = folder->GetModeBits();
                  break;
            }
            
            m_scopeItemList.AddTail(folder);
            return S_OK;
         } 
         else 
         {
            delete folder;
            return hr;
         }


      case ANALYSIS:
         pFolder->SetInfFile(GT_COMPUTER_TEMPLATE);
         m_AnalFolder = pFolder;
         //
         // Very first time initialization of the sad name.
         // Ask the user to get a sad name if none exists.
         //
         if(!m_AnalFolder && SadName.IsEmpty() )
            OnOpenDataBase();
         //
         // enumerate security areas for analysis
         //
         if ( !SadHandle )
            LoadSadInfo(TRUE);

         //
         // The data under the Analysis node is not valid right now,
         // so don't display any folders
         //
         if (m_bIsLocked)
            return S_OK;

         //
         // We weren't able to load the Analysis data even though we're
         // not in the middle of an action that should be blocking it
         //
         if ( SadErrored != ERROR_SUCCESS || !SadHandle) 
            return E_FAIL;

         nStart = FIRST_PROFILE_FOLDER;

            //
            // Display all but the DS Objects folder
            //
            nCount = LAST_PROFILE_NODS_FOLDER - FIRST_PROFILE_FOLDER +1;
         bHasChildren = FALSE;
         break;

      case AREA_REGISTRY_ANALYSIS:
      case AREA_FILESTORE_ANALYSIS:
         if ( SadHandle == NULL ) 
         {
            //
            // We shouldn't be able to get this far without a SadHandle
            //
            ASSERT(FALSE);
            return E_FAIL;
         }

         if (m_bIsLocked) 
         {
            //
            // We shouldn't be able to get this far if we're locked
            //
            ASSERT(FALSE);
            return E_FAIL;
         }

         switch ( type ) 
         {
            case AREA_REGISTRY_ANALYSIS:
               status = AREA_REGISTRY_SECURITY; // use status temporatorily
               newType = REG_OBJECTS;
               break;

            case AREA_FILESTORE_ANALYSIS:
               status = AREA_FILE_SECURITY;
               newType = FILE_OBJECTS;
               break;

            default:
               break;
         }

         //
         // get the object roots
         //
         pet = GetTemplate(GT_LAST_INSPECTION,status,&dwErr);
         if (!pet) 
         {
            CString strErr;
            strErr.LoadString(dwErr);
            AfxMessageBox(strErr);
            return E_FAIL;
         }
         pProfileInfo = pet->pTemplate;

         if ( pProfileInfo ) 
         {
            //
            // add the object roots
            //
            if ( type == AREA_REGISTRY_ANALYSIS)
               pObject = pProfileInfo->pRegistryKeys.pOneLevel;
            else if ( type == AREA_FILESTORE_ANALYSIS )
               pObject = pProfileInfo->pFiles.pOneLevel;
            else 
               pObject = pProfileInfo->pDsObjects.pOneLevel;

            for (; pObject!=NULL; pObject=pObject->Next) 
            {
               CString strRoot;
               strRoot = (LPCTSTR)pObject->Name;
               if (AREA_FILESTORE_ANALYSIS == type) 
               {
                  //
                  // We want c:\, not c: here.
                  //
         