f(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                if (value == null) {
                    fileNames = null;
                }
                else {
                    // UNDONE : ChrisAn:  This broke the save file dialog.
                    //string temp = Path.GetFullPath(value); // ensure filename is valid...
                    fileNames = new string[] {value};
                }
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.FileNames"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the file
        ///       names of all selected files in the dialog box.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FDFileNamesDescr)
        ]
        public string[] FileNames {
            get{
                string[] files = FileNamesInternal;
                foreach (string file in files) {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileIO(" + file + ") Demanded");
                    IntSecurity.DemandFileIO(FileIOPermissionAccess.AllAccess, file);
                }
                return files;
            }
        }

        internal string[] FileNamesInternal {
            get {

                if (fileNames == null) {
                    return new string[0];
                }
                else {
                    return(string[])fileNames.Clone();
                }
            }
        }


        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.Filter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the current file name filter string,
        ///       which determines the choices that appear in the "Save as file type" or
        ///       "Files of type" box in the dialog box.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(""),
        Localizable(true),
        SRDescription(SR.FDfilterDescr)
        ]
        public string Filter {
            get {
                return filter == null? "": filter;
            }

            set {
                if (value != filter) {
                    if (value != null && value.Length > 0) {
                        string[] formats = value.Split('|');
                        if (formats == null || formats.Length % 2 != 0) {
                            throw new ArgumentException(SR.GetString(SR.FileDialogInvalidFilter));
                        }
                    }
                    else {
                        value = null;
                    }
                    filter = value;
                }
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.FilterExtensions"]/*' />
        /// <devdoc>
        ///     Extracts the file extensions specified by the current file filter into
        ///     an array of strings.  None of the extensions contain .'s, and the 
        ///     default extension is first.
        /// </devdoc>
        private string[] FilterExtensions {
            get {
                string filter = this.filter;
                ArrayList extensions = new ArrayList();
                
                // First extension is the default one.  It's a little strange if DefaultExt
                // is not in the filters list, but I guess it's legal.
                if (defaultExt != null) 
                    extensions.Add(defaultExt);

                if (filter != null) {
                    string[] tokens = filter.Split('|');
                    
                    if ((filterIndex * 2) - 1 >= tokens.Length) {
                        throw new InvalidOperationException(SR.GetString(SR.FileDialogInvalidFilterIndex));
                    }
                    
                    string[] exts = tokens[(filterIndex * 2) - 1].Split(';');
                    
                    foreach(string ext in exts) {
                        int i = ext.LastIndexOf('.');
                        if (i >= 0) {
                            extensions.Add(ext.Substring(i + 1, ext.Length - (i + 1)));
                        }
                    }
                }
                string[] temp = new string[extensions.Count];
                extensions.CopyTo(temp, 0);
                return temp;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.FilterIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the index of the filter currently selected in the file dialog box.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(1),
        SRDescription(SR.FDfilterIndexDescr)
        ]
        public int FilterIndex {
            get {
                return filterIndex;
            }

            set {
                filterIndex = value;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.InitialDirectory"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the initial directory displayed by the file dialog
        ///       box.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(""),
        SRDescription(SR.FDinitialDirDescr)
        ]
        public string InitialDirectory {
            get {
                return initialDir == null? "": initialDir;
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();

                initialDir = value;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.Instance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets the Win32 instance handle for the application.
        ///    </para>
        /// </devdoc>
        /* SECURITYUNDONE : should require EventQueue permission */
        protected virtual IntPtr Instance {
            [
                UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows),
                UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)
            ]
            get { return UnsafeNativeMethods.GetModuleHandle(null);}
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.Options"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets the Win32 common Open File Dialog OFN_* option flags.
        ///    </para>
        /// </devdoc>
        protected int Options {
            get {
                return options & (NativeMethods.OFN_READONLY | NativeMethods.OFN_HIDEREADONLY |
                                  NativeMethods.OFN_NOCHANGEDIR | NativeMethods.OFN_SHOWHELP | NativeMethods.OFN_NOVALIDATE |
                                  NativeMethods.OFN_ALLOWMULTISELECT | NativeMethods.OFN_PATHMUSTEXIST |
                                  NativeMethods.OFN_NODEREFERENCELINKS);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.RestoreDirectory"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box restores the current directory before
        ///       closing.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FDrestoreDirectoryDescr)
        ]
        public bool RestoreDirectory {
            get {
                return GetOption(NativeMethods.OFN_NOCHANGEDIR);
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();

                SetOption(NativeMethods.OFN_NOCHANGEDIR, value);
            }
        }


        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating
        ///       whether whether the Help button is displayed in the file dialog.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FDshowHelpDescr)
        ]
        public bool ShowHelp {
            get {
                return GetOption(NativeMethods.OFN_SHOWHELP);
            }
            set {
                SetOption(NativeMethods.OFN_SHOWHELP, value);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.Title"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the file dialog box title.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(""),
        Localizable(true),
        SRDescription(SR.FDtitleDescr)
        ]
        public string Title {
            get {
                return title == null? "": title;
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();

                title = value;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.ValidateNames"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box accepts only valid
        ///       Win32 file names.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FDvalidateNamesDescr)
        ]
        public bool ValidateNames {
            get {
                return !GetOption(NativeMethods.OFN_NOVALIDATE);
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();

                SetOption(NativeMethods.OFN_NOVALIDATE, !value);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.FileOk"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the user clicks on the Open or Save button on a file dialog
        ///       box.
        ///    </para>
        /// <remarks>
        ///    <para>
        ///       For information about handling events, see <see topic='cpconEventsOverview'/>.
        ///    </para>
        /// </remarks>
        /// </devdoc>
        [SRDescription(SR.FDfileOkDescr)]
        public event CancelEventHandler FileOk {
            add {
                Events.AddHandler(EventFileOk, value);
            }
            remove {
                Events.RemoveHandler(EventFileOk, value);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.DoFileOk"]/*' />
        /// <devdoc>
        ///     Processes the CDN_FILEOK notification.
        /// </devdoc>
        private bool DoFileOk(IntPtr lpOFN) {
            NativeMethods.OPENFILENAME_I ofn = (NativeMethods.OPENFILENAME_I)UnsafeNativeMethods.PtrToStructure(lpOFN, typeof(NativeMethods.OPENFILENAME_I));
            int saveOptions = options;
            int saveFilterIndex = filterIndex;
            string[] saveFileNames = fileNames;
            bool ok = false;
            try {
                options = options & ~NativeMethods.OFN_READONLY |
                          ofn.Flags & NativeMethods.OFN_READONLY;
                filterIndex = ofn.nFilterIndex;
                charBuffer.PutCoTaskMem(ofn.lpstrFile);
                if ((options & NativeMethods.OFN_ALLOWMULTISELECT) == 0)
                            fileNames = new string[] {charBuffer.GetString()};
                else
                fileNames = GetMultiselectFiles(charBuffer);
                if (ProcessFileNames()) {
                    CancelEventArgs ceevent = new CancelEventArgs();
                    try {
                        OnFileOk(ceevent);
                        ok = !ceevent.Cancel;
                    }
                    catch (Exception e) {
                        Application.OnThreadException(e);
                    }
                }
            }
            finally {
                if (!ok) {
                    options = saveOptions;
                    filterIndex = saveFilterIndex;
                    fileNames = saveFileNames;
                }
            }
            return ok;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.GetMultiselectFiles"]/*' />
        /// <devdoc>
        ///     Extracts the filename(s) returned by the file dialog.
        /// </devdoc>

        private string[] GetMultiselectFiles(CharBuffer charBuffer) {
            string directory = charBuffer.GetString();
            string fileName = charBuffer.GetString();
            if (fileName.Length == 0) return new string[] {
                    directory
                };
            if (directory[directory.Length - 1] != '\\') {
                directory = directory + "\\";
            }
            ArrayList names = new ArrayList();
            do {
                if (fileName[0] != '\\' && (fileName.Length <= 3 ||
                                            fileName[1] != ':' || fileName[2] != '\\')) {
                    fileName = directory + fileName;
                }
                names.Add(fileName);
                fileName = charBuffer.GetString();
            } while (fileName.Length > 0);
            string[] temp = new string[names.Count];
            names.CopyTo(temp, 0);
            return temp;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.GetOption"]/*' />
        /// <devdoc>
        ///     Returns the state of the given option flag.
        /// </devdoc>
        /// <internalonly/>

        internal bool GetOption(int option) {
            return(options & option) != 0;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.HookProc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines the common dialog box hook procedure that is overridden to add
        ///       specific functionality to the file dialog box.
        ///    </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override IntPtr HookProc(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
            if (msg == NativeMethods.WM_NOTIFY) {
                dialogHWnd = UnsafeNativeMethods.GetParent(new HandleRef(null, hWnd));
                UnsafeNativeMethods.OFNOTIFY notify = (UnsafeNativeMethods.OFNOTIFY)UnsafeNativeMethods.PtrToStructure(lparam, typeof(UnsafeNativeMethods.OFNOTIFY));

                switch (notify.hdr_code) {
                    case -601: /* CDN_INITDONE */
                        MoveToScreenCenter(dialogHWnd);
                        break;
                    case -606: /* CDN_FILEOK */
                        if (!DoFileOk(notify.lpOFN)) {
                            UnsafeNativeMethods.SetWindowLong(new HandleRef(null, hWnd), 0, new HandleRef(null, NativeMethods.InvalidIntPtr));
                            return NativeMethods.InvalidIntPtr;
                        }
                        break;
                }
            }
            return IntPtr.Zero;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.MakeFilterString"]/*' />
        /// <devdoc>
        ///     Converts the given filter string to the format required in an OPENFILENAME_I
        ///     structure.
        /// </devdoc>

        private static string MakeFilterString(string s) {
            if (s == null) return null;
            int length = s.Length;
            char[] filter = new char[length + 2];
            s.CopyTo(0, filter, 0, length);
            for (int i = 0; i < length; i++) {
                if (filter[i] == '|') filter[i] = (char)0;
            }
            filter[length + 1] = (char)0;
            return new string(filter);
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.OnFileOk"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.FileDialog.FileOk'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnFileOk(CancelEventArgs e) {
            CancelEventHandler handler = (CancelEventHandler)Events[EventFileOk];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.ProcessFileNames"]/*' />
        /// <devdoc>
        ///     Processes the filenames entered in the dialog according to the settings
        ///     of the "addExtension", "checkFileExists", "createPrompt", and
        ///     "overwritePrompt" properties.
        /// </devdoc>

        private bool ProcessFileNames() {
            if ((options & NativeMethods.OFN_NOVALIDATE) == 0) {
                string[] extensions = FilterExtensions;
                for (int i = 0; i < fileNames.Length; i++) {
                    string fileName = fileNames[i];
                    if ((options & OPTION_ADDEXTENSION) != 0 && !Path.HasExtension(fileName)) {
                        bool fileMustExist = (options & NativeMethods.OFN_FILEMUSTEXIST) != 0;

                        for (int j = 0; j < extensions.Length; j++) {
                            string currentExtension = Path.GetExtension(fileName);
                            
                            Debug.Assert(!extensions[j].StartsWith("."), 
                                         "FileDialog.FilterExtensions should not return things starting with '.'");
                            Debug.Assert(currentExtension.Length == 0 || currentExtension.StartsWith("."), 
                                         "File.GetExtension should return something that starts with '.'");
                            
                            string s = fileName.Substring(0, fileName.Length - currentExtension.Length);

                            // we don't want to append the extension if it contains wild cards
                            if (extensions[j].IndexOfAny(new char[] { '*', '?' }) == -1) {
                                s += "." + extensions[j];
                            }

                            if (!fileMustExist || File.Exists(s)) {
                                fileName = s;
                                break;
                            }
                        }
                        fileNames[i] = fileName;
                    }
                    if (!PromptUserIfAppropriate(fileName))
                        return false;
                }
            }
            return true;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.MessageBoxWithFocusRestore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Prompts the user with a <see cref='System.Windows.Forms.MessageBox'/>
        ///       with the given parameters. It also ensures that
        ///       the focus is set back on the window that had
        ///       the focus to begin with (before we displayed
        ///       the MessageBox).
        ///    </para>
        /// </devdoc>
        internal bool MessageBoxWithFocusRestore(string message, string caption,
                MessageBoxButtons buttons, MessageBoxIcon icon)
        {
            bool ret;
            IntPtr focusHandle = UnsafeNativeMethods.GetFocus();           
            try {
                ret = MessageBox.Show(message, caption,
                               buttons, icon) == DialogResult.Yes;
            }
            finally {
                UnsafeNativeMethods.SetFocus(new HandleRef(null, focusHandle));
            }
            return ret;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.PromptFileNotFound"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Prompts the user with a <see cref='System.Windows.Forms.MessageBox'/>
        ///       when a file
        ///       does not exist.
        ///    </para>
        /// </devdoc>
        private void PromptFileNotFound(string fileName) {
            MessageBoxWithFocusRestore(SR.GetString(SR.FileDialogFileNotFound, fileName), DialogCaption,
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
        }

        // If it's necessary to throw up a "This file exists, are you sure?" kind of
        // MessageBox, here's where we do it
        // Return value is whether or not the user hit "okay".
        internal virtual bool PromptUserIfAppropriate(string fileName) {
            if ((options & NativeMethods.OFN_FILEMUSTEXIST) != 0) {
                bool fileExists = false;

                // SECREVIEW : We must Assert just to check if the file exists. Since
                //           : we are doing this as part of the FileDialog, this is
                //           : OK.
                //
                new FileIOPermission(FileIOPermissionAccess.Read, IntSecurity.UnsafeGetFullPath(fileName)).Assert();
                try {
                   fileExists = File.Exists(fileName);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                if (!fileExists) {
                    PromptFileNotFound(fileName);
                    return false;
                }
            }

            return true;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all properties to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            options = NativeMethods.OFN_HIDEREADONLY | NativeMethods.OFN_PATHMUSTEXIST |
                      OPTION_ADDEXTENSION;
            title = null;
            initialDir = null;
            defaultExt = null;
            fileNames = null;
            filter = null;
            filterIndex = 1;
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.RunDialog"]/*' />
        /// <devdoc>
        ///    Implements running of a file dialog.
        /// </devdoc>
        /// <internalonly/>
        protected override bool RunDialog(IntPtr hWndOwner) {

            NativeMethods.WndProc hookProcPtr = new NativeMethods.WndProc(this.HookProc);
            NativeMethods.OPENFILENAME_I ofn = new NativeMethods.OPENFILENAME_I();
            try {
                charBuffer = CharBuffer.CreateBuffer(FILEBUFSIZE);
                if (fileNames != null) charBuffer.PutString(fileNames[0]);
                ofn.lStructSize = Marshal.SizeOf(typeof(NativeMethods.OPENFILENAME_I));

                // SECREVIEW : Assert environment so that we can determine
                //           : the platform that we are running on. We only
                //           : use the information to change the style of 
                //           : dialog, so it is safe.
                //
                IntSecurity.UnrestrictedEnvironment.Assert();
                try {
                    // Degrade to the older style dialog if we're not on Win2K.
                    // We do this by setting the struct size to a different value
                    //
                    if (Environment.OSVersion.Platform != System.PlatformID.Win32NT ||
                        Environment.OSVersion.Version.Major < 5) {
                        ofn.lStructSize = 0x4C;
                    }
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                ofn.hwndOwner = hWndOwner;
                ofn.hInstance = Instance;
                ofn.lpstrFilter = MakeFilterString(filter);
                ofn.nFilterIndex = filterIndex;
                ofn.lpstrFile = charBuffer.AllocCoTaskMem();
                ofn.nMaxFile = FILEBUFSIZE;
                ofn.lpstrInitialDir = initialDir;
                ofn.lpstrTitle = title;
                ofn.Flags = Options | (NativeMethods.OFN_EXPLORER | NativeMethods.OFN_ENABLEHOOK | NativeMethods.OFN_ENABLESIZING);
                ofn.lpfnHook = hookProcPtr;
                ofn.FlagsEx = NativeMethods.OFN_USESHELLITEM;
                if (defaultExt != null && AddExtension) {
                    ofn.lpstrDefExt = defaultExt;
                }
                return RunFileDialog(ofn);
            }
            finally {
                charBuffer = null;
                if (ofn.lpstrFile != IntPtr.Zero) Marshal.FreeCoTaskMem(ofn.lpstrFile);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.RunFileDialog"]/*' />
        /// <devdoc>
        ///     Implements the actual call to GetOPENFILENAME_I or GetSaveFileName.
        /// </devdoc>
        /// <internalonly/>
        internal abstract bool RunFileDialog(NativeMethods.OPENFILENAME_I ofn);

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.SetOption"]/*' />
        /// <devdoc>
        ///     Sets the given option to the given boolean value.
        /// </devdoc>
        /// <internalonly/>
        internal void SetOption(int option, bool value) {
            if (value) {
                options |= option;
            }
            else {
                options &= ~option;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides a string version of this Object.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            StringBuilder sb = new StringBuilder(base.ToString() + ": Title: " + Title + ", FileName: ");
            try {
                sb.Append(FileName);
            }
            catch (Exception e) {
                sb.Append("<");
                sb.Append(e.GetType().FullName);
                sb.Append(">");
            }
            return sb.ToString();
        }
        
#if false
        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.CharBuffer"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal abstract class CharBuffer {
            internal static CharBuffer CreateBuffer(int size) {
                if (Marshal.SystemDefaultCharSize == 1) return new AnsiBuffer(size);
                return new UnicodeBuffer(size);
            }

            internal abstract int AllocCoTaskMem();
            internal abstract string GetString();
            internal abstract void PutCoTaskMem(IntPtr ptr);
            internal abstract void PutString(string s);
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.AnsiBuffer"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal class AnsiBuffer : CharBuffer {
            internal byte[] buffer;
            internal int offset;

            internal AnsiBuffer(int size) {
                buffer = new byte[size];
            }

            internal override int AllocCoTaskMem() {
                int result = Marshal.AllocCoTaskMem(buffer.Length);
                Marshal.Copy(buffer, 0, result, buffer.Length);
                return result;
            }

            internal override string GetString() {
                int i = offset;
                while (i < buffer.Length && buffer[i] != 0) i++;
                string result = Encoding.Default.GetString(buffer, offset, i - offset);
                if (i < buffer.Length) i++;
                offset = i;
                return result;
            }

            internal override void PutCoTaskMem(IntPtr ptr) {
                Marshal.Copy(ptr, buffer, 0, buffer.Length);
                offset = 0;
            }

            internal override void PutString(string s) {
                byte[] bytes = Encoding.Default.GetBytes(s);
                int count = Math.Min(bytes.Length, buffer.Length - offset);
                Array.Copy(bytes, 0, buffer, offset, count);
                offset += count;
                if (offset < buffer.Length) buffer[offset++] = 0;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.UnicodeBuffer"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal class UnicodeBuffer : CharBuffer {
            internal char[] buffer;
            internal int offset;

            internal UnicodeBuffer(int size) {
                buffer = new char[size];
            }

            internal override int AllocCoTaskMem() {
                int result = Marshal.AllocCoTaskMem(buffer.Length * 2);
                Marshal.Copy(buffer, 0, result, buffer.Length);
                return result;
            }

            internal override string GetString() {
                int i = offset;
                while (i < buffer.Length && buffer[i] != 0) i++;
                string result = new string(buffer, offset, i - offset);
                if (i < buffer.Length) i++;
                offset = i;
                return result;
            }

            internal override void PutCoTaskMem(IntPtr ptr) {
                Marshal.Copy(ptr, buffer, 0, buffer.Length);
                offset = 0;
            }

            internal override void PutString(string s) {
                int count = Math.Min(s.Length, buffer.Length - offset);
                s.CopyTo(0, buffer, offset, count);
                offset += count;
                if (offset < buffer.Length) buffer[offset++] = (char)0;
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\folderbrowserdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="FolderBrowserDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms 
{
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;

    /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a common dialog box that allows the user to specify options for 
    ///       selecting a folder. This class cannot be inherited.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("HelpRequest"),
    DefaultProperty("SelectedPath"),
    Designer("System.Windows.Forms.Design.FolderBrowserDialogDesigner, " + AssemblyRef.SystemDesign)
    ]
    public sealed class FolderBrowserDialog : CommonDialog
    {
        // Root node of the tree view.
        private Environment.SpecialFolder rootFolder;
    
        // Description text to show.
        private string descriptionText;
    
        // Folder picked by the user.
        private string selectedPath;

        // Show the 'New Folder' button?
        private bool showNewFolderButton;

        // set to True when selectedPath is set after the dialog box returns
        // set to False when selectedPath is set via the SelectedPath property.
        // Warning! Be careful about race conditions when touching this variable.
        // This variable is determining if the PathDiscovery security check should
        // be bypassed or not.
        private bool selectedPathNeedsCheck;
    
        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.FolderBrowserDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.FolderBrowserDialog'/> class.
        ///    </para>
        /// </devdoc>
        public FolderBrowserDialog() 
        {
            Reset();
        }

        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.HelpRequest"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler HelpRequest 
        {
            add 
            {
                base.HelpRequest += value;
            }
            remove 
            {
                base.HelpRequest -= value;
            }
        }

        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.ShowNewFolderButton"]/*' />
        /// <devdoc>
        ///     Determines if the 'New Folder' button should be exposed.
        /// </devdoc>
        [
        Browsable(true),
        DefaultValue(true),
        Localizable(false),
        SRCategory(SR.CatFolderBrowsing),
        SRDescription(SR.FolderBrowserDialogShowNewFolderButton)
        ]
        public bool ShowNewFolderButton
        {
            get
            {
                return showNewFolderButton;
            }
            set
            {
                showNewFolderButton = value;
            }
        }

        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.SelectedPath"]/*' />
        /// <devdoc>
        ///     Gets the directory path of the folder the user picked.
        ///     Sets the directory path of the initial folder shown in the dialog box.
        /// </devdoc>
        [
        Browsable(true),
        DefaultValue(""),
        Editor("System.Windows.Forms.Design.SelectedPathEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        Localizable(true),
        SRCategory(SR.CatFolderBrowsing),
        SRDescription(SR.FolderBrowserDialogSelectedPath)
        ]
        public string SelectedPath
        {
            get
            {
                if (selectedPath == null || selectedPath.Length == 0)
                {
                    return selectedPath;
                }

                if (selectedPathNeedsCheck)
                {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileIO(" + selectedPath + ") Demanded");
                    new FileIOPermission(FileIOPermissionAccess.PathDiscovery, selectedPath).Demand();
                }
                return selectedPath;
            }
            set
            {
                selectedPath = (value == null) ? String.Empty : value;
                selectedPathNeedsCheck = false;
            }
        }

        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.RootFolder"]/*' />
        /// <devdoc>
        ///     Gets/sets the root node of the directory tree.
        /// </devdoc>
        [
        Browsable(true),
        DefaultValue(System.Environment.SpecialFolder.Desktop),
        Localizable(false),
        SRCategory(SR.CatFolderBrowsing),
        SRDescription(SR.FolderBrowserDialogRootFolder)
        ]
        public System.Environment.SpecialFolder RootFolder
        {
            get
            {
                return rootFolder;
            }
            set
            {
                if (!Enum.IsDefined(typeof(System.Environment.SpecialFolder), value)) 
                {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(System.Environment.SpecialFolder));
                }
                rootFolder = value;
            }
        }
    
        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.Description"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a description to show above the folders. Here you can provide instructions for
        ///       selecting a folder.
        ///    </para>
        /// </devdoc>
        [
        Browsable(true),
        DefaultValue(""),
        Localizable(true),
        SRCategory(SR.CatFolderBrowsing),
        SRDescription(SR.FolderBrowserDialogDescription)
        ]
        public string Description
        {
            get
            {
                return descriptionText;
            }
            set
            {
                descriptionText = (value == null) ? String.Empty : value;
            }
        }
    
        /// <devdoc>
        ///     Helper function that returns the IMalloc interface used by the shell.
        /// </devdoc>
        private static UnsafeNativeMethods.IMalloc GetSHMalloc()
        {
            UnsafeNativeMethods.IMalloc[] malloc = new UnsafeNativeMethods.IMalloc[1];
            UnsafeNativeMethods.Shell32.SHGetMalloc(malloc);
            return malloc[0];
        }
    
        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all properties to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() 
        {
            rootFolder = System.Environment.SpecialFolder.Desktop;
            descriptionText = String.Empty;
            selectedPath = String.Empty;
            selectedPathNeedsCheck = false;
            showNewFolderButton = true;
        }

        /// <include file='doc\FolderBrowserDialog.uex' path='docs/doc[@for="FolderBrowserDialog.RunDialog"]/*' />
        /// <devdoc>
        ///    Implements running of a folder browser dialog.
        /// </devdoc>
        protected override bool RunDialog(IntPtr hWndOwner) 
        {
            IntPtr pidlRoot = IntPtr.Zero;
            bool returnValue = false;
    
            UnsafeNativeMethods.Shell32.SHGetSpecialFolderLocation(hWndOwner, (int) rootFolder, ref pidlRoot);
            if (pidlRoot == IntPtr.Zero)
            {
                UnsafeNativeMethods.Shell32.SHGetSpecialFolderLocation(hWndOwner, NativeMethods.CSIDL_DESKTOP, ref pidlRoot);
                if (pidlRoot == IntPtr.Zero)
                {
                    throw new Exception(SR.GetString(SR.FolderBrowserDialogNoRootFolder));
                }
            }

            int mergedOptions = (int) UnsafeNativeMethods.BrowseInfos.NewDialogStyle;
            if (!showNewFolderButton)
            {
                mergedOptions += (int) UnsafeNativeMethods.BrowseInfos.HideNewFolderButton;
            }

            Application.OleRequired();
    
            IntPtr pidlRet = IntPtr.Zero;
    
            try {
                // Construct a BROWSEINFO
                UnsafeNativeMethods.BROWSEINFO bi = new UnsafeNativeMethods.BROWSEINFO();
    
                IntPtr pszDisplayName = Marshal.AllocHGlobal(NativeMethods.MAX_PATH);
                IntPtr pszSelectedPath = Marshal.AllocHGlobal(NativeMethods.MAX_PATH);
                UnsafeNativeMethods.BrowseCallbackProc callback = new UnsafeNativeMethods.BrowseCallbackProc(this.FolderBrowserDialog_BrowseCallbackProc);

                bi.pidlRoot = pidlRoot;
                bi.hwndOwner = hWndOwner;
                bi.pszDisplayName = pszDisplayName;
                bi.lpszTitle = descriptionText;
                bi.ulFlags = mergedOptions;
                bi.lpfn = callback;
                bi.lParam = IntPtr.Zero;
                bi.iImage = 0;
    
                // And show the dialog
                pidlRet = UnsafeNativeMethods.Shell32.SHBrowseForFolder(bi);
    
                if (pidlRet != IntPtr.Zero)
                {
                    // Then retrieve the path from the IDList
                    UnsafeNativeMethods.Shell32.SHGetPathFromIDList(pidlRet, pszSelectedPath);
    
                    // set the flag to True before selectedPath is set to
                    // assure security check and avoid bogus race condition
                    selectedPathNeedsCheck = true;

                    // Convert to a string
                    selectedPath = Marshal.PtrToStringAuto(pszSelectedPath);

                    // Then free all the stuff we've allocated or the SH API gave us
                    Marshal.FreeHGlobal(pszSelectedPath);
                    Marshal.FreeHGlobal(pszDisplayName);
                    returnValue = true;
                }
            }
            finally 
            {
                UnsafeNativeMethods.IMalloc malloc = GetSHMalloc();
                malloc.Free(pidlRoot);
    
                if (pidlRet != IntPtr.Zero)
                {
                    malloc.Free(pidlRet);
                }
            }
    
            return returnValue;
        }

        /// <devdoc>
        ///    Callback function used to enable/disable the OK button,
        ///    and select the initial folder.
        /// </devdoc>
        private int FolderBrowserDialog_BrowseCallbackProc(IntPtr hwnd,
                                                           int msg, 
                                                           IntPtr lParam, 
                                                           IntPtr lpData)
        {
            switch (msg)
            {
                case NativeMethods.BFFM_INITIALIZED: 
                    // Indicates the browse dialog box has finished initializing. The lpData value is zero. 
                    if (selectedPath != string.Empty) 
                    {
                        // Try to select the folder specified by selectedPath
                        UnsafeNativeMethods.SendMessage(new HandleRef(null, hwnd), (int) NativeMethods.BFFM_SETSELECTION, 1, selectedPath);
                    }
                    break;
                case NativeMethods.BFFM_SELCHANGED: 
                    // Indicates the selection has changed. The lpData parameter points to the item identifier list for the newly selected item. 
                    IntPtr selectedPidl = lParam;
                    if (selectedPidl != IntPtr.Zero)
                    {
                        IntPtr pszSelectedPath = Marshal.AllocHGlobal(NativeMethods.MAX_PATH);
                        // Try to retrieve the path from the IDList
                        bool isFileSystemFolder = UnsafeNativeMethods.Shell32.SHGetPathFromIDList(selectedPidl, pszSelectedPath);
                        Marshal.FreeHGlobal(pszSelectedPath);
                        UnsafeNativeMethods.SendMessage(new HandleRef(null, hwnd), (int) NativeMethods.BFFM_ENABLEOK, 0, isFileSystemFolder ? 1 : 0);
                    }
                    break;
            }
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\formstartposition.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormStartPosition.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Drawing;



    /// <include file='doc\FormStartPosition.uex' path='docs/doc[@for="FormStartPosition"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the initial position of a
    ///       form.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum FormStartPosition {

        /// <include file='doc\FormStartPosition.uex' path='docs/doc[@for="FormStartPosition.Manual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The location and size of the form will determine its
        ///       starting position.
        ///       
        ///    </para>
        /// </devdoc>
        Manual = 0,
        /// <include file='doc\FormStartPosition.uex' path='docs/doc[@for="FormStartPosition.CenterScreen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The form is centered on the current display,
        ///       and has the dimensions specified in the form's size.
        ///    </para>
        /// </devdoc>
        CenterScreen = 1,
        /// <include file='doc\FormStartPosition.uex' path='docs/doc[@for="FormStartPosition.WindowsDefaultLocation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The form is positioned at the Windows default
        ///       location and has the dimensions specified in the form's size.
        ///    </para>
        /// </devdoc>
        WindowsDefaultLocation = 2,
        /// <include file='doc\FormStartPosition.uex' path='docs/doc[@for="FormStartPosition.WindowsDefaultBounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The form is positioned at the Windows default
        ///       location and has the bounds determined by Windows default.
        ///    </para>
        /// </devdoc>
        WindowsDefaultBounds = 3,
        /// <include file='doc\FormStartPosition.uex' path='docs/doc[@for="FormStartPosition.CenterParent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The form is centered within the bounds of its parent form.
        ///    </para>
        /// </devdoc>
        CenterParent = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\formborderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormBorderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Drawing;

    /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the border styles for a form.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum FormBorderStyle {

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No border.
        ///
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.FixedSingle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A fixed, single line border.
        ///
        ///    </para>
        /// </devdoc>
        FixedSingle = 1,

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.Fixed3D"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A fixed, three-dimensional border.
        ///       
        ///    </para>
        /// </devdoc>
        Fixed3D = 2,

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.FixedDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A thick, fixed dialog-style border.
        ///
        ///    </para>
        /// </devdoc>
        FixedDialog = 3,

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.Sizable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A resizable border.
        ///       
        ///    </para>
        /// </devdoc>
        Sizable = 4,

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.FixedToolWindow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A tool window border
        ///       that is not resizable.
        ///    </para>
        /// </devdoc>
        FixedToolWindow = 5,

        /// <include file='doc\FormBorderStyle.uex' path='docs/doc[@for="FormBorderStyle.SizableToolWindow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A resizable tool window border.
        ///       
        ///    </para>
        /// </devdoc>
        SizableToolWindow = 6,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\formwindowstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormWindowState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Drawing;



    /// <include file='doc\FormWindowState.uex' path='docs/doc[@for="FormWindowState"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how a form window
    ///       is displayed.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum FormWindowState {

        /// <include file='doc\FormWindowState.uex' path='docs/doc[@for="FormWindowState.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A default sized window.
        ///       
        ///    </para>
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\FormWindowState.uex' path='docs/doc[@for="FormWindowState.Minimized"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A minimized window.
        ///
        ///    </para>
        /// </devdoc>
        Minimized = 1,

        /// <include file='doc\FormWindowState.uex' path='docs/doc[@for="FormWindowState.Maximized"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A maximized window.
        ///    </para>
        /// </devdoc>
        Maximized = 2,


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\givefeedbackevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="GiveFeedbackEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    //=--------------------------------------------------------------------------=
    // GiveFeedbackEventArgs.cs
    //=--------------------------------------------------------------------------=
    // Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
    //
    // THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
    // ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
    // THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
    // PARTICULAR PURPOSE.
    //=--------------------------------------------------------------------------=

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\GiveFeedbackEvent.uex' path='docs/doc[@for="GiveFeedbackEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.GiveFeedback'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class GiveFeedbackEventArgs : EventArgs {
        private readonly DragDropEffects effect;
        private bool useDefaultCursors;

        /// <include file='doc\GiveFeedbackEvent.uex' path='docs/doc[@for="GiveFeedbackEventArgs.GiveFeedbackEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.GiveFeedbackEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public GiveFeedbackEventArgs(DragDropEffects effect, bool useDefaultCursors) {
            this.effect = effect;
            this.useDefaultCursors = useDefaultCursors;
        }

        /// <include file='doc\GiveFeedbackEvent.uex' path='docs/doc[@for="GiveFeedbackEventArgs.Effect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of drag-and-drop operation.
        ///    </para>
        /// </devdoc>
        public DragDropEffects Effect {
            get {
                return effect;
            }
        }

        /// <include file='doc\GiveFeedbackEvent.uex' path='docs/doc[@for="GiveFeedbackEventArgs.UseDefaultCursors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a
        ///       value
        ///       indicating whether a default pointer is used.
        ///    </para>
        /// </devdoc>
        public bool UseDefaultCursors {
            get {
                return useDefaultCursors;
            }
            set {
                useDefaultCursors = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\framestyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="FrameStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;

    /// <include file='doc\FrameStyle.uex' path='docs/doc[@for="FrameStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the frame style of the selected control.
    ///    </para>
    /// </devdoc>
    public enum FrameStyle {

        /// <include file='doc\FrameStyle.uex' path='docs/doc[@for="FrameStyle.Dashed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A thin, dashed border.
        ///    </para>
        /// </devdoc>
        Dashed,

        /// <include file='doc\FrameStyle.uex' path='docs/doc[@for="FrameStyle.Thick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A thick, solid border.
        ///    </para>
        /// </devdoc>
        Thick,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\griditemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Windows.Forms;

    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms.PropertyGridInternal;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;

    /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection"]/*' />
    /// <devdoc>
    ///  A read-only collection of GridItem objects
    /// </devdoc>
    public class GridItemCollection : ICollection {
    
        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.Empty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static GridItemCollection Empty = new GridItemCollection(new GridItem[0]);

        internal GridItem[] entries;
        
        internal GridItemCollection(GridItem[] entries) {
            if (entries == null) {
               this.entries = new GridItem[0];
            }
            else {
               this.entries = entries;
            }
        }
        
        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.Count"]/*' />
        /// <devdoc>
        ///     Retrieves the number of member attributes.
        /// </devdoc>
        public int Count {
            get {
                return entries.Length;
            }
        }

        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.this"]/*' />
        /// <devdoc>
        ///     Retrieves the member attribute with the specified index.
        /// </devdoc>
        public GridItem this[int index] {
            get {
                return entries[index];
            }
        }
        
        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public GridItem this[string label]{
            get {
                foreach(GridItem g in entries) {
                    if (g.Label == label) {
                        return g;
                    }
                }
                return null;
            }
        }

        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array dest, int index) {
            if (entries.Length > 0) {
                System.Array.Copy(entries, 0, dest, index, entries.Length);
            }
        }
        /// <include file='doc\GridItemCollection.uex' path='docs/doc[@for="GridItemCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///      Creates and retrieves a new enumerator for this collection.
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return entries.GetEnumerator();
        }

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\griditem.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Windows.Forms;

    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms.PropertyGridInternal;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;

    /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem"]/*' />
    /// <devdoc>
    /// <para>Representaion of one row item in the PropertyGrid.  These items represent the
    /// hierarchy of the grid's "tree-like" view and can be used to get information about
    /// the grid's state and contents.</para>
    /// <para>These objects should not be cached because they represent a snapshot of the PropertyGrid's state
    ///  and may be disposed by grid activity.  The PropertyGrid often recretates these objects internally even if
    ///  it doesn't appear to change to the user. </para>
    /// </devdoc>
    public abstract class GridItem {
    
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.GridItems"]/*' />
        /// <devdoc>
        /// <para>Retrieves the child GridItems, if any, of this GridItem</para>
        /// </devdoc>
        public abstract GridItemCollection GridItems {
            get;
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.GridItemType"]/*' />
        /// <devdoc>
        /// <para>Retrieves type of this GridItem, as a value from System.Windows.Forms.GridItemType</para>
        /// </devdoc>
        public abstract GridItemType GridItemType {
            get;
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.Label"]/*' />
        /// <devdoc>
        /// <para>Retrieves the text label of this GridItem.  This may be different from the actual PropertyName.
        ///       For GridItemType.Property GridItems, retrieve the PropertyDescriptor and check its Name property.</para>
        /// </devdoc>
        public abstract string Label {
            get;
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.Parent"]/*' />
        /// <devdoc>
        /// <para>Retrieves parent GridItem of this GridItem, if any</para>
        /// </devdoc>
        public abstract GridItem Parent {
            get;
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.PropertyDescriptor"]/*' />
        /// <devdoc>
        /// <para>If this item is a GridItemType.Property GridItem, this retreives the System.ComponentModel.PropertyDescriptor that is
        ///       associated with this GridItem.  This can be used to retrieve infomration such as property Type, Name, or TypeConverter.</para>
        /// </devdoc>
        public abstract PropertyDescriptor PropertyDescriptor {
            get;
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.Value"]/*' />
        /// <devdoc>
        /// <para>Retrieves the current Value of this grid Item.  This may be null. </para>
        /// </devdoc>
        public abstract object Value {
            get;
            // note: we don't do set because of the value class semantics, etc.
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.Expandable"]/*' />
        /// <devdoc>
        /// <para>Retreives whether the given property is expandable.</para>
        /// </devdoc>
        public virtual bool Expandable {
            get {
                return false;
            }
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.Expanded"]/*' />
        /// <devdoc>
        /// <para>Retreives or sets whether the GridItem is in an expanded state.</para>
        /// </devdoc>
        public virtual bool Expanded {
            get {
                return false;
            }
            set {
                throw new NotSupportedException(SR.GetString(SR.GridItemNotExpandable));
            }
        }
        
        /// <include file='doc\GridItem.uex' path='docs/doc[@for="GridItem.Select"]/*' />
        /// <devdoc>
        /// <para>Attempts to select this GridItem in the PropertyGrid.</para>
        /// </devdoc>
        public abstract bool Select();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\graphicsbuffer.cs ===
//------------------------------------------------------------------------------
// <copyright file="GraphicsBuffer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System;
    using System.ComponentModel;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Text;
    using System.Diagnostics;
    using System.Drawing.Drawing2D;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Security;
    using System.Security.Permissions;

    internal class GraphicsBuffer : IDisposable {
        Graphics surface;
        GraphicsBufferManager owner;
        internal bool disposeOwner;

        internal GraphicsBuffer(Graphics surface, GraphicsBufferManager owner) {
            this.surface = surface;
            this.owner = owner;
        }

        public Graphics Graphics {
            get {
                Debug.Assert(surface != null, "Someone is probably expecting this to be non-null... Token is already disposed");
                return surface;
            }
        }

        public void Dispose() {
            owner.ReleaseBuffer(this);

            if (disposeOwner) {
                owner.Dispose();
            }
            owner = null;
            surface = null;
        }
    }

    internal abstract class GraphicsBufferManager : IDisposable {

        static TraceSwitch doubleBuffering;
        internal static TraceSwitch DoubleBuffering {
            get {
                if (doubleBuffering == null) {
                    doubleBuffering = new TraceSwitch("DoubleBuffering", "Output information about double buffering");
                }
                return doubleBuffering;
            }
        }

        public static GraphicsBufferManager CreateOptimal() {
            return new DibGraphicsBufferManager();
        }
        
        ~GraphicsBufferManager() {
            Dispose(false);
        }
        public abstract GraphicsBuffer AllocBuffer(Graphics target, Rectangle targetBounds);
        public abstract GraphicsBuffer AllocBuffer(IntPtr target, Rectangle targetBounds);
        public abstract void ReleaseBuffer(GraphicsBuffer buffer);
        public abstract void PaintBuffer();
        protected abstract void Dispose(bool disposing);
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        class DibGraphicsBufferManager : GraphicsBufferManager {
            IntPtr dib;
            IntPtr compatDC;
            IntPtr oldBitmap;
            int bufferWidth = -1;
            int bufferHeight = -1;
            Graphics compatGraphics;
            GraphicsContainer container;

            IntPtr targetDC;
            Graphics targetGraphics;
            int targetX = -1;
            int targetY = -1;
            int virtualWidth = -1;
            int virtualHeight = -1;

            GraphicsBuffer buffer;
            int busy;

            public override GraphicsBuffer AllocBuffer(Graphics target, Rectangle targetBounds) {
                if (ShouldUseTempManager(targetBounds)) {
                    Debug.WriteLineIf(DoubleBuffering.TraceWarning, "Too big of buffer requested (" + targetBounds.Width + " x " + targetBounds.Height + ") ... allocating temp buffer manager");
                    return AllocBufferInTempManager(target, IntPtr.Zero, targetBounds);
                }
                return AllocBuffer(target, IntPtr.Zero, targetBounds);
            }

            public override GraphicsBuffer AllocBuffer(IntPtr target, Rectangle targetBounds) {
                if (ShouldUseTempManager(targetBounds)) {
                    Debug.WriteLineIf(DoubleBuffering.TraceWarning, "Too big of buffer requested (" + targetBounds.Width + " x " + targetBounds.Height + ") ... allocating temp buffer manager");
                    return AllocBufferInTempManager(null, target, targetBounds);
                }
                return AllocBuffer(null, target, targetBounds);
            }
            private bool ShouldUseTempManager(Rectangle targetBounds) {
                // This routine allows us to control the point were we start using throw away
                // managers for painting. Since the buffer manager stays around (by default)
                // for the life of the app, we don't want to consume too much memory
                // in the buffer. However, re-allocating the buffer for small things (like
                // buttons, labels, etc) will hit us on runtime performance.
                //
                // Don't modify this routine without running perf benchmarks.
                //


                // default... if size is larger than 3X the default button size (both directions), 
                // we don't want to keep the buffer around, it will consume too much working set.
                //
                return (targetBounds.Width * targetBounds.Height) > ((75 * 3) * (23 * 3));
            }
            private GraphicsBuffer AllocBufferInTempManager(Graphics targetGraphics, IntPtr targetDC, Rectangle targetBounds) {
                GraphicsBuffer ret = new DibGraphicsBufferManager().AllocBuffer(targetGraphics, targetDC, targetBounds);;
                ret.disposeOwner = true;
                return ret;
            }
            private GraphicsBuffer AllocBuffer(Graphics targetGraphics, IntPtr targetDC, Rectangle targetBounds) {
                int oldBusy = Interlocked.CompareExchange(ref busy, 1, 0);

                // In the case were we have contention on the buffer - i.e. two threads 
                // trying to use the buffer at the same time, we just create a temp 
                // buffermanager and have the buffer dispose of it when it is done.
                //
                if (oldBusy == 1) {
                    Debug.WriteLineIf(DoubleBuffering.TraceWarning, "Attempt to have two buffers for a buffer manager... allocating temp buffer manager");
                    return AllocBufferInTempManager(targetGraphics, targetDC, targetBounds);
                }

                Graphics surface;
                this.targetX = targetBounds.X;
                this.targetY = targetBounds.Y;
                this.targetDC = targetDC;
                this.targetGraphics = targetGraphics;

                if (targetGraphics != null) {
                    IntPtr destDc = targetGraphics.GetHdc();
                    try {
                        surface = CreateBuffer(destDc, -targetX, -targetY, targetBounds.Width, targetBounds.Height);
                    }
                    finally {
                        targetGraphics.ReleaseHdcInternal(destDc);
                    }
                }
                else {
                    surface = CreateBuffer(targetDC, -targetX, -targetY, targetBounds.Width, targetBounds.Height);
                }

                container = surface.BeginContainer();
                this.buffer = new GraphicsBuffer(surface, this);

                return this.buffer;
            }

            public override void ReleaseBuffer(GraphicsBuffer buffer) {
                Debug.Assert(buffer == this.buffer, "Tried to release a bogus buffer");
                PaintBuffer();

                compatGraphics.EndContainer(container);
                container = null;
                this.buffer = null;
                this.busy = 0;
            }

            public override void PaintBuffer() {
                IntPtr destDC;
                 
                if (targetGraphics != null) {
                    destDC = targetGraphics.GetHdc();
                }
                else {
                    destDC = targetDC;
                }

                try {
                    int rop = 0xcc0020; // RasterOp.SOURCE.GetRop();
                    SafeNativeMethods.BitBlt(new HandleRef(targetGraphics, destDC), 
                                         targetX, targetY, virtualWidth, virtualHeight, 
                                         new HandleRef(this, compatDC), 0, 0, 
                                         rop); 
                }
                finally {
                    if (targetGraphics != null) {
                        targetGraphics.ReleaseHdcInternal(destDC);
                    }
                }
            }

            protected override void Dispose(bool disposing) {
                Debug.Assert(disposing, "Never let a graphics buffer finalize!");

                Debug.WriteLineIf(DoubleBuffering.TraceInfo, "Dispose(" + disposing + ") {");
                Debug.Indent();

                if (disposing && compatGraphics != null) {
                    Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "Disposing compatGraphics");
                    compatGraphics.Dispose();
                    compatGraphics = null;
                }
                if (oldBitmap != IntPtr.Zero && compatDC != IntPtr.Zero) {
                    Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "restoring bitmap to DC");
                    SafeNativeMethods.SelectObject(new HandleRef(this, compatDC), new HandleRef(this, oldBitmap));
                    oldBitmap = IntPtr.Zero;
                }
                if (compatDC != IntPtr.Zero) {
                    Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "delete compat DC");
                    UnsafeNativeMethods.DeleteDC(new HandleRef(this, compatDC));
                    compatDC = IntPtr.Zero;
                }
                if (dib != IntPtr.Zero) {
                    Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "delete dib");
                    SafeNativeMethods.DeleteObject(new HandleRef(this, dib));
                    dib = IntPtr.Zero;
                }
                bufferWidth = -1;
                bufferHeight = -1;
                virtualWidth = -1;
                virtualHeight = -1;
                Debug.Unindent();
                Debug.WriteLineIf(DoubleBuffering.TraceInfo, "}");
            }

            private Graphics CreateBuffer(IntPtr src, int offsetX, int offsetY, int width, int height) {
                //NativeMethods.POINT pVp = new NativeMethods.POINT();

                if (width <= bufferWidth && height <= bufferHeight && compatDC != IntPtr.Zero) {
                    virtualWidth = width;
                    virtualHeight = height;

                    Debug.WriteLineIf(DoubleBuffering.TraceInfo, "Reusing compatible DC");
                    if (compatGraphics != null) {
                        Debug.WriteLineIf(DoubleBuffering.TraceInfo, "    Disposing compatGraphics");
                        compatGraphics.Dispose();
                        compatGraphics = null;
                    }

                    //SafeNativeMethods.SetViewportOrgEx(compatDC, offsetX, offsetY, pVp);
                    Debug.WriteLineIf(DoubleBuffering.TraceInfo, "    Create compatGraphics");
                    compatGraphics = Graphics.FromHdcInternal(compatDC);
                    compatGraphics.TranslateTransform(-targetX, -targetY);
                    return compatGraphics;
                }

                int optWidth = bufferWidth;
                int optHeight = bufferHeight;

                Dispose();

                Debug.WriteLineIf(DoubleBuffering.TraceInfo, "allocating new buffer: "+ width + " x " + height);
                Debug.WriteLineIf(DoubleBuffering.TraceInfo, "    old size         : "+ optWidth + " x " + optHeight);
                optWidth = Math.Max(width, optWidth);
                optHeight = Math.Max(height, optHeight);

                Debug.WriteLineIf(DoubleBuffering.TraceInfo, "    new size         : "+ optWidth + " x " + optHeight);
                IntPtr pvbits = IntPtr.Zero;
                dib = CreateCompatibleDIB(src, IntPtr.Zero, optWidth, optHeight, ref pvbits);
                compatDC = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, src));

                oldBitmap = SafeNativeMethods.SelectObject(new HandleRef(this, compatDC), new HandleRef(this, dib));

                //SafeNativeMethods.SetViewportOrgEx(compatDC, offsetX, offsetY, pVp);
                Debug.WriteLineIf(DoubleBuffering.TraceInfo, "    Create compatGraphics");
                compatGraphics = Graphics.FromHdcInternal(compatDC);
                compatGraphics.TranslateTransform(-targetX, -targetY);
                bufferWidth = optWidth;
                bufferHeight = optHeight;
                virtualWidth = width;
                virtualHeight = height;

                return compatGraphics;
            }

    #if DEBUG
            private void DumpBitmapInfo(ref NativeMethods.BITMAPINFO_FLAT pbmi) {
                //Debug.WriteLine("biSize --> " + pbmi.bmiHeader_biSize);
                Debug.WriteLine("biWidth --> " + pbmi.bmiHeader_biWidth);
                Debug.WriteLine("biHeight --> " + pbmi.bmiHeader_biHeight);
                Debug.WriteLine("biPlanes --> " + pbmi.bmiHeader_biPlanes);
                Debug.WriteLine("biBitCount --> " + pbmi.bmiHeader_biBitCount);
                //Debug.WriteLine("biCompression --> " + pbmi.bmiHeader_biCompression);
                //Debug.WriteLine("biSizeImage --> " + pbmi.bmiHeader_biSizeImage);
                //Debug.WriteLine("biXPelsPerMeter --> " + pbmi.bmiHeader_biXPelsPerMeter);
                //Debug.WriteLine("biYPelsPerMeter --> " + pbmi.bmiHeader_biYPelsPerMeter);
                //Debug.WriteLine("biClrUsed --> " + pbmi.bmiHeader_biClrUsed);
                //Debug.WriteLine("biClrImportant --> " + pbmi.bmiHeader_biClrImportant);
                //Debug.Write("bmiColors --> ");
                //for (int i=0; i<pbmi.bmiColors.Length; i++) {
                //    Debug.Write(pbmi.bmiColors[i].ToString("X"));
                //}
                Debug.WriteLine("");
            }
    #endif

            // CreateCompatibleDIB
            //
            // Create a DIB section with an optimal format w.r.t. the specified hdc.
            //
            // If DIB <= 8bpp, then the DIB color table is initialized based on the
            // specified palette.  If the palette handle is NULL, then the system
            // palette is used.
            //
            // Note: The hdc must be a direct DC (not an info or memory DC).
            //
            // Note: On palettized displays, if the system palette changes the
            //       UpdateDIBColorTable function should be called to maintain
            //       the identity palette mapping between the DIB and the display.
            //
            // Returns:
            //   Valid bitmap handle if successful, NULL if error.
            //
            // History:
            //  23-Jan-1996 -by- Gilman Wong [gilmanw]
            // Wrote it.
            //
            //  15-Nov-2000 -by- Chris Anderson [chrisan]
            // Ported it to C#.
            //
            private IntPtr CreateCompatibleDIB(IntPtr hdc, IntPtr hpal, int ulWidth, int ulHeight, ref IntPtr ppvBits) {
                if (hdc == IntPtr.Zero) {
                    throw new ArgumentNullException("hdc");
                }

                IntPtr hbmRet = IntPtr.Zero;
                NativeMethods.BITMAPINFO_FLAT pbmi = new NativeMethods.BITMAPINFO_FLAT();

                //
                // Validate hdc.
                //
                if (UnsafeNativeMethods.GetObjectType(new HandleRef(null, hdc)) != NativeMethods.OBJ_DC ) {
                    throw new ArgumentException("hdc");
                }

                if (bFillBitmapInfo(hdc, hpal, ref pbmi)) {

                    //
                    // Change bitmap size to match specified dimensions.
                    //

                    pbmi.bmiHeader_biWidth = ulWidth;
                    pbmi.bmiHeader_biHeight = ulHeight;
                    if (pbmi.bmiHeader_biCompression == NativeMethods.BI_RGB) {
                        pbmi.bmiHeader_biSizeImage = 0;
                    }
                    else {
                        if ( pbmi.bmiHeader_biBitCount == 16 )
                            pbmi.bmiHeader_biSizeImage = ulWidth * ulHeight * 2;
                        else if ( pbmi.bmiHeader_biBitCount == 32 )
                            pbmi.bmiHeader_biSizeImage = ulWidth * ulHeight * 4;
                        else
                            pbmi.bmiHeader_biSizeImage = 0;
                    }
                    pbmi.bmiHeader_biClrUsed = 0;
                    pbmi.bmiHeader_biClrImportant = 0;

                    //
                    // Create the DIB section.  Let Win32 allocate the memory and return
                    // a pointer to the bitmap surface.
                    //

                    hbmRet = SafeNativeMethods.CreateDIBSection(new HandleRef(null, hdc), ref pbmi, NativeMethods.DIB_RGB_COLORS, ref ppvBits, IntPtr.Zero, 0);

    #if DEBUG
                    if (DoubleBuffering.TraceVerbose) {
                        DumpBitmapInfo(ref pbmi);
                    }
    #endif

                    if ( hbmRet == IntPtr.Zero ) {
    #if DEBUG
                        DumpBitmapInfo(ref pbmi);
    #endif
                        throw new Win32Exception(Marshal.GetLastWin32Error());
                    }
                }

                return hbmRet;

            }

            // bFillBitmapInfo
            //
            // Fills in the fields of a BITMAPINFO so that we can create a bitmap
            // that matches the format of the display.
            //
            // This is done by creating a compatible bitmap and calling GetDIBits
            // to return the color masks.  This is done with two calls.  The first
            // call passes in biBitCount = 0 to GetDIBits which will fill in the
            // base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
            // in the BITMAPINFO filled in by the first call) will return the color
            // table or bitmasks, as appropriate.
            //
            // Returns:
            //   TRUE if successful, FALSE otherwise.
            //
            // History:
            //  07-Jun-1995 -by- Gilman Wong [gilmanw]
            // Wrote it.
            //
            //  15-Nov-2000 -by- Chris Anderson [chrisan]
            // Ported it to C#
            //
            private bool bFillBitmapInfo(IntPtr hdc, IntPtr hpal, ref NativeMethods.BITMAPINFO_FLAT pbmi) {
                IntPtr hbm = IntPtr.Zero;
                bool bRet = false;
                try {

                    //
                    // Create a dummy bitmap from which we can query color format info
                    // about the device surface.
                    //

                    hbm = SafeNativeMethods.CreateCompatibleBitmap(new HandleRef(null, hdc), 1, 1);

                    if (hbm == IntPtr.Zero) {
                        throw new OutOfMemoryException(SR.GetString(SR.GraphicsBufferQueryFail));
                    }

                    pbmi.bmiHeader_biSize = Marshal.SizeOf(typeof(NativeMethods.BITMAPINFOHEADER));
                    pbmi.bmiColors = new byte[NativeMethods.BITMAPINFO_MAX_COLORSIZE*4];

                    //
                    // Call first time to fill in BITMAPINFO header.
                    //

                    IntPtr diRet = SafeNativeMethods.GetDIBits(new HandleRef(null, hdc), 
                                                        new HandleRef(null, hbm), 
                                                        0, 
                                                        0, 
                                                        IntPtr.Zero, 
                                                        ref pbmi, 
                                                        NativeMethods.DIB_RGB_COLORS);

                    if ( pbmi.bmiHeader_biBitCount <= 8 ) {
                        bRet = bFillColorTable(hdc, hpal, ref pbmi);
                    }
                    else {
                        if ( pbmi.bmiHeader_biCompression == NativeMethods.BI_BITFIELDS ) {

                            //
                            // Call a second time to get the color masks.
                            // It's a GetDIBits Win32 "feature".
                            //

                            SafeNativeMethods.GetDIBits(new HandleRef(null, hdc), 
                                                    new HandleRef(null, hbm), 
                                                    0, 
                                                    pbmi.bmiHeader_biHeight, 
                                                    IntPtr.Zero, 
                                                    ref pbmi,
                                                    NativeMethods.DIB_RGB_COLORS);
                        }

                        bRet = true;
                    }
                }
                finally {
                    if (hbm != IntPtr.Zero) {
                        SafeNativeMethods.DeleteObject(new HandleRef(null, hbm));
                        hbm = IntPtr.Zero;
                    }
                }

                return bRet;
            }

            // bFillColorTable
            //
            // Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
            // are set to the current system palette.
            //
            // Note: call only valid for displays of 8bpp or less.
            //
            // Returns:
            //   TRUE if successful, FALSE otherwise.
            //
            // History:
            //  23-Jan-1996 -by- Gilman Wong [gilmanw]
            // Wrote it.
            //
            //  15-Nov-2000 -by- Chris Anderson [chrisan]
            // Ported it to C#
            //
            private unsafe bool bFillColorTable(IntPtr hdc, IntPtr hpal, ref NativeMethods.BITMAPINFO_FLAT pbmi) {
                bool bRet = false;
                byte[] aj = new byte[sizeof(NativeMethods.PALETTEENTRY) * 256];
                int i, cColors;

                fixed (byte* pcolors = pbmi.bmiColors) {
                    fixed (byte* ppal = aj) {
                        NativeMethods.RGBQUAD* prgb = (NativeMethods.RGBQUAD*)pcolors;
                        NativeMethods.PALETTEENTRY* lppe = (NativeMethods.PALETTEENTRY*)ppal;


                        cColors = 1 << pbmi.bmiHeader_biBitCount;
                        if ( cColors <= 256 ) {
                            Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "8 bit or less...");

                            // NOTE : Didn't port "MyGetPaletteEntries" as it is only
                            //      : for 4bpp displays, which we don't work on anyway.
                            IntPtr palRet;
                            IntPtr palHalftone = IntPtr.Zero;
                            if (hpal == IntPtr.Zero) {
                                Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "using halftone palette...");
                                palHalftone = Graphics.GetHalftonePalette();
                                palRet = SafeNativeMethods.GetPaletteEntries(new HandleRef(null, palHalftone), 0, cColors, aj);
                            }
                            else {
                                Debug.WriteLineIf(DoubleBuffering.TraceVerbose, "using custom palette...");
                                palRet = SafeNativeMethods.GetPaletteEntries(new HandleRef(null, hpal), 0, cColors, aj);
                            }
                            if ( palRet != IntPtr.Zero ) {
                                for (i = 0; i < cColors; i++) {
                                    prgb[i].rgbRed      = lppe[i].peRed;
                                    prgb[i].rgbGreen    = lppe[i].peGreen;
                                    prgb[i].rgbBlue     = lppe[i].peBlue;
                                    prgb[i].rgbReserved = 0;
                                }

                                bRet = true;
                            }
                            else {
                                Debug.WriteLine("bFillColorTable: MyGetSystemPaletteEntries failed\n");
                            }
                        }
                    }
                }


                return bRet;
            }
        }
    }


    /*
    internal class BitmapGraphicsBuffer : GraphicsBuffer {
        int bufferWidth;
        int bufferHeight;
        Bitmap surface;
        Graphics buffer;

        private void CleanNative() {
            if (buffer != null) {
                buffer.Dispose();
                buffer = null;
            }
            if (surface != null) {
                surface.Dispose();
                surface = null;
            }
        }

        public override Graphics RequestBuffer(Graphics dest, int width, int height) {
            if (width == bufferWidth && height == bufferHeight && buffer != null) {
                return buffer;
            }

            CleanNative();
            surface = new Bitmap(width, height);
            buffer = Graphics.FromImage(surface);
            buffer.FillRectangle(new SolidBrush(Color.Black), 0, 0, width, height);
            bufferWidth = width;
            bufferHeight = height;
            return buffer;
        }

        public override void PaintBuffer(Graphics dest, int x, int y) {
            buffer.SetClip(new Rectangle(0, 0, bufferWidth, bufferHeight));
            dest.DrawImage(surface, x, y);
        }
        public override void PaintBuffer(IntPtr hdc, int x, int y) {
            buffer.SetClip(new Rectangle(0, 0, bufferWidth, bufferHeight));
            using (Graphics dest = Graphics.FromHdc(hdc)) {
                dest.DrawImage(surface, x, y);
            }
        }
        public override void Dispose() {
            CleanNative();
        }
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\givefeedbackeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="GiveFeedbackEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\GiveFeedbackEventHandler.uex' path='docs/doc[@for="GiveFeedbackEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that handles the <see cref='System.Windows.Forms.Control.GiveFeedback'/> event
    ///       of a <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void GiveFeedbackEventHandler(object sender, GiveFeedbackEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\groupbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="GroupBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Text;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Security.Permissions;

    /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Encapsulates
    ///       a standard Windows(r) group
    ///       box.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("Enter"),
    DefaultProperty("Text"),
    Designer("System.Windows.Forms.Design.GroupBoxDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class GroupBox : Control {
        int fontHeight = -1;
        FlatStyle flatStyle = FlatStyle.Standard;

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.GroupBox"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.GroupBox'/> class.
        ///    </para>
        /// </devdoc>
        public GroupBox()
        : base() {
            SetStyle(ControlStyles.ContainerControl, true);
            SetStyle(ControlStyles.SupportsTransparentBackColor |
                     ControlStyles.UserPaint |
                     ControlStyles.ResizeRedraw, OwnerDraw);
                     
            SetStyle(ControlStyles.Selectable, false);
            TabStop = false;
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.AllowDrop"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the control will allow drag and
        ///       drop operations and events to be used.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public override bool AllowDrop {
            get {
                return base.AllowDrop;
            }
            set {
                base.AllowDrop = value;
            }
        }
        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.CreateParams"]/*' />
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                if (!OwnerDraw) {
                    cp.ClassName = "BUTTON";
                    cp.Style |= NativeMethods.BS_GROUPBOX;
                }
                cp.ExStyle |= NativeMethods.WS_EX_CONTROLPARENT;

                return cp;
            }
        }
        
        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(200, 100);
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.DisplayRectangle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets a rectangle that represents the
        ///       dimensions of the <see cref='System.Windows.Forms.GroupBox'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public override Rectangle DisplayRectangle {
            get {
                Size size = ClientSize;
                if (fontHeight == -1) {
                    fontHeight = (int)Font.Height;
                }
                return new Rectangle(3, fontHeight + 3, Math.Max(size.Width - 6, 0), Math.Max(size.Height - fontHeight - 6, 0));
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.FlatStyle"]/*' />
        [
            SRCategory(SR.CatAppearance),
            DefaultValue(FlatStyle.Standard),
            SRDescription(SR.ButtonFlatStyleDescr)
        ]
        public FlatStyle FlatStyle {
            get {
                return flatStyle;
            }
            set {
                if (!Enum.IsDefined(typeof(FlatStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FlatStyle));
                }
                
                if (flatStyle != value) {
                    bool needRecreate = (flatStyle == FlatStyle.System) || (value == FlatStyle.System);
                    
                    flatStyle = value;
                    
                    SetStyle(ControlStyles.SupportsTransparentBackColor, OwnerDraw);
                    SetStyle(ControlStyles.UserPaint, OwnerDraw);
                    SetStyle(ControlStyles.UserMouse, OwnerDraw);
                    SetStyle(ControlStyles.ResizeRedraw, OwnerDraw);
                    
                    if (needRecreate) {
                        RecreateHandle();
                    }
                    else {
                        Refresh();
                    }
                }
            }
        }
        
        private bool OwnerDraw {
            get {
                return FlatStyle != FlatStyle.System;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.TabStop"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the user may
        ///       press the TAB key to give the focus to the <see cref='System.Windows.Forms.GroupBox'/>
        ///       .
        ///       
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }
        
        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override string Text {
            get{
                return base.Text;
            }
            set {
               // the GroupBox controls immediately draws when teh WM_SETTEXT comes through, but
               // does so in the wrong font, so we suspend that behavior, and then
               // invalidate.
               bool suspendRedraw = this.Visible;
               try {
                    if (suspendRedraw && IsHandleCreated) {
                        SendMessage(NativeMethods.WM_SETREDRAW, 0, 0);
                    }
                    base.Text = value;
               }
               finally {
                    if (suspendRedraw && IsHandleCreated) {
                        SendMessage(NativeMethods.WM_SETREDRAW, 1, 0);
                    }
               }
               Invalidate(true);
            }
        } 

       
        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.Click"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.KeyUp"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event KeyEventHandler KeyUp {
            add {
                base.KeyUp += value;
            }
            remove {
                base.KeyUp -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.KeyDown"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event KeyEventHandler KeyDown {
            add {
                base.KeyDown += value;
            }
            remove {
                base.KeyDown -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.KeyPress"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event KeyPressEventHandler KeyPress {
            add {
                base.KeyPress += value;
            }
            remove {
                base.KeyPress -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.MouseDown"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event MouseEventHandler MouseDown {
            add {
                base.MouseDown += value;
            }
            remove {
                base.MouseDown -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.MouseUp"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event MouseEventHandler MouseUp {
            add {
                base.MouseUp += value;
            }
            remove {
                base.MouseUp -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.MouseMove"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event MouseEventHandler MouseMove {
            add {
                base.MouseMove += value;
            }
            remove {
                base.MouseMove -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.MouseEnter"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler MouseEnter {
            add {
                base.MouseEnter += value;
            }
            remove {
                base.MouseEnter -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.MouseLeave"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler MouseLeave {
            add {
                base.MouseLeave += value;
            }
            remove {
                base.MouseLeave -= value;
            }
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.OnPaint"]/*' />
        /// <internalonly/>
        protected override void OnPaint(PaintEventArgs e) {
            Graphics graphics = e.Graphics;
            Rectangle textRectangle = ClientRectangle;
            
            int textOffset = 8;
            textRectangle.X += textOffset;
            textRectangle.Width -= 2 * textOffset;

            Brush textBrush = new SolidBrush(ForeColor);
            StringFormat format = new StringFormat();
            
            if (ShowKeyboardCues) {
                format.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Show;
            }
            else {
                format.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Hide;
            }
            
            // Adjust string format for Rtl controls
            if (RightToLeft == RightToLeft.Yes) {
                format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;                
            }
            
            Size textSize = Size.Ceiling(graphics.MeasureString(Text, Font, textRectangle.Width, format));
            
            Color backColor = DisabledColor;

            if (Enabled)
                graphics.DrawString(Text, Font, textBrush, textRectangle, format);
            else
                ControlPaint.DrawStringDisabled(graphics, Text, Font, backColor, textRectangle, format);

            format.Dispose();
            textBrush.Dispose();

            Pen light = new Pen(ControlPaint.Light(backColor, 1.0f));
            Pen dark = new Pen(ControlPaint.Dark(backColor, 0f));

            int textLeft = textOffset;
            if (RightToLeft == RightToLeft.Yes) {
                textLeft = textOffset + textRectangle.Width - textSize.Width;
            }

            int boxTop = FontHeight / 2;
            
            // left
            graphics.DrawLine(light, 1, boxTop, 1, Height - 1);
            graphics.DrawLine(dark, 0, boxTop, 0, Height - 2);

            // bottom
            graphics.DrawLine(light, 0, Height - 1, Width, Height - 1);
            graphics.DrawLine(dark, 0, Height - 2, Width - 1, Height - 2);

            // top-left
            graphics.DrawLine(dark, 0, boxTop - 1, textLeft, boxTop - 1);
            graphics.DrawLine(light, 1, boxTop, textLeft, boxTop);

            // top-right
            graphics.DrawLine(dark, textLeft + textSize.Width, boxTop - 1, Width - 2, boxTop - 1);
            graphics.DrawLine(light, textLeft + textSize.Width, boxTop, Width - 1, boxTop);

            // right
            graphics.DrawLine(light, Width - 1, boxTop - 1, Width - 1, Height - 1);
            graphics.DrawLine(dark, Width - 2, boxTop, Width - 2, Height - 2);

            // light.Dispose();
            // dark.Dispose();

            base.OnPaint(e); // raise paint event
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.OnFontChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            fontHeight = -1;
            Invalidate();
            base.OnFontChanged(e);
            PerformLayout();
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.ProcessMnemonic"]/*' />
        /// <devdoc>
        ///     We use this to process mnemonics and send them on to the first child
        ///     control.
        /// </devdoc>
        /// <internalonly/>
        protected override bool ProcessMnemonic(char charCode) {
            if (IsMnemonic(charCode, Text) && CanProcessMnemonic()) {
                IntSecurity.ModifyFocus.Assert();
                try {
                    SelectNextControl(null, true, true, true, false);
                }
                finally {
                    System.Security.CodeAccessPermission.RevertAssert();
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Text: " + Text;
        }
        /// <summary>
        ///     The Windows group box doesn't erase the background so we do it
        ///     ourselves here.
        /// </summary>
        /// <internalonly/>
        private void WmEraseBkgnd(ref Message m) {
            NativeMethods.RECT rect = new NativeMethods.RECT();
            SafeNativeMethods.GetClientRect(new HandleRef(this, Handle), ref rect);
            Graphics graphics = Graphics.FromHdcInternal(m.WParam);
            Brush b = new SolidBrush(BackColor);
            graphics.FillRectangle(b, rect.left, rect.top,
                                   rect.right - rect.left, rect.bottom - rect.top);
            graphics.Dispose();
            b.Dispose();
            m.Result = (IntPtr)1;
        }

        /// <include file='doc\GroupBox.uex' path='docs/doc[@for="GroupBox.WndProc"]/*' />
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            if (OwnerDraw) {
                base.WndProc(ref m);
                return;
            }

            switch (m.Msg) {
                case NativeMethods.WM_ERASEBKGND:
                case NativeMethods.WM_PRINTCLIENT:
                    WmEraseBkgnd(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\griditemtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridItemType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Windows.Forms;

    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms.PropertyGridInternal;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
       
    /// <include file='doc\GridItemType.uex' path='docs/doc[@for="GridItemType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum GridItemType {
        /// <include file='doc\GridItemType.uex' path='docs/doc[@for="GridItemType.Property"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Property,
        /// <include file='doc\GridItemType.uex' path='docs/doc[@for="GridItemType.Category"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Category,
        /// <include file='doc\GridItemType.uex' path='docs/doc[@for="GridItemType.ArrayValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ArrayValue, 
        /// <include file='doc\GridItemType.uex' path='docs/doc[@for="GridItemType.Root"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Root
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\helpevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;    
    using Microsoft.Win32;


    /// <include file='doc\HelpEvent.uex' path='docs/doc[@for="HelpEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the Control.HelpRequest event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class HelpEventArgs : EventArgs {
        private readonly Point mousePos;
        private bool           handled = false;

        /// <include file='doc\HelpEvent.uex' path='docs/doc[@for="HelpEventArgs.HelpEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.HelpEventArgs'/>class.
        ///    </para>
        /// </devdoc>
        public HelpEventArgs(Point mousePos) {
            this.mousePos = mousePos;
        }

        /// <include file='doc\HelpEvent.uex' path='docs/doc[@for="HelpEventArgs.MousePos"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the screen coordinates of the mouse pointer.
        ///    </para>
        /// </devdoc>
        public Point MousePos {
            get {
                return mousePos;
            }
        }

        /// <include file='doc\HelpEvent.uex' path='docs/doc[@for="HelpEventArgs.Handled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating
        ///       whether the Help event was handled.
        ///    </para>
        /// </devdoc>
        public bool Handled {
            get {
                return handled;
            }
            set {
                handled = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\helpnavigator.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpNavigator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1997, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/

namespace System.Windows.Forms {
    using System;

    /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the HTML 1.0 Help engine.
    ///    </para>
    /// </devdoc>
    public enum HelpNavigator {

        /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator.Topic"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the topic referenced by the topic referenced by
        ///       the specified Url.
        ///       This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        Topic = unchecked((int)0x80000001),
        /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator.TableOfContents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the contents of the 
        ///       HTML 1.0 Help file. This field is constant.
        ///    </para>
        /// </devdoc>
        TableOfContents = unchecked((int)0x80000002),
        /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator.Index"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the index of a specified
        ///       Url. This field is constant.
        ///    </para>
        /// </devdoc>
        Index = unchecked((int)0x80000003),
        /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator.Find"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the search page
        ///       of a specified Url. This field is constant.
        ///    </para>
        /// </devdoc>
        Find = unchecked((int)0x80000004),
        /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator.AssociateIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the topic referenced by the topic referenced by
        ///       the specified Url.
        ///       This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        AssociateIndex = unchecked((int)0x80000005),
        /// <include file='doc\HelpNavigator.uex' path='docs/doc[@for="HelpNavigator.KeywordIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the topic referenced by the topic referenced by
        ///       the specified Url.
        ///       This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        KeywordIndex = unchecked((int)0x80000006)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\help.cs ===
//------------------------------------------------------------------------------
// <copyright file="Help.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1997, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/

namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Net;
    using System.Drawing;
    using System.ComponentModel;
    using System.IO;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Globalization;
    
    /// <include file='doc\Help.uex' path='docs/doc[@for="Help"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the HTML 1.0 Help engine.
    ///    </para>
    /// </devdoc>
    public class Help {
#if DEBUG        
        internal static readonly TraceSwitch WindowsFormsHelpTrace = new TraceSwitch("WindowsFormsHelpTrace", "Debug help system");
#else
        internal static readonly TraceSwitch WindowsFormsHelpTrace;
#endif

        private const int HH_DISPLAY_TOPIC        =0x0000;
        private const int HH_HELP_FINDER          =0x0000;  // WinHelp equivalent
        private const int HH_DISPLAY_TOC          =0x0001;  // not currently implemented
        private const int HH_DISPLAY_INDEX        =0x0002;  // not currently implemented
        private const int HH_DISPLAY_SEARCH       =0x0003;  // not currently implemented
        private const int HH_SET_WIN_TYPE         =0x0004;
        private const int HH_GET_WIN_TYPE         =0x0005;
        private const int HH_GET_WIN_HANDLE       =0x0006;
        private const int HH_ENUM_INFO_TYPE       =0x0007;  // Get Info type name, call repeatedly to enumerate, -1 at end
        private const int HH_SET_INFO_TYPE        =0x0008;  // Add Info type to filter.
        private const int HH_SYNC                 =0x0009;
        private const int HH_ADD_NAV_UI           =0x000A;  // not currently implemented
        private const int HH_ADD_BUTTON           =0x000B;  // not currently implemented
        private const int HH_GETBROWSER_APP       =0x000C;  // not currently implemented
        private const int HH_KEYWORD_LOOKUP       =0x000D;
        private const int HH_DISPLAY_TEXT_POPUP   =0x000E;  // display string resource id or text in a popup window
        private const int HH_HELP_CONTEXT         =0x000F;  // display mapped numeric value in dwData
        private const int HH_TP_HELP_CONTEXTMENU  =0x0010;  // text popup help, same as WinHelp HELP_CONTEXTMENU
        private const int HH_TP_HELP_WM_HELP      =0x0011;  // text popup help, same as WinHelp HELP_WM_HELP
        private const int HH_CLOSE_ALL            =0x0012;  // close all windows opened directly or indirectly by the caller
        private const int HH_ALINK_LOOKUP         =0x0013;  // ALink version of HH_KEYWORD_LOOKUP
        private const int HH_GET_LAST_ERROR       =0x0014;  // not currently implemented // See HHERROR.h
        private const int HH_ENUM_CATEGORY        =0x0015;   // Get category name, call repeatedly to enumerate, -1 at end
        private const int HH_ENUM_CATEGORY_IT     =0x0016;  // Get category info type members, call repeatedly to enumerate, -1 at end
        private const int HH_RESET_IT_FILTER      =0x0017;  // Clear the info type filter of all info types.
        private const int HH_SET_INCLUSIVE_FILTER =0x0018;  // set inclusive filtering method for untyped topics to be included in display
        private const int HH_SET_EXCLUSIVE_FILTER =0x0019;  // set exclusive filtering method for untyped topics to be excluded from display
        private const int HH_SET_GUID             =0x001A;  // For Microsoft Installer -- dwData is a pointer to the GUID string

        private const int HTML10HELP = 2;
        private const int HTMLFILE   = 3;

        // not creatable
        //
        private Help() {
        }        

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays
        ///       the contents of the Help file at located at a specified Url.
        ///    </para>
        /// </devdoc>
        public static void ShowHelp(Control parent, string url) {
            ShowHelp(parent, url, HelpNavigator.TableOfContents, null);
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHelp1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the contents of
        ///       the Help
        ///       file for a specific topic found at the specified Url.
        ///    </para>
        /// </devdoc>
        public static void ShowHelp(Control parent, string url, HelpNavigator navigator) {
            ShowHelp(parent, url, navigator, null);
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHelp2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the contents of
        ///       the Help
        ///       file for a specific topic found at the specified Url.
        ///    </para>
        /// </devdoc>
        public static void ShowHelp(Control parent, string url, string keyword) {
            if (keyword != null && keyword.Length != 0) {
                ShowHelp(parent, url, HelpNavigator.Topic, keyword);
            }
            else {
                ShowHelp(parent, url, HelpNavigator.TableOfContents, null);
            }
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHelp3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the contents of the Help file located at
        ///       the Url
        ///       supplied by the
        ///       user.
        ///    </para>
        /// </devdoc>
        public static void ShowHelp(Control parent, string url, HelpNavigator command, object param) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: ShowHelp");

            switch (GetHelpFileType(url)) {
                case HTML10HELP:
                    ShowHTML10Help(parent, url, command, param);
                    break;
                case HTMLFILE:
                    ShowHTMLFile(parent, url, command, param);
                    break;
            }
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHelpIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the index of the specified file.
        ///    </para>
        /// </devdoc>
        public static void ShowHelpIndex(Control parent, string url) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: ShowHelpIndex");

            ShowHelp(parent, url, HelpNavigator.Index, null);
        }
 
        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowPopup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a Help pop-up window.
        ///    </para>
        /// </devdoc>
        public static void ShowPopup(Control parent, string caption, Point location) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: ShowPopup");

            NativeMethods.HH_POPUP pop = new NativeMethods.HH_POPUP();
 
            // ASURT 148069
            // HtmlHelpW overwrites the pszText pointer in the HH_POPUP structure
            // so we've got to explicitly allocate and free the memory ourselves
            // rather than depending on the marshaller.
	    IntPtr pszText = Marshal.StringToCoTaskMemAuto(caption);
	    
	    try {
               pop.pszText = pszText;
               pop.idString = 0;
               pop.pt = new NativeMethods.POINT(location.X, location.Y);

               // ASURT 108580
               // Looks like a windows bug causes the -1 value for clrBackground to not
               // do the right thing for High Contrast Black color scheme (and probably others)
               //
               pop.clrBackground = Color.FromKnownColor(KnownColor.Window).ToArgb() & 0x00ffffff;
          
               ShowHTML10Help(parent, null, HelpNavigator.Topic, pop);
            }
            finally {
               Marshal.FreeCoTaskMem(pszText);
            }
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHTML10Help"]/*' />
        /// <devdoc>
        ///     Displays HTML 1.0 Help with the specified parameters
        /// </devdoc>
        /// <internalonly/>
        private static void ShowHTML10Help(Control parent, string url, HelpNavigator command, object param) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: ShowHTML10Help:: " + url + ", " + command.ToString("G") + ", " + param);

            object htmlParam;
            if (param is string) {
                int htmlCommand = MapCommandToHTMLCommand(command, (string)param, out htmlParam);
                
                if (htmlParam is string) {
                    SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, htmlCommand, (string)htmlParam);
                }
                else if (htmlParam is NativeMethods.HH_FTS_QUERY) {
                    SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, htmlCommand, (NativeMethods.HH_FTS_QUERY)htmlParam);
                }
                else if (htmlParam is NativeMethods.HH_AKLINK) {
                    // According to MSDN documentation, we have to ensure that the help window is up
                    // before we call ALINK lookup.
                    //
                    SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, HH_DISPLAY_TOPIC, (string)null);
                    SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, htmlCommand, (NativeMethods.HH_AKLINK)htmlParam);
                }
                else {
                    Debug.Fail("Cannot handle HTML parameter of type: " + htmlParam.GetType());
                    SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, htmlCommand, (string)param);
                }
            }
            else if (param == null) {
                SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, MapCommandToHTMLCommand(command, null, out htmlParam), 0);
            }
            else if (param is NativeMethods.HH_POPUP) {
                SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, HH_DISPLAY_TEXT_POPUP, (NativeMethods.HH_POPUP)param);
            }
            else if (param.GetType() == typeof(Int32)) {
                SafeNativeMethods.HtmlHelp(new HandleRef(parent, parent.Handle), url, MapCommandToHTMLCommand(command, null, out htmlParam), (int)param);
            }
        }


        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.ShowHTMLFile"]/*' />
        /// <devdoc>
        ///     Displays HTMLFile with the specified parameters
        /// </devdoc>
        /// <internalonly/>
        private static void ShowHTMLFile(Control parent, string url, HelpNavigator command, object param) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: ShowHTMLHelp:: " + url + ", " + command.ToString("G") + ", " + param);

            Uri file = Resolve(url);

            if (file == null) {
                throw new ArgumentException(SR.GetString(SR.HelpInvalidURL, url), "url");
            }

            switch (file.Scheme) {
                case "http":
                case "https":
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "WebPermission Demanded");
                    new WebPermission(NetworkAccess.Connect, url).Demand();
                    break;
                default:
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "UnmanagedCode Demanded");
                    IntSecurity.UnmanagedCode.Demand();
                    break;
            }

            switch (command) {
                case HelpNavigator.TableOfContents:
                case HelpNavigator.Find:
                case HelpNavigator.Index:
                    // nothing needed...
                    //
                    break;
                case HelpNavigator.Topic:
                    if (param != null && param is string) {
                        file = new Uri(file.ToString() + "#" + (string)param);
                    }
                    break;
            }

            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "\tExecuting '" + file.ToString() + "'");
            UnsafeNativeMethods.ShellExecute_NoBFM(new HandleRef(parent, parent.Handle), null, file.ToString(), null, null, NativeMethods.SW_NORMAL);
        }

        private static Uri Resolve(string partialUri) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: Resolve " + partialUri);
            Debug.Indent();

            Uri file = null;
            try {
                file = new Uri(partialUri);
            }
            catch {
                // eat URI parse exceptions...
                //
            }

            if (file != null && file.Scheme == "file") {
                string localPath = NativeMethods.GetLocalPath(partialUri);
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "file, check for existence");
                new FileIOPermission(FileIOPermissionAccess.Read, localPath).Assert();
                try {
                    if (!File.Exists(localPath)) {
                        // nuke, and try relative to AppBase...
                        //
                        file = null;
                    }
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }

            if (file == null) {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "try appbase relative");
                try {
                    // try relative to AppBase...
                    //
                    file = new Uri(new Uri(AppDomain.CurrentDomain.SetupInformation.ApplicationBase), 
                                   partialUri);
                }
                catch {
                    // eat URI parse exceptions...
                    //
                }

                if (file != null && file.Scheme == "file") {
                    string localPath = file.LocalPath + file.Fragment;
                    Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "file, check for existence");
                    new FileIOPermission(FileIOPermissionAccess.Read, localPath).Assert();
                    try {
                        if (!File.Exists(localPath)) {
                            // nuke - file isn't there...
                            //
                            file = null;
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }



            Debug.Unindent();
            return file;
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.GetHelpFileType"]/*' />
        /// <internalonly/>
        private static int GetHelpFileType(string url) {
            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "Help:: GetHelpFileType " + url);

            if (url == null) {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "\tnull, must be Html File");
                return HTMLFILE;
            }

            Uri file = Resolve(url);

            if (file == null || file.Scheme == "file") {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "\tfile");

                string ext = Path.GetExtension(file == null ? url : file.LocalPath + file.Fragment).ToLower(CultureInfo.InvariantCulture);
                if (ext == ".chm" || ext == ".col") {
                    Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "\tchm or col, HtmlHelp 1.0 file");
                    return HTML10HELP;
                }
            }

            Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "\tnot file, or odd extension, but be HTML");
            return HTMLFILE;
        }

        /// <include file='doc\Help.uex' path='docs/doc[@for="Help.MapCommandToHTMLCommand"]/*' />
        /// <devdoc>
        ///     Maps one of the COMMAND_* constants to the HTML 1.0 Help equivalent.
        /// </devdoc>
        /// <internalonly/>
        private static int MapCommandToHTMLCommand(HelpNavigator command, string param, out object htmlParam) {
            htmlParam = param;

            if ((param == null || param == "") &&
                (command == HelpNavigator.AssociateIndex || command == HelpNavigator.KeywordIndex)) {
                return HH_DISPLAY_INDEX;
            }

            switch (command) {
                case HelpNavigator.Topic:
                    return HH_DISPLAY_TOPIC;
                
                case HelpNavigator.TableOfContents:
                    return HH_DISPLAY_TOC;
                
                case HelpNavigator.Index:
                    return HH_DISPLAY_INDEX;
                
                case HelpNavigator.Find: {
                    NativeMethods.HH_FTS_QUERY ftsQuery = new NativeMethods.HH_FTS_QUERY();
                    ftsQuery.pszSearchQuery = param;
                    htmlParam = ftsQuery;
                    return HH_DISPLAY_SEARCH;
                }
                
                case HelpNavigator.KeywordIndex:
                case HelpNavigator.AssociateIndex: {
                    NativeMethods.HH_AKLINK alink = new NativeMethods.HH_AKLINK();
                    alink.pszKeywords = param;
                    alink.fIndexOnFail = true;
                    htmlParam = alink;
                    return (command == HelpNavigator.KeywordIndex) ? HH_KEYWORD_LOOKUP : HH_ALINK_LOOKUP;
                }
                
                default:
                    return (int)command;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\helpeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\HelpEventHandler.uex' path='docs/doc[@for="HelpEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the Help event of a Control.
    ///    </para>
    /// </devdoc>
    public delegate void HelpEventHandler(object sender, HelpEventArgs hlpevent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\horizontalalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="HorizontalAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\HorizontalAlignment.uex' path='docs/doc[@for="HorizontalAlignment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how an object or text in a control is
    ///       horizontally aligned relative to an element of the control.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum HorizontalAlignment {

        /// <include file='doc\HorizontalAlignment.uex' path='docs/doc[@for="HorizontalAlignment.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is aligned on the left of the control element.
        ///    </para>
        /// </devdoc>
        Left = 0,

        /// <include file='doc\HorizontalAlignment.uex' path='docs/doc[@for="HorizontalAlignment.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is aligned on the right of the control element.
        ///    </para>
        /// </devdoc>
        Right = 1,

        /// <include file='doc\HorizontalAlignment.uex' path='docs/doc[@for="HorizontalAlignment.Center"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is aligned in the center of the control element.
        ///    </para>
        /// </devdoc>
        Center = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\ibuttoncontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="IButtonControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    /*
     * Copyright (c) 1997, Microsoft Corporation. All Rights Reserved.
     * Information Contained Herein is Proprietary and Confidential.
     *
     * @security(checkClassLinking=on)
     */

    using System;

    /// <include file='doc\IButtonControl.uex' path='docs/doc[@for="IButtonControl"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Allows a control to act like a button
    ///       on a form.
    ///       
    ///    </para>
    /// </devdoc>
    public interface IButtonControl {

        /// <include file='doc\IButtonControl.uex' path='docs/doc[@for="IButtonControl.DialogResult"]/*' />
        /// <devdoc>
        ///    <para>Gets and sets the dialog result of the Button control. This is 
        ///       used as the result for the dialog on which the button is set to 
        ///       be an "accept" or "cancel" button.
        ///       </para>
        /// </devdoc>
        DialogResult DialogResult {get; set;}
        
        /// <include file='doc\IButtonControl.uex' path='docs/doc[@for="IButtonControl.NotifyDefault"]/*' />
        /// <devdoc>
        ///    <para>Notifies a control that it is the default button so that its appearance and behavior
        ///       is adjusted accordingly.
        ///       </para>
        /// </devdoc>
        void NotifyDefault(bool value);

        /// <include file='doc\IButtonControl.uex' path='docs/doc[@for="IButtonControl.PerformClick"]/*' />
        /// <devdoc>
        /// <para>Generates a <see cref='System.Windows.Forms.Control.Click'/>
        /// event for the control.</para>
        /// </devdoc>
        void PerformClick();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\icommandexecutor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICommandExecutor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\ICommandExecutor.uex' path='docs/doc[@for="ICommandExecutor"]/*' />
    /// <devdoc>
    /// </devdoc>
    /// <internalonly/>
    public interface ICommandExecutor {
        /// <include file='doc\ICommandExecutor.uex' path='docs/doc[@for="ICommandExecutor.Execute"]/*' />
        void Execute();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\helpprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using Hashtable = System.Collections.Hashtable;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    

    /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides pop-up or online Help for controls.
    ///    </para>
    /// </devdoc>
    [
    ProvideProperty("HelpString", typeof(Control)),
    ProvideProperty("HelpKeyword", typeof(Control)),
    ProvideProperty("HelpNavigator", typeof(Control)),
    ProvideProperty("ShowHelp", typeof(Control)),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public class HelpProvider : Component, IExtenderProvider {

        private string helpNamespace = null;
        private Hashtable helpStrings = new Hashtable();
        private Hashtable showHelp = new Hashtable();
        private Hashtable boundControls = new Hashtable();
        private Hashtable keywords = new Hashtable();
        private Hashtable navigators = new Hashtable();

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.HelpProvider"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.HelpProvider'/> class.
        ///    </para>
        /// </devdoc>
        public HelpProvider() {
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.HelpNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a string indicating the name of the Help
        ///       file associated with this <see cref='System.Windows.Forms.HelpProvider'/> object.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(null),
        Editor("System.Windows.Forms.Design.HelpNamespaceEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        SRDescription(SR.HelpProviderHelpNamespaceDescr)
        ]
        public virtual string HelpNamespace {
            get {
                return helpNamespace;
            }

            set {
                this.helpNamespace = value;
            }
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.CanExtend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the help provider can offer it's extender properties
        ///       to the specified target object.
        ///    </para>
        /// </devdoc>
        public virtual bool CanExtend(object target) {
            return(target is Control);
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.GetHelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the Help Keyword displayed when the
        ///       user invokes Help for the specified control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        Localizable(true),
        SRDescription(SR.HelpProviderHelpKeywordDescr)
        ]
        public virtual string GetHelpKeyword(Control ctl) {
            return(string)keywords[ctl];
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.GetHelpNavigator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the contents of the pop-up help window for the specified
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(HelpNavigator.AssociateIndex),
        Localizable(true),
        SRDescription(SR.HelpProviderNavigatorDescr)
        ]
        public virtual HelpNavigator GetHelpNavigator(Control ctl) {
            object nav = navigators[ctl];
            return (nav == null) ? HelpNavigator.AssociateIndex : (HelpNavigator)nav;
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.GetHelpString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the contents of the pop-up help window for the specified
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        Localizable(true),
        SRDescription(SR.HelpProviderHelpStringDescr)
        ]
        public virtual string GetHelpString(Control ctl) {
            return(string)helpStrings[ctl];
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.GetShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a value indicating whether Help displays for
        ///       the specified control.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.HelpProviderShowHelpDescr)
        ]
        public virtual bool GetShowHelp(Control ctl) {
            object b = showHelp[ctl];
            if (b == null) {
                return false;
            }
            else {
                return(Boolean) b;
            }
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.OnControlHelp"]/*' />
        /// <devdoc>
        ///     Handles the help event for any bound controls.
        /// </devdoc>
        /// <internalonly/>
        private void OnControlHelp(object sender, HelpEventArgs hevent) {
            Control ctl = (Control)sender;
            string helpString = GetHelpString(ctl);
            string keyword = GetHelpKeyword(ctl);
            HelpNavigator navigator = GetHelpNavigator(ctl);
            bool show = GetShowHelp(ctl);

            if (!show) {
                return;
            }

            // If the mouse was down, we first try whats this help
            //
            if (Control.MouseButtons != MouseButtons.None && helpString != null) {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "HelpProvider:: Mouse down w/ helpstring");

                if (helpString.Length > 0) {
                    Help.ShowPopup(ctl, helpString, hevent.MousePos);
                    hevent.Handled = true;
                }
            }

            // If we have a help file, and help keyword we try F1 help next
            //
            if (!hevent.Handled && helpNamespace != null) {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "HelpProvider:: F1 help");
                if (keyword != null) {
                    if (keyword.Length > 0) {
                        Help.ShowHelp(ctl, helpNamespace, navigator, keyword);
                        hevent.Handled = true;
                    }
                }

                if (!hevent.Handled) {
                    Help.ShowHelp(ctl, helpNamespace, navigator);
                    hevent.Handled = true;
                }
            }

            // So at this point we don't have a help keyword, so try to display
            // the whats this help
            //
            if (!hevent.Handled && helpString != null) {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "HelpProvider:: back to helpstring");

                if (helpString.Length > 0) {
                    Help.ShowPopup(ctl, helpString, hevent.MousePos);
                    hevent.Handled = true;
                }
            }

            // As a last resort, just popup the contents page of the help file...
            //
            if (!hevent.Handled && helpNamespace != null) {
                Debug.WriteLineIf(Help.WindowsFormsHelpTrace.TraceVerbose, "HelpProvider:: contents");

                Help.ShowHelp(ctl, helpNamespace);
                hevent.Handled = true;
            }
        }
        
        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.OnQueryAccessibilityHelp"]/*' />
        /// <devdoc>
        ///     Handles the help event for any bound controls.
        /// </devdoc>
        /// <internalonly/>
        private void OnQueryAccessibilityHelp(object sender, QueryAccessibilityHelpEventArgs e) {
            Control ctl = (Control)sender;
            
            e.HelpString = GetHelpString(ctl);
            e.HelpKeyword = GetHelpKeyword(ctl);
            e.HelpNamespace = HelpNamespace;
        }    

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.SetHelpString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       a Help string associated with a control.
        ///    </para>
        /// </devdoc>
        public virtual void SetHelpString(Control ctl, string helpString) {
            helpStrings[ctl] = helpString;
            if (helpString != null) {
                if (helpString.Length > 0) {
                    SetShowHelp(ctl, true);
                }
            }
            UpdateEventBinding(ctl);
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.SetHelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the Help keyword to display when
        ///       the user invokes Help for a control.
        ///    </para>
        /// </devdoc>
        public virtual void SetHelpKeyword(Control ctl, string keyword) {
            keywords[ctl] = keyword;
            if (keyword != null) {
                if (keyword.Length > 0) {
                    SetShowHelp(ctl, true);
                }
            }
            UpdateEventBinding(ctl);
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.SetHelpNavigator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the Help keyword to display when
        ///       the user invokes Help for a control.
        ///    </para>
        /// </devdoc>
        public virtual void SetHelpNavigator(Control ctl, HelpNavigator navigator) {
            //validate the HelpNavigator enum
            if (!Enum.IsDefined(typeof(HelpNavigator), navigator)) {
                throw new InvalidEnumArgumentException("navigator", (int)navigator, typeof(HelpNavigator));
            }

            navigators[ctl] = navigator;
            SetShowHelp(ctl, true);
            UpdateEventBinding(ctl);
        }
        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.SetShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies whether Help is displayed for a given control.
        ///    </para>
        /// </devdoc>
        public virtual void SetShowHelp(Control ctl, bool value) {
            showHelp[ ctl] = value ;
            UpdateEventBinding(ctl);
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.ShouldSerializeShowHelp"]/*' />
        /// <devdoc>
        ///    Used by the designer
        /// </devdoc>
        /// <internalonly/>
        internal virtual bool ShouldSerializeShowHelp(Control ctl) {
            return showHelp.ContainsKey(ctl);
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.ResetShowHelp"]/*' />
        /// <devdoc>
        ///    Used by the designer
        /// </devdoc>
        /// <internalonly/>
        public virtual void ResetShowHelp(Control ctl) {
            showHelp.Remove(ctl);
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.UpdateEventBinding"]/*' />
        /// <devdoc>
        ///     Binds/unbinds event handlers to ctl
        /// </devdoc>
        /// <internalonly/>
        private void UpdateEventBinding(Control ctl) {
            if (GetShowHelp(ctl) && !boundControls.ContainsKey(ctl)) {
                ctl.HelpRequested += new HelpEventHandler(this.OnControlHelp);
                ctl.QueryAccessibilityHelp += new QueryAccessibilityHelpEventHandler(this.OnQueryAccessibilityHelp);
                boundControls[ctl] = ctl;
            }
            else if (!GetShowHelp(ctl) && boundControls.ContainsKey(ctl)) {
                ctl.HelpRequested -= new HelpEventHandler(this.OnControlHelp);
                ctl.QueryAccessibilityHelp -= new QueryAccessibilityHelpEventHandler(this.OnQueryAccessibilityHelp);
                boundControls.Remove(ctl);
            }
        }

        /// <include file='doc\HelpProvider.uex' path='docs/doc[@for="HelpProvider.ToString"]/*' />
        /// <devdoc>
        ///    Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            string s = base.ToString();
            return s + ", HelpNamespace: " + HelpNamespace;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\hscrollbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="HScrollBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\HScrollBar.uex' path='docs/doc[@for="HScrollBar"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       a standard Windows horizontal scroll bar.
    ///    </para>
    /// </devdoc>
    public class HScrollBar : ScrollBar {
        
        /// <include file='doc\HScrollBar.uex' path='docs/doc[@for="HScrollBar.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns the parameters needed to create the handle. Inheriting classes
        ///       can override this to provide extra functionality. They should not,
        ///       however, forget to call base.getCreateParams() first to get the struct
        ///       filled up with the basic info.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.Style |= NativeMethods.SBS_HORZ;
                return cp;
            }
        }
        
        /// <include file='doc\HScrollBar.uex' path='docs/doc[@for="HScrollBar.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(80, SystemInformation.HorizontalScrollBarHeight);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\icompletion.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICompletion.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
#if false
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\ICompletion.uex' path='docs/doc[@for="ICompletion"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public interface ICompletion { 
       /// <include file='doc\ICompletion.uex' path='docs/doc[@for="ICompletion.CompletionStatusChanged"]/*' />
       /// <devdoc>
        ///     This function will be called by the ThreadPool's worker threads when a
        ///     packet is ready.
        ///     
        /// </devdoc>
        void CompletionStatusChanged(bool status, int size, NativeMethods.OVERLAPPED overlapped);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\icontainercontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="IContainerControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\IContainerControl.uex' path='docs/doc[@for="IContainerControl"]/*' />
    /// <devdoc>
    ///    <para> Provides functionality for a control 
    ///       to parent other controls.</para>
    /// </devdoc>
    public interface IContainerControl {
        /// <include file='doc\IContainerControl.uex' path='docs/doc[@for="IContainerControl.ActiveControl"]/*' />
        /// <devdoc>
        ///    <para>Indicates the control that is currently active on the container control.</para>
        /// </devdoc>
        Control ActiveControl { get; set; }
        /// <include file='doc\IContainerControl.uex' path='docs/doc[@for="IContainerControl.ActivateControl"]/*' />
        /// <devdoc>
        ///    <para>Activates the specified control.</para>
        /// </devdoc>
        bool ActivateControl(Control active);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\idataobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;


    /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject"]/*' />
    /// <devdoc>
    ///    <para>Provides a format-independent mechanism for transferring
    ///       data.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IDataObject {
        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetData"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data associated with the specified data 
        ///       format, using autoConvert to determine whether to convert the data to the
        ///       format. </para>
        /// </devdoc>
        object GetData(string format, bool autoConvert);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetData1"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data associated with the specified data format.</para>
        /// </devdoc>
        object GetData(string format);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetData2"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data associated with the specified class 
        ///       type format.</para>
        /// </devdoc>
        object GetData(Type format);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.SetData"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data and its associated format in 
        ///       this instance, using autoConvert to specify whether the data can be converted
        ///       to another format.</para>
        /// </devdoc>
        void SetData(string format, bool autoConvert, object data);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.SetData1"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data and its associated format in this
        ///       instance.</para>
        /// </devdoc>
        void SetData(string format, object data);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.SetData2"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data and its associated class type in this
        ///       instance.</para>
        /// </devdoc>
        void SetData(Type format, object data);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.SetData3"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data in this instance, using the class of the
        ///       data for the format.</para>
        /// </devdoc>
        void SetData(object data);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetDataPresent"]/*' />
        /// <devdoc>
        ///    <para>Determines whether data stored in this instance is 
        ///       associated with the specified format, using autoConvert to determine whether to
        ///       convert the data to the format.</para>
        /// </devdoc>
        bool GetDataPresent(string format, bool autoConvert);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetDataPresent1"]/*' />
        /// <devdoc>
        ///    <para>Determines whether data stored in this instance is associated with, or can be
        ///       converted to, the specified format.</para>
        /// </devdoc>
        bool GetDataPresent(string format);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetDataPresent2"]/*' />
        /// <devdoc>
        ///    <para>Determines whether data stored in this instance is associated with, or can be converted to, the specified format.</para>
        /// </devdoc>
        bool GetDataPresent(Type format);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetFormats"]/*' />
        /// <devdoc>
        ///    <para>Gets a list of all formats that data stored in this 
        ///       instance is associated with or can be converted to, using autoConvert to determine whether to
        ///       retrieve all formats that the data can be converted to or only native data
        ///       formats.</para>
        /// </devdoc>
        string[] GetFormats(bool autoConvert);

        /// <include file='doc\IDataObject.uex' path='docs/doc[@for="IDataObject.GetFormats1"]/*' />
        /// <devdoc>
        ///    <para>Gets a list of all formats that data stored in this instance is associated
        ///       with or can be converted to.</para>
        /// </devdoc>
        string[] GetFormats();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\idatagrideditingservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataGridEditingService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    
    /// <include file='doc\IDataGridEditingService.uex' path='docs/doc[@for="IDataGridEditingService"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>The DataGrid exposes hooks to request editing commands
    ///       via this interface.</para>
    /// </devdoc>
    public interface IDataGridEditingService {
        /// <include file='doc\IDataGridEditingService.uex' path='docs/doc[@for="IDataGridEditingService.BeginEdit"]/*' />
        bool BeginEdit(DataGridColumnStyle gridColumn, int rowNumber);
        
        /// <include file='doc\IDataGridEditingService.uex' path='docs/doc[@for="IDataGridEditingService.EndEdit"]/*' />
        bool EndEdit(DataGridColumnStyle gridColumn, int rowNumber, bool shouldAbort);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\ifeaturesupport.cs ===
//------------------------------------------------------------------------------
// <copyright file="IFeatureSupport.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Configuration.Assemblies;

    using System.Diagnostics;

    using System;
    
    /// <include file='doc\IFeatureSupport.uex' path='docs/doc[@for="IFeatureSupport"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies a standard
    ///       interface for retrieving feature information from the current system.
    ///    </para>
    /// </devdoc>

    public interface IFeatureSupport {
    
        /// <include file='doc\IFeatureSupport.uex' path='docs/doc[@for="IFeatureSupport.IsPresent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether any version of the specified feature
        ///       is currently available
        ///       on the system.
        ///    </para>
        /// </devdoc>
        bool IsPresent(object feature);
        
        /// <include file='doc\IFeatureSupport.uex' path='docs/doc[@for="IFeatureSupport.IsPresent1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether the specified or newer version of the
        ///       specified feature
        ///       is currently available on the system.
        ///    </para>
        /// </devdoc>
        bool IsPresent(object feature, Version minimumVersion);
    
        /// <include file='doc\IFeatureSupport.uex' path='docs/doc[@for="IFeatureSupport.GetVersionPresent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the version
        ///       of the specified feature.
        ///    </para>
        /// </devdoc>
        Version GetVersionPresent(object feature);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\imageindexconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageIndexConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter"]/*' />
    /// <devdoc>
    ///      ImageIndexConverter is a class that can be used to convert
    ///      image index values one data type to another.
    /// </devdoc>
    public class ImageIndexConverter : Int32Converter {

        /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter.IncludeNoneAsStandardValue"]/*' />
        protected virtual bool IncludeNoneAsStandardValue {
            get {
                return true;
            }
        }                                
                                
        /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given value object to a 32-bit signed integer object.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string && String.Compare((string) value, SR.GetString(SR.toStringNone), true, culture) == 0) {
                return -1;
            }

            return base.ConvertFrom(context, culture, value);
        }


        /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is int && ((int)value) == -1) {
                return SR.GetString(SR.toStringNone);
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (context != null && context.Instance != null) {
                object instance = context.Instance;
                PropertyDescriptor imageListProp = null;

                while (instance != null && imageListProp == null) {
                    PropertyDescriptorCollection props = TypeDescriptor.GetProperties(instance);

                    foreach (PropertyDescriptor prop in props) {
                        if (typeof(ImageList).IsAssignableFrom(prop.PropertyType)) {
                            imageListProp = prop;
                            break;
                        }
                    }

                    if (imageListProp == null) {

                        // We didn't find the image list in this component.  See if the 
                        // component has a "parent" property.  If so, walk the tree...
                        //
                        PropertyDescriptor parentProp = props["Parent"];
                        if (parentProp != null) {
                            instance = parentProp.GetValue(instance);
                        }
                        else {
                            // Stick a fork in us, we're done.
                            //
                            instance = null;
                        }
                    }
                }

                if (imageListProp != null) {
                    ImageList imageList = (ImageList)imageListProp.GetValue(instance);

                    if (imageList != null) {
                        
                        // Create array to contain standard values
                        //
                        object[] values;
                        int nImages = imageList.Images.Count;
                        if (IncludeNoneAsStandardValue) {
                            values = new object[nImages + 1];
                            values[nImages] = -1;
                        }
                        else {
                            values = new object[nImages];
                        }
                        
                        
                        // Fill in the array
                        //
                        for (int i = 0; i < nImages; i++) {
                            values[i] = i;
                        }
                        
                        return new StandardValuesCollection(values);
                    }
                }
            }

            if (IncludeNoneAsStandardValue) {
                return new StandardValuesCollection(new object[] {-1});
            }
            else {
                return new StandardValuesCollection(new object[0]);
            }
        }

        /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///      Determines if the list of standard values returned from
        ///      GetStandardValues is an exclusive list.  If the list
        ///      is exclusive, then no other values are valid, such as
        ///      in an enum data type.  If the list is not exclusive,
        ///      then there are other valid values besides the list of
        ///      standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\ImageIndexConverter.uex' path='docs/doc[@for="ImageIndexConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\ifilereaderservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IFileReaderService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.IO;

    // CONSIDER:  chrisan, REMOVE ME!  I'm a workaround for security...
    /// <include file='doc\IFileReaderService.uex' path='docs/doc[@for="IFileReaderService"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public interface IFileReaderService {
        /// <include file='doc\IFileReaderService.uex' path='docs/doc[@for="IFileReaderService.OpenFileFromSource"]/*' />
        Stream OpenFileFromSource(string relativePath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\imageliststreamer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageListStreamer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using System.IO;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Globalization;

    /// <include file='doc\ImageListStreamer.uex' path='docs/doc[@for="ImageListStreamer"]/*' />
    /// <devdoc>
    /// </devdoc>
    [Serializable]
    public sealed class ImageListStreamer : ISerializable {
    
        // compressed magic header.  If we see this, the image stream is compressed.
        // (unicode for MSFT).
        //
        private static readonly byte[] HEADER_MAGIC = new byte[] {0x4D, 0x53, 0x46, 0X74};
        
        private ImageList imageList;
        private ImageList.NativeImageList nativeImageList;

        internal ImageListStreamer(ImageList il) {
            imageList = il;
        }

        /**
         * Constructor used in deserialization
         */
        private ImageListStreamer(SerializationInfo info, StreamingContext context) {
            SerializationInfoEnumerator sie = info.GetEnumerator();
            if (sie == null) {
                return;
            }
            for (; sie.MoveNext();) {
                if (String.Compare(sie.Name, "Data", true, CultureInfo.InvariantCulture) == 0) {
#if DEBUG
                    try {
#endif
                    byte[] dat = (byte[])sie.Value;
                    if (dat != null) {
                        SafeNativeMethods.InitCommonControls();
                        nativeImageList = new ImageList.NativeImageList(
                            SafeNativeMethods.ImageList_Read(new UnsafeNativeMethods.ComStreamFromDataStream(new MemoryStream(Decompress(dat)))));
                        if (nativeImageList.Handle == IntPtr.Zero) {
                            throw new InvalidOperationException(SR.GetString(SR.ImageListStreamerLoadFailed));
                        }
                    }
#if DEBUG
                    }
                    catch (Exception e) {
                        Debug.Fail("imagelist serialization failure: " + e.ToString());
                        throw e;
                    }
#endif
                }
            }        
        }
             
        /// <devdoc>
        ///     Compresses the given input, returning a new array that represents
        ///     the compressed data.
        /// </devdoc>
        private byte[] Compress(byte[] input) {
        
            int finalLength = 0;
            int idx = 0;
            int compressedIdx = 0;
            
            while(idx < input.Length) {
            
                byte current = input[idx++];
                byte runLength = 1;
                
                while(idx < input.Length && input[idx] == current && runLength < 0xFF) {
                    runLength++;
                    idx++;
                }
                
                finalLength += 2;
            }
            
            byte[] output = new byte[finalLength + HEADER_MAGIC.Length];
            
            Buffer.BlockCopy(HEADER_MAGIC, 0, output, 0, HEADER_MAGIC.Length);
            int idxOffset = HEADER_MAGIC.Length;
            idx = 0;
            
            while(idx < input.Length) {
            
                byte current = input[idx++];
                byte runLength = 1;
                
                while(idx < input.Length && input[idx] == current && runLength < 0xFF) {
                    runLength++;
                    idx++;
                }
                
                output[idxOffset + compressedIdx++] = runLength;
                output[idxOffset + compressedIdx++] = current;
            }
            
            Debug.Assert(idxOffset + compressedIdx == output.Length, "RLE Compression failure in ImageListStreamer -- didn't fill array");
            
            // Validate that our compression routine works
            #if DEBUG
            byte[] debugCompare = Decompress(output);
            Debug.Assert(debugCompare.Length == input.Length, "RLE Compression in ImageListStreamer is broken.");
            int debugMaxCompare = input.Length;
            for(int debugIdx = 0; debugIdx < debugMaxCompare; debugIdx++) {
                if (debugCompare[debugIdx] != input[debugIdx]) {
                    Debug.Fail("RLE Compression failure in ImageListStreamer at byte offset " + debugIdx);
                    break;
                }
            }
            #endif // DEBUG
            
            return output;
        }
        
        /// <devdoc>
        ///     Decompresses the given input, returning a new array that represents
        ///     the uncompressed data.
        /// </devdoc>
        private byte[] Decompress(byte[] input) {
            
            int finalLength = 0;
            int idx = 0;
            int outputIdx = 0;
            
            // Check for our header. If we don't have one,
            // we're not actually decompressed, so just return
            // the original.
            //
            if (input.Length < HEADER_MAGIC.Length) {
                return input;
            }
            
            for(idx = 0; idx < HEADER_MAGIC.Length; idx++) {
                if (input[idx] != HEADER_MAGIC[idx]) {  
                    return input;
                }
            }
            
            // Ok, we passed the magic header test.
            
            for (idx = HEADER_MAGIC.Length; idx < input.Length; idx+=2) {
                finalLength += input[idx];
            }
            
            byte[] output = new byte[finalLength];
            
            idx = HEADER_MAGIC.Length;
            
            while(idx < input.Length) {
                byte runLength = input[idx++];
                byte current = input[idx++];
                
                int startIdx = outputIdx;
                int endIdx = outputIdx + runLength;
                
                while(startIdx < endIdx) {
                    output[startIdx++] = current;
                }
                
                outputIdx += runLength;
            }
            
            return output;
        }

        /// <include file='doc\ImageListStreamer.uex' path='docs/doc[@for="ImageListStreamer.GetObjectData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void /*cpr: ISerializable*/GetObjectData(SerializationInfo si, StreamingContext context) {
            MemoryStream stream = new MemoryStream();

            IntPtr handle = IntPtr.Zero;
            if (imageList != null) {
                handle = imageList.Handle;
            }
            else if (nativeImageList != null) {
                handle = nativeImageList.Handle;
            }

            if (handle == IntPtr.Zero || !SafeNativeMethods.ImageList_Write(new HandleRef(this, handle), new UnsafeNativeMethods.ComStreamFromDataStream(stream)))
                throw new InvalidOperationException(SR.GetString(SR.ImageListStreamerSaveFailed));

            si.AddValue("Data", Compress(stream.ToArray()));
        }

        internal ImageList.NativeImageList GetNativeImageList() {
            return nativeImageList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\imagelist.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Drawing;
    
    using System.Drawing.Design;
    using System.Windows.Forms;    
    using System.Windows.Forms.Design;
    using System.IO;

    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList"]/*' />
    /// <devdoc>
    ///     The ImageList is an object that stores a collection of Images, most
    ///     commonly used by other controls, such as the ListView, TreeView, or
    ///     Toolbar.  You can add either bitmaps or Icons to the ImageList, and the
    ///     other controls will be able to use the Images as they desire.
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.ImageListDesigner, " + AssemblyRef.SystemDesign),
    ToolboxItemFilter("System.Windows.Forms"),
    DefaultProperty("Images"),
    TypeConverter(typeof(ImageListConverter))
    ]
    public sealed class ImageList : Component {

        // gpr: Copied from Icon
        private static Color fakeTransparencyColor = Color.FromArgb(0x0d, 0x0b, 0x0c);

        private const int INITIAL_CAPACITY = 4;
        private const int GROWBY = 4;

        private NativeImageList nativeImageList;        
        
        // private int himlTemp;
        // private Bitmap temp = null;  // Used for drawing

        private ColorDepth colorDepth = System.Windows.Forms.ColorDepth.Depth8Bit;
        private Color transparentColor = Color.Transparent;
        private Size imageSize = new Size(16, 16);

        private ImageCollection imageCollection;

        // The usual handle virtualization problem, with a new twist: image
        // lists are lossy.  At runtime, we delay handle creation as long as possible, and store
        // away the original images until handle creation (and hope no one disposes of the images!).  At design time, we keep the originals around indefinitely.
        // This variable will become null when the original images are lost. See ASURT 65162.
        private IList /* of Original */ originals = new ArrayList();
        private EventHandler recreateHandler = null;        

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageList"]/*' />
        /// <devdoc>
        ///     Creates a new ImageList Control with a default image size of 16x16
        ///     pixels
        /// </devdoc>
        public ImageList() { // DO NOT DELETE -- AUTOMATION BP 1
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageList1"]/*' />
        /// <devdoc>
        ///     Creates a new ImageList Control with a default image size of 16x16
        ///     pixels and adds the ImageList to the passed in container.
        /// </devdoc>
        public ImageList(IContainer container) {
            container.Add(this);
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ColorDepth"]/*' />
        /// <devdoc>
        ///     Retrieves the color depth of the imagelist.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(ColorDepth.Depth8Bit),
        SRDescription(SR.ImageListColorDepthDescr)
        ]
        public ColorDepth ColorDepth {
            get {
                return colorDepth;
            }
            set {
                if (!Enum.IsDefined(typeof(ColorDepth), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ColorDepth));
                }

                if (colorDepth != value) {
                    colorDepth = value;
                    PerformRecreateHandle("ColorDepth");
                }
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.Handle"]/*' />
        /// <devdoc>
        ///     The handle of the ImageList object.  This corresponds to a win32
        ///     HIMAGELIST Handle.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ImageListHandleDescr)
        ]
        public IntPtr Handle {
            get {
                if (nativeImageList == null) {
                    CreateHandle();
                }
                return nativeImageList.Handle;
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.HandleCreated"]/*' />
        /// <devdoc>
        ///     Whether or not the underlying Win32 handle has been created.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ImageListHandleCreatedDescr)
        ]
        public bool HandleCreated {
            get { return nativeImageList != null; }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.Images"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ImageListImagesDescr),
        MergableProperty(false)
        ]
        public ImageCollection Images {
            get {
                if (imageCollection == null)
                    imageCollection = new ImageCollection(this);
                return imageCollection;
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageSize"]/*' />
        /// <devdoc>
        ///     Returns the size of the images in the ImageList
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        SRDescription(SR.ImageListSizeDescr)
        ]
        public Size ImageSize {
            get {
                return imageSize;
            }
            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "value",
                                                              "Size.Empty"));
                }

                // ImageList appears to consume an exponential amount of memory 
                // based on image size x bpp.  Restrict this to a reasonable maximum
                // to keep people's systems from crashing.
                //
                if (value.Width <= 0 || value.Width > 256) {
                    throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "value", value.Width.ToString(), "1", "256"));
                }

                if (value.Height <= 0 || value.Height > 256) {
                    throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "value", value.Height.ToString(), "1", "256"));
                }

                if (imageSize.Width != value.Width || imageSize.Height != value.Height) {
                    imageSize = new Size(value.Width, value.Height);
                    PerformRecreateHandle("ImageSize");
                }
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageStream"]/*' />
        /// <devdoc>
        ///     Returns an ImageListStreamer, or null if the image list is empty.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DefaultValue(null),
        SRDescription(SR.ImageListImageStreamDescr)
        ]
        public ImageListStreamer ImageStream {
            get {
                if (Images.Empty)
                    return null;

                // No need for us to create the handle, because any serious attempts to use the
                // ImageListStreamer will do it for us.
                return new ImageListStreamer(this);
            }
            set {
                if (value != null) {
                    NativeImageList himl = value.GetNativeImageList();
                    if (himl != null && himl != this.nativeImageList) {
                        DestroyHandle();
                        originals = null;                                                            
                        this.nativeImageList = himl;
                    }
                }
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.TransparentColor"]/*' />
        /// <devdoc>
        ///     The color to treat as transparent.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.ImageListTransparentColorDescr)
        ]
        public Color TransparentColor {
            get {
                return transparentColor;
            }
            set {
                transparentColor = value;
            }
        }

        // Whether to use the transparent color, or rely on alpha instead
        private bool UseTransparentColor {
            get { return TransparentColor.A > 0;}
        }


        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.RecreateHandle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        SRDescription(SR.ImageListOnRecreateHandleDescr)
        ]
        public event EventHandler RecreateHandle {
            add {
                recreateHandler += value;
            }
            remove {
                recreateHandler -= value;
            }
        }

        //Creates a bitmap from the original image source..
        //

        private Bitmap CreateBitmap(Original original) { 
            Color transparent = transparentColor;
            if ((original.options & OriginalOptions.CustomTransparentColor) != 0)
                transparent = original.customTransparentColor;

            Bitmap bitmap;
            if (original.image is Bitmap) {
                bitmap = (Bitmap) original.image;
            }
            else if (original.image is Icon) {
                bitmap = ((Icon)original.image).ToBitmap();
            }
            else {
                bitmap = new Bitmap((Image)original.image);
            }

            if (transparent.A > 0) {
                // ImageList_AddMasked doesn't work on high color bitmaps,
                // so we always create the mask ourselves
                Bitmap source = bitmap;
                bitmap = (Bitmap) bitmap.Clone();
                bitmap.MakeTransparent(transparent);
            }

            Size size = bitmap.Size;
            if ((original.options & OriginalOptions.ImageStrip) != 0) {
                // strip width must be a positive multiple of image list width
                if (size.Width == 0 || (size.Width % imageSize.Width) != 0)
                    throw new ArgumentException(SR.GetString(SR.ImageListStripBadWidth), "original");
                if (size.Height != imageSize.Height)
                    throw new ArgumentException(SR.GetString(SR.ImageListImageTooShort), "original");
            }
            else if (!size.Equals(ImageSize)) {
                Bitmap source = bitmap;
                bitmap = new Bitmap(source, ImageSize);
            }
            return bitmap;
            
        }

        private int AddIconToHandle(Original original, Icon icon) {
            Debug.Assert(HandleCreated, "Calling AddIconToHandle when there is no handle");
            int index = SafeNativeMethods.ImageList_ReplaceIcon(new HandleRef(this, Handle), -1, new HandleRef(icon, icon.Handle));
            if (index == -1) throw new InvalidOperationException(SR.GetString(SR.ImageListAddFailed));
            return index;
        }
        // Adds bitmap to the Imagelist handle...
        //
        private int AddToHandle(Original original, Bitmap bitmap) {
            
            Debug.Assert(HandleCreated, "Calling AddToHandle when there is no handle");
            IntPtr hMask = ControlPaint.CreateHBitmapTransparencyMask(bitmap);
            IntPtr hBitmap = ControlPaint.CreateHBitmapColorMask(bitmap, hMask);
            int index = SafeNativeMethods.ImageList_Add(new HandleRef(this, Handle), new HandleRef(null, hBitmap), new HandleRef(null, hMask));
            SafeNativeMethods.DeleteObject(new HandleRef(null, hBitmap));
            SafeNativeMethods.DeleteObject(new HandleRef(null, hMask));

            if (index == -1) throw new InvalidOperationException(SR.GetString(SR.ImageListAddFailed));
            return index;
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.CreateHandle"]/*' />
        /// <devdoc>
        ///     Creates the underlying HIMAGELIST handle, and sets up all the
        ///     appropriate values with it.  Inheriting classes overriding this method
        ///     should not forget to call base.createHandle();
        /// </devdoc>
        private void CreateHandle() {
            // so we don't reinit while we're doing this...            
            nativeImageList = null;
            SafeNativeMethods.InitCommonControls();

            int flags = NativeMethods.ILC_MASK;
            switch (colorDepth) {
                case ColorDepth.Depth4Bit:
                    flags |= NativeMethods.ILC_COLOR4;
                    break;
                case ColorDepth.Depth8Bit:
                    flags |= NativeMethods.ILC_COLOR8;
                    break;
                case ColorDepth.Depth16Bit:
                    flags |= NativeMethods.ILC_COLOR16;
                    break;
                case ColorDepth.Depth24Bit:
                    flags |= NativeMethods.ILC_COLOR24;
                    break;
                case ColorDepth.Depth32Bit:
                    flags |= NativeMethods.ILC_COLOR32;
                    break;
                default:
                    Debug.Fail("Unknown color depth in ImageList");
                    break;
            }
            
            nativeImageList = new NativeImageList(SafeNativeMethods.ImageList_Create(imageSize.Width, imageSize.Height, flags, INITIAL_CAPACITY, GROWBY));            

            if (Handle == IntPtr.Zero) throw new InvalidOperationException(SR.GetString(SR.ImageListCreateFailed));
            SafeNativeMethods.ImageList_SetBkColor(new HandleRef(this, Handle), NativeMethods.CLR_NONE);

            Debug.Assert(originals != null, "Handle not yet created, yet original images are gone");
            for (int i = 0; i < originals.Count; i++) {
                Original original = (Original) originals[i];
                if (original.image is Icon) {
                    AddIconToHandle(original, (Icon)original.image);
                }
                else {
                    Bitmap bitmapValue = CreateBitmap(original);
                    AddToHandle(original, bitmapValue);
                }
            }
            originals = null;
        }

        // Don't merge this function into Dispose() -- that base.Dispose() will damage the design time experience
        private void DestroyHandle() {
            if (HandleCreated) {
                // NOTE! No need to call ImageList_Destroy. It will be called in the NativeImageList finalizer.
                nativeImageList = null;                
                originals = new ArrayList();                
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.Dispose"]/*' />
        /// <devdoc>
        ///     Frees all resources assocaited with this component.
        /// </devdoc>
        protected override void Dispose(bool disposing) {           
            // NOTE! No need to call ImageList_Destroy. It will be called in the NativeImageList finalizer.
            if (disposing) {                
                DestroyHandle();
            }            
            base.Dispose(disposing);
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.Draw"]/*' />
        /// <devdoc>
        ///     Draw the image indicated by the given index on the given Graphics
        ///     at the given location.
        /// </devdoc>
        public void Draw(Graphics g, Point pt, int index) {
            Draw(g, pt.X, pt.Y, index);
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.Draw1"]/*' />
        /// <devdoc>
        ///     Draw the image indicated by the given index on the given Graphics
        ///     at the given location.
        /// </devdoc>
        public void Draw(Graphics g, int x, int y, int index) {
            if (index < 0 || index >= Images.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));
            IntPtr dc = g.GetHdc();
            try {
                SafeNativeMethods.ImageList_DrawEx(new HandleRef(this, Handle), index, new HandleRef(g, dc), x, y,
                                        imageSize.Width, imageSize.Height, NativeMethods.CLR_NONE, NativeMethods.CLR_NONE, NativeMethods.ILD_TRANSPARENT);
            }
            finally {
                // SECREVIEW : GetHdc allocs the handle, so we must release it.
                //
                IntSecurity.Win32HandleManipulation.Assert();
                try {
                    g.ReleaseHdc(dc);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.Draw2"]/*' />
        /// <devdoc>
        ///     Draw the image indicated by the given index using the location, size
        ///     and raster op code specified.  The image is stretched or compressed as
        ///     necessary to fit the bounds provided.
        /// </devdoc>
        public void Draw(Graphics g, int x, int y, int width, int height, int index) {
            int rop = NativeMethods.SRCCOPY;
            if (width != imageSize.Width || height != imageSize.Height) {
                Bitmap bitmap = GetBitmap(index);
                g.DrawImage(bitmap, new Rectangle(x, y, width, height));
            }
            else {
                IntPtr dc = g.GetHdc();
                try {
                    IntPtr handle = Handle; // Force handle creation
                    if (index < 0 || index >= Images.Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));

                    NativeMethods.IMAGELISTDRAWPARAMS dp = new NativeMethods.IMAGELISTDRAWPARAMS();

                    int backColor = NativeMethods.CLR_NONE;
                    int mode = NativeMethods.ILD_TRANSPARENT | NativeMethods.ILD_ROP;

                    dp.himl = Handle;
                    dp.i = index;
                    dp.hdcDst = dc;
                    dp.x = x;
                    dp.y = y;
                    dp.cx = width;
                    dp.cy = height;
                    dp.xBitmap = 0;
                    dp.yBitmap = 0;
                    dp.rgbBk = backColor;
                    dp.rgbFg = NativeMethods.CLR_NONE;
                    dp.fStyle = mode;
                    dp.dwRop = rop;

                    SafeNativeMethods.ImageList_DrawIndirect(dp);
                }
                finally {
                    // SECREVIEW : GetHdc allocs the handle, so we must release it.
                    //
                    IntSecurity.Win32HandleManipulation.Assert();
                    try {
                        g.ReleaseHdc(dc);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.GetBitmap"]/*' />
        /// <devdoc>
        ///     Returns the image specified by the given index.  The bitmap returned is a
        ///     copy of the original image.
        /// </devdoc>
        // NOTE: forces handle creation, so doesn't return things from the original list
        private Bitmap GetBitmap(int index) {
            if (index < 0 || index >= Images.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));

            Bitmap result = new Bitmap(imageSize.Width, imageSize.Height);

            Graphics graphics = Graphics.FromImage(result);
            try {
                IntPtr dc = graphics.GetHdc();
                try {
                    SafeNativeMethods.ImageList_DrawEx(new HandleRef(this, Handle), index, new HandleRef(graphics, dc), 0, 0,
                                            imageSize.Width, imageSize.Height, NativeMethods.CLR_NONE, NativeMethods.CLR_NONE, NativeMethods.ILD_TRANSPARENT);

                }
                finally {
                    // SECREVIEW : GetHdc allocs the handle, so we must release it.
                    //
                    IntSecurity.Win32HandleManipulation.Assert();
                    try {
                        graphics.ReleaseHdc(dc);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }
            finally {
                graphics.Dispose();
            }

            // gpr: See Icon for description of fakeTransparencyColor
            result.MakeTransparent(fakeTransparencyColor);

            return result;
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.GetImageInfo"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal NativeMethods.IMAGEINFO GetImageInfo(int index) {
            if (index < 0 || index >= Images.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));
            NativeMethods.IMAGEINFO info = new NativeMethods.IMAGEINFO();
            if (SafeNativeMethods.ImageList_GetImageInfo(new HandleRef(this, Handle), index, info) == false)
                throw new InvalidOperationException(SR.GetString(SR.ImageListGetFailed));
            return info;
        }

#if DEBUG_ONLY_APIS
        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.DebugOnly_GetMasterImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Bitmap DebugOnly_GetMasterImage() {
            if (Images.Empty)
                return null;

            return Image.FromHBITMAP(GetImageInfo(0).hbmImage);
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.DebugOnly_GetMasterMask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Bitmap DebugOnly_GetMasterMask() {
            if (Images.Empty)
                return null;

            return Image.FromHBITMAP(GetImageInfo(0).hbmMask);
        }
#endif // DEBUG_ONLY_APIS

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.OnRecreateHandle"]/*' />
        /// <devdoc>
        ///     Called when the Handle property changes.
        /// </devdoc>
        private void OnRecreateHandle(EventArgs eventargs) {
            if (recreateHandler != null) {
                recreateHandler(this, eventargs);
            }
        }

#if false
        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.PutImageInTempBitmap"]/*' />
        /// <devdoc>
        ///     Copies the image at the specified index into the temporary Bitmap object.
        ///     The temporary Bitmap object is used for stuff that the Windows ImageList
        ///     control doesn't support, such as stretching images or copying images from
        ///     different image lists.  Since bitmap creation is expensive, the same instance
        ///     of the temporary Bitmap is reused.
        /// </devdoc>
        private void PutImageInTempBitmap(int index, bool useSnapshot) {
            Debug.Assert(!useSnapshot || himlTemp != 0, "Where's himlTemp?");

            IntPtr handleUse = (useSnapshot ? himlTemp : Handle);
            int count = SafeNativeMethods.ImageList_GetImageCount(handleUse);

            if (index < 0 || index >= count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));

            if (temp != null) {
                Size size = temp.Size;
                if (!temp.Size.Equals(imageSize)) {
                    temp.Dispose();
                    temp = null;
                }
            }
            if (temp == null) {
                temp = new Bitmap(imageSize.Width, imageSize.Height);
            }

            temp.Transparent = useMask;
            // OldGraphics gTemp = /*gpr useMask ? temp.ColorMask.GetGraphics() :*/ temp.GetGraphics();
            SafeNativeMethods.ImageList_DrawEx(handleUse, index, gTemp.Handle, 0, 0,
                                    imageSize.Width, imageSize.Height, useMask ? 0 : NativeMethods.CLR_DEFAULT, NativeMethods.CLR_NONE, NativeMethods.ILD_NORMAL);

            if (useMask) {
                gTemp = temp/*gpr .MonochromeMask*/.GetGraphics();
                SafeNativeMethods.ImageList_DrawEx(handleUse, index, gTemp.Handle, 0, 0, imageSize.Width, imageSize.Height, NativeMethods.CLR_DEFAULT, NativeMethods.CLR_NONE, NativeMethods.ILD_MASK);
            }
        }
#endif

        private void PerformRecreateHandle(string reason) {
            if (!HandleCreated) return;

            if (originals == null || Images.Empty)
                originals = new ArrayList(); // spoof it into thinking this is the first CreateHandle

            if (originals == null)
                throw new InvalidOperationException(SR.GetString(SR.ImageListCantRecreate, reason));

            DestroyHandle();
            CreateHandle();
            OnRecreateHandle(new EventArgs());
        }

        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.RemoveImage"]/*' />
        /// <devdoc>
        ///     Remove the image specified by the given index.
        /// </devdoc>
        private void RemoveImage(int index) {
            if (index < 0 || index >= Images.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));

            bool ok = SafeNativeMethods.ImageList_Remove(new HandleRef(this, Handle), index);
            if (!ok)
                throw new InvalidOperationException(SR.GetString(SR.ImageListRemoveFailed));
        }

        private bool ShouldSerializeTransparentColor() {
            return !TransparentColor.Equals(Color.LightGray);
        }

        private bool ShouldSerializeImageSize() {
            return !ImageSize.Equals(new Size(16, 16));
        }


        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            string s = base.ToString();
            if (Images != null) {
                return s + " Images.Count: " + Images.Count.ToString() + ", ImageSize: " + ImageSize.ToString();
            }
            else {
                return s;
            }
        }            

        internal class NativeImageList {
            private IntPtr himl;

            internal NativeImageList(IntPtr himl) {
                this.himl = himl;
            }

            internal IntPtr Handle
            {
                get
                {
                    return himl;
                }
            }

            ~NativeImageList() {
                if (himl != IntPtr.Zero) {                
                    SafeNativeMethods.ImageList_Destroy(new HandleRef(null, himl));
                    himl = IntPtr.Zero;
                }
            }
        }

        // An image before we add it to the image list, along with a few details about how to add it.
        private class Original {
            internal object image;
            internal OriginalOptions options;
            internal Color customTransparentColor = Color.Transparent;
            
            internal int nImages = 1;

            internal Original(object image, OriginalOptions options)
            : this(image, options, Color.Transparent) {
            }
            
            internal Original(object image, OriginalOptions options, int nImages) 
            : this(image, options, Color.Transparent) {
                this.nImages = nImages;
            }

            internal Original(object image, OriginalOptions options, Color customTransparentColor) {
                Debug.Assert(image != null, "image is null");
                if (!(image is Icon) && !(image is Image)) {
                    throw new InvalidOperationException(SR.GetString(SR.ImageListEntryType));
                }
                this.image = image;
                this.options = options;
                this.customTransparentColor = customTransparentColor;
                if ((options & OriginalOptions.CustomTransparentColor) == 0) {
                    Debug.Assert(customTransparentColor.Equals(Color.Transparent),
                                 "Specified a custom transparent color then told us to ignore it");
                }
            }
        }

        [Flags]
        private enum OriginalOptions {
            Default                = 0x00,

            ImageStrip             = 0x01,
            CustomTransparentColor = 0x02,
        }

        // Everything other than set_All, Add, and Clear will force handle creation.
        /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Editor("System.Windows.Forms.Design.ImageCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        public sealed class ImageCollection : IList {
            private ImageList owner;

            internal ImageCollection(ImageList owner) {
                this.owner = owner;
            }

            private void AssertInvariant() {
                Debug.Assert(owner != null, "ImageCollection has no owner (ImageList)");
                Debug.Assert( (owner.originals == null) == (owner.HandleCreated), " Either we should have the original images, or the handle should be created");
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    AssertInvariant();
                    if (owner.HandleCreated) {
                        return SafeNativeMethods.ImageList_GetImageCount(new HandleRef(owner, owner.Handle));
                    }
                    else {
                        int count = 0;
                        foreach(Original original in owner.originals) {
                            if (original != null) {
                                count += original.nImages;
                            }
                        }
                        return count;
                    }
                }
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
           
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }  
              
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Empty"]/*' />
            /// <devdoc>
            ///      Determines if the ImageList has any images, without forcing a handle creation.
            /// </devdoc>
            public bool Empty {
                get  {
                    return Count == 0;
                }
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.this"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public Image this[int index] {
                get {
                    if (index < 0 || index >= Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));
                    return owner.GetBitmap(index);
                }
                set {
                    if (index < 0 || index >= Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));
                      
                    if (value == null) {
                        throw new ArgumentNullException("value");
                    }
                    
                    if (!(value is Bitmap))
                        throw new ArgumentException(SR.GetString(SR.ImageListBitmap));


                    AssertInvariant();

                    Bitmap bitmap = (Bitmap)value;

                    if (owner.UseTransparentColor) {
                        // Since there's no ImageList_ReplaceMasked, we need to generate
                        // a transparent bitmap
                        Bitmap source = bitmap;
                        bitmap = (Bitmap) bitmap.Clone();
                        bitmap.MakeTransparent(owner.transparentColor);
                    }


                    IntPtr hMask = ControlPaint.CreateHBitmapTransparencyMask(bitmap);
                    IntPtr hBitmap = ControlPaint.CreateHBitmapColorMask(bitmap, hMask);
                    bool ok = SafeNativeMethods.ImageList_Replace(new HandleRef(owner, owner.Handle), index, new HandleRef(null, hBitmap), new HandleRef(null, hMask));
                    SafeNativeMethods.DeleteObject(new HandleRef(null, hBitmap));
                    SafeNativeMethods.DeleteObject(new HandleRef(null, hMask));

                    if (!ok)
                        throw new InvalidOperationException(SR.GetString(SR.ImageListReplaceFailed));
                }
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    if (value is Image) {
                        this[index] = (Image)value;
                    }
                    else {  
                        throw new ArgumentException("value");
                    }
                }
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                if (value is Image) {
                    Add((Image)value);
                    return Count - 1;
                }
                else {  
                    throw new ArgumentException("value");
                }
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Add(Icon value) {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }
                Add(new Original(value.Clone(), OriginalOptions.Default));
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Add1"]/*' />
            /// <devdoc>
            ///     Add the given image to the ImageList.
            /// </devdoc>
            public void Add(Image value) {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }
                Original original = new Original(value, OriginalOptions.Default);
                Add(original);
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Add2"]/*' />
            /// <devdoc>
            ///     Add the given image to the ImageList, using the given color
            ///     to generate the mask. The number of images to add is inferred from
            ///     the width of the given image.
            /// </devdoc>
            public int Add(Image value, Color transparentColor) {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }                                                                  
                Original original = new Original(value, OriginalOptions.CustomTransparentColor,
                                                 transparentColor);
                return Add(original);
            }

            private int Add(Original original) {
                if (original == null || original.image == null) {
                    throw new ArgumentNullException("value");
                }
                
                int index = -1;

                AssertInvariant();
                
                if (original.image is Bitmap) {
                    if (owner.originals != null) {
                        index = owner.originals.Add(original);
                    }

                    if (owner.HandleCreated) {
                        Bitmap bitmapValue = owner.CreateBitmap(original);
                        index = owner.AddToHandle(original, bitmapValue);
                    }
                }
                else if (original.image is Icon) {
                    if (owner.originals != null) {
                        index = owner.originals.Add(original);
                    }
                    if (owner.HandleCreated) {
                        index = owner.AddIconToHandle(original, (Icon)original.image);
                    }
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.ImageListBitmap));
                }
                
                return index;
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.AddStrip"]/*' />
            /// <devdoc>
            ///     Add an image strip the given image to the ImageList.  A strip is a single Image
            ///     which is treated as multiple images arranged side-by-side.
            /// </devdoc>
            public int AddStrip(Image value) {
                
                if (value == null) {
                    throw new ArgumentNullException("value");
                }
                
                // strip width must be a positive multiple of image list width
                //
                if (value.Width == 0 || (value.Width % owner.ImageSize.Width) != 0)
                    throw new ArgumentException(SR.GetString(SR.ImageListStripBadWidth), "value");
                if (value.Height != owner.ImageSize.Height)
                    throw new ArgumentException(SR.GetString(SR.ImageListImageTooShort), "value");
                
                int nImages = value.Width / owner.ImageSize.Width;
                
                Original original = new Original(value, OriginalOptions.ImageStrip, nImages);
                
                return Add(original);
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Clear"]/*' />
            /// <devdoc>
            ///     Remove all images and masks from the ImageList.
            /// </devdoc>
            public void Clear() {
                AssertInvariant();
                if (owner.originals != null)
                    owner.originals.Clear();

                if (owner.HandleCreated)
                    SafeNativeMethods.ImageList_Remove(new HandleRef(owner, owner.Handle), -1);
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(Image image) {
                throw new NotSupportedException();
            }
        
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object image) {
                if (image is Image) {
                    return Contains((Image)image);
                }
                else {  
                    return false;
                }
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(Image image) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object image) {
                if (image is Image) {
                    return IndexOf((Image)image);
                }
                else {  
                    return -1;
                }
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                AssertInvariant();
                for (int i = 0; i < Count; ++i) {
                    dest.SetValue(owner.GetBitmap(i), index++);
                }
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                // Forces handle creation
                
                AssertInvariant();
                Image[] images = new Image[Count];
                for (int i = 0; i < images.Length; ++i)
                    images[i] = owner.GetBitmap(i);
                
                return images.GetEnumerator();
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Remove(Image image) {
                throw new NotSupportedException();                
            }
            
            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object image) {
                if (image is Image) {
                    Remove((Image)image);
                }                
            }

            /// <include file='doc\ImageList.uex' path='docs/doc[@for="ImageList.ImageCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void RemoveAt(int index) {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              index.ToString()));

                AssertInvariant();
                bool ok = SafeNativeMethods.ImageList_Remove(new HandleRef(owner, owner.Handle), index);
                if (!ok)
                    throw new InvalidOperationException(SR.GetString(SR.ImageListRemoveFailed));
            }

        } // end class ImageCollection
    }

    /// <include file='doc\ImageListConverter.uex' path='docs/doc[@for="ImageListConverter"]/*' />
    /// <internalonly/>
    internal class ImageListConverter : ComponentConverter {

        public ImageListConverter() : base(typeof(ImageList)) {
        }

        /// <include file='doc\ImageListConverter.uex' path='docs/doc[@for="ImageListConverter.GetPropertiesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object supports properties using the
        ///       specified context.</para>
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\inputlangchangeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputLangChangeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\InputLangChangeEventHandler.uex' path='docs/doc[@for="InputLanguageChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.Form.InputLanguageChanged'/> event of a
    ///    <see cref='System.Windows.Forms.Form'/>.
    ///    </para>
    /// </devdoc>
    public delegate void InputLanguageChangedEventHandler(object sender, InputLanguageChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\imemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMEMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies a value that determines the IME (Input Method Editor) status of the 
    ///       object when that object is selected.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum ImeMode {
    
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Inherit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inherit (Default). This value indicates inherit the ImeMode from the parent control. For controls with no parent,
        ///       the ImeMode will default to NoControl.
        ///    </para>
        /// </devdoc>
        Inherit = -1,

        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.NoControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       None. This value indicates "No control to IME". When the IMEMode property is set to 0, you can use the 
        ///       IMEStatus function to determine the current IME status. 
        ///    </para>
        /// </devdoc>
        NoControl = 0,

        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.On"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IME on. This value indicates that the IME is on and characters specific to Chinese or Japanese can be entered. 
        ///       This setting is valid for Japanese, Simplified Chinese, and Traditional Chinese IME only. 
        ///    </para>
        /// </devdoc>
        On = 1,

        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Off"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IME off. This mode indicates that the IME is off, meaning that the object behaves the same as English entry mode. 
        ///       This setting is valid for Japanese, Simplified Chinese, and Traditional Chinese IME only. 
        ///    </para>
        /// </devdoc>
        Off = 2,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Disable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IME disabled. This mode is similar to IMEMode = 2, except the value 3 disables IME. With this setting, the users 
        ///       cannot turn the IME on from the keyboard, and the IME floating window is hidden. This setting is valid for Japanese IME only. 
        ///    </para>
        /// </devdoc>
        Disable = 3,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Hiragana"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Hiragana double-byte characters (DBC). This setting is valid for Japanese IME only. 
        ///    </para>
        /// </devdoc>
        Hiragana = 4,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Katakana"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Katakana DBC. This setting is valid for Japanese IME only. 
        ///    </para>
        /// </devdoc>
        Katakana = 5,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.KatakanaHalf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Katakana single-byte characters (SBC). This setting is valid for Japanese IME only. 
        ///    </para>
        /// </devdoc>
        KatakanaHalf = 6,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.AlphaFull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Alphanumeric DBC. This setting is valid for Japanese IME only. 
        ///    </para>
        /// </devdoc>
        AlphaFull = 7,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Alpha"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Alphanumeric SBC. This setting is valid for Japanese IME only. 
        ///    </para>
        /// </devdoc>
        Alpha = 8,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.HangulFull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Hangeul DBC. This setting is valid for Korean IME only. 
        ///    </para>
        /// </devdoc>
        HangulFull = 9,
        
        /// <include file='doc\IMEMode.uex' path='docs/doc[@for="ImeMode.Hangul"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Hangeul SBC. This setting is valid for Korean IME only.
        ///    </para>
        /// </devdoc>
        Hangul = 10,
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\imessagefilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMessageFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;
    
    using System;
	using System.Security;
	using System.Security.Permissions;

    /// <include file='doc\IMessageFilter.uex' path='docs/doc[@for="IMessageFilter"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Defines a message filter interface.</para>
    /// </devdoc>
    public interface IMessageFilter {
    
        /// <include file='doc\IMessageFilter.uex' path='docs/doc[@for="IMessageFilter.PreFilterMessage"]/*' />
        /// <devdoc>
        ///    <para>Filters out a message before it is dispatched. </para>
        /// </devdoc>
		[
		System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
		]
		bool PreFilterMessage(ref Message m);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\inputlangchangerequesteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputLangChangeRequestEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\InputLangChangeRequestEventHandler.uex' path='docs/doc[@for="InputLanguageChangingEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.Form.InputLanguageChanging'/> event of a <see cref='System.Windows.Forms.Form'/>.
    ///    </para>
    /// </devdoc>
    public delegate void InputLanguageChangingEventHandler(object sender, InputLanguageChangingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\inputlangchangeevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputLangChangeEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Globalization;
    using System.Windows.Forms;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Form.InputLanguageChanged'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class InputLanguageChangedEventArgs : EventArgs {

        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.inputLanguage"]/*' />
        /// <devdoc>
        ///     The input language.
        /// </devdoc>
        private readonly InputLanguage inputLanguage;

        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.culture"]/*' />
        /// <devdoc>
        ///     The culture of the input language.
        /// </devdoc>
        private readonly CultureInfo culture;
        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.charSet"]/*' />
        /// <devdoc>
        ///     The charSet associated with the new input language.
        /// </devdoc>
        private readonly byte   charSet;

        /**
         * @deprecated.  Use the other constructor instead.
         */
        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.InputLanguageChangedEventArgs"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.InputLanguageChangedEventArgs'/> class with the
        ///       specified locale and character set.
        ///    </para>
        /// </devdoc>
        public InputLanguageChangedEventArgs(CultureInfo culture, byte charSet) {
            this.inputLanguage = System.Windows.Forms.InputLanguage.FromCulture(culture);
            this.culture = culture;
            this.charSet = charSet;
        }

        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.InputLanguageChangedEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.InputLanguageChangedEventArgs'/>class with the specified input language and
        ///       character set.
        ///    </para>
        /// </devdoc>
        public InputLanguageChangedEventArgs(InputLanguage inputLanguage, byte charSet) {
            this.inputLanguage = inputLanguage;
            this.culture = inputLanguage.Culture;
            this.charSet = charSet;
        }

        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.InputLanguage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the input language.
        ///    </para>
        /// </devdoc>
        public InputLanguage InputLanguage {
            get {
                return inputLanguage;
            }
        }

        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.Culture"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the locale of the input language.
        ///    </para>
        /// </devdoc>
        public CultureInfo Culture {
            get {
                return culture;
            }
        }

        /// <include file='doc\InputLangChangeEvent.uex' path='docs/doc[@for="InputLanguageChangedEventArgs.CharSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the character set associated with the new input language.
        ///    </para>
        /// </devdoc>
        public byte CharSet {
            get {
                  return charSet;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\inputlanguage.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputLanguage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Security.Permissions;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Globalization;
    using System.ComponentModel;
    using System.Drawing;

    /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides methods and fields to manage the input language.
    ///    </para>
    /// </devdoc>
    public sealed class InputLanguage {

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.handle"]/*' />
        /// <devdoc>
        ///     The HKL handle.
        /// </devdoc>
        /// <internalonly/>
        private readonly IntPtr handle;

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.InputLanguage"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal InputLanguage(IntPtr handle) {
            this.handle = handle;
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.Culture"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       the culture of the current input language.
        ///    </para>
        /// </devdoc>
        public CultureInfo Culture {
            get {
                return new CultureInfo((int)handle & 0xFFFF);
            }
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.CurrentInputLanguage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the input language for the current thread.
        ///    </para>
        /// </devdoc>
        public static InputLanguage CurrentInputLanguage {
            get {
                // note we can obtain the KeyboardLayout for a given thread...
                return new InputLanguage(SafeNativeMethods.GetKeyboardLayout(0));
            }
            set {
                IntSecurity.AffectThreadBehavior.Demand();
                if (value == null) {
                    value = InputLanguage.DefaultInputLanguage;
                }
                IntPtr handleOld = SafeNativeMethods.ActivateKeyboardLayout(new HandleRef(value, value.handle), 0);
                if (handleOld == IntPtr.Zero) {
                    throw new ArgumentException(SR.GetString(SR.ErrorBadInputLanguage), "value");
                }
            }
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.DefaultInputLanguage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the default input language for the system.
        ///    </para>
        /// </devdoc>
        public static InputLanguage DefaultInputLanguage {
            get {
                int[] data = new int[1];
                UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETDEFAULTINPUTLANG, 0, data, 0);
                return new InputLanguage((IntPtr)data[0]);
            }
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.Handle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the handle for the input language.
        ///    </para>
        /// </devdoc>
        public IntPtr Handle {
            get {
                return handle;
            }
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.InstalledInputLanguages"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a list of all installed input languages.
        ///    </para>
        /// </devdoc>
        public static InputLanguageCollection InstalledInputLanguages {
            get {
                int size = SafeNativeMethods.GetKeyboardLayoutList(0, null);
                
                int[] handles = new int[size];
                SafeNativeMethods.GetKeyboardLayoutList(size, handles);
    
                InputLanguage[] ils = new InputLanguage[size];
                for (int i = 0; i < size; i++)
                    ils[i] = new InputLanguage((IntPtr)handles[i]);
    
                return new InputLanguageCollection(ils);
            }
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.LayoutName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       the name of the current keyboard layout as it appears in the Windows Regional Settings on the computer.
        ///    </para>
        /// </devdoc>
        public string LayoutName {
            get {
                // There is no good way to do this in Win32...  GetKeyboardLayoutName does what we want,
                // but only for the current input language; setting and resetting the current input language
                // would generate spurious InputLanguageChanged events.
    
                /*
                            HKL is a 32 bit value. HIWORD is a Device Handle. LOWORD is Language ID.
                
                HKL
                +------------------------+-------------------------+
                |     Device Handle      |       Language ID       |
                +------------------------+-------------------------+
                31                     16 15                      0   bit
                
                
                Language ID
                +---------------------------+-----------------------+
                |     Sublanguage ID        | Primary Language ID   |
                +---------------------------+-----------------------+
                15                        10 9                     0   bit
                
                WORD LangId  = MAKELANGID(primary, sublang)
                BYTE primary = PRIMARYLANGID(LangId)
                BYTE sublang = PRIMARYLANGID(LangID)
                
                How Preload is interpreted: example US-Dvorak
                Look in HKEY_CURRENT_USER\Keyboard Layout\Preload
                Name="4"  (may vary)
                Value="d0000409"  -> Language ID = 0409
                Look in HKEY_CURRENT_USER\Keyboard Layout\Substitutes
                Name="d0000409"
                Value="00010409"
                Look in HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010409
                "Layout File": name of keyboard layout DLL (KBDDV.DLL)
                "Layout Id": ID of this layout (0002)
                Win32k will change the top nibble of layout ID to F, which makes F002.
                Combined with Language ID, the final HKL is F0020409.
                */
    
                string layoutName = null;
    
                IntPtr currentHandle = handle;
                int language = (int)currentHandle & 0xffff;
                int device = ((int)currentHandle >> 16) & 0x0fff;
    
                // SECREVIEW : We have to get the input information from the registry. These two 
                //           : keys only contain keyboard information. This is safe to do.
                //
                new RegistryPermission(PermissionState.Unrestricted).Assert();
                
                try {
                    if (device == language || device == 0) {
                        // Default keyboard for language
                        string keyName = Convert.ToString(language, 16);
                        keyName = PadWithZeroes(keyName, 8);
                        RegistryKey key = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\" + keyName);
                        layoutName = (string) key.GetValue("Layout Text");
                        key.Close();
                    }
                    else {
                    
                        // Look for a substitution 
                        //
                        RegistryKey substitutions = Registry.CurrentUser.OpenSubKey("Keyboard Layout\\Substitutes");
                        string[] encodings = substitutions.GetValueNames();
                        
                        foreach (string encoding in encodings) {
                            int encodingValue = Convert.ToInt32(encoding, 16);
                            if (encodingValue == (int)currentHandle || 
                                (encodingValue & 0x0FFFFFFF) == ((int)currentHandle & 0x0FFFFFFF) ||
                                (encodingValue & 0xFFFF) == language) {
                                
                                currentHandle = (IntPtr)Convert.ToInt32((string)substitutions.GetValue(encoding), 16);
                                language = (int)currentHandle & 0xFFFF;
                                device = ((int)currentHandle >> 16) & 0xFFF;
                                break;
                            }
                        }
                        
                        substitutions.Close();
                        
                        RegistryKey layouts = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts");
                        encodings = layouts.GetSubKeyNames();
                        
                        // Check to see if the encoding directly matches the handle -- some do.
                        //
                        foreach (string encoding in encodings) {
                            Debug.Assert(encoding.Length == 8, "unexpected key in registry: hklm\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\" + encoding);
                            if (currentHandle == (IntPtr)Convert.ToInt32(encoding, 16)) {
                                RegistryKey key = layouts.OpenSubKey(encoding);
                                layoutName = (string)key.GetValue("Layout Text");
                                key.Close();
                                break;
                            }
                        }
                        
                        if (layoutName == null) {
                        
                            // No luck there.  Match the language first, then try to find a layout ID
                            //
                            foreach (string encoding in encodings) {
                                Debug.Assert(encoding.Length == 8, "unexpected key in registry: hklm\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\" + encoding);
                                if (language == (0xffff & Convert.ToInt32(encoding.Substring(4,4), 16))) {
                                    RegistryKey key = layouts.OpenSubKey(encoding);
                                    string codeValue = (string) key.GetValue("Layout Id");
                                    if (codeValue != null) {
                                        int value = Convert.ToInt32(codeValue, 16);
                                        if (value == device) {
                                            layoutName = (string) key.GetValue("Layout Text");
                                        }
                                    }
                                    key.Close();
                                    if (layoutName != null) {
                                        break;
                                    }
                                }
                            }
                        }
                        
                        layouts.Close();
                    }
                }
                finally {
                    System.Security.CodeAccessPermission.RevertAssert();
                }
    
                if (layoutName == null) {
                    layoutName = SR.GetString(SR.UnknownInputLanguageLayout);
                }
                return layoutName;
            }
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.CreateInputLanguageChangedEventArgs"]/*' />
        /// <devdoc>
        ///     Creates an InputLanguageChangedEventArgs given a windows message.
        /// </devdoc>
        /// <internalonly/>
        internal static InputLanguageChangedEventArgs CreateInputLanguageChangedEventArgs(Message m) {
            return new InputLanguageChangedEventArgs(new InputLanguage(m.LParam), (byte)m.WParam);
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.CreateInputLanguageChangingEventArgs"]/*' />
        /// <devdoc>
        ///     Creates an InputLanguageChangingEventArgs given a windows message.
        /// </devdoc>
        /// <internalonly/>
        internal static InputLanguageChangingEventArgs CreateInputLanguageChangingEventArgs(Message m) {
            InputLanguage inputLanguage = new InputLanguage(m.LParam);

            // NOTE: by default we should allow any locale switch
            //
            bool localeSupportedBySystem = !(m.WParam == IntPtr.Zero);
            return new InputLanguageChangingEventArgs(inputLanguage, localeSupportedBySystem);

        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.Equals"]/*' />
        /// <devdoc>
        ///    <para>Specifies whether two input languages are equal.</para>
        /// </devdoc>
        public override bool Equals(object value) {
            if (value is InputLanguage) {
                return(this.handle == ((InputLanguage)value).handle);
            }
            return false;
        }

        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.FromCulture"]/*' />
        /// <devdoc>
        ///    <para>Returns the input language associated with the specified 
        ///       culture.</para>
        /// </devdoc>
        public static InputLanguage FromCulture(CultureInfo culture) {
        
            int lcid = culture.LCID;
            
            foreach(InputLanguage lang in InstalledInputLanguages) {
                if (((int)lang.handle & 0xFFFF) == lcid) {
                    return lang;
                }
            }

            return null;
        }
        
        /// <include file='doc\InputLanguage.uex' path='docs/doc[@for="InputLanguage.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>Hash code for this input language.</para>
        /// </devdoc>
        public override int GetHashCode() {
            return (int)handle;
        }

        private static string PadWithZeroes(string input, int length) {
            return "0000000000000000".Substring(0, length - input.Length) + input;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\inputlangchangerequestevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputLangChangeRequestEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Globalization;
    using System.Windows.Forms;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Form.InputLanguageChanging'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class InputLanguageChangingEventArgs : CancelEventArgs {

        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.inputLanguage"]/*' />
        /// <devdoc>
        ///     The requested input language.
        /// </devdoc>
        private readonly InputLanguage inputLanguage;

        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.culture"]/*' />
        /// <devdoc>
        ///     The locale of the requested input langugage.
        /// </devdoc>
        private readonly CultureInfo culture;
        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.sysCharSet"]/*' />
        /// <devdoc>
        ///     Set to true if the system default font supports the character
        ///     set required for the requested input language.
        /// </devdoc>
        private readonly bool sysCharSet;

        /**
         * @deprecated Should use the new constructor instead.
         */
        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.InputLanguageChangingEventArgs"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.InputLanguageChangingEventArgs'/> class with the
        ///       specified locale, character set, and acceptance.
        ///    </para>
        /// </devdoc>
        public InputLanguageChangingEventArgs(CultureInfo culture, bool sysCharSet) {

            this.inputLanguage = System.Windows.Forms.InputLanguage.FromCulture(culture);
            this.culture = culture;
            this.sysCharSet = sysCharSet;
        }

        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.InputLanguageChangingEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.InputLanguageChangingEventArgs'/> class with the
        ///       specified input language, character set, and acceptance of
        ///       a language change.
        ///    </para>
        /// </devdoc>
        public InputLanguageChangingEventArgs(InputLanguage inputLanguage, bool sysCharSet) {

            if (inputLanguage == null)
                throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,"inputLanguage"));

            this.inputLanguage = inputLanguage;
            this.culture = inputLanguage.Culture;
            this.sysCharSet = sysCharSet;
        }

        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.InputLanguage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the requested input language.
        ///    </para>
        /// </devdoc>
        public InputLanguage InputLanguage {
            get {
                return inputLanguage;
            }
        }

        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.Culture"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the locale of the requested input language.
        ///    </para>
        /// </devdoc>
        public CultureInfo Culture {
            get {
                return culture;
            }
        }

        /// <include file='doc\InputLangChangeRequestEvent.uex' path='docs/doc[@for="InputLanguageChangingEventArgs.SysCharSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the system default font supports the character
        ///       set required for the requested input language.
        ///    </para>
        /// </devdoc>
        public bool SysCharSet {
            get {
                return sysCharSet;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\invalidateeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="InvalidateEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\InvalidateEventHandler.uex' path='docs/doc[@for="InvalidateEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.Control.Invalidate'/> event
    ///       of a <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void InvalidateEventHandler(object sender, InvalidateEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\form.cs ===
//------------------------------------------------------------------------------
// <copyright file="Form.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace System.Windows.Forms {
    using System;
    using System.Security.Permissions;
    using System.Net;
    using System.Windows.Forms.Design;
    using System.Threading;
    using System.Security;
    using System.Security.Policy;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Globalization;
    using System.Drawing;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Collections;
    using System.Collections.Specialized;

    /// <include file='doc\Form.uex' path='docs/doc[@for="Form"]/*' />
    /// <devdoc>
    ///    <para>Represents a window or dialog box that makes up an application's user interface.</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    Designer("System.Windows.Forms.Design.FormDocumentDesigner, " + AssemblyRef.SystemDesign, typeof(IRootDesigner)),
    DesignerCategory("Form"),
    DefaultEvent("Load"),
    ]
    public class Form : ContainerControl {
#if DEBUG
        static readonly BooleanSwitch AlwaysRestrictWindows = new BooleanSwitch("AlwaysRestrictWindows", "Always make Form classes behave as though they are restricted");
#endif
        private static readonly object EVENT_ACTIVATED = new object();
        private static readonly object EVENT_CLOSING = new object();
        private static readonly object EVENT_CLOSED = new object();
        private static readonly object EVENT_DEACTIVATE = new object();
        private static readonly object EVENT_LOAD = new object();
        private static readonly object EVENT_MDI_CHILD_ACTIVATE = new object();
        private static readonly object EVENT_INPUTLANGCHANGE = new object();
        private static readonly object EVENT_INPUTLANGCHANGEREQUEST = new object();
        private static readonly object EVENT_MENUSTART = new object();
        private static readonly object EVENT_MENUCOMPLETE = new object();
        private static readonly object EVENT_MAXIMUMSIZECHANGED = new object();
        private static readonly object EVENT_MINIMUMSIZECHANGED = new object();

        private static readonly BitVector32.Section FormStateAllowLayered                = BitVector32.CreateSection(1);
        private static readonly BitVector32.Section FormStateBorderStyle                 = BitVector32.CreateSection(6, FormStateAllowLayered);
        private static readonly BitVector32.Section FormStateTaskBar                     = BitVector32.CreateSection(1, FormStateBorderStyle);
        private static readonly BitVector32.Section FormStateControlBox                  = BitVector32.CreateSection(1, FormStateTaskBar);
        private static readonly BitVector32.Section FormStateKeyPreview                  = BitVector32.CreateSection(1, FormStateControlBox);
        private static readonly BitVector32.Section FormStateLayered                     = BitVector32.CreateSection(1, FormStateKeyPreview);
        private static readonly BitVector32.Section FormStateMaximizeBox                 = BitVector32.CreateSection(1, FormStateLayered);
        private static readonly BitVector32.Section FormStateMinimizeBox                 = BitVector32.CreateSection(1, FormStateMaximizeBox);
        private static readonly BitVector32.Section FormStateHelpButton                  = BitVector32.CreateSection(1, FormStateMinimizeBox);
        private static readonly BitVector32.Section FormStateStartPos                    = BitVector32.CreateSection(4, FormStateHelpButton);
        private static readonly BitVector32.Section FormStateWindowState                 = BitVector32.CreateSection(2, FormStateStartPos);
        private static readonly BitVector32.Section FormStateShowWindowOnCreate          = BitVector32.CreateSection(1, FormStateWindowState);
        private static readonly BitVector32.Section FormStateAutoScaling                 = BitVector32.CreateSection(1, FormStateShowWindowOnCreate);
        private static readonly BitVector32.Section FormStateSetClientSize               = BitVector32.CreateSection(1, FormStateAutoScaling);
        private static readonly BitVector32.Section FormStateTopMost                     = BitVector32.CreateSection(1, FormStateSetClientSize);
        private static readonly BitVector32.Section FormStateSWCalled                    = BitVector32.CreateSection(1, FormStateTopMost);
        private static readonly BitVector32.Section FormStateMdiChildMax                 = BitVector32.CreateSection(1, FormStateSWCalled);
        private static readonly BitVector32.Section FormStateRenderSizeGrip              = BitVector32.CreateSection(1, FormStateMdiChildMax);
        private static readonly BitVector32.Section FormStateSizeGripStyle               = BitVector32.CreateSection(2, FormStateRenderSizeGrip);
        private static readonly BitVector32.Section FormStateIsRestrictedWindow          = BitVector32.CreateSection(1, FormStateSizeGripStyle);
        private static readonly BitVector32.Section FormStateIsRestrictedWindowChecked   = BitVector32.CreateSection(1, FormStateIsRestrictedWindow);
        private static readonly BitVector32.Section FormStateIsWindowActivated           = BitVector32.CreateSection(1, FormStateIsRestrictedWindowChecked);
        private static readonly BitVector32.Section FormStateIsTextEmpty                 = BitVector32.CreateSection(1, FormStateIsWindowActivated);
        private static readonly BitVector32.Section FormStateIsActive                    = BitVector32.CreateSection(1, FormStateIsTextEmpty);
        private static readonly BitVector32.Section FormStateIconSet                     = BitVector32.CreateSection(1, FormStateIsActive);
#if SECURITY_DIALOG
        private static readonly BitVector32.Section FormStateAddedSecurityMenuItem       = BitVector32.CreateSection(1, FormStateIconSet);
#endif
        private const int SizeGripSize = 16;

        private static Icon defaultIcon = null;
        private static Icon defaultRestrictedIcon = null;
        

        // Property store keys for properties.  The property store allocates most efficiently
        // in groups of four, so we try to lump properties in groups of four based on how
        // likely they are going to be used in a group.
        //
        private static readonly int PropAcceptButton           = PropertyStore.CreateKey();
        private static readonly int PropCancelButton           = PropertyStore.CreateKey();
        private static readonly int PropDefaultButton          = PropertyStore.CreateKey();
        private static readonly int PropDialogOwner            = PropertyStore.CreateKey();

        private static readonly int PropMainMenu               = PropertyStore.CreateKey();
        private static readonly int PropDummyMenu              = PropertyStore.CreateKey();
        private static readonly int PropCurMenu                = PropertyStore.CreateKey();
        private static readonly int PropMergedMenu             = PropertyStore.CreateKey();

        private static readonly int PropOwner                  = PropertyStore.CreateKey();
        private static readonly int PropOwnedForms             = PropertyStore.CreateKey();
        private static readonly int PropMaximizedBounds        = PropertyStore.CreateKey();
        private static readonly int PropOwnedFormsCount        = PropertyStore.CreateKey();

        private static readonly int PropMinTrackSizeWidth      = PropertyStore.CreateKey();
        private static readonly int PropMinTrackSizeHeight     = PropertyStore.CreateKey();
        private static readonly int PropMaxTrackSizeWidth      = PropertyStore.CreateKey();
        private static readonly int PropMaxTrackSizeHeight     = PropertyStore.CreateKey();

        private static readonly int PropFormMdiParent          = PropertyStore.CreateKey();
        private static readonly int PropActiveMdiChild         = PropertyStore.CreateKey();
        private static readonly int PropOpacity                = PropertyStore.CreateKey();
        private static readonly int PropTransparencyKey        = PropertyStore.CreateKey();

        private static readonly int PropSecurityTip            = PropertyStore.CreateKey();
#if SECURITY_DIALOG                                    
        private static readonly int PropSecuritySystemMenuItem = PropertyStore.CreateKey();
#endif
        
        ///////////////////////////////////////////////////////////////////////
        // Form per instance members
        //
        // Note: Do not add anything to this list unless absolutely neccessary.
        //
        // Begin Members {

        // List of properties that are generally set, so we keep them directly on
        // Form.
        //

        private BitVector32      formState = new BitVector32(0x21338);   // magic value... all the defaults... see the ctor for details...
        private Icon             icon;
        private Icon             smallIcon;
        private Size             autoScaleBaseSize = System.Drawing.Size.Empty;
        private Rectangle        restoredWindowBounds = new Rectangle(-1, -1, -1, -1);
        private BoundsSpecified  restoredWindowBoundsSpecified;
        private DialogResult     dialogResult;
        private MdiClient        ctlClient;
        private byte             updateMenuHandlesSuspendCount;
        private bool             updateMenuHandlesDeferred;
        private bool             useMdiChildProc;
        private string           userWindowText;
        private string           securityZone;
        private string           securitySite;
        
        private bool             calledOnLoad;
        private bool             calledMakeVisible;
        private bool             calledCreateControl = false;

        // } End Members
        ///////////////////////////////////////////////////////////////////////
                    

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Form"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Form'/> class.
        ///    </para>
        /// </devdoc>
        public Form()
        : base() {

            // we must setup the formState *before* calling Control's ctor... so we do that
            // at the member variable... that magic number is generated by switching
            // the line below to "true" and running a form.
            //
            // keep the "init" and "assert" sections always in sync!
            //
#if false
            // init section...
            //
            formState[FormStateAllowLayered]                = 0;
            formState[FormStateBorderStyle]                 = (int)FormBorderStyle.Sizable;
            formState[FormStateTaskBar]                     = 1;
            formState[FormStateControlBox]                  = 1;
            formState[FormStateKeyPreview]                  = 0;
            formState[FormStateLayered]                     = 0;
            formState[FormStateMaximizeBox]                 = 1;
            formState[FormStateMinimizeBox]                 = 1;
            formState[FormStateHelpButton]                  = 0;
            formState[FormStateStartPos]                    = (int)FormStartPosition.WindowsDefaultLocation;
            formState[FormStateWindowState]                 = (int)FormWindowState.Normal;
            formState[FormStateShowWindowOnCreate]          = 0;
            formState[FormStateAutoScaling]                 = 1;
            formState[FormStateSetClientSize]               = 0;
            formState[FormStateTopMost]                     = 0;
            formState[FormStateSWCalled]                    = 0;
            formState[FormStateMdiChildMax]                 = 0;
            formState[FormStateRenderSizeGrip]              = 0;
            formState[FormStateSizeGripStyle]               = 0;
            formState[FormStateIsRestrictedWindow]          = 0;
            formState[FormStateIsRestrictedWindowChecked]   = 0;
            formState[FormStateIsWindowActivated]           = 0;
            formState[FormStateIsTextEmpty]                 = 0;
            formState[FormStateIsActive]                    = 0;
            formState[FormStateIconSet]                     = 0;
#if SECURITY_DIALOG
            formState[FormStateAddedSecurityMenuItem]       = 0;
#endif



            Debug.WriteLine("initial formState: 0x" + formState.Data.ToString("X"));
#endif
            // assert section...
            //
            Debug.Assert(formState[FormStateAllowLayered]                == 0, "Failed to set formState[FormStateAllowLayered]");
            Debug.Assert(formState[FormStateBorderStyle]                 == (int)FormBorderStyle.Sizable, "Failed to set formState[FormStateBorderStyle]");
            Debug.Assert(formState[FormStateTaskBar]                     == 1, "Failed to set formState[FormStateTaskBar]");
            Debug.Assert(formState[FormStateControlBox]                  == 1, "Failed to set formState[FormStateControlBox]");
            Debug.Assert(formState[FormStateKeyPreview]                  == 0, "Failed to set formState[FormStateKeyPreview]");
            Debug.Assert(formState[FormStateLayered]                     == 0, "Failed to set formState[FormStateLayered]");
            Debug.Assert(formState[FormStateMaximizeBox]                 == 1, "Failed to set formState[FormStateMaximizeBox]");
            Debug.Assert(formState[FormStateMinimizeBox]                 == 1, "Failed to set formState[FormStateMinimizeBox]");
            Debug.Assert(formState[FormStateHelpButton]                  == 0, "Failed to set formState[FormStateHelpButton]");
            Debug.Assert(formState[FormStateStartPos]                    == (int)FormStartPosition.WindowsDefaultLocation, "Failed to set formState[FormStateStartPos]");
            Debug.Assert(formState[FormStateWindowState]                 == (int)FormWindowState.Normal, "Failed to set formState[FormStateWindowState]");
            Debug.Assert(formState[FormStateShowWindowOnCreate]          == 0, "Failed to set formState[FormStateShowWindowOnCreate]");
            Debug.Assert(formState[FormStateAutoScaling]                 == 1, "Failed to set formState[FormStateAutoScaling]");
            Debug.Assert(formState[FormStateSetClientSize]               == 0, "Failed to set formState[FormStateSetClientSize]");
            Debug.Assert(formState[FormStateTopMost]                     == 0, "Failed to set formState[FormStateTopMost]");
            Debug.Assert(formState[FormStateSWCalled]                    == 0, "Failed to set formState[FormStateSWCalled]");
            Debug.Assert(formState[FormStateMdiChildMax]                 == 0, "Failed to set formState[FormStateMdiChildMax]");
            Debug.Assert(formState[FormStateRenderSizeGrip]              == 0, "Failed to set formState[FormStateRenderSizeGrip]");
            Debug.Assert(formState[FormStateSizeGripStyle]               == 0, "Failed to set formState[FormStateSizeGripStyle]");
            // can't check these... Control::.ctor may force the check
            // of security... you can only assert these are 0 when running
            // under full trust...
            //
            //Debug.Assert(formState[FormStateIsRestrictedWindow]          == 0, "Failed to set formState[FormStateIsRestrictedWindow]");
            //Debug.Assert(formState[FormStateIsRestrictedWindowChecked]   == 0, "Failed to set formState[FormStateIsRestrictedWindowChecked]");
            Debug.Assert(formState[FormStateIsWindowActivated]           == 0, "Failed to set formState[FormStateIsWindowActivated]");
            Debug.Assert(formState[FormStateIsTextEmpty]                 == 0, "Failed to set formState[FormStateIsTextEmpty]");
            Debug.Assert(formState[FormStateIsActive]                    == 0, "Failed to set formState[FormStateIsActive]");
            Debug.Assert(formState[FormStateIconSet]                     == 0, "Failed to set formState[FormStateIconSet]");
#if SECURITY_DIALOG
            Debug.Assert(formState[FormStateAddedSecurityMenuItem]       == 0, "Failed to set formState[FormStateAddedSecurityMenuItem]");
#endif
            
            
            SetState(STATE_VISIBLE, false);
            SetState(STATE_TOPLEVEL, true);
            
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AcceptButton"]/*' />
        /// <devdoc>
        /// <para>Indicates the <see cref='System.Windows.Forms.Button'/> control on the form that is clicked when
        ///    the user presses the ENTER key.</para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.FormAcceptButtonDescr)
        ]
        public IButtonControl AcceptButton {
            get {
                return (IButtonControl)Properties.GetObject(PropAcceptButton);
            }
            set {
                if (AcceptButton != value) {
                    Properties.SetObject(PropAcceptButton, value);
                    UpdateDefaultButton();
                    
                    // this was removed as it breaks any accept button that isn't
                    // an OK, like in the case of wizards 'next' button.  it was
                    // added as a fix to 47209...which has been reactivated.
                    /*
                    if (acceptButton != null && acceptButton.DialogResult == DialogResult.None) {
                        acceptButton.DialogResult = DialogResult.OK;
                    }
                    */
                }
            }
        }

        /// <devdoc>
        ///     Retrieves true if this form is currently active.
        /// </devdoc>
        internal bool Active {
            get {
                Form parentForm = ParentFormInternal;
                if (parentForm == null) {
                    return formState[FormStateIsActive] != 0;
                }
                return(parentForm.ActiveControl == this && parentForm.Active);
            }

            set {
                if ((formState[FormStateIsActive] != 0) != value) {
                    if (value) {
                        // There is a wierd user32 bug (see 124232) where it will
                        // activate the MDIChild even when it is not visible, when
                        // we set it's parent handle. Ignore this. We will get
                        // activated again when the MDIChild's visibility is set to true.
                        if (IsMdiChildAndNotVisible)
                            return;
                    }

                    formState[FormStateIsActive] = value ? 1 : 0;
                    
                    if (value) {

                        // SECREVIEW : This internal method is called from various places, all 
                        //           : of which are OK. Since SelectNextControl (a public function)
                        //           : Demands ModifyFocus, we must assert it.
                        //
                        IntSecurity.ModifyFocus.Assert();
                        try {
                            if (ActiveControl == null) {
                                SelectNextControl(null, true, true, true, false);
                                // If no control is selected focus will go to form
                            }
                            InnerMostActiveContainerControl.FocusActiveControlInternal();
                            formState[FormStateIsWindowActivated] = 1;
                            if (IsRestrictedWindow) {
                                WindowText = userWindowText;
                            }
                            OnActivated(EventArgs.Empty);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    else {
                        formState[FormStateIsWindowActivated] = 0;
                        if (IsRestrictedWindow) {
                            Text = userWindowText;
                        }
                        OnDeactivate(EventArgs.Empty);
                    }
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ActiveForm"]/*' />
        /// <devdoc>
        ///    <para> Gets the currently active form for this application.</para>
        /// </devdoc>
        public static Form ActiveForm {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
                IntSecurity.GetParent.Demand();

                IntPtr hwnd = UnsafeNativeMethods.GetForegroundWindow();
                Control c = Control.FromHandleInternal(hwnd);
                if (c != null && c is Form) {
                    return(Form)c;
                }
                return null;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ActiveMdiChild"]/*' />
        /// <devdoc>
        ///    <para> Gets the currently active
        ///       multiple
        ///       document interface (MDI) child window.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormActiveMDIChildDescr)
        ]
        public Form ActiveMdiChild {
            get {
                return (Form)Properties.GetObject(PropActiveMdiChild);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AllowTransparency"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> 
        ///       Gets or sets
        ///       a value indicating whether the opacity of the form can be
        ///       adjusted.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlAllowTransparencyDescr)
        ]
        public bool AllowTransparency {
            get {
                return formState[FormStateAllowLayered] != 0;
            }
            set {
                if (value != (formState[FormStateAllowLayered] != 0) && OSFeature.Feature.IsPresent(OSFeature.LayeredWindows)) {
                    formState[FormStateAllowLayered] = (value ? 1 : 0);

                    UpdateStyles();

                    if (!value && (formState[FormStateLayered] != 0)) {
                        formState[FormStateLayered] = 0;
                    }

                    if (!value) {
                        if (Properties.ContainsObject(PropOpacity)) {
                            Properties.SetObject(PropOpacity, (object)1.0f);
                        }
                        if (Properties.ContainsObject(PropTransparencyKey)) {
                            Properties.SetObject(PropTransparencyKey, Color.Empty);
                        }
                        UpdateLayered();
                    }
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AutoScale"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the form will adjust its size
        ///       to fit the height of the font used on the form and scale
        ///       its controls.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        DefaultValue(true),
        SRDescription(SR.FormAutoScaleDescr)
        ]
        public bool AutoScale {
            get {
                return formState[FormStateAutoScaling] != 0;
            }

            set {
                if (value) {
                    formState[FormStateAutoScaling] = 1;
                }
                else {
                    formState[FormStateAutoScaling] = 0;
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AutoScaleBaseSize"]/*' />
        /// <devdoc>
        ///     The base size used for autoscaling. The AutoScaleBaseSize is used
        ///     internally to determine how much to scale the form when AutoScaling is
        ///     used.
        /// </devdoc>
        //
        // Virtual so subclasses like PrintPreviewDialog can prevent changes.
        [
        Localizable(true),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public virtual Size AutoScaleBaseSize {
            get {
                if (autoScaleBaseSize.IsEmpty) {
                    SizeF real = GetAutoScaleSize(Font); 
                    return new Size((int)Math.Round(real.Width), (int)Math.Round(real.Height));
                }
                return autoScaleBaseSize;
            }

            set {
                // Only allow the set when not in designmode, this prevents us from
                // preserving an old value.  The form design should prevent this for
                // us by shadowing this property, so we just assert that the designer
                // is doing its job.
                //
                Debug.Assert(!DesignMode, "Form designer should not allow base size set in design mode.");
                autoScaleBaseSize = value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AutoScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the form implements
        ///       autoscrolling.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override bool AutoScroll {
            get { return base.AutoScroll;}

            set {
                if (value) {
                    IsMdiContainer = false;
                }
                base.AutoScroll = value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.BackColor"]/*' />
        /// <devdoc>
        ///     The background color of this control. This is an ambient property and
        ///     will always return a non-null value.
        /// </devdoc>
        public override Color BackColor {
            get {
                // Forms should not inherit BackColor from their parent,
                // particularly if the parent is an MDIClient.
                Color c = RawBackColor; // inheritedProperties.BackColor
                if (!c.IsEmpty)
                    return c;

                return DefaultBackColor;
            }

            set {
                base.BackColor = value;
            }
        }

        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.FormBorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border style of the form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(FormBorderStyle.Sizable),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.FormBorderStyleDescr)
        ]
        public FormBorderStyle FormBorderStyle {
            get {
                return(FormBorderStyle)formState[FormStateBorderStyle];
            }

            set {
                //validate FormBorderStyle enum
                //
                if (!Enum.IsDefined(typeof(FormBorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FormBorderStyle));
                }

                if (IsRestrictedWindow) {
                    switch (value) {
                        case FormBorderStyle.None:
                            value = FormBorderStyle.FixedSingle;
                            break;
                        case FormBorderStyle.FixedSingle:
                        case FormBorderStyle.Fixed3D:
                        case FormBorderStyle.FixedDialog:
                        case FormBorderStyle.Sizable:
                            // nothing needed here, we can just let these stay
                            //
                            break;
                        case FormBorderStyle.FixedToolWindow:
                            value = FormBorderStyle.FixedSingle;
                            break;
                        case FormBorderStyle.SizableToolWindow:
                            value = FormBorderStyle.Sizable;
                            break;
                        default:
                            value = FormBorderStyle.Sizable;
                            break;
                    }
                }

                formState[FormStateBorderStyle] = (int)value;
                
                if (formState[FormStateIconSet] == 0 && !IsRestrictedWindow) {
                    UpdateWindowIcon(false);
                }
                
                //(bug 112024).. It seems that the FormBorderStyle is Code serialised after the ClientSize is Set...
                //Hence in the Setter for FormBodrstyle we need to push in the Correct ClientSize once again..
                if (formState[FormStateSetClientSize] == 1 && !IsHandleCreated) {
                    ClientSize = ClientSize;
                }
                
                UpdateFormStyles();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.CancelButton"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or
        ///       sets the button control that will be clicked when the
        ///       user presses the ESC key.</para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.FormCancelButtonDescr)
        ]
        public IButtonControl CancelButton {
            get {
                return (IButtonControl)Properties.GetObject(PropCancelButton);
            }
            set {
                Properties.SetObject(PropCancelButton, value);
                
                if (value != null && value.DialogResult == DialogResult.None) {
                    value.DialogResult = DialogResult.Cancel;
                }
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ClientSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the size of the client area of the form.
        ///    </para>
        /// </devdoc>
        [Localizable(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        new public Size ClientSize {
            get {
                return base.ClientSize;
            }
            set {
                base.ClientSize = value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ControlBox"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether a control box is displayed in the
        ///       caption bar of the form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(true),
        SRDescription(SR.FormControlBoxDescr)
        ]
        public bool ControlBox {
            get {
                return formState[FormStateControlBox] != 0;
            }

            set {
                if (IsRestrictedWindow) {
                    return;
                }

                if (value) {
                    formState[FormStateControlBox] = 1;
                }
                else {
                    formState[FormStateControlBox] = 0;
                }
                UpdateFormStyles();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Retrieves the CreateParams used to create the window.
        ///    If a subclass overrides this function, it must call the base implementation.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;

                // It doesn't seem to make sense to allow a top-level form to be disabled
                //
                if (TopLevel) {
                    cp.Style &= (~NativeMethods.WS_DISABLED);                           
                }
                           
                if (TopLevel && (formState[FormStateAllowLayered] != 0)) {
                    cp.ExStyle |= NativeMethods.WS_EX_LAYERED;
                }

                IWin32Window dialogOwner = (IWin32Window)Properties.GetObject(PropDialogOwner);
                if (dialogOwner != null) {
                    cp.Parent = dialogOwner.Handle;
                }

                FillInCreateParamsBorderStyles(cp);
                FillInCreateParamsWindowState(cp);
                FillInCreateParamsBorderIcons(cp);

                if (formState[FormStateTaskBar] != 0) {
                    cp.ExStyle |= NativeMethods.WS_EX_APPWINDOW;
                }

                if (IsMdiChild) {
                    if (Visible
                            && (WindowState == FormWindowState.Maximized
                                || WindowState == FormWindowState.Normal)) {
                        Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
                        Form form = formMdiParent.ActiveMdiChild;

                        if (form != null
                            && form.WindowState == FormWindowState.Maximized) {
                            cp.Style |= NativeMethods.WS_MAXIMIZE;
                            formState[FormStateWindowState] = (int)FormWindowState.Maximized;
                            SetState(STATE_SIZELOCKEDBYOS, true);
                        }
                    }

                    if (formState[FormStateMdiChildMax] != 0) {
                        cp.Style |= NativeMethods.WS_MAXIMIZE;
                    }

                    cp.ExStyle |= NativeMethods.WS_EX_MDICHILD;                                 
                }

                if (TopLevel || IsMdiChild) {
                    FillInCreateParamsStartPosition(cp);
                    // Delay setting to visible until after the handle gets created
                    // to allow applyClientSize to adjust the size before displaying
                    // the form.
                    //
                    if ((cp.Style & NativeMethods.WS_VISIBLE) != 0) {
                        formState[FormStateShowWindowOnCreate] = 1;
                        cp.Style &= (~NativeMethods.WS_VISIBLE);
                    }
                }

                if (IsRestrictedWindow) {
                    cp.Caption = RestrictedWindowText(cp.Caption);
                }

                return cp;
            }
        }

        /// <devdoc>
        ///     The default icon used by the Form. This is the standard "windows forms" icon.
        /// </devdoc>
        private static Icon DefaultIcon {
            get {
                // Avoid locking if the value is filled in...
                //
                if (defaultIcon == null) {
                    lock(typeof(Form)) {
                        // Once we grab the lock, we re-check the value to avoid a
                        // race condition.
                        //
                        if (defaultIcon == null) {
                            // SECREVIEW : Safe loading of known icons
                            //
                            IntSecurity.ObjectFromWin32Handle.Assert();
                            try {
                                defaultIcon = new Icon(typeof(Form), "wfc.ico");
                            }
                            finally {
                                CodeAccessPermission.RevertAssert();
                            }
                        }
                    }
                }
                return defaultIcon;
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.NoControl;
            }
        }

        /// <devdoc>
        ///     The default icon used by the Form. This is the standard "windows forms" icon.
        /// </devdoc>
        private static Icon DefaultRestrictedIcon {
            get {
                // Note: We do this as a static property to allow delay
                // loading of the resource. There are some issues with doing
                // an OleInitialize from a static constructor...
                //

                // Avoid locking if the value is filled in...
                //
                if (defaultRestrictedIcon == null) {
                    lock(typeof(Form)) {
                        // Once we grab the lock, we re-check the value to avoid a
                        // race condition.
                        //
                        if (defaultRestrictedIcon == null) {
                            // SECREVIEW : Safe loading of known icons
                            //
                            IntSecurity.ObjectFromWin32Handle.Assert();
                            try {
                                defaultRestrictedIcon = new Icon(typeof(Form), "wfsecurity.ico");
                            }
                            finally {
                                CodeAccessPermission.RevertAssert();
                            }
                        }
                    }
                }
                return defaultRestrictedIcon;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(300, 300);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.DesktopBounds"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the size and location of the form on the Windows desktop.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormDesktopBoundsDescr)
        ]
        public Rectangle DesktopBounds {
            get {
                Rectangle screen = SystemInformation.WorkingArea;
                Rectangle bounds = Bounds;
                bounds.X -= screen.X;
                bounds.Y -= screen.Y;
                return bounds;
            }

            set {
                SetDesktopBounds(value.X, value.Y, value.Width, value.Height);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.DesktopLocation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the location of the form on the Windows desktop.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormDesktopLocationDescr)
        ]
        public Point DesktopLocation {
            get {
                Rectangle screen = SystemInformation.WorkingArea;
                Point loc = Location;
                loc.X -= screen.X;
                loc.Y -= screen.Y;
                return loc;
            }

            set {
                SetDesktopLocation(value.X, value.Y);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.DialogResult"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the dialog result for the form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormDialogResultDescr)
        ]
        public DialogResult DialogResult {
            get {
                return dialogResult;
            }

            set {
                if ( !Enum.IsDefined(typeof(DialogResult), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DialogResult));
                }

                dialogResult = value;
            }
        }
        
        internal override bool HasMenu {
            get {
                bool hasMenu = false;
                if (TopLevel && Menu != null) {
                    hasMenu = true;
                }
                return hasMenu;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.HelpButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a
        ///       help button should be displayed in the caption box of the form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(false),
        SRDescription(SR.FormHelpButtonDescr)
        ]
        public bool HelpButton {
            get {
                return formState[FormStateHelpButton] != 0;
            }

            set {
                if (value) {
                    formState[FormStateHelpButton] = 1;
                }
                else {
                    formState[FormStateHelpButton] = 0;
                }
                UpdateFormStyles();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Icon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the icon for the form.
        ///    </para>
        /// </devdoc>
        [
        AmbientValue(null),
        Localizable(true),
        SRCategory(SR.CatWindowStyle),
        SRDescription(SR.FormIconDescr)
        ]
        public Icon Icon {
            get {
                if (formState[FormStateIconSet] == 0) {
                    if (IsRestrictedWindow) {
                        return DefaultRestrictedIcon;
                    }
                    else {
                        return DefaultIcon;
                    }
                }
                
                return icon;
            }

            set {
                if (icon != value && !IsRestrictedWindow) {

                    // If the user is poking the default back in, 
                    // treat this as a null (reset).
                    //
                    if (value == defaultIcon) {
                        value = null;
                    }

                    // And if null is passed, reset the icon.
                    //
                    formState[FormStateIconSet] = (value == null ? 0 : 1);
                    this.icon = value;

                    if (smallIcon != null) {
                        smallIcon.Dispose();
                        smallIcon = null;
                    }
                    
                    UpdateWindowIcon(true);
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.IsMdiChild"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the form is a multiple document
        ///       interface (MDI) child form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormIsMDIChildDescr)
        ]
        public bool IsMdiChild {
            get {
                return (Properties.GetObject(PropFormMdiParent) != null);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.IsMdiContainer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the form is a container for multiple document interface
        ///       (MDI) child forms.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(false),
        SRDescription(SR.FormIsMDIContainerDescr)
        ]
        public bool IsMdiContainer {
            get {
                return ctlClient != null;
            }

            set {
                if (value == IsMdiContainer)
                    return;
                if (value) {
                    Debug.Assert(ctlClient == null, "why isn't ctlClient null");

                    Controls.Add(new MdiClient());
                }
                else {
                    Debug.Assert(ctlClient != null, "why is ctlClient null");
                    Properties.SetObject(PropActiveMdiChild, null);
                    
                    ctlClient.Dispose();
                }
                //since we paint the background when mdi is true, we need
                //to invalidate here
                //
                Invalidate();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.KeyPreview"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the form will receive key events
        ///       before the event is passed to the control that has focus.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FormKeyPreviewDescr)
        ]
        public bool KeyPreview {
            get {
                return formState[FormStateKeyPreview] != 0;
            }
            set {
                if (value) {
                    formState[FormStateKeyPreview] = 1;
                }
                else {
                    formState[FormStateKeyPreview] = 0;
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MaximizedBounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the size of the form when it is
        ///       maximized.
        ///    </para>
        /// </devdoc>
        protected Rectangle MaximizedBounds {
            get {
                object maximizedBounds = Properties.GetObject(PropMaximizedBounds);
                if (maximizedBounds != null) {
                    return (Rectangle)maximizedBounds;
                }
                else {
                    return Rectangle.Empty;
                }
            }
            set {
                if (!value.Equals( MaximizedBounds )) {
                    Properties.SetObject(PropMaximizedBounds, value);
                    OnMaximizedBoundsChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_MAXIMIZEDBOUNDSCHANGED = new object();

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MaximizedBoundsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.FormOnMaximizedBoundsChangedDescr)]
        public event EventHandler MaximizedBoundsChanged {
            add {
                Events.AddHandler(EVENT_MAXIMIZEDBOUNDSCHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_MAXIMIZEDBOUNDSCHANGED, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MaximumSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the maximum size the form can be resized to.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        SRDescription(SR.FormMaximumSizeDescr),
        RefreshProperties(RefreshProperties.Repaint),
        DefaultValue(typeof(Size), "0, 0")
        ]
        public Size MaximumSize {
            get {
                if (Properties.ContainsInteger(PropMaxTrackSizeWidth)) {
                    return new Size(Properties.GetInteger(PropMaxTrackSizeWidth), Properties.GetInteger(PropMaxTrackSizeHeight));
                }
                return Size.Empty;
            }
            set {
                if (!value.Equals( MaximumSize )) {
                
                    if (value.Width < 0 || value.Height < 0 ) {
                        throw new ArgumentOutOfRangeException("value");
                    }
                    
                    Properties.SetInteger(PropMaxTrackSizeWidth, value.Width);
                    Properties.SetInteger(PropMaxTrackSizeHeight, value.Height);
                    
                    // Bump minimum size if necessary
                    //
                    if (!MinimumSize.IsEmpty && !value.IsEmpty) {
                    
                        if (Properties.GetInteger(PropMinTrackSizeWidth) > value.Width) {
                            Properties.SetInteger(PropMinTrackSizeWidth, value.Width);
                        }
                        
                        if (Properties.GetInteger(PropMinTrackSizeHeight) > value.Height) {
                            Properties.SetInteger(PropMinTrackSizeHeight, value.Height);
                        }
                    }
                    
                    // Keep form size within new limits
                    //
                    Size size = Size;
                    if (!value.IsEmpty && (size.Width > value.Width || size.Height > value.Height)) {
                        Size = new Size(Math.Min(size.Width, value.Width), Math.Min(size.Height, value.Height));
                    }
                    
                    OnMaximumSizeChanged(EventArgs.Empty);
                }
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MaximumSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.FormOnMaximumSizeChangedDescr)]
        public event EventHandler MaximumSizeChanged {
            add {
                Events.AddHandler(EVENT_MAXIMUMSIZECHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_MAXIMUMSIZECHANGED, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Menu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.MainMenu'/>
        ///       that is displayed in the form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(null),
        SRDescription(SR.FormMenuDescr)
        ]
        public MainMenu Menu {
            get { 
                return (MainMenu)Properties.GetObject(PropMainMenu);
            }
            set {
                MainMenu mainMenu = Menu;
                
                if (mainMenu != value) {
                    if (mainMenu != null) {
                        mainMenu.form = null;
                    }
                    
                    Properties.SetObject(PropMainMenu, value);
                    
                    if (value != null) {
                        if (value.form != null) {
                            value.form.Menu = null;
                        }
                        value.form = this;
                    }
                    
                    if (formState[FormStateSetClientSize] == 1 && !IsHandleCreated) {
                        ClientSize = ClientSize;
                    }
                    
                    MenuChanged(Windows.Forms.Menu.CHANGE_ITEMS, value);
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MinimumSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the minimum size the form can be resized to.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        SRDescription(SR.FormMinimumSizeDescr),
        RefreshProperties(RefreshProperties.Repaint),
        DefaultValue(typeof(Size), "0, 0")
        ]
        public Size MinimumSize {
            get {
                if (Properties.ContainsInteger(PropMinTrackSizeWidth)) {
                    return new Size(Properties.GetInteger(PropMinTrackSizeWidth), Properties.GetInteger(PropMinTrackSizeHeight));
                }
                return Size.Empty;
            }
            set {
                if (!value.Equals( MinimumSize )) {
                
                    if (value.Width < 0 || value.Height < 0 ) {
                        throw new ArgumentOutOfRangeException("value");
                    }

                    Properties.SetInteger(PropMinTrackSizeWidth, value.Width);
                    Properties.SetInteger(PropMinTrackSizeHeight, value.Height);
                    
                    // Bump maximum size if necessary
                    //
                    if (!MaximumSize.IsEmpty && !value.IsEmpty) {
                    
                        if (Properties.GetInteger(PropMaxTrackSizeWidth) < value.Width) {
                            Properties.SetInteger(PropMaxTrackSizeWidth, value.Width);
                        }
                        
                        if (Properties.GetInteger(PropMaxTrackSizeHeight) < value.Height) {
                            Properties.SetInteger(PropMaxTrackSizeHeight, value.Height);
                        }
                    }
                    
                    // Keep form size within new limits
                    //
                    Size size = Size;
                    if (size.Width < value.Width || size.Height < value.Height) {
                        Size = new Size(Math.Max(size.Width, value.Width), Math.Max(size.Height, value.Height));
                    }                             
                             
                    OnMinimumSizeChanged(EventArgs.Empty);
                }
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MinimumSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.FormOnMinimumSizeChangedDescr)]
        public event EventHandler MinimumSizeChanged {
            add {
                Events.AddHandler(EVENT_MINIMUMSIZECHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_MINIMUMSIZECHANGED, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MaximizeBox"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the maximize button is
        ///       displayed in the caption bar of the form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(true),
        SRDescription(SR.FormMaximizeBoxDescr)
        ]
        public bool MaximizeBox {
            get {
                return formState[FormStateMaximizeBox] != 0;
            }
            set {
                if (value) {
                    formState[FormStateMaximizeBox] = 1;
                }
                else {
                    formState[FormStateMaximizeBox] = 0;
                }
                UpdateFormStyles();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MdiChildren"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an array of forms that represent the
        ///       multiple document interface (MDI) child forms that are parented to this
        ///       form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormMDIChildrenDescr)
        ]
        public Form[] MdiChildren {
            get {
                if (ctlClient != null) {
                    return ctlClient.MdiChildren;
                }
                else {
                    return new Form[0];
                }
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MdiParent"]/*' />
        /// <devdoc>
        ///    <para> Indicates the current multiple document
        ///       interface (MDI) parent form of this form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormMDIParentDescr)
        ]
        public Form MdiParent {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
                IntSecurity.GetParent.Demand();

                return MdiParentInternal;
            }
            set {
                MdiParentInternal = value;
            }
        }

        internal Form MdiParentInternal {
            get {
                return (Form)Properties.GetObject(PropFormMdiParent);
            }
            set {
                Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
                if (value == formMdiParent && (value != null || ParentInternal == null)) {
                    return;
                }
                
                if (value != null && this.CreateThreadId != value.CreateThreadId) {
                    throw new ArgumentException(SR.GetString(SR.AddDifferentThreads), "value");
                }

                bool oldVisibleBit = GetState(STATE_VISIBLE);
                //bug(108303) .. this should apply whether or not value  == null.
                Visible = false;


                try {
                    if (value == null) {
                        ParentInternal = null;
                        TopLevel = true;
                    }
                    else {
                        if (IsMdiContainer) {
                            throw new ArgumentException(SR.GetString(SR.FormMDIParentAndChild), "value");
                        }
                        if (!value.IsMdiContainer) {
                            throw new ArgumentException(SR.GetString(SR.MDIParentNotContainer), "value");
                        }

                        // Setting TopLevel forces a handle recreate before Parent is set,
                        // which causes problems because we try to assign an MDI child to the parking window,
                        // which can't take MDI children.  So we explicitly destroy and create the handle here.
                        
                        Dock = DockStyle.None;
                        Properties.SetObject(PropFormMdiParent, value);
                        
                        SetState(STATE_TOPLEVEL, false);
                        ParentInternal = value.GetMdiClient();
                        
                        // If it is an MDIChild, and it is not yet visible, we'll
                        // hold off on recreating the window handle. We'll do that
                        // when MdiChild's visibility is set to true (see bug 124232)
                        if (ParentInternal.IsHandleCreated && !IsMdiChildAndNotVisible) {
                            RecreateHandle();
                        }
                    }
                    InvalidateMergedMenu();
                    UpdateMenuHandles();
                }
                finally {
                    UpdateStyles();
                    Visible = oldVisibleBit;
                }
            }
        }

        internal bool IsMdiChildAndNotVisible {
            get {
                return IsMdiChild && !GetState(STATE_VISIBLE);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MergedMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the merged menu for the
        ///       form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormMergedMenuDescr)
        ]
        public MainMenu MergedMenu {
            get {
                Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
                if (formMdiParent == null) return null;
                
                MainMenu mergedMenu = (MainMenu)Properties.GetObject(PropMergedMenu);
                if (mergedMenu != null) return mergedMenu;

                MainMenu parentMenu = formMdiParent.Menu;
                MainMenu mainMenu = Menu;
                
                if (mainMenu == null) return parentMenu;
                if (parentMenu == null) return mainMenu;

                // Create a menu that merges the two and save it for next time.
                mergedMenu = new MainMenu();
                mergedMenu.MergeMenu(parentMenu);
                mergedMenu.MergeMenu(mainMenu);
                Properties.SetObject(PropMergedMenu, mergedMenu);
                
                return mergedMenu;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MinimizeBox"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the minimize button is displayed in the caption bar of the form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(true),
        SRDescription(SR.FormMinimizeBoxDescr)
        ]
        public bool MinimizeBox {
            get {
                return formState[FormStateMinimizeBox] != 0;
            }
            set {
                if (value) {
                    formState[FormStateMinimizeBox] = 1;
                }
                else {
                    formState[FormStateMinimizeBox] = 0;
                }
                UpdateFormStyles();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Modal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this form is
        ///       displayed modally.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormModalDescr)
        ]
        public bool Modal {
            get {
                return GetState(STATE_MODAL);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Opacity"]/*' />
        /// <devdoc>
        ///     Determines the opacity of the form. This can only be set on top level
        ///     controls.  Opacity requires Windows 2000 or later, and is ignored on earlier
        ///     operating systems.
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        TypeConverterAttribute(typeof(OpacityConverter)),
        SRDescription(SR.FormOpacityDescr),
        DefaultValue(1.0)
        ]
        public double Opacity {
            get {
                object opacity = Properties.GetObject(PropOpacity);
                if (opacity != null) {
                    return Convert.ToDouble(opacity);
                }
                else {
                    return 1.0f;
                }
            }
            set {
                if (IsRestrictedWindow) {
                    value = Math.Max(value, .50f);
                }

                if (value > 1.0) {
                    value = 1.0f;
                }
                else if (value < 0.0) {
                    value = 0.0f;
                }
                
                Properties.SetObject(PropOpacity, value);
                
                if (OpacityAsByte < 255 && OSFeature.Feature.IsPresent(OSFeature.LayeredWindows)) {
                    AllowTransparency = true;
                    formState[FormStateLayered] = 1;
                }

                UpdateLayered();
            }
        }
        
        private byte OpacityAsByte {
            get {
                return (byte)(Opacity * 255.0f);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OwnedForms"]/*' />
        /// <devdoc>
        /// <para>Gets an array of <see cref='System.Windows.Forms.Form'/> objects that represent all forms that are owned by this form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormOwnedFormsDescr)
        ]
        public Form[] OwnedForms {
            get {
                Form[] ownedForms = (Form[])Properties.GetObject(PropOwnedForms);
                int ownedFormsCount = Properties.GetInteger(PropOwnedFormsCount);
                
                Form[] result = new Form[ownedFormsCount];
                if (ownedFormsCount > 0) {
                    Array.Copy(ownedForms, 0, result, 0, ownedFormsCount);
                }

                return result;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Owner"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the form that owns this form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormOwnerDescr)
        ]
        public Form Owner {
            get {
                IntSecurity.GetParent.Demand();
                return OwnerInternal;
            }
            set {
                Form ownerOld = OwnerInternal;
                if (ownerOld == value)
                    return;

                if (value != null && !TopLevel) {
                    throw new ArgumentException(SR.GetString(SR.NonTopLevelCantHaveOwner), "value");
                }

                CheckParentingCycle(this, value);
                CheckParentingCycle(value, this);

                Properties.SetObject(PropOwner, null);
                
                if (ownerOld != null) {
                    ownerOld.RemoveOwnedForm(this);
                }

                Properties.SetObject(PropOwner, value);
                
                if (value != null) {
                    value.AddOwnedForm(this);
                }

                UpdateHandleWithOwner();
            }
        }
        
        internal Form OwnerInternal {
            get {
                return (Form)Properties.GetObject(PropOwner);
            }
        }
        internal override Control ParentInternal {
            get {
                return base.ParentInternal;
            }
            set {
                if (value != null) {
                    Owner = null;
                }
                base.ParentInternal = value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ShowInTaskbar"]/*' />
        /// <devdoc>
        ///    <para>If ShowInTaskbar is true then the form will be displayed
        ///       in the Windows Taskbar.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRCategory(SR.CatWindowStyle),
        SRDescription(SR.FormShowInTaskbarDescr)
        ]
        public bool ShowInTaskbar {
            get {
                return formState[FormStateTaskBar] != 0;
            }
            set {
                if (IsRestrictedWindow) {
                    return;
                }

                if (ShowInTaskbar != value) {
                    if (value) {
                        formState[FormStateTaskBar] = 1;
                    }
                    else {
                        formState[FormStateTaskBar] = 0;
                    }
                    if (IsHandleCreated) {
                        RecreateHandle();
                    }
                }
            }
        }

        
        internal override int ShowParams {
            [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, Name="System.Windows.Forms", PublicKey="0x00000000000000000400000000000000")]
            get {
                // From MSDN:
                //      The first time an application calls ShowWindow, it should use the WinMain function's nCmdShow parameter as its nCmdShow parameter. Subsequent calls to ShowWindow must use one of the values in the given list, instead of the one specified by the WinMain function's nCmdShow parameter. 
                
                //      As noted in the discussion of the nCmdShow parameter, the nCmdShow value is ignored in the first call to ShowWindow if the program that launched the application specifies startup information in the STARTUPINFO structure. In this case, ShowWindow uses the information specified in the STARTUPINFO structure to show the window. On subsequent calls, the application must call ShowWindow with nCmdShow set to SW_SHOWDEFAULT to use the startup information provided by the program that launched the application. This behavior is designed for the following situations: 
                // 
                //      Applications create their main window by calling CreateWindow with the WS_VISIBLE flag set. 
                //      Applications create their main window by calling CreateWindow with the WS_VISIBLE flag cleared, and later call ShowWindow with the SW_SHOW flag set to make it visible. 
                //
                
                switch(WindowState) {
                    case FormWindowState.Maximized:
                        return NativeMethods.SW_SHOWMAXIMIZED;
                    case FormWindowState.Minimized:
                        return NativeMethods.SW_SHOWMINIMIZED;                    
                }
                return NativeMethods.SW_SHOW;
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the size of the form.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        Localizable(false)
        ]
        new public Size Size {
            get {
                return base.Size;
            }
            set {
                base.Size = value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.SizeGripStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the style of size grip to display in the lower-left corner of the form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        DefaultValue(SizeGripStyle.Auto),
        SRDescription(SR.FormSizeGripStyleDescr)
        ]
        public SizeGripStyle SizeGripStyle {
            get {
                return(SizeGripStyle)formState[FormStateSizeGripStyle];
            }
            set {
                if (SizeGripStyle != value) {
                    //do some bounds checking here
                    //
                    if ( !Enum.IsDefined(typeof(SizeGripStyle), (int)value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(SizeGripStyle));
                    }

                    formState[FormStateSizeGripStyle] = (int)value;
                    UpdateRenderSizeGrip();
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.StartPosition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       starting position of the form at run time.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatLayout),
        DefaultValue(FormStartPosition.WindowsDefaultLocation),
        SRDescription(SR.FormStartPositionDescr)
        ]
        public FormStartPosition StartPosition {
            get {
                return(FormStartPosition)formState[FormStateStartPos];
            }
            set {
                if (!Enum.IsDefined(typeof(FormStartPosition), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FormStartPosition));
                }
                formState[FormStateStartPos] = (int)value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.TabIndex"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false),
        EditorBrowsable(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        new public int TabIndex {
            get {
                return base.TabIndex;
            }
            set {
                base.TabIndex = value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.TabIndexChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabIndexChanged {
            add {
                base.TabIndexChanged += value;
            }
            remove {
                base.TabIndexChanged -= value;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.TopLevel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to display the form as a top-level
        ///       window.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool TopLevel {
            get {
                return GetTopLevel();
            }
            set {
                if (!value && ((Form)this).IsMdiContainer && !DesignMode) {
                    throw new ArgumentException(SR.GetString(SR.MDIContainerMustBeTopLevel), "value");
                }
                SetTopLevel(value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.TopMost"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the form should be displayed as the top-most
        ///       form of your application.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatWindowStyle),
        SRDescription(SR.FormTopMostDescr)
        ]
        public bool TopMost {
            get {
                return formState[FormStateTopMost] != 0;
            }
            set {
                if (IsRestrictedWindow) {
                    return;
                }

                if (IsHandleCreated && TopLevel) {
                    HandleRef key = value ? NativeMethods.HWND_TOPMOST : NativeMethods.HWND_NOTOPMOST;
                    SafeNativeMethods.SetWindowPos(new HandleRef(this, Handle), key, 0, 0, 0, 0,
                                         NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE);
                }

                if (value) {
                    formState[FormStateTopMost] = 1;
                }
                else {
                    formState[FormStateTopMost] = 0;
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.TransparencyKey"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the color that will represent transparent areas of the form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatWindowStyle),
        SRDescription(SR.FormTransparencyKeyDescr)
        ]
        public Color TransparencyKey {
            get {
                object key = Properties.GetObject(PropTransparencyKey);
                if (key != null) {
                    return (Color)key;
                }
                return Color.Empty;
            }
            set {
                AllowTransparency = true;
                
                Properties.SetObject(PropTransparencyKey, value);
                UpdateLayered();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.SetVisibleCore"]/*' />
        //
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void SetVisibleCore(bool value) {
            
            /* SECUNDONE : do we need to do this?
            if (!value) {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "TransparentWindows Demanded");
                IntSecurity.TransparentWindows.Demand();
            }
            */

            // (!value || calledMakeVisible) is to make sure that we fall
            // through and execute the code below atleast once.
            if (GetVisibleCore() == value && (!value || calledMakeVisible)) {
                base.SetVisibleCore(value);
                return;
            }

            if (value) {
                calledMakeVisible = true;
                if (calledCreateControl && !calledOnLoad) {
                    calledOnLoad = true;
                    OnLoad(EventArgs.Empty);
                    if (dialogResult != DialogResult.None) 
                    {
                        // Don't show the dialog if the dialog result was set
                        // in the OnLoad event.
                        //
                        value = false;
                    }
                }
            }
            else {
                ResetSecurityTip(true /* modalOnly */);
            }

            if (!IsMdiChild) {
                base.SetVisibleCore(value);

                // We need to force this call if we were created
                // with a STARTUPINFO structure (e.g. launched from explorer), since
                // it won't send a WM_SHOWWINDOW the first time it's called.
                // when WM_SHOWWINDOW gets called, we'll flip this bit to true
                //
                if (0==formState[FormStateSWCalled]) {
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.WM_SHOWWINDOW, value ? 1 : 0, 0);
                }
            }
            else {
                // Throw away any existing handle.
                if (IsHandleCreated) {

                    // SECREVIEW : Allow us to destroy the Form's handle when making it non-visible
                    //           : when we are an MdiChild.
                    //
                    IntSecurity.ManipulateWndProcAndHandles.Assert();
                    try {
                        DestroyHandle();
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }

                if (!value) {
                    SetState(STATE_VISIBLE, false);
                }
                else {

                    // The ordering is important here... Force handle creation
                    // (getHandle) then show the window (ShowWindow) then finish
                    // creating children using createControl...
                    //
                    SetState(STATE_VISIBLE, true);
                                        
                    if (ParentInternal != null && ParentInternal.Created) {
                        SafeNativeMethods.ShowWindow(new HandleRef(this, Handle), NativeMethods.SW_SHOW);
                        CreateControl();
                    }
                }
                OnVisibleChanged(EventArgs.Empty);
            }

            //(bug 111549)... For FormWindowState.Maximized.. Wm_activate is not Fired before setting Focus
            //on Active Control..
            
            if (value && !IsMdiChild && (WindowState == FormWindowState.Maximized || TopMost)) {
                if (ActiveControl == null)
                    SelectNextControl(null, true, true, true, false);
                FocusActiveControlInternal();
            }
            

        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.IsRestrictedWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> Determines if this form should display a warning banner 
        ///       when the form is displayed in an unsecure mode.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool IsRestrictedWindow {
            get {
                if (formState[FormStateIsRestrictedWindowChecked] == 0) {
                    formState[FormStateIsRestrictedWindowChecked] = 1;
                    formState[FormStateIsRestrictedWindow] = 0;

                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "Checking for restricted window...");
                    Debug.Indent();
#if DEBUG
                    if (AlwaysRestrictWindows.Enabled) {
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "Always restricted switch is on...");
                        formState[FormStateIsRestrictedWindow] = 1;
                        Debug.Unindent();
                        return true;
                    }
#endif                    

                    try {
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "WindowAdornmentModification Demanded");
                        IntSecurity.WindowAdornmentModification.Demand();
                    }
                    catch (Exception) {
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "Caught exception, we are restricted...");
                        formState[FormStateIsRestrictedWindow] = 1;
                    }
                    Debug.Unindent();
                }

                return formState[FormStateIsRestrictedWindow] != 0;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.WindowState"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the form's window state.
        ///       </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        DefaultValue(FormWindowState.Normal),
        SRDescription(SR.FormWindowStateDescr)
        ]
        public FormWindowState WindowState {
            get {
                return(FormWindowState)formState[FormStateWindowState];
            }
            set {

                //verify that 'value' is a valid enum type...

                if ( !Enum.IsDefined(typeof(FormWindowState), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FormWindowState));
                }

                if (IsRestrictedWindow) {
                    if (value == FormWindowState.Minimized) {
                        value = FormWindowState.Normal;
                    }
                }

                formState[FormStateWindowState] = (int)value;

                switch (WindowState) {
                    case FormWindowState.Normal:
                        SetState(STATE_SIZELOCKEDBYOS, false);
                        break;
                    case FormWindowState.Maximized:
                    case FormWindowState.Minimized:
                        SetState(STATE_SIZELOCKEDBYOS, true);
                        break;
                }

                if (IsHandleCreated && Visible) {
                    IntPtr hWnd = Handle;
                    switch (value) {
                        case FormWindowState.Normal:
                            SafeNativeMethods.ShowWindow(new HandleRef(this, hWnd), NativeMethods.SW_RESTORE);
                            break;
                        case FormWindowState.Maximized:
                            SafeNativeMethods.ShowWindow(new HandleRef(this, hWnd), NativeMethods.SW_MAXIMIZE);
                            break;
                        case FormWindowState.Minimized:
                            SafeNativeMethods.ShowWindow(new HandleRef(this, hWnd), NativeMethods.SW_MINIMIZE);
                            break;
                    }
                }
                // And if the form isn't visible, changing Visible will recreate the handle
            }
        }

        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text to display in the caption bar of the form.
        ///    </para>
        /// </devdoc>
        internal override string WindowText {
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            get {
                if (IsRestrictedWindow && formState[FormStateIsWindowActivated] == 1) {
                    if (userWindowText == null) {
                        return "";
                    }
                    return userWindowText;
                }

                return base.WindowText;

            }
            
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            set {
                string oldText = this.WindowText;

                userWindowText = value;

                if (IsRestrictedWindow && formState[FormStateIsWindowActivated] == 1) {
                    if (value == null) {
                        value = "";
                    }
                    base.WindowText = RestrictedWindowText(value);
                }
                else {
                    base.WindowText = value;
                }

                // For non-default FormBorderStyles, we do not set the WS_CAPTION style if the Text property is null or "".
                // When we reload the form from code view, the text property is not set till the very end, and so we do not
                // end up updating the CreateParams with WS_CAPTION. Fixed this by making sure we call UpdateStyles() when
                // we transition from a non-null value to a null value or vice versa in Form.WindowText.
                //
                if (oldText == null || oldText.Equals("") || value == null || value.Equals("")) {
                    UpdateFormStyles();
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Activate"]/*' />
        /// <devdoc>
        ///    <para>Activates the form and gives it focus.</para>
        /// </devdoc>
        public void Activate() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyFocus Demanded");
            IntSecurity.ModifyFocus.Demand();

            if (Visible && IsHandleCreated) {
                if (IsMdiChild) {
                    MdiParentInternal.GetMdiClient().SendMessage(NativeMethods.WM_MDIACTIVATE, Handle, 0);
                }
                else {
                    UnsafeNativeMethods.SetForegroundWindow(new HandleRef(this, Handle));
                }
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Activated"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the form is activated in code or by the user.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.FormOnActivateDescr)]
        public event EventHandler Activated {
            add {
                Events.AddHandler(EVENT_ACTIVATED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_ACTIVATED, value);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Closing"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the form is closing.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnClosingDescr)]
        public event CancelEventHandler Closing {
            add {
                Events.AddHandler(EVENT_CLOSING, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CLOSING, value);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Closed"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the form is closed.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnClosedDescr)]
        public event EventHandler Closed {
            add {
                Events.AddHandler(EVENT_CLOSED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CLOSED, value);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Deactivate"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the form loses focus and is not the active form.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.FormOnDeactivateDescr)]
        public event EventHandler Deactivate {
            add {
                Events.AddHandler(EVENT_DEACTIVATE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DEACTIVATE, value);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Load"]/*' />
        /// <devdoc>
        ///    <para>Occurs before the form becomes visible.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnLoadDescr)]
        public event EventHandler Load {
            add {
                Events.AddHandler(EVENT_LOAD, value);
            }
            remove {
                Events.RemoveHandler(EVENT_LOAD, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MdiChildActivate"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a Multiple Document Interface (MDI) child form is activated or closed 
        ///       within an MDI application.</para>
        /// </devdoc>
        [SRCategory(SR.CatLayout), SRDescription(SR.FormOnMDIChildActivateDescr)]
        public event EventHandler MdiChildActivate {
            add {
                Events.AddHandler(EVENT_MDI_CHILD_ACTIVATE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MDI_CHILD_ACTIVATE, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MenuComplete"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the menu of a form loses focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnMenuCompleteDescr)]
        public event EventHandler MenuComplete {
            add {
                Events.AddHandler(EVENT_MENUCOMPLETE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MENUCOMPLETE, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.MenuStart"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the menu of a form receives focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnMenuStartDescr)]
        public event EventHandler MenuStart {
            add {
                Events.AddHandler(EVENT_MENUSTART, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MENUSTART, value);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.InputLanguageChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs after the input language of the form has changed.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnInputLangChangeDescr)]
        public event InputLanguageChangedEventHandler InputLanguageChanged {
            add {
                Events.AddHandler(EVENT_INPUTLANGCHANGE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_INPUTLANGCHANGE, value);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.InputLanguageChanging"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the the user attempts to change the input language for the 
        ///       form.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.FormOnInputLangChangeRequestDescr)]
        public event InputLanguageChangingEventHandler InputLanguageChanging {
            add {
                Events.AddHandler(EVENT_INPUTLANGCHANGEREQUEST, value);
            }
            remove {
                Events.RemoveHandler(EVENT_INPUTLANGCHANGEREQUEST, value);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AddOwnedForm"]/*' />
        /// <devdoc>
        ///    <para> Adds
        ///       an owned form to this form.</para>
        /// </devdoc>
        public void AddOwnedForm(Form ownedForm) {
            if (ownedForm == null)
                return;

            if (ownedForm.OwnerInternal != this) {
                ownedForm.Owner = this; // NOTE: this calls AddOwnedForm again with correct owner set.
                return;
            }
            
            Form[] ownedForms = (Form[])Properties.GetObject(PropOwnedForms);
            int ownedFormsCount = Properties.GetInteger(PropOwnedFormsCount);

            // Make sure this isn't already in the list:
            for (int i=0;i < ownedFormsCount;i++) {
                if (ownedForms[i]==ownedForm) {
                    return;
                }
            }

            if (ownedForms == null) {
                ownedForms = new Form[4];
                Properties.SetObject(PropOwnedForms, ownedForms);
            }
            else if (ownedForms.Length == ownedFormsCount) {
                Form[] newOwnedForms = new Form[ownedFormsCount*2];
                Array.Copy(ownedForms, 0, newOwnedForms, 0, ownedFormsCount);
                ownedForms = newOwnedForms;
                Properties.SetObject(PropOwnedForms, ownedForms);
            }

            
            ownedForms[ownedFormsCount] = ownedForm;
            Properties.SetInteger(PropOwnedFormsCount, ownedFormsCount + 1);
        }

        // When shrinking the form (i.e. going from Large Fonts to Small
        // Fonts) we end up making everything too small due to roundoff,
        // etc... solution - just don't shrink as much.
        //
        private float AdjustScale(float scale) {
            // NOTE : This function is cloned in FormDocumentDesigner... remember to keep
            //      : them in sync
            //


            // Map 0.0 - .92... increment by 0.08
            //
            if (scale < .92f) {
                return scale + 0.08f;
            }

            // Map .92 - .99 to 1.0
            //
            else if (scale < 1.0f) {
                return 1.0f;
            }

            // Map 1.02... increment by 0.08
            //
            else if (scale > 1.01f) {
                return scale + 0.08f;
            }

            // Map 1.0 - 1.01... no change
            //
            else {
                return scale;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.AdjustFormScrollbars"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void AdjustFormScrollbars(bool displayScrollbars) {
            if (WindowState != FormWindowState.Minimized) {
                base.AdjustFormScrollbars(displayScrollbars);
            }
        }

        private void AdjustSystemMenu(IntPtr hmenu) {
            UpdateWindowState();
            FormWindowState winState = WindowState;
            FormBorderStyle borderStyle = FormBorderStyle;
            bool sizableBorder = (borderStyle == FormBorderStyle.SizableToolWindow
                                  || borderStyle == FormBorderStyle.Sizable);


            bool showMin = MinimizeBox && winState != FormWindowState.Minimized;
            bool showMax = MaximizeBox && winState != FormWindowState.Maximized;
            bool showClose = ControlBox;
            bool showRestore = winState != FormWindowState.Normal;
            bool showSize = sizableBorder && winState != FormWindowState.Minimized
                            && winState != FormWindowState.Maximized;

            if (!showMin) {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_MINIMIZE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_GRAYED);
            }
            else {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_MINIMIZE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_ENABLED);
            }
            if (!showMax) {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_MAXIMIZE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_GRAYED);
            }
            else {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_MAXIMIZE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_ENABLED);
            }
            if (!showClose) {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_CLOSE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_GRAYED);
            }
            else {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_CLOSE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_ENABLED);
            }
            if (!showRestore) {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_RESTORE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_GRAYED);
            }
            else {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_RESTORE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_ENABLED);
            }
            if (!showSize) {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_SIZE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_GRAYED);
            }
            else {
                UnsafeNativeMethods.EnableMenuItem(new HandleRef(this, hmenu), NativeMethods.SC_SIZE,
                                       NativeMethods.MF_BYCOMMAND | NativeMethods.MF_ENABLED);
            }

#if SECURITY_DIALOG
            AdjustSystemMenuForSecurity(hmenu);
#endif
        }

#if SECURITY_DIALOG
        private void AdjustSystemMenuForSecurity(IntPtr hmenu) {
            if (formState[FormStateAddedSecurityMenuItem] == 0) {
                formState[FormStateAddedSecurityMenuItem] = 1;

                SecurityMenuItem securitySystemMenuItem = new SecurityMenuItem(this);
                Properties.SetObject(PropSecuritySystemMenuItem, securitySystemMenuItem);

                NativeMethods.MENUITEMINFO_T info = new NativeMethods.MENUITEMINFO_T();
                info.fMask = NativeMethods.MIIM_ID | NativeMethods.MIIM_STATE |
                             NativeMethods.MIIM_SUBMENU | NativeMethods.MIIM_TYPE | NativeMethods.MIIM_DATA;
                info.fType = 0;
                info.fState = 0;
                info.wID = securitySystemMenuItem.ID;
                info.hbmpChecked = IntPtr.Zero;
                info.hbmpUnchecked = IntPtr.Zero;
                info.dwItemData = 0;
                
                // Note:  This code is not shipping in the final product.  We do not want to measure the
                //     :  performance hit of loading the localized resource for this at startup, so I
                //     :  am hard-wiring the strings below.  If you need to localize these, move them to
                //     :  a SECONDARY resource file so we don't have to contend with our big error message
                //     :  file on startup.
                //
                if (IsRestrictedWindow) {
                    info.dwTypeData = ".NET Restricted Window...";
                }
                else {
                    info.dwTypeData = ".NET Window...";
                }
                info.cch = 0;
                UnsafeNativeMethods.InsertMenuItem(new HandleRef(this, hmenu), 0, true, info);


                NativeMethods.MENUITEMINFO_T sep = new NativeMethods.MENUITEMINFO_T();
                sep.fMask = NativeMethods.MIIM_ID | NativeMethods.MIIM_STATE |
                             NativeMethods.MIIM_SUBMENU | NativeMethods.MIIM_TYPE | NativeMethods.MIIM_DATA;
                sep.fType = NativeMethods.MFT_MENUBREAK;
                UnsafeNativeMethods.InsertMenuItem(new HandleRef(this, hmenu), 1, true, sep);

            }
        }
#endif

        /// <devdoc>
        ///     This forces the SystemMenu to look like we want.
        /// </devdoc>
        /// <internalonly/>
        private void AdjustSystemMenu() {
            if (IsHandleCreated) {
                IntPtr hmenu = UnsafeNativeMethods.GetSystemMenu(new HandleRef(this, Handle), false);
                AdjustSystemMenu(hmenu);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ApplyAutoScaling"]/*' />
        /// <devdoc>
        ///     This auto scales the form based on the AutoScaleBaseSize.
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void ApplyAutoScaling() {
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "ApplyAutoScaling... ");
            Debug.Indent();
            // NOTE : This function is cloned in FormDocumentDesigner... remember to keep
            //      : them in sync
            //


            // We also don't do this if the property is empty.  Otherwise we will perform
            // two GetAutoScaleBaseSize calls only to find that they returned the same
            // value.
            //
            if (!autoScaleBaseSize.IsEmpty) {
                Size baseVar = AutoScaleBaseSize;
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "base  =" + baseVar);
                SizeF newVarF = GetAutoScaleSize(Font);
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "new(f)=" + newVarF);
                Size newVar = new Size((int)Math.Round(newVarF.Width), (int)Math.Round(newVarF.Height));
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "new(i)=" + newVar);

                // We save a significant amount of time by bailing early if there's no work to be done
                if (baseVar.Equals(newVar))
                    return;

                float percY = AdjustScale(((float)newVar.Height) / ((float)baseVar.Height));
                float percX = AdjustScale(((float)newVar.Width) / ((float)baseVar.Width));
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "scale=" + percX + ", " + percY);
                Scale(percX, percY);
                // This would ensure that we use the new
                // font information to calculate the AutoScaleBaseSize. According to Triage
                // this was decided to Fix in this version.
                //
                AutoScaleBaseSize = newVar;
            }
            Debug.Unindent();
        
        }

        /// <devdoc>
        ///     This adjusts the size of the windowRect so that the client rect is the
        ///     correct size.
        /// </devdoc>
        /// <internalonly/>
        private void ApplyClientSize() {
            if ((FormWindowState)formState[FormStateWindowState] != FormWindowState.Normal
                || !IsHandleCreated) {
                return;
            }

            // Cache the clientSize, since calling setBounds will end up causing
            // clientSize to get reset to the actual clientRect size...
            //
            Size correctClientSize = ClientSize;
            bool hscr = HScroll;
            bool vscr = VScroll;

            // This logic assumes that the caller of setClientSize() knows if the scrollbars
            // are showing or not. Since the 90% case is that setClientSize() is the persisted
            // ClientSize, this is correct.
            // Without this logic persisted forms that were saved with the scrollbars showing,
            // don't get set to the correct size.
            //
            bool adjustScroll = false;
            if (formState[FormStateSetClientSize] != 0) {
                adjustScroll = true;
                formState[FormStateSetClientSize] = 0;
            }
            if (adjustScroll) {
                if (hscr) {
                    correctClientSize.Height += SystemInformation.HorizontalScrollBarHeight;
                }
                if (vscr) {
                    correctClientSize.Width += SystemInformation.VerticalScrollBarWidth;
                }
            }

            IntPtr h = Handle;
            NativeMethods.RECT rc = new NativeMethods.RECT();
            SafeNativeMethods.GetClientRect(new HandleRef(this, h), ref rc);
            Rectangle currentClient = Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom);

            Rectangle bounds = Bounds;

            // If the width is incorrect, compute the correct size with
            // computeWindowSize. We only do this logic if the width needs to
            // be adjusted to avoid double adjusting the window.
            //
            if (correctClientSize.Width != currentClient.Width) {
                Size correct = ComputeWindowSize(correctClientSize);

                // Since computeWindowSize ignores scrollbars, we must tack these on to
                // assure the correct size.
                //
                if (vscr) {
                    correct.Width += SystemInformation.VerticalScrollBarWidth;
                }
                if (hscr) {
                    correct.Height += SystemInformation.HorizontalScrollBarHeight;
                }
                bounds.Width = correct.Width;
                bounds.Height = correct.Height;
                Bounds = bounds;
                SafeNativeMethods.GetClientRect(new HandleRef(this, h), ref rc);
                currentClient = Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom);
            }

            // If it still isn't correct, then we assume that the problem is
            // menu wrapping (since computeWindowSize doesn't take that into
            // account), so we just need to adjust the height by the correct
            // amount.
            //
            if (correctClientSize.Height != currentClient.Height) {

                int delta = correctClientSize.Height - currentClient.Height;
                bounds.Height += delta;
                Bounds = bounds;
            }

            UpdateBounds();
        }

        /// <internalonly/>
        /// <devdoc>
        ///    <para>Assigns a new parent control. Sends out the appropriate property change
        ///       notifications for properties that are affected by the change of parent.</para>
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        internal override void AssignParent(Control value) {
            
            // If we are being unparented from the MDI client control, remove
            // formMDIParent as well.
            //
            Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
            if (formMdiParent != null && formMdiParent.GetMdiClient() != value) {
                Properties.SetObject(PropFormMdiParent, null);
            }

            base.AssignParent(value);
        }

        /// <devdoc>
        ///     Checks whether a modal dialog is ready to close. If the dialogResult
        ///     property is not DialogResult.NONE, the onClosing and onClosed events
        ///     are fired. A return value of true indicates that both events were
        ///     successfully dispatched and that event handlers did not cancel closing
        ///     of the dialog. User code should never have a reason to call this method.
        ///     It is public only so that the Application class can call it from a
        ///     modal message loop.
        /// </devdoc>
        internal bool CheckCloseDialog() {
            if (dialogResult == DialogResult.None && Visible) return false;
            try {
                CancelEventArgs e = new CancelEventArgs(false);
                OnClosing(e);
                
                if (e.Cancel) {
                    dialogResult = DialogResult.None;
                }
                if (dialogResult != DialogResult.None) {
                    OnClosed(EventArgs.Empty);
                }
            }
            catch (Exception e) {
                dialogResult = DialogResult.None;
                Application.OnThreadException(e);
            }
            return dialogResult != DialogResult.None || !Visible;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Close"]/*' />
        /// <devdoc>
        ///    <para>Closes the form.</para>
        /// </devdoc>
        public void Close() {
        
            if (GetState(STATE_CREATINGHANDLE))
                throw new InvalidOperationException(SR.GetString(SR.ClosingWhileCreatingHandle, "Close"));

            if (IsHandleCreated) {
                SendMessage(NativeMethods.WM_CLOSE, 0, 0);
            }
        }

        /// <devdoc>
        ///     Computes the window size from the clientSize based on the styles
        ///     returned from CreateParams.
        /// </devdoc>
        private Size ComputeWindowSize(Size clientSize) {
            CreateParams cp = CreateParams;
            return ComputeWindowSize(clientSize, cp.Style, cp.ExStyle);
        }

        /// <devdoc>
        ///     Computes the window size from the clientSize base on the specified
        ///     window styles. This will not return the correct size if menus wrap.
        /// </devdoc>
        private Size ComputeWindowSize(Size clientSize, int style, int exStyle) {
            NativeMethods.RECT result = new NativeMethods.RECT(0, 0, clientSize.Width, clientSize.Height);
            SafeNativeMethods.AdjustWindowRectEx(ref result, style, HasMenu, exStyle);
            return new Size(result.right - result.left, result.bottom - result.top);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.CreateControlsInstance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override Control.ControlCollection CreateControlsInstance() {
            return new ControlCollection(this);
        }

        /// <devdoc>
        ///     Cleans up form state after a control has been removed.
        ///     Package scope for Control
        /// </devdoc>
        /// <internalonly/>
        internal override void AfterControlRemoved(Control control) {
            base.AfterControlRemoved(control);
            
            if (control == AcceptButton) {
                this.AcceptButton = null;
            }
            if (control == CancelButton) {
                this.CancelButton = null;
            }
            if (control == ctlClient) {
                ctlClient = null;
                UpdateMenuHandles();
            }
        }

        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private Rectangle CalcScreenBounds() {
            if (this.ParentInternal != null) {
                return this.ParentInternal.RectangleToScreen(Bounds);
            }
            else {
                return this.Bounds;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.CreateHandle"]/*' />
        /// <devdoc>
        ///    <para>Creates the handle for the Form. If a
        ///       subclass overrides this function,
        ///       it must call the base implementation.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void CreateHandle() {
            // In the windows MDI code we have to suspend menu
            // updates on the parent while creating the handle. Otherwise if the
            // child is created maximized, the menu ends up with two sets of
            // MDI child ornaments.
            Form form = (Form)Properties.GetObject(PropFormMdiParent);
            if (form != null)
                form.SuspendUpdateMenuHandles();

            try {

                // If we think that we are maximized, then a duplicate set of mdi gadgets are created.
                // If we create the window maximized, BUT our internal form state thinks it
                // isn't... then everything is OK...
                //
                // We really should find out what causes this... but I can't find it...
                //
                if (IsMdiChild
                    && (FormWindowState)formState[FormStateWindowState] == FormWindowState.Maximized) {

                    formState[FormStateWindowState] = (int)FormWindowState.Normal;
                    formState[FormStateMdiChildMax] = 1;
                    base.CreateHandle();
                    formState[FormStateWindowState] = (int)FormWindowState.Maximized;
                    formState[FormStateMdiChildMax] = 0;
                }
                else {
                    base.CreateHandle();
                }

                UpdateHandleWithOwner();
                UpdateWindowIcon(false);

                AdjustSystemMenu();

                if ((FormStartPosition)formState[FormStateStartPos] != FormStartPosition.WindowsDefaultBounds) {
                    ApplyClientSize();
                }
                if (formState[FormStateShowWindowOnCreate] == 1) {
                    Visible = true;
                }
                

                // avoid extra SetMenu calls for perf
                if (Menu != null || !TopLevel || IsMdiContainer)
                    UpdateMenuHandles();

                // In order for a window not to have a taskbar entry, it must
                // be owned.
                //
                if (!ShowInTaskbar && OwnerInternal == null && TopLevel) {
                    IntPtr parkingHandle = Application.GetParkingWindow(this).Handle;
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_HWNDPARENT, new HandleRef(Application.GetParkingWindow(this), parkingHandle));
                }

                if (formState[FormStateTopMost] != 0) {
                    TopMost = true;
                }

            }
            finally {
                if (form != null)
                    form.ResumeUpdateMenuHandles();
                
                // We need to reset the styles in case Windows tries to set us up
                // with "correct" styles... See ASURT 81646.
                //
                UpdateStyles();
            }                        
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.DefWndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Calls the default window proc for the form. If 
        ///       a
        ///       subclass overrides this function,
        ///       it must call the base implementation.
        ///       </para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        protected override void DefWndProc(ref Message m) {
            if (ctlClient != null && ctlClient.IsHandleCreated && ctlClient.ParentInternal == this)
                m.Result = UnsafeNativeMethods.DefFrameProc(m.HWnd, ctlClient.Handle, m.Msg, m.WParam, m.LParam);
            else if (useMdiChildProc)
                m.Result = UnsafeNativeMethods.DefMDIChildProc(m.HWnd, m.Msg, m.WParam, m.LParam);
            else {
                base.DefWndProc(ref m);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Releases all the system resources associated with the Form. If a subclass 
        ///       overrides this function, it must call the base implementation.</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                this.calledOnLoad = false;
                this.calledMakeVisible = false;
                this.calledCreateControl = false;

                ResetSecurityTip(false /* modalOnly */);
                if (Properties.ContainsObject(PropAcceptButton)) Properties.SetObject(PropAcceptButton, null);
                if (Properties.ContainsObject(PropCancelButton)) Properties.SetObject(PropCancelButton, null);
                if (Properties.ContainsObject(PropDefaultButton)) Properties.SetObject(PropDefaultButton, null);
                if (Properties.ContainsObject(PropActiveMdiChild)) Properties.SetObject(PropActiveMdiChild, null);

                Form owner = (Form)Properties.GetObject(PropOwner);
                if (owner != null) {
                    owner.RemoveOwnedForm(this);
                    Properties.SetObject(PropOwner, null);
                }

                Form[] ownedForms = (Form[])Properties.GetObject(PropOwnedForms);
                int ownedFormsCount = Properties.GetInteger(PropOwnedFormsCount);

                for (int i = ownedFormsCount-1 ; i >= 0; i--) {
                    if (ownedForms[i] != null) {
                        // it calls remove and removes itself.
                        ownedForms[i].Dispose();
                    }
                }

                base.Dispose(disposing);
                ctlClient = null;

                MainMenu mainMenu = Menu;

                if (mainMenu != null) {
                    Debug.Assert(mainMenu.form == this, "we should not dispose other form's menus");
                    mainMenu.CleanupMenuItemsHashtable();
                    mainMenu.form = null;
                    Properties.SetObject(PropMainMenu, null);
                }

                if (Properties.GetObject(PropCurMenu) != null) {
                    Properties.SetObject(PropCurMenu, null);
                }

                MenuChanged(Windows.Forms.Menu.CHANGE_ITEMS, null);

                MainMenu dummyMenu = (MainMenu)Properties.GetObject(PropDummyMenu);

                if (dummyMenu != null) {
                    dummyMenu.Dispose();
                    Properties.SetObject(PropDummyMenu, null);
                }

                MainMenu mergedMenu = (MainMenu)Properties.GetObject(PropMergedMenu);

                if (mergedMenu != null) {
                    if (mergedMenu.form == this || mergedMenu.form == null) {
                        mergedMenu.CleanupMenuItemsHashtable();
                        mergedMenu.Dispose();
                    }

                    Properties.SetObject(PropMergedMenu, null);
                }
            }
            else {
                base.Dispose(disposing);
            }
        }

        /// <devdoc>
        ///     Adjusts the window style of the CreateParams to reflect the bordericons.
        /// </devdoc>
        /// <internalonly/>
        private void FillInCreateParamsBorderIcons(CreateParams cp) {
            if (FormBorderStyle != FormBorderStyle.None) {
                if (!("".Equals(Text ))) {
                    cp.Style |= NativeMethods.WS_CAPTION;
                }

                if (ControlBox || IsRestrictedWindow) {
                    cp.Style |= NativeMethods.WS_SYSMENU | NativeMethods.WS_CAPTION;
                }
                else {
                    cp.Style &= (~NativeMethods.WS_SYSMENU);
                }

                if (MaximizeBox || IsRestrictedWindow) {
                    cp.Style |= NativeMethods.WS_MAXIMIZEBOX;
                }
                else {
                    cp.Style &= ~NativeMethods.WS_MAXIMIZEBOX;
                }

                if (MinimizeBox || IsRestrictedWindow) {
                    cp.Style |= NativeMethods.WS_MINIMIZEBOX;
                }
                else {
                    cp.Style &= ~NativeMethods.WS_MINIMIZEBOX;
                }

                if (HelpButton && !MaximizeBox && !MinimizeBox && ControlBox) {
                    // Windows should ignore WS_EX_CONTEXTHELP unless all those conditions hold.
                    // But someone must have screwed up the check, because Windows 2000
                    // will show a help button if either the maximize or 
                    // minimize button is disabled.
                    cp.ExStyle |= NativeMethods.WS_EX_CONTEXTHELP;
                }
                else {
                    cp.ExStyle &= ~NativeMethods.WS_EX_CONTEXTHELP;
                }
            }
        }

        /// <devdoc>
        ///     Adjusts the window style of the CreateParams to reflect the borderstyle.
        /// </devdoc>
        private void FillInCreateParamsBorderStyles(CreateParams cp) {
            switch ((FormBorderStyle)formState[FormStateBorderStyle]) {
                case FormBorderStyle.None:
                    if (IsRestrictedWindow) {
                        goto case FormBorderStyle.FixedSingle;
                    }
                    break;
                case FormBorderStyle.FixedSingle:
                    cp.Style |= NativeMethods.WS_BORDER;
                    break;
                case FormBorderStyle.Sizable:
                    cp.Style |= NativeMethods.WS_BORDER | NativeMethods.WS_THICKFRAME;
                    break;
                case FormBorderStyle.Fixed3D:
                    cp.Style |= NativeMethods.WS_BORDER;
                    cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                    break;
                case FormBorderStyle.FixedDialog:
                    cp.Style |= NativeMethods.WS_BORDER;
                    cp.ExStyle |= NativeMethods.WS_EX_DLGMODALFRAME;
                    break;
                case FormBorderStyle.FixedToolWindow:
                    cp.Style |= NativeMethods.WS_BORDER;
                    cp.ExStyle |= NativeMethods.WS_EX_TOOLWINDOW;
                    break;
                case FormBorderStyle.SizableToolWindow:
                    cp.Style |= NativeMethods.WS_BORDER | NativeMethods.WS_THICKFRAME;
                    cp.ExStyle |= NativeMethods.WS_EX_TOOLWINDOW;
                    break;
            }
        }

        /// <devdoc>
        ///     Adjusts the CreateParams to reflect the window bounds and start position.
        /// </devdoc>
        private void FillInCreateParamsStartPosition(CreateParams cp) {

            // V#42613 - removed logic that forced MDI children to always be
            //           default size and position... need to verify that
            //           this works on Win9X
            /*
            if (getIsMdiChild()) {
            cp.x = NativeMethods.CW_USEDEFAULT;
            cp.y = NativeMethods.CW_USEDEFAULT;
            cp.width = NativeMethods.CW_USEDEFAULT;
            cp.height = NativeMethods.CW_USEDEFAULT;
            }
            else {
            */
            if (formState[FormStateSetClientSize] != 0) {

                // V7#37980 - when computing the client window size, don't tell them that
                // we are going to be maximized!
                //
                int maskedStyle = cp.Style & ~(NativeMethods.WS_MAXIMIZE | NativeMethods.WS_MINIMIZE);
                Size correct = ComputeWindowSize(ClientSize, maskedStyle, cp.ExStyle);
                cp.Width = correct.Width;
                cp.Height = correct.Height;
            }

            switch ((FormStartPosition)formState[FormStateStartPos]) {
                case FormStartPosition.WindowsDefaultBounds:
                    cp.Width = NativeMethods.CW_USEDEFAULT;
                    cp.Height = NativeMethods.CW_USEDEFAULT;
                    // no break, fall through to set the location to default...
                    goto
                case FormStartPosition.WindowsDefaultLocation;
                case FormStartPosition.WindowsDefaultLocation:
                case FormStartPosition.CenterParent:
                    cp.X = NativeMethods.CW_USEDEFAULT;
                    cp.Y = NativeMethods.CW_USEDEFAULT;
                    break;
                case FormStartPosition.CenterScreen:
                    if (IsMdiChild) {
                        Control mdiclient = MdiParentInternal.GetMdiClient();
                        Rectangle clientRect = mdiclient.ClientRectangle;

                        cp.X = Math.Max(clientRect.X,clientRect.X + (clientRect.Width - cp.Width)/2);
                        cp.Y = Math.Max(clientRect.Y,clientRect.Y + (clientRect.Height - cp.Height)/2);
                    }
                    else {
                        Screen desktop = null;
                        IWin32Window dialogOwner = (IWin32Window)Properties.GetObject(PropDialogOwner);
                        if ((OwnerInternal != null) || (dialogOwner != null)) {
                            IntPtr ownerHandle = (dialogOwner != null) ? dialogOwner.Handle : OwnerInternal.Handle;
                            desktop = Screen.FromHandleInternal(ownerHandle);
                        }
                        else {
                            desktop = Screen.FromPoint(Control.MousePosition);
                        }
                        Rectangle screenRect = desktop.WorkingArea;
                        //if, we're maximized, then don't set the x & y coordinates (they're @ (0,0) )
                        if (WindowState != FormWindowState.Maximized) {
                            cp.X = Math.Max(screenRect.X,screenRect.X + (screenRect.Width - cp.Width)/2);
                            cp.Y = Math.Max(screenRect.Y,screenRect.Y + (screenRect.Height - cp.Height)/2);
                        }
                    }
                    break;
            }
        }

        /// <devdoc>
        ///     Adjusts the Createparams to reflect the window state.
        ///     If a subclass overrides this function, it must call the base implementation.
        /// </devdoc>
        private void FillInCreateParamsWindowState(CreateParams cp) {
            if (IsRestrictedWindow) {
                return;
            }

            switch ((FormWindowState)formState[FormStateWindowState]) {
                case FormWindowState.Maximized:
                    cp.Style |= NativeMethods.WS_MAXIMIZE;
                    break;
                case FormWindowState.Minimized:
                    cp.Style |= NativeMethods.WS_MINIMIZE;
                    break;
            }
        }

        /// <devdoc>
        ///    <para> Sets focus to the Form.</para>
        ///    <para>Attempts to set focus to this Form.</para>
        /// </devdoc>
        internal override bool FocusInternal() {

            //if this form is a MdiChild, then we need to set the focus in a different way...
            //
            if (IsMdiChild) {
                MdiParentInternal.GetMdiClient().SendMessage(NativeMethods.WM_MDIACTIVATE, Handle, 0);
                return Focused;
            }

            return base.FocusInternal();
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.GetAutoScaleSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static SizeF GetAutoScaleSize(Font font) {
            float height = font.Height;
            float width = 9.0f;

            try {
                IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                try {
                    Graphics graphics = Graphics.FromHdcInternal(screenDC);

                    try {
                        string magicString = "The quick brown fox jumped over the lazy dog.";
                        double magicNumber = 44.549996948242189; // chosen for compatibility with older versions of windows forms, but approximately magicString.Length
                        float stringWidth = graphics.MeasureString(magicString, font).Width;
                        width = (float) (stringWidth / magicNumber);
                    }
                    finally {
                        graphics.Dispose();
                    }

                }
                finally {
                    UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));
                }
            }
            catch (Exception e) {
                Debug.Fail("Exception attempting to determine autoscalesize... defaulting...", e.ToString());
            }

            return new SizeF(width, height);
        }
        
        /// <devdoc>
        /// <para>Gets the MDIClient that the form is 
        ///    using to contain Multiple Document Interface (MDI) child forms.</para>
        /// </devdoc>
        private MdiClient GetMdiClient() {
            return ctlClient;
        }

        /// <devdoc>
        ///    This private method attempts to resolve security zone and site 
        ///    information given a list of urls (sites).  This list is supplied
        ///    by the runtime and will contain the paths of all loaded assemblies
        ///    on the stack.  From here, we can examine zones and sites and 
        ///    attempt to identify the unique and mixed scenarios for each.  This
        ///    information will be displayed in the titlebar of the Form in a
        ///    semi-trust environment.
        /// </devdoc>
        private void ResolveZoneAndSiteNames(ArrayList sites, ref string securityZone, ref string securitySite) {

            //Start by defaulting to 'unknown zone' and 'unknown site' strings.  We will return this 
            //information if anything goes wrong while trying to resolve this information.
            //
            securityZone = SR.GetString(SR.SecurityRestrictedWindowTextUnknownZone);
            securitySite = SR.GetString(SR.SecurityRestrictedWindowTextUnknownSite);
            
            try 
            {
                //these conditions must be met
                //
                if (sites == null || sites.Count == 0)
                    return;
                
                //create a new zone array list which has no duplicates and no 
                //instances of mycomputer
                ArrayList zoneList = new ArrayList();
                foreach (object arrayElement in sites) 
                {
                    if (arrayElement == null)
                        return;
                
                    string url = arrayElement.ToString();
                
                    if (url.Length == 0)
                        return;
                
                    //into a zoneName
                    //
                    Zone currentZone = Zone.CreateFromUrl(url);
                
                    //skip this if the zone is mycomputer
                    //
                    if (currentZone.SecurityZone.Equals(SecurityZone.MyComputer))
                        continue;
                
                    //add our unique zonename to our list of zones
                    //
                    string zoneName = currentZone.SecurityZone.ToString();
                
                    if (!zoneList.Contains(zoneName)) 
                    {
                        zoneList.Add(zoneName);
                    }
                }
                
                //now, we resolve the zone name based on the unique information
                //left in the zoneList
                //
                if (zoneList.Count == 0) 
                {
                    //here, all the original zones were 'mycomputer'
                    //so we can just return that
                    securityZone = SecurityZone.MyComputer.ToString();
                }
                else if (zoneList.Count == 1) 
                {
                    //we only found 1 unique zone other than 
                    //mycomputer
                    securityZone = zoneList[0].ToString();
                }
                else 
                {
                    //here, we found multiple zones
                    //
                    securityZone = SR.GetString(SR.SecurityRestrictedWindowTextMixedZone);
                }
                
                //generate a list of loaded assemblies that came from the gac, this 
                //way we can safely ignore these from the url list
                ArrayList loadedAssembliesFromGac = new ArrayList();
                
                FileIOPermission fiop = new FileIOPermission( PermissionState.None );
                fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
                fiop.Assert();
                
                try 
                {
                    foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) 
                    {
                        if (asm.GlobalAssemblyCache) 
                        {
                            loadedAssembliesFromGac.Add(asm.CodeBase.ToUpper(CultureInfo.InvariantCulture));
                        }
                    }
                }
                finally 
                {
                    CodeAccessPermission.RevertAssert();
                }
                
                //now, build up a sitelist which contains a friendly string
                //we've extracted via the uri class and omit any urls that reference
                //our local gac
                //
                ArrayList siteList = new ArrayList();
                foreach (object arrayElement in sites) 
                {
                    //we know that each element is valid because of our
                    //first pass
                    Uri currentSite = new Uri(arrayElement.ToString());
                
                    //if we see a site that contains the path to our gac, 
                    //we'll just skip it
                
                    if (loadedAssembliesFromGac.Contains(currentSite.AbsoluteUri.ToUpper(CultureInfo.InvariantCulture))) 
                    {
                        continue;
                    }
                
                    //add the unique host name to our list
                    string hostName = currentSite.Host;
                    if (hostName.Length > 0 && !siteList.Contains(hostName))
                        siteList.Add(hostName);
                }

                
                //resolve the site name from our list, if siteList.count == 0
                //then we have already set our securitySite to "unknown site"
                //
                if (siteList.Count == 0) {
                    //here, we'll set the local machine name to the site string
                    //
                    new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                    try {
                        securitySite = Environment.MachineName;
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                else if (siteList.Count == 1) 
                {
                    //We found 1 unique site other than the info in the 
                    //gac
                    securitySite = siteList[0].ToString();
                }
                else
                {
                    //multiple sites, we'll have to return 'mixed sites'
                    //
                    securitySite = SR.GetString(SR.SecurityRestrictedWindowTextMultipleSites);
                }
            }
            catch
            {
                //We'll do nothing here. The idea is that zone and security strings are set
                //to "unkown" at the top of this method - if an exception is thrown, we'll
                //stick with those values
            }
        }

        /// <devdoc>
        ///    Sets the restricted window text (titlebar text of a form) when running
        ///    in a semi-trust environment.  The format is: [zone info] - Form Text - [site info]
        /// </devdoc>
        private string RestrictedWindowText(string original) {
            if (securityZone == null || securitySite == null) {

                ArrayList zones = new ArrayList();
                ArrayList sites = new ArrayList();
                
                SecurityManager.GetZoneAndOrigin( out zones, out sites );

                ResolveZoneAndSiteNames(sites, ref securityZone, ref securitySite);
            }

            return string.Format(Application.SafeTopLevelCaptionFormat, original, securityZone, securitySite);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.CenterToParent"]/*' />
        /// <devdoc>
        ///     Centers the dialog to its parent.
        /// </devdoc>
        /// <internalonly/>
        protected void CenterToParent() {
            if (TopLevel) {
                Point p = new Point();
                Size s = Size;
                IntPtr ownerHandle = IntPtr.Zero;

                ownerHandle = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_HWNDPARENT);
                if (ownerHandle != IntPtr.Zero) {
                    Screen desktop = Screen.FromHandleInternal(ownerHandle);
                    Rectangle screenRect = desktop.WorkingArea;
                    NativeMethods.RECT ownerRect = new NativeMethods.RECT();

                    UnsafeNativeMethods.GetWindowRect(new HandleRef(null, ownerHandle), ref ownerRect);

                    p.X = (ownerRect.left + ownerRect.right - s.Width) / 2;
                    if (p.X < screenRect.X)
                        p.X = screenRect.X;
                    else if (p.X + s.Width > screenRect.X + screenRect.Width)
                        p.X = screenRect.X + screenRect.Width - s.Width;

                    p.Y = (ownerRect.top + ownerRect.bottom - s.Height) / 2;
                    if (p.Y < screenRect.Y)
                        p.Y = screenRect.Y;
                    else if (p.Y + s.Height > screenRect.Y + screenRect.Height)
                        p.Y = screenRect.Y + screenRect.Height - s.Height;

                    Location = p;
                }
                else {
                    CenterToScreen();
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.CenterToScreen"]/*' />
        /// <devdoc>
        ///     Centers the dialog to the screen. This will first attempt to use
        ///     the owner property to determine the correct screen, then
        ///     it will try the HWND owner of the form, and finally this will
        ///     center the form on the same monitor as the mouse cursor.
        /// </devdoc>
        /// <internalonly/>
        protected void CenterToScreen() {
            Point p = new Point();
            Screen desktop = null;
            if (OwnerInternal != null) {
                desktop = Screen.FromControl(OwnerInternal);
            }
            else {
                IntPtr hWndOwner = IntPtr.Zero;
                if (TopLevel) {
                    hWndOwner = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_HWNDPARENT);
                }
                if (hWndOwner != IntPtr.Zero) {
                    desktop = Screen.FromHandleInternal(hWndOwner);
                }
                else {
                    desktop = Screen.FromPoint(Control.MousePosition);
                }
            }
            Rectangle screenRect = desktop.WorkingArea;
            p.X = Math.Max(screenRect.X,screenRect.X + (screenRect.Width - Width)/2);
            p.Y = Math.Max(screenRect.Y,screenRect.Y + (screenRect.Height - Height)/2);
            Location = p;
        }

        /// <devdoc>
        ///     Invalidates the merged menu, forcing the menu to be recreated if
        ///     needed again.
        /// </devdoc>
        private void InvalidateMergedMenu() {
            // here, we just set the merged menu to null (indicating that the menu structure
            // needs to be rebuilt).  Then, we signal the parent to updated its menus.
            if (Properties.ContainsObject(PropMergedMenu)) {
                MainMenu menu = Properties.GetObject(PropMergedMenu) as MainMenu;
                if (menu!=null) {
                    menu.CleanupMenuItemsHashtable();
                }

                Properties.SetObject(PropMergedMenu, null);
            }

            Form parForm = ParentFormInternal;
            if (parForm != null) {
                parForm.MenuChanged(0, parForm.Menu);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.LayoutMdi"]/*' />
        /// <devdoc>
        ///    <para> Arranges the Multiple Document Interface
        ///       (MDI) child forms according to value.</para>
        /// </devdoc>
        public void LayoutMdi(MdiLayout value) {
            if (ctlClient == null)
                return;
            ctlClient.LayoutMdi(value);
        }

        // Package scope for menu interop
        internal void MenuChanged(int change, Menu menu) {
            Form parForm = ParentFormInternal;
            if (parForm != null) {
                parForm.MenuChanged(change, menu);
                return;
            }

            switch (change) {
                case Windows.Forms.Menu.CHANGE_ITEMS:
                case Windows.Forms.Menu.CHANGE_MERGE:
                    if (ctlClient == null || !ctlClient.IsHandleCreated) {
                        if (menu == Menu && change == Windows.Forms.Menu.CHANGE_ITEMS)
                            UpdateMenuHandles();
                        break;
                    }

                    // Tell the children to toss their mergedMenu.
                    if (IsHandleCreated) {
                        UpdateMenuHandles(null, false);
                    }

                    for (int i = ctlClient.Controls.Count; i-- > 0;) {
                        Control ctl = ctlClient.Controls[i];
                        if (ctl is Form && ctl.Properties.ContainsObject(PropMergedMenu)) {
                            MainMenu mainMenu = ctl.Properties.GetObject(PropMergedMenu) as MainMenu;
                            if (mainMenu!=null) {
                                mainMenu.CleanupMenuItemsHashtable();
                            }
                            ctl.Properties.SetObject(PropMergedMenu, null);
                        }
                    }

                    UpdateMenuHandles();
                    break;
                case Windows.Forms.Menu.CHANGE_VISIBLE:
                    if (menu == Menu || (this.ActiveMdiChild != null && menu == this.ActiveMdiChild.Menu)) {
                        UpdateMenuHandles();
                    }
                    break;
                case Windows.Forms.Menu.CHANGE_MDI:
                    if (ctlClient != null && ctlClient.IsHandleCreated) {
                        UpdateMenuHandles();
                    }
                    break;
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnActivated"]/*' />
        /// <devdoc>
        ///    <para>The activate event is fired when the form is activated.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnActivated(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_ACTIVATED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnClosing"]/*' />
        /// <devdoc>
        ///    <para>The Closing event is fired when the form is closed.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnClosing(CancelEventArgs e) {
            CancelEventHandler handler = (CancelEventHandler)Events[EVENT_CLOSING];
            if (handler != null) handler(this,e);                        
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnClosed"]/*' />
        /// <devdoc>
        ///    <para>The Closed event is fired when the form is closed.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnClosed(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_CLOSED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnCreateControl"]/*' />
        /// <devdoc>
        ///    <para> Raises the CreateControl event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnCreateControl() {
            calledCreateControl = true;
            base.OnCreateControl();

            if (calledMakeVisible && !calledOnLoad) {
                calledOnLoad = true;
                OnLoad(EventArgs.Empty);
            }

            // If this form has a mainmenu, we need to setup the 
            // correct RTL bits on every menu item
            MainMenu m = Menu;
            if (m != null && RightToLeft == RightToLeft.Yes) {
                m.UpdateRtl();
            }

        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnDeactivate"]/*' />
        /// <devdoc>
        /// <para>Raises the Deactivate event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDeactivate(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_DEACTIVATE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnFontChanged(EventArgs e) {
            if (DesignMode) {
                UpdateAutoScaleBaseSize();
            }
            base.OnFontChanged(e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to find out when the
        ///     handle has been created.
        ///     Call base.OnHandleCreated first.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnHandleCreated(EventArgs e) {
            useMdiChildProc = IsMdiChild && Visible;
            base.OnHandleCreated(e);
            UpdateLayered();
            
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnHandleDestroyed"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Inheriting classes should override this method to find out when the
        ///    handle is about to be destroyed.
        ///    Call base.OnHandleDestroyed last.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnHandleDestroyed(EventArgs e) {
            base.OnHandleDestroyed(e);
            useMdiChildProc = false;

            // If the handle is being destroyed, and the security tip hasn't been dismissed
            // then we nuke it from the property bag. When we come back around and get
            // an NCACTIVATE we will see that this is missing and recreate the security
            // tip in it's default state.
            //
            ResetSecurityTip(true /* modalOnly */);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnLoad"]/*' />
        /// <devdoc>
        ///    <para>The Load event is fired before the form becomes visible for the first time.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnLoad(EventArgs e) {
            // subhag: This will apply AutoScaling to the form just
            // before the form becomes visible.
            //
            if (formState[FormStateAutoScaling] == 1 && !DesignMode) {
                // Turn off autoscaling so we don't do this on every handle
                // creation.
                //
                formState[FormStateAutoScaling] = 0;
                ApplyAutoScaling();
            }

            // Also, at this time we can now locate the form the the correct
            // area of the screen.  We must do this after applying any
            // autoscaling.
            //
            if (GetState(STATE_MODAL)) {
                FormStartPosition startPos = (FormStartPosition)formState[FormStateStartPos];
                if (startPos == FormStartPosition.CenterParent) {
                    CenterToParent();
                }
                else if (startPos == FormStartPosition.CenterScreen) {
                    CenterToScreen();
                }
            }

            // There is no good way to explain this event except to say
            // that it's just another name for OnControlCreated.
            EventHandler handler = (EventHandler)Events[EVENT_LOAD];
            if (handler != null) {
                string text = Text;
                
                handler(this,e);

                
		// It seems that if you set a window style during the onload 
		// event, we have a problem initially painting the window.  
		// So in the event that the user has set the on load event
		// in their application, we should go ahead and invalidate
		// the controls in their collection so that we paint properly.
		// This seems to manifiest itself in changes to the window caption,
		// and changes to the control box and help.

                foreach (Control c in Controls) {
                    c.Invalidate();
                }


            }

        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnMaximizedBoundsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMaximizedBoundsChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_MAXIMIZEDBOUNDSCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnMaximumSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMaximumSizeChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_MAXIMUMSIZECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnMinimumSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMinimumSizeChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_MINIMUMSIZECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnInputLanguageChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Form.InputLanguageChanged'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnInputLanguageChanged(InputLanguageChangedEventArgs e) {
            InputLanguageChangedEventHandler handler = (InputLanguageChangedEventHandler)Events[EVENT_INPUTLANGCHANGE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnInputLanguageChanging"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Form.InputLanguageChanging'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnInputLanguageChanging(InputLanguageChangingEventArgs e) {
            InputLanguageChangingEventHandler handler = (InputLanguageChangingEventHandler)Events[EVENT_INPUTLANGCHANGEREQUEST];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnVisibleChanged(EventArgs e) {
            UpdateRenderSizeGrip();
            base.OnVisibleChanged(e);

            // windows forms have to behave like dialog boxes sometimes. If the
            // user has specified that the mouse should snap to the
            // Accept button using the Mouse applet in the control panel,
            // we have to respect that setting each time our form is made visible.
            bool data = false;
            if (IsHandleCreated
                    && Visible
                    && (AcceptButton != null)
                    && UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETSNAPTODEFBUTTON, 0, ref data, 0)
                    && data) {

                Control button = AcceptButton as Control;
                NativeMethods.POINT ptToSnap = new NativeMethods.POINT(
                    button.Left + button.Width / 2,
                    button.Top + button.Height / 2);

                UnsafeNativeMethods.ClientToScreen(new HandleRef(this, Handle), ptToSnap);
                if (!button.IsWindowObscured) {
                    IntSecurity.AdjustCursorPosition.Assert();
                    try {
                        Cursor.Position = new Point(ptToSnap.x, ptToSnap.y);
                    }
                    finally {
                        System.Security.CodeAccessPermission.RevertAssert();
                    }
                }
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ActivateMdiChild"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>This function handles the activation of a MDI child form. If a subclass
        ///       overrides this function, it must call base.ActivateMdiChild</para>
        /// </devdoc>
        protected void ActivateMdiChild(Form form) {
            Form activeMdiChild = (Form)Properties.GetObject(PropActiveMdiChild);
            if (activeMdiChild == form) {
                return;
            }

            if (null != activeMdiChild) {
                activeMdiChild.Active = false;
            }

            activeMdiChild = form;
            Properties.SetObject(PropActiveMdiChild, form);

            if (null != activeMdiChild) {
                activeMdiChild.Active = true;
            }
            else if (this.Active) {
                ActivateControlInternal(this);
            }

            OnMdiChildActivate(EventArgs.Empty);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnMdiChildActivate"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Form.MdiChildActivate'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMdiChildActivate(EventArgs e) {
            UpdateMenuHandles();
            EventHandler handler = (EventHandler)Events[EVENT_MDI_CHILD_ACTIVATE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnMenuStart"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Form.MenuStart'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMenuStart(EventArgs e) {
            SecurityToolTip secTip = (SecurityToolTip)Properties.GetObject(PropSecurityTip);
            if (secTip != null) {
                secTip.Pop();
            }
            EventHandler handler = (EventHandler)Events[EVENT_MENUSTART];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnMenuComplete"]/*' />
        /// <devdoc>
        /// <para>Raises the MenuComplete event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMenuComplete(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_MENUCOMPLETE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnPaint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Raises the Paint event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnPaint(PaintEventArgs e) {
            base.OnPaint(e);
            if (formState[FormStateRenderSizeGrip] != 0) {
                Size sz = ClientSize;
                ControlPaint.DrawSizeGrip(e.Graphics, BackColor, sz.Width - SizeGripSize, sz.Height - SizeGripSize, SizeGripSize, SizeGripSize);
            }
            //If we have an mdi container - make sure we're painting the appworkspace background
            //
            if (IsMdiContainer) {
                Brush brush = SystemBrushes.FromSystemColor(SystemColors.AppWorkspace);
                e.Graphics.FillRectangle(brush, ClientRectangle);
            }
        }

       /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnResize"]/*' />
       /// <internalonly/>
        /// <devdoc>
        ///    <para>Raises the Resize event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnResize(EventArgs e) {
            base.OnResize(e);
            if (formState[FormStateRenderSizeGrip] != 0) {
                Invalidate();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnTextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnTextChanged(EventArgs e) {
            base.OnTextChanged(e);
            
            // If there is no control box, there should only be a title bar if text != "".
            int newTextEmpty = Text.Length == 0 ? 1 : 0;
            if (!ControlBox && formState[FormStateIsTextEmpty] != newTextEmpty)
                this.RecreateHandle();
                
            formState[FormStateIsTextEmpty] = newTextEmpty;
        }

        /// <devdoc>
        ///     Simulates a InputLanguageChanged event. Used by Control to forward events
        ///     to the parent form.
        /// </devdoc>
        /// <internalonly/>
        internal void PerformOnInputLanguageChanged(InputLanguageChangedEventArgs iplevent) {
            OnInputLanguageChanged(iplevent);
        }

        /// <devdoc>
        ///     Simulates a InputLanguageChanging event. Used by Control to forward
        ///     events to the parent form.
        /// </devdoc>
        /// <internalonly/>
        internal void PerformOnInputLanguageChanging(InputLanguageChangingEventArgs iplcevent) {
            OnInputLanguageChanging(iplcevent);
        }
        
        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ProcessCmdKey"]/*' />
        /// <devdoc>
        ///     Processes a command key. Overrides Control.processCmdKey() to provide
        ///     additional handling of main menu command keys and Mdi accelerators.
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected override bool ProcessCmdKey(ref Message msg, Keys keyData) {
            if (base.ProcessCmdKey(ref msg, keyData)) return true;
            
            MainMenu curMenu = (MainMenu)Properties.GetObject(PropCurMenu);
            if (curMenu != null && curMenu.ProcessCmdKey(ref msg, keyData)) return true;

            // Process MDI accelerator keys.

            bool retValue = false;

            NativeMethods.MSG win32Message = new NativeMethods.MSG();
            win32Message.message = msg.Msg;
            win32Message.wParam = msg.WParam;
            win32Message.lParam = msg.LParam;
            win32Message.hwnd = msg.HWnd;

            if (ctlClient != null && ctlClient.Handle != IntPtr.Zero &&
                UnsafeNativeMethods.TranslateMDISysAccel(ctlClient.Handle, ref win32Message)) {

                retValue = true;
            }
            
            msg.Msg = win32Message.message;
            msg.WParam = win32Message.wParam;
            msg.LParam = win32Message.lParam;
            msg.HWnd = win32Message.hwnd;

            return retValue;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///     Processes a dialog key. Overrides Control.processDialogKey(). This
        ///     method implements handling of the RETURN, and ESCAPE keys in dialogs.
        /// The method performs no processing on keys that include the ALT or
        ///     CONTROL modifiers.
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
            if ((keyData & (Keys.Alt | Keys.Control)) == Keys.None) {
                Keys keyCode = (Keys)keyData & Keys.KeyCode;
                IButtonControl button;
                
                switch (keyCode) {
                    case Keys.Return:
                        button = (IButtonControl)Properties.GetObject(PropDefaultButton);
                        if (button != null) {
                            //PerformClick now checks for validationcancelled...
                            if (button is Control) { 
                                button.PerformClick();
                            }
                            return true;
                        }
                        break;
                    case Keys.Escape:
                        button = (IButtonControl)Properties.GetObject(PropCancelButton);
                        if (button != null) {
                            // In order to keep the behavior in sync with native
                            // and MFC dialogs, we want to not give the cancel button
                            // the focus on Escape. If we do, we end up with giving it
                            // the focus when we reshow the dialog.
                            //
                            //if (button is Control) {
                            //    ((Control)button).Focus();
                            //}
                            button.PerformClick();
                            return true;
                        }
                        break;
                }
            }
            return base.ProcessDialogKey(keyData);
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ProcessKeyPreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected override bool ProcessKeyPreview(ref Message m) {
            if (formState[FormStateKeyPreview] != 0 && ProcessKeyEventArgs(ref m))
                return true;
            return base.ProcessKeyPreview(ref m);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ProcessTabKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool ProcessTabKey(bool forward) {
            if (SelectNextControl(ActiveControl, forward, true, true, true))
                return true;

            // I've added a special case for UserControls because they shouldn't cycle back to the
            // beginning if they don't have a parent form, such as when they're on an ActiveXBridge.
            if (IsMdiChild || ParentFormInternal == null) {
                bool selected = SelectNextControl(null, forward, true, true, false);

                if (selected) {
                    return true;
                }
            }

            return false;
        }

        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal override void RecreateHandleCore() {
            NativeMethods.WINDOWPLACEMENT wp = new NativeMethods.WINDOWPLACEMENT();
            FormStartPosition oldStartPosition = FormStartPosition.Manual;

            if (!IsMdiChild && (WindowState == FormWindowState.Minimized || WindowState == FormWindowState.Maximized)) {
                wp.length = Marshal.SizeOf(typeof(NativeMethods.WINDOWPLACEMENT));
                UnsafeNativeMethods.GetWindowPlacement(new HandleRef(this, Handle), ref wp);
            }

            if (StartPosition != FormStartPosition.Manual) {
                oldStartPosition = StartPosition;
                // Set the startup postion to manual, to stop the form from
                // changing position each time RecreateHandle() is called.
                StartPosition = FormStartPosition.Manual;
            }

            base.RecreateHandleCore();

            if (oldStartPosition != FormStartPosition.Manual) {
                StartPosition = oldStartPosition;
            }
  
            if (wp.length > 0) {
                UnsafeNativeMethods.SetWindowPlacement(new HandleRef(this, Handle), ref wp);
            }
    
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.RemoveOwnedForm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes a form from the list of owned forms. Also sets the owner of the
        ///       removed form to null.
        ///    </para>
        /// </devdoc>
        public void RemoveOwnedForm(Form ownedForm) {
            if (ownedForm == null)
                return;

            if (ownedForm.OwnerInternal != null) {
                ownedForm.Owner = null; // NOTE: this will call RemoveOwnedForm again, bypassing if.
                return;
            }

            Form[] ownedForms = (Form[])Properties.GetObject(PropOwnedForms);
            int ownedFormsCount = Properties.GetInteger(PropOwnedFormsCount);

            if (ownedForms != null) {
                for (int i = 0; i < ownedFormsCount; i++) {
                    if (ownedForm.Equals(ownedForms[i])) {
                        if (i + 1 < ownedFormsCount) {
                            Array.Copy(ownedForms, i + 1, ownedForms, i, ownedFormsCount - i - 1);
                        }
                        ownedFormsCount--;
                    }
                }
                
                Properties.SetInteger(PropOwnedFormsCount, ownedFormsCount);
            }
        }

        /// <devdoc>
        ///     Resets the form's icon the the default value.
        /// </devdoc>
        private void ResetIcon() {
            icon = null;
            if (smallIcon != null) {
                smallIcon.Dispose();
                smallIcon = null;
            }
            formState[FormStateIconSet] = 0;
            UpdateWindowIcon(true);
        }

        void ResetSecurityTip(bool modalOnly) {
            SecurityToolTip secTip = (SecurityToolTip)Properties.GetObject(PropSecurityTip);
            if (secTip != null) {
                if ((modalOnly && secTip.Modal) || !modalOnly) {
                    secTip.Dispose();
                    secTip = null;
                    Properties.SetObject(PropSecurityTip, null);
                }
            }
        }

        // If someone set Location or Size while the form was maximized or minimized,
        // we had to cache the new value away until after the form was restored to normal size.
        // This function is called after WindowState changes, and handles the above logic.
        // In the normal case where no one sets Location or Size programmatically,
        // Windows does the restoring for us.
        //
        private void RestoreWindowBoundsIfNecessary() {
            if (WindowState  == FormWindowState.Normal) {
                SetBounds(restoredWindowBounds.X, restoredWindowBounds.Y,
                          restoredWindowBounds.Width, restoredWindowBounds.Height, 
                          restoredWindowBoundsSpecified);
                restoredWindowBoundsSpecified = 0;
                restoredWindowBounds = new Rectangle(-1, -1, -1, -1);
            }
        }

        void RestrictedProcessNcActivate() {
            Debug.Assert(IsRestrictedWindow, "This should only be called for restricted windows");

            // Ignore if tearing down...
            //
            if (IsDisposed || Disposing) {
                return;
            }

            SecurityToolTip secTip = (SecurityToolTip)Properties.GetObject(PropSecurityTip);
            if (secTip == null) {
                if (UnsafeNativeMethods.GetForegroundWindow() == this.Handle) {
                    secTip = new SecurityToolTip(this);
                    Properties.SetObject(PropSecurityTip, secTip);
                }
            }
            else if (UnsafeNativeMethods.GetForegroundWindow() != this.Handle) {
                secTip.Pop();
            }
        }

        /// <devdoc>
        ///     Decrements updateMenuHandleSuspendCount. If updateMenuHandleSuspendCount
        ///     becomes zero and updateMenuHandlesDeferred is true, updateMenuHandles
        ///     is called.
        /// </devdoc>
        private void ResumeUpdateMenuHandles() {
            if (updateMenuHandlesSuspendCount <= 0)
                throw new InvalidOperationException(SR.GetString(SR.TooManyResumeUpdateMenuHandles));
            if (--updateMenuHandlesSuspendCount == 0 && updateMenuHandlesDeferred)
                UpdateMenuHandles();
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.Select"]/*' />
        /// <devdoc>
        ///     Selects this form, and optionally selects the next/previous control.
        /// </devdoc>
        protected override void Select(bool directed, bool forward) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyFocus Demanded");
            IntSecurity.ModifyFocus.Demand();

            if (directed) SelectNextControl(null, forward, true, true, false);
            if (TopLevel) {
                UnsafeNativeMethods.SetActiveWindow(new HandleRef(this, Handle));
            }
            else if (IsMdiChild) {
                UnsafeNativeMethods.SetActiveWindow(new HandleRef(MdiParentInternal, MdiParentInternal.Handle));
                MdiParentInternal.GetMdiClient().SendMessage(NativeMethods.WM_MDIACTIVATE, Handle, 0);
            }
            else {
                Form form = ParentFormInternal;
                if (form != null) form.ActiveControl = this;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ScaleCore"]/*' />
        /// <devdoc>
        ///     Base function that performs scaling of the form.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void ScaleCore(float x, float y) {
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, GetType().Name + "::ScaleCore(" + x + ", " + y + ")");
            SuspendLayout();
            try {
                if (WindowState == FormWindowState.Normal) {
                    Size size = ClientSize;
                    if (!GetStyle(ControlStyles.FixedWidth)) {
                        size.Width = (int) (((float)size.Width) * x);
                    }
                    if (!GetStyle(ControlStyles.FixedHeight)) {
                        size.Height = (int) (((float)size.Height) * y);
                    }
                    ClientSize = size;
                }

                ScaleDockPadding(x, y);

                foreach(Control control in Controls) {
                    if (control != null) {
                        control.Scale(x, y);
                    }
                }                           
            }
            finally {
                ResumeLayout();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.SetBoundsCore"]/*' />
        /// <devdoc>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            if (WindowState != FormWindowState.Normal) {
                // See RestoreWindowBoundsIfNecessary for an explanation of this
                restoredWindowBoundsSpecified |= specified;

                if ((specified & BoundsSpecified.X) != 0)
                    restoredWindowBounds.X = x;
                if ((specified & BoundsSpecified.Y) != 0)
                    restoredWindowBounds.Y = y;
                if ((specified & BoundsSpecified.Width) != 0)
                    restoredWindowBounds.Width = width;
                if ((specified & BoundsSpecified.Height) != 0)
                    restoredWindowBounds.Height = height;
            }

            // Enforce maximum size...
            //
            if (WindowState == FormWindowState.Normal
                && (this.Height != height || this.Width != width)) {

                Size max = SystemInformation.MaxWindowTrackSize;
                if (height > max.Height) {
                    height = max.Height;
                }
                if (width > max.Width) {
                    width = max.Width;
                }
            }

            // Only enforce the minimum size if the form has a border and is a top
            // level form.
            //
            FormBorderStyle borderStyle = FormBorderStyle;
            if (borderStyle != FormBorderStyle.None
                && borderStyle != FormBorderStyle.FixedToolWindow
                && borderStyle != FormBorderStyle.SizableToolWindow
                && ParentInternal == null) {

                Size min = SystemInformation.MinWindowTrackSize;
                if (height < min.Height) {
                    height = min.Height;
                }
                if (width < min.Width) {
                    width = min.Width;
                }
            }

            if (IsRestrictedWindow) {
                // Check to ensure that the title bar, and all corners of the window, are visible on a monitor
                //

                Screen[] screens = Screen.AllScreens;
                bool topLeft = false;
                bool topRight = false;
                bool bottomLeft = false;
                bool bottomRight = false;

                for (int i=0; i<screens.Length; i++) {
                    Rectangle current = screens[i].WorkingArea;
                    if (current.Contains(x, y)) {
                        topLeft = true;
                    }
                    if (current.Contains(x + width, y)) {
                        topRight = true;
                    }
                    if (current.Contains(x, y + height)) {
                        bottomLeft = true;
                    }
                    if (current.Contains(x + width, y + height)) {
                        bottomRight = true;
                    }
                }

                if (!(topLeft && topRight && bottomLeft && bottomRight)) {
                    base.SetBoundsCore(Left, Top, Width, Height, BoundsSpecified.All);
                    return;
                }
            }

            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <devdoc>
        ///     Sets the defaultButton for the form. The defaultButton is "clicked" when
        ///     the user presses Enter.
        /// </devdoc>
        private void SetDefaultButton(IButtonControl button) {
            IButtonControl defaultButton = (IButtonControl)Properties.GetObject(PropDefaultButton);
            
            if (defaultButton != button) {
                if (defaultButton != null) defaultButton.NotifyDefault(false);
                Properties.SetObject(PropDefaultButton, button);
                if (button != null) button.NotifyDefault(true);
            }
        }


        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.SetClientSizeCore"]/*' />
        /// <devdoc>
        ///     Sets the clientSize of the form. This will adjust the bounds of the form
        ///     to make the clientSize the requested size.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void SetClientSizeCore(int x, int y) {
            bool hadHScroll = HScroll, hadVScroll = VScroll;
            base.SetClientSizeCore(x, y);

            if (IsHandleCreated) {
                // Adjust for the scrollbars, if they were introduced by
                // the call to base.SetClientSizeCore
                if (VScroll != hadVScroll) {
                    if (VScroll) x += SystemInformation.VerticalScrollBarWidth;
                }
                if (HScroll != hadHScroll) {
                    if (HScroll) y += SystemInformation.HorizontalScrollBarHeight;
                }
                if (x != ClientSize.Width || y != ClientSize.Height) {
                    base.SetClientSizeCore(x, y);
                }
            }
            formState[FormStateSetClientSize] = 1;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.SetDesktopBounds"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Sets the bounds of the form in desktop coordinates.</para>
        /// </devdoc>
        public void SetDesktopBounds(int x, int y, int width, int height) {
            Rectangle workingArea = SystemInformation.WorkingArea;
            SetBounds(x + workingArea.X, y + workingArea.Y, width, height, BoundsSpecified.All);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.SetDesktopLocation"]/*' />
        /// <devdoc>
        ///    <para>Sets the location of the form in desktop coordinates.</para>
        /// </devdoc>
        public void SetDesktopLocation(int x, int y) {
            Rectangle workingArea = SystemInformation.WorkingArea;
            Location = new Point(workingArea.X + x, workingArea.Y + y);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ShowDialog"]/*' />
        /// <devdoc>
        ///    <para>Displays this form as a modal dialog box with no owner window.</para>
        /// </devdoc>
        public DialogResult ShowDialog() {
            return ShowDialog(null);
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ShowDialog1"]/*' />
        /// <devdoc>
        ///    <para>Shows this form as a modal dialog with the specified owner.</para>
        /// </devdoc>
        public DialogResult ShowDialog(IWin32Window owner) {
            if (owner == this) {
                throw new ArgumentException(SR.GetString(SR.OwnsSelfOrOwner,
                                                  "showDialog"), "owner");
            }
            else if (Visible) {
                throw new InvalidOperationException(SR.GetString(SR.ShowDialogOnVisible,
                                                  "showDialog"));
            }
            else if (!Enabled) {
                throw new InvalidOperationException(SR.GetString(SR.ShowDialogOnDisabled,
                                                  "showDialog"));
            }
            else if (!TopLevel) {
                throw new InvalidOperationException(SR.GetString(SR.ShowDialogOnNonTopLevel,
                                                  "showDialog"));
            }
            else if (Modal) {
                throw new InvalidOperationException(SR.GetString(SR.ShowDialogOnModal,
                                                  "showDialog"));
            }
            else if (!SystemInformation.UserInteractive) {
                throw new InvalidOperationException(SR.GetString(SR.CantShowModalOnNonInteractive));
            }
            else if ( (owner != null) && ((int)UnsafeNativeMethods.GetWindowLong(new HandleRef(owner, owner.Handle), NativeMethods.GWL_EXSTYLE)
                     & NativeMethods.WS_EX_TOPMOST) == 0 ) {   // It's not the top-most window
                if (owner is Control) {
                    owner = ((Control)owner).TopLevelControl;
                }
            }

            this.calledOnLoad = false;
            this.calledMakeVisible = false;

            IntPtr hWndCapture = UnsafeNativeMethods.GetCapture();
            if (hWndCapture != IntPtr.Zero) {
                UnsafeNativeMethods.SendMessage(new HandleRef(null, hWndCapture), NativeMethods.WM_CANCELMODE, IntPtr.Zero, IntPtr.Zero);
                SafeNativeMethods.ReleaseCapture();
            }
            IntPtr hWndActive = UnsafeNativeMethods.GetActiveWindow();
            IntPtr hWndOwner = owner == null? hWndActive: owner.Handle;
            IntPtr hWndOldOwner = IntPtr.Zero;
            Properties.SetObject(PropDialogOwner, owner);

            Form oldOwner = OwnerInternal;
            
            if (owner is Form && owner != oldOwner) {
                Owner = (Form)owner;
            }

            try {
                SetState(STATE_MODAL, true);

                // ASURT 102728
                // It's possible that while in the process of creating the control,
                // (i.e. inside the CreateControl() call) the dialog can be closed.
                // e.g. A user might call Close() inside the OnLoad() event.
                // Calling Close() will set the DialogResult to some value, so that
                // we'll know to terminate the RunDialog loop immediately.
                // Thus we must initialize the DialogResult *before* the call
                // to CreateControl().
                //
                dialogResult = DialogResult.None;

                // V#36617 - if "this" is an MDI parent then the window gets activated,
                // causing GetActiveWindow to return "this.handle"... to prevent setting
                // the owner of this to this, we must create the control AFTER calling
                // GetActiveWindow.
                //
                CreateControl();

                if (hWndOwner != IntPtr.Zero && hWndOwner != Handle) {
                    // Catch the case of a window trying to own its owner
                    if (UnsafeNativeMethods.GetWindowLong(new HandleRef(owner, hWndOwner), NativeMethods.GWL_HWNDPARENT) == Handle) {
                        throw new ArgumentException(SR.GetString(SR.OwnsSelfOrOwner,
                                                          "showDialog"), "owner");
                    }

                    // Set the new owner.
                    hWndOldOwner = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_HWNDPARENT);
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_HWNDPARENT, new HandleRef(owner, hWndOwner));
                }

                try {	
                    Visible = true;
                    
                    // If the DialogResult was already set, then there's
                    // no need to actually display the dialog.
                    //
                    if (dialogResult == DialogResult.None) 
                    {						
                        Application.RunDialog(this);
                    }
                }                
                finally {
                    // Call SetActiveWindow before setting Visible = false.
                    if (!UnsafeNativeMethods.IsWindow(new HandleRef(null, hWndActive))) hWndActive = hWndOwner;
                    if (UnsafeNativeMethods.IsWindow(new HandleRef(null, hWndActive)) && SafeNativeMethods.IsWindowVisible(new HandleRef(null, hWndActive))) {
                        UnsafeNativeMethods.SetActiveWindow(new HandleRef(null, hWndActive));
                    }

                    SetVisibleCore(false);
                    if (IsHandleCreated) {

                        // SECREVIEW : Dialog is done, we need to cleanup by destroying
                        //           : the handle.
                        //
                        IntSecurity.ManipulateWndProcAndHandles.Assert();
                        try {
                            DestroyHandle();
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    SetState(STATE_MODAL, false);
                }
            }
            finally {
                Owner = oldOwner;
                Properties.SetObject(PropDialogOwner, null);
            }
            return DialogResult;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ShouldSerializeAutoScaleBaseSize"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.Form.AutoScaleBaseSize'/> property should be 
        ///    persisted.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeAutoScaleBaseSize() {
            return true;
        }

        private bool ShouldSerializeClientSize() {
            return true;
        }

        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.Form.Icon'/> property should be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeIcon() {
            return formState[FormStateIconSet] == 1;
        }

        /// <devdoc>
        ///     Determines if the Location property needs to be persisted.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool ShouldSerializeLocation() {
            return Left != 0 || Top != 0;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ShouldSerializeSize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.Form.Size'/> property should be persisted.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal override bool ShouldSerializeSize() {
            return false;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ShouldSerializeTransparencyKey"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.Form.TransparencyKey'/> property should be 
        ///    persisted.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal bool ShouldSerializeTransparencyKey() {
            return !TransparencyKey.Equals(Color.Empty);
        }

        /// <devdoc>
        ///     Increments updateMenuHandleSuspendCount.
        /// </devdoc>
        private void SuspendUpdateMenuHandles() {
            updateMenuHandlesSuspendCount++;
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Text: " + Text;
        }

        /// <devdoc>
        ///     Updates the autoscalebasesize based on the current font.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateAutoScaleBaseSize() {
            autoScaleBaseSize = Size.Empty;
        }

        private void UpdateRenderSizeGrip() {
            int current = formState[FormStateRenderSizeGrip];
            switch (FormBorderStyle) {
                case FormBorderStyle.None:
                case FormBorderStyle.FixedSingle:
                case FormBorderStyle.Fixed3D:
                case FormBorderStyle.FixedDialog:
                case FormBorderStyle.FixedToolWindow:
                    formState[FormStateRenderSizeGrip] = 0;
                    break;
                case FormBorderStyle.Sizable:
                case FormBorderStyle.SizableToolWindow:
                    switch (SizeGripStyle) {
                        case SizeGripStyle.Show:
                            formState[FormStateRenderSizeGrip] = 1;
                            break;
                        case SizeGripStyle.Hide:
                            formState[FormStateRenderSizeGrip] = 0;
                            break;
                        case SizeGripStyle.Auto:
                            if (GetState(STATE_MODAL)) {
                                formState[FormStateRenderSizeGrip] = 1;
                            }
                            else {
                                formState[FormStateRenderSizeGrip] = 0;
                            }
                            break;
                    }
                    break;
            }

            if (formState[FormStateRenderSizeGrip] != current) {
                Invalidate();
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.UpdateDefaultButton"]/*' />
        /// <devdoc>
        ///     Updates the default button based on current selection, and the
        ///     acceptButton property.
        /// </devdoc>
        /// <internalonly/>
        protected override void UpdateDefaultButton() {
            ContainerControl cc = this;
            while (cc.ActiveControl is ContainerControl)
            {
                cc = cc.ActiveControl as ContainerControl;
                Debug.Assert(cc != null);
            }
            if (cc.ActiveControl is IButtonControl)
            {
                SetDefaultButton((IButtonControl) cc.ActiveControl);
            }
            else
            {
                SetDefaultButton(AcceptButton);
            }
        }

        /// <devdoc>
        ///     Updates the underlying hWnd with the correct parent/owner of the form.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateHandleWithOwner() {
            if (IsHandleCreated && TopLevel) {
                HandleRef ownerHwnd = NativeMethods.NullHandleRef;
                
                Form owner = (Form)Properties.GetObject(PropOwner);
                
                if (owner != null) {
                    ownerHwnd = new HandleRef(owner, owner.Handle);
                }
                else {
                    if (!ShowInTaskbar) {
                        ownerHwnd = new HandleRef(Application.GetParkingWindow(this), Application.GetParkingWindow(this).Handle);
                    }
                }

                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_HWNDPARENT, ownerHwnd);
            }
        }

        /// <devdoc>
        ///     Updates the layered window attributes if the control
        ///     is in layered mode.
        /// </devdoc>
        private void UpdateLayered() {
            if ((formState[FormStateAllowLayered] != 0) && IsHandleCreated && TopLevel) {
                bool result;
                
                Color transparencyKey = TransparencyKey;
                
                if (transparencyKey.IsEmpty) {
                    
                    result = UnsafeNativeMethods.SetLayeredWindowAttributes(new HandleRef(this, Handle), 0, OpacityAsByte, NativeMethods.LWA_ALPHA);
                }
                else if (OpacityAsByte == 255) {
                    // Windows doesn't do so well setting colorkey and alpha, so avoid it if we can
                    result = UnsafeNativeMethods.SetLayeredWindowAttributes(new HandleRef(this, Handle), ColorTranslator.ToWin32(transparencyKey), 0, NativeMethods.LWA_COLORKEY);
                }
                else {
                    result = UnsafeNativeMethods.SetLayeredWindowAttributes(new HandleRef(this, Handle), ColorTranslator.ToWin32(transparencyKey),
                                                                OpacityAsByte, NativeMethods.LWA_ALPHA | NativeMethods.LWA_COLORKEY);
                }

                if (!result) {
                    throw new Win32Exception();
                }
            }
        }

        /// <internalonly/>
        private void UpdateMenuHandles() {
            Form form;

            // Forget the current menu.
            if (Properties.GetObject(PropCurMenu) != null) {
                Properties.SetObject(PropCurMenu, null);
            }

            if (IsHandleCreated) {


                if (!TopLevel) {
                    UpdateMenuHandles(null, true);
                }
                else {
                    form = ActiveMdiChild;
                    if (form != null) {
                        UpdateMenuHandles(form.MergedMenu, true);
                    }
                    else {
                        UpdateMenuHandles(Menu, true);
                    }
                }
            }
        }

        private void UpdateMenuHandles(MainMenu menu, bool forceRedraw) {
            Debug.Assert(IsHandleCreated, "shouldn't call when handle == 0");

            if (updateMenuHandlesSuspendCount > 0 && menu != null) {
                updateMenuHandlesDeferred = true;
                return;
            }

            MainMenu curMenu = menu;
            if (curMenu != null) {
                curMenu.form = this;
            }
            
            if (curMenu != null || Properties.ContainsObject(PropCurMenu)) {
                Properties.SetObject(PropCurMenu, curMenu);
            }

            if (ctlClient == null || !ctlClient.IsHandleCreated) {
                if (menu != null) {
                    UnsafeNativeMethods.SetMenu(new HandleRef(this, Handle), new HandleRef(menu, menu.Handle));
                }
                else {
                    UnsafeNativeMethods.SetMenu(new HandleRef(this, Handle), NativeMethods.NullHandleRef);
                }
            }
            else {
                // Make MDI forget the mdi item position.
                MainMenu dummyMenu = (MainMenu)Properties.GetObject(PropDummyMenu);
                
                if (dummyMenu == null) {
                    dummyMenu = new MainMenu();
                    Properties.SetObject(PropDummyMenu, dummyMenu);
                }
                UnsafeNativeMethods.SendMessage(new HandleRef(ctlClient, ctlClient.Handle), NativeMethods.WM_MDISETMENU, dummyMenu.Handle, IntPtr.Zero);
                if (menu != null) {

                    MenuItem mdiItem = menu.MdiListItem;
                    IntPtr mdiHandle = IntPtr.Zero;
                    if (mdiItem != null) {
                        mdiHandle = mdiItem.Handle;
                    }

                    // CHRISAN, 5/2/1998 - Don't ever use Win32 native MDI lists,
                    // instead rely on our own implementation... see MenuItem
                    // for the implementation of our window menu...
                    //
                    //Windows.SendMessage(ctlClient.getHandle(), NativeMethods.WM_MdiSETMENU,
                    //menu.getHandle(), mdiHandle);


                    // CHRISAN, 5/2/1998 - don't use Win32 native Mdi lists...
                    //
                    UnsafeNativeMethods.SendMessage(new HandleRef(ctlClient, ctlClient.Handle), NativeMethods.WM_MDISETMENU, menu.Handle, IntPtr.Zero);
                }
            }
            if (forceRedraw) {
                SafeNativeMethods.DrawMenuBar(new HandleRef(this, Handle));
            }
            updateMenuHandlesDeferred = false;
        }

        // Call this function instead of UpdateStyles() when the form's client-size must
        // be preserved e.g. when changing the border style.
        //
        internal void UpdateFormStyles() {
            Size previousClientSize = ClientSize;
            base.UpdateStyles();
            if (!ClientSize.Equals(previousClientSize)) {
                ClientSize = previousClientSize;
            }
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.OnStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnStyleChanged(EventArgs e) {
            base.OnStyleChanged(e);
            AdjustSystemMenu();
        }

        /// <devdoc>
        ///     Updates the window icon.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateWindowIcon(bool redrawFrame) {
            if (IsHandleCreated) {
                Icon icon;

                // Preserve Win32 behavior by keeping the icon we set NULL if
                // the user hasn't specified an icon and we are a dialog frame.
                //
                if (FormBorderStyle == FormBorderStyle.FixedDialog && formState[FormStateIconSet] == 0 && !IsRestrictedWindow) {
                    icon = null;
                }
                else {
                    icon = Icon;
                }

                if (icon != null) {
                    if (smallIcon == null) {
                        try {
                            smallIcon = new Icon(icon, SystemInformation.SmallIconSize);
                        }
                        catch {
                        }
                    }
                
                    if (smallIcon != null) {
                        SendMessage(NativeMethods.WM_SETICON,NativeMethods.ICON_SMALL,smallIcon.Handle);
                    }
                    SendMessage(NativeMethods.WM_SETICON,NativeMethods.ICON_BIG,icon.Handle);
                }
                else {
                    SendMessage(NativeMethods.WM_SETICON,NativeMethods.ICON_SMALL,0);
                    SendMessage(NativeMethods.WM_SETICON,NativeMethods.ICON_BIG,0);
                }

                if (redrawFrame) {
                    SafeNativeMethods.RedrawWindow(new HandleRef(this, Handle), null, NativeMethods.NullHandleRef, NativeMethods.RDW_INVALIDATE | NativeMethods.RDW_FRAME);
                }
            }
        }

        /// <devdoc>
        ///     Updated the window state from the handle, if created.
        /// </devdoc>
        /// <internalonly/>
        //
        // This function is called from all over the place, including my personal favorite,
        // WM_ERASEBKGRND.  Seems that's one of the first messages we get when a user clicks the min/max
        // button, even before WM_WINDOWPOSCHANGED.
        private void UpdateWindowState() {
            if (IsHandleCreated) {
                FormWindowState oldState = WindowState;
                NativeMethods.WINDOWPLACEMENT wp = new NativeMethods.WINDOWPLACEMENT();
                wp.length = Marshal.SizeOf(typeof(NativeMethods.WINDOWPLACEMENT));
                UnsafeNativeMethods.GetWindowPlacement(new HandleRef(this, Handle), ref wp);

                switch (wp.showCmd) {
                    case NativeMethods.SW_NORMAL:
                    case NativeMethods.SW_RESTORE:
                    case NativeMethods.SW_SHOW:
                    case NativeMethods.SW_SHOWNA:
                    case NativeMethods.SW_SHOWNOACTIVATE:
                        formState[FormStateWindowState] = (int)FormWindowState.Normal;
                        break;
                    case NativeMethods.SW_SHOWMAXIMIZED:
                        formState[FormStateWindowState] = (int)FormWindowState.Maximized;
                        break;
                    case NativeMethods.SW_SHOWMINIMIZED:
                    case NativeMethods.SW_MINIMIZE:
                    case NativeMethods.SW_SHOWMINNOACTIVE:
                        formState[FormStateWindowState] = (int)FormWindowState.Minimized;
                        break;
                    case NativeMethods.SW_HIDE:
                    default:
                        break;
                }

                // If we used to be normal and we just became minimized or maximized,
                // stash off our current bounds so we can properly restore.
                //
                if (oldState == FormWindowState.Normal && WindowState != FormWindowState.Normal) {
                    restoredWindowBounds.Size = Size;
                    restoredWindowBoundsSpecified = BoundsSpecified.Size;
                    if (StartPosition == FormStartPosition.Manual) {
                        restoredWindowBounds.Location = Location;
                        restoredWindowBoundsSpecified |= BoundsSpecified.Location;
                    }
                }

                switch (WindowState) {
                    case FormWindowState.Normal:
                        SetState(STATE_SIZELOCKEDBYOS, false);
                        break;
                    case FormWindowState.Maximized:
                    case FormWindowState.Minimized:
                        SetState(STATE_SIZELOCKEDBYOS, true);
                        break;
                }


                bool adjusted = false;

                // Strip the control box off an MDIChild if it is getting
                // un-maximized. When you maximize and MDIChild the controlbox is
                // forced on, this keeps the state correct.
                //
                if (Properties.GetObject(PropFormMdiParent) != null && !ControlBox) {
                    if (oldState != WindowState
                        && oldState == FormWindowState.Maximized) {
                        UpdateStyles();
                        adjusted = true;
                    }
                }

                if (oldState != WindowState && !adjusted) {
                    AdjustSystemMenu();
                }
            }
        }

        /// <devdoc>
        ///     WM_ACTIVATE handler
        /// </devdoc>
        /// <internalonly/>
        private void WmActivate(ref Message m) {
            Application.FormActivated(this.Modal, true); // inform MsoComponentManager we're active
            Active = ((int)m.WParam & 0x0000FFFF) != NativeMethods.WA_INACTIVE;
            Application.FormActivated(this.Modal, Active); // inform MsoComponentManager we're active
        }

        /// <devdoc>
        ///     WM_CREATE handler
        /// </devdoc>
        /// <internalonly/>
        private void WmCreate(ref Message m) {
            base.WndProc(ref m);
            NativeMethods.STARTUPINFO_I si = new NativeMethods.STARTUPINFO_I();
            UnsafeNativeMethods.GetStartupInfo(si);

            // If we've been created from explorer, it may
            // force us to show up normal.  Force our current window state to
            // the specified state, unless it's _specified_ max or min
            if (TopLevel && (si.dwFlags & NativeMethods.STARTF_USESHOWWINDOW) != 0) {
                switch (si.wShowWindow) {
                    case NativeMethods.SW_MAXIMIZE:
                        WindowState = FormWindowState.Maximized;
                        break;
                    case NativeMethods.SW_MINIMIZE:
                        WindowState = FormWindowState.Minimized;
                        break;
                }                                 
            }
        }

        /// <devdoc>
        ///     WM_CLOSE, WM_QUERYENDSESSION, and WM_ENDSESSION handler
        /// </devdoc>
        /// <internalonly/>
        private void WmClose(ref Message m) {
            CancelEventArgs e = new CancelEventArgs(false);

            // Pass 1 (WM_CLOSE & WM_QUERYENDSESSION)... Closing
            //
            if (m.Msg != NativeMethods.WM_ENDSESSION) {
                if (Modal) {
                    if (dialogResult == DialogResult.None) {
                        dialogResult = DialogResult.Cancel;
                    }
                    return;
                }
                e.Cancel = !Validate();
                
                // Fire closing event on all mdi children and ourselves
                //
                if (IsMdiContainer) {
                    foreach(Form mdiChild in MdiChildren) {
                        if (mdiChild.IsHandleCreated) {
                            mdiChild.OnClosing(e);
                            if (e.Cancel) {
                                break;
                            }
                        }
                    }
                }

                //ALWAYS Fire OnClosing Irrespective of the Validation result
                //Pass the Validation result into the EventArgs...
                OnClosing(e);
                
                if (m.Msg == NativeMethods.WM_QUERYENDSESSION) {
                    m.Result = (IntPtr)(e.Cancel ? 0 : 1);
                }
            }
            else {
                e.Cancel = m.WParam == IntPtr.Zero;
            }
            
            // Pass 2 (WM_CLOSE & WM_ENDSESSION)... Fire closed
            // event on all mdi children and ourselves
            //
            if (m.Msg != NativeMethods.WM_QUERYENDSESSION) {
                if (!e.Cancel) {
                    if (IsMdiContainer) {
                        foreach(Form mdiChild in MdiChildren) {
                            if (mdiChild.IsHandleCreated) {
                                mdiChild.OnClosed(EventArgs.Empty);
                            }
                        }
                    }
                    
                    OnClosed(EventArgs.Empty);
                    Dispose();                    
                }
            }
        }

        /// <devdoc>
        ///     WM_ENTERMENULOOP handler
        /// </devdoc>
        /// <internalonly/>
        private void WmEnterMenuLoop(ref Message m) {
            OnMenuStart(EventArgs.Empty);
            base.WndProc(ref m);
        }

        /// <devdoc>
        ///     Handles the WM_ERASEBKGND message
        /// </devdoc>
        /// <internalonly/>
        private void WmEraseBkgnd(ref Message m) {
            UpdateWindowState();
            base.WndProc(ref m);
        }

        /// <devdoc>
        ///     WM_EXITMENULOOP handler
        /// </devdoc>
        /// <internalonly/>
        private void WmExitMenuLoop(ref Message m) {
            OnMenuComplete(EventArgs.Empty);
            base.WndProc(ref m);
        }

        /// <devdoc>
        ///     WM_GETMINMAXINFO handler
        /// </devdoc>
        /// <internalonly/>
        private void WmGetMinMaxInfo(ref Message m) {
            
            Size minTrack = MinimumSize;
            Size maxTrack = MaximumSize;
            Rectangle maximizedBounds = MaximizedBounds;

            if (!minTrack.IsEmpty
                || !maxTrack.IsEmpty 
                || !maximizedBounds.IsEmpty
                || IsRestrictedWindow) {

                WmGetMinMaxInfoHelper(ref m, minTrack, maxTrack, maximizedBounds);
            }
            if (IsMdiChild) {
                base.WndProc(ref m);
                return;
            }
        }

        // PERFTRACK : ChrisAn, 2/22/2000 - Refer to MINMAXINFO in a separate method
        //           : to avoid loading the class in the common case.
        //
        private void WmGetMinMaxInfoHelper(ref Message m, Size minTrack, Size maxTrack, Rectangle maximizedBounds) {
            NativeMethods.MINMAXINFO mmi = (NativeMethods.MINMAXINFO)m.GetLParam(typeof(NativeMethods.MINMAXINFO));

            if (!minTrack.IsEmpty) {
            
                // Windows appears to freak out when the minimum size is greater than the screen dimensions, so
                // clip these dimensions here.
                //
                Screen screen = Screen.FromControl(this);
                if (minTrack.Width > screen.Bounds.Width) {
                    minTrack.Width = screen.Bounds.Width;
                }
                if (minTrack.Height > screen.Bounds.Height) {
                    minTrack.Height = screen.Bounds.Height;
                }
            
                mmi.ptMinTrackSize.x = minTrack.Width;
                mmi.ptMinTrackSize.y = minTrack.Height;
            }
            if (!maxTrack.IsEmpty) {
                mmi.ptMaxTrackSize.x = maxTrack.Width;
                mmi.ptMaxTrackSize.y = maxTrack.Height;
            }
            if (!maximizedBounds.IsEmpty && !IsRestrictedWindow) {
                mmi.ptMaxPosition.x = maximizedBounds.X;
                mmi.ptMaxPosition.y = maximizedBounds.Y;
                mmi.ptMaxSize.x = maximizedBounds.Width;
                mmi.ptMaxSize.y = maximizedBounds.Height;
            }

            if (IsRestrictedWindow) {
                mmi.ptMinTrackSize.x = Math.Max(mmi.ptMinTrackSize.x, 100);
                mmi.ptMinTrackSize.y = Math.Max(mmi.ptMinTrackSize.y, SystemInformation.CaptionButtonSize.Height * 3);
            }
            
            Marshal.StructureToPtr(mmi, m.LParam, true);
            m.Result = IntPtr.Zero;
        }
        /// <devdoc>
        ///     WM_INITMENUPOPUP handler
        /// </devdoc>
        /// <internalonly/>
        private void WmInitMenuPopup(ref Message m) {

            MainMenu curMenu = (MainMenu)Properties.GetObject(PropCurMenu);
            if (curMenu != null) {

                if (RightToLeft == RightToLeft.Yes) {
                    curMenu.UpdateRtl();
                }
                if (curMenu.ProcessInitMenuPopup(m.WParam))
                    return;
            }
            base.WndProc(ref m);
        }

        /// <devdoc>
        ///     Handles the WM_MENUCHAR message
        /// </devdoc>
        /// <internalonly/>
        private void WmMenuChar(ref Message m) {
            MainMenu curMenu = (MainMenu)Properties.GetObject(PropCurMenu);
            if (curMenu == null) {
                // KB article Q92527 tells us to forward these to our parent...
                //
                Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
                if (formMdiParent != null && formMdiParent.Menu != null) {
                    UnsafeNativeMethods.PostMessage(new HandleRef(formMdiParent, formMdiParent.Handle), NativeMethods.WM_SYSCOMMAND, new IntPtr(NativeMethods.SC_KEYMENU), m.WParam);
                    m.Result = (IntPtr)NativeMethods.Util.MAKELONG(0, 1);
                    return;
                }
            }
            if (curMenu != null) {
                curMenu.WmMenuChar(ref m);
                if (m.Result != IntPtr.Zero) {
                    // This char is a mnemonic on our menu.
                    return;
                }
            }

            base.WndProc(ref m);
        }

        /// <devdoc>
        ///     WM_MDIACTIVATE handler
        /// </devdoc>
        /// <internalonly/>
        private void WmMdiActivate(ref Message m) {
            Form form;

            base.WndProc(ref m);
            Debug.Assert(Properties.GetObject(PropFormMdiParent) != null, "how is formMdiParent null?");
            Debug.Assert(IsHandleCreated, "how is handle 0?");

            if (Handle == m.LParam) {
                form = this;
            }
            else {
                Control ctl = Control.FromHandleInternal(m.LParam);
                form = (ctl is Form) ? (Form)ctl : null;
            }

            Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
            formMdiParent.ActivateMdiChild(form);
        }

        void WmNcButtonDown(ref Message m) {
            if (IsMdiChild) {
                Form formMdiParent = (Form)Properties.GetObject(PropFormMdiParent);
                if (formMdiParent.ActiveMdiChild == this) {
                    if (ActiveControl != null && !ActiveControl.Focused) {
                        ActiveControl.FocusInternal();
                    }
                }
            }
            base.WndProc(ref m);
        }
        
        /// <devdoc>
        ///     WM_NCDESTROY handler
        /// </devdoc>
        /// <internalonly/>
        private void WmNCDestroy(ref Message m) {
            MainMenu mainMenu   = Menu;
            MainMenu dummyMenu  = (MainMenu)Properties.GetObject(PropDummyMenu);
            MainMenu curMenu    = (MainMenu)Properties.GetObject(PropCurMenu);
            MainMenu mergedMenu = (MainMenu)Properties.GetObject(PropMergedMenu);
            
            if (mainMenu != null) {
                mainMenu.ClearHandles();
            }
            if (curMenu != null) {
                curMenu.ClearHandles();
            }
            if (mergedMenu != null) {
                mergedMenu.ClearHandles();
            }
            if (dummyMenu != null) {
                dummyMenu.ClearHandles();
            }
            
            base.WndProc(ref m);
            
            if (Modal && dialogResult == DialogResult.None) {
                DialogResult = DialogResult.Cancel;
            }
        }

        /// <devdoc>
        ///     WM_NCHITTEST handler
        /// </devdoc>
        /// <internalonly/>
        private void WmNCHitTest(ref Message m) {
            bool callBase = true;

            if (formState[FormStateRenderSizeGrip] != 0) {
                int x = NativeMethods.Util.LOWORD(m.LParam);
                int y = NativeMethods.Util.HIWORD(m.LParam);

                Rectangle bounds = Bounds;
                if (x >= bounds.X + bounds.Width - SizeGripSize
                    && x <= bounds.X + bounds.Width
                    && y >= bounds.Y + bounds.Height - SizeGripSize
                    && y <= bounds.Y + bounds.Height) {

                    m.Result = (IntPtr)NativeMethods.HTBOTTOMRIGHT;
                    callBase = false;
                }
            }

            if (callBase) {
                base.WndProc(ref m);
            }
        }

        /// <devdoc>
        ///     WM_SHOWWINDOW handler
        /// </devdoc>
        /// <internalonly/>
        private void WmShowWindow(ref Message m) {
            formState[FormStateSWCalled] = 1;
            base.WndProc(ref m);
        }


        /// <devdoc>
        ///     WM_SYSCOMMAND handler
        /// </devdoc>
        /// <internalonly/>
        private void WmSysCommand(ref Message m) {
            bool callDefault = true;

            int sc = ((int)m.WParam & 0xFFF0);

            switch (sc) {
                case NativeMethods.SC_CLOSE:
                case NativeMethods.SC_KEYMENU:
                    if (IsMdiChild && !ControlBox) {
                        callDefault = false;
                    }
                    break;
            }

            if (Command.DispatchID((int)m.WParam & 0xFFFF)) {
                callDefault = false;
            }

            if (callDefault) {

                base.WndProc(ref m);
            }
        }

        /// <devdoc>
        ///     WM_SIZE handler
        /// </devdoc>
        /// <internalonly/>
        private void WmSize(ref Message m) {
            // If this is an MDI parent, don't pass WM_SIZE to the default
            // window proc. We handle resizing the MDIClient window ourselves
            // (using ControlDock.FILL).
            //
            if (ctlClient == null) {
                base.WndProc(ref m);
            }
        }

        /// <devdoc>
        ///     WM_WINDOWPOSCHANGED handler
        /// </devdoc>
        /// <internalonly/>
        private void WmWindowPosChanged(ref Message m) {

            // V#40654 - We must update the windowState, because resize is fired
            //           from here... (in Control)
            UpdateWindowState();
            base.WndProc(ref m);

            RestoreWindowBoundsIfNecessary();
        }

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.WndProc"]/*' />
        /// <devdoc>
        ///     Base wndProc encapsulation.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_NCACTIVATE:
                    if (IsRestrictedWindow) {
                        BeginInvoke(new MethodInvoker(RestrictedProcessNcActivate));
                    }
                    base.WndProc(ref m);
                    break;
                case NativeMethods.WM_NCLBUTTONDOWN:
                case NativeMethods.WM_NCRBUTTONDOWN:
                case NativeMethods.WM_NCMBUTTONDOWN:
                case NativeMethods.WM_NCXBUTTONDOWN:
                    WmNcButtonDown(ref m);
                    break;
                case NativeMethods.WM_ACTIVATE:
                    WmActivate(ref m);
                    break;
                case NativeMethods.WM_MDIACTIVATE:
                    WmMdiActivate(ref m);
                    break;
                case NativeMethods.WM_CLOSE:
                case NativeMethods.WM_QUERYENDSESSION:
                case NativeMethods.WM_ENDSESSION:
                    WmClose(ref m);
                    break;
                case NativeMethods.WM_CREATE:
                    WmCreate(ref m);
                    break;
                case NativeMethods.WM_ERASEBKGND:
                    WmEraseBkgnd(ref m);
                    break;

                case NativeMethods.WM_INITMENUPOPUP:
                    WmInitMenuPopup(ref m);
                    break;
                case NativeMethods.WM_MENUCHAR:
                    WmMenuChar(ref m);
                    break;
                case NativeMethods.WM_NCDESTROY:
                    WmNCDestroy(ref m);
                    break;
                case NativeMethods.WM_NCHITTEST:
                    WmNCHitTest(ref m);
                    break;
                case NativeMethods.WM_SHOWWINDOW:
                    WmShowWindow(ref m);
                    break;
                case NativeMethods.WM_SIZE:
                    WmSize(ref m);
                    break;
                case NativeMethods.WM_SYSCOMMAND:
                    WmSysCommand(ref m);
                    break;
                case NativeMethods.WM_GETMINMAXINFO:
                    WmGetMinMaxInfo(ref m);
                    break;
                case NativeMethods.WM_WINDOWPOSCHANGED:
                    WmWindowPosChanged(ref m);
                    break;
            case NativeMethods.WM_ENTERMENULOOP:
                    WmEnterMenuLoop(ref m);
                    break;
                case NativeMethods.WM_EXITMENULOOP:
                    WmExitMenuLoop(ref m);
                    break;
                case NativeMethods.WM_CAPTURECHANGED:
                    base.WndProc(ref m);
                    // This is a work-around for the Win32 scroll bar; it
                    // doesn't release it's capture in response to a CAPTURECHANGED
                    // message, so we force capture away if no button is down.
                    //
                    if (Capture && MouseButtons == (MouseButtons)0) {
                        CaptureInternal = false;
                    }
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

#if SECURITY_DIALOG
        class SecurityMenuItem : ICommandExecutor {
            Form owner;
            Command cmd;

            public SecurityMenuItem(Form owner) {
                this.owner = owner;
                cmd = new Command(this);
            }

            public int ID {
                get {
                    return cmd.ID;
                }
            }

            [
                ReflectionPermission(SecurityAction.Assert, TypeInformation=true, MemberAccess=true),
                UIPermission(SecurityAction.Assert, Window=UIPermissionWindow.AllWindows),
                EnvironmentPermission(SecurityAction.Assert, Unrestricted=true),
                FileIOPermission(SecurityAction.Assert, Unrestricted=true),
                SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode),
            ] 
            void ICommandExecutor.Execute() {
                Form information = (Form)Activator.CreateInstance(GetType().Module.Assembly.GetType("System.Windows.Forms.SysInfoForm"), new object[] {owner.IsRestrictedWindow});
                information.ShowDialog();
            }
        }
#endif

        /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ControlCollection"]/*' />
        /// <devdoc>
        ///    <para>Represents a collection of controls on the form.</para>
        /// </devdoc>
        public new class ControlCollection : Control.ControlCollection {

            private Form owner;

            /*C#r:protected*/

            /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ControlCollection.ControlCollection"]/*' />
            /// <devdoc>
            /// <para>Initializes a new instance of the ControlCollection class.</para>
            /// </devdoc>
            public ControlCollection(Form owner)
            : base(owner) {
                this.owner = owner;
            }

            /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ControlCollection.Add"]/*' />
            /// <devdoc>
            ///    <para> Adds a control
            ///       to the form.</para>
            /// </devdoc>
            public override void Add(Control value) {
                if (value is MdiClient && owner.ctlClient == null) {
                    if (!owner.TopLevel && !owner.DesignMode) {
                        throw new ArgumentException(SR.GetString(SR.MDIContainerMustBeTopLevel), "value");
                    }
                    owner.AutoScroll = false;
                    if (owner.IsMdiChild) {
                        throw new ArgumentException(SR.GetString(SR.FormMDIParentAndChild), "value");
                    }
                    owner.ctlClient = (MdiClient)value;
                }

                // make sure we don't add a form that has a valid mdi parent
                //
                if (value is Form && ((Form)value).MdiParentInternal != null) {
                    throw new ArgumentException(SR.GetString(SR.FormMDIParentCannotAdd), "value");
                }

                base.Add(value);

                if (owner.ctlClient != null) {
                    owner.ctlClient.SendToBack();
                }                                
            }

            /// <include file='doc\Form.uex' path='docs/doc[@for="Form.ControlCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para> 
            ///       Removes a control from the form.</para>
            /// </devdoc>
            public override void Remove(Control value) {
                if (value == owner.ctlClient) {
                    owner.ctlClient = null;
                }
                base.Remove(value);
            }
        }

        class SecurityToolTip : IDisposable {
            Form owner;
            string toolTipText;
            bool first = true;
            ToolTipNativeWindow window;

            internal SecurityToolTip(Form owner) {
                this.owner = owner;
                this.toolTipText = SR.GetString(SR.SecurityToolTipText);
                window = new ToolTipNativeWindow(this);
                SetupToolTip();
                owner.LocationChanged += new EventHandler(FormLocationChanged);
                owner.HandleCreated += new EventHandler(FormHandleCreated);
            }

            CreateParams CreateParams {
                get {
                    NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                    icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
                    SafeNativeMethods.InitCommonControlsEx(icc);

                    CreateParams cp = new CreateParams();
                    cp.Parent = owner.Handle;
                    cp.ClassName = NativeMethods.TOOLTIPS_CLASS;
                    cp.Style |= NativeMethods.TTS_ALWAYSTIP | NativeMethods.TTS_BALLOON;
                    cp.ExStyle = 0;
                    cp.Caption = null;
                    return cp;
                }
            }

            public bool Modal {
                get {
                    return first;
                }
            }

            public void Dispose() {
                if (owner != null) {
                    owner.LocationChanged -= new EventHandler(FormLocationChanged);
                }
                if (window.Handle != IntPtr.Zero) {
                    window.DestroyHandle();
                    window = null;
                }
            }

            private NativeMethods.TOOLINFO_T GetTOOLINFO() {
                NativeMethods.TOOLINFO_T toolInfo;
                toolInfo = new NativeMethods.TOOLINFO_T();
                toolInfo.cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
                toolInfo.uFlags |= NativeMethods.TTF_SUBCLASS;
                toolInfo.lpszText = this.toolTipText;
                if (owner.RightToLeft == RightToLeft.Yes) {
                    toolInfo.uFlags |= NativeMethods.TTF_RTLREADING;
                }
                if (!first) {
                    toolInfo.uFlags |= NativeMethods.TTF_TRANSPARENT;
                    toolInfo.hwnd = owner.Handle;
                    Size s = SystemInformation.CaptionButtonSize;
                    Rectangle r = new Rectangle(owner.Left, owner.Top, s.Width, SystemInformation.CaptionHeight);
                    r = owner.RectangleToClient(r);
                    r.Width -= r.X;
                    r.Y += 1;
                    toolInfo.rect = NativeMethods.RECT.FromXYWH(r.X, r.Y, r.Width, r.Height);
                    toolInfo.uId = IntPtr.Zero;
                }
                else {
                    toolInfo.uFlags |= NativeMethods.TTF_IDISHWND | NativeMethods.TTF_TRACK;
                    toolInfo.hwnd = IntPtr.Zero;
                    toolInfo.uId = owner.Handle;
                }
                return toolInfo;
            }

            private void SetupToolTip() {
               window.CreateHandle(CreateParams);

               SafeNativeMethods.SetWindowPos(new HandleRef(window, window.Handle), NativeMethods.HWND_TOPMOST,
                                  0, 0, 0, 0,
                                  NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE |
                                  NativeMethods.SWP_NOACTIVATE); 

               UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, owner.Width);

               UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_SETTITLE, NativeMethods.TTI_WARNING, SR.GetString(SR.SecurityToolTipCaption));


               if (0 == (int)UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_ADDTOOL, 0, GetTOOLINFO())) {
                     Debug.Fail("TTM_ADDTOOL failed for security tip");
               }

               UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_ACTIVATE, 1, 0);
               if (first) {
                   Size s = SystemInformation.CaptionButtonSize;
                   UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_TRACKPOSITION, 0, NativeMethods.Util.MAKELONG(owner.Left + s.Width / 2, owner.Top + SystemInformation.CaptionHeight));
                   UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_TRACKACTIVATE, 1, GetTOOLINFO());
               }
            }

            private void RecreateHandle() {
                if (window.Handle != IntPtr.Zero) {
                    window.DestroyHandle();
                }
                SetupToolTip();
            }

            private void FormHandleCreated(object sender, EventArgs e) {
                RecreateHandle();
            }

            private void FormLocationChanged(object sender, EventArgs e) {
                if (window != null && first) {
                    Size s = SystemInformation.CaptionButtonSize;

                    if (owner.WindowState == FormWindowState.Minimized) {
                        Pop();
                    }
                    else {
                        UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_TRACKPOSITION, 0, NativeMethods.Util.MAKELONG(owner.Left + s.Width / 2, owner.Top + SystemInformation.CaptionHeight));
                    }
                }
                else {
                    Pop();
                }
            }

            internal void Pop() {
                first = false;
                UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_TRACKACTIVATE, 0, GetTOOLINFO());
                UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_DELTOOL, 0, GetTOOLINFO());
                UnsafeNativeMethods.SendMessage(new HandleRef(window, window.Handle), NativeMethods.TTM_ADDTOOL, 0, GetTOOLINFO());
            }

            private void WndProc(ref Message msg) {
                if (first) {
                    if (msg.Msg == NativeMethods.WM_LBUTTONDOWN
                        || msg.Msg == NativeMethods.WM_RBUTTONDOWN
                        || msg.Msg == NativeMethods.WM_MBUTTONDOWN
                        || msg.Msg == NativeMethods.WM_XBUTTONDOWN) {

                        Pop();
                    }
                }
                window.DefWndProc(ref msg);
            }
    
            private class ToolTipNativeWindow : NativeWindow {
                SecurityToolTip control;
    
                internal ToolTipNativeWindow(SecurityToolTip control) {
                    this.control = control;
                }
                protected override void WndProc(ref Message m) {
                    if (control != null) {
                        control.WndProc(ref m);
                    }
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\invalidateevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="InvalidateEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\InvalidateEvent.uex' path='docs/doc[@for="InvalidateEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.Invalidate'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class InvalidateEventArgs : EventArgs {

        /// <include file='doc\InvalidateEvent.uex' path='docs/doc[@for="InvalidateEventArgs.invalidRect"]/*' />
        /// <devdoc>
        ///     Rectangle that bounds the window area which has been invalidated.
        /// </devdoc>
        private readonly Rectangle invalidRect;

        /// <include file='doc\InvalidateEvent.uex' path='docs/doc[@for="InvalidateEventArgs.InvalidateEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.InvalidateEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public InvalidateEventArgs(Rectangle invalidRect) {
            this.invalidRect = invalidRect;
        }

        /// <include file='doc\InvalidateEvent.uex' path='docs/doc[@for="InvalidateEventArgs.InvalidRect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating the <see cref='System.Drawing.Rectangle'/>
        ///       that contains the invalidated window area.
        ///    </para>
        /// </devdoc>
        public Rectangle InvalidRect {
            get {
                return invalidRect;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\inputlanguagecollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="InputLanguageCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.Windows.Forms {
    using System;
    using System.Collections;
    
    
    /// <include file='doc\InputLanguageCollection.uex' path='docs/doc[@for="InputLanguageCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.Windows.Forms.InputLanguage'/> objects.
    ///    </para>
    /// </devdoc>
    public class InputLanguageCollection : ReadOnlyCollectionBase {
        
        /// <include file='doc\InputLanguageCollection.uex' path='docs/doc[@for="InputLanguageCollection.InputLanguageCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.Windows.Forms.InputLanguageCollection'/> containing any array of <see cref='System.Windows.Forms.InputLanguage'/> objects.
        ///    </para>
        /// </devdoc>
        internal InputLanguageCollection(InputLanguage[] value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\InputLanguageCollection.uex' path='docs/doc[@for="InputLanguageCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.Windows.Forms.InputLanguage'/>.</para>
        /// </devdoc>
        public InputLanguage this[int index] {
            get {
                return ((InputLanguage)(InnerList[index]));
            }
        }
        
        /// <include file='doc\InputLanguageCollection.uex' path='docs/doc[@for="InputLanguageCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.Windows.Forms.InputLanguageCollection'/> contains the specified <see cref='System.Windows.Forms.InputLanguage'/>.</para>
        /// </devdoc>
        public bool Contains(InputLanguage value) {
            return InnerList.Contains(value);
        }
        
        /// <include file='doc\InputLanguageCollection.uex' path='docs/doc[@for="InputLanguageCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.Windows.Forms.InputLanguageCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(InputLanguage[] array, int index) {
            InnerList.CopyTo(array, index);
        }
        
        /// <include file='doc\InputLanguageCollection.uex' path='docs/doc[@for="InputLanguageCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.Windows.Forms.InputLanguage'/> in 
        ///       the <see cref='System.Windows.Forms.InputLanguageCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(InputLanguage value) {
            return InnerList.IndexOf(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemactivation.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemActivation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\ItemActivation.uex' path='docs/doc[@for="ItemActivation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how the user activates items and the appearance
    ///       of items as the mouse cursor moves over them.
    ///
    ///    </para>
    /// </devdoc>
    public enum ItemActivation {

        /// <include file='doc\ItemActivation.uex' path='docs/doc[@for="ItemActivation.Standard"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Activate items with a double-click.
        ///       Items do not change appearance.
        ///
        ///    </para>
        /// </devdoc>
        Standard = 0,

        /// <include file='doc\ItemActivation.uex' path='docs/doc[@for="ItemActivation.OneClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Activate
        ///       items with a single click. The cursor changes shape and the item
        ///       text changes color.
        ///
        ///    </para>
        /// </devdoc>
        OneClick = 1,

        /// <include file='doc\ItemActivation.uex' path='docs/doc[@for="ItemActivation.TwoClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Activate items with a
        ///       double click. The item text changes color.
        ///
        ///    </para>
        /// </devdoc>
        TwoClick = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    
    /// <include file='doc\ItemChangedEventHandler.uex' path='docs/doc[@for="ItemChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void ItemChangedEventHandler(object sender, ItemChangedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemboundsportion.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemBoundsPortion.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\ItemBoundsPortion.uex' path='docs/doc[@for="ItemBoundsPortion"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the display bounds of a ListItem.
    ///    </para>
    /// </devdoc>
    public enum ItemBoundsPortion {

        /// <include file='doc\ItemBoundsPortion.uex' path='docs/doc[@for="ItemBoundsPortion.Entire"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both the icon and label
        ///       portions. In Report View, this includes subitems.
        ///
        ///    </para>
        /// </devdoc>
        Entire = NativeMethods.LVIR_BOUNDS,

        /// <include file='doc\ItemBoundsPortion.uex' path='docs/doc[@for="ItemBoundsPortion.Icon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Only the icon portion.
        ///    </para>
        /// </devdoc>
        Icon = NativeMethods.LVIR_ICON,

        /// <include file='doc\ItemBoundsPortion.uex' path='docs/doc[@for="ItemBoundsPortion.Label"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Only the label portion.
        ///    </para>
        /// </devdoc>
        Label = NativeMethods.LVIR_LABEL,

        /// <include file='doc\ItemBoundsPortion.uex' path='docs/doc[@for="ItemBoundsPortion.ItemOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both the icon and label portions. In Report view, this
        ///       does not include subitems. In all other views, this is the same as
        ///    <see langword='Entire'/>
        ///    .
        /// </para>
        /// </devdoc>
        ItemOnly = NativeMethods.LVIR_SELECTBOUNDS,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemcheckeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemCheckEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\ItemCheckEventHandler.uex' path='docs/doc[@for="ItemCheckEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will
    ///       handle the <see langword='ItemCheck'/> event of a
    ///    <see cref='System.Windows.Forms.CheckedListBox'/> or 
    ///    <see cref='System.Windows.Forms.ListView'/>.
    ///       
    ///    </para>
    /// </devdoc>
    public delegate void ItemCheckEventHandler(object sender, ItemCheckEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemdragevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemDragEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ItemDragEvent.uex' path='docs/doc[@for="ItemDragEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.ListView.OnItemDrag'/> event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ItemDragEventArgs : EventArgs {
        readonly MouseButtons button;
        readonly object item;

        /// <include file='doc\ItemDragEvent.uex' path='docs/doc[@for="ItemDragEventArgs.ItemDragEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ItemDragEventArgs(MouseButtons button) {
            this.button = button;
            this.item = null;
        }
        
        /// <include file='doc\ItemDragEvent.uex' path='docs/doc[@for="ItemDragEventArgs.ItemDragEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ItemDragEventArgs(MouseButtons button, object item) {
            this.button = button;
            this.item = item;
        }
        
        /// <include file='doc\ItemDragEvent.uex' path='docs/doc[@for="ItemDragEventArgs.Button"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MouseButtons Button {
            get { return button; }
        }

        /// <include file='doc\ItemDragEvent.uex' path='docs/doc[@for="ItemDragEventArgs.Item"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Item {
            get { return item; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemchangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    
    using System;

    /// <include file='doc\ItemChangedEventArgs.uex' path='docs/doc[@for="ItemChangedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ItemChangedEventArgs : EventArgs {

        private int index;    
    
        internal ItemChangedEventArgs(int index) {
            this.index = index;
        }

        /// <include file='doc\ItemChangedEventArgs.uex' path='docs/doc[@for="ItemChangedEventArgs.Index"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Index {
            get {
                return index;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemcheckevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemCheckEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\ItemCheckEvent.uex' path='docs/doc[@for="ItemCheckEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.CheckedListBox.ItemCheck'/>
    ///       event.
    ///
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ItemCheckEventArgs : EventArgs {

        readonly int index;
        CheckState newValue;
        readonly CheckState currentValue;

        /// <include file='doc\ItemCheckEvent.uex' path='docs/doc[@for="ItemCheckEventArgs.ItemCheckEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ItemCheckEventArgs(int index, CheckState newCheckValue, CheckState currentValue) {
            this.index = index;
            this.newValue = newCheckValue;
            this.currentValue = currentValue;
        }
        /// <include file='doc\ItemCheckEvent.uex' path='docs/doc[@for="ItemCheckEventArgs.Index"]/*' />
        /// <devdoc>
        ///     The index of the item that is about to change.
        /// </devdoc>
        public int Index {
            get { return index; }
        }

        /// <include file='doc\ItemCheckEvent.uex' path='docs/doc[@for="ItemCheckEventArgs.NewValue"]/*' />
        /// <devdoc>
        ///     The proposed new value of the CheckBox.
        /// </devdoc>
        public CheckState NewValue {
            get { return newValue; }
            set { newValue = value; }
        }

        /// <include file='doc\ItemCheckEvent.uex' path='docs/doc[@for="ItemCheckEventArgs.CurrentValue"]/*' />
        /// <devdoc>
        ///     The current state of the CheckBox.
        /// </devdoc>
        public CheckState CurrentValue {
            get { return currentValue; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\itemdrageventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemDragEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\ItemDragEventHandler.uex' path='docs/doc[@for="ItemDragEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.ListView.OnItemDrag'/>
    ///       
    ///       event of a
    ///    <see cref='System.Windows.Forms.ListView'/> 
    ///    .
    ///    
    /// </para>
    /// </devdoc>
    public delegate void ItemDragEventHandler(object sender, ItemDragEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\iwin32window.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWin32window.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\IWin32window.uex' path='docs/doc[@for="IWin32Window"]/*' />
    /// <devdoc>
    ///    <para>Provides an interface to expose Win32 HWND handles.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComImport(), System.Runtime.InteropServices.Guid("458AB8A2-A1EA-4d7b-8EBE-DEE5D3D9442C"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IWin32Window {
    
        /// <include file='doc\IWin32window.uex' path='docs/doc[@for="IWin32Window.Handle"]/*' />
        /// <devdoc>
        ///    <para>Gets the handle to the window represented by the implementor.</para>
        /// </devdoc>
        IntPtr Handle { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\keyevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="KeyEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.KeyDown'/> or <see cref='System.Windows.Forms.Control.KeyUp'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class KeyEventArgs : EventArgs {

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.keyData"]/*' />
        /// <devdoc>
        ///     Contains key data for KeyDown and KeyUp events.  This is a combination
        ///     of keycode and modifer flags.
        /// </devdoc>
        private readonly Keys keyData;

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.handled"]/*' />
        /// <devdoc>
        ///     Determines if this event has been handled by a handler.  If handled, the
        ///     key event will not be sent along to Windows.  If not handled, the event
        ///     will be sent to Windows for default processing.
        /// </devdoc>
        private bool handled;

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.KeyEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new
        ///       instance of the <see cref='System.Windows.Forms.KeyEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public KeyEventArgs(Keys keyData) {
            this.keyData = keyData;
        }

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.Alt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the ALT key was pressed.
        ///    </para>
        /// </devdoc>
        public virtual bool Alt {
            get {
                return (keyData & Keys.Alt) == Keys.Alt;
            }
        }

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.Control"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the CTRL key was pressed.
        ///    </para>
        /// </devdoc>
        public bool Control {
            get {
                return (keyData & Keys.Control) == Keys.Control;
            }
        }

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.Handled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the event was handled.
        ///    </para>
        /// </devdoc>
        //
        public bool Handled {
            get {
                return handled;
            }
            set {
                handled = value;
            }
        }
        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.KeyCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the keyboard code for a <see cref='System.Windows.Forms.Control.KeyDown'/> or <see cref='System.Windows.Forms.Control.KeyUp'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        //subhag : changed the behaviour of the KeyCode as per the new requirements.
        public Keys KeyCode {
            get {
                Keys keyGenerated =  keyData & Keys.KeyCode;
                if (!Enum.IsDefined(typeof(Keys),(int)keyGenerated))
                    return Keys.None;
                else
                    return keyGenerated;
            }
        }

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.KeyValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the keyboard value for a <see cref='System.Windows.Forms.Control.KeyDown'/> or <see cref='System.Windows.Forms.Control.KeyUp'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        //subhag : added the KeyValue as per the new requirements.
        public int KeyValue {
            get {
                return (int)(keyData & Keys.KeyCode);
            }
        }
       
        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.KeyData"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the key data for a <see cref='System.Windows.Forms.Control.KeyDown'/> or <see cref='System.Windows.Forms.Control.KeyUp'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        public Keys KeyData {
            get {
                return keyData;
            }
        }

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.Modifiers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the modifier flags for a <see cref='System.Windows.Forms.Control.KeyDown'/> or <see cref='System.Windows.Forms.Control.KeyUp'/> event.
        ///       This indicates which modifier keys (CTRL, SHIFT, and/or ALT) were pressed.
        ///    </para>
        /// </devdoc>
        public Keys Modifiers {
            get {
                return keyData & Keys.Modifiers;
            }
        }

        /// <include file='doc\KeyEvent.uex' path='docs/doc[@for="KeyEventArgs.Shift"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether the SHIFT key was pressed.
        ///    </para>
        /// </devdoc>
        public virtual bool Shift {
            get {
                return (keyData & Keys.Shift) == Keys.Shift;
            }
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\iwindowtarget.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWindowTarget.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\IWindowTarget.uex' path='docs/doc[@for="IWindowTarget"]/*' />
    /// <devdoc>
    ///      This interface defines the communication layer between
    ///      a Control object and the Win32 API.  Each Control object
    ///      has an internal implementation this interface that is called
    ///      by the Win32 window.
    /// </devdoc>
    /// <internalonly/>
    public interface IWindowTarget {

        /// <include file='doc\IWindowTarget.uex' path='docs/doc[@for="IWindowTarget.OnHandleChange"]/*' />
        /// <devdoc>
        ///      Called when the window handle of the control has changed.
        /// </devdoc>
        void OnHandleChange(IntPtr newHandle);

        /// <include file='doc\IWindowTarget.uex' path='docs/doc[@for="IWindowTarget.OnMessage"]/*' />
        /// <devdoc>
        ///      Called to do control-specific processing for this window.
        /// </devdoc>
        void OnMessage(ref Message m);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\keyeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="KeyEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\KeyEventHandler.uex' path='docs/doc[@for="KeyEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a method that will handle the <see cref='System.Windows.Forms.Control.KeyUp'/> or <see cref='System.Windows.Forms.Control.KeyDown'/> event of a <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void KeyEventHandler(object sender, KeyEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\keypresseventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="KeyPressEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\KeyPressEventHandler.uex' path='docs/doc[@for="KeyPressEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a method that will handle the <see cref='System.Windows.Forms.Control.KeyPress'/> event of a
    ///    <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void KeyPressEventHandler(object sender, KeyPressEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\keypressevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="KeyPressEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\KeyPressEvent.uex' path='docs/doc[@for="KeyPressEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.KeyPress'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class KeyPressEventArgs : EventArgs {

        /// <include file='doc\KeyPressEvent.uex' path='docs/doc[@for="KeyPressEventArgs.keyChar"]/*' />
        /// <devdoc>
        ///     Contains the character of the current KeyPress event.
        /// </devdoc>
        private readonly char keyChar;

        /// <include file='doc\KeyPressEvent.uex' path='docs/doc[@for="KeyPressEventArgs.handled"]/*' />
        /// <devdoc>
        ///     Determines if this event has been handled by a handler.  If handled, the
        ///     key event will not be sent along to Windows.  If not handled, the event
        ///     will be sent to Windows for default processing.
        /// </devdoc>
        private bool handled;

        /// <include file='doc\KeyPressEvent.uex' path='docs/doc[@for="KeyPressEventArgs.KeyPressEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new
        ///       instance of the <see cref='System.Windows.Forms.KeyPressEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public KeyPressEventArgs(char keyChar) {
            this.keyChar = keyChar;
        }

        /// <include file='doc\KeyPressEvent.uex' path='docs/doc[@for="KeyPressEventArgs.KeyChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the character corresponding to the key
        ///       pressed.
        ///    </para>
        /// </devdoc>
        public char KeyChar {
            get {
                return keyChar;
            }
        }

        /// <include file='doc\KeyPressEvent.uex' path='docs/doc[@for="KeyPressEventArgs.Handled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the <see cref='System.Windows.Forms.Control.KeyPress'/>
        ///       event was handled.
        ///    </para>
        /// </devdoc>
        public bool Handled {
            get {
                return handled;
            }
            set {
                handled = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\keys.cs ===
//------------------------------------------------------------------------------
// <copyright file="Keys.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using System.Windows.Forms;
    using Hashtable = System.Collections.Hashtable;
    using Microsoft.Win32;

    /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies key codes and modifiers.
    ///    </para>
    /// </devdoc>
    [
    Flags,
    TypeConverterAttribute(typeof(KeysConverter))
    ]
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum Keys {
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.KeyCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The bit mask to extract a key code from a key value.
        ///       
        ///    </para>
        /// </devdoc>
        KeyCode = 0x0000FFFF,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Modifiers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The bit mask to extract modifiers from a key value.
        ///       
        ///    </para>
        /// </devdoc>
        Modifiers = unchecked((int)0xFFFF0000),

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No key pressed.
        ///    </para>
        /// </devdoc>
        None           = 0x00,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The left mouse button.
        ///       
        ///    </para>
        /// </devdoc>
        LButton        = 0x01,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.RButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The right mouse button.
        ///    </para>
        /// </devdoc>
        RButton        = 0x02,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Cancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CANCEL key.
        ///    </para>
        /// </devdoc>
        Cancel         = 0x03,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.MButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The middle mouse button (three-button mouse).
        ///    </para>
        /// </devdoc>
        MButton        = 0x04,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.XButton1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first x mouse button (five-button mouse).
        ///    </para>
        /// </devdoc>
        XButton1       = 0x05,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.XButton2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The second x mouse button (five-button mouse).
        ///    </para>
        /// </devdoc>
        XButton2       = 0x06,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Back"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The BACKSPACE key.
        ///    </para>
        /// </devdoc>
        Back           = 0x08,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Tab"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The TAB key.
        ///    </para>
        /// </devdoc>
        Tab            = 0x09,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LineFeed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CLEAR key.
        ///    </para>
        /// </devdoc>
        LineFeed       = 0x0A,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CLEAR key.
        ///    </para>
        /// </devdoc>
        Clear          = 0x0C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Return"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The RETURN key.
        ///
        ///    </para>
        /// </devdoc>
        Return         = 0x0D,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Enter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ENTER key.
        ///       
        ///    </para>
        /// </devdoc>
        Enter          = Return,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.ShiftKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The SHIFT key.
        ///    </para>
        /// </devdoc>
        ShiftKey      = 0x10,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.ControlKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CTRL key.
        ///    </para>
        /// </devdoc>
        ControlKey    = 0x11,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Menu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ALT key.
        ///    </para>
        /// </devdoc>
        Menu           = 0x12,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Pause"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PAUSE key.
        ///    </para>
        /// </devdoc>
        Pause          = 0x13,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Capital"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CAPS LOCK key.
        ///
        ///    </para>
        /// </devdoc>
        Capital        = 0x14,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.CapsLock"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CAPS LOCK key.
        ///    </para>
        /// </devdoc>
        CapsLock       = 0x14,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Escape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ESC key.
        ///    </para>
        /// </devdoc>
        Escape         = 0x1B,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Space"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The SPACEBAR key.
        ///    </para>
        /// </devdoc>
        Space          = 0x20,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Prior"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PAGE UP key.
        ///    </para>
        /// </devdoc>
        Prior          = 0x21,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.PageUp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PAGE UP key.
        ///    </para>
        /// </devdoc>
        PageUp         = Prior,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Next"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PAGE DOWN key.
        ///    </para>
        /// </devdoc>
        Next           = 0x22,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.PageDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PAGE DOWN key.
        ///    </para>
        /// </devdoc>
        PageDown       = Next,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.End"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The END key.
        ///    </para>
        /// </devdoc>
        End            = 0x23,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Home"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The HOME key.
        ///    </para>
        /// </devdoc>
        Home           = 0x24,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The LEFT ARROW key.
        ///    </para>
        /// </devdoc>
        Left           = 0x25,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Up"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The UP ARROW key.
        ///    </para>
        /// </devdoc>
        Up             = 0x26,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The RIGHT ARROW key.
        ///    </para>
        /// </devdoc>
        Right          = 0x27,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Down"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The DOWN ARROW key.
        ///    </para>
        /// </devdoc>
        Down           = 0x28,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The SELECT key.
        ///    </para>
        /// </devdoc>
        Select         = 0x29,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Print"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PRINT key.
        ///    </para>
        /// </devdoc>
        Print          = 0x2A,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Execute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The EXECUTE key.
        ///    </para>
        /// </devdoc>
        Execute        = 0x2B,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Snapshot"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PRINT SCREEN key.
        ///
        ///    </para>
        /// </devdoc>
        Snapshot       = 0x2C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.PrintScreen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PRINT SCREEN key.
        ///    </para>
        /// </devdoc>
        PrintScreen    = Snapshot,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Insert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The INS key.
        ///    </para>
        /// </devdoc>
        Insert         = 0x2D,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Delete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The DEL key.
        ///    </para>
        /// </devdoc>
        Delete         = 0x2E,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Help"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The HELP key.
        ///    </para>
        /// </devdoc>
        Help           = 0x2F,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D0"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 0 key.
        ///    </para>
        /// </devdoc>
        D0             = 0x30, // 0
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 1 key.
        ///    </para>
        /// </devdoc>
        D1             = 0x31, // 1
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 2 key.
        ///    </para>
        /// </devdoc>
        D2             = 0x32, // 2
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 3 key.
        ///    </para>
        /// </devdoc>
        D3             = 0x33, // 3
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 4 key.
        ///    </para>
        /// </devdoc>
        D4             = 0x34, // 4
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 5 key.
        ///    </para>
        /// </devdoc>
        D5             = 0x35, // 5
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 6 key.
        ///    </para>
        /// </devdoc>
        D6             = 0x36, // 6
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 7 key.
        ///    </para>
        /// </devdoc>
        D7             = 0x37, // 7
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 8 key.
        ///    </para>
        /// </devdoc>
        D8             = 0x38, // 8
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 9 key.
        ///    </para>
        /// </devdoc>
        D9             = 0x39, // 9

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.A"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The A key.
        ///    </para>
        /// </devdoc>
        A              = 0x41,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.B"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The B key.
        ///    </para>
        /// </devdoc>
        B              = 0x42,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.C"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The C key.
        ///    </para>
        /// </devdoc>
        C              = 0x43,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.D"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The D key.
        ///    </para>
        /// </devdoc>
        D              = 0x44,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.E"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The E key.
        ///    </para>
        /// </devdoc>
        E              = 0x45,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F key.
        ///    </para>
        /// </devdoc>
        F              = 0x46,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.G"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The G key.
        ///    </para>
        /// </devdoc>
        G              = 0x47,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.H"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The H key.
        ///    </para>
        /// </devdoc>
        H              = 0x48,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.I"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The I key.
        ///    </para>
        /// </devdoc>
        I              = 0x49,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.J"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The J key.
        ///    </para>
        /// </devdoc>
        J              = 0x4A,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.K"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The K key.
        ///    </para>
        /// </devdoc>
        K              = 0x4B,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.L"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The L key.
        ///    </para>
        /// </devdoc>
        L              = 0x4C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.M"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The M key.
        ///    </para>
        /// </devdoc>
        M              = 0x4D,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.N"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The N key.
        ///    </para>
        /// </devdoc>
        N              = 0x4E,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.O"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The O key.
        ///    </para>
        /// </devdoc>
        O              = 0x4F,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.P"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The P key.
        ///    </para>
        /// </devdoc>
        P              = 0x50,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Q"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Q key.
        ///    </para>
        /// </devdoc>
        Q              = 0x51,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.R"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The R key.
        ///    </para>
        /// </devdoc>
        R              = 0x52,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.S"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The S key.
        ///    </para>
        /// </devdoc>
        S              = 0x53,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.T"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The T key.
        ///    </para>
        /// </devdoc>
        T              = 0x54,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.U"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The U key.
        ///    </para>
        /// </devdoc>
        U              = 0x55,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.V"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The V key.
        ///    </para>
        /// </devdoc>
        V              = 0x56,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.W"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The W key.
        ///    </para>
        /// </devdoc>
        W              = 0x57,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The X key.
        ///    </para>
        /// </devdoc>
        X              = 0x58,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Y key.
        ///    </para>
        /// </devdoc>
        Y              = 0x59,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Z"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Z key.
        ///    </para>
        /// </devdoc>
        Z              = 0x5A,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LWin"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The left Windows logo key (Microsoft Natural Keyboard).
        ///    </para>
        /// </devdoc>
        LWin           = 0x5B,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.RWin"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The right Windows logo key (Microsoft Natural Keyboard).
        ///    </para>
        /// </devdoc>
        RWin           = 0x5C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Apps"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Application key (Microsoft Natural Keyboard).
        ///    </para>
        /// </devdoc>
        Apps           = 0x5D,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad0"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 0
        ///       key on the numeric keypad.
        ///       
        ///    </para>
        /// </devdoc>
        NumPad0        = 0x60,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 1 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad1        = 0x61,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 2 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad2        = 0x62,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 3 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad3        = 0x63,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 4 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad4        = 0x64,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 5 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad5        = 0x65,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 6 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad6        = 0x66,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 7 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad7        = 0x67,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 8 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad8        = 0x68,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumPad9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The 9 key on the numeric keypad.
        ///    </para>
        /// </devdoc>
        NumPad9        = 0x69,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Multiply"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Multiply key.
        ///    </para>
        /// </devdoc>
        Multiply       = 0x6A,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Add key.
        ///    </para>
        /// </devdoc>
        Add            = 0x6B,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Separator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Separator key.
        ///    </para>
        /// </devdoc>
        Separator      = 0x6C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Subtract"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Subtract key.
        ///    </para>
        /// </devdoc>
        Subtract       = 0x6D,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Decimal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Decimal key.
        ///       
        ///    </para>
        /// </devdoc>
        Decimal        = 0x6E,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Divide"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Divide key.
        ///    </para>
        /// </devdoc>
        Divide         = 0x6F,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F1 key.
        ///    </para>
        /// </devdoc>
        F1             = 0x70,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F2 key.
        ///    </para>
        /// </devdoc>
        F2             = 0x71,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F3 key.
        ///    </para>
        /// </devdoc>
        F3             = 0x72,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F4 key.
        ///    </para>
        /// </devdoc>
        F4             = 0x73,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F5 key.
        ///    </para>
        /// </devdoc>
        F5             = 0x74,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F6 key.
        ///    </para>
        /// </devdoc>
        F6             = 0x75,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F7 key.
        ///    </para>
        /// </devdoc>
        F7             = 0x76,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F8 key.
        ///    </para>
        /// </devdoc>
        F8             = 0x77,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F9 key.
        ///    </para>
        /// </devdoc>
        F9             = 0x78,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F10 key.
        ///    </para>
        /// </devdoc>
        F10            = 0x79,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F11 key.
        ///    </para>
        /// </devdoc>
        F11            = 0x7A,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F12 key.
        ///    </para>
        /// </devdoc>
        F12            = 0x7B,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F13"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F13 key.
        ///    </para>
        /// </devdoc>
        F13            = 0x7C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F14"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F14 key.
        ///    </para>
        /// </devdoc>
        F14            = 0x7D,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F15"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F15 key.
        ///    </para>
        /// </devdoc>
        F15            = 0x7E,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F16"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F16 key.
        ///    </para>
        /// </devdoc>
        F16            = 0x7F,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F17"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F17 key.
        ///    </para>
        /// </devdoc>
        F17            = 0x80,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F18"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F18 key.
        ///    </para>
        /// </devdoc>
        F18            = 0x81,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F19"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F19 key.
        ///    </para>
        /// </devdoc>
        F19            = 0x82,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F20"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F20 key.
        ///    </para>
        /// </devdoc>
        F20            = 0x83,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F21"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F21 key.
        ///    </para>
        /// </devdoc>
        F21            = 0x84,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F22"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F22 key.
        ///    </para>
        /// </devdoc>
        F22            = 0x85,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F23"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F23 key.
        ///    </para>
        /// </devdoc>
        F23            = 0x86,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.F24"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The F24 key.
        ///    </para>
        /// </devdoc>
        F24            = 0x87,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NumLock"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The NUM LOCK key.
        ///    </para>
        /// </devdoc>
        NumLock        = 0x90,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Scroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The SCROLL LOCK key.
        ///    </para>
        /// </devdoc>
        Scroll         = 0x91,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LShiftKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The left SHIFT key.
        ///    </para>
        /// </devdoc>
        LShiftKey     = 0xA0,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.RShiftKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The right SHIFT key.
        ///    </para>
        /// </devdoc>
        RShiftKey     = 0xA1,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LControlKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The left CTRL key.
        ///    </para>
        /// </devdoc>
        LControlKey   = 0xA2,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.RControlKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The right CTRL key.
        ///    </para>
        /// </devdoc>
        RControlKey   = 0xA3,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The left ALT key.
        ///    </para>
        /// </devdoc>
        LMenu          = 0xA4,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.RMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The right ALT key.
        ///    </para>
        /// </devdoc>
        RMenu          = 0xA5,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.ProcessKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PROCESS KEY key.
        ///    </para>
        /// </devdoc>
        ProcessKey     = 0xE5,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Attn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ATTN key.
        ///    </para>
        /// </devdoc>
        Attn           = 0xF6,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Crsel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CRSEL key.
        ///    </para>
        /// </devdoc>
        Crsel          = 0xF7,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Exsel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The EXSEL key.
        ///    </para>
        /// </devdoc>
        Exsel          = 0xF8,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.EraseEof"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ERASE EOF key.
        ///    </para>
        /// </devdoc>
        EraseEof          = 0xF9,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Play"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PLAY key.
        ///    </para>
        /// </devdoc>
        Play           = 0xFA,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Zoom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ZOOM key.
        ///    </para>
        /// </devdoc>
        Zoom           = 0xFB,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.NoName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A constant reserved for future use.
        ///    </para>
        /// </devdoc>
        NoName         = 0xFC,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Pa1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The PA1 key.
        ///    </para>
        /// </devdoc>
        Pa1            = 0xFD,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemClear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The CLEAR key.
        ///    </para>
        /// </devdoc>
        OemClear      = 0xFE,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Kana"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Kana mode key.
        ///    </para>
        /// </devdoc>
        KanaMode      = 0x15,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.HanguelMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Hanguel mode key.
        ///    </para>
        /// </devdoc>
        HanguelMode   = 0x15,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.HangulMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Hangul mode key.
        ///    </para>
        /// </devdoc>
        HangulMode    = 0x15,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.JunjaMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Junja mode key.
        ///    </para>
        /// </devdoc>
        JunjaMode     = 0x17,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.FinalMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Final mode key.
        ///    </para>
        /// </devdoc>
        FinalMode     = 0x18,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.HanjaMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Hanja mode key.
        ///    </para>
        /// </devdoc>
        HanjaMode     = 0x19,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.KanjiMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Kanji mode key.
        ///    </para>
        /// </devdoc>
        KanjiMode     = 0x19,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.IMEConvert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Convert key.
        ///    </para>
        /// </devdoc>
        IMEConvert    = 0x1C,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.IMENonconvert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME NonConvert key.
        ///    </para>
        /// </devdoc>
        IMENonconvert = 0x1D,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.IMEAceept"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Accept key.
        ///    </para>
        /// </devdoc>
        IMEAceept     = 0x1E,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.IMEModeChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The IME Mode change request.
        ///    </para>
        /// </devdoc>
        IMEModeChange = 0x1F,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserBack"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Back key.
        ///    </para>
        /// </devdoc>
        BrowserBack   = 0xA6,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserForward"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Forward key.
        ///    </para>
        /// </devdoc>
        BrowserForward= 0xA7,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserRefresh"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Refresh key.
        ///    </para>
        /// </devdoc>
        BrowserRefresh= 0xA8,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserStop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Stop key.
        ///    </para>
        /// </devdoc>
        BrowserStop   = 0xA9,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserSearch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Search key.
        ///    </para>
        /// </devdoc>
        BrowserSearch = 0xAA,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserFavorites"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Favorites key.
        ///    </para>
        /// </devdoc>
        BrowserFavorites = 0xAB,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.BrowserHome"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Browser Home key.
        ///    </para>
        /// </devdoc>
        BrowserHome   = 0xAC,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.VolumeMute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Volume Mute key.
        ///    </para>
        /// </devdoc>
        VolumeMute    = 0xAD,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.VolumeDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Volume Down key.
        ///    </para>
        /// </devdoc>
        VolumeDown    = 0xAE,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.VolumeUp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Volume Up key.
        ///    </para>
        /// </devdoc>
        VolumeUp      = 0xAF,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.MediaNextTrack"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Media Next Track key.
        ///    </para>
        /// </devdoc>
        MediaNextTrack = 0xB0,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.MediaPreviousTrack"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Media Previous Track key.
        ///    </para>
        /// </devdoc>
        MediaPreviousTrack = 0xB1,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.MediaStop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Media Stop key.
        ///    </para>
        /// </devdoc>
        MediaStop     = 0xB2,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.MediaPlayPause"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Media Play Pause key.
        ///    </para>
        /// </devdoc>
        MediaPlayPause = 0xB3,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LaunchMail"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Launch Mail key.
        ///    </para>
        /// </devdoc>
        LaunchMail    = 0xB4,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.SelectMedia"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Select Media key.
        ///    </para>
        /// </devdoc>
        SelectMedia   = 0xB5,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LaunchApplication1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Launch Application1 key.
        ///    </para>
        /// </devdoc>
        LaunchApplication1 = 0xB6,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.LaunchApplication2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Launch Application2 key.
        ///    </para>
        /// </devdoc>
        LaunchApplication2 = 0xB7,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemSemicolons"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Semicolon key.
        ///    </para>
        /// </devdoc>
        OemSemicolon  = 0xBA,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Oemplus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem plus key.
        ///    </para>
        /// </devdoc>
        Oemplus       = 0xBB,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Oemcomma"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem comma key.
        ///    </para>
        /// </devdoc>
        Oemcomma      = 0xBC,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemMinus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Minus key.
        ///    </para>
        /// </devdoc>
        OemMinus      = 0xBD,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemPeriod"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Period key.
        ///    </para>
        /// </devdoc>
        OemPeriod     = 0xBE,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemQuestion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Question key.
        ///    </para>
        /// </devdoc>
        OemQuestion   = 0xBF,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Oemtilde"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem tilde key.
        ///    </para>
        /// </devdoc>
        Oemtilde      = 0xC0,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemOpenBrackets"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Open Brackets key.
        ///    </para>
        /// </devdoc>
        OemOpenBrackets = 0xDB,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemPipe"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Pipe key.
        ///    </para>
        /// </devdoc>
        OemPipe       = 0xDC,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemCloseBrackets"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Close Brackets key.
        ///    </para>
        /// </devdoc>
        OemCloseBrackets = 0xDD,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemQuotes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Quotes key.
        ///    </para>
        /// </devdoc>
        OemQuotes     = 0xDE,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Oem8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem8 key.
        ///    </para>
        /// </devdoc>
        Oem8          = 0xDF,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.OemBackslash"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Oem Backslash key.
        ///    </para>
        /// </devdoc>
        OemBackslash  = 0xE2,

        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Shift"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The SHIFT modifier key.
        ///    </para>
        /// </devdoc>
        Shift   = 0x00010000,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Control"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       CTRL modifier key.
        ///
        ///    </para>
        /// </devdoc>
        Control = 0x00020000,
        /// <include file='doc\Keys.uex' path='docs/doc[@for="Keys.Alt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The ALT modifier key.
        ///
        ///    </para>
        /// </devdoc>
        Alt     = 0x00040000,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\label.cs ===
//------------------------------------------------------------------------------
// <copyright file="Label.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    
    using System;
    using System.Security.Permissions;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Drawing.Imaging;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization.Formatters;
    using Microsoft.Win32;

    /// <include file='doc\Label.uex' path='docs/doc[@for="Label"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Represents a standard Windows label. </para>
    /// </devdoc>
    [
    DefaultProperty("Text"),
    Designer("System.Windows.Forms.Design.LabelDesigner, " + AssemblyRef.SystemDesign)
    ]
    // If not for FormatControl, we could inherit from ButtonBase and get foreground images for free.
    public class Label : Control {

        private static readonly object EVENT_AUTOSIZECHANGED  = new object();
        private static readonly object EVENT_TEXTALIGNCHANGED = new object();

        private static readonly BitVector32.Section StateUseMnemonic = BitVector32.CreateSection(1);
        private static readonly BitVector32.Section StateAutoSize    = BitVector32.CreateSection(1, StateUseMnemonic);
        private static readonly BitVector32.Section StateAnimating   = BitVector32.CreateSection(1, StateAutoSize);
        private static readonly BitVector32.Section StateFlatStyle   = BitVector32.CreateSection((int)FlatStyle.System, StateAnimating);
        private static readonly BitVector32.Section StateBorderStyle = BitVector32.CreateSection((int)BorderStyle.Fixed3D, StateFlatStyle);

        private static readonly int PropImageList  = PropertyStore.CreateKey();
        private static readonly int PropImage      = PropertyStore.CreateKey();

        private static readonly int PropTextAlign  = PropertyStore.CreateKey();
        private static readonly int PropImageAlign = PropertyStore.CreateKey();
        private static readonly int PropImageIndex = PropertyStore.CreateKey();

        ///////////////////////////////////////////////////////////////////////
        // Label per instance members
        //
        // Note: Do not add anything to this list unless absolutely neccessary.
        //
        // Begin Members {

        // List of properties that are generally set, so we keep them directly on
        // Label.
        //

        BitVector32 labelState = new BitVector32();        
        int         requestedHeight;
        int         requestedWidth;
        short       prefWidthCache = -1;
        
        // } End Members
        ///////////////////////////////////////////////////////////////////////

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Label"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Label'/> class.      
        ///    </para>
        /// </devdoc>
        public Label()
        : base() {
            SetStyle(ControlStyles.UserPaint |
                     ControlStyles.SupportsTransparentBackColor |
                     ControlStyles.DoubleBuffer, OwnerDraw);
            
            SetStyle(ControlStyles.FixedHeight |    
                     ControlStyles.Selectable, false);

            SetStyle(ControlStyles.ResizeRedraw, true);
            
            labelState[StateFlatStyle]   = (int)FlatStyle.Standard;
            labelState[StateUseMnemonic] = 1;
            labelState[StateBorderStyle] = (int)BorderStyle.None;
            
            TabStop = false;
            
            requestedHeight = Height;
            requestedWidth = Width;
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.AutoSize"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the control is automatically resized
        ///       to fit its contents. </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        RefreshProperties(RefreshProperties.All),
        Localizable(true),
        SRDescription(SR.LabelAutoSizeDescr)
        ]
        public virtual bool AutoSize {
            get {
                return labelState[StateAutoSize] != 0;
            }

            set {
                if (AutoSize != value) {
                    labelState[StateAutoSize] = value ? 1 : 0;
                    SetStyle(ControlStyles.FixedHeight, value);
                    AdjustSize();
                    OnAutoSizeChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.AutoSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.LabelOnAutoSizeChangedDescr)]
        public event EventHandler AutoSizeChanged {
            add {
                Events.AddHandler(EVENT_AUTOSIZECHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_AUTOSIZECHANGED, value);
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.BackgroundImage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the image rendered on the background of the control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.LabelBackgroundImageDescr)
        ]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border style for the control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.None),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.LabelBorderDescr)
        ]
        public virtual BorderStyle BorderStyle {
            get {
                return (BorderStyle)labelState[StateBorderStyle];
            }
            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }

                if (BorderStyle != value) {
                    labelState[StateBorderStyle] = (int)value;
                    if (AutoSize) {
                        AdjustSize();
                    }
                    RecreateHandle();
                }
            }
        }
        
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overrides Control.  A Label is a Win32 STATIC control, which we setup here.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "STATIC";

                if (OwnerDraw) {
                    // An unfortunate side effect of this style is Windows sends us WM_DRAWITEM
                    // messages instead of WM_PAINT, but since Windows insists on repainting 
                    // *without* a WM_PAINT after SetWindowText, I don't see much choice.
                    cp.Style |= NativeMethods.SS_OWNERDRAW; 
                    
                    // Since we're owner draw, I don't see any point in setting the 
                    // SS_CENTER/SS_RIGHT styles.
                    //
                    cp.ExStyle &= ~NativeMethods.WS_EX_RIGHT;   // WS_EX_RIGHT overrides the SS_XXXX alignment styles
                }
                

                if (!OwnerDraw) {
                    switch(TextAlign) {
                        case ContentAlignment.TopLeft:
                        case ContentAlignment.MiddleLeft:
                        case ContentAlignment.BottomLeft:
                            cp.Style |= NativeMethods.SS_LEFT;
                            break;
    
                        case ContentAlignment.TopRight:
                        case ContentAlignment.MiddleRight:
                        case ContentAlignment.BottomRight:
                            cp.Style |= NativeMethods.SS_RIGHT;
                            break;
    
                        case ContentAlignment.TopCenter:
                        case ContentAlignment.MiddleCenter:
                        case ContentAlignment.BottomCenter:
                            cp.Style |= NativeMethods.SS_CENTER;
                            break;
                    }
                }
                else
                    cp.Style |= NativeMethods.SS_LEFT;
                
                switch (BorderStyle) {
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                    case BorderStyle.Fixed3D:
                        cp.Style |= NativeMethods.SS_SUNKEN;
                        break;
                }

                if (!UseMnemonic)
                    cp.Style |= NativeMethods.SS_NOPREFIX;

                return cp;
            }
        }
        
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(100, AutoSize ? PreferredHeight : 23);
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.FlatStyle"]/*' />
        [
            SRCategory(SR.CatAppearance),
            DefaultValue(FlatStyle.Standard),
            SRDescription(SR.ButtonFlatStyleDescr)
        ]
        public FlatStyle FlatStyle {
            get {
                return (FlatStyle)labelState[StateFlatStyle];
            }
            set {
                if (!Enum.IsDefined(typeof(FlatStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FlatStyle));
                }
                
                if (labelState[StateFlatStyle] != (int)value) {
                    bool needRecreate = (labelState[StateFlatStyle] == (int)FlatStyle.System) || (value == FlatStyle.System);
                    
                    labelState[StateFlatStyle] = (int)value;
                    
                    SetStyle(ControlStyles.UserPaint 
                             | ControlStyles.SupportsTransparentBackColor
                             | ControlStyles.DoubleBuffer, OwnerDraw);

                    if (needRecreate) {
                        RecreateHandle();
                    }
                    else {
                        Refresh();
                    }
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Image"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the image that is displayed on a <see cref='System.Windows.Forms.Label'/>.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.ButtonImageDescr),
        SRCategory(SR.CatAppearance)
        ]
        public Image Image {
            get {
                Image image = (Image)Properties.GetObject(PropImage);
            
                if (image == null && ImageList != null && ImageIndex >= 0) {
                    return ImageList.Images[ImageIndex];
                }
                else {
                    return image;
                }
            }
            set {
                if (Image != value) {
                    StopAnimate();

                    Properties.SetObject(PropImage, value);
                    if (value != null) {
                        ImageIndex = -1;
                        ImageList = null;
                    }

                    // Hook up the frame changed event
                    //
                    Animate();
                    Invalidate();
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ImageIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the index value of the images displayed on the
        ///    <see cref='System.Windows.Forms.Label'/>.
        ///    </para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(ImageIndexConverter)),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        DefaultValue(-1),
        Localizable(true),
        SRDescription(SR.ButtonImageIndexDescr),
        SRCategory(SR.CatAppearance)
        ]
        public int ImageIndex {
            get {
                bool found;
                int imageIndex = Properties.GetInteger(PropImageIndex, out found);
                if (found) {
                    if (ImageList != null) {
                        if (imageIndex >= ImageList.Images.Count) {
                            return ImageList.Images.Count - 1;
                        }
                        return imageIndex;
                    }
                }
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString(), "-1"));
                }
                if (ImageIndex != value) {
                    if (value != -1) {
                        // Image.set calls ImageIndex = -1
                        Properties.SetObject(PropImage, null);
                    }
                    Properties.SetInteger(PropImageIndex, value);
                    Invalidate();
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ImageList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the images displayed in a <see cref='System.Windows.Forms.Label'/>.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.ButtonImageListDescr),
        SRCategory(SR.CatAppearance)
        ]
        public ImageList ImageList {
            get {
                return (ImageList)Properties.GetObject(PropImageList);
            }
            set {
                if (ImageList != value) {
                
                    EventHandler recreateHandler = new EventHandler(ImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    // Remove the previous imagelist handle recreate handler
                    //
                    ImageList imageList = ImageList;
                    if (imageList != null) {
                        imageList.RecreateHandle -= recreateHandler;
                        imageList.Disposed -= disposedHandler;
                    }
                    
                    // Make sure we don't have an Image as well as an ImageList
                    //
                    if (value != null) {
                        Properties.SetObject(PropImage, null); // Image.set calls ImageList = null
                    }
                    
                    Properties.SetObject(PropImageList, value);
                    
                    // Add the new imagelist handle recreate handler
                    //
                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;
                    }
                    
                    Invalidate();
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ImageAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the alignment of the image on the <see cref='System.Windows.Forms.Label'/>.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(ContentAlignment.MiddleCenter),
        Localizable(true),
        SRDescription(SR.ButtonImageAlignDescr),
        SRCategory(SR.CatAppearance)
        ]
        public ContentAlignment ImageAlign {
            get {
                bool found;
                int imageAlign = Properties.GetInteger(PropImageAlign, out found);
                if (found) {
                    return (ContentAlignment)imageAlign;
                }
                return ContentAlignment.MiddleCenter;
            }
            set {
                if (!Enum.IsDefined(typeof(ContentAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ContentAlignment));
                }
                Properties.SetInteger(PropImageAlign, (int)value);
                Invalidate();
            }
        }

        private Rectangle ImageBounds {
            get {
                Image image = (Image)Properties.GetObject(PropImage);
                return CalcImageRenderBounds(image, ClientRectangle, RtlTranslateAlignment(ImageAlign));
            }
        }
        
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        internal virtual bool OwnerDraw {
            get {
                return FlatStyle != FlatStyle.System;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.PreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of the control (in pixels), assuming a
        ///       single line of text is displayed.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.LabelPreferredHeightDescr)
        ]

        public virtual int PreferredHeight {
            get {
                int result = FontHeight;
                
                //Always return the Fontheight + some buffer else the Text gets clipped for Autosize = true..
                //(bug 118909)
                if (BorderStyle != BorderStyle.None)
                {
                    result += 6; // count for border - Darwing ..
                }
                else
                    result += 3;
                
                    
                return result;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.PreferredWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the width of the control (in pixels), assuming a single line
        ///       of text is displayed.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.LabelPreferredWidthDescr)
        ]
        public virtual int PreferredWidth {
            get {
                // If we've already got a good value for this, just return that.
                if (prefWidthCache != -1) return prefWidthCache;

                // we don't - so recalc.

                string s = this.Text;
                if (s == "") {
                    prefWidthCache = 0;
                    return 0;
                }
                else {
                    Graphics g = this.CreateGraphicsInternal();

                    // Calculate the size of the label's text
                    //
                    StringFormat stringFormat = CreateStringFormat();
                    SizeF textSize = g.MeasureString(s, Font, new SizeF(0, 0), stringFormat);                    
                    stringFormat.Dispose();

                    // Make sure to round any numbers up, not down
                    //
                    prefWidthCache = (short) Math.Ceiling(textSize.Width);
                    g.Dispose();
                    if (BorderStyle != BorderStyle.None)
                        prefWidthCache += 2;
                        
                    return prefWidthCache;
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.RenderTransparent"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether
        ///       the container control background is rendered on the <see cref='System.Windows.Forms.Label'/>.</para>
        /// </devdoc>
        virtual new protected bool RenderTransparent {
            get {
                return((Control) this).RenderTransparent;
            }
            set {
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.TabStop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the user can tab to the
        ///    <see cref='System.Windows.Forms.Label'/>.
        ///    </para>
        /// </devdoc>
        [DefaultValue(false), Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.TextAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       horizontal alignment of the text in the control.
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.LabelTextAlignDescr),
        Localizable(true),
        DefaultValue(ContentAlignment.TopLeft),
        SRCategory(SR.CatAppearance)
        ]
        public virtual ContentAlignment TextAlign {
            get {
                bool found;
                int textAlign = Properties.GetInteger(PropTextAlign, out found);
                if (found) {
                    return (ContentAlignment)textAlign;
                }
                
                return ContentAlignment.TopLeft;
            }
            set {

                if (!Enum.IsDefined(typeof(ContentAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ContentAlignment));
                }

                if (TextAlign != value) {
                    Properties.SetInteger(PropTextAlign, (int)value);
                    Invalidate();
                    //Change the TextAlignment for SystemDrawn Labels ....
                    if (!OwnerDraw) {
                        RecreateHandle();
                    }
                    OnTextAlignChanged(EventArgs.Empty);

                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.TextAlignChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.LabelOnTextAlignChangedDescr)]
        public event EventHandler TextAlignChanged {
            add {
                Events.AddHandler(EVENT_TEXTALIGNCHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_TEXTALIGNCHANGED, value);
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.UseMnemonic"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether an ampersand (&amp;) included in the text of
        ///       the control.</para>
        /// </devdoc>
        [
        SRDescription(SR.LabelUseMnemonicDescr),
        DefaultValue(true),
        SRCategory(SR.CatAppearance)
        ]
        public bool UseMnemonic {
            get { 
                return labelState[StateUseMnemonic] != 0;
            }

            set {
                labelState[StateUseMnemonic] = value ? 1 : 0;
                RecreateHandle();
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.KeyUp"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyUp {
            add {
                base.KeyUp += value;
            }
            remove {
                base.KeyUp -= value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.KeyDown"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyDown {
            add {
                base.KeyDown += value;
            }
            remove {
                base.KeyDown -= value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.KeyPress"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyPressEventHandler KeyPress {
            add {
                base.KeyPress += value;
            }
            remove {
                base.KeyPress -= value;
            }
        }

        /// <devdoc>
        ///     Adjusts the height of the label control to match the height of
        ///     the control's font, and the width of the label to match the
        ///     width of the text it contains.
        /// </devdoc>
        /// <internalonly/>
        private void AdjustSize() {      
            // If we're anchored to two opposite sides of the form, don't adjust the size because
            // we'll lose our anchored size by resetting to the requested width.
            //
            if (!AutoSize && 
                 ((this.Anchor & (AnchorStyles.Left | AnchorStyles.Right)) == (AnchorStyles.Left | AnchorStyles.Right) ||
                  ((this.Anchor & (AnchorStyles.Top | AnchorStyles.Bottom)) == (AnchorStyles.Top | AnchorStyles.Bottom)))) {                
                return;
            }

            prefWidthCache = -1;

            int saveHeight = requestedHeight;
            int saveWidth = requestedWidth;
            try {
                Size = new Size(AutoSize ? PreferredWidth : saveWidth,
                                AutoSize ? PreferredHeight: saveHeight);
            }
            finally {
                requestedHeight = saveHeight;
                requestedWidth = saveWidth;
            }
        }

        internal void Animate() {
            Animate(Visible && Enabled && ParentInternal != null);
        }

        internal void StopAnimate() {
            Animate(false);
        }

        private void Animate(bool animate) {
            bool currentlyAnimating = labelState[StateAnimating] != 0;
            if (animate != currentlyAnimating) {
                Image image = (Image)Properties.GetObject(PropImage);
                if (animate) {
                    if (image != null) {
                        ImageAnimator.Animate(image, new EventHandler(this.OnFrameChanged));
                        labelState[StateAnimating] = animate ? 1 : 0;
                    }
                }
                else {
                    if (image != null) {
                        ImageAnimator.StopAnimate(image, new EventHandler(this.OnFrameChanged));
                        labelState[StateAnimating] = animate ? 1 : 0;
                    }
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.CalcImageRenderBounds"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Rectangle CalcImageRenderBounds(Image image, Rectangle r, ContentAlignment align) {

            ContentAlignment anyRight  = ContentAlignment.TopRight | ContentAlignment.MiddleRight | ContentAlignment.BottomRight;
            ContentAlignment anyTop    = ContentAlignment.TopLeft | ContentAlignment.TopCenter | ContentAlignment.TopRight;
            ContentAlignment anyBottom = ContentAlignment.BottomLeft | ContentAlignment.BottomCenter | ContentAlignment.BottomRight;
            ContentAlignment anyCenter = ContentAlignment.TopCenter | ContentAlignment.MiddleCenter | ContentAlignment.BottomCenter;

            Size pointImageSize = image.Size;

            int xLoc = r.X + 2;
            int yLoc = r.Y + 2;

            if ((align & anyRight) !=0) {
                xLoc = (r.X+r.Width - 4)-pointImageSize.Width;
            }
            else if ((align & anyCenter) != 0) {
                xLoc = r.X + (r.Width - pointImageSize.Width)/2;
            }


            if ((align & anyBottom) != 0) {
                yLoc = (r.Y+r.Height - 4)-pointImageSize.Height;
            }
            else if ((align & anyTop) != 0) {
                yLoc = r.Y + 2;
            }
            else {
                yLoc = r.Y + (r.Height - pointImageSize.Height)/2;
            }

            return new Rectangle(xLoc, yLoc, pointImageSize.Width, pointImageSize.Height);
        }


        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.CreateAccessibilityInstance"]/*' />
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new LabelAccessibleObject(this);
        }

        private StringFormat CreateStringFormat() {
            StringFormat stringFormat = ControlPaint.StringFormatForAlignment(TextAlign);

            // Adjust string format for Rtl controls
            if (RightToLeft == RightToLeft.Yes) {
                stringFormat.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
            }

            if (!UseMnemonic) {
                stringFormat.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;
            }
            else if (ShowKeyboardCues) {
                stringFormat.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Show;
            }
            else {
                stringFormat.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Hide;
            }
            if (AutoSize) {
                stringFormat.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;
            }

            return stringFormat;
        }

        private void DetachImageList(object sender, EventArgs e) {
            ImageList = null;
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                StopAnimate();
                if (ImageList != null) {
                    ImageList.Disposed -= new EventHandler(this.DetachImageList);
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.DrawImage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws an <see cref='System.Drawing.Image'/> within the specified bounds.
        ///    </para>
        /// </devdoc>
        protected void DrawImage(System.Drawing.Graphics g, Image image, Rectangle r, ContentAlignment align) {
            Rectangle loc = CalcImageRenderBounds(image, r, align);

            if (!Enabled) {
                ControlPaint.DrawImageDisabled(g, image, loc.X, loc.Y, BackColor);
            }
            else {
                g.DrawImage(image, loc.X, loc.Y, image.Width, image.Height);
            }
        }
        
        private void ImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated) {
                Invalidate();
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnAutoSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnAutoSizeChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_AUTOSIZECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }
        
        private void OnFrameChanged(object o, EventArgs e) {
            if (IsWindowObscured) {
                StopAnimate();
                return;
            }
            Invalidate();  
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            prefWidthCache = -1;
            AdjustSize();
            Invalidate();
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnTextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnTextChanged(EventArgs e) {
            base.OnTextChanged(e);
            prefWidthCache = -1;
            AdjustSize();
            Invalidate();
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnTextAlignChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnTextAlignChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_TEXTALIGNCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnPaint"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnPaint(PaintEventArgs e) {
            Animate();

            ImageAnimator.UpdateFrames();
            Image i = this.Image;
            if (i != null) {
                DrawImage(e.Graphics, i, ClientRectangle, RtlTranslateAlignment(ImageAlign));
            }

            Color color = e.Graphics.GetNearestColor((Enabled) ? ForeColor : DisabledColor);

            // Do actual drawing
            StringFormat stringFormat = CreateStringFormat();
            if (Enabled) {
                using (Brush brush = new SolidBrush(color)) {
                    e.Graphics.DrawString(Text, Font, brush, this.ClientRectangle, stringFormat);
                }
            }
            else {
                ControlPaint.DrawStringDisabled(e.Graphics, Text, Font, color,
                                                this.ClientRectangle,
                                                stringFormat);
            }
            stringFormat.Dispose();

            base.OnPaint(e); // raise paint event
        }
        
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnEnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnEnabledChanged(EventArgs e) {
            base.OnEnabledChanged(e);
            Animate();
        }


        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnParentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnParentChanged(EventArgs e) {
            base.OnParentChanged(e);
            Animate();
        }
        
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.OnVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnVisibleChanged(EventArgs e) {
            base.OnVisibleChanged(e);
            Animate();
        }


        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ProcessMnemonic"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Overrides Control. This is called when the user has pressed an Alt-CHAR
        ///       key combination and determines if that combination is an interesting
        ///       mnemonic for this control.
        ///    </para>
        /// </devdoc>
        protected override bool ProcessMnemonic(char charCode) {
            if (UseMnemonic && IsMnemonic(charCode, Text) && CanProcessMnemonic()) {
                Control parent = ParentInternal;
                if (parent != null) {
                    IntSecurity.ModifyFocus.Assert();
                    try {
                        if (parent.SelectNextControl(this, true, false, true, false)) {
                            if (!parent.ContainsFocus) {
                                parent.Focus();
                            }
                        }
                    }
                    finally {
                        System.Security.CodeAccessPermission.RevertAssert();
                    }
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.SetBoundsCore"]/*' />
        /// <devdoc>
        ///    Overrides Control.setBoundsCore to enforce autoSize.
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            if ((specified & BoundsSpecified.Height) != BoundsSpecified.None)
                requestedHeight = height;
            if ((specified & BoundsSpecified.Width) != BoundsSpecified.None)
                requestedWidth = width;
            Rectangle oldBounds = Bounds;
            if (AutoSize && height != oldBounds.Height) height = PreferredHeight;
            if (AutoSize && width != oldBounds.Width) width = PreferredWidth;
            base.SetBoundsCore(x, y, width, height, specified);
        }

        private void ResetImage() {
            Image = null;
        }

        private bool ShouldSerializeImage() {
            return Properties.GetObject(PropImage) != null;
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.ToString"]/*' />
        /// <devdoc>
        ///    Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            string s = base.ToString();
            return s + ", Text: " + Text;
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.WndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Overrides Control. This processes certain messages that the Win32 STATIC
        ///       class would normally override.
        ///    </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_NCHITTEST:
                    // label returns HT_TRANSPARENT for everything, so all messages get
                    // routed to the parent.  Change this so we can tell what's going on.
                    //
                    if (ParentInternal != null) {
                        Point pt = ParentInternal.PointToClientInternal(new Point((int)m.LParam));
                        m.Result = (IntPtr)((Bounds.Contains(pt) ? NativeMethods.HTCLIENT : NativeMethods.HTNOWHERE));
                    }
                    else {
                        base.WndProc(ref m);
                    }
                    break;

                    // NT4 and Windows 95 STATIC controls don't properly handle WM_PRINTCLIENT
                case NativeMethods.WM_PRINTCLIENT:
                    SendMessage(NativeMethods.WM_PAINT, m.WParam, IntPtr.Zero);
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }
        
        [System.Runtime.InteropServices.ComVisible(true)]
        internal class LabelAccessibleObject : ControlAccessibleObject {
            
            public LabelAccessibleObject(Label owner) : base(owner) {
            }
            
            public override string Name {
                get {
                    string name = Owner.AccessibleName;
                    if (name != null) {
                        return name;
                    }
                    
                    return ((Label)Owner).TextWithoutMnemonics;
                }
                set {
                    base.Name = value;
                }
            }            
            
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.StaticText;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\labelediteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="LabelEditEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\LabelEditEventHandler.uex' path='docs/doc[@for="LabelEditEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.ListView.LabelEdit'/> event of a
    ///    <see cref='System.Windows.Forms.ListView'/> 
    ///    .
    /// </para>
    /// </devdoc>
    public delegate void LabelEditEventHandler(object sender, LabelEditEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\labeleditevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="LabelEditEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\LabelEditEvent.uex' path='docs/doc[@for="LabelEditEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.ListView.LabelEdit'/> event.
    ///    </para>
    /// </devdoc>
    public class LabelEditEventArgs : EventArgs {
        private readonly string label;
        private readonly int item;
        private bool cancelEdit = false;

        /// <include file='doc\LabelEditEvent.uex' path='docs/doc[@for="LabelEditEventArgs.LabelEditEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance
        ///       of the <see cref='System.Windows.Forms.LabelEditEventArgs'/> class with the specified
        ///       index to the <see cref='System.Windows.Forms.ListViewItem'/> to edit.
        ///    </para>
        /// </devdoc>
        public LabelEditEventArgs(int item) {
            this.item = item;
            this.label = null;
        }

        /// <include file='doc\LabelEditEvent.uex' path='docs/doc[@for="LabelEditEventArgs.LabelEditEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance
        ///       of the <see cref='System.Windows.Forms.LabelEditEventArgs'/> class with the specified index to the <see cref='System.Windows.Forms.ListViewItem'/> being
        ///       edited and the new text for the label of the <see cref='System.Windows.Forms.ListViewItem'/>.
        ///    </para>
        /// </devdoc>
        public LabelEditEventArgs(int item, string label) {
            this.item = item;
            this.label = label;
        }

        /// <include file='doc\LabelEditEvent.uex' path='docs/doc[@for="LabelEditEventArgs.Label"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the new text assigned to the label of the <see cref='System.Windows.Forms.ListViewItem'/>.
        ///    </para>
        /// </devdoc>
        public string Label {
            get {
                return label;
            }
        }

        /// <include file='doc\LabelEditEvent.uex' path='docs/doc[@for="LabelEditEventArgs.Item"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the zero-based index of the <see cref='System.Windows.Forms.ListViewItem'/> containing the label to
        ///       edit.
        ///    </para>
        /// </devdoc>
        public int Item {
            get {
                return item;
            }
        }

        /// <include file='doc\LabelEditEvent.uex' path='docs/doc[@for="LabelEditEventArgs.CancelEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether changes made to the label of
        ///       the <see cref='System.Windows.Forms.ListViewItem'/> should be canceled.
        ///    </para>
        /// </devdoc>
        public bool CancelEdit {
            get {
                return cancelEdit;
            }
            set {
                cancelEdit = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\leftrightalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="LeftRightAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\LeftRightAlignment.uex' path='docs/doc[@for="LeftRightAlignment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies whether an object or text is aligned to
    ///       the left or
    ///       right of a reference point.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum LeftRightAlignment {

        /// <include file='doc\LeftRightAlignment.uex' path='docs/doc[@for="LeftRightAlignment.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or
        ///       text is aligned to the left of the reference
        ///       point.
        ///    </para>
        /// </devdoc>
        Left = 0,

        /// <include file='doc\LeftRightAlignment.uex' path='docs/doc[@for="LeftRightAlignment.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is aligned to the right of the reference point.
        ///    </para>
        /// </devdoc>
        Right = 1,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\layoutevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="LayoutEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\LayoutEvent.uex' path='docs/doc[@for="LayoutEventArgs"]/*' />
    /// <devdoc>
    /// </devdoc>
    public sealed class LayoutEventArgs : EventArgs {
        private readonly Control affectedControl;
        private readonly string affectedProperty;

        /// <include file='doc\LayoutEvent.uex' path='docs/doc[@for="LayoutEventArgs.LayoutEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public LayoutEventArgs(Control affectedControl, string affectedProperty) {
            this.affectedControl = affectedControl;
            this.affectedProperty = affectedProperty;
        }

        /// <include file='doc\LayoutEvent.uex' path='docs/doc[@for="LayoutEventArgs.AffectedControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Control AffectedControl {
            get {
                return affectedControl;
            }
        }

        /// <include file='doc\LayoutEvent.uex' path='docs/doc[@for="LayoutEventArgs.AffectedProperty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string AffectedProperty {
            get {
                return affectedProperty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\keysconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="KeysConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Text;
    using Microsoft.Win32;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Drawing;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.Windows.Forms.Keys'/> objects to and from various 
    ///    other representations.</para>
    /// </devdoc>
    public class KeysConverter : TypeConverter, IComparer {
        private IDictionary keyNames;
        private StandardValuesCollection values;
    
        private const Keys FirstDigit = System.Windows.Forms.Keys.D0;
        private const Keys LastDigit = System.Windows.Forms.Keys.D9;
        private const Keys FirstAscii = System.Windows.Forms.Keys.A;
        private const Keys LastAscii = System.Windows.Forms.Keys.Z;
        private const Keys FirstNumpadDigit = System.Windows.Forms.Keys.NumPad0;
        private const Keys LastNumpadDigit = System.Windows.Forms.Keys.NumPad9;
        
        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.KeyNames"]/*' />
        /// <devdoc>
        ///  Access to a lookup table of name/value pairs for keys.  These are localized
        ///  names.
        /// </devdoc>
        private IDictionary KeyNames {
            get {
                if (keyNames == null) {
                    keyNames = new Hashtable(34, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                    keyNames[SR.GetString(SR.toStringControl)] = Keys.Control;
                    keyNames[SR.GetString(SR.toStringShift)] = Keys.Shift;
                    keyNames[SR.GetString(SR.toStringAlt)] = Keys.Alt;
                    keyNames[SR.GetString(SR.toStringBack)] = Keys.Back;
                    keyNames[SR.GetString(SR.toStringInsert)] = Keys.Insert;
                    keyNames[SR.GetString(SR.toStringDelete)] = Keys.Delete;
                    keyNames[SR.GetString(SR.toStringHome)] = Keys.Home;
                    keyNames[SR.GetString(SR.toStringEnd)] = Keys.End;
                    keyNames[SR.GetString(SR.toStringPageUp)] = Keys.Prior;
                    keyNames[SR.GetString(SR.toStringPageDown)] = Keys.Next;
                    keyNames[SR.GetString(SR.toStringEnter)] = Keys.Return;
                    keyNames["F1"] = Keys.F1;
                    keyNames["F2"] = Keys.F2;
                    keyNames["F3"] = Keys.F3;
                    keyNames["F4"] = Keys.F4;
                    keyNames["F5"] = Keys.F5;
                    keyNames["F6"] = Keys.F6;
                    keyNames["F7"] = Keys.F7;
                    keyNames["F8"] = Keys.F8;
                    keyNames["F9"] = Keys.F9;
                    keyNames["F10"] = Keys.F10;
                    keyNames["F11"] = Keys.F11;
                    keyNames["F12"] = Keys.F12;
                }
                return keyNames;
            }
        }
    
        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.CanConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Determines if this converter can convert an object in the given source
        ///    type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.Compare"]/*' />
        /// <devdoc>
        ///    <para>Compares two key values for equivalence.</para>
        /// </devdoc>
        public int Compare(object a, object b) {
            return String.Compare(ConvertToString(a), ConvertToString(b), false, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
        
            if (value is string) {
            
                string text = ((string)value).Trim();
            
                if (text.Length == 0) {
                    return null;
                }
                else {
                
                    // Parse an array of key tokens.
                    //
                    string[] tokens = text.Split(new char[] {'+'});
                    for (int i = 0; i < tokens.Length; i++) {
                        tokens[i] = tokens[i].Trim();
                    }
                    
                    // Now lookup each key token in our key hashtable.
                    //
                    Keys key = (Keys)0;
                    bool foundKeyCode = false;
                    
                    for (int i = 0; i < tokens.Length; i++) {
                        object obj = KeyNames[tokens[i]];
                        
                        if (obj == null) {
                        
                            // Key was not found in our table.  See if it is a valid value in
                            // the Keys enum.
                            //
                            obj = Enum.Parse(typeof(Keys), tokens[i]);
                        }
                        
                        if (obj != null) {
                            Keys currentKey = (Keys)obj;
                            
                            if ((currentKey & Keys.KeyCode) != 0) {
                            
                                // We found a match.  If we have previously found a
                                // key code, then check to see that this guy
                                // isn't a key code (it is illegal to have, say,
                                // "A + B"
                                //
                                if (foundKeyCode) {
                                    throw new FormatException(SR.GetString(SR.KeysConverterInvalidKeyCombination));
                                }
                                foundKeyCode = true;
                            }
                            
                            // Now OR the key into our current key
                            //
                            key |= currentKey;
                        }
                        else {
                        
                            // We did not match this key.  Report this as an error too.
                            //
                            throw new FormatException(SR.GetString(SR.KeysConverterInvalidKeyName, tokens[i]));
                            
                        }
                    }
                    
                    return (object)key;
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Converts the given object to another type.  The most common types to convert
        ///    are to and from a string object.  The default implementation will make a call
        ///    to ToString on the object if the object is valid and if the destination
        ///    type is string.  If this cannot convert to the desitnation type, this will
        ///    throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && (value is Keys || value is int)) {
                Keys key = (Keys)value;
                StringBuilder caption = new StringBuilder(32);
                bool added = false;
                
                Keys modifiers = (key & Keys.Modifiers);
                
                IDictionaryEnumerator keyNames = KeyNames.GetEnumerator();
                
                // First, iterate through and do the modifiers. These are
                // additive, so we support things like Ctrl + Alt
                //
                while(keyNames.MoveNext()) {
                    if (((int)((Keys)keyNames.Value) & (int)modifiers) != 0) {
                        
                        if (added) {
                            caption.Append("+");
                        }
                            
                        caption.Append((string)keyNames.Key);
                        added = true;
                    }
                }
    
                // Now reset and do the key values.  Here, we quit if
                // we find a match.
                //
                keyNames.Reset();
                Keys keyOnly = (key & Keys.KeyCode);
                bool foundKey = false;
                
                if (added) {
                    caption.Append("+");
                }
                
                while(keyNames.MoveNext()) {
                    if (((Keys)keyNames.Value).Equals(keyOnly)) {
                        caption.Append((string)keyNames.Key);
                        added = true;
                        foundKey = true;
                        break;
                    }
                }
                
                // Finally, if the key wasn't in our list, add it to 
                // the end anyway.  Here we just pull the key value out
                // of the enum.
                //
                if (!foundKey && Enum.IsDefined(typeof(Keys), (int)keyOnly)) {
                    caption.Append(((Enum)keyOnly).ToString());
                }
                return caption.ToString();
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Retrieves a collection containing a set of standard values
        ///    for the data type this validator is designed for.  This
        ///    will return null if the data type does not support a
        ///    standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                ArrayList list = new ArrayList();
                
                ICollection keys = KeyNames.Values;
                
                foreach (object o in keys) {
                    list.Add(o);
                }
                
                list.Sort(this);
                
                values = new StandardValuesCollection(list.ToArray());
            }
            return values;
        }
    
        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Determines if the list of standard values returned from
        ///    GetStandardValues is an exclusive list.  If the list
        ///    is exclusive, then no other values are valid, such as
        ///    in an enum data type.  If the list is not exclusive,
        ///    then there are other valid values besides the list of
        ///    standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }
        
        /// <include file='doc\KeysConverter.uex' path='docs/doc[@for="KeysConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Determines if this object supports a standard set of values
        ///    that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\layouteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="LayoutEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\LayoutEventHandler.uex' path='docs/doc[@for="LayoutEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void LayoutEventHandler(object sender, LayoutEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linkbehavior.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkBehavior.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\LinkBehavior.uex' path='docs/doc[@for="LinkBehavior"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum LinkBehavior {
        /// <include file='doc\LinkBehavior.uex' path='docs/doc[@for="LinkBehavior.SystemDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemDefault,
        /// <include file='doc\LinkBehavior.uex' path='docs/doc[@for="LinkBehavior.AlwaysUnderline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AlwaysUnderline,
        /// <include file='doc\LinkBehavior.uex' path='docs/doc[@for="LinkBehavior.HoverUnderline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HoverUnderline,
        /// <include file='doc\LinkBehavior.uex' path='docs/doc[@for="LinkBehavior.NeverUnderline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NeverUnderline,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linkclickeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkClickEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\LinkClickEventHandler.uex' path='docs/doc[@for="LinkClickedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle 
    ///       the <see cref='System.Windows.Forms.RichTextBox.LinkClicked'/> event of 
    ///       a <see cref='System.Windows.Forms.RichTextBox'/>.
    ///    </para>
    /// </devdoc>
    public delegate void LinkClickedEventHandler(object sender, LinkClickedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linkclickevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkClickEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\LinkClickEvent.uex' path='docs/doc[@for="LinkClickedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.RichTextBox.LinkClicked'/> event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class LinkClickedEventArgs : EventArgs {
        private string linkText;

        /// <include file='doc\LinkClickEvent.uex' path='docs/doc[@for="LinkClickedEventArgs.LinkText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the text of the link being clicked.
        ///    </para>
        /// </devdoc>
        public string LinkText {
            get {
                return linkText;
            }
        }

        /// <include file='doc\LinkClickEvent.uex' path='docs/doc[@for="LinkClickedEventArgs.LinkClickedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.LinkClickedEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public LinkClickedEventArgs(string linkText) {
            this.linkText = linkText;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linklabel.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkLabel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Drawing.Drawing2D;
    using System.Drawing.Text;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms;
    using System;
    using System.Globalization;
    
    /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays text that can contain a hyperlink.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("LinkClicked"),
    ]
    public class LinkLabel : Label, IButtonControl {

        static readonly object EventLinkClicked = new object();

        static Color ielinkColor = Color.Empty;
        static Color ieactiveLinkColor = Color.Empty;
        static Color ievisitedLinkColor = Color.Empty;
        static Color iedisabledLinkColor = Color.Empty;
        static LinkComparer linkComparer = new LinkComparer();

        const string IESettingsRegPath = "Software\\Microsoft\\Internet Explorer\\Settings";
        const string IEMainRegPath = "Software\\Microsoft\\Internet Explorer\\Main";
        const string IEAnchorColor = "Anchor Color";
        const string IEAnchorColorVisited = "Anchor Color Visited";
        const string IEAnchorColorHover = "Anchor Color Hover";

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.dialogResult"]/*' />
        /// <devdoc>
        ///     The dialog result that will be sent to the parent dialog form when
        ///     we are clicked.
        /// </devdoc>
        DialogResult dialogResult;

        Color linkColor = Color.Empty;
        Color activeLinkColor = Color.Empty;
        Color visitedLinkColor = Color.Empty;
        Color disabledLinkColor = Color.Empty;

        Font linkFont;
        Font hoverLinkFont;

        bool textLayoutValid = false;
        bool receivedDoubleClick = false;

        ArrayList links = new ArrayList(2);

        Link focusLink = null;
        LinkCollection linkCollection = null;
        Region textRegion = null;
        Cursor overrideCursor = null;

        LinkBehavior linkBehavior = System.Windows.Forms.LinkBehavior.SystemDefault;

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkLabel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new default instance of the <see cref='System.Windows.Forms.LinkLabel'/> class.
        ///    </para>
        /// </devdoc>
        public LinkLabel() : base() {
            SetStyle(ControlStyles.AllPaintingInWmPaint
                     | ControlStyles.DoubleBuffer
                     | ControlStyles.Opaque
                     | ControlStyles.UserPaint
                     | ControlStyles.StandardClick
                     | ControlStyles.ResizeRedraw, true);
            ResetLinkArea();
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ActiveLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the color used to display active links.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.LinkLabelActiveLinkColorDescr)
        ]
        public Color ActiveLinkColor {
            get {
                if (activeLinkColor.IsEmpty) {
                    return IEActiveLinkColor;
                }
                else {
                    return activeLinkColor;
                }
            }
            set {
                if (activeLinkColor != value) {
                    activeLinkColor = value;
                    InvalidateLink(null);
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.DisabledLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the color used to display disabled links.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.LinkLabelDisabledLinkColorDescr)
        ]
        public Color DisabledLinkColor {
            get {
                if (disabledLinkColor.IsEmpty) {
                    return IEDisabledLinkColor;
                }
                else {
                    return disabledLinkColor;
                }
            }
            set {
                if (disabledLinkColor != value) {
                    disabledLinkColor = value;
                    InvalidateLink(null);
                }
            }
        }

        private Link FocusLink {
            get {
                return focusLink;
            }
            set {
                if (focusLink != value) {

                    if (focusLink != null) {
                        InvalidateLink(focusLink);
                    }

                    focusLink = value;
                    
                    if (focusLink != null) {
                        InvalidateLink(focusLink);

                        int focusIndex = -1;
                        for (int i=0; i<links.Count; i++) {
                            if (links[i] == focusLink) {
                                focusIndex = i;
                            }
                        }
                        if (IsHandleCreated) {
                            AccessibilityNotifyClients(AccessibleEvents.Focus, focusIndex);
                        }
                        
                    }
                }
            }
        }
        
        private Color IELinkColor {
            get {
                if (ielinkColor.IsEmpty) {
                    ielinkColor = GetIEColor(IEAnchorColor);
                }
                return ielinkColor;
            }
        }

        private Color IEActiveLinkColor {
            get {
                if (ieactiveLinkColor.IsEmpty) {
                    ieactiveLinkColor = GetIEColor(IEAnchorColorHover);
                }
                return ieactiveLinkColor;
            }
        }
        private Color IEVisitedLinkColor {
            get {
                if (ievisitedLinkColor.IsEmpty) {
                    ievisitedLinkColor = GetIEColor(IEAnchorColorVisited);
                }
                return ievisitedLinkColor;
            }
        }
        private Color IEDisabledLinkColor {
            get {
                if (iedisabledLinkColor.IsEmpty) {
                    iedisabledLinkColor = ControlPaint.Dark(DisabledColor);
                }
                return iedisabledLinkColor;
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkArea"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the range in the text that is treated as a link.
        ///    </para>
        /// </devdoc>
        [
        Editor("System.Windows.Forms.Design.LinkAreaEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        Localizable(true),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.LinkLabelLinkAreaDescr)
        ]
        public LinkArea LinkArea {
            get {
                if (links.Count == 0) {
                    return new LinkArea(0, 0);
                }
                return new LinkArea(((Link)links[0]).Start, ((Link)links[0]).Length);
            }
            set {
                LinkArea pt = LinkArea;

                links.Clear();

                if (!value.IsEmpty) {
                    if (value.Start < 0) {
                        throw new ArgumentException(SR.GetString(SR.LinkLabelAreaStart));
                    }
                    if (value.Length < -1) {
                        throw new ArgumentException(SR.GetString(SR.LinkLabelAreaLength));
                    }

                    Links.Add(new Link(this));

                    // Update the link area of the first link
                    //
                    ((Link)links[0]).Start = value.Start;
                    ((Link)links[0]).Length = value.Length;
                }

                UpdateSelectability();

                if (!pt.Equals(LinkArea)) {
                    InvalidateTextLayout();
                    Invalidate();
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkBehavior"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets ir sets a value that represents how the link will be underlined.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(LinkBehavior.SystemDefault),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.LinkLabelLinkBehaviorDescr)
        ]
        public LinkBehavior LinkBehavior {
            get {
                return linkBehavior;
            }
            set {
                if (!Enum.IsDefined(typeof(LinkBehavior), value)) {
                    throw new InvalidEnumArgumentException("LinkBehavior", (int)value, typeof(LinkBehavior));
                }
                if (value != linkBehavior) {
                    linkBehavior = value;
                    InvalidateLinkFonts();
                    InvalidateLink(null);
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the color used to display links in normal cases.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.LinkLabelLinkColorDescr)
        ]
        public Color LinkColor {
            get {
                if (linkColor.IsEmpty) {
                    return IELinkColor;
                }
                else {
                    return linkColor;
                }
            }
            set {
                if (linkColor != value) {
                    linkColor = value;
                    InvalidateLink(null);
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Links"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of links used in a <see cref='System.Windows.Forms.LinkLabel'/>.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.LinkLabelLinksDescr)
        ]
        public LinkCollection Links {
            get {
                if (linkCollection == null) {
                    linkCollection = new LinkCollection(this);
                }
                return linkCollection;
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkVisited"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the link should be displayed as if it was visited.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.LinkLabelLinkVisitedDescr)
        ]
        public bool LinkVisited {
            get {
                if (links.Count == 0) {
                    return false;
                }
                else {
                    return((Link)links[0]).Visited;
                }
            }
            set {
                if (value != LinkVisited) {
                    if (links.Count == 0) {
                        Links.Add(new Link(this));
                    }
                    ((Link)links[0]).Visited = value;
                }
            }
        }


        // link labels must always ownerdraw
        //
        internal override bool OwnerDraw {
            get {
                return true;
            }
        }


        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OverrideCursor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Cursor OverrideCursor {
            get {
                return overrideCursor;
            }
            set {
                if (overrideCursor != value) {
                    overrideCursor = value;

                    if (IsHandleCreated) {
                        // We want to instantly change the cursor if the mouse is within our bounds.
                        // This includes the case where the mouse is over one of our children
                        NativeMethods.POINT p = new NativeMethods.POINT();
                        NativeMethods.RECT r = new NativeMethods.RECT();
                        UnsafeNativeMethods.GetCursorPos(p);
                        UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref r);

                        // REVIEW: This first part is just a PtInRect but it seems a waste to make an API call for that
                        if ((r.left <= p.x && p.x < r.right && r.top <= p.y && p.y < r.bottom) || UnsafeNativeMethods.GetCapture() == Handle)
                            SendMessage(NativeMethods.WM_SETCURSOR, Handle, NativeMethods.HTCLIENT);
                    }
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Text"]/*' />
        [RefreshProperties(RefreshProperties.Repaint)]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.VisitedLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the color used to display the link once it has been visited.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.LinkLabelVisitedLinkColorDescr)
        ]
        public Color VisitedLinkColor {
            get {
                if (visitedLinkColor.IsEmpty) {
                    return IEVisitedLinkColor;
                }
                else {
                    return visitedLinkColor;
                }
            }
            set {
                if (visitedLinkColor != value) {
                    visitedLinkColor = value;
                    InvalidateLink(null);
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkClicked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the link is clicked.
        ///    </para>
        /// </devdoc>
        [WinCategory("Action"), SRDescription(SR.LinkLabelLinkClickedDescr)]
        public event LinkLabelLinkClickedEventHandler LinkClicked {
            add {
                Events.AddHandler(EventLinkClicked, value);
            }
            remove {
                Events.RemoveHandler(EventLinkClicked, value);
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.CreateAccessibilityInstance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Constructs the new instance of the accessibility object for this control. Subclasses
        ///    should not call base.CreateAccessibilityObject.
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new LinkLabelAccessibleObject(this);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.CreateHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a handle for this control. This method is called by the .NET Framework,
        ///       this should not be called. Inheriting classes should always call
        ///       base.createHandle when overriding this method.
        ///    </para>
        /// </devdoc>
        protected override void CreateHandle() {
            base.CreateHandle();
            InvalidateTextLayout();
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.EnsureLinkFonts"]/*' />
        /// <devdoc>
        ///     Updates the various link fonts based upon the specified link
        ///     behavior.
        /// </devdoc>
        private void EnsureLinkFonts() {
            if (linkFont != null && hoverLinkFont != null) {
                return;
            }

            bool underlineLink = true;
            bool underlineHover = true;

            LinkBehavior link = linkBehavior;
            if (link == LinkBehavior.SystemDefault) {
                link = GetIELinkBehavior();
            }

            switch (link) {
                case LinkBehavior.AlwaysUnderline:
                    underlineLink = true;
                    underlineHover = true;
                    break;
                case LinkBehavior.HoverUnderline:
                    underlineLink = false;
                    underlineHover = true;
                    break;
                case LinkBehavior.NeverUnderline:
                    underlineLink = false;
                    underlineHover = false;
                    break;
            }

            Font f = Font;

            // We optimize for the "same" value (never & always) to avoid creating an
            // extra font object.
            //
            if (underlineHover == underlineLink) {
                FontStyle style = f.Style;
                if (underlineHover) {
                    style |= FontStyle.Underline;
                }
                else {
                    style &= ~FontStyle.Underline;
                }
                hoverLinkFont = new Font(f, style);
                linkFont = hoverLinkFont;
            }
            else {
                FontStyle hoverStyle = f.Style;
                if (underlineHover) {
                    hoverStyle |= FontStyle.Underline;
                }
                else {
                    hoverStyle &= ~FontStyle.Underline;
                }

                hoverLinkFont = new Font(f, hoverStyle);

                FontStyle linkStyle = f.Style;
                if (underlineLink) {
                    linkStyle |= FontStyle.Underline;
                }
                else {
                    linkStyle &= ~FontStyle.Underline;
                }

                linkFont = new Font(f, linkStyle);
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.EnsureRun"]/*' />
        /// <devdoc>
        ///     Ensures that we have analyzed the text run so that we can render each segment
        ///     and link.
        /// </devdoc>
        private void EnsureRun() {
            EnsureRun(null);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.EnsureRun1"]/*' />
        /// <devdoc>
        ///     Ensures that we have analyzed the text run so that we can render each segment
        ///     and link.
        /// </devdoc>
        private void EnsureRun(Graphics g) {

            // bail early if everything is valid!
            //
            if (textLayoutValid) {
                return;
            }
            if (textRegion != null) {
                textRegion.Dispose();
                textRegion = null;
            }

            // bail early for no text
            //
            if (Text.Length == 0) {
                textLayoutValid = true;
                return;
            }

            StringFormat textFormat = GetStringFormat();
            try {

                Font alwaysUnderlined = new Font(Font, Font.Style | FontStyle.Underline);
                Graphics created = null;
                Rectangle layoutRectangle = ClientRectangle;

                try {

                    if (g == null) {
                        g = created = CreateGraphicsInternal();
                    }

                    Region[] textRegions = g.MeasureCharacterRanges(Text, alwaysUnderlined, layoutRectangle, textFormat);
                    int regionIndex = 0;
                    for (int i=0; i<Links.Count; i++) {
                        Link link = Links[i];
                        if (LinkInText(link.Start, link.Length)) {
                            Links[i].VisualRegion = textRegions[regionIndex];
                            regionIndex++;
                        }
                    }
                    Debug.Assert(regionIndex == (textRegions.Length - 1), "Failed to consume all link label visual regions");

                    textRegion = textRegions[textRegions.Length - 1];
                }
                finally {
                    alwaysUnderlined.Dispose();
                    alwaysUnderlined = null;

                    if (created != null) {
                        created.Dispose();
                        created = null;
                    }
                }

                textLayoutValid = true;
            }
            finally {
                textFormat.Dispose();
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.GetIEColor"]/*' />
        /// <devdoc>
        ///     Retrieves a named IE color from the registry. There are constants at the top
        ///     of this file of the valid names to retrieve.
        /// </devdoc>
        private Color GetIEColor(string name) {
            // SECREVIEW : We are just reading the IE color settings from the registry...
            //
            // SECUNDONE : This assert doesn't work... assert everything for now...
            //
            //new RegistryPermission(RegistryPermissionAccess.Read, "HKCU\\" + IESettingsRegPath).Assert();
            new RegistryPermission(PermissionState.Unrestricted).Assert();
            try {
                RegistryKey key = Registry.CurrentUser.OpenSubKey(IESettingsRegPath);

                if (key != null) {

                    // Since this comes from the registry, be very careful about its contents.
                    //
                    string s = (string)key.GetValue(name);
                    if (s != null) {
                        string[] rgbs = s.Split(new char[] {','});
                        int[] rgb = new int[3];

                        int nMax = Math.Min(rgb.Length, rgbs.Length);

                        for (int i = 0; i < nMax; i++) {
                            try {
                                rgb[i] = int.Parse(rgbs[i]);
                            }
                            catch (Exception) {
                            }
                        }

                        return Color.FromArgb(rgb[0], rgb[1], rgb[2]);
                    }
                }

                if (string.Compare(name, IEAnchorColor, true, CultureInfo.InvariantCulture) == 0) {
                    return Color.Blue;
                }
                else if (string.Compare(name, IEAnchorColorVisited, true, CultureInfo.InvariantCulture) == 0) {
                    return Color.Purple;
                }
                else if (string.Compare(name, IEAnchorColorHover, true, CultureInfo.InvariantCulture) == 0) {
                    return Color.Red;
                }
                else {
                    return Color.Red;
                }
            }
            finally {
                System.Security.CodeAccessPermission.RevertAssert();
            }

        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.GetIELinkBehavior"]/*' />
        /// <devdoc>
        ///     Retrieves the IE settings for link behavior from the registry.
        /// </devdoc>
        private LinkBehavior GetIELinkBehavior() {
            // SECREVIEW : We are just reading the IE color settings from the registry...
            //
            // SECUNDONE : This assert doesn't work... assert everything for now...
            //
            //new RegistryPermission(RegistryPermissionAccess.Read, "HKCU\\" + IEMainRegPath).Assert();
            new RegistryPermission(PermissionState.Unrestricted).Assert();
            try {
                RegistryKey key = Registry.CurrentUser.OpenSubKey(IEMainRegPath);
                if (key != null) {
                    string s = (string)key.GetValue("Anchor Underline");

                    if (s != null && string.Compare(s, "no", true, CultureInfo.InvariantCulture) == 0) {
                        return LinkBehavior.NeverUnderline;
                    }
                    if (s != null && string.Compare(s, "hover", true, CultureInfo.InvariantCulture) == 0) {
                        return LinkBehavior.HoverUnderline;
                    }
                    else {
                        return LinkBehavior.AlwaysUnderline;
                    }
                }
            }
            finally {
                System.Security.CodeAccessPermission.RevertAssert();
            }

            return LinkBehavior.AlwaysUnderline;
        }

        private StringFormat GetStringFormat() {
            StringFormat stringFormat = ControlPaint.StringFormatForAlignment(TextAlign);

            if (!UseMnemonic) {
                stringFormat.HotkeyPrefix = HotkeyPrefix.None;
            }
            else if (ShowKeyboardCues) {
                stringFormat.HotkeyPrefix = HotkeyPrefix.Show;
            }
            else {
                stringFormat.HotkeyPrefix = HotkeyPrefix.Hide;
            }

            // Adjust string format for Rtl controls
            if (RightToLeft == RightToLeft.Yes) {
                stringFormat.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
            }

            int textLen = Text.Length;
            ArrayList ranges = new ArrayList(Links.Count);
            foreach (Link link in Links) {
                if (LinkInText(link.Start, link.Length)) {
                    int length = (int) Math.Min(link.Length, textLen - link.Start);
                    ranges.Add(new CharacterRange(link.Start, length));
                }
            }

            CharacterRange[] regions = new CharacterRange[ranges.Count + 1];
            ranges.CopyTo(regions, 0);
            regions[regions.Length - 1] = new CharacterRange(0, textLen);
            stringFormat.SetMeasurableCharacterRanges(regions);

            return stringFormat;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.PointInLink"]/*' />
        /// <devdoc>
        ///     Determines if the given client coordinates is contained within a portion
        ///     of a link area.
        /// </devdoc>
        protected Link PointInLink(int x, int y) {
            Graphics g = CreateGraphicsInternal();
            Link hit = null;
            try {
                EnsureRun(g);
                foreach (Link link in links) {
                    if (link.VisualRegion != null && link.VisualRegion.IsVisible(x, y, g)) {
                        hit = link;
                        break;
                    }
                }
            }
            finally {
                g.Dispose();
                g = null;
            }
            return hit;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.InvalidateLink"]/*' />
        /// <devdoc>
        ///     Invalidates only the portions of the text that is linked to
        ///     the specified link. If link is null, then all linked text
        ///     is invalidated.
        /// </devdoc>
        private void InvalidateLink(Link link) {
            if (IsHandleCreated) {
                if (link == null) {
                    Invalidate();
                }
                else if (link.VisualRegion != null) {
                    Invalidate(link.VisualRegion);
                }
                else {
                    Invalidate();
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.InvalidateLinkFonts"]/*' />
        /// <devdoc>
        ///     Invalidates the current set of fonts we use when painting
        ///     links.  The fonts will be recreated when needed.
        /// </devdoc>
        private void InvalidateLinkFonts() {

            if (linkFont != null) {
                linkFont.Dispose();
            }

            if (hoverLinkFont != null && hoverLinkFont != linkFont) {
                hoverLinkFont.Dispose();
            }

            linkFont = null;
            hoverLinkFont = null;
        }

        private void InvalidateTextLayout() {
            textLayoutValid = false;
        }

        private bool LinkInText(int start, int length) {
            return(0 <= start && start < Text.Length && 0 < length);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.IButtonControl.DialogResult"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets or sets a value that is returned to the
        /// parent form when the link label.
        /// is clicked.
        /// </para>
        /// </devdoc>
        DialogResult IButtonControl.DialogResult {
            get {
                return dialogResult;
            }

            set {
                if (!Enum.IsDefined(typeof(DialogResult), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DialogResult));
                }

                dialogResult = value;
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.IButtonControl.NotifyDefault"]/*' />
        /// <internalonly/>
        void IButtonControl.NotifyDefault(bool value) {
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnGotFocus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.GotFocus'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnGotFocus(EventArgs e) {
            base.OnGotFocus(e);

            if (FocusLink != null) {
                InvalidateLink(FocusLink);
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnLostFocus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.LostFocus'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnLostFocus(EventArgs e) {
            base.OnLostFocus(e);

            if (FocusLink != null) {
                InvalidateLink(FocusLink);
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnKeyDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnKeyDown'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnKeyDown(KeyEventArgs e) {
            base.OnKeyDown(e);

            if (e.KeyCode == Keys.Enter) {
                if (FocusLink != null && FocusLink.Enabled) {
                    OnLinkClicked(new LinkLabelLinkClickedEventArgs(FocusLink));
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnMouseLeave"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseLeave'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseLeave(EventArgs e) {
            base.OnMouseLeave(e);
            if (!Enabled) {
                return;
            }

            foreach (Link link in links) {
                if ((link.State & LinkState.Hover) == LinkState.Hover
                    || (link.State & LinkState.Active) == LinkState.Active) {

                    bool activeChanged = (link.State & LinkState.Active) == LinkState.Active;
                    link.State &= ~(LinkState.Hover | LinkState.Active);

                    if (activeChanged || hoverLinkFont != linkFont) {
                        InvalidateLink(link);
                    }
                    OverrideCursor = null;
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnMouseDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseDown'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs e) {
            base.OnMouseDown(e);

            if (!Enabled || e.Clicks > 1) {
                receivedDoubleClick = true;
                return;
            }

            for (int i=0; i<links.Count; i++) {
                if ((((Link)links[i]).State & LinkState.Hover) == LinkState.Hover) {
                    ((Link)links[i]).State |= LinkState.Active;

                    FocusInternal();
                    if (((Link)links[i]).Enabled) {
                        FocusLink = (Link)links[i];
                        InvalidateLink(FocusLink);
                    }
                    CaptureInternal = true;
                    break;
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnMouseUp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseUp'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs e) {

            base.OnMouseUp(e);

            if (!Enabled || e.Clicks > 1 || receivedDoubleClick) {
                receivedDoubleClick = false;
                return;
            }

            for (int i=0; i<links.Count; i++) {
                if ((((Link)links[i]).State & LinkState.Active) == LinkState.Active) {
                    ((Link)links[i]).State &= (~LinkState.Active);
                    InvalidateLink((Link)links[i]);
                    CaptureInternal = false;

                    Link clicked = PointInLink(e.X, e.Y);

                    if (clicked != null && clicked == FocusLink && clicked.Enabled) {
                        OnLinkClicked(new LinkLabelLinkClickedEventArgs(clicked));
                    }
                }
            }
        }
        
        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnMouseMove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseMove'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs e) {
            base.OnMouseMove(e);

            if (!Enabled) {
                return;
            }

            Link hoverLink = null;
            foreach (Link link in links) {
                if ((link.State & LinkState.Hover) == LinkState.Hover) {
                    hoverLink = link;
                    break;
                }
            }

            Link pointIn = PointInLink(e.X, e.Y);

            if (pointIn != hoverLink) {
                if (hoverLink != null) {
                    hoverLink.State &= ~LinkState.Hover;
                }
                if (pointIn != null) {
                    pointIn.State |= LinkState.Hover;
                    if (pointIn.Enabled) {
                        OverrideCursor = Cursors.Hand;
                    }
                }
                else {
                    OverrideCursor = null;
                }

                if (hoverLinkFont != linkFont) {
                    if (hoverLink != null) {
                        InvalidateLink(hoverLink);
                    }
                    if (pointIn != null) {
                        InvalidateLink(pointIn);
                    }
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnLinkClicked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.LinkLabel.OnLinkClicked'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnLinkClicked(LinkLabelLinkClickedEventArgs e) {
            LinkLabelLinkClickedEventHandler handler = (LinkLabelLinkClickedEventHandler)Events[EventLinkClicked];
            if (handler != null) {
                handler(this, e);
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnPaint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnPaint'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs e) {
            Animate();

            ImageAnimator.UpdateFrames();
            EnsureRun(e.Graphics);

            // bail early for no text
            //
            if (Text.Length == 0) {
                PaintLinkBackground(e.Graphics);                
            }
            // Paint enabled link label
            //
            else if (Enabled) {
                bool optimizeBackgroundRendering = !GetStyle(ControlStyles.DoubleBuffer);
                Brush foreBrush = new SolidBrush(ForeColor);
                Brush linkBrush = new SolidBrush(LinkColor);

                try {
                    if (!optimizeBackgroundRendering) {
                        PaintLinkBackground(e.Graphics);
                    }

                    EnsureLinkFonts();

                    Region originalClip = e.Graphics.Clip;

                    try {
                        foreach (Link link in links) {
                            if (link.VisualRegion != null) {
                                e.Graphics.ExcludeClip(link.VisualRegion);
                            }
                        }
                        PaintLink(e.Graphics, null, foreBrush, linkBrush, optimizeBackgroundRendering);

                        foreach (Link link in links) {
                            PaintLink(e.Graphics, link, foreBrush, linkBrush, optimizeBackgroundRendering);
                        }

                        if (optimizeBackgroundRendering) {
                            e.Graphics.Clip = originalClip;
                            e.Graphics.ExcludeClip(textRegion);
                            PaintLinkBackground(e.Graphics);
                        }
                    }
                    finally {
                        e.Graphics.Clip = originalClip;
                    }
                }
                finally {
                    foreBrush.Dispose();
                    linkBrush.Dispose();
                }
            }
            // Paint disabled link label
            //
            else {
                StringFormat stringFormat = GetStringFormat();
                Region originalClip = e.Graphics.Clip;

                // two pass paint, much less flicker!
                //
                try {
                    e.Graphics.IntersectClip(textRegion);
                    PaintLinkBackground(e.Graphics);
                    ControlPaint.DrawStringDisabled(e.Graphics, Text, Font, 
                                                  DisabledColor, ClientRectangle,
                                                  stringFormat);

                    e.Graphics.Clip = originalClip;
                    e.Graphics.ExcludeClip(textRegion);
                    PaintLinkBackground(e.Graphics);
                }
                finally {
                    e.Graphics.Clip = originalClip;
                }
            }

            // We can't call base.OnPaint because labels paint differently from link labels,
            // but we still need to raise the Paint event.
            //
            RaisePaintEvent(this, e);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnPaintBackground"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnPaintBackground(PaintEventArgs e) {
            Image i = this.Image;

            if (i != null) {
                Region oldClip = e.Graphics.Clip;
                Rectangle imageBounds = CalcImageRenderBounds(i, ClientRectangle, RtlTranslateAlignment(ImageAlign));
                e.Graphics.ExcludeClip(imageBounds);
                try {
                    base.OnPaintBackground(e);
                }
                finally {
                    e.Graphics.Clip = oldClip;
                }

                e.Graphics.IntersectClip(imageBounds);
                try {
                    base.OnPaintBackground(e);
                    DrawImage(e.Graphics, i, ClientRectangle, RtlTranslateAlignment(ImageAlign));
                }
                finally {
                    e.Graphics.Clip = oldClip;
                }
            }
            else {
                base.OnPaintBackground(e);
            }

        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            InvalidateTextLayout();
            InvalidateLinkFonts();
            Invalidate();
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnEnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnEnabledChanged(EventArgs e) {
            base.OnEnabledChanged(e);
            
            if (!Enabled) {
                for (int i=0; i<links.Count; i++) {
                    ((Link)links[i]).State &= ~(LinkState.Hover | LinkState.Active);
                }
                OverrideCursor = null;
            }
            Invalidate();
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnTextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnTextChanged(EventArgs e) {
            base.OnTextChanged(e);
            InvalidateTextLayout();
            UpdateSelectability();
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.OnTextAlignChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnTextAlignChanged(EventArgs e) {
            base.OnTextAlignChanged(e);
            InvalidateTextLayout();
            UpdateSelectability();
        }

        private void PaintLink(Graphics g, Link link, Brush foreBrush, Brush linkBrush, bool optimizeBackgroundRendering) {
            
            // link = null means paint the whole text

            Debug.Assert(g != null, "Must pass valid graphics");
            Debug.Assert(foreBrush != null, "Must pass valid foreBrush");
            Debug.Assert(linkBrush != null, "Must pass valid linkBrush");

            StringFormat stringFormat = GetStringFormat();

            Font font = Font;
            Brush created = null;
            if (link != null) {
                if (link.VisualRegion != null) {
                    Brush useBrush = null;
                    LinkState linkState = link.State;

                    if ((linkState & LinkState.Hover) == LinkState.Hover) {
                        font = hoverLinkFont;
                    }
                    else {
                        font = linkFont;
                    }

                    if (link.Enabled) {
                        if ((linkState & LinkState.Active) == LinkState.Active) {
                            useBrush = created = new SolidBrush(ActiveLinkColor);
                        }
                        else if ((linkState & LinkState.Visited) == LinkState.Visited) {
                            useBrush = created = new SolidBrush(VisitedLinkColor);
                        }
                        else {
                            useBrush = linkBrush;
                        }
                    }
                    else {
                        useBrush = created = new SolidBrush(DisabledLinkColor);
                    }
                    g.Clip = link.VisualRegion;
                    if (optimizeBackgroundRendering) {
                        PaintLinkBackground(g);
                    }
                    
                    if (Focused && ShowFocusCues && FocusLink == link) {
                        // Get the rectangles making up the visual region, and draw
                        // each one.
                        RectangleF[] rects = link.VisualRegion.GetRegionScans(g.Transform);
                        foreach (RectangleF rect in rects) {
                            ControlPaint.DrawFocusRectangle(g, Rectangle.Ceiling(rect));
                        }
                    }

                    g.DrawString(Text, font, useBrush, ClientRectangle, stringFormat);
                }

                // no else clause... we don't paint anything if we are given a link with no visual region.
                //
            }
            else {
                g.IntersectClip(textRegion);
                if (optimizeBackgroundRendering) {
                    PaintLinkBackground(g);
                }
                g.DrawString(Text, font, foreBrush, ClientRectangle, stringFormat);
            }

            if (created != null) {
                created.Dispose();
            }
        }

        private void PaintLinkBackground(Graphics g) {
            InvokePaintBackground(this, new PaintEventArgs(g, ClientRectangle));
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.IButtonControl.PerformClick"]/*' />
        /// <internalonly/>
        void IButtonControl.PerformClick() {

            // If a link is not currently focused, focus on the first link
            //
            if (FocusLink == null && Links.Count > 0) {
                foreach (Link link in Links) {
                    if (link.Enabled && LinkInText(link.Start, link.Length)) {
                        FocusLink = link;
                        break;
                    }
                }
            }

            // Act as if the focused link was clicked
            //
            if (FocusLink != null) {
                OnLinkClicked(new LinkLabelLinkClickedEventArgs(FocusLink));
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Processes a dialog key. This method is called during message pre-processing
        ///       to handle dialog characters, such as TAB, RETURN, ESCAPE, and arrow keys. This
        ///       method is called only if the isInputKey() method indicates that the control
        ///       isn't interested in the key. processDialogKey() simply sends the character to
        ///       the parent's processDialogKey() method, or returns false if the control has no
        ///       parent. The Form class overrides this method to perform actual processing
        ///       of dialog keys. When overriding processDialogKey(), a control should return true
        ///       to indicate that it has processed the key. For keys that aren't processed by the
        ///       control, the result of "base.processDialogChar()" should be returned. Controls
        ///       will seldom, if ever, need to override this method.
        ///    </para>
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
            if ((keyData & (Keys.Alt | Keys.Control)) != Keys.Alt) {
                Keys keyCode = keyData & Keys.KeyCode;
                switch (keyCode) {
                    case Keys.Tab:
                        if (TabStop) {
                            Link focusedLink = FocusLink;

                            bool forward = (keyData & Keys.Shift) != Keys.Shift;
                            if (FocusNextLink(forward)) {
                                return true;
                            }
                        }
                        break;
                    case Keys.Up:
                    case Keys.Left:
                        if (FocusNextLink(false)) {
                            return true;
                        }
                        break;
                    case Keys.Down:
                    case Keys.Right:
                        if (FocusNextLink(true)) {
                            return true;
                        }
                        break;
                }
            }
            return base.ProcessDialogKey(keyData);
        }

        private bool FocusNextLink(bool forward) {
            int focusIndex = -1;
            if (focusLink != null) {
                for (int i=0; i<links.Count; i++) {
                    if (links[i] == focusLink) {
                        focusIndex = i;
                    }
                }
            }

            focusIndex = GetNextLinkIndex(focusIndex, forward);
            if (focusIndex != -1) {
                FocusLink = Links[focusIndex];
                return true;
            }
            else {
                FocusLink = null;
                return false;
            }
        }

        private int GetNextLinkIndex(int focusIndex, bool forward) {
            Link test;

            if (forward) {
                do {
                    focusIndex++;

                    if (focusIndex < Links.Count) {
                        test = Links[focusIndex];
                    }
                    else {
                        test = null;
                    }

                } while (test != null
                         && !test.Enabled
                         && LinkInText(test.Start, test.Length));
            }
            else {
                do {
                    focusIndex--;
                    if (focusIndex >= 0) {
                        test = Links[focusIndex];
                    }
                    else {
                        test = null;
                    }
                } while (test != null
                         && !test.Enabled
                         && LinkInText(test.Start, test.Length));
            }

            if (focusIndex < 0 || focusIndex >= links.Count) {
                return -1;
            }
            else {
                return focusIndex;
            }
        }

        private void ResetLinkArea() {
            LinkArea = new LinkArea(0, -1);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.SetBoundsCore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs the work of setting the bounds of this control. Inheriting classes
        ///       can overide this function to add size restrictions. Inheriting classes must call
        ///       base.setBoundsCore to actually cause the bounds of the control to change.
        ///    </para>
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {

            // we cache too much state to try and optimize this (regions, etc)... it is best 
            // to always relayout here... If we want to resurect this code in the future, 
            // remember that we need to handle a word wrapped top aligned text that 
            // will become newly exposed (and therefore layed out) when we resize...
            //
            /*
            ContentAlignment anyTop = ContentAlignment.TopLeft | ContentAlignment.TopCenter | ContentAlignment.TopRight;

            if ((TextAlign & anyTop) == 0 || Width != width || (Image != null && (ImageAlign & anyTop) == 0)) {
                InvalidateTextLayout();
                Invalidate();
            }
            */
            
            InvalidateTextLayout();
            Invalidate();

            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Select"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Select(bool directed, bool forward) {

            if (directed) {
                if (links.Count > 0) {

                    // Find which link is currently focused
                    //
                    int focusIndex = -1;
                    if (FocusLink != null) {
                        focusIndex = links.IndexOf(FocusLink);
                    }

                    // We could be getting focus from ourself, so we must
                    // invalidate each time.                                   
                    //
                    FocusLink = null;

                    int newFocus = GetNextLinkIndex(focusIndex, forward);
                    if (newFocus == -1) {
                        if (forward) {
                            newFocus = GetNextLinkIndex(-1, forward); // -1, so "next" will be 0
                        }
                        else {
                            newFocus = GetNextLinkIndex(links.Count, forward); // Count, so "next" will be Count-1
                        }
                    }

                    if (newFocus != -1) {
                        FocusLink = (Link)links[newFocus];
                    }
                }
            }
            base.Select(directed, forward);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ShouldSerializeActiveLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the color for active links should remain the same.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeActiveLinkColor() {
            return !activeLinkColor.IsEmpty;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ShouldSerializeDisabledLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the color for disabled links should remain the same.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeDisabledLinkColor() {
            return !disabledLinkColor.IsEmpty;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ShouldSerializeLinkArea"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the range in text that is treated as a
        ///       link should remain the same.      
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeLinkArea() {
            if (links.Count == 1) {
                // use field access to find out if "length" is really -1
                return Links[0].Start != 0 || Links[0].length != -1;
            }
            return true;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ShouldSerializeLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the color of links in normal cases should remain the same.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeLinkColor() {
            return !linkColor.IsEmpty;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ShouldSerializeVisitedLinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the color of links that have been visited should remain the same.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeVisitedLinkColor() {
            return !visitedLinkColor.IsEmpty;
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.ValidateNoOverlappingLinks"]/*' />
        /// <devdoc>
        ///     Validates that no links overlap. This will throw an exception if
        ///     they do.
        /// </devdoc>
        private void ValidateNoOverlappingLinks() {
            for (int x=0; x<links.Count; x++) {

                Link left = (Link)links[x];
                if (left.Length < 0) {
                    throw new InvalidOperationException(SR.GetString(SR.LinkLabelOverlap));
                }

                for (int y=x; y<links.Count; y++) {
                    if (x != y) {
                        Link right = (Link)links[y];
                        int maxStart = Math.Max(left.Start, right.Start);
                        int minEnd = Math.Min(left.Start + left.Length, right.Start + right.Length);
                        if (maxStart < minEnd) {
                            throw new InvalidOperationException(SR.GetString(SR.LinkLabelOverlap));
                        }
                    }
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.UpdateSelectability"]/*' />
        /// <devdoc>
        ///     Updates the label's ability to get focus. If there are
        ///     any links in the label, then the label can get focus,
        ///     else it can't.
        /// </devdoc>
        private void UpdateSelectability() {
            LinkArea pt = LinkArea;
            bool selectable = false;

            if (LinkInText(pt.Start, pt.Length)) {
                selectable = true;
            }
            else {
                // If a link is currently focused, de-select it
                //
                if (FocusLink != null) {
                    FocusLink = null;
                }
            }
            
            OverrideCursor = null;
            TabStop = selectable;
            SetStyle(ControlStyles.Selectable, selectable);
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.WmSetCursor"]/*' />
        /// <devdoc>
        ///     Handles the WM_SETCURSOR message
        /// </devdoc>
        /// <internalonly/>
        private void WmSetCursor(ref Message m) {

            // Accessing through the Handle property has side effects that break this
            // logic. You must use InternalHandle.
            //
            if (m.WParam == InternalHandle && ((int)m.LParam & 0x0000FFFF) == NativeMethods.HTCLIENT) {
                if (OverrideCursor != null) {
                    Cursor.CurrentInternal = OverrideCursor;
                }
                else {
                    Cursor.CurrentInternal = Cursor;
                }
            }
            else {
                DefWndProc(ref m);
            }

        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.WndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message msg) {
            switch (msg.Msg) {
                case NativeMethods.WM_SETCURSOR:
                    WmSetCursor(ref msg);
                    break;
                default:
                    base.WndProc(ref msg);
                    break;
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class LinkCollection : IList {
            private LinkLabel owner;

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.LinkCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public LinkCollection(LinkLabel owner) {
                if (owner == null)
                    throw new ArgumentNullException("owner");
                this.owner = owner;
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.this"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual Link this[int index] {
                get {
                    return(Link)owner.links[index];
                }
                set {
                    owner.links[index] = value;

                    owner.links.Sort(LinkLabel.linkComparer);

                    owner.InvalidateTextLayout();
                    owner.Invalidate();
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    if (value is Link) {
                        this[index] = (Link)value;
                    }
                    else {  
                        throw new ArgumentException("value");
                    }
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.links.Count;
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
           
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public Link Add(int start, int length) {
                return Add(start, length, null);
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.Add1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public Link Add(int start, int length, object linkData) {
                // check for the special case where the list is in the "magic"
                // state of having only the default link in it. In that case
                // we want to clear the list before adding this link.
                //
                if (owner.links.Count == 1 
                    && this[0].Start == 0
                    && this[0].length == -1) {

                    owner.links.Clear();
                }

                Link l = new Link(owner);
                l.Start = start;
                l.Length = length;
                l.LinkData = linkData;
                Add(l);
                return l;
            }

            internal int Add(Link value) {

                // Set the owner control for this link
                value.owner = this.owner;

                owner.links.Add(value);

                if (owner.Links.Count > 1) {
                    owner.links.Sort(LinkLabel.linkComparer);
                }

                owner.ValidateNoOverlappingLinks();
                owner.UpdateSelectability();
                owner.InvalidateTextLayout();
                owner.Invalidate();

                if (owner.Links.Count > 1) {
                    return IndexOf(value);
                }
                else {
                    return 0;
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                if (value is Link) {
                    return Add((Link)value);
                }
                else {  
                    throw new ArgumentException("value");
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                if (value is Link) {
                    Add((Link)value);
                }
                else {  
                    throw new ArgumentException("value");
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(Link link) {
                return owner.links.Contains(link);
            }
        
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object link) {
                if (link is Link) {
                    return Contains((Link)link);
                }
                else {  
                    return false;
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(Link link) {
                return owner.links.IndexOf(link);
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object link) {
                if (link is Link) {
                    return IndexOf((Link)link);
                }
                else {  
                    return -1;
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.Clear"]/*' />
            /// <devdoc>
            ///    Remove all links from the linkLabel.
            /// </devdoc>
            public virtual void Clear() {
                owner.links.Clear();

                owner.UpdateSelectability();
                owner.InvalidateTextLayout();
                owner.Invalidate();
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                owner.links.CopyTo(dest, index);
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                if (owner.links != null) {
                    return owner.links.GetEnumerator();
                }
                else {
                    return new Link[0].GetEnumerator();
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Remove(Link value) {

                if (value.owner != this.owner) {
                    return;
                }

                owner.links.Remove(value);

                owner.links.Sort(LinkLabel.linkComparer);

                owner.ValidateNoOverlappingLinks();
                owner.UpdateSelectability();
                owner.InvalidateTextLayout();
                owner.Invalidate();

                if (owner.FocusLink == null && owner.links.Count > 0) {
                    owner.FocusLink = (Link)owner.links[0];
                }
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void RemoveAt(int index) {
                Remove(this[index]);
            }
            
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                if (value is Link) {
                    Remove((Link)value);
                }                
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Link"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class Link {
            private int start = 0;
            private object linkData = null;
            private LinkState state = LinkState.Normal;
            private bool enabled = true;
            private Region visualRegion;
            internal int length = 0;
            internal LinkLabel owner = null;

            internal Link() {
            }

            internal Link(LinkLabel owner) {
                this.owner = owner;
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Link.Enabled"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Enabled {
                get {
                    return enabled;
                }
                set {
                    if (enabled != value) {
                        enabled = value;

                        if ((int)(state & (LinkState.Hover | LinkState.Active)) != 0) {
                            state &= ~(LinkState.Hover | LinkState.Active);
                            owner.OverrideCursor = null;
                        }

                        owner.InvalidateLink(this);
                    }
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Link.Length"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Length {
                get {
                    if (length == -1) {
                        return owner.Text.Length - Start;
                    }
                    return length;
                }
                set {
                    if (length != value) {
                        length = value;
                        owner.InvalidateTextLayout();
                        owner.Invalidate();
                    }
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Link.LinkData"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public object LinkData {
                get {
                    return linkData;
                }
                set {
                    linkData = value;
                }
            }

            internal LinkState State {
                get {
                    return state;
                }
                set {
                    state = value;
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Link.Start"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Start {
                get {
                    return start;
                }
                set {
                    if (start != value) {
                        start = value;

                        owner.links.Sort(LinkLabel.linkComparer);

                        owner.InvalidateTextLayout();
                        owner.Invalidate();
                    }
                }
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.Link.Visited"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Visited {
                get {
                    return(State & LinkState.Visited) == LinkState.Visited;
                }
                set {
                    bool old = Visited;

                    if (value) {
                        State |= LinkState.Visited;
                    }
                    else {
                        State &= ~LinkState.Visited;
                    }

                    if (old != Visited) {
                        owner.InvalidateLink(this);
                    }
                }
            }

            internal Region VisualRegion {
                get {
                    return visualRegion;
                }
                set {
                    visualRegion = value;
                }
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkComparer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private class LinkComparer : IComparer {
            int IComparer.Compare(object link1, object link2) {

                Debug.Assert(link1 != null && link2 != null, "Null objects sent for comparison");

                int pos1 = ((Link)link1).Start;
                int pos2 = ((Link)link2).Start;

                return pos1 - pos2;                                       
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkLabelAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]
        internal class LinkLabelAccessibleObject : LabelAccessibleObject {
            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkLabelAccessibleObject.LinkLabelAccessibleObject"]/*' />
            /// <devdoc>
            /// </devdoc>
            public LinkLabelAccessibleObject(LinkLabel owner) : base(owner) {
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkLabelAccessibleObject.GetChild"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override AccessibleObject GetChild(int index) {
                if (index >= 0 && index < ((LinkLabel)Owner).Links.Count) {
                    return new LinkAccessibleObject(((LinkLabel)Owner).Links[index]);
                }
                else {
                    return null;
                }
            }

            public override System.Windows.Forms.AccessibleObject HitTest(int x,  int y) {
                Point p = Owner.PointToClient(new Point(x, y));
                Link hit = ((LinkLabel)Owner).PointInLink(p.X, p.Y);
                if (hit != null) {
                    return new LinkAccessibleObject(hit);
                }
                if (this.Bounds.Contains(x, y)) {
                    return this;
                }
                return null;
            }

            /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkLabelAccessibleObject.GetChildCount"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override int GetChildCount() {
                return((LinkLabel)Owner).Links.Count;
            }
        }

        /// <include file='doc\LinkLabel.uex' path='docs/doc[@for="LinkLabel.LinkAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        internal class LinkAccessibleObject : AccessibleObject {

            private Link link;

            public LinkAccessibleObject(Link link) : base() {
                this.link = link;
            }

            public override Rectangle Bounds {
                get {
                    Region region = link.VisualRegion;
                    Graphics g = null;

                    IntSecurity.ObjectFromWin32Handle.Assert();
                    try
                    {
                        g = Graphics.FromHwnd(link.owner.Handle);
                    }
                    finally 
                    {
                        CodeAccessPermission.RevertAssert();
                    }

                    // Make sure we have a region for this link
                    //
                    if (region == null) {
                        link.owner.EnsureRun(g);
                        region = link.VisualRegion;
                        if (region == null) {
                            g.Dispose();
                            return Rectangle.Empty;
                        }
                    }

                    Rectangle rect;
                    try {
                        rect = Rectangle.Ceiling(region.GetBounds(g));
                    }
                    finally {
                        g.Dispose();
                    }

                    // Translate rect to screen coordinates
                    //
                    return link.owner.RectangleToScreen(rect);
                }
            }

            public override string DefaultAction {
                get {
                    return SR.GetString(SR.AccessibleActionClick);
                }
            }

            public override string Name {
                get {
                    return link.owner.Text.Substring(link.Start, link.Length);
                }
                set {
                    base.Name = value;
                }
            }

            public override AccessibleObject Parent {
                get {
                    return link.owner.AccessibilityObject;                
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.Link;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.Focusable;

                    // Selected state
                    //
                    if (link.owner.FocusLink == link) {
                        state |= AccessibleStates.Focused;
                    }

                    return state;

                }
            }

            public override string Value {
                get {
                    return Name;
                }
            }

            public override void DoDefaultAction() {
                link.owner.OnLinkClicked(new LinkLabelLinkClickedEventArgs(link));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linkarea.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkArea.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Collections;

    /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        TypeConverterAttribute(typeof(LinkArea.LinkAreaConverter)),
        Serializable
    ]
    public struct LinkArea {
        int start;
        int length;

        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkArea"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public LinkArea(int start, int length) {
            this.start = start;
            this.length = length;
        }

        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.Start"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Start {
            get {
                return start;
            }
            set {
                start = value;
            }
        }

        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.Length"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Length {
            get {
                return length;
            }
            set {
                length = value;
            }
        }
        
        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.IsEmpty"]/*' />
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEmpty {
            get {
                return length == start && start == 0;
            }
        }
        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.Equals"]/*' />
        public override bool Equals(object o) {
            if (!(o is LinkArea)) {
                return false;
            }
            
            LinkArea a = (LinkArea)o;
            return start == a.start && length == a.length;
        }
        
        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.GetHashCode"]/*' />
        public override int GetHashCode() {
            return start << 4 | length;
        }

        /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter"]/*' />
        /// <devdoc>
        ///      LinkAreaConverter is a class that can be used to convert
        ///      LinkArea from one data type to another.  Access this
        ///      class through the TypeDescriptor.
        /// </devdoc>
        public class LinkAreaConverter : TypeConverter {

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.CanConvertFrom"]/*' />
            /// <devdoc>
            ///      Determines if this converter can convert an object in the given source
            ///      type to the native type of the converter.
            /// </devdoc>
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
                if (sourceType == typeof(string)) {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.CanConvertTo"]/*' />
            /// <devdoc>
            ///    <para>Gets a value indicating whether this converter can
            ///       convert an object to the given destination type using the context.</para>
            /// </devdoc>
            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
                if (destinationType == typeof(InstanceDescriptor)) {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.ConvertFrom"]/*' />
            /// <devdoc>
            ///      Converts the given object to the converter's native type.
            /// </devdoc>
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

                if (value is string) {

                    string text = ((string)value).Trim();

                    if (text.Length == 0) {
                        return null;
                    }
                    else {

                        // Parse 2 integer values.
                        //
                        if (culture == null) {
                            culture = CultureInfo.CurrentCulture;
                        }                    
                        char sep = culture.TextInfo.ListSeparator[0];
                        string[] tokens = text.Split(new char[] {sep});
                        int[] values = new int[tokens.Length];
                        TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                        for (int i = 0; i < values.Length; i++) {
                            values[i] = (int)intConverter.ConvertFromString(context, culture, tokens[i]);
                        }

                        if (values.Length == 2) {
                            return new LinkArea(values[0], values[1]);
                        }
                        else {
                            throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                      text,
                                                                      "start, length"));
                        }
                    }
                }

                return base.ConvertFrom(context, culture, value);
            }

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.ConvertTo"]/*' />
            /// <devdoc>
            ///      Converts the given object to another type.  The most common types to convert
            ///      are to and from a string object.  The default implementation will make a call
            ///      to ToString on the object if the object is valid and if the destination
            ///      type is string.  If this cannot convert to the desitnation type, this will
            ///      throw a NotSupportedException.
            /// </devdoc>
            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                if (destinationType == null) {
                    throw new ArgumentNullException("destinationType");
                }

                if (destinationType == typeof(string) && value is LinkArea) {
                    LinkArea pt = (LinkArea)value;

                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }
                    string sep = culture.TextInfo.ListSeparator + " ";
                    TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                    string[] args = new string[2];
                    int nArg = 0;

                    args[nArg++] = intConverter.ConvertToString(context, culture, pt.Start);
                    args[nArg++] = intConverter.ConvertToString(context, culture, pt.Length);

                    return string.Join(sep, args);
                }
                if (destinationType == typeof(InstanceDescriptor) && value is LinkArea) {
                    LinkArea pt = (LinkArea)value;

                    ConstructorInfo ctor = typeof(LinkArea).GetConstructor(new Type[] {typeof(int), typeof(int)});
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {pt.Start, pt.Length});
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.CreateInstance"]/*' />
            /// <devdoc>
            ///      Creates an instance of this type given a set of property values
            ///      for the object.  This is useful for objects that are immutable, but still
            ///      want to provide changable properties.
            /// </devdoc>
            public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
                return new LinkArea((int)propertyValues["Start"],
                                 (int)propertyValues["Length"]);
            }

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.GetCreateInstanceSupported"]/*' />
            /// <devdoc>
            ///      Determines if changing a value on this object should require a call to
            ///      CreateInstance to create a new value.
            /// </devdoc>
            public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
                return true;
            }

            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.GetProperties"]/*' />
            /// <devdoc>
            ///      Retrieves the set of properties for this type.  By default, a type has
            ///      does not return any properties.  An easy implementation of this method
            ///      can just call TypeDescriptor.GetProperties for the correct data type.
            /// </devdoc>
            public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(LinkArea), attributes);
                return props.Sort(new string[] {"Start", "Length"});
            }


            /// <include file='doc\LinkArea.uex' path='docs/doc[@for="LinkArea.LinkAreaConverter.GetPropertiesSupported"]/*' />
            /// <devdoc>
            ///      Determines if this object supports properties.  By default, this
            ///      is false.
            /// </devdoc>
            public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
                return true;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linklabellinkclickedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkLabelLinkClickedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\LinkLabelLinkClickedEvent.uex' path='docs/doc[@for="LinkLabelLinkClickedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.LinkLabel.OnLinkClicked'/> event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class LinkLabelLinkClickedEventArgs : EventArgs {
        private readonly LinkLabel.Link link;
        /// <include file='doc\LinkLabelLinkClickedEvent.uex' path='docs/doc[@for="LinkLabelLinkClickedEventArgs.LinkLabelLinkClickedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.LinkLabelLinkClickedEventArgs'/> class, given the link.
        ///    </para>
        /// </devdoc>
        public LinkLabelLinkClickedEventArgs(LinkLabel.Link link) {
            this.link = link;
        }

        /// <include file='doc\LinkLabelLinkClickedEvent.uex' path='docs/doc[@for="LinkLabelLinkClickedEventArgs.Link"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Windows.Forms.LinkLabel.Link'/> that was clicked.
        ///    </para>
        /// </devdoc>
        public LinkLabel.Link Link {
            get {
                return link;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linklabellinkclickedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkLabelLinkClickedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\LinkLabelLinkClickedEventHandler.uex' path='docs/doc[@for="LinkLabelLinkClickedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.LinkLabel.LinkClicked'/> event of a <see cref='System.Windows.Forms.LinkLabel'/>.
    ///    </para>
    /// </devdoc>
    public delegate void LinkLabelLinkClickedEventHandler(object sender, LinkLabelLinkClickedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\linkstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\LinkState.uex' path='docs/doc[@for="LinkState"]/*' />
    /// <internalonly />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum LinkState {
        /// <include file='doc\LinkState.uex' path='docs/doc[@for="LinkState.Normal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Normal =  0x00,
        /// <include file='doc\LinkState.uex' path='docs/doc[@for="LinkState.Hover"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Hover  =  0x01,
        /// <include file='doc\LinkState.uex' path='docs/doc[@for="LinkState.Active"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Active =  0x02,
        /// <include file='doc\LinkState.uex' path='docs/doc[@for="LinkState.Visited"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Visited = 0x04
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listcontrol.cs ===
//------------------------------------------------------------------------------

// <copyright file="ListControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Globalization;
    using System.Windows.Forms;
    
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.Windows.Forms.ComponentModel;

    using System.Collections;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Text;

    /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class ListControl : Control {

        private static readonly object EVENT_DATASOURCECHANGED      = new object();
        private static readonly object EVENT_DISPLAYMEMBERCHANGED   = new object();
        private static readonly object EVENT_VALUEMEMBERCHANGED     = new object();
        private static readonly object EVENT_SELECTEDVALUECHANGED   = new object();

        private object dataSource;
        private CurrencyManager dataManager;
        private BindingMemberInfo displayMember;        
        private BindingMemberInfo valueMember;

        private bool changingLinkedSelection;
        
        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataSource"]/*' />
        /// <devdoc>
        ///     The ListSource to consume as this ListBox's source of data.
        ///     When set, a user can not modify the Items collection.
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DefaultValue(null),
        RefreshProperties(RefreshProperties.Repaint),
        TypeConverterAttribute("System.Windows.Forms.Design.DataSourceConverter, " + AssemblyRef.SystemDesign),
        SRDescription(SR.ListControlDataSourceDescr)
        ]
        public object DataSource {
            get {
                return dataSource;
            }
            set {
                if (value != null && !(value is IList || value is IListSource))
                    throw new Exception(SR.GetString(SR.BadDataSourceForComplexBinding));
                if (dataSource == value)
                    return;
                // When we change the dataSource to null, we should reset
                // the displayMember to "". See ASURT 85662.
                try {
                    SetDataConnection(value, displayMember, false);
                } catch (Exception) {
                    // If we get an exception while setting the dataSource;
                    // reset the DisplayMember to "".
                    // this will work because if the displayMember is set to "" before
                    // setting the dataConnection, then SetDataConnection should not fail.
                    // we need to make sure that when we set the dataSource the dataManager
                    // will be up to date wrt the new dataSource.
                    Debug.Assert(!"".Equals(this.DisplayMember), "SetDataConnection should not fail w/ an empty DisplayMember");
                    DisplayMember = "";
                }
                if (value == null)
                    DisplayMember = "";
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataSourceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ListControlOnDataSourceChangedDescr)]
        public event EventHandler DataSourceChanged {
            add {
                Events.AddHandler(EVENT_DATASOURCECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DATASOURCECHANGED, value);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataManager"]/*' />
        protected CurrencyManager DataManager {
            get {
                return this.dataManager;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DisplayMember"]/*' />
        /// <devdoc>
        ///     If the ListBox contains objects that support properties, this indicates
        ///     which property of the object to show.  If "", the object shows it's ToString().
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DefaultValue(""),
        TypeConverterAttribute("System.Windows.Forms.Design.DataMemberFieldConverter, " + AssemblyRef.SystemDesign),
        Editor("System.Windows.Forms.Design.DataMemberFieldEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor)),
        SRDescription(SR.ListControlDisplayMemberDescr)
        ]
        public string DisplayMember {
            get {
                return displayMember.BindingMember;
            }
            set {
                BindingMemberInfo oldDisplayMember = displayMember;
                try {
                    SetDataConnection(dataSource, new BindingMemberInfo(value), false);
                } catch (Exception) {
                    displayMember = oldDisplayMember;
                }
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DisplayMemberChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ListControlOnDisplayMemberChangedDescr)]
        public event EventHandler DisplayMemberChanged {
            add {
                Events.AddHandler(EVENT_DISPLAYMEMBERCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DISPLAYMEMBERCHANGED, value);
            }
        }

        private bool BindingMemberInfoInDataManager(BindingMemberInfo bindingMemberInfo) {
            if (dataManager == null)
                return false;
            PropertyDescriptorCollection props = dataManager.GetItemProperties();
            int propsCount = props.Count;
            bool fieldFound = false;

            for (int i = 0; i < propsCount; i++) {
                if (typeof(IList).IsAssignableFrom(props[i].PropertyType))
                    continue;
                if (props[i].Name.Equals(bindingMemberInfo.BindingField)) {
                    fieldFound = true;
                    break;
                }
            }

            return fieldFound;
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.ValueMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DefaultValue(""),
        Editor("System.Windows.Forms.Design.DataMemberFieldEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor)),
        SRDescription(SR.ListControlValueMemberDescr)
        ]
        public string ValueMember {
            get {
                return valueMember.BindingMember;
            }
            set {
                if (value == null)
                    value = "";
                BindingMemberInfo newValueMember = new BindingMemberInfo(value);
                BindingMemberInfo oldValueMember = valueMember;
                if (!newValueMember.Equals(valueMember)) {
                    // If the displayMember is set to the EmptyString, then recreate the dataConnection
                    //
                    if (DisplayMember.Length == 0)
                        SetDataConnection(DataSource, newValueMember, false);
                    // See if the valueMember is a member of 
                    // the properties in the dataManager
                    if (this.dataManager != null && !"".Equals(value))
                        if (!BindingMemberInfoInDataManager(newValueMember)) {
                            throw new ArgumentException(SR.GetString(SR.ListControlWrongValueMember), "value");
                        }

                    valueMember = newValueMember;
                    OnValueMemberChanged(EventArgs.Empty);
                    OnSelectedValueChanged(EventArgs.Empty);
                }
            }
        }        

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.ValueMemberChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ListControlOnValueMemberChangedDescr)]
        public event EventHandler ValueMemberChanged {
            add {
                Events.AddHandler(EVENT_VALUEMEMBERCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_VALUEMEMBERCHANGED, value);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract int SelectedIndex {
            get;
            set;
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DefaultValue(null),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListControlSelectedValueDescr),
        Bindable(true)
        ]        
        public object SelectedValue {
            get {
                if (SelectedIndex != -1 && dataManager != null ) {
                    object currentItem = dataManager[SelectedIndex];
                    object filteredItem = FilterItemOnProperty(currentItem, valueMember.BindingField);
                    return filteredItem;
                }
                return null;
            }
            set {
                if (dataManager != null) {
                    string propertyName = valueMember.BindingField;
                    // we can't set the SelectedValue property when the listManager does not
                    // have a ValueMember set.
                    if (propertyName.Equals(String.Empty))
                        throw new Exception(SR.GetString(SR.ListControlEmptyValueMemberInSettingSelectedValue));
                    PropertyDescriptorCollection props = dataManager.GetItemProperties();
                    PropertyDescriptor property = props.Find(propertyName, true);
                    int index = dataManager.Find(property, value, true);
                    changingLinkedSelection = true;
                    this.SelectedIndex = index;
                    changingLinkedSelection = false;
                }
            }
        }
        
        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedValueChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ListControlOnSelectedValueChangedDescr)]
        public event EventHandler SelectedValueChanged {
            add {
                Events.AddHandler(EVENT_SELECTEDVALUECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SELECTEDVALUECHANGED, value);
            }
        }

        private void DataManager_PositionChanged(object sender, EventArgs e) {
            if (this.dataManager != null) {
                this.SelectedIndex = dataManager.Position;
            }
        }

        private void DataManager_ItemChanged(object sender, ItemChangedEventArgs e) {
            // Note this is being called internally with a null event.
            if (dataManager != null) {
                if (e.Index == -1) {
                    SetItemsCore(dataManager.List);
                    this.SelectedIndex = this.dataManager.Position;
                }
                else {
                    SetItemCore(e.Index, dataManager[e.Index]);
                }
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.FilterItemOnProperty"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object FilterItemOnProperty(object item) {
            return FilterItemOnProperty(item, displayMember.BindingField);
        }
        
        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.FilterItemOnProperty1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object FilterItemOnProperty(object item, string field) {
            if (item != null && field.Length > 0) {
                try {
                    // if we have a dataSource, then use that to display the string
                    PropertyDescriptor descriptor;
                    if (this.dataManager != null)
                        descriptor = this.dataManager.GetItemProperties().Find(field, true);
                    else
                        descriptor = TypeDescriptor.GetProperties(item).Find(field, true);
                    if (descriptor != null) {
                        item = descriptor.GetValue(item);
                    }
                }
                catch (Exception) {
                }
            }
            return item;
        }

        //We use  this to prevent getting the selected item when mouse is hovering over the dropdown.
        //
        internal bool BindingFieldEmpty { 
            get {
                return (displayMember.BindingField.Length > 0 ? false : true);
            }

        }
        
        internal int FindStringInternal(string str, IList items, int startIndex, bool exact) {
        
            // Sanity check parameters
            //
            if (str == null || items == null) {
                return -1;
            }
            if (startIndex < -1 || startIndex >= items.Count - 1) {
                return -1;
            }
        
            bool found = false;
            int length = str.Length;
            
            int index = startIndex;
            do {
                index++;
                if (exact) {
                    found = String.Compare(str, GetItemText(items[index]), true, CultureInfo.CurrentCulture) == 0;
                }
                else {
                    found = String.Compare(str, 0, GetItemText(items[index]), 0, length, true, CultureInfo.CurrentCulture) == 0;
                }
                
                if (found) {
                    return index;
                }
                
                if (index == items.Count - 1) {
                    index = -1;
                }
            }
            while (index != startIndex);
            
            return -1;
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.GetItemText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetItemText(object item) {
            item = FilterItemOnProperty(item, displayMember.BindingField);
            return (item != null) ? Convert.ToString(item, CultureInfo.CurrentCulture) : "";
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.IsInputKey"]/*' />
        /// <devdoc>
        ///      Handling special input keys, such as pgup, pgdown, home, end, etc...
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                    return true;
            }
            return base.IsInputKey(keyData);
        }
  
        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnBindingContextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBindingContextChanged(EventArgs e) {
            SetDataConnection(dataSource, displayMember, true);
            
            base.OnBindingContextChanged(e);
        }


        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnDataSourceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnDataSourceChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_DATASOURCECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnDisplayMemberChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnDisplayMemberChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_DISPLAYMEMBERCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }
        
        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the selectedIndexChanged event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler on yourself for this event].  They should,
        ///     however, remember to call base.OnSelectedIndexChanged(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected virtual void OnSelectedIndexChanged(EventArgs e) {
            if (!changingLinkedSelection) {
                OnSelectedValueChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnValueMemberChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnValueMemberChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_VALUEMEMBERCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnSelectedValueChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSelectedValueChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_SELECTEDVALUECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.RefreshItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void RefreshItem(int index);
        
        private void DataSourceDisposed(object sender, EventArgs e) {
            Debug.Assert(sender == this.dataSource, "how can we get dispose notification for anything other than our dataSource?");
            SetDataConnection(null, new BindingMemberInfo(""), true);
        }

        private void SetDataConnection(object newDataSource, BindingMemberInfo newDisplayMember, bool force) {
            bool dataSourceChanged = dataSource != newDataSource;
            bool displayMemberChanged = !displayMember.Equals(newDisplayMember);

            // make sure something interesting is happening...
            //
            //force = force && (dataSource != null || newDataSource != null);
            
            if (force || dataSourceChanged || displayMemberChanged) {

                // If the source is a component, then hook the Disposed event,
                // so we know when the component is deleted from the form
                if (this.dataSource is IComponent) {
                    ((IComponent) dataSource).Disposed -= new EventHandler(DataSourceDisposed);
                }

                dataSource = newDataSource;
                displayMember = newDisplayMember;

                if (this.dataSource is IComponent) {
                    ((IComponent) dataSource).Disposed += new EventHandler(DataSourceDisposed);
                }

                CurrencyManager newDataManager = null;
                if (newDataSource != null && BindingContext != null && !(newDataSource == Convert.DBNull)) {
                    newDataManager = (CurrencyManager) BindingContext[newDataSource, newDisplayMember.BindingPath];
                }
                
                if (dataManager != newDataManager) {
                    if (dataManager != null) {
                        dataManager.ItemChanged -= new ItemChangedEventHandler(DataManager_ItemChanged);
                        dataManager.PositionChanged -= new EventHandler(DataManager_PositionChanged);
                    }
                    
                    dataManager = newDataManager;
                    
                    if (dataManager != null) {
                        dataManager.ItemChanged += new ItemChangedEventHandler(DataManager_ItemChanged);
                        dataManager.PositionChanged += new EventHandler(DataManager_PositionChanged);
                    }                    
                }

                // See if the BindingField in the newDisplayMember is valid
                // The same thing if dataSource Changed
                // "" is a good value for displayMember
                if (dataManager != null && (displayMemberChanged || dataSourceChanged) && !"".Equals(displayMember.BindingMember)) {

                    if (!BindingMemberInfoInDataManager(displayMember))
                        throw new ArgumentException(SR.GetString(SR.ListControlWrongDisplayMember), "newDisplayMember");
                }

                if (dataManager != null && (dataSourceChanged || displayMemberChanged || force))
                    DataManager_ItemChanged(dataManager, new ItemChangedEventArgs(-1));
            }        

                        
            if (dataSourceChanged) {
                OnDataSourceChanged(EventArgs.Empty);
            }            

            if (displayMemberChanged) {
                OnDisplayMemberChanged(EventArgs.Empty);
            }                        
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SetItemsCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void SetItemsCore(IList items);

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SetItemCore"]/*' />
        /// <internalonly/>
        protected virtual void SetItemCore(int index, object value) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
      using System.Security;
    using System.Security.Permissions;
    using System.Globalization;
    using System.Windows.Forms;

    using System.Drawing.Design;
    using System.ComponentModel;
    using System.Windows.Forms.ComponentModel;

    using System.Collections;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Text;

    /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox"]/*' />
    /// <devdoc>
    ///
    ///     This is a control that presents a list of items to the user.  They may be
    ///     navigated using the keyboard, or the scrollbar on the right side of the
    ///     control.  One or more items may be selected as well.
    /// <para>
    ///
    ///     The preferred way to add items is to set them all via an array at once,
    ///     which is definitely the most efficient way.  The following is an example
    ///     of this:
    /// </para>
    /// <code>
    ///     ListBox lb = new ListBox();
    ///     //     set up properties on the listbox here.
    ///     lb.Items.All = new String [] {
    ///     "A",
    ///     "B",
    ///     "C",
    ///     "D"};
    /// </code>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.ListBoxDesigner, " + AssemblyRef.SystemDesign),
    DefaultEvent("SelectedIndexChanged"),
    DefaultProperty("Items")
    ]
    public class ListBox : ListControl {
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.NoMatches"]/*' />
        /// <devdoc>
        ///     while doing a search, if no matches are found, this is returned
        /// </devdoc>
        public const int NoMatches = NativeMethods.LB_ERR;
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.DefaultItemHeight"]/*' />
        /// <devdoc>
        ///     The default item height for an owner-draw ListBox.
        /// </devdoc>
        public const int DefaultItemHeight = 13; // 13 == listbox's non-ownerdraw item height.  That's with Win2k and 
        // the default font; on other platforms and with other fonts, it may be different.

        private static readonly object EVENT_SELECTEDINDEXCHANGED = new object();
        private static readonly object EVENT_DRAWITEM             = new object();
        private static readonly object EVENT_MEASUREITEM          = new object();
        
        static bool checkedOS = false;
        static bool runningOnWin2K = true;

        SelectedObjectCollection selectedItems;
        SelectedIndexCollection selectedIndices;
        ObjectCollection itemsCollection;
        
        // UNDONE (brianpe/soak): Compact all these into a PropStore.
        //
        int itemHeight = DefaultItemHeight;
        int columnWidth;
        int requestedHeight;
        int topIndex;
        int horizontalExtent = 0;
        int maxWidth = -1;
        int updateCount = 0;

        bool sorted = false;
        bool scrollAlwaysVisible = false;
        bool integralHeight = true;
        bool integralHeightAdjust = false;
        bool multiColumn = false;
        bool horizontalScrollbar = false;
        bool useTabStops = true;
        bool fontIsChanged = false;
        bool doubleClickFired = false;
        bool selectedValueChangedFired = false;

        DrawMode drawMode = System.Windows.Forms.DrawMode.Normal;
        BorderStyle borderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
        SelectionMode selectionMode = System.Windows.Forms.SelectionMode.One;
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ListBox"]/*' />
        /// <devdoc>
        ///     Creates a basic win32 list box with default values for everything.
        /// </devdoc>
        public ListBox() : base() {
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.StandardClick, false);
            SetBounds(0, 0, 120, 96);
            
            requestedHeight = Height;
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.BackColor"]/*' />
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }
            set {
                base.BackColor = value;
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.BorderStyle"]/*' />
        /// <devdoc>
        ///     Retrieves the current border style.  Values for this are taken from
        ///     The System.Windows.Forms.BorderStyle enumeration.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.Fixed3D),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.ListBoxBorderDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }

                if (value != borderStyle) {
                    borderStyle = value;
                    RecreateHandle();
                    // Avoid the listbox and textbox behavior in Collection editors
                    //
                    integralHeightAdjust = true;
                    try {
                        Height = requestedHeight;
                    }
                    finally {
                        integralHeightAdjust = false;
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ColumnWidth"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(0),
        SRDescription(SR.ListBoxColumnWidthDescr)
        ]
        public int ColumnWidth {
            get {
                return columnWidth;
            }

            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value",
                                                             (value).ToString(), "0"));
                }
                if (columnWidth != value) {
                    columnWidth = value;
                    // if it's zero, we need to reset, and only way to do
                    // that is to recreate the handle.
                    if (columnWidth == 0) {
                        RecreateHandle();
                    }
                    else if (IsHandleCreated) {
                        SendMessage(NativeMethods.LB_SETCOLUMNWIDTH, columnWidth, 0);
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.CreateParams"]/*' />
        /// <devdoc>
        ///     Retrieves the parameters needed to create the handle.  Inheriting classes
        ///     can override this to provide extra functionality.  They should not,
        ///     however, forget to call base.getCreateParams() first to get the struct
        ///     filled up with the basic info.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "LISTBOX";

                cp.Style |= NativeMethods.WS_VSCROLL | NativeMethods.LBS_NOTIFY | NativeMethods.LBS_HASSTRINGS;
                if (scrollAlwaysVisible) cp.Style |= NativeMethods.LBS_DISABLENOSCROLL;
                if (!integralHeight) cp.Style |= NativeMethods.LBS_NOINTEGRALHEIGHT;
                if (useTabStops) cp.Style |= NativeMethods.LBS_USETABSTOPS;

                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }

                if (multiColumn) {
                    cp.Style |= NativeMethods.LBS_MULTICOLUMN | NativeMethods.WS_HSCROLL;
                }
                else if (horizontalScrollbar) {
                    cp.Style |= NativeMethods.WS_HSCROLL;
                }                              
                
                switch (selectionMode) {
                    case SelectionMode.None:
                        cp.Style |= NativeMethods.LBS_NOSEL;
                        break;
                    case SelectionMode.MultiSimple:
                        cp.Style |= NativeMethods.LBS_MULTIPLESEL;
                        break;
                    case SelectionMode.MultiExtended:
                        cp.Style |= NativeMethods.LBS_EXTENDEDSEL;
                        break;
                    case SelectionMode.One:
                        break;
                }

                switch (drawMode) {
                    case DrawMode.Normal:
                        break;
                    case DrawMode.OwnerDrawFixed:
                        cp.Style |= NativeMethods.LBS_OWNERDRAWFIXED;
                        break;
                    case DrawMode.OwnerDrawVariable:
                        cp.Style |= NativeMethods.LBS_OWNERDRAWVARIABLE;
                        break;
                }

                return cp;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.DefaultSize"]/*' />
        protected override Size DefaultSize {
            get {
                return new Size(120, 96);
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.DrawMode"]/*' />
        /// <devdoc>
        ///     Retrieves the style of the listbox.  This will indicate if the system
        ///     draws it, or if the user paints each item manually.  It also indicates
        ///     whether or not items have to be of the same height.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DrawMode.Normal),
        SRDescription(SR.ListBoxDrawModeDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public virtual DrawMode DrawMode {
            get {
                return drawMode;
            }

            set {
                if (!Enum.IsDefined(typeof(DrawMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DrawMode));
                }
                if (drawMode != value) {
                    if (MultiColumn && value == DrawMode.OwnerDrawVariable) {
                        throw new ArgumentException(SR.GetString(SR.ListBoxVarHeightMultiCol), "value");
                    }
                    drawMode = value;
                    RecreateHandle();
                }
            }
        }
        
        // Used internally to find the currently focused item
        //
        internal int FocusedIndex {
            get {
                if (IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.LB_GETCARETINDEX, 0, 0);
                }
                
                return -1;
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ForeColor"]/*' />
        public override Color ForeColor {
            get {
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.HorizontalExtent"]/*' />
        /// <devdoc>
        ///     Indicates the width, in pixels, by which a list box can be scrolled horizontally (the scrollable width).        
        ///     This property will only have an effect if HorizontalScrollbars is true. 
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        Localizable(true),
        SRDescription(SR.ListBoxHorizontalExtentDescr)
        ]
        public int HorizontalExtent {
            get {
                return horizontalExtent;
            }

            set {
                if (value != horizontalExtent) {
                    horizontalExtent = value;
                    UpdateHorizontalExtent();
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.HorizontalScrollbar"]/*' />
        /// <devdoc>
        ///     Indicates whether or not the ListBox should display a horizontal scrollbar
        ///     when the items extend beyond the right edge of the ListBox.   
        ///     If true, the scrollbar will automatically set its extent depending on the length
        ///     of items in the ListBox. The exception is if the ListBox is owner-draw, in
        ///     which case HorizontalExtent will need to be explicitly set.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        Localizable(true),
        SRDescription(SR.ListBoxHorizontalScrollbarDescr)
        ]
        public bool HorizontalScrollbar {
            get {
                return horizontalScrollbar;
            }

            set {
                if (value != horizontalScrollbar) {
                    horizontalScrollbar = value;
                    
                    // Only need to recreate the handle if not MultiColumn
                    // (HorizontalScrollbar has no effect on a MultiColumn listbox)
                    //
                    if (!MultiColumn) {
                        RecreateHandle();
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.IntegralHeight"]/*' />
        /// <devdoc>
        ///     Indicates if the listbox should avoid showing partial Items.  If so,
        ///     then only full items will be displayed, and the listbox will be resized
        ///     to prevent partial items from being shown.  Otherwise, they will be
        ///     shown
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ListBoxIntegralHeightDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public bool IntegralHeight {
            get {
                return integralHeight;
            }

            set {
                if (integralHeight != value) {
                    integralHeight = value;
                    RecreateHandle();
                    // Avoid the listbox and textbox behaviour in Collection editors
                    //

                    integralHeightAdjust = true;
                    try {
                        Height = requestedHeight;
                    }
                    finally {
                        integralHeightAdjust = false;
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ItemHeight"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Returns
        ///       the height of an item in an owner-draw list box.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DefaultItemHeight),
        Localizable(true),
        SRDescription(SR.ListBoxItemHeightDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public virtual int ItemHeight {
            get {
                if (drawMode == DrawMode.OwnerDrawFixed ||
                    drawMode == DrawMode.OwnerDrawVariable) {
                    return itemHeight;
                }
                
                return GetItemHeight(0);
            }

            set {
                if (value < 1 || value > 255) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidExBoundArgument,
                                                              "value", (value).ToString(), "0", "256"));
                }
                if (itemHeight != value) {
                    itemHeight = value;
                    if (drawMode == DrawMode.OwnerDrawFixed && IsHandleCreated) {
                        BeginUpdate();
                        SendMessage(NativeMethods.LB_SETITEMHEIGHT, 0, value);
                        
                        // Changing the item height might require a resize for IntegralHeight list boxes
                        //
                        if (IntegralHeight) {
                            Size oldSize = Size;
                            Size = new Size(oldSize.Width + 1, oldSize.Height);
                            Size = oldSize;
                        }
                        
                        EndUpdate();
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.Items"]/*' />
        /// <devdoc>
        ///     Collection of items in this listbox.
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        Localizable(true),
        SRDescription(SR.ListBoxItemsDescr),
        Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        public ObjectCollection Items {
            get {
                if (itemsCollection == null) {
                    itemsCollection = CreateItemCollection();
                }
                return itemsCollection;
            }
        }
        
        // Computes the maximum width of all items in the ListBox
        //             
        internal virtual int MaxItemWidth {
            get {

                if (horizontalExtent > 0) {
                    return horizontalExtent;
                }

                if (DrawMode != DrawMode.Normal) {
                    return -1;
                }

                // Return cached maxWidth if available
                //
                if (maxWidth > -1) {
                    return maxWidth;
                }

                // Compute maximum width
                //
                maxWidth = ComputeMaxItemWidth(maxWidth);

                return maxWidth;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.MultiColumn"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates if the listbox is multi-column
        ///       or not.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ListBoxMultiColumnDescr)
        ]
        public bool MultiColumn {
            get {
                return multiColumn;
            }
            set {
                if (multiColumn != value) {
                    if (value && drawMode == DrawMode.OwnerDrawVariable) {
                        throw new ArgumentException(SR.GetString(SR.ListBoxVarHeightMultiCol), "value");
                    }
                    multiColumn = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.PreferredHeight"]/*' />
        /// <devdoc>
        ///     The total height of the items in the list box.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListBoxPreferredHeightDescr)
        ]
        public int PreferredHeight {
            get {
                int height = 0;
            
                if (drawMode == DrawMode.OwnerDrawVariable) {
                    if (itemsCollection != null) {
                        int cnt = itemsCollection.Count;
                        for (int i = 0; i < cnt; i++) {
                            height += GetItemHeight(i);
                        }
                    }
                }
                else {
                    int cnt = (itemsCollection == null) ? 0 : itemsCollection.Count;
                    height = GetItemHeight(0) * cnt;
                }
                
                if (borderStyle != BorderStyle.None) {
                    height += SystemInformation.BorderSize.Height * 4 + 3;
                }
                
                return height;
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.RightToLeft"]/*' />
        public override RightToLeft RightToLeft {
            get {
                if (!RunningOnWin2K) {
                    return RightToLeft.No;
                }
                return base.RightToLeft;
            }
            set {
                base.RightToLeft = value;
            }
        }
        
        static bool RunningOnWin2K {
            get {
                if (!checkedOS) {
                    new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                    try {
                        if (Environment.OSVersion.Platform != System.PlatformID.Win32NT || 
                            Environment.OSVersion.Version.Major < 5) {
                            runningOnWin2K = false;
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                return runningOnWin2K;
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ScrollAlwaysVisible"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets or sets whether the scrollbar is shown at all times.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        Localizable(true),
        SRDescription(SR.ListBoxScrollIsVisibleDescr)
        ]
        public bool ScrollAlwaysVisible {
            get {
                return scrollAlwaysVisible;
            }
            set {
                if (scrollAlwaysVisible != value) {
                    scrollAlwaysVisible = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndex"]/*' />
        /// <devdoc>
        ///     The index of the currently selected item in the list, if there
        ///     is one.  If the value is -1, there is currently no selection.  If the
        ///     value is 0 or greater, than the value is the index of the currently
        ///     selected item.  If the MultiSelect property on the ListBox is true,
        ///     then a non-zero value for this property is the index of the first
        ///     selection
        /// </devdoc>
        [
        Browsable(false),
        Bindable(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListBoxSelectedIndexDescr)
        ]
        public override int SelectedIndex {
            get {
                if (selectionMode == SelectionMode.None) {
                    return -1;
                }
                
                if (selectionMode == SelectionMode.One && IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.LB_GETCURSEL, 0, 0);
                }
                
                if (itemsCollection != null && SelectedItems.Count > 0) {    
                    return Items.IndexOfIdentifier(SelectedItems.GetObjectAt(0));
                }
                
                return -1;
            }
            set {
            
                int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;
                
                if (value < -1 || value >= itemCount) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "value", (value).ToString()));
                }
                    
                if (selectionMode == SelectionMode.None) {
                    throw new ArgumentException(SR.GetString(SR.ListBoxInvalidSelectionMode), "value");
                }
                
                if (selectionMode == SelectionMode.One && value != -1) {
                
                    // Single select an individual value.  
                    int currentIndex = SelectedIndex;
                    
                    if (currentIndex != value) {
                        if (currentIndex != -1) {
                            SelectedItems.SetSelected(currentIndex, false);
                        }
                        SelectedItems.SetSelected(value, true);
                        
                        if (IsHandleCreated) {
                            NativeSetSelected(value, true);
                        }
                        
                        OnSelectedIndexChanged(EventArgs.Empty);
                    }
                }
                else if (value == -1) {
                    if (SelectedIndex != -1) {
                        ClearSelected();
                        // ClearSelected raises OnSelectedIndexChanged for us
                    }
                }
                else {
                    if (!SelectedItems.GetSelected(value)) {
                        
                        // Select this item while keeping any previously selected items selected.
                        //
                        SelectedItems.SetSelected(value, true);
                        if (IsHandleCreated) {
                            NativeSetSelected(value, true);
                        }
                        OnSelectedIndexChanged(EventArgs.Empty);
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndices"]/*' />
        /// <devdoc>
        ///     A collection of the indices of the selected items in the
        ///     list box. If there are no selected items in the list box, the result is
        ///     an empty collection.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListBoxSelectedIndicesDescr)
        ]
        public SelectedIndexCollection SelectedIndices {
            get {
                if (selectedIndices == null) {
                    selectedIndices = new SelectedIndexCollection(this);
                }
                return selectedIndices;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedItem"]/*' />
        /// <devdoc>
        ///     The value of the currently selected item in the list, if there
        ///     is one.  If the value is null, there is currently no selection.  If the
        ///     value is non-null, then the value is that of the currently selected
        ///     item. If the MultiSelect property on the ListBox is true, then a
        ///     non-null return value for this method is the value of the first item
        ///     selected
        /// </devdoc>
        [
        Browsable(false),
        Bindable(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListBoxSelectedItemDescr)
        ]
        public object SelectedItem {
            get {
                if (SelectedItems.Count > 0) {
                    return SelectedItems[0];
                }
                
                return null;
            }
            set {
                if (itemsCollection != null) {
                    if (value != null) {
                        int index = itemsCollection.IndexOf(value);
                        if (index != -1) {
                            SelectedIndex = index;
                        }
                    }
                    else {
                        SelectedIndex = -1;
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedItems"]/*' />
        /// <devdoc>
        ///     The collection of selected items.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListBoxSelectedItemsDescr)
        ]
        public SelectedObjectCollection SelectedItems {
            get {
                if (selectedItems == null) {
                    selectedItems = new SelectedObjectCollection(this);
                }
                return selectedItems;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectionMode"]/*' />
        /// <devdoc>
        ///     Controls how many items at a time can be selected in the listbox. Valid
        ///     values are from the System.Windows.Forms.SelectionMode enumeration.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(SelectionMode.One),
        SRDescription(SR.ListBoxSelectionModeDescr)
        ]
        public virtual SelectionMode SelectionMode {
            get {
                return selectionMode;
            }
            set {
                if (!Enum.IsDefined(typeof(SelectionMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(SelectionMode));
                }

                if (selectionMode != value) {
                    SelectedItems.EnsureUpToDate();
                    selectionMode = value;

                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.Sorted"]/*' />
        /// <devdoc>
        ///     Indicates if the ListBox is sorted or not.  'true' means that strings in
        ///     the list will be sorted alphabetically
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ListBoxSortedDescr)
        ]
        public bool Sorted {
            get {
                return sorted;
            }
            set {
                if (sorted != value) {
                    sorted = value;

                    if (sorted && itemsCollection != null && itemsCollection.Count > 1) {
                        Sort();                        
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        Bindable(false)
        ]
        public override string Text {
            get {
                if (SelectionMode != SelectionMode.None && SelectedItem != null) {
                    return FilterItemOnProperty(SelectedItem).ToString();
                }
                else {
                    return base.Text;
                }
            }
            set {
                base.Text = value;                                                          
                
                // Scan through the list items looking for the supplied text string.  If we find it,
                // select it.
                //
                if (SelectionMode != SelectionMode.None && value != null && (SelectedItem == null || !value.Equals(GetItemText(SelectedItem)))) {
                    
                    int cnt = Items.Count;
                    for (int index=0; index < cnt; ++index) {
                        if (String.Compare(value, GetItemText(Items[index]), true, CultureInfo.CurrentCulture) == 0) {
                            SelectedIndex = index;
                            return;
                        }
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.TopIndex"]/*' />
        /// <devdoc>
        ///     The index of the first visible item in a list box. Initially
        ///     the item with index 0 is at the top of the list box, but if the list
        ///     box contents have been scrolled another item may be at the top.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListBoxTopIndexDescr)
        ]
        public int TopIndex {
            get {
                if (IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.LB_GETTOPINDEX, 0, 0);
                }
                else {
                    return topIndex;
                }
            }
            set {
                if (IsHandleCreated) {
                    SendMessage(NativeMethods.LB_SETTOPINDEX, value, 0);
                }
                else {
                    topIndex = value;
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.UseTabStops"]/*' />
        /// <devdoc>
        ///     Enables a list box to recognize and expand tab characters when drawing
        ///     its strings.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.ListBoxUseTabStopsDescr)
        ]
        public bool UseTabStops {
            get {
                return useTabStops;
            }
            set {
                if (useTabStops != value) {
                    useTabStops = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.AddItemsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of adding the specified items to the Listbox
        /// </devdoc>
        protected virtual void AddItemsCore(object[] value) {
            int count = value == null? 0: value.Length;
            if (count == 0) {
                return;
            }

            Items.AddRangeInternal(value);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.Click"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnPaint"]/*' />
        /// <devdoc>
        ///     ListBox / CheckedListBox Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.DrawItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.drawItemEventDescr)]
        public event DrawItemEventHandler DrawItem {
            add {
                Events.AddHandler(EVENT_DRAWITEM, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DRAWITEM, value);
            }
        }        


        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.MeasureItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.measureItemEventDescr)]
        public event MeasureItemEventHandler MeasureItem {
            add {
                Events.AddHandler(EVENT_MEASUREITEM, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MEASUREITEM, value);
            }
        }        


        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.selectedIndexChangedEventDescr)]
        public event EventHandler SelectedIndexChanged {
            add {
                Events.AddHandler(EVENT_SELECTEDINDEXCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SELECTEDINDEXCHANGED, value);
            }
        }        

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.BeginUpdate"]/*' />
        /// <devdoc>
        ///     While the preferred way to insert items is to set Items.All,
        ///     and set all the items at once, there are times when you may wish to
        ///     insert each item one at a time.  To help with the performance of this,
        ///     it is desirable to prevent the ListBox from painting during these
        ///     operations.  This method, along with EndUpdate, is the preferred
        ///     way of doing this.  Don't forget to call EndUpdate when you're done,
        ///     or else the ListBox won't paint properly afterwards.
        /// </devdoc>
        public void BeginUpdate() {
            BeginUpdateInternal();
            updateCount++;
        }

        private void CheckIndex(int index) {
            if (index < 0 || index >= Items.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.IndexOutOfRange, index.ToString()));
        }

        private void CheckNoDataSource() {
            if (DataSource != null)
                throw new ArgumentException(SR.GetString(SR.DataSourceLocksItems));
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.CreateItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual ObjectCollection CreateItemCollection() {
            return new ObjectCollection(this);
        }
        
        internal virtual int ComputeMaxItemWidth(int oldMax) {
            int maxItemWidth = oldMax;

            IntPtr hdc = UnsafeNativeMethods.GetDC(new HandleRef(this, Handle));
            IntPtr oldFont = SafeNativeMethods.SelectObject(new HandleRef(this, hdc), new HandleRef(this, FontHandle));

            try {
                NativeMethods.RECT rect = new NativeMethods.RECT();

                foreach(object item in Items) {

                    SafeNativeMethods.DrawText(new HandleRef(this, hdc), item.ToString(), item.ToString().Length, ref rect, NativeMethods.DT_CALCRECT);
                    int width = rect.right - rect.left;

                    if (width > maxItemWidth) {
                        maxItemWidth = width;
                    }
                }
            }
            finally {
                SafeNativeMethods.SelectObject(new HandleRef(this, hdc), new HandleRef(this, oldFont));
                UnsafeNativeMethods.ReleaseDC(new HandleRef(this, Handle), new HandleRef(this, hdc));
            }
            return maxItemWidth;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ClearSelected"]/*' />
        /// <devdoc>
        ///     Unselects all currently selected items.
        /// </devdoc>                               
        public void ClearSelected() {
        
            bool hadSelection = false;
            
            int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;
            for (int x = 0; x < itemCount;x++) {
                if (SelectedItems.GetSelected(x)) {
                    hadSelection = true;
                    SelectedItems.SetSelected(x, false);
                    if (IsHandleCreated) {
                        NativeSetSelected(x, false);
                    }
                }
            }
            
            if (hadSelection) {
                OnSelectedIndexChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.EndUpdate"]/*' />
        /// <devdoc>
        ///     While the preferred way to insert items is to set Items.All,
        ///     and set all the items at once, there are times when you may wish to
        ///     insert each item one at a time.  To help with the performance of this,
        ///     it is desirable to prevent the ListBox from painting during these
        ///     operations.  This method, along with BeginUpdate, is the preferred
        ///     way of doing this.  BeginUpdate should be called first, and this method
        ///     should be called when you want the control to start painting again.
        /// </devdoc>
        public void EndUpdate() {
            EndUpdateInternal();
            --updateCount;
            
            // Get the itemCount and call Sort only if the ListBox contains More than 1 item...
            // bug # 108910... where Sort is Called thru EndUpdate ... with ni items in the Listbox...
            int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;
            if (updateCount == 0 && this.sorted && itemCount > 1) {
                Sort();
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.FindString"]/*' />
        /// <devdoc>
        ///     Finds the first item in the list box that starts with the given string.
        ///     The search is not case sensitive.
        /// </devdoc>
        public int FindString(string s) {
            return FindString(s, -1);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.FindString1"]/*' />
        /// <devdoc>
        ///     Finds the first item after the given index which starts with the given
        ///     string. The search is not case sensitive.
        /// </devdoc>
        public int FindString(string s, int startIndex) {
            if (s == null) return -1;

            int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;
            
            if (itemCount == 0) {
                return -1;
            }
            
            if (startIndex < -1 || startIndex >= itemCount - 1) {
                throw new ArgumentOutOfRangeException("startIndex");
            }

            // Always use the managed FindStringInternal instead of LB_FINDSTRING.
            // The managed version correctly handles Turkish I.
            return FindStringInternal(s, Items, startIndex, false);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.FindStringExact"]/*' />
        /// <devdoc>
        ///     Finds the first item in the list box that matches the given string.
        ///     The strings must match exactly, except for differences in casing.
        /// </devdoc>
        public int FindStringExact(string s) {
            return FindStringExact(s, -1);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.FindStringExact1"]/*' />
        /// <devdoc>
        ///     Finds the first item after the given index that matches the given
        ///     string. The strings must match excatly, except for differences in
        ///     casing.
        /// </devdoc>
        public int FindStringExact(string s, int startIndex) {
            if (s == null) return -1;

            int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;
            
            if (itemCount == 0) {
                return -1;
            }
            
            if (startIndex < -1 || startIndex >= itemCount - 1) {
                throw new ArgumentOutOfRangeException("startIndex");
            }

            // Always use the managed FindStringInternal instead of LB_FINDSTRING.
            // The managed version correctly handles Turkish I.                
            //
            return FindStringInternal(s, Items, startIndex, true);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.GetItemHeight"]/*' />
        /// <devdoc>
        ///     Returns the height of the given item in a list box. The index parameter
        ///     is ignored if drawMode is not OwnerDrawVariable.
        /// </devdoc>
        public int GetItemHeight(int index) {
            int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;

            // Note: index == 0 is OK even if the ListBox currently has
            // no items.
            //
            if (index < 0 || (index > 0 && index >= itemCount))
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index", (index).ToString()));

            if (drawMode != DrawMode.OwnerDrawVariable) index = 0;

            if (IsHandleCreated) {
                int h = (int)SendMessage(NativeMethods.LB_GETITEMHEIGHT, index, 0);
                if (h == -1)
                    throw new Win32Exception();
                return h;
            }
            
            return itemHeight;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.GetItemRectangle"]/*' />
        /// <devdoc>
        ///     Retrieves a Rectangle object which describes the bounding rectangle
        ///     around an item in the list.  If the item in question is not visible,
        ///     the rectangle will be outside the visible portion of the control.
        /// </devdoc>
        public Rectangle GetItemRectangle(int index) {
            CheckIndex(index);
            NativeMethods.RECT rect = new NativeMethods.RECT();
            SendMessage(NativeMethods.LB_GETITEMRECT, index, ref rect);
            return Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.GetSelected"]/*' />
        /// <devdoc>
        ///     Tells you whether or not the item at the supplied index is selected
        ///     or not.
        /// </devdoc>
        public bool GetSelected(int index) {
            CheckIndex(index);
            return GetSelectedInternal(index);
        }
        
        private bool GetSelectedInternal(int index) {
            if (IsHandleCreated) {
                int sel = (int)SendMessage(NativeMethods.LB_GETSEL, index, 0);
                if (sel == -1) {
                    throw new Win32Exception();
                }
                return sel > 0;
            }
            else {
                if (itemsCollection != null && SelectedItems.GetSelected(index)) {
                    return true;
                }
                return false;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.IndexFromPoint"]/*' />
        /// <devdoc>
        ///     Retrieves the index of the item at the given coordinates.
        /// </devdoc>
        public int IndexFromPoint(Point p) {
            return IndexFromPoint(p.X, p.Y);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.IndexFromPoint1"]/*' />
        /// <devdoc>
        ///     Retrieves the index of the item at the given coordinates.
        /// </devdoc>
        public int IndexFromPoint(int x, int y) {
            //NT4 SP6A : SendMessage Fails. So First check whether the point is in Client Co-ordinates and then
            //call Sendmessage.
            //
            NativeMethods.RECT r = new NativeMethods.RECT();
            UnsafeNativeMethods.GetClientRect(new HandleRef(this, Handle), ref r);
            if (r.left <= x && x < r.right && r.top <= y && y < r.bottom) {
                int index = (int)SendMessage(NativeMethods.LB_ITEMFROMPOINT, 0, (int)NativeMethods.Util.MAKELPARAM(x, y));
                if (NativeMethods.Util.HIWORD(index) == 0) {
                    // Inside ListBox client area               
                    return NativeMethods.Util.LOWORD(index);
                }
            }

            return NoMatches;
        }

        /// <devdoc>
        ///     Adds the given item to the native combo box.  This asserts if the handle hasn't been
        ///     created.
        /// </devdoc>
        private int NativeAdd(object item) {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            int insertIndex = (int)SendMessage(NativeMethods.LB_ADDSTRING, 0, GetItemText(item));
            
            if (insertIndex == NativeMethods.LB_ERRSPACE) {
                throw new OutOfMemoryException();
            }
            
            if (insertIndex == NativeMethods.LB_ERR) {
                // On some platforms (e.g. Win98), the ListBox control
                // appears to return LB_ERR if there are a large number (>32000)
                // of items. It doesn't appear to set error codes appropriately,
                // so we'll have to assume that LB_ERR corresponds to item
                // overflow.
                //
                throw new OutOfMemoryException(SR.GetString(SR.ListBoxItemOverflow));
            }
            
            return insertIndex;
        }
        
        /// <devdoc>
        ///     Clears the contents of the combo box.
        /// </devdoc>
        private void NativeClear() {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            SendMessage(NativeMethods.LB_RESETCONTENT, 0, 0);
        }

        /// <devdoc>
        ///     Inserts the given item to the native combo box at the index.  This asserts if the handle hasn't been
        ///     created or if the resulting insert index doesn't match the passed in index.
        /// </devdoc>
        private int NativeInsert(int index, object item) {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            int insertIndex = (int)SendMessage(NativeMethods.LB_INSERTSTRING, index, GetItemText(item));
            
            if (insertIndex == NativeMethods.LB_ERRSPACE) {
                throw new OutOfMemoryException();
            }
            
            if (insertIndex == NativeMethods.LB_ERR) {
                // On some platforms (e.g. Win98), the ListBox control
                // appears to return LB_ERR if there are a large number (>32000)
                // of items. It doesn't appear to set error codes appropriately,
                // so we'll have to assume that LB_ERR corresponds to item
                // overflow.
                //
                throw new OutOfMemoryException(SR.GetString(SR.ListBoxItemOverflow));
            }
            
            Debug.Assert(insertIndex == index, "NativeListBox inserted at " + insertIndex + " not the requested index of " + index);
            return insertIndex;
        }
        
        /// <devdoc>
        ///     Removes the native item from the given index.
        /// </devdoc>
        private void NativeRemoveAt(int index) {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");

            bool selected = ((int)SendMessage(NativeMethods.LB_GETSEL, (IntPtr)index, IntPtr.Zero) > 0);
            SendMessage(NativeMethods.LB_DELETESTRING, index, 0);
            
            //If the item currently selected is removed then we should fire a Selectionchanged event...
            //as the next time selected index returns -1...

            if (selected) {
                OnSelectedIndexChanged(EventArgs.Empty);
            }
        }

        /// <devdoc>
        ///     Sets the selection of the given index to the native window.  This does not change
        ///     the collection; you must update the collection yourself.
        /// </devdoc>
        private void NativeSetSelected(int index, bool value) {
            Debug.Assert(IsHandleCreated, "Should only call Native methods after the handle has been created");
            Debug.Assert(selectionMode != SelectionMode.None, "Guard against setting selection for None selection mode outside this code.");
            
            if (selectionMode == SelectionMode.One) {
                SendMessage(NativeMethods.LB_SETCURSEL, (value ? index : -1), 0);
            }
            else {
                SendMessage(NativeMethods.LB_SETSEL, value? -1: 0, index);
            }
        }

        /// <devdoc>
        ///     This is called by the SelectedObjectCollection in response to the first
        ///     query on that collection after we have called Dirty().  Dirty() is called
        ///     when we receive a LBN_SELCHANGE message.
        /// </devdoc>
        private void NativeUpdateSelection() {
            Debug.Assert(IsHandleCreated, "Should only call native methods if handle is created");

            // Clear the selection state.
            //
            int cnt = Items.Count;
            for (int i = 0; i < cnt; i++) {
                SelectedItems.SetSelected(i, false);
            }
            
            int[] result = null;

            switch (selectionMode) {
            
                case SelectionMode.One:
                    int index = (int)SendMessage(NativeMethods.LB_GETCURSEL, 0, 0);
                    if (index >= 0) result = new int[] {index};
                    break;
                    
                case SelectionMode.MultiSimple:
                case SelectionMode.MultiExtended:
                    int count = (int)SendMessage(NativeMethods.LB_GETSELCOUNT, 0, 0);
                    if (count > 0) {
                        result = new int[count];
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LB_GETSELITEMS, count, result);
                    }
                    break;
            }
            
            // Now set the selected state on the appropriate items.
            //
            if (result != null) {
                foreach(int i in result) {
                    SelectedItems.SetSelected(i, true);
                }
            }
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnChangeUICues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnChangeUICues(UICuesEventArgs e) {
        
            // ListBox seems to get a bit confused when the UI cues change for the first
            // time - it draws the focus rect when it shouldn't and vice-versa. So when
            // the UI cues change, we just do an extra invalidate to get it into the 
            // right state.
            //
            Invalidate();
            
            base.OnChangeUICues(e);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnDrawItem"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the drawItem event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler yourself for this event].  They should,
        ///     however, remember to call base.onDrawItem(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected virtual void OnDrawItem(DrawItemEventArgs e) {
            DrawItemEventHandler handler = (DrawItemEventHandler)Events[EVENT_DRAWITEM];
            if (handler != null) {
                handler(this, e);
            }
        }

                
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     We need to know when the window handle has been created so we can
        ///     set up a few things, like column width, etc!  Inheriting classes should
        ///     not forget to call base.OnHandleCreated().
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            
            //for getting the current Locale to set the Scrollbars...
            //
            SendMessage(NativeMethods.LB_SETLOCALE, CultureInfo.CurrentCulture.LCID, 0);

            if (columnWidth != 0) {
                SendMessage(NativeMethods.LB_SETCOLUMNWIDTH, columnWidth, 0);
            }
            if (drawMode == DrawMode.OwnerDrawFixed) {
                SendMessage(NativeMethods.LB_SETITEMHEIGHT, 0, ItemHeight);
            }
            
            if (topIndex != 0) {
                SendMessage(NativeMethods.LB_SETTOPINDEX, topIndex, 0);
            }
            
            if (itemsCollection != null) {
            
                int count = itemsCollection.Count;
                
                for(int i = 0; i < count; i++) {
                    NativeAdd(itemsCollection[i]);
                    
                    if (selectionMode != SelectionMode.None) {
                        if (selectedItems != null && selectedItems.GetSelected(i)) {
                            NativeSetSelected(i, true);
                        }
                    }
                }
            }
            if (selectedItems != null) {
                if (selectedItems.Count > 0 && selectionMode == SelectionMode.One) {
                    SelectedItems.Dirty();
                    SelectedItems.EnsureUpToDate();
                }
            }
            UpdateHorizontalExtent();
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///     Overridden to make sure that we set up and clear out items
        ///     correctly.  Inheriting controls should not forget to call
        ///     base.OnHandleDestroyed()
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            SelectedItems.EnsureUpToDate();
            if (Disposing) {
                itemsCollection = null;
            }
            base.OnHandleDestroyed(e);
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnMeasureItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnMeasureItem(MeasureItemEventArgs e) {
            MeasureItemEventHandler handler = (MeasureItemEventHandler)Events[EVENT_MEASUREITEM];
            if (handler != null) {
                handler(this, e);
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);

            // Changing the font causes us to resize, always rounding down.
            // Make sure we do this after base.OnPropertyChanged, which sends the WM_SETFONT message
            
            // Avoid the listbox and textbox behaviour in Collection editors
            //
            fontIsChanged = true;
            integralHeightAdjust = true;
            try {
                Height = requestedHeight;
            }
            finally {
                integralHeightAdjust = false;
            }
            maxWidth = -1;
            UpdateHorizontalExtent();
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnParentChanged"]/*' />
        /// <devdoc>
        ///    <para>We override this so we can re-create the handle if the parent has changed.</para>
        /// </devdoc>
        protected override void OnParentChanged(EventArgs e) {
            base.OnParentChanged(e);
            //No need to RecreateHandle if we are removing the Listbox from controls collection...
            //so check the parent before recreating the handle...
            if (this.ParentInternal != null) {
                RecreateHandle();
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnResize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnResize(EventArgs e) {

            base.OnResize(e);

            // There are some repainting issues for RightToLeft - so invalidate when we resize.
            //                             
            if (RightToLeft == RightToLeft.Yes) {
                Invalidate();
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the selectedIndexChanged event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler on yourself for this event].  They should,
        ///     however, remember to call base.OnSelectedIndexChanged(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected override void OnSelectedIndexChanged(EventArgs e) {
            base.OnSelectedIndexChanged(e);
            EventHandler handler = (EventHandler)Events[EVENT_SELECTEDINDEXCHANGED];
            if (handler != null) {
                handler(this, e);
            }

            // set the position in the dataSource, if there is any
            // we will only set the position in the currencyManager if it is different
            // from the SelectedIndex. Setting CurrencyManager::Position (even w/o changing it)
            // calls CurrencyManager::EndCurrentEdit, and that will pull the dataFrom the controls
            // into the backEnd. We do not need to do that.
            //
            if (this.DataManager != null && DataManager.Position != SelectedIndex) {
                this.DataManager.Position = this.SelectedIndex;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnSelectedValueChanged"]/*' />
        protected override void OnSelectedValueChanged(EventArgs e) {
            base.OnSelectedValueChanged(e);
            selectedValueChangedFired = true;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnDataSourceChanged"]/*' />
        protected override void OnDataSourceChanged(EventArgs e) {
            if (DataSource == null)
            {
                BeginUpdate();
                SelectedIndex = -1;
                Items.ClearInternal();
                EndUpdate();
            }
            base.OnDataSourceChanged(e);
            RefreshItems();
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.OnDisplayMemberChanged"]/*' />
        protected override void OnDisplayMemberChanged(EventArgs e) {
            base.OnDisplayMemberChanged(e);
            if (this.DataManager == null || !IsHandleCreated) {
                return;
            }

            RefreshItems();

            if (SelectionMode != SelectionMode.None)
                this.SelectedIndex = this.DataManager.Position;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.Refresh"]/*' />
        /// <devdoc>
        ///     Forces the ListBox to invalidate and immediately
        ///     repaint itself and any children if OwnerDrawVariable.
        /// </devdoc>
        public override void Refresh() {
            if (drawMode == DrawMode.OwnerDrawVariable) {
                //Fire MeasureItem for Each Item in the Listbox...
                int cnt = Items.Count;
                Graphics graphics = CreateGraphicsInternal();
                
                try 
                {
                    for (int i = 0; i < cnt; i++) {
                        MeasureItemEventArgs mie = new MeasureItemEventArgs(graphics, i, ItemHeight);
                        OnMeasureItem(mie);
                    }
                }
                finally {
                    graphics.Dispose();
                }
                
            }
            base.Refresh();
        }
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.RefreshItems"]/*' />
        /// <devdoc>
        /// Reparses the objects, getting new text strings for them.
        /// </devdoc>
        /// <internalonly/>
        private void RefreshItems() {
        
            // Store the currently selected object collection.
            //
            ObjectCollection savedItems = itemsCollection;
            
            // Clear the items.
            //
            itemsCollection = null;
            selectedIndices = null;
            
            if (IsHandleCreated) {
                NativeClear();
            }
            
            object[] newItems = null;
            
            // if we have a dataSource and a DisplayMember, then use it
            // to populate the Items collection
            //
            if (this.DataManager != null && this.DataManager.Count != -1) {
                newItems = new object[this.DataManager.Count];
                for(int i = 0; i < newItems.Length; i++) {
                    newItems[i] = this.DataManager[i];
                }
            }
            else if (savedItems != null) {
                newItems = new object[savedItems.Count];
                savedItems.CopyTo(newItems, 0);
            }

            // Store the current list of items
            //
            if (newItems != null) {
                Items.AddRangeInternal(newItems);
            }
            
            // Restore the selected indices
            //
            if (this.DataManager != null && SelectionMode != SelectionMode.None) {
                // put the selectedIndex in sync w/ the position in the dataManager
                this.SelectedIndex = this.DataManager.Position;
            }
            else {
                if (savedItems != null) {
                    int cnt = savedItems.Count;
                    for(int index = 0; index < cnt; index++) {
                        if (savedItems.InnerArray.GetState(index, SelectedObjectCollection.SelectedObjectMask)) {
                            SelectedItem = savedItems[index];
                        }
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.RefreshItem"]/*' />
        /// <devdoc>
        /// Reparses the object at the given index, getting new text string for it.
        /// </devdoc>
        /// <internalonly/>
        protected override void RefreshItem(int index) {
            Items.SetItemInternal(index, Items[index]);
        }
        
        private void ResetItemHeight() {
            itemHeight = DefaultItemHeight;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Overrides Control.SetBoundsCore to remember the requestedHeight.
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            
            // Avoid the listbox and textbox behaviour in Collection editors
            //

            
            if (!integralHeightAdjust && height != Height)
                requestedHeight = height;
            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SetItemsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of setting the specified items into the ListBox.
        /// </devdoc>
        protected override void SetItemsCore(IList value) {
                BeginUpdate();
                Items.ClearInternal();
                Items.AddRangeInternal(value);

                this.SelectedItems.Dirty();

                // if the list changed, we want to keep the same selected index
                // CurrencyManager will provide the PositionChanged event
                // it will be provided before changing the list though...
                if (this.DataManager != null) {
                    SendMessage(NativeMethods.LB_SETCURSEL, DataManager.Position, 0);

                    // if the list changed and we still did not fire the
                    // onselectedChanged event, then fire it now;
                    if (!selectedValueChangedFired) {
                        OnSelectedValueChanged(EventArgs.Empty);
                        selectedValueChangedFired = false;
                    }
                }
                EndUpdate();
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SetItemCore"]/*' />
        protected override void SetItemCore(int index, object value) {
            Items.SetItemInternal(index, value);
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SetSelected"]/*' />
        /// <devdoc>
        ///     Allows the user to set an item as being selected or not.  This should
        ///     only be used with ListBoxes that allow some sort of multi-selection.
        /// </devdoc>
        public void SetSelected(int index, bool value) {
            int itemCount = (itemsCollection == null) ? 0: itemsCollection.Count;
            if (index < 0 || index >= itemCount)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", (index).ToString()));

            if (selectionMode == SelectionMode.None)
                throw new InvalidOperationException(SR.GetString(SR.ListBoxInvalidSelectionMode));
 
            SelectedItems.SetSelected(index, value);
            if (IsHandleCreated) {
                NativeSetSelected(index, value);
            }
            SelectedItems.Dirty();
            OnSelectedIndexChanged(EventArgs.Empty);
        }
        
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.Sort"]/*' />
        /// <devdoc>
        ///     Sorts the items in the listbox.
        /// </devdoc>                                        
        protected virtual void Sort() {
            // This will force the collection to add each item back to itself
            // if sorted is now true, then the add method will insert the item
            // into the correct position
            //
            CheckNoDataSource();

            SelectedObjectCollection currentSelections = SelectedItems;
            currentSelections.EnsureUpToDate();

            if (sorted && itemsCollection != null) {
                itemsCollection.InnerArray.Sort();

                // Now that we've sorted, update our handle
                // if it has been created.
                if (IsHandleCreated) {
                    NativeClear();
                    int count = itemsCollection.Count;
                    for(int i = 0; i < count; i++) {
                        NativeAdd(itemsCollection[i]);
                        if (currentSelections.GetSelected(i)) {
                            NativeSetSelected(i, true);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            if (itemsCollection != null) {
                s += ", Items.Count: " + Items.Count.ToString();
                if (Items.Count > 0) {
                    string z = GetItemText(Items[0]);
                    string txt = (z.Length > 40) ? z.Substring(0, 40) : z;
                    s += ", Items[0]: " + txt;
                }
            }
            return s;
        }

        private void UpdateHorizontalExtent() {
            if (!multiColumn && horizontalScrollbar && IsHandleCreated) {
                int width = horizontalExtent;
                if (width == 0) {
                    width = MaxItemWidth;
                }
                SendMessage(NativeMethods.LB_SETHORIZONTALEXTENT, width, 0);
            }
        }

        // Updates the cached max item width
        //
        private void UpdateMaxItemWidth(object item, bool removing) {

            // We shouldn't be caching maxWidth if we don't have horizontal scrollbars,
            // or horizontal extent has been set
            //
            if (!horizontalScrollbar || horizontalExtent > 0) {
                maxWidth = -1;
                return;
            }

            // Only update if we are currently caching maxWidth
            //
            if (maxWidth > -1) {

                // Compute item width
                //
                int width;
                using (Graphics graphics = CreateGraphicsInternal()) {
                    width = (int)(Math.Ceiling(graphics.MeasureString(item.ToString(), this.Font).Width));
                }

                if (removing) {
                    // We're removing this item, so if it's the longest
                    // in the list, reset the cache
                    //
                    if (width >= maxWidth) {
                        maxWidth = -1;
                    }
                }
                else {
                    // We're adding or inserting this item - update the cache
                    //
                    if (width > maxWidth) {
                        maxWidth = width;
                    }
                }
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.WmReflectCommand"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual void WmReflectCommand(ref Message m) {
            switch ((int)m.WParam >> 16) {
                case NativeMethods.LBN_SELCHANGE:
                    if (selectedItems != null) {
                        selectedItems.Dirty();
                    }
                    OnSelectedIndexChanged(EventArgs.Empty);
                    break;
                case NativeMethods.LBN_DBLCLK:
                    // Handle this inside WM_LBUTTONDBLCLK
                    // OnDoubleClick(EventArgs.Empty);
                    break;
            }
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.WmReflectDrawItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectDrawItem(ref Message m) {
            NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT));
            IntPtr dc = dis.hDC;
            IntPtr oldPal = SetUpPalette(dc, false /*force*/, false /*realize*/);
            try {
                Graphics g = Graphics.FromHdcInternal(dc);

                try {
                    Rectangle bounds = Rectangle.FromLTRB(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, dis.rcItem.bottom);
                    if (HorizontalScrollbar) {
                        if (MultiColumn) {
                            bounds.Width = Math.Max(ColumnWidth, bounds.Width);
                        }
                        else {
                            bounds.Width = Math.Max(MaxItemWidth, bounds.Width);
                        }
                    }

                    OnDrawItem(new DrawItemEventArgs(g, Font, bounds, dis.itemID, (DrawItemState)dis.itemState, ForeColor, BackColor));
                }
                finally {
                    g.Dispose();
                }
            }
            finally {
                if (oldPal != IntPtr.Zero) {
                    SafeNativeMethods.SelectPalette(new HandleRef(null, dc), new HandleRef(null, oldPal), 0);
                }
            }
            m.Result = (IntPtr)1;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.WmReflectMeasureItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        // This method is only called if in owner draw mode
        private void WmReflectMeasureItem(ref Message m) {
            
            NativeMethods.MEASUREITEMSTRUCT mis = (NativeMethods.MEASUREITEMSTRUCT)m.GetLParam(typeof(NativeMethods.MEASUREITEMSTRUCT));
                                                                             
            if (drawMode == DrawMode.OwnerDrawVariable && mis.itemID >= 0) {
                Graphics graphics = CreateGraphicsInternal();
                MeasureItemEventArgs mie = new MeasureItemEventArgs(graphics, mis.itemID, ItemHeight);
                try {
                    OnMeasureItem(mie);
                    mis.itemHeight = mie.ItemHeight;
                }
                finally {
                    graphics.Dispose();
                }
            }
            else {
                mis.itemHeight = ItemHeight;
            }
            Marshal.StructureToPtr(mis, m.LParam, false);
            m.Result = (IntPtr)1;
        }

        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.WndProc"]/*' />
        /// <devdoc>
        ///     The list's window procedure.  Inheriting classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(m); to ensure the list continues to function properly.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_COMMAND:
                    WmReflectCommand(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_DRAWITEM:
                    WmReflectDrawItem(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_MEASUREITEM:
                    WmReflectMeasureItem(ref m);
                    break;
                case NativeMethods.WM_LBUTTONDOWN:
                    base.WndProc(ref m);
                    break;
                case NativeMethods.WM_LBUTTONUP:
                    // Get the mouse location
                    //
                    int x = (int)(short)m.LParam;
                    int y = (int)m.LParam >> 16;
                    Point pt = new Point(x,y);
                    pt = PointToScreen(pt);
                    bool captured = Capture;
                    if (captured && UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                        if (selectedItems != null) {
                            selectedItems.Dirty();
                        }
                        
                        if (!doubleClickFired && !ValidationCancelled) {
                             OnClick(EventArgs.Empty);
                        }
                        else {
                            doubleClickFired = false;
                            // WM_COMMAND is only fired if the user double clicks an item,
                            // so we can't use that as a double-click substitute
                            if (!ValidationCancelled) {
                                OnDoubleClick(EventArgs.Empty);
                            }
                       }
                    }
                    base.WndProc(ref m);
                    doubleClickFired = false;
                    break;

                case NativeMethods.WM_LBUTTONDBLCLK:
                    //the Listbox gets  WM_LBUTTONDOWN - WM_LBUTTONUP -WM_LBUTTONDBLCLK - WM_LBUTTONUP...
                    //sequence for doubleclick...
                    //the first WM_LBUTTONUP, resets the flag for Doubleclick
                    //So its necessary for us to set it again...
                    doubleClickFired = true;
                    base.WndProc(ref m);
                    break;
                
                case NativeMethods.WM_WINDOWPOSCHANGED:
                    base.WndProc(ref m);
                    if (integralHeight && fontIsChanged) {
                        Height = Math.Max(Height,ItemHeight);
                        fontIsChanged = false;
                    }
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }
        
        /// <devdoc>
        ///     This is similar to ArrayList except that it also
        ///     mantains a bit-flag based state element for each item
        ///     in the array.
        ///
        ///     The methods to enumerate, count and get data support
        ///     virtualized indexes.  Indexes are virtualized according
        ///     to the state mask passed in.  This allows ItemArray
        ///     to be the backing store for one read-write "master"
        ///     collection and serveral read-only collections based
        ///     on masks.  ItemArray supports up to 31 masks.
        /// </devdoc>
        internal class ItemArray : IComparer {
        
            private static int lastMask = 1;
            
            private ListControl listControl;
            private Entry[]     entries;
            private int         count;
            private int         version;
            
            public ItemArray(ListControl listControl) {
                this.listControl = listControl;
            }
            
            /// <devdoc>
            ///     The version of this array.  This number changes with each
            ///     change to the item list.
            /// </devdoc>
            public int Version {
                get {
                    return version;
                }
            }
        
            /// <devdoc>
            ///     Adds the given item to the array.  The state is initially
            ///     zero.
            /// </devdoc>
            public object Add(object item) {
                EnsureSpace(1);
                version++;
                entries[count] = new Entry(item);
                return entries[count++];
            }
            
            /// <devdoc>
            ///     Adds the given collection of items to the array.
            /// </devdoc>
            public void AddRange(ICollection items) {
                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                EnsureSpace(items.Count);
                foreach(object i in items) {
                    entries[count++] = new Entry(i);
                }
                version++;
            }
            
            /// <devdoc>
            ///     Clears this array.
            /// </devdoc>
            public void Clear() {
                count = 0;
                version++;
            }
        
            /// <devdoc>
            ///     Allocates a new bitmask for use.
            /// </devdoc>
            public static int CreateMask() {
                int mask = lastMask;
                lastMask = lastMask << 1;
                Debug.Assert(lastMask > mask, "We have overflowed our state mask.");
                return mask;
            }
        
            /// <devdoc>
            ///     Ensures that our internal array has space for 
            ///     the requested # of elements.
            /// </devdoc>
            private void EnsureSpace(int elements) {
                if (entries == null) {
                    entries = new Entry[Math.Max(elements, 4)];
                }
                else if (count + elements >= entries.Length) {
                    int newLength = Math.Max(entries.Length * 2, entries.Length + elements);
                    Entry[] newEntries = new Entry[newLength];
                    entries.CopyTo(newEntries, 0);
                    entries = newEntries;
                }
            }
            
            /// <devdoc>
            ///     Turns a virtual index into an actual index.
            /// </devdoc>
            public int GetActualIndex(int virtualIndex, int stateMask) {
                if (stateMask == 0) {
                    return virtualIndex;
                }
                
                // More complex; we must compute this index.
                int calcIndex = -1;
                for(int i = 0; i < count; i++) {
                    if ((entries[i].state & stateMask) != 0) {
                        calcIndex++;
                        if (calcIndex == virtualIndex) {
                            return i;
                        }
                    }
                }
                
                return -1;
            }
            
            /// <devdoc>
            ///     Gets the count of items matching the given mask.
            /// </devdoc>
            public int GetCount(int stateMask) {
                // If mask is zero, then just give the main count
                if (stateMask == 0) {
                    return count;
                }
                
                // more complex:  must provide a count of items
                // based on a mask.
                
                int filteredCount = 0;
                
                for(int i = 0; i < count; i++) {
                    if ((entries[i].state & stateMask) != 0) {
                        filteredCount++;
                    }
                }
                
                return filteredCount;
            }
            
            /// <devdoc>
            ///     Retrieves an enumerator that will enumerate based on 
            ///     the given mask.
            /// </devdoc>
            public IEnumerator GetEnumerator(int stateMask) {
                return GetEnumerator(stateMask, false);
            }
            
            /// <devdoc>
            ///     Retrieves an enumerator that will enumerate based on 
            ///     the given mask.
            /// </devdoc>
            public IEnumerator GetEnumerator(int stateMask, bool anyBit) {
                return new EntryEnumerator(this, stateMask, anyBit);
            }
            
            /// <devdoc>
            ///     Gets the item at the given index.  The index is
            ///     virtualized against the given mask value.
            /// </devdoc>
            public object GetItem(int virtualIndex, int stateMask) {
                int actualIndex = GetActualIndex(virtualIndex, stateMask);
                
                if (actualIndex == -1) {
                    throw new IndexOutOfRangeException();
                }
                
                return entries[actualIndex].item;
            }
            /// <devdoc>
            ///     Gets the item at the given index.  The index is
            ///     virtualized against the given mask value.
            /// </devdoc>
            internal object GetEntryObject(int virtualIndex, int stateMask) {
                int actualIndex = GetActualIndex(virtualIndex, stateMask);
                
                if (actualIndex == -1) {
                    throw new IndexOutOfRangeException();
                }
                
                return entries[actualIndex];
            }
            /// <devdoc>
            ///     Returns true if the requested state mask is set.
            ///     The index is the actual index to the array.
            /// </devdoc>
            public bool GetState(int index, int stateMask) {
                return ((entries[index].state & stateMask) == stateMask);
            }
            
            /// <devdoc>
            ///     Returns the virtual index of the item based on the
            ///     state mask.
            /// </devdoc>
            public int IndexOf(object item, int stateMask) {
            
                int virtualIndex = -1;
                
                for(int i = 0; i < count; i++) {
                    if (stateMask == 0 || (entries[i].state & stateMask) != 0) {
                        virtualIndex++;
                        if (entries[i].item.Equals(item)) {
                            return virtualIndex;
                        }
                    }
                }
                
                return -1;
            }
            
            /// <devdoc>
            ///     Returns the virtual index of the item based on the
            ///     state mask. Uses reference equality to identify the
            ///     given object in the list.
            /// </devdoc>
            public int IndexOfIdentifier(object identifier, int stateMask) {
                int virtualIndex = -1;
                
                for(int i = 0; i < count; i++) {
                    if (stateMask == 0 || (entries[i].state & stateMask) != 0) {
                        virtualIndex++;
                        if (entries[i] == identifier) {
                            return virtualIndex;
                        }
                    }
                }
                
                return -1;
            }
            
            /// <devdoc>
            ///     Inserts item at the given index.  The index
            ///     is not virtualized.
            /// </devdoc>
            public void Insert(int index, object item) {
                EnsureSpace(1);
                
                if (index < count) {
                    System.Array.Copy(entries, index, entries, index + 1, count - index);
                }
                
                entries[index] = new Entry(item);
                count++;
                version++;
            }
            
            /// <devdoc>
            ///     Removes the given item from the array.  If
            ///     the item is not in the array, this does nothing.
            /// </devdoc>
            public void Remove(object item) {
                int index = IndexOf(item, 0);
                
                if (index != -1) {
                    RemoveAt(index);
                }
            }
            
            /// <devdoc>
            ///     Removes the item at the given index.
            /// </devdoc>
            public void RemoveAt(int index) {
                count--;
                for (int i = index; i < count; i++) {
                    entries[i] = entries[i+1];
                }
                version++;
            }
            
            /// <devdoc>
            ///     Sets the item at the given index to a new value.
            /// </devdoc>
            public void SetItem(int index, object item) {
                entries[index].item = item;
            }
            
            /// <devdoc>
            ///     Sets the state data for the given index.
            /// </devdoc>
            public void SetState(int index, int stateMask, bool value) {
                if (value) {
                    entries[index].state |= stateMask;
                }
                else {
                    entries[index].state &= ~stateMask;
                }
                version++;
            }
            
            /// <devdoc>
            ///     Sorts our array.
            /// </devdoc>
            public void Sort() {
                Array.Sort(entries, 0, count, this);
            }
            
            public void Sort(Array externalArray) {
                Array.Sort(externalArray, this);
            }
        
            int IComparer.Compare(object item1, object item2) {
                if (item1 == null) {
                    if (item2 == null)
                        return 0; //both null, then they are equal

                    return -1; //item1 is null, but item2 is valid (greater)
                }
                if (item2 == null)
                    return 1; //item2 is null, so item 1 is greater

                if (item1 is Entry) {
                    item1 = ((Entry)item1).item;
                }
                
                if (item2 is Entry) {
                    item2 = ((Entry)item2).item;
                }
                
                String itemName1 = listControl.GetItemText(item1);
                String itemName2 = listControl.GetItemText(item2);

                CompareInfo compInfo = (Application.CurrentCulture).CompareInfo;
                return compInfo.Compare(itemName1, itemName2, CompareOptions.StringSort);
            }
            
            /// <devdoc>
            ///     This is a single entry in our item array.
            /// </devdoc>
            private class Entry {
                public object item;
                public int state;
                
                public Entry(object item) {
                    this.item = item;
                    this.state = 0;
                }
            }
            
            /// <devdoc>
            ///     EntryEnumerator is an enumerator that will enumerate over
            ///     a given state mask.
            /// </devdoc>
            private class EntryEnumerator : IEnumerator {
                private ItemArray items;
                private bool anyBit;
                private int state;
                private int current;
                private int version;
                
                /// <devdoc>
                ///     Creates a new enumerator that will enumerate over the given state.
                /// </devdoc>
                public EntryEnumerator(ItemArray items, int state, bool anyBit) {
                    this.items = items;
                    this.state = state;
                    this.anyBit = anyBit;
                    this.version = items.version;
                    this.current = -1;
                }
                
                /// <devdoc>
                ///     Moves to the next element, or returns false if at the end.
                /// </devdoc>
                bool IEnumerator.MoveNext() {
                    if(version != items.version) throw new InvalidOperationException(SR.GetString(SR.ListEnumVersionMismatch));
                    
                    while(true) {
                        if (current < items.count - 1) {
                                            current++;
                            if (anyBit) {
                                if ((items.entries[current].state & state) != 0) {
                                    return true;
                                }
                            }
                            else {
                                if ((items.entries[current].state & state) == state) {
                                    return true;
                                }
                            }
                        }
                        else {
                            current = items.count;
                            return false;
                        }
                    }
                }
    
                /// <devdoc>
                ///     Resets the enumeration back to the beginning.
                /// </devdoc>
                void IEnumerator.Reset() {
                    if(version != items.version) throw new InvalidOperationException(SR.GetString(SR.ListEnumVersionMismatch));
                    current = -1;
                }
    
                /// <devdoc>
                ///     Retrieves the current value in the enumerator.
                /// </devdoc>
                object IEnumerator.Current {
                    get {
                        if (current == -1 || current == items.count) {
                            throw new InvalidOperationException(SR.GetString(SR.ListEnumCurrentOutOfRange));
                        }
                        
                        return items.entries[current].item;
                    }
                }
            }
        }

        // Items
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       A collection that stores objects.
        ///    </para>
        /// </devdoc>
        [ListBindable(false)]
        public class ObjectCollection : IList {

            private ListBox owner;
            private ItemArray items;
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.ObjectCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ObjectCollection(ListBox owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.ObjectCollection1"]/*' />
            /// <devdoc>
            ///     <para>
            ///       Initializes a new instance of ListBox.ObjectCollection based on another ListBox.ObjectCollection.
            ///    </para>
            /// </devdoc>
            public ObjectCollection(ListBox owner, ObjectCollection value) {
                this.owner = owner;
                this.AddRange(value);
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.ObjectCollection2"]/*' />
            /// <devdoc>
            ///     <para>
            ///       Initializes a new instance of ListBox.ObjectCollection containing any array of objects.
            ///    </para>
            /// </devdoc>
            public ObjectCollection(ListBox owner, object[] value) {
                this.owner = owner;
                this.AddRange(value);
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.Count"]/*' />
            /// <devdoc>
            ///     Retrieves the number of items.
            /// </devdoc>
            public int Count {
                get {
                    return InnerArray.GetCount(0);
                }
            }
            
            /// <devdoc>
            ///     Internal access to the actual data store.
            /// </devdoc>
            internal ItemArray InnerArray {
                get {
                    if (items == null) {
                        items = new ItemArray(owner);
                    }
                    return items;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ObjectCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ObjectCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ObjectCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }
        
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.Add"]/*' />
            /// <devdoc>
            ///     Adds an item to the List box. For an unsorted List box, the item is
            ///     added to the end of the existing list of items. For a sorted List box,
            ///     the item is inserted into the list according to its sorted position.
            ///     The item's toString() method is called to obtain the string that is
            ///     displayed in the combo box.
            ///     A SystemException occurs if there is insufficient space available to
            ///     store the new item.
            /// </devdoc>
            public int Add(object item) {
                owner.CheckNoDataSource();
                
                if (item == null) {
                    throw new ArgumentNullException("item");
                }
                
                object identifier = InnerArray.Add(item);
                int index = -1;
                bool successful = false;
                
                try {
                    if (owner.sorted) {
                        if (owner.updateCount <= 0) {
                            InnerArray.Sort();
    
                            // Note: we don't need to add for the deferred
                            // sort case above because the Sort method on 
                            // the control will add all the items anyway.
                            //
                            index = InnerArray.IndexOfIdentifier(identifier, 0);
                            if (owner.IsHandleCreated) {
                                owner.NativeInsert(index, item);
                                owner.UpdateMaxItemWidth(item, false);
                            }
                        }
                    }
                    else {
                        index = InnerArray.GetCount(0) - 1;
                        if (owner.IsHandleCreated) {
                            owner.NativeAdd(item);
                            owner.UpdateMaxItemWidth(item, false);
                        }
                    }
                    successful = true;
                }
                finally {
                    if (!successful) {
                        InnerArray.Remove(item);
                    }
                }
                
                owner.UpdateHorizontalExtent();
                return index;
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ObjectCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object item) {
                return Add(item);
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.AddRange1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddRange(ObjectCollection value) {
                owner.CheckNoDataSource();
                AddRangeInternal((ICollection)value);
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddRange(object[] items) {
                owner.CheckNoDataSource();
                AddRangeInternal((ICollection)items);
            }
            
            /// <devdoc>
            ///     Add range that bypasses the data source check.
            /// </devdoc>
            internal void AddRangeInternal(ICollection items) {

                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                
                owner.BeginUpdate();
                
                if (owner.sorted) {
                
                    // Add everything to the array list first, then
                    // sort, and then add to the hwnd according to
                    // index.
                
                    foreach(object item in items) {
                        if (item == null) {
                            throw new ArgumentNullException("item");
                        }
                    }
                    
                    InnerArray.AddRange(items);
                    InnerArray.Sort();

                    if (owner.IsHandleCreated) {
                        Exception failureException = null;
                    
                        // We must pull the new items out in sort order.
                        //
                        object[] sortedArray = new object[items.Count];
                        items.CopyTo(sortedArray, 0);
                        InnerArray.Sort(sortedArray);
                        
                        foreach(object item in sortedArray) {
                            if (failureException == null) {
                                try {
                                    int index = InnerArray.IndexOf(item, 0);
                                    Debug.Assert(index != -1, "Lost track of item");
                                    owner.NativeInsert(index, item);
                                    owner.UpdateMaxItemWidth(item, false);
                                }
                                catch(Exception ex) {
                                    failureException = ex;
                                    InnerArray.Remove(item);
                                }
                            }
                            else {
                                InnerArray.Remove(item);
                            }
                        }

                        if (failureException != null) {
                            throw failureException;
                        }
                    }
                }
                else {

                    // Non sorted add.  Just throw them in here.
                    
                    foreach(object item in items) {
                        if (item == null) {
                            throw new ArgumentNullException("item");
                        }
                    }

                    InnerArray.AddRange(items);

                    // Add each item to the actual list.  If we got
                    // an error while doing it, stop adding and switch
                    // to removing items from the actual list. Then
                    // throw.
                    //
                    if (owner.IsHandleCreated) {
                        Exception failureException = null;

                        foreach(object item in items) {

                            if (failureException == null) {
                                try {
                                    owner.NativeAdd(item);
                                    owner.UpdateMaxItemWidth(item, false);
                                }
                                catch(Exception ex) {
                                    failureException = ex;
                                    InnerArray.Remove(item);
                                }
                            }
                            else {
                                InnerArray.Remove(item);
                            }
                        }

                        if (failureException != null) {
                            throw failureException;
                        }
                    }
                }
                
                owner.UpdateHorizontalExtent();
                owner.EndUpdate();
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the item with the specified index.
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public virtual object this[int index] {
                get {
                    if (index < 0 || index >= InnerArray.GetCount(0)) {
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", (index).ToString()));
                    }
                    
                    return InnerArray.GetItem(index, 0);
                }
                set {
                    owner.CheckNoDataSource();
                    SetItemInternal(index, value);
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.Clear"]/*' />
            /// <devdoc>
            ///     Removes all items from the ListBox.
            /// </devdoc>
            public virtual void Clear() {
                owner.CheckNoDataSource();
                ClearInternal();
            }
            
            /// <devdoc>
            ///     Removes all items from the ListBox.  Bypasses the data source check.
            /// </devdoc>
            internal void ClearInternal() {

                //update the width.. to reset Scrollbars..
                // Clear the selection state.
                //
                int cnt = owner.Items.Count;
                for (int i = 0; i < cnt; i++) {
                    owner.UpdateMaxItemWidth(InnerArray.GetItem(i, 0), true);
                }
                

                if (owner.IsHandleCreated) {
                    owner.NativeClear();
                }
                InnerArray.Clear();
                owner.maxWidth = -1;
                owner.UpdateHorizontalExtent();
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(object value) {
                return IndexOf(value) != -1;
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.CopyTo"]/*' />
            /// <devdoc>
            ///     Copies the ListBox Items collection to a destination array.
            /// </devdoc>
            public void CopyTo(object[] dest, int arrayIndex) {
                int count = InnerArray.GetCount(0);
                for(int i = 0; i < count; i++) {
                    dest[i + arrayIndex] = InnerArray.GetItem(i, 0);
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ObjectCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                int count = InnerArray.GetCount(0);
                for(int i = 0; i < count; i++) {
                    dest.SetValue(InnerArray.GetItem(i, 0), i + index);
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///     Returns an enumerator for the ListBox Items collection.
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return InnerArray.GetEnumerator(0);
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(object value) {
                if (value == null) {
                    throw new ArgumentNullException(SR.GetString(SR.InvalidArgument, "value", "null"));
                }

                return InnerArray.IndexOf(value,0);
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.IndexOfIdentifier"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            /// <internalonly/>
            internal int IndexOfIdentifier(object value) {
                if (value == null) {
                    throw new ArgumentNullException(SR.GetString(SR.InvalidArgument, "value", "null"));
                }

                return InnerArray.IndexOfIdentifier(value,0);
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.Insert"]/*' />
            /// <devdoc>
            ///     Adds an item to the combo box. For an unsorted combo box, the item is
            ///     added to the end of the existing list of items. For a sorted combo box,
            ///     the item is inserted into the list according to its sorted position.
            ///     The item's toString() method is called to obtain the string that is
            ///     displayed in the combo box.
            ///     A SystemException occurs if there is insufficient space available to
            ///     store the new item.
            /// </devdoc>
            public void Insert(int index, object item) {
                owner.CheckNoDataSource();
                
                if (item == null) {
                    throw new ArgumentNullException("item");
                }
                
                if (index < 0 || index > InnerArray.GetCount(0)) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index", (index).ToString()));
                }
                
                // If the combo box is sorted, then nust treat this like an add
                // because we are going to twiddle the index anyway.
                //
                if (owner.sorted) {
                    Add(item);
                }
                else {
                    InnerArray.Insert(index, item);
                    if (owner.IsHandleCreated) {
                    
                        bool successful = false;
                        
                        try {
                            owner.NativeInsert(index, item);
                            owner.UpdateMaxItemWidth(item, false);
                            successful = true;
                        }
                        finally {
                            if (!successful) {
                                InnerArray.RemoveAt(index);
                            }
                        }
                    }
                }
                owner.UpdateHorizontalExtent();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.Remove"]/*' />
            /// <devdoc>
            ///     Removes the given item from the ListBox, provided that it is
            ///     actually in the list.
            /// </devdoc>
            public void Remove(object value) {
            
                int index = InnerArray.IndexOf(value, 0);
                
                if (index != -1) {
                    RemoveAt(index);
                }
            }
        
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.ObjectCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///     Removes an item from the ListBox at the given index.
            /// </devdoc>
            public void RemoveAt(int index) {
                owner.CheckNoDataSource();
                
                if (index < 0 || index >= InnerArray.GetCount(0)) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index", (index).ToString()));
                }
                
                owner.UpdateMaxItemWidth(InnerArray.GetItem(index, 0), true);
                
                if (owner.IsHandleCreated) {
                    owner.NativeRemoveAt(index);
                }
                
                InnerArray.RemoveAt(index);
                owner.UpdateHorizontalExtent();
            }
            
            internal void SetItemInternal(int index, object value) {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }
                
                if (index < 0 || index >= InnerArray.GetCount(0)) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", (index).ToString()));
                }
                
                owner.UpdateMaxItemWidth(InnerArray.GetItem(index, 0), true);
                InnerArray.SetItem(index, value);
                
                if (owner.IsHandleCreated) {
                    bool selected = (owner.SelectedIndex == index);
                    owner.NativeRemoveAt(index);
                    owner.SelectedItems.SetSelected(index, false);
                    owner.NativeInsert(index, value);
                    owner.UpdateMaxItemWidth(value, false);
                    if (selected) {
                        owner.SelectedIndex = index;
                    }
                }
                owner.UpdateHorizontalExtent();
            }
        } // end ObjectCollection


        // SelectedIndices
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class SelectedIndexCollection : IList {
            private ListBox owner;

            /* C#r: protected */
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.SelectedIndexCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public SelectedIndexCollection(ListBox owner) {
                this.owner = owner;
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>Number of current selected items.</para>
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.SelectedItems.Count;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(int selectedIndex) {
                return IndexOf(selectedIndex) != -1;   
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object selectedIndex) {
                if (selectedIndex is Int32) {
                    return Contains((int)selectedIndex);
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(int selectedIndex) {
            
                // Just what does this do?  The selectedIndex parameter above is the index into the
                // main object collection.  We look at the state of that item, and if the state indicates
                // that it is selected, we get back the virtualized index into this collection.  Indexes on 
                // this collection match those on the SelectedObjectCollection.
                if (selectedIndex >= 0 && 
                    selectedIndex < InnerArray.GetCount(0) && 
                    InnerArray.GetState(selectedIndex, SelectedObjectCollection.SelectedObjectMask)) {
                    
                    return InnerArray.IndexOf(InnerArray.GetItem(selectedIndex, 0), SelectedObjectCollection.SelectedObjectMask);
                }
                
                return -1;
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object selectedIndex) {
                if (selectedIndex is Int32) {
                    return IndexOf((int)selectedIndex);
                }
                else {
                    return -1;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the specified selected item.
            /// </devdoc>
            public int this[int index] {
                get {
                    object identifier = InnerArray.GetEntryObject(index, SelectedObjectCollection.SelectedObjectMask);
                    return InnerArray.IndexOfIdentifier(identifier, 0);
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedIndexCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <devdoc>
            ///     This is the item array that stores our data.  We share this backing store
            ///     with the main object collection.
            /// </devdoc>
            private ItemArray InnerArray {
                get {
                    owner.SelectedItems.EnsureUpToDate();
                    return ((ObjectCollection)owner.Items).InnerArray;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                int cnt = Count;
                for (int i = 0; i < cnt; i++) {
                    dest.SetValue(this[i], i + index);
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedIndexCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new SelectedIndexEnumerator(this);
            }
            
            /// <devdoc>
            ///     EntryEnumerator is an enumerator that will enumerate over
            ///     a given state mask.
            /// </devdoc>
            private class SelectedIndexEnumerator : IEnumerator {
                private SelectedIndexCollection items;
                private int current;
                
                /// <devdoc>
                ///     Creates a new enumerator that will enumerate over the given state.
                /// </devdoc>
                public SelectedIndexEnumerator(SelectedIndexCollection items) {
                    this.items = items;
                    this.current = -1;
                }
                
                /// <devdoc>
                ///     Moves to the next element, or returns false if at the end.
                /// </devdoc>
                bool IEnumerator.MoveNext() {

                    if (current < items.Count - 1) {
                        current++;
                        return true;
                    }
                    else {
                        current = items.Count;
                        return false;
                    }
                }
    
                /// <devdoc>
                ///     Resets the enumeration back to the beginning.
                /// </devdoc>
                void IEnumerator.Reset() {
                    current = -1;
                }
    
                /// <devdoc>
                ///     Retrieves the current value in the enumerator.
                /// </devdoc>
                object IEnumerator.Current {
                    get {
                        if (current == -1 || current == items.Count) {
                            throw new InvalidOperationException(SR.GetString(SR.ListEnumCurrentOutOfRange));
                        }
                        
                        return items[current];
                    }
                }
            }
        }
        
        // Should be "ObjectCollection", except we already have one of those.
        /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class SelectedObjectCollection : IList {
        
            // This is the bitmask used within ItemArray to identify selected objects.
            internal static int SelectedObjectMask = ItemArray.CreateMask();
            
            private ListBox owner;
            private bool    stateDirty;
            private int     lastVersion;
            private int     count;

            /* C#r: protected */
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.SelectedObjectCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public SelectedObjectCollection(ListBox owner) {
                this.owner = owner;
                this.stateDirty = true;
                this.lastVersion = -1;
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of current selected items.
            /// </devdoc>
            public int Count {
                get {
                    if (owner.IsHandleCreated) {
                        switch (owner.selectionMode) {
                            
                            case SelectionMode.None:
                                return 0;
        
                            case SelectionMode.One:
                                int index = owner.SelectedIndex;
                                if (index >= 0) {
                                    return 1;
                                }
                                return 0;
        
                            case SelectionMode.MultiSimple:
                            case SelectionMode.MultiExtended:
                                return (int)owner.SendMessage(NativeMethods.LB_GETSELCOUNT, 0, 0);
                        }
        
                        return 0;
                    }
                    
                    // If the handle hasn't been created, we must do this the hard way.
                    // Getting the count when using a mask is expensive, so cache it.
                    //
                    if (lastVersion != InnerArray.Version) {
                        lastVersion = InnerArray.Version;
                        count = InnerArray.GetCount(SelectedObjectMask);
                    }
                    
                    return count;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <devdoc>
            ///     Called by the list box to dirty the selected item state.
            /// </devdoc>
            internal void Dirty() {
                stateDirty = true;
            }
            
            /// <devdoc>
            ///     This is the item array that stores our data.  We share this backing store
            ///     with the main object collection.
            /// </devdoc>
            private ItemArray InnerArray {
                get {
                    EnsureUpToDate();
                    return ((ObjectCollection)owner.Items).InnerArray;
                }
            }
            

            /// <devdoc>
            ///     This is the function that Ensures that the selections are uptodate with
            ///     current listbox handle selections.
            /// </devdoc>
            internal void EnsureUpToDate() {
                if (stateDirty) {
                     stateDirty = false;
                     if (owner.IsHandleCreated) {
                         owner.NativeUpdateSelection();
                     }
                }
            }


            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(object selectedObject) {
                return IndexOf(selectedObject) != -1;   
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(object selectedObject) {
                return InnerArray.IndexOf(selectedObject, SelectedObjectMask);
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }
            
            // A new internal method used in SelectedIndex getter...
            // For a Multi select ListBox there can be two items with the same name ...
            // and hence a object comparison is required...
            // This method returns the "object" at the passed index rather than the "item" ...
            // this "object" is then compared in the IndexOf( ) method of the itemsCollection.
            //
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="SelectedObjectCollection.IList.GetObjectAt"]/*' />
            /// <internalonly/>
            internal object GetObjectAt(int index) {
               return InnerArray.GetEntryObject(index, SelectedObjectCollection.SelectedObjectMask);
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the specified selected item.
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public object this[int index] {
                get {
                    return InnerArray.GetItem(index, SelectedObjectMask);
                }
                set {
                    throw new NotSupportedException();
                }
            }
            
            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                int cnt = InnerArray.GetCount(SelectedObjectMask);
                for (int i = 0; i < cnt; i++) {
                    dest.SetValue(InnerArray.GetItem(i, SelectedObjectMask), i + index);
                }
            }

            /// <include file='doc\ListBox.uex' path='docs/doc[@for="ListBox.SelectedObjectCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return InnerArray.GetEnumerator(SelectedObjectMask);
            }
            
            /// <devdoc>
            ///     This method returns if the actual item index is selected.  The index is the index to the MAIN
            ///     collection, not this one.
            /// </devdoc>
            internal bool GetSelected(int index) {
                return InnerArray.GetState(index, SelectedObjectMask);
            }
            
            /// <devdoc>
            ///     Same thing for GetSelected.
            /// </devdoc>
            internal void SetSelected(int index, bool value) {
                InnerArray.SetState(index, SelectedObjectMask, value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listmanagerbindingscollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListManagerBindingsCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Collections;
    
    /// <include file='doc\ListManagerBindingsCollection.uex' path='docs/doc[@for="ListManagerBindingsCollection"]/*' />
    /// <devdoc>
    /// BindingsCollection is a collection of bindings for a Control.  It has Add/Remove capabilities,
    /// as well as an All array property, enumeration, etc.
    /// </devdoc>
    [DefaultEvent("CollectionChanged")]
    internal class ListManagerBindingsCollection : BindingsCollection {

        private BindingManagerBase bindingManagerBase;
        
        /// <include file='doc\ListManagerBindingsCollection.uex' path='docs/doc[@for="ListManagerBindingsCollection.ListManagerBindingsCollection"]/*' />
        /// <devdoc>
        /// ColumnsCollection constructor.  Used only by DataSource.
        /// </devdoc>
        internal ListManagerBindingsCollection(BindingManagerBase bindingManagerBase) : base() {
            Debug.Assert(bindingManagerBase != null, "How could a listmanagerbindingscollection not have a bindingManagerBase associated with it!");
            this.bindingManagerBase = bindingManagerBase;
        }

        protected override void AddCore(Binding dataBinding) {
            if (dataBinding == null)
                throw new ArgumentNullException("dataBinding");
            if (dataBinding.BindingManagerBase == bindingManagerBase)
                throw new ArgumentException(SR.GetString(SR.BindingsCollectionAdd1), "dataBinding");
            if (dataBinding.BindingManagerBase != null)
                throw new ArgumentException(SR.GetString(SR.BindingsCollectionAdd2), "dataBinding");

            // important to set prop first for error checking.
            dataBinding.SetListManager(bindingManagerBase);

            base.AddCore(dataBinding);
        }

        protected override void ClearCore() {
            int numLinks = Count;
            for (int i = 0; i < numLinks; i++) {
                Binding dataBinding = this[i];
                dataBinding.SetListManager(null);
            }
            base.ClearCore();
        }

        protected override void RemoveCore(Binding dataBinding) {
            if (dataBinding.BindingManagerBase != bindingManagerBase)
                throw new ArgumentException(SR.GetString(SR.BindingsCollectionForeign));
            dataBinding.SetListManager(null);
            base.RemoveCore(dataBinding);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listbindingconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListBindingConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Collections;
    using System.Globalization;
    using System.Reflection;
    
    /// <include file='doc\ListBindingConverter.uex' path='docs/doc[@for="ListBindingConverter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ListBindingConverter : TypeConverter {
        
        /// <include file='doc\ListBindingConverter.uex' path='docs/doc[@for="ListBindingConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\ListBindingConverter.uex' path='docs/doc[@for="ListBindingConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is Binding) {
                Binding b = (Binding)value;
                ConstructorInfo ctor = typeof(Binding).GetConstructor(new Type[] {
                    typeof(string),
                    typeof(object),
                    typeof(string)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {
                        b.PropertyName,
                        b.BindToObject.DataSource,
                        b.BindToObject.BindingMemberInfo.BindingMember});
                }
                
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        /// <include file='doc\ListBindingConverter.uex' path='docs/doc[@for="ListBindingConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return new Binding((string)propertyValues["PropertyName"],
                                           propertyValues["DataSource"],
                                   (string)propertyValues["DataMember"]
                                   );
        }

        /// <include file='doc\ListBindingConverter.uex' path='docs/doc[@for="ListBindingConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listviewalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListViewAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\ListViewAlignment.uex' path='docs/doc[@for="ListViewAlignment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how items align in the <see cref='System.Windows.Forms.ListView'/>.
    ///    </para>
    /// </devdoc>
    public enum ListViewAlignment {

        /// <include file='doc\ListViewAlignment.uex' path='docs/doc[@for="ListViewAlignment.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When the user moves an
        ///       item, it remains where it is dropped.
        ///    </para>
        /// </devdoc>
        Default = NativeMethods.LVA_DEFAULT,

        /// <include file='doc\ListViewAlignment.uex' path='docs/doc[@for="ListViewAlignment.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Items are aligned to the top of the <see cref='System.Windows.Forms.ListView'/> control.
        ///    </para>
        /// </devdoc>
        Top = NativeMethods.LVA_ALIGNTOP,

        /// <include file='doc\ListViewAlignment.uex' path='docs/doc[@for="ListViewAlignment.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Items are aligned to the left of the <see cref='System.Windows.Forms.ListView'/> control.
        ///    </para>
        /// </devdoc>
        Left = NativeMethods.LVA_ALIGNLEFT,

        /// <include file='doc\ListViewAlignment.uex' path='docs/doc[@for="ListViewAlignment.SnapToGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Items
        ///       are aligned to an invisible grid in the control.
        ///       When the user moves an item, it moves to the
        ///       closest juncture in the grid.
        ///    </para>
        /// </devdoc>
        SnapToGrid = NativeMethods.LVA_SNAPTOGRID,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listitemconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListItemConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Drawing;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\ListItemConverter.uex' path='docs/doc[@for="ListViewItemConverter"]/*' />
    /// <devdoc>
    ///      ListViewItemConverter is a class that can be used to convert
    ///      ListViewItem objects from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class ListViewItemConverter : ExpandableObjectConverter {
    
        /// <include file='doc\ListItemConverter.uex' path='docs/doc[@for="ListViewItemConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\ListItemConverter.uex' path='docs/doc[@for="ListViewItemConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is ListViewItem) {
                ListViewItem item = (ListViewItem)value;
                ConstructorInfo ctor;
                
                // Should we use the subitem constructor?
                //
                for(int i=1; i < item.SubItems.Count; ++i) {
                    if (item.SubItems[i].CustomStyle) {
                        ctor = typeof(ListViewItem).GetConstructor(new Type[] { typeof(ListViewItem.ListViewSubItem[]), typeof(int)});
                        if (ctor != null) {
                            ListViewItem.ListViewSubItem[] subItemArray = new ListViewItem.ListViewSubItem[item.SubItems.Count];
                            ((ICollection)item.SubItems).CopyTo(subItemArray, 0);
                            return new InstanceDescriptor(ctor, new object[] {subItemArray, item.ImageIndex}, false);
                        }       
                        else {
                            break;
                        }
                    }
                }                
                
                // Convert SubItem array to string array
                //
                string[] subItems = new string[item.SubItems.Count];
                for(int i=0; i < subItems.Length; ++i) {
                    subItems[i] = item.SubItems[i].Text;
                }
                
                // ForeColor, BackColor or ItemFont set
                //
                if (item.SubItems[0].CustomStyle) {
                    ctor = typeof(ListViewItem).GetConstructor(new Type[] {
                        typeof(string[]),
                        typeof(int),
                        typeof(Color),
                        typeof(Color),
                        typeof(Font)});
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {
                            subItems,
                            item.ImageIndex,
                            item.SubItems[0].CustomForeColor ? item.ForeColor : Color.Empty,
                            item.SubItems[0].CustomBackColor ? item.BackColor : Color.Empty,
                            item.SubItems[0].CustomFont ? item.Font : null
                            }, false);
                    }
                }

                // Text
                //
                if (item.ImageIndex == -1 && item.SubItems.Count <= 1) {
                    ctor = typeof(ListViewItem).GetConstructor(new Type[] {typeof(string)});
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {item.Text}, false);
                    }
                }
                
                // Text and Image
                //
                if (item.SubItems.Count <= 1) {
                    ctor = typeof(ListViewItem).GetConstructor(new Type[] {
                        typeof(string),
                        typeof(int)});
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {item.Text, item.ImageIndex}, false);
                    }
                }

                // Text, Image and SubItems
                //
                ctor = typeof(ListViewItem).GetConstructor(new Type[] {
                    typeof(string[]),
                    typeof(int)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {subItems, item.ImageIndex}, false);
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }    

    internal class ListViewSubItemConverter : ExpandableObjectConverter {
    
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is ListViewItem.ListViewSubItem) {
                ListViewItem.ListViewSubItem item = (ListViewItem.ListViewSubItem)value;
                ConstructorInfo ctor;
                
                // Subitem has custom style
                //
                if (item.CustomStyle) {
                    ctor = typeof(ListViewItem.ListViewSubItem).GetConstructor(new Type[] {
                        typeof(ListViewItem),
                        typeof(string),
                        typeof(Color),
                        typeof(Color),
                        typeof(Font)});
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {
                            null,
                            item.Text,
                            item.ForeColor,
                            item.BackColor,
                            item.Font}, true);
                    }
                }

                // Otherwise, just use the text constructor
                //
                ctor = typeof(ListViewItem.ListViewSubItem).GetConstructor(new Type[] {typeof(ListViewItem), typeof(string)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {null, item.Text}, true);
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mdiclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="MDIClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Threading;
    using System.Windows.Forms;
    
    /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para> 
    ///       Summary to
    ///       Come</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false)
    ]
    public sealed class MdiClient : Control {

        // kept in add order, not ZOrder. Need to return the correct
        // array of items...
        //
        private ArrayList children = new ArrayList();


        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.MdiClient"]/*' />
        /// <devdoc>
        ///     Creates a new MdiClient.
        /// </devdoc>
        /// <internalonly/>
        public MdiClient() : base() {
            SetStyle(ControlStyles.Selectable, false);
            BackColor = SystemColors.AppWorkspace;
            Dock = DockStyle.Fill;
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.BackgroundImage"]/*' />
        /// <devdoc>
        ///      Use parent's BackgroundImage if our BackgroundImage isn't set.
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override Image BackgroundImage {
            get {
                Image result = base.BackgroundImage;
                if (result == null && ParentInternal != null)
                    result = ParentInternal.BackgroundImage;
                return result;
            }
            
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.CreateParams"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;

                cp.ClassName = "MDICLIENT";
                cp.Style |= NativeMethods.WS_VSCROLL | NativeMethods.WS_HSCROLL;
                cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                cp.Param = new NativeMethods.CLIENTCREATESTRUCT(IntPtr.Zero, 1);
                ISite site = (ParentInternal == null) ? null : ParentInternal.Site;
                if (site != null && site.DesignMode) {
                      cp.Style |= NativeMethods.WS_DISABLED;
                      SetState(STATE_ENABLED, false);
                }
                return cp;
            }
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.MdiChildren"]/*' />
        /// <devdoc>
        ///     The list of MDI children contained. This list
        ///     will be sorted by the order in which the children were
        ///     added to the form, not the current ZOrder.
        /// </devdoc>
        public Form[] MdiChildren {
            get {
                Form[] temp = new Form[children.Count];
                children.CopyTo(temp, 0);
                return temp;
            }
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.CreateControlsInstance"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override Control.ControlCollection CreateControlsInstance() {
            return new ControlCollection(this);
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.LayoutMdi"]/*' />
        /// <devdoc>
        ///     Arranges the MDI child forms according to value, which should be a
        ///     member of the MdiLayout enum.
        /// </devdoc>
        public void LayoutMdi(MdiLayout value) {
            if (Handle == IntPtr.Zero)
                return;

            switch (value) {
                case MdiLayout.Cascade:
                    SendMessage(NativeMethods.WM_MDICASCADE, 0, 0);
                    break;
                case MdiLayout.TileVertical:
                    SendMessage(NativeMethods.WM_MDITILE, NativeMethods.MDITILE_VERTICAL, 0);
                    break;
                case MdiLayout.TileHorizontal:
                    SendMessage(NativeMethods.WM_MDITILE, NativeMethods.MDITILE_HORIZONTAL, 0);
                    break;
                case MdiLayout.ArrangeIcons:
                    SendMessage(NativeMethods.WM_MDIICONARRANGE, 0, 0);
                    break;
            }
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.OnResize"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnResize(EventArgs e) {
            ISite site = (ParentInternal == null) ? null : ParentInternal.Site;
            if (site != null && site.DesignMode && Handle != IntPtr.Zero) {
                SetWindowRgn();
            }
            base.OnResize(e);
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ScaleCore"]/*' />
        /// <devdoc>
        ///     Performs the work of scaling the entire control and any child controls.
        /// </devdoc>
        protected override void ScaleCore(float dx, float dy) {

            // Don't scale child forms...
            //

            SuspendLayout();
            try {
                float xAdjust;
                float yAdjust;
                Rectangle bounds = Bounds;
                if (bounds.X < 0) {
                    xAdjust = -0.5f;
                }
                else {
                    xAdjust = 0.5f;
                }
                if (bounds.Y < 0) {
                    yAdjust = -0.5f;
                }
                else {
                    yAdjust = 0.5f;
                }
                int sx = (int)(bounds.X * dx + xAdjust);
                int sy = (int)(bounds.Y * dy + yAdjust);
                int sw = (int)((bounds.X + bounds.Width) * dx + 0.5f) - sx;
                int sh = (int)((bounds.Y + bounds.Height) * dy + 0.5f) - sy;
                SetBounds(sx, sy, sw, sh, BoundsSpecified.All);
            }
            finally {
                ResumeLayout();
            }
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.SetBoundsCore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            ISite site = (ParentInternal == null) ? null : ParentInternal.Site;
            if (IsHandleCreated && (site == null || !site.DesignMode)) {
                Rectangle oldBounds = Bounds;
                base.SetBoundsCore(x, y, width, height, specified);
                Rectangle newBounds = Bounds;

                int yDelta = oldBounds.Height - newBounds.Height;

                // NOTE: This logic is to keep minimized MDI children anchored to
                // the bottom left of the client area, normally they are anchored
                // to the top right which just looks wierd!
                //
                NativeMethods.WINDOWPLACEMENT wp = new NativeMethods.WINDOWPLACEMENT();
                wp.length = Marshal.SizeOf(typeof(NativeMethods.WINDOWPLACEMENT));

                for (int i=0; i < Controls.Count; i++) {
                    Control ctl = Controls[i];
                    if (ctl != null && ctl is Form) {
                        Form child = (Form)ctl;
                        if (child.WindowState == FormWindowState.Minimized) {
                            UnsafeNativeMethods.GetWindowPlacement(new HandleRef(child, child.Handle), ref wp);
                            wp.ptMinPosition_y -= yDelta;
                            if (wp.ptMinPosition_y == -1) {
                                if (yDelta < 0) {
                                    wp.ptMinPosition_y = 0;
                                }
                                else {
                                    wp.ptMinPosition_y = -2;
                                }
                            }
                            wp.flags = NativeMethods.WPF_SETMINPOSITION;
                            UnsafeNativeMethods.SetWindowPlacement(new HandleRef(child, child.Handle), ref wp);
                            wp.flags = 0;
                        }
                    }
                }
            }
            else {
                base.SetBoundsCore(x, y, width, height, specified);
            }

        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void SetWindowRgn() {
            IntPtr rgn1 = IntPtr.Zero;
            IntPtr rgn2 = IntPtr.Zero;
            NativeMethods.RECT rect = new NativeMethods.RECT();
            CreateParams cp = CreateParams;

            SafeNativeMethods.AdjustWindowRectEx(ref rect, cp.Style, false, cp.ExStyle);

            Rectangle bounds = Bounds;
            rgn1 = SafeNativeMethods.CreateRectRgn(0, 0, bounds.Width, bounds.Height);
            try {
                rgn2 = SafeNativeMethods.CreateRectRgn(-rect.left, -rect.top,
                                             bounds.Width - rect.right, bounds.Height - rect.bottom);
                try {
                    if (rgn1 == IntPtr.Zero || rgn2 == IntPtr.Zero)
                        throw new InvalidOperationException(SR.GetString(SR.ErrorSettingWindowRegion));

                    if (SafeNativeMethods.CombineRgn(new HandleRef(null, rgn1), new HandleRef(null, rgn1), new HandleRef(null, rgn2), NativeMethods.RGN_DIFF) == 0)
                        throw new InvalidOperationException(SR.GetString(SR.ErrorSettingWindowRegion));

                    if (UnsafeNativeMethods.SetWindowRgn(new HandleRef(this, Handle), new HandleRef(null, rgn1), true) == 0) {
                        throw new InvalidOperationException(SR.GetString(SR.ErrorSettingWindowRegion));
                    }
                    else {
                        // The hwnd now owns the region.
                        rgn1 = IntPtr.Zero;
                    }
                }
                finally {
                    if (rgn2 != IntPtr.Zero) {
                        SafeNativeMethods.DeleteObject(new HandleRef(null, rgn2));
                    }
                }
            }
            finally {
                if (rgn1 != IntPtr.Zero) {
                    SafeNativeMethods.DeleteObject(new HandleRef(null, rgn1)); 
                }
            }
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ShouldSerializeBackColor"]/*' />
        internal override bool ShouldSerializeBackColor() {
            return BackColor != SystemColors.AppWorkspace;
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ShouldSerializeLocation"]/*' />
        private bool ShouldSerializeLocation() {
            return false;
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ShouldSerializeSize"]/*' />
        internal override bool ShouldSerializeSize() {
            return false;
        }
        

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.WndProc"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_CREATE:
                    if (ParentInternal != null && ParentInternal.Site != null && ParentInternal.Site.DesignMode && Handle != IntPtr.Zero) {
                        SetWindowRgn();
                    }
                    break;
                case NativeMethods.WM_SETFOCUS:
                    InvokeGotFocus(ParentInternal, EventArgs.Empty);
                    Form childForm = null;
                    if (ParentInternal is Form) {
                        childForm = ((Form)ParentInternal).ActiveMdiChild;
                    }
                    if (childForm == null  &&  MdiChildren.Length > 0) {
                        childForm = MdiChildren[0];
                    }
                    if (childForm != null && childForm.Visible) {
                        childForm.Active = true;
                    }

                    // Do not use control's implementation of WmSetFocus
		    // as it will improperly activate this control. 
	            ImeSetFocus();
		    DefWndProc(ref m);
		    InvokeGotFocus(this, EventArgs.Empty);
		    return;
                case NativeMethods.WM_KILLFOCUS:
                    InvokeLostFocus(ParentInternal, EventArgs.Empty);
                    break;
            }
            base.WndProc(ref m);
        }

        /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ControlCollection"]/*' />
        /// <devdoc>
        ///     Collection of controls...
        /// </devdoc>
        new public class ControlCollection : Control.ControlCollection {
            private MdiClient owner;

            /*C#r: protected*/

            /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ControlCollection.ControlCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ControlCollection(MdiClient owner)
            : base(owner) {
                this.owner = owner;
            }

            /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ControlCollection.Add"]/*' />
            /// <devdoc>
            ///     Adds a control to the MDI Container. This child must be
            ///     a Form that is marked as an MDI Child to be added to the
            ///     container. You should not call this directly, but rather
            ///     set the child form's (ctl) MDIParent property:
            /// <code>
            ///     //     wrong
            ///     Form child = new ChildForm();
            ///     this.getMdiClient().add(child);
            ///     //     right
            ///     Form child = new ChildForm();
            ///     child.setMdiParent(this);
            /// </code>
            /// </devdoc>
            public override void Add(Control value) {
                if (!(value is Form) || !((Form)value).IsMdiChild) {
                    throw new ArgumentException(SR.GetString(SR.MDIChildAddToNonMDIParent), "value");
                }
                if (owner._CreateThreadId != value._CreateThreadId) {
                    throw new ArgumentException(SR.GetString(SR.AddDifferentThreads), "value");
                }
                owner.children.Add((Form)value);
                base.Add(value);
            }

            /// <include file='doc\MDIClient.uex' path='docs/doc[@for="MdiClient.ControlCollection.Remove"]/*' />
            /// <devdoc>
            ///     Removes a child control.
            /// </devdoc>
            public override void Remove(Control value) {
                owner.children.Remove(value);
                base.Remove(value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listviewitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListViewItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.IO;
    using System.Windows.Forms;
    using System.Globalization;
    using Microsoft.Win32;
    using System.Collections;
    using System.Collections.Specialized;

    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.ComponentModel.Design.Serialization;
    using System.Reflection;

    /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Implements an item of a <see cref='System.Windows.Forms.ListView'/>.
    ///    </para>
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(ListViewItemConverter)),
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultProperty("Text"),
    Serializable
    ]
    public class ListViewItem : ICloneable, ISerializable {

        private const int MAX_SUBITEMS = 4096;
        
        private static readonly BitVector32.Section StateSelectedSection         = BitVector32.CreateSection(1);
        private static readonly BitVector32.Section StateWholeRowOneStyleSection = BitVector32.CreateSection(1, StateSelectedSection);
        private static readonly BitVector32.Section SavedStateImageIndexSection  = BitVector32.CreateSection(15, StateWholeRowOneStyleSection);
        private static readonly BitVector32.Section SubItemCountSection          = BitVector32.CreateSection(MAX_SUBITEMS, SavedStateImageIndexSection);
        
        internal ListView listView;
        
        private ListViewSubItemCollection listViewSubItemCollection = null;
        private ListViewSubItem[] subItems;
        
        // we stash the last index we got as a seed to GetDisplayIndex.
        private int lastIndex = -1;

        // An ID unique relative to a given list view that comctl uses to identify items.
        internal int ID = -1;

        private BitVector32 state = new BitVector32();
        private int imageIndex      = -1;
        
        object userData;
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem() {
            StateSelected = false;
            UseItemStyleForSubItems = true;
            SavedStateImageIndex = -1;
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem1"]/*' />
        /// <devdoc>
        ///     Creates a ListViewItem object from an Stream.
        /// </devdoc>
        private ListViewItem(SerializationInfo info, StreamingContext context) : this() {
            Deserialize(info, context);
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem(string text) : this(text, -1) {            
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem(string text, int imageIndex) : this() {
            this.imageIndex = imageIndex;
            Text = text;
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem(string[] items) : this(items, -1) {
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem(string[] items, int imageIndex) : this() {

            this.imageIndex = imageIndex;
            if (items != null && items.Length > 0) {
                this.subItems = new ListViewSubItem[items.Length];
                for (int i = 0; i < items.Length; i++) {
                    subItems[i] = new ListViewSubItem(this, items[i]);
                }
                this.SubItemCount = items.Length;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem(string[] items, int imageIndex, Color foreColor, Color backColor, Font font) : this(items, imageIndex) {
            this.ForeColor = foreColor;
            this.BackColor = backColor;
            this.Font = font;
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewItem7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListViewItem(ListViewSubItem[] subItems, int imageIndex) : this() {

            this.imageIndex = imageIndex;
            this.subItems = subItems;
            this.SubItemCount = this.subItems.Length;
            
            // Update the owner of these subitems
            //
            for(int i=0; i < subItems.Length; ++i) {
                subItems[i].owner = this;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.BackColor"]/*' />
        /// <devdoc>
        ///     The font that this item will be displayed in. If its value is null, it will be displayed
        ///     using the global font for the ListView control that hosts it.
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Color BackColor {
            get {
                if (SubItemCount == 0) {
                    if (listView != null) {
                        return listView.BackColor;
                    }
                    return SystemColors.Window;
                }
                else {
                    return subItems[0].BackColor;
                }
            }
            set {
                SubItems[0].BackColor = value;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Bounds"]/*' />
        /// <devdoc>
        ///     Returns the ListViewItem's bounding rectangle, including subitems. The bounding rectangle is empty if
        ///     the ListViewItem has not been added to a ListView control.
        /// </devdoc>
        [Browsable(false)]
        public Rectangle Bounds {
            get {
                if (listView != null) {
                    return listView.GetItemRect(Index);
                }
                else
                    return new Rectangle();
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Checked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(false),
        RefreshPropertiesAttribute(RefreshProperties.Repaint)
        ]
        public bool Checked {
            get {
                return StateImageIndex > 0;
            }

            set {
                if (Checked != value) {
                    if (listView != null && listView.IsHandleCreated) {
                        StateImageIndex = value ? 1 : 0;
                    }
                    else {
                        SavedStateImageIndex = value ? 1 : 0;
                    }
                }
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Focused"]/*' />
        /// <devdoc>
        ///     Returns the focus state of the ListViewItem.
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        Browsable(false)
        ]
        public bool Focused {
            get {
                if (listView != null && listView.IsHandleCreated) {
                    return(listView.GetItemState(Index, NativeMethods.LVIS_FOCUSED) != 0);
                }
                else return false;
            }

            set {
                if (listView != null && listView.IsHandleCreated) {
                    listView.SetItemState(Index, value ? NativeMethods.LVIS_FOCUSED : 0, NativeMethods.LVIS_FOCUSED);
                }
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Font"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Font Font {
            get {
                if (SubItemCount == 0) {
                    if (listView != null) {
                        return listView.Font;
                    }
                    return Control.DefaultFont;
                }
                else {
                    return subItems[0].Font;
                }
            }
            set {
                SubItems[0].Font = value;
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Color ForeColor {
            get {
                if (SubItemCount == 0) {
                    if (listView != null) {
                        return listView.ForeColor;
                    }
                    return SystemColors.WindowText;
                }
                else {
                    return subItems[0].ForeColor;
                }
            }
            set {
                SubItems[0].ForeColor = value;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ImageIndex"]/*' />
        /// <devdoc>
        ///     Returns the ListViewItem's currently set image index        
        /// </devdoc>
        [
        DefaultValue(-1), 
        TypeConverterAttribute(typeof(ImageIndexConverter)),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        Localizable(true),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]        
        public int ImageIndex {
            get {
                if (imageIndex != -1 && ImageList != null && imageIndex >= ImageList.Images.Count) {
                    return ImageList.Images.Count - 1;
                } 
                return this.imageIndex;
            }
            set {
                if (value < -1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", value.ToString(), "-1"));
                }
            
                imageIndex = value;

                if (listView != null && listView.IsHandleCreated) {
                    listView.SetItemImage(Index, value);
                }
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ImageList"]/*' />
        [Browsable(false)]
        public ImageList ImageList {
            get {
                if (listView != null) {
                    switch(listView.View) {
                        case View.LargeIcon:
                            return listView.LargeImageList;
                        case View.SmallIcon:
                        case View.Details:
                        case View.List:
                            return listView.SmallImageList;
                    }
                }
                return null;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Index"]/*' />
        /// <devdoc>
        ///     Returns ListViewItem's current index in the listview, or -1 if it has not been added to a ListView control.
        /// </devdoc>
        [Browsable(false)]
        public int Index {
            get {
                if (listView != null) {
                    lastIndex = listView.GetDisplayIndex(this, lastIndex);
                    return lastIndex;
                }   
                else {
                    return -1;
                }
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListView"]/*' />
        /// <devdoc>
        /// Returns the ListView control that holds this ListViewItem. May be null if no
        /// control has been assigned yet.
        /// </devdoc>
        [Browsable(false)]
        public ListView ListView {
            get {
                return listView;
            }
        }

        /// <devdoc>
        ///     Accessor for our state bit vector.
        /// </devdoc>
        private int SavedStateImageIndex {
            get {
                // State goes from zero to 15, but we need a negative
                // number, so we store + 1.
                return state[SavedStateImageIndexSection] - 1;
            }
            set {
                state[SavedStateImageIndexSection] = value + 1;
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Selected"]/*' />
        /// <devdoc>
        ///     Treats the ListViewItem as a row of strings, and returns an array of those strings
        /// </devdoc>
        [
        Browsable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool Selected {
            get {
                if (listView != null && listView.IsHandleCreated) {
                    return(listView.GetItemState(Index, NativeMethods.LVIS_SELECTED) != 0);
                }
                else
                    return StateSelected;
            }
            set {
                if (listView != null && listView.IsHandleCreated) {
                    listView.SetItemState(Index, value ? NativeMethods.LVIS_SELECTED: 0, NativeMethods.LVIS_SELECTED);
                }
                else {
                    StateSelected = value;
                }
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.StateImageIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true),
        TypeConverterAttribute(typeof(ImageIndexConverter)),
        DefaultValue(-1),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        public int StateImageIndex {
            get {
                if (listView != null && listView.IsHandleCreated) {
                    int state = listView.GetItemState(Index, NativeMethods.LVIS_STATEIMAGEMASK);
                    return((state >> 12) - 1);   // index is 1-based
                }
                else return SavedStateImageIndex;
            }
            set {
                if (value < -1 || value > 14)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "value",
                                                              (value).ToString()));

                if (listView != null && listView.IsHandleCreated) {
                    int state = ((value + 1) << 12);  // index is 1-based
                    listView.SetItemState(Index, state, NativeMethods.LVIS_STATEIMAGEMASK);
                }
                else {
                    SavedStateImageIndex = value;
                }
            }
        }

        /// <devdoc>
        ///     Accessor for our state bit vector.
        /// </devdoc>
        private bool StateSelected {
            get {
                return state[StateSelectedSection] == 1;
            }
            set {
                state[StateSelectedSection] = value ? 1 : 0;
            }
        }
        
        /// <devdoc>
        ///     Accessor for our state bit vector.
        /// </devdoc>
        private int SubItemCount {
            get {
                return state[SubItemCountSection];
            }
            set {
                state[SubItemCountSection] = value;
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.SubItems"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListViewItemSubItemsDescr)        
        ]
        public ListViewSubItemCollection SubItems {
            get {
                if (SubItemCount == 0) {
                    subItems = new ListViewSubItem[1];
                    subItems[0] = new ListViewSubItem(this, string.Empty);                        
                    SubItemCount = 1;
                }
            
                if (listViewSubItemCollection == null) {
                    listViewSubItemCollection = new ListViewSubItemCollection(this);
                }
                return listViewSubItemCollection;
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Tag"]/*' />
        [
        SRCategory(SR.CatData),
        Localizable(false),
        Bindable(true),
        SRDescription(SR.ControlTagDescr),
        DefaultValue(null),
        TypeConverter(typeof(StringConverter)),
        ]
        public object Tag {
            get {
                return userData;
            }
            set {
                userData = value;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Text"]/*' />
        /// <devdoc>
        ///     Text associated with this ListViewItem
        /// </devdoc>
        [
        Localizable(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Text {
            get {
                if (SubItemCount == 0) {
                    return string.Empty;
                }
                else {
                    return subItems[0].Text;
                }
            }
            set {
                SubItems[0].Text = value;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.UseItemStyleForSubItems"]/*' />
        /// <devdoc>
        ///     Whether or not the font and coloring for the ListViewItem will be used for all of its subitems.
        ///     If true, the ListViewItem style will be used when drawing the subitems.
        ///     If false, the ListViewItem and its subitems will be drawn in their own individual styles
        ///     if any have been set.
        /// </devdoc>
        [
        DefaultValue(true)
        ]
        public bool UseItemStyleForSubItems {
            get {
                return state[StateWholeRowOneStyleSection] == 1;
            }
            set {
                state[StateWholeRowOneStyleSection] = value ? 1 : 0;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.BeginEdit"]/*' />
        /// <devdoc>
        ///     Initiate editing of the item's label.
        ///     Only effective if LabelEdit property is true.
        /// </devdoc>
        public void BeginEdit() {
            if (Index >= 0) {
                ListView lv = ListView;
                if (lv.LabelEdit == false)
                    throw new InvalidOperationException(SR.GetString(SR.ListViewBeginEditFailed));
                if (!lv.Focused)
                    lv.FocusInternal();
                UnsafeNativeMethods.SendMessage(new HandleRef(lv, lv.Handle), NativeMethods.LVM_EDITLABEL, Index, 0);
            }
        }                   
                   
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Clone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object Clone() {
            ListViewSubItem[] clonedSubItems = new ListViewSubItem[this.SubItems.Count];
            for(int index=0; index < this.SubItems.Count; ++index) {
                ListViewSubItem subItem = this.SubItems[index];
                clonedSubItems[index] = new ListViewSubItem(null, 
                                                            subItem.Text, 
                                                            subItem.ForeColor, 
                                                            subItem.BackColor,
                                                            subItem.Font);
            }
        
            Type clonedType = this.GetType();
            ListViewItem newItem = null;
            
            if (clonedType == typeof(ListViewItem))
                newItem = new ListViewItem(clonedSubItems, this.imageIndex);
            else 
                newItem = (ListViewItem)Activator.CreateInstance(clonedType);
            
            newItem.subItems = clonedSubItems;
            newItem.imageIndex = this.imageIndex;
            newItem.SubItemCount = this.SubItemCount;
            newItem.Checked = this.Checked;
            newItem.UseItemStyleForSubItems = this.UseItemStyleForSubItems;
            newItem.Tag = this.Tag;
            
            return newItem;
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.EnsureVisible"]/*' />
        /// <devdoc>
        ///     Ensure that the item is visible, scrolling the view as necessary.
        /// </devdoc>
        public virtual void EnsureVisible() {
            if (listView != null)
                listView.EnsureVisible(Index);
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.GetBounds"]/*' />
        /// <devdoc>
        ///     Returns a specific portion of the ListViewItem's bounding rectangle.
        ///     The rectangle returned is empty if the ListViewItem has not been added to a ListView control.
        /// </devdoc>
        public Rectangle GetBounds(ItemBoundsPortion portion) {
            if (listView != null) {
                return listView.GetItemRect(Index, portion);
            }
            else return new Rectangle();
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Host"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void Host(ListView parent, int ID, int index) {
            // Don't let the name "host" fool you -- Handle is not necessarily created
            
            this.ID = ID;
            listView = parent;
            
            // If the index is valid, then the handle has been created.
            if (index != -1) {
                UpdateStateToListView(index);
            }
        }
        
        /// <devdoc>
        ///     Called when we have just pushed this item into a list view and we need
        ///     to configure the list view's state for the item.  Use a valid index
        ///     if you can, or use -1 if you can't.
        /// </devdoc>
        internal void UpdateStateToListView(int index) {
        
            Debug.Assert(listView.IsHandleCreated, "Should only invoke UpdateStateToListView when handle is created.");
            
            if (index == -1) {
                index = Index;
            }
            else {
                lastIndex = index;
            }
            
            // Update Item state in one shot
            //
            int itemState = 0;
            int stateMask = 0;
            
            if (StateSelected) {
                itemState |= NativeMethods.LVIS_SELECTED;
                stateMask |= NativeMethods.LVIS_SELECTED;
            }
            
            if (SavedStateImageIndex > -1) {
                itemState |= ((SavedStateImageIndex + 1) << 12);
                stateMask |= NativeMethods.LVIS_STATEIMAGEMASK;
            }
            
            if (stateMask != 0) {
                listView.SetItemState(index, itemState, stateMask);
            }
        }
        
        internal void UpdateStateFromListView() {
            UpdateStateFromListView(Index);
        }

        internal void UpdateStateFromListView(int displayIndex) {
            if (listView != null && listView.IsHandleCreated) {

                int state = listView.GetItemState(displayIndex, NativeMethods.LVIS_STATEIMAGEMASK | NativeMethods.LVIS_SELECTED);
                
                StateSelected = (state & NativeMethods.LVIS_SELECTED) != 0;
                SavedStateImageIndex = ((state & NativeMethods.LVIS_STATEIMAGEMASK) >> 12) - 1;
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.UnHost"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void UnHost() {
            UnHost(Index);
        }

        internal void UnHost(int displayIndex) {
            UpdateStateFromListView(displayIndex);
            
            // Make sure you do these last, as the first several lines depends on this information
            ID = -1;
            listView = null;            
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Remove() {
            if (listView != null)
                listView.Items.RemoveAt(Index);
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Deserialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void Deserialize(SerializationInfo info, StreamingContext context) {

            bool foundSubItems = false;

            foreach (SerializationEntry entry in info) {
                if (entry.Name == "Text") {
                    Text = (string)entry.Value;
                }
                else if (entry.Name == "ImageIndex") {
                    imageIndex = (int)entry.Value;
                }
                else if (entry.Name == "SubItemCount") {
                    SubItemCount = (int)entry.Value;
                    foundSubItems = true;
                }
                else if (entry.Name == "BackColor") {
                    BackColor = (Color)entry.Value;
                }
                else if (entry.Name == "Checked") {
                    Checked = (bool)entry.Value;
                }
                else if (entry.Name == "Font") {
                    Font = (Font)entry.Value;
                }
                else if (entry.Name == "ForeColor") {
                    ForeColor = (Color)entry.Value;
                }
                else if (entry.Name == "UseItemStyleForSubItems") {
                    UseItemStyleForSubItems = (bool)entry.Value;
                }
            }

            if (foundSubItems) {
                ListViewSubItem[] newItems = new ListViewSubItem[SubItemCount];
                for (int i = 1; i < SubItemCount; i++) {
                    ListViewSubItem newItem = (ListViewSubItem)info.GetValue("SubItem" + i.ToString(), typeof(ListViewSubItem));
                    newItem.owner = this;
                    newItems[i] = newItem;
                }
                newItems[0] = subItems[0];
                subItems = newItems;
            }
        }

        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.Serialize"]/*' />
        /// <devdoc>
        ///     Saves this ListViewItem object to the given data stream.
        /// </devdoc>
        protected virtual void Serialize(SerializationInfo info, StreamingContext context) {
            info.AddValue("Text", Text);
            info.AddValue("ImageIndex", imageIndex);
            if (SubItemCount > 1) {
                info.AddValue("SubItemCount", SubItemCount);
                for (int i = 1; i < SubItemCount; i++) {
                    info.AddValue("SubItem" + i.ToString(), subItems[i], typeof(ListViewSubItem));
                }
            }
            info.AddValue("BackColor", BackColor);
            info.AddValue("Checked", Checked);
            info.AddValue("Font", Font);
            info.AddValue("ForeColor", ForeColor);
            info.AddValue("UseItemStyleForSubItems", UseItemStyleForSubItems);
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ShouldSerializeText"]/*' />
        internal bool ShouldSerializeText() {
            return false;
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            return "ListViewItem: {" + Text + "}";
        }
        
        // The ListItem's state (or a SubItem's state) has changed, so invalidate the ListView control
        internal void InvalidateListView() {
            if (listView != null && listView.IsHandleCreated) {
                listView.Invalidate();
            }
        }
        
        internal void UpdateSubItems(int index){
            UpdateSubItems(index, SubItemCount);
        }

        internal void UpdateSubItems(int index, int oldCount){
            if (listView != null && listView.IsHandleCreated) {
                int subItemCount = SubItemCount;
                
                int itemIndex = Index;
                    
                if (index != -1) {
                    listView.SetItemText(itemIndex, index, subItems[index].Text);
                }
                else {
                    for(int i=0; i < subItemCount; i++) {
                        listView.SetItemText(itemIndex, i, subItems[i].Text);
                    }
                }

                for (int i = subItemCount; i < oldCount; i++) {
                    listView.SetItemText(itemIndex, i, string.Empty);
                }
            }
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            Serialize(info, context);
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            TypeConverterAttribute(typeof(ListViewSubItemConverter)),
            ToolboxItem(false),
            DesignTimeVisible(false),
            DefaultProperty("Text"),
            Serializable
        ]
        public class ListViewSubItem {
        
            [NonSerialized]
            internal ListViewItem owner;

            private string text;
            private SubItemStyle style;
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.ListViewSubItem"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewSubItem() {
            }
                
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.ListViewSubItem1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewSubItem(ListViewItem owner, string text) {
                this.owner = owner;
                this.text = text;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.ListViewSubItem2"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewSubItem(ListViewItem owner, string text, Color foreColor, Color backColor, Font font) {
                this.owner = owner;
                this.text = text;
                this.style = new SubItemStyle();
                this.style.foreColor = foreColor;
                this.style.backColor = backColor;
                this.style.font = font;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.BackColor"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public Color BackColor {
                get {
                    if (style != null && style.backColor != Color.Empty) {
                        return style.backColor;
                    }
                    
                    if (owner != null && owner.listView != null) {
                        return owner.listView.BackColor;
                    }
                    
                    return SystemColors.Window;
                }
                set {
                    if (style == null) {
                        style = new SubItemStyle();
                    }
                    
                    if (style.backColor != value) {
                        style.backColor = value;
                        if (owner != null) {
                            owner.InvalidateListView();
                        }
                    }
                }
            }

            internal bool CustomBackColor {
                get {
                    return style != null && !style.backColor.IsEmpty;
                }
            }

            internal bool CustomFont {
                get {
                    return style != null && style.font != null;
                }
            }

            internal bool CustomForeColor {
                get {
                    return style != null && !style.foreColor.IsEmpty;
                }
            }

            internal bool CustomStyle {
                get {
                    return style != null;
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.Font"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            [
            Localizable(true)
            ]
            public Font Font {
                get {
                    if (style != null && style.font != null) {
                        return style.font;
                    }
                    
                    if (owner != null && owner.listView != null) {
                        return owner.listView.Font;
                    }
                    
                    return Control.DefaultFont;
                }
                set {
                    if (style == null) {
                        style = new SubItemStyle();
                    }
                    
                    if (style.font != value) {
                        style.font = value;
                        if (owner != null) {
                            owner.InvalidateListView();
                        }
                    }
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.ForeColor"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public Color ForeColor {
                get {
                    if (style != null && style.foreColor != Color.Empty) {
                        return style.foreColor;
                    }
                    
                    if (owner != null && owner.listView != null) {
                        return owner.listView.ForeColor;
                    }
                    
                    return SystemColors.WindowText;
                }
                set {
                    if (style == null) {
                        style = new SubItemStyle();
                    }
                    
                    if (style.foreColor != value) {
                        style.foreColor = value;
                        if (owner != null) {
                            owner.InvalidateListView();
                        }
                    }
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.Text"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            [
            Localizable(true)
            ]
            public string Text {
                get {
                    return text == null ? "" : text;
                }
                set {
                    text = value;
                    if (owner != null) {
                        owner.UpdateSubItems(-1);
                    }
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.ResetStyle"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void ResetStyle() {
                if (style != null) {
                    style = null;
                    if (owner != null) {
                        owner.InvalidateListView();                                                                    
                    }
                }
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItem.ToString"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string ToString() {
                return "ListViewSubItem: {" + Text + "}";
            }
            
            [Serializable]
            private class SubItemStyle {
                public Color backColor = Color.Empty;
                public Color foreColor = Color.Empty;
                public Font font = null;
            }            
        }
        
        /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class ListViewSubItemCollection : IList {
            private ListViewItem owner;

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.ListViewSubItemCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewSubItemCollection(ListViewItem owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.Count"]/*' />
            /// <devdoc>
            ///     Returns the total number of items within the list view.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.SubItemCount;
                }
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.this"]/*' />
            /// <devdoc>
            ///     Returns a ListViewSubItem given it's zero based index into the ListViewSubItemCollection.
            /// </devdoc>
            public ListViewSubItem this[int index] {
                get {
                    if (index < 0 || index >= Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  (index).ToString()));

                    return owner.subItems[index];
                }
                set {
                    if (index < 0 || index >= Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  (index).ToString()));

                    owner.subItems[index] = value;
                    owner.UpdateSubItems(index);                    
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    if (value is ListViewSubItem) {
                        this[index] = (ListViewSubItem)value;
                    }
                    else {
                        throw new ArgumentException("value");
                    }
                }
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewSubItem Add(ListViewSubItem item) {
                EnsureSubItemSpace(1, -1);
                owner.subItems[owner.SubItemCount] = item;
                owner.UpdateSubItems(owner.SubItemCount++);
                return item;    
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.Add"]/*' />
            public ListViewSubItem Add(string text) {
                ListViewSubItem item = new ListViewSubItem(owner, text);
                Add(item);                
                return item;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.Add1"]/*' />
            public ListViewSubItem Add(string text, Color foreColor, Color backColor, Font font) {
                ListViewSubItem item = new ListViewSubItem(owner, text, foreColor, backColor, font);
                Add(item);                
                return item;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.AddRange"]/*' />
            public void AddRange(ListViewSubItem[] items) {
                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                EnsureSubItemSpace(items.Length, -1);
                
                foreach(ListViewSubItem item in items) {
                    if (item != null) {
                        owner.subItems[owner.SubItemCount++] = item;
                    }
                }
                
                owner.UpdateSubItems(-1);
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.AddRange1"]/*' />
            public void AddRange(string[] items) {
                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                EnsureSubItemSpace(items.Length, -1);
                
                foreach(string item in items) {
                    if (item != null) {
                        owner.subItems[owner.SubItemCount++] = new ListViewSubItem(owner, item);
                    }
                }
                
                owner.UpdateSubItems(-1);
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.AddRange2"]/*' />
            public void AddRange(string[] items, Color foreColor, Color backColor, Font font) {
                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                EnsureSubItemSpace(items.Length, -1);
                
                foreach(string item in items) {
                    if (item != null) {
                        owner.subItems[owner.SubItemCount++] = new ListViewSubItem(owner, item, foreColor, backColor, font);
                    }
                }
                
                owner.UpdateSubItems(-1);
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object item) {
                if (item is ListViewSubItem) {
                    return IndexOf(Add((ListViewSubItem)item));
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.ListViewSubItemCollectionInvalidArgument));
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Clear() {
                int oldCount = owner.SubItemCount;
                if (oldCount > 0) {
                    owner.SubItemCount = 0;
                    owner.UpdateSubItems(-1, oldCount);
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(ListViewSubItem subItem) {
                return IndexOf(subItem) != -1;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object subItem) {
                if (subItem is ListViewSubItem) {
                    return Contains((ListViewSubItem)subItem);
                }
                else {
                    return false;
                }
            }
            
            /// <devdoc>
            ///     Ensures that the sub item array has the given
            ///     capacity.  If it doesn't, it enlarges the
            ///     array until it does.  If index is -1, additional
            ///     space is tacked onto the end.  If it is a valid
            ///     insertion index into the array, this will move
            ///     the array data to accomodate the space.
            /// </devdoc>
            private void EnsureSubItemSpace(int size, int index) {
            
                // Range check subItems.
                if (owner.SubItemCount == ListViewItem.MAX_SUBITEMS) {
                    throw new InvalidOperationException(SR.GetString(SR.ErrorCollectionFull));
                }
                
                if (owner.SubItemCount + size > owner.subItems.Length) {
                
                    // must grow array.  Don't do it just by size, though;
                    // chunk it for efficiency.
                    
                    if (owner.subItems == null) {
                        int newSize = (size > 4) ? size : 4;
                        owner.subItems = new ListViewSubItem[newSize];
                    }
                    else {
                        int newSize = owner.subItems.Length * 2;
                        while(newSize - owner.SubItemCount < size) {
                            newSize *= 2;
                        }
                        
                        ListViewSubItem[] newItems = new ListViewSubItem[newSize];
                        
                        // Now, when copying to the member variable, use index
                        // if it was provided.
                        //
                        if (index != -1) {
                            Array.Copy(owner.subItems, 0, newItems, 0, index);
                            Array.Copy(owner.subItems, index, newItems, index + size, owner.SubItemCount - index);
                        }
                        else {
                            Array.Copy(owner.subItems, newItems, owner.SubItemCount);
                        }
                        owner.subItems = newItems;
                    }
                }
                else {
                
                    // We had plenty of room.  Just move the items if we need to
                    //
                    if (index != -1) {
                        for(int i = owner.SubItemCount - 1; i >= index; i--) {
                            owner.subItems[i + size] = owner.subItems[i];
                        }
                    }
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(ListViewSubItem subItem) {
                for(int index=0; index < Count; ++index) {
                    if (owner.subItems[index] == subItem) {
                        return index;
                    }
                }    
                return -1;
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object subItem) {
                if (subItem is ListViewSubItem) {
                    return IndexOf((ListViewSubItem)subItem);
                }
                else {
                    return -1;
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.Insert"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Insert(int index, ListViewSubItem item) {
            
                if (index < 0 || index > Count) {
                    throw new ArgumentOutOfRangeException("index");
                }
                
                item.owner = owner;
                
                EnsureSubItemSpace(1, index);
            
                // Insert new item
                //
                owner.subItems[index] = item;
                owner.SubItemCount++;
                owner.UpdateSubItems(-1);
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object item) {
                if (item is ListViewSubItem) {
                    Insert(index, (ListViewSubItem)item);
                }
                else {
                    throw new ArgumentException("item");
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Remove(ListViewSubItem item) {
                int index = IndexOf(item);
                if (index != -1) {                    
                    RemoveAt(index);
                }
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object item) {
                if (item is ListViewSubItem) {
                    Remove((ListViewSubItem)item);
                }                
            }
            
            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void RemoveAt(int index) {
            
                if (index < 0 || index >= Count) {
                    throw new ArgumentOutOfRangeException("index");
                }
                
                // Collapse the items
                for (int i = index + 1; i < owner.SubItemCount; i++) {
                    owner.subItems[i - 1] = owner.subItems[i];
                }

                int oldCount = owner.SubItemCount;
                owner.SubItemCount--;
                owner.UpdateSubItems(-1, oldCount);
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewSubItemCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(owner.subItems, 0, dest, index, Count);           
                }
            }

            /// <include file='doc\ListViewItem.uex' path='docs/doc[@for="ListViewItem.ListViewSubItemCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                if (owner.subItems != null) {
                    return new WindowsFormsUtils.ArraySubsetEnumerator(owner.subItems, owner.SubItemCount);
                }   
                else 
                {
                    return new ListViewSubItem[0].GetEnumerator();
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mainmenu.cs ===
//------------------------------------------------------------------------------
// <copyright file="MainMenu.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Represents
    ///       a menu structure for a form.</para>
    /// </devdoc>
    [ToolboxItemFilter("System.Windows.Forms.MainMenu")]
    public class MainMenu : Menu
    {
        internal Form form;
        private RightToLeft rightToLeft = System.Windows.Forms.RightToLeft.Inherit;
        
        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.MainMenu"]/*' />
        /// <devdoc>
        ///     Creates a new MainMenu control.
        /// </devdoc>
        public MainMenu()
            : base(null) {
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.MainMenu1"]/*' />
        /// <devdoc>
        ///     Creates a new MainMenu control with the given items to start
        ///     with.
        /// </devdoc>
        public MainMenu(MenuItem[] items)
            : base(items) {
        }
        
        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.RightToLeft"]/*' />
        /// <devdoc>
        ///     This is used for international applications where the language
        ///     is written from RightToLeft. When this property is true,
        ///     text alignment and reading order will be from right to left.
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.MenuRightToLeftDescr)
        ]
        public virtual RightToLeft RightToLeft {
            get {
                if (System.Windows.Forms.RightToLeft.Inherit == rightToLeft) {
                    if (form != null) {
                        return form.RightToLeft;
                    }
                    else {
                        return RightToLeft.Inherit;
                    }
                }
                else {
                    return rightToLeft;
                }
            }
            set {
            
                if (!Enum.IsDefined(typeof(System.Windows.Forms.RightToLeft), value)) {
                    throw new InvalidEnumArgumentException("RightToLeft", (int)value, typeof(RightToLeft));
                }
                if (rightToLeft != value) {
                    rightToLeft = value;
                }

            }
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.CloneMenu"]/*' />
        /// <devdoc>
        ///     Creates a new MainMenu object which is a dupliate of this one.
        /// </devdoc>
        public virtual MainMenu CloneMenu() {
            MainMenu newMenu = new MainMenu();
            newMenu.CloneMenu(this);
            return newMenu;
        }

        internal void CleanupMenuItemsHashtable() {
            for (int i = 0; i < itemCount; i++) {
                MenuItem menu = items[i];
                menu.CleanupHashtable();
            }
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.CreateMenuHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override IntPtr CreateMenuHandle() {
            return UnsafeNativeMethods.CreateMenu();
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.Dispose"]/*' />
        /// <devdoc>
        ///     Clears out this MainMenu object and discards all of it's resources.
        ///     If the menu is parented in a form, it is disconnected from that as
        ///     well.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (form != null) {
                    form.Menu = null;
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.GetForm"]/*' />
        /// <devdoc>
        ///     Indicates which form in which we are currently residing [if any]
        /// </devdoc>
        public Form GetForm() {
            return form;
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.ItemsChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal override void ItemsChanged(int change) {
            base.ItemsChanged(change);
            if (form != null)
                form.MenuChanged(change, this);
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.ItemsChanged1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal virtual void ItemsChanged(int change, Menu menu) {
            if (form != null)
                form.MenuChanged(change, menu);
        }
        
        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.ShouldSerializeRightToLeft"]/*' />
        /// <devdoc>
        ///     Returns true if the RightToLeft should be persisted in code gen.
        /// </devdoc>
        internal virtual bool ShouldSerializeRightToLeft() {
            if (System.Windows.Forms.RightToLeft.Inherit == rightToLeft) {
                return false;
            }
            return true;
        }

        /// <include file='doc\MainMenu.uex' path='docs/doc[@for="MainMenu.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            Form f = GetForm();
            string formname = SR.GetString(SR.MainMenuToStringNoForm);
            if (f != null)
                formname = f.ToString();

            return s + ", GetForm: " + formname;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mdiwindowdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="MDIWindowDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;


    /// <include file='doc\MDIWindowDialog.uex' path='docs/doc[@for="MdiWindowDialog"]/*' />
    /// <devdoc>
    /// </devdoc>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class MdiWindowDialog : Form {
        private System.Windows.Forms.ListBox itemList;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private System.ComponentModel.IContainer components;
        Form active;

        public MdiWindowDialog()
            : base() {

            InitializeComponent();
        }

        public Form ActiveChildForm {
            get {
#if DEBUG
                ListItem item = (ListItem)itemList.SelectedItem;
                Debug.Assert(item != null, "No item selected!");
#endif
                return active;
            }
        }

        /// <include file='doc\MDIWindowDialog.uex' path='docs/doc[@for="MdiWindowDialog.Dispose"]/*' />
        /// <devdoc>
        ///     MdiWindowDialog overrides dispose so it can clean up the
        ///     component list.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                components.Dispose();
            }
            base.Dispose(disposing);
        }


        /// <include file='doc\MDIWindowDialog.uex' path='docs/doc[@for="MdiWindowDialog.ListItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class ListItem {
            public Form form;

            public ListItem(Form f) {
                form = f;
            }

            public override string ToString() {
                return form.Text;
            }
        }

        public void SetItems(Form active, Form[] all) {
            int selIndex = 0;
            for (int i=0; i<all.Length; i++) {
                int n = itemList.Items.Add(new ListItem(all[i]));
                if (all[i].Equals(active)) {
                    selIndex = n;
                }
            }
            this.active = active;
            itemList.SelectedIndex = selIndex;
        }

        private void ItemList_doubleClick(object source, EventArgs e) {
            okButton.PerformClick();
        }

        private void ItemList_selectedIndexChanged(object source, EventArgs e) {
            ListItem item = (ListItem)itemList.SelectedItem;
            if (item != null) {
                active = item.form;
            }
        }

        /// <include file='doc\MDIWindowDialog.uex' path='docs/doc[@for="MdiWindowDialog.components"]/*' />
        /// <devdoc>
        ///     NOTE: The following code is required by the Windows Forms
        ///     designer.  It can be modified using the form editor.  Do not
        ///     modify it using the code editor.
        /// </devdoc>

        private void InitializeComponent() {
            this.components = new System.ComponentModel.Container();
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(MdiWindowDialog));
            this.itemList = new System.Windows.Forms.ListBox();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.itemList.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("itemList.Anchor")));
            this.itemList.IntegralHeight = false;
            this.itemList.Location = ((System.Drawing.Point)(resources.GetObject("itemList.Location")));
            this.itemList.Size = ((System.Drawing.Size)(resources.GetObject("itemList.Size")));
            this.itemList.TabIndex = ((int)(resources.GetObject("itemList.TabIndex")));
            this.itemList.DoubleClick += new System.EventHandler(this.ItemList_doubleClick);
            this.itemList.SelectedIndexChanged += new EventHandler(this.ItemList_selectedIndexChanged);
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("okButton.Anchor")));
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.okButton.Location = ((System.Drawing.Point)(resources.GetObject("okButton.Location")));
            this.okButton.Size = ((System.Drawing.Size)(resources.GetObject("okButton.Size")));
            this.okButton.TabIndex = ((int)(resources.GetObject("okButton.TabIndex")));
            this.okButton.Text = resources.GetString("okButton.Text");
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("cancelButton.Anchor")));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = ((System.Drawing.Point)(resources.GetObject("cancelButton.Location")));
            this.cancelButton.Size = ((System.Drawing.Size)(resources.GetObject("cancelButton.Size")));
            this.cancelButton.TabIndex = ((int)(resources.GetObject("cancelButton.TabIndex")));
            this.cancelButton.Text = resources.GetString("cancelButton.Text");
            this.AcceptButton = this.okButton;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this.cancelButton;
            
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this.cancelButton,
                        this.okButton,
                        this.itemList});
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.ControlBox = false;
            this.StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
            this.Text = resources.GetString("$this.Text");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\measureitemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="MeasureItemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\MeasureItemEventHandler.uex' path='docs/doc[@for="MeasureItemEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void MeasureItemEventHandler(object sender, MeasureItemEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\measureitemevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="MeasureItemEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs"]/*' />
    /// <devdoc>
    ///     This event is sent by controls such as the ListBox or ComboBox that need users
    ///     to tell them how large a given item is to be.
    /// </devdoc>
    public class MeasureItemEventArgs : EventArgs {

        private int itemHeight;
        private int itemWidth;
        private int index;

        private readonly System.Drawing.Graphics graphics;


        /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs.MeasureItemEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MeasureItemEventArgs(Graphics graphics, int index, int itemHeight) {
            this.graphics = graphics;
            this.index = index;
            this.itemHeight = itemHeight;
            this.itemWidth = 0;
        }

        /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs.MeasureItemEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MeasureItemEventArgs(Graphics graphics, int index) {
            this.graphics = graphics;
            this.index = index;
            this.itemHeight = 0;
            this.itemWidth = 0;
        }
        
        /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs.Graphics"]/*' />
        /// <devdoc>
        ///     A Graphics object to measure relative to.
        /// </devdoc>
        public System.Drawing.Graphics Graphics {
            get {
                return graphics;
            }
        }

        /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs.Index"]/*' />
        /// <devdoc>
        ///     The index of item for which the height/width is needed.
        /// </devdoc>
        public int Index {
            get {
                return index;
            }
        }

        /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs.ItemHeight"]/*' />
        /// <devdoc>
        ///     Where the recipient of the event should put the height of the
        ///     item specified by the index.
        /// </devdoc>
        public int ItemHeight {
            get {
                return itemHeight;
            }
            set {
                itemHeight = value;
            }
        }

        /// <include file='doc\MeasureItemEvent.uex' path='docs/doc[@for="MeasureItemEventArgs.ItemWidth"]/*' />
        /// <devdoc>
        ///     Where the recipient of the event should put the width of the
        ///     item specified by the index.
        /// </devdoc>
        public int ItemWidth {
            get {
                return itemWidth;
            }
            set {
                itemWidth = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mdilayout.cs ===
//------------------------------------------------------------------------------
// <copyright file="MDILayout.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\MDILayout.uex' path='docs/doc[@for="MdiLayout"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the layout of multiple document interface (MDI) child windows in an MDI parent window.
    ///    </para>
    /// </devdoc>
    public enum MdiLayout {

        /// <include file='doc\MDILayout.uex' path='docs/doc[@for="MdiLayout.Cascade"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All MDI child windows are cascaded within the client
        ///       region of
        ///       the MDI parent form.
        ///    </para>
        /// </devdoc>
        Cascade         = 0,
        /// <include file='doc\MDILayout.uex' path='docs/doc[@for="MdiLayout.TileHorizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All MDI child windows are tiled horizontally within the client region of the MDI parent form.
        ///    </para>
        /// </devdoc>
        TileHorizontal = 1,
        /// <include file='doc\MDILayout.uex' path='docs/doc[@for="MdiLayout.TileVertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All MDI child windows are tiled vertically within the client region of the MDI parent form.
        ///    </para>
        /// </devdoc>
        TileVertical   = 2,
        /// <include file='doc\MDILayout.uex' path='docs/doc[@for="MdiLayout.ArrangeIcons"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All MDI child icons are arranged within the client region of the MDI parent form.
        ///    </para>
        /// </devdoc>
        ArrangeIcons   = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\menu.cs ===
//------------------------------------------------------------------------------
// <copyright file="Menu.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;    
    using System.Collections;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Security;
    using System.Globalization;

    /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu"]/*' />
    /// <devdoc>
    ///     This is the base class for all menu components (MainMenu, MenuItem, and ContextMenu).
    /// </devdoc>
    [
    Designer("Microsoft.VisualStudio.Windows.Forms.MenuDesigner, " + AssemblyRef.MicrosoftVisualStudio),
    ToolboxItemFilter("System.Windows.Forms"),
    ListBindable(false)
    ]
    public abstract class Menu : Component {
        internal const int CHANGE_ITEMS     = 0; // item(s) added or removed
        internal const int CHANGE_VISIBLE   = 1; // item(s) hidden or shown
        internal const int CHANGE_MDI       = 2; // mdi item changed
        internal const int CHANGE_MERGE     = 3; // mergeType or mergeOrder changed

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.FindHandle"]/*' />
        /// <devdoc>
        ///     Used by findMenuItem
        /// </devdoc>
        /// <internalonly/>
        public const int FindHandle = 0;
        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.FindShortcut"]/*' />
        /// <devdoc>
        ///     Used by findMenuItem
        /// </devdoc>
        /// <internalonly/>
        public const int FindShortcut = 1;

        private MenuItemCollection itemsCollection;
        internal MenuItem[] items;
        internal int itemCount;
        internal IntPtr handle;
        internal bool created;
        
        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.Menu"]/*' />
        /// <devdoc>
        ///     This is an abstract class.  Instances cannot be created, so the constructor
        ///     is only called from derived classes.
        /// </devdoc>
        /// <internalonly/>
        protected Menu(MenuItem[] items) {
            if (items != null) {
                MenuItems.AddRange(items);
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.Handle"]/*' />
        /// <devdoc>
        ///     The HMENU handle corresponding to this menu.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlHandleDescr)
        ]
        public IntPtr Handle {
            get {
                if (handle == IntPtr.Zero) handle = CreateMenuHandle();
                CreateMenuItems();
                return handle;
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.IsParent"]/*' />
        /// <devdoc>
        ///     Specifies whether this menu contains any items.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.MenuIsParentDescr)
        ]
        public virtual bool IsParent {
            [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
            get {
                return null != items && itemCount > 0;
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MdiListItem"]/*' />
        /// <devdoc>
        ///     The MenuItem that contains the list of MDI child windows.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.MenuMDIListItemDescr)
        ]
        public MenuItem MdiListItem {
            get {
                for (int i = 0; i < itemCount; i++) {
                    MenuItem item = items[i];
                    if (item.MdiList)
                        return item;
                    if (item.IsParent) {
                        item = item.MdiListItem;
                        if (item != null) return item;
                    }
                }
                return null;
            }
        }


        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItems"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRDescription(SR.MenuMenuItemsDescr),
        MergableProperty(false)
        ]
        public MenuItemCollection MenuItems {
            get {
                if (itemsCollection == null) {
                    itemsCollection = new MenuItemCollection(this);
                }
                return itemsCollection;
            }
        }
        
        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.ClearHandles"]/*' />
        /// <devdoc>
        ///     Notifies Menu that someone called Windows.DeleteMenu on its handle.
        /// </devdoc>
        /// <internalonly/>
        internal void ClearHandles() {
            UnsafeNativeMethods.DestroyMenu(new HandleRef(this, handle));
            handle = IntPtr.Zero;
            if (created) {
                for (int i = 0; i < itemCount; i++)
                    items[i].ClearHandles();
                created = false;
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.CloneMenu"]/*' />
        /// <devdoc>
        ///     Sets this menu to be an identical copy of another menu.
        /// </devdoc>
        protected void CloneMenu(Menu menuSrc) {
            MenuItem[] newItems = null;
            if (menuSrc.items != null) {
                int count = menuSrc.MenuItems.Count;
                newItems = new MenuItem[count];
                for (int i = 0; i < count; i++)
                    newItems[i] = menuSrc.MenuItems[i].CloneMenu();
            }
            MenuItems.Clear();
            if (newItems != null) {
                MenuItems.AddRange(newItems);
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.CreateMenuHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected virtual IntPtr CreateMenuHandle() {
            return UnsafeNativeMethods.CreatePopupMenu();
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.CreateMenuItems"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void CreateMenuItems() {
            if (!created) {
                for (int i = 0; i < itemCount; i++) items[i].CreateMenuItem();
                created = true;
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.DestroyMenuItems"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void DestroyMenuItems() {
            if (created) {
                while (UnsafeNativeMethods.GetMenuItemCount(new HandleRef(this, handle)) > 0) {
                    UnsafeNativeMethods.RemoveMenu(new HandleRef(this, handle), 0, NativeMethods.MF_BYPOSITION);
                }
                created = false;
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of the component.  Call dispose when the component is no longer needed.
        ///     This method removes the component from its container (if the component has a site)
        ///     and triggers the dispose event.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                while (itemCount > 0) {
                    MenuItem item = items[--itemCount];

                    // remove the item before we dispose it so it still has valid state
                    // for undo/redo
                    //
                    if (item.Site != null && item.Site.Container != null) {
                        item.Site.Container.Remove(item);
                    }

                    item.menu = null;
                    item.Dispose();
                }
                items = null;
            }
            if (handle != IntPtr.Zero) {
                UnsafeNativeMethods.DestroyMenu(new HandleRef(this, handle));
                if (disposing) {
                    ClearHandles();
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.FindMenuItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public MenuItem FindMenuItem(int type, IntPtr value) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ControlFromHandleOrLocation Demanded");
            IntSecurity.ControlFromHandleOrLocation.Demand();
            return FindMenuItemInternal(type, value);
        }

        private MenuItem FindMenuItemInternal(int type, IntPtr value) {
            for (int i = 0; i < itemCount; i++) {
                MenuItem item = items[i];
                switch (type) {
                    case FindHandle:
                        if (item.handle == value) return item;
                        break;
                    case FindShortcut:
                        if (item.Shortcut == (Shortcut)(int)value) return item;
                        break;
                }
                item = item.FindMenuItemInternal(type, value);
                if (item != null) return item;
            }
            return null;
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.FindMergePosition"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected int FindMergePosition(int mergeOrder) {
            int iMin, iLim, iT;

            for (iMin = 0, iLim = itemCount; iMin < iLim;) {
                iT = (iMin + iLim) / 2;
                if (items[iT].MergeOrder <= mergeOrder)
                    iMin = iT + 1;
                else
                    iLim = iT;
            }
            return iMin;
        }
        
        //There's a win32 problem that doesn't allow menus to cascade right to left
        //unless we explicitely set the bit on the menu the first time it pops up
        internal void UpdateRtl() {
            foreach (MenuItem item in MenuItems) {
                item.UpdateItemRtl();
                item.UpdateRtl();
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.GetContextMenu"]/*' />
        /// <devdoc>
        ///     Returns the ContextMenu that contains this menu.  The ContextMenu
        ///     is at the top of this menu's parent chain.
        ///     Returns null if this menu is not contained in a ContextMenu.
        ///     This can occur if it's contained in a MainMenu or if it isn't
        ///     currently contained in any menu at all.
        /// </devdoc>
        public ContextMenu GetContextMenu() {
            Menu menuT;
            for (menuT = this; !(menuT is ContextMenu);) {
                if (!(menuT is MenuItem)) return null;
                menuT = ((MenuItem)menuT).menu;
            }
            return(ContextMenu)menuT;

        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.GetMainMenu"]/*' />
        /// <devdoc>
        ///     Returns the MainMenu item that contains this menu.  The MainMenu
        ///     is at the top of this menu's parent chain.
        ///     Returns null if this menu is not contained in a MainMenu.
        ///     This can occur if it's contained in a ContextMenu or if it isn't
        ///     currently contained in any menu at all.
        /// </devdoc>
        public MainMenu GetMainMenu() {
            Menu menuT;
            for (menuT = this; !(menuT is MainMenu);) {
                if (!(menuT is MenuItem)) return null;
                menuT = ((MenuItem)menuT).menu;
            }
            return(MainMenu)menuT;
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.ItemsChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal virtual void ItemsChanged(int change) {
            switch (change) {
                case CHANGE_ITEMS:
                case CHANGE_VISIBLE:
                    DestroyMenuItems();
                    break;
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MergeMenu"]/*' />
        /// <devdoc>
        ///     Merges another menu's items with this one's.  Menu items are merged according to their
        ///     mergeType and mergeOrder properties.  This function is typically used to
        ///     merge an MDI container's menu with that of its active MDI child.
        /// </devdoc>
        public virtual void MergeMenu(Menu menuSrc) {
            int i, j;
            MenuItem item;
            MenuItem itemDst;

            if (menuSrc == this)
                throw new ArgumentException(SR.GetString(SR.MenuMergeWithSelf), "menuSrc");

            if (menuSrc.items != null && items == null) {
                MenuItems.Clear();                
            }

            for (i = 0; i < menuSrc.itemCount; i++) {
                item = menuSrc.items[i];

                switch (item.MergeType) {
                    default:
                        continue;
                    case MenuMerge.Add:
                        MenuItems.Add(FindMergePosition(item.MergeOrder), item.MergeMenu());
                        continue;
                    case MenuMerge.Replace:
                    case MenuMerge.MergeItems:
                        break;
                }

                int mergeOrder = item.MergeOrder;
                for (j = FindMergePosition(mergeOrder - 1); ; j++) {
                    if (j >= itemCount) {
                        MenuItems.Add(j, item.MergeMenu());
                        break;
                    }
                    itemDst = items[j];
                    if (itemDst.MergeOrder != mergeOrder) {
                        MenuItems.Add(j, item.MergeMenu());
                        break;
                    }
                    if (itemDst.MergeType != MenuMerge.Add) {
                        if (item.MergeType != MenuMerge.MergeItems
                            || itemDst.MergeType != MenuMerge.MergeItems) {
                            itemDst.Dispose();
                            MenuItems.Add(j, item.MergeMenu());
                        }
                        else {
                            itemDst.MergeMenu(item);
                        }
                        break;
                    }
                }
            }
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.ProcessInitMenuPopup"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal virtual bool ProcessInitMenuPopup(IntPtr handle) {
            MenuItem item = FindMenuItemInternal(FindHandle, handle);
            if (item != null) {
                item._OnInitMenuPopup(EventArgs.Empty);
                item.CreateMenuItems();
                return true;
            }
            return false;
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.ProcessCmdKey"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        protected internal virtual bool ProcessCmdKey(ref Message msg, Keys keyData) {
            MenuItem item = FindMenuItemInternal(FindShortcut, (IntPtr)(int)keyData);
            return item != null? item.ShortcutClick(): false;
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Items.Count: " + itemCount.ToString();
        }

        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.WmMenuChar"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void WmMenuChar(ref Message m) {
            
            // Handles WM_MENUCHAR for owner-drawn menus
            Menu menu;
            
            if (m.LParam == handle) {
                menu = this;
            }
            else {
                menu = FindMenuItemInternal(FindHandle, m.LParam);
            }
            
            if (menu != null) {
                char key = Char.ToUpper((char)((int)m.WParam & 0x0000FFFF), CultureInfo.CurrentCulture);
                
                foreach(MenuItem mi in menu.items) {
                    //First check that out menu item is not null - keep in mind that
                    //we build this array up in increments of 4 (so we can have null items)
                    //
                    if (mi != null && mi.OwnerDraw && mi.Mnemonic == key) {
                        m.Result = (IntPtr)NativeMethods.Util.MAKELONG(mi.MenuIndex, NativeMethods.MNC_EXECUTE);
                        break;
                    }
                }
            }
        }
        
        /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [ListBindable(false)]
        public class MenuItemCollection : IList {
            private Menu owner;

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.MenuItemCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public MenuItemCollection(Menu owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.this"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual MenuItem this[int index] {
                get {
                    if (index < 0 || index >= owner.itemCount)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  (index).ToString()));
                    return owner.items[index];
                }
                // set not supported
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Count {
                get {
                    return owner.itemCount;
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
           
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Add"]/*' />
            /// <devdoc>
            ///     Adds a new MenuItem to the end of this menu with the specified caption.
            /// </devdoc>
            public virtual MenuItem Add(string caption) {
                MenuItem item = new MenuItem(caption);
                Add(item);
                return item;
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Add1"]/*' />
            /// <devdoc>
            ///     Adds a new MenuItem to the end of this menu with the specified caption,
            ///     and click handler.
            /// </devdoc>
            public virtual MenuItem Add(string caption, EventHandler onClick) {
                MenuItem item = new MenuItem(caption, onClick);
                Add(item);
                return item;
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Add2"]/*' />
            /// <devdoc>
            ///     Adds a new MenuItem to the end of this menu with the specified caption,
            ///     click handler, and items.
            /// </devdoc>
            public virtual MenuItem Add(string caption, MenuItem[] items) {
                MenuItem item = new MenuItem(caption, items);
                Add(item);
                return item;
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Add3"]/*' />
            /// <devdoc>
            ///     Adds a MenuItem to the end of this menu
            ///     MenuItems can only be contained in one menu at a time, and may not be added
            ///     more than once to the same menu.
            /// </devdoc>
            public virtual int Add(MenuItem item) {                
                return Add(owner.itemCount, item);
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Add4"]/*' />
            /// <devdoc>
            ///     Adds a MenuItem to this menu at the specified index.  The item currently at
            ///     that index, and all items after it, will be moved up one slot.
            ///     MenuItems can only be contained in one menu at a time, and may not be added
            ///     more than once to the same menu.
            /// </devdoc>
            public virtual int Add(int index, MenuItem item) {
                // MenuItems can only belong to one menu at a time
                if (item.menu != null){
                    // First check that we're not adding ourself, i.e. walk
                    // the parent chain for equality
                    if (owner is MenuItem) {
                        MenuItem parent = (MenuItem)owner;
                        while (parent != null) {
                            if (parent.Equals(item)) {
                                throw new ArgumentException(SR.GetString(SR.MenuItemAlreadyExists, item.Text), "item");
                            }
                            if (parent.Parent is MenuItem)
                                parent = (MenuItem)parent.Parent;
                            else 
                                break;
                        }
                    }

                    item.menu.MenuItems.Remove(item);
                }

                if (index < 0 || index > owner.itemCount) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,"index",(index).ToString()));
                }
                
                if (owner.items == null || owner.items.Length == owner.itemCount) {
                    MenuItem[] newItems = new MenuItem[owner.itemCount < 2? 4: owner.itemCount * 2];
                    if (owner.itemCount > 0) System.Array.Copy(owner.items, 0, newItems, 0, owner.itemCount);
                    owner.items = newItems;
                }
                System.Array.Copy(owner.items, index, owner.items, index + 1, owner.itemCount - index);
                owner.items[index] = item;
                owner.itemCount++;
                item.menu = owner;
                owner.ItemsChanged(CHANGE_ITEMS);
                
                return index;
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void AddRange(MenuItem[] items) {
                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                foreach(MenuItem item in items) {
                    Add(item);
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                if (value is MenuItem) {
                    return Add((MenuItem)value);
                }
                else {  
                    throw new ArgumentException("value");
                }
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(MenuItem value) {
                return IndexOf(value) != -1;
            }
        
            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object value) {
                if (value is MenuItem) {
                    return Contains((MenuItem)value);
                }
                else {  
                    return false;
                }
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(MenuItem value) {
                for(int index=0; index < Count; ++index) {
                    if (this[index] == value) {
                        return index;
                    } 
                }
                return -1;
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object value) {
                if (value is MenuItem) {
                    return IndexOf((MenuItem)value);
                }
                else {  
                    return -1;
                }
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                if (value is MenuItem) {
                    Add(index, (MenuItem)value);                    
                }
                else {  
                    throw new ArgumentException("value");
                }
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Clear"]/*' />
            /// <devdoc>
            ///     Removes all existing MenuItems from this menu
            /// </devdoc>
            public virtual void Clear() {
                if (owner.itemCount > 0) {
                    
                    for (int i = 0; i < owner.itemCount; i++) {
                        owner.items[i].menu = null;
                    }

                    owner.itemCount = 0;
                    owner.items = null;

                    owner.ItemsChanged(CHANGE_ITEMS);

                    if (owner is MenuItem) {
                        ((MenuItem)(owner)).UpdateMenuItem(true);
                    }
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                if (owner.itemCount > 0) {
                    System.Array.Copy(owner.items, 0, dest, index, owner.itemCount);
                }
            }
            
            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new WindowsFormsUtils.ArraySubsetEnumerator(owner.items, owner.itemCount);
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///     Removes the item at the specified index in this menu.  All subsequent
            ///     items are moved up one slot.
            /// </devdoc>
            public virtual void RemoveAt(int index) {
                if (index < 0 || index >= owner.itemCount) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,"index",(index).ToString()));
                }

                MenuItem item = owner.items[index];
                item.menu = null;
                owner.itemCount--;
                System.Array.Copy(owner.items, index + 1, owner.items, index, owner.itemCount - index);
                owner.items[owner.itemCount] = null;
                owner.ItemsChanged(CHANGE_ITEMS);

                //if the last item was removed, clear the collection
                //
                if (owner.itemCount == 0) {
                    Clear();
                }
            
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="Menu.MenuItemCollection.Remove"]/*' />
            /// <devdoc>
            ///     Removes the specified item from this menu.  All subsequent
            ///     items are moved down one slot.
            /// </devdoc>
            public virtual void Remove(MenuItem item) {
                if (item.menu == owner) {
                    RemoveAt(item.Index);
                }
            }

            /// <include file='doc\Menu.uex' path='docs/doc[@for="MenuItemCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                if (value is MenuItem) {
                    Remove((MenuItem)value);
                }                
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\menuglyph.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuGlyph.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\MenuGlyph.uex' path='docs/doc[@for="MenuGlyph"]/*' />
    /// <devdoc>
    ///     Enum to be used with the drawMenuGlyph function.
    ///
    /// </devdoc>
    public enum MenuGlyph {

        /// <include file='doc\MenuGlyph.uex' path='docs/doc[@for="MenuGlyph.Arrow"]/*' />
        /// <devdoc>
        ///     Draws a submenu arrow.
        /// </devdoc>
        Arrow = NativeMethods.DFCS_MENUARROW,

        /// <include file='doc\MenuGlyph.uex' path='docs/doc[@for="MenuGlyph.Checkmark"]/*' />
        /// <devdoc>
        ///     Draws a menu checkmark.
        /// </devdoc>
        Checkmark = NativeMethods.DFCS_MENUCHECK,

        /// <include file='doc\MenuGlyph.uex' path='docs/doc[@for="MenuGlyph.Bullet"]/*' />
        /// <devdoc>
        ///     Draws a menu bullet.
        /// </devdoc>
        Bullet = NativeMethods.DFCS_MENUBULLET,

        /// <include file='doc\MenuGlyph.uex' path='docs/doc[@for="MenuGlyph.Min"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Min = NativeMethods.DFCS_MENUARROW,
        /// <include file='doc\MenuGlyph.uex' path='docs/doc[@for="MenuGlyph.Max"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Max = NativeMethods.DFCS_MENUBULLET,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\messagebox.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays a
    ///       message box that can contain text, buttons, and symbols that
    ///       inform and instruct the
    ///       user.
    ///    </para>
    /// </devdoc>
    public class MessageBox {
        private const int IDOK             = 1;
        private const int IDCANCEL         = 2;
        private const int IDABORT          = 3;
        private const int IDRETRY          = 4;
        private const int IDIGNORE         = 5;
        private const int IDYES            = 6;
        private const int IDNO             = 7;

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.MessageBox"]/*' />
        /// <devdoc>
        ///     This constructor is private so people aren't tempted to try and create
        ///     instances of these -- they should just use the static show
        ///     methods.
        /// </devdoc>
        private MessageBox() {
        }

        private static DialogResult Win32ToDialogResult(int value) {
            switch (value) {
                case IDOK:
                    return DialogResult.OK;
                case IDCANCEL:
                    return DialogResult.Cancel;
                case IDABORT:
                    return DialogResult.Abort;
                case IDRETRY:
                    return DialogResult.Retry;
                case IDIGNORE:
                    return DialogResult.Ignore;
                case IDYES:
                    return DialogResult.Yes;
                case IDNO:
                    return DialogResult.No;
                default:
                    return DialogResult.No;
            }
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon, 
                                        MessageBoxDefaultButton defaultButton, MessageBoxOptions options) {
            return ShowCore(null, text, caption, buttons, icon, defaultButton, options);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon, 
                                        MessageBoxDefaultButton defaultButton) {
            return ShowCore(null, text, caption, buttons, icon, defaultButton, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon) {
            return ShowCore(null, text, caption, buttons, icon, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(string text, string caption, MessageBoxButtons buttons) {
            return ShowCore(null, text, caption, buttons, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text and caption.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(string text, string caption) {
            return ShowCore(null, text, caption, MessageBoxButtons.OK, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(string text) {
            return ShowCore(null, text, "", MessageBoxButtons.OK, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(IWin32Window owner, string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon, 
                                        MessageBoxDefaultButton defaultButton, MessageBoxOptions options) {
            return ShowCore(owner, text, caption, buttons, icon, defaultButton, options);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(IWin32Window owner, string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon, 
                                        MessageBoxDefaultButton defaultButton) {
            return ShowCore(owner, text, caption, buttons, icon, defaultButton, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(IWin32Window owner, string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon) {
            return ShowCore(owner, text, caption, buttons, icon, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text, caption, and style.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(IWin32Window owner, string text, string caption, MessageBoxButtons buttons) {
            return ShowCore(owner, text, caption, buttons, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text and caption.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(IWin32Window owner, string text, string caption) {
            return ShowCore(owner, text, caption, MessageBoxButtons.OK, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, 0);
        }

        /// <include file='doc\MessageBox.uex' path='docs/doc[@for="MessageBox.Show11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays a message box with specified text.
        ///    </para>
        /// </devdoc>
        public static DialogResult Show(IWin32Window owner, string text) {
            return ShowCore(owner, text, "", MessageBoxButtons.OK, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, 0);
        }

        private static DialogResult ShowCore(IWin32Window owner, string text, string caption,   
                                             MessageBoxButtons buttons, MessageBoxIcon icon, MessageBoxDefaultButton defaultButton,
                                             MessageBoxOptions options) {
            if (!Enum.IsDefined(typeof(MessageBoxButtons), buttons))
                throw new InvalidEnumArgumentException("buttons", (int)buttons, typeof(DialogResult));
            if (!Enum.IsDefined(typeof(MessageBoxIcon), icon))
                throw new InvalidEnumArgumentException("icon", (int)icon, typeof(DialogResult));
            if (!Enum.IsDefined(typeof(MessageBoxDefaultButton), defaultButton))
                throw new InvalidEnumArgumentException("defaultButton", (int)defaultButton, typeof(DialogResult));
            
            // options intentionally not verified because we don't expose all the options Win32 supports.

            if (!SystemInformation.UserInteractive && (options & (MessageBoxOptions.ServiceNotification | MessageBoxOptions.DefaultDesktopOnly)) == 0) {
                throw new InvalidOperationException(SR.GetString(SR.CantShowModalOnNonInteractive));
            }
            if (owner != null && (options & (MessageBoxOptions.ServiceNotification | MessageBoxOptions.DefaultDesktopOnly)) != 0) {
                throw new ArgumentException(SR.GetString(SR.CantShowMBServiceWithOwner), "style");
            }

            IntSecurity.SafeSubWindows.Demand();

            int style = (int) buttons | (int) icon | (int) defaultButton | (int) options;

            IntPtr handle = IntPtr.Zero;
            if ((options & (MessageBoxOptions.ServiceNotification | MessageBoxOptions.DefaultDesktopOnly)) == 0) {
                if (owner == null) {
                    handle = UnsafeNativeMethods.GetActiveWindow();
                }
                else {
                    handle = owner.Handle;
                }
            }

            Application.BeginModalMessageLoop();
            DialogResult result = Win32ToDialogResult(SafeNativeMethods.MessageBox(new HandleRef(owner, handle), text, caption, style));
            Application.EndModalMessageLoop();

            return result;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\menumerge.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuMerge.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\MenuMerge.uex' path='docs/doc[@for="MenuMerge"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the behavior of a <see cref='System.Windows.Forms.MenuItem'/> when it is merged with items in another menu.
    ///    </para>
    /// </devdoc>
    public enum MenuMerge {

        /// <include file='doc\MenuMerge.uex' path='docs/doc[@for="MenuMerge.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The <see cref='System.Windows.Forms.MenuItem'/> is added to
        ///       the existing <see cref='System.Windows.Forms.MenuItem'/> objects in a merged menu.
        ///    </para>
        /// </devdoc>
        Add        = 0,

        /// <include file='doc\MenuMerge.uex' path='docs/doc[@for="MenuMerge.Replace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The <see cref='System.Windows.Forms.MenuItem'/> replaces the
        ///       existing <see cref='System.Windows.Forms.MenuItem'/>
        ///       at the same position in a
        ///       merged menu.
        ///
        ///    </para>
        /// </devdoc>
        Replace    = 1,

        /// <include file='doc\MenuMerge.uex' path='docs/doc[@for="MenuMerge.MergeItems"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Subitems of this <see cref='System.Windows.Forms.MenuItem'/> are merged with
        ///       those of existing <see cref='System.Windows.Forms.MenuItem'/> objects
        ///       at the same position in a merged menu.
        ///    </para>
        /// </devdoc>
        MergeItems = 2,

        /// <include file='doc\MenuMerge.uex' path='docs/doc[@for="MenuMerge.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The <see cref='System.Windows.Forms.MenuItem'/> is not included in a merged menu.
        ///    </para>
        /// </devdoc>
        Remove     = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\menuitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Collections;

    using System.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;

    /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an individual item that is displayed within
    ///       a <see cref='System.Windows.Forms.Menu'/> or <see cref='System.Windows.Forms.Menu'/>.
    ///    </para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultEvent("Click"),
    DefaultProperty("Text")
    ]
    public class MenuItem : Menu {
        internal const int STATE_BARBREAK   = 0x00000020;
        internal const int STATE_BREAK      = 0x00000040;
        internal const int STATE_CHECKED    = 0x00000008;
        internal const int STATE_DEFAULT    = 0x00001000;
        internal const int STATE_DISABLED   = 0x00000003;
        internal const int STATE_RADIOCHECK = 0x00000200;
        internal const int STATE_HIDDEN     = 0x00010000;
        internal const int STATE_MDILIST    = 0x00020000;
        internal const int STATE_CLONE_MASK = 0x0003136B;
        internal const int STATE_OWNERDRAW  = 0x00000100;
        internal const int STATE_INMDIPOPUP = 0x00000200;

        internal Menu menu;
        private bool hasHandle;
        private MenuItemData data;
        private int dataVersion;
        private MenuItem nextLinkedItem; // Next item linked to the same MenuItemData.

        // We need to store a table of all created menuitems, so that other objects
        // such as ContainerControl can get a reference to a particular menuitem,
        // given a unique ID.
        private static Hashtable allCreatedMenuItems = new Hashtable();
        private static int createdMenuItemsCounter = 0;
        private int uniqueID = -1;

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a <see cref='System.Windows.Forms.MenuItem'/> with
        ///       a blank caption.
        ///    </para>
        /// </devdoc>
        public MenuItem() : this(MenuMerge.Add, 0, 0, null, null, null, null, null) {
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItem1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see
        ///       cref='System.Windows.Forms.MenuItem'/>
        ///       class with a specified caption for
        ///       the menu item.
        ///    </para>
        /// </devdoc>
        public MenuItem(string text) : this(MenuMerge.Add, 0, 0, text, null, null, null, null) {
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItem2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the
        ///       class with a
        ///       specified caption and
        ///       event handler for the menu item.
        ///    </para>
        /// </devdoc>
        public MenuItem(string text, EventHandler onClick) : this(MenuMerge.Add, 0, 0, text, onClick, null, null, null) {
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItem3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the
        ///       class with a
        ///       specified caption, event handler, and associated
        ///       shorcut key for the menu item.
        ///    </para>
        /// </devdoc>
        public MenuItem(string text, EventHandler onClick, Shortcut shortcut) : this(MenuMerge.Add, 0, shortcut, text, onClick, null, null, null) {
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItem4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the
        ///       class with a
        ///       specified caption and an array of
        ///       submenu items defined for the menu item.
        ///    </para>
        /// </devdoc>
        public MenuItem(string text, MenuItem[] items) : this(MenuMerge.Add, 0, 0, text, null, null, null, items) {
        }

        internal MenuItem(MenuItemData data)
        : base(null) {
            data.AddItem(this);
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItem5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the class with a specified
        ///       caption, defined event-handlers for the Click, Select and
        ///       Popup events, a shortcut key,
        ///       a merge type, and order specified for the menu item.
        /// </para>
        /// </devdoc>
        public MenuItem(MenuMerge mergeType, int mergeOrder, Shortcut shortcut,
                        string text, EventHandler onClick, EventHandler onPopup,
                        EventHandler onSelect, MenuItem[] items)

        : base(items) {

            MenuItemData dataT = new MenuItemData(this, mergeType, mergeOrder, shortcut, true,
                                                  text, onClick, onPopup, onSelect, null, null);
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.BarBreak"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the item is
        ///       placed on a new line (for a menu item added to a <see
        ///       cref='System.Windows.Forms.MainMenu'/> object) or in a new
        ///       column (for a submenu or menu displayed in a <see
        ///       cref='System.Windows.Forms.ContextMenu'/>
        ///       ).
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(false)
        ]
        public bool BarBreak {
            get {
                return(data.State & STATE_BARBREAK) != 0;
            }

            set {
                data.SetState(STATE_BARBREAK, value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Break"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the item is
        ///       placed on a new line (for a menu item added to a <see
        ///       cref='System.Windows.Forms.MainMenu'/> object) or in a new column (for a
        ///       submenu or menu displayed in a <see
        ///       cref='System.Windows.Forms.ContextMenu'/>).
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(false)
        ]
        public bool Break {
            get {
                return(data.State & STATE_BREAK) != 0;
            }

            set {
                data.SetState(STATE_BREAK, value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a checkmark
        ///       appears beside the text of the menu item.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.MenuItemCheckedDescr)
        ]
        public bool Checked {
            get {
                return(data.State & STATE_CHECKED) != 0;
            }

            set {
                //if trying to set checked=true - if we're a top-level item (from a mainmenu) or have children, don't do this...
                if (value == true && (itemCount != 0 || (Parent != null && (Parent is MainMenu)))) {
                    throw new ArgumentException(SR.GetString(SR.MenuItemInvalidCheckProperty));
                }

                data.SetState(STATE_CHECKED, value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.DefaultItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating
        ///       whether the menu item is the default.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.MenuItemDefaultDescr)
        ]        
        public bool DefaultItem {
            get { return(data.State & STATE_DEFAULT) != 0;}
            set {
                if (menu != null) {
                    if (value) {
                        UnsafeNativeMethods.SetMenuDefaultItem(new HandleRef(menu, menu.handle), MenuID, false);
                    }
                    else if (DefaultItem) {
                        UnsafeNativeMethods.SetMenuDefaultItem(new HandleRef(menu, menu.handle), -1, false);
                    }
                }
                data.SetState(STATE_DEFAULT, value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OwnerDraw"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether code
        ///       that you provide draws the menu item or Windows draws the
        ///       menu item.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.MenuItemOwnerDrawDescr)
        ]
        public bool OwnerDraw {
            get {
                return((data.State & STATE_OWNERDRAW) != 0);
            }

            set {
                data.SetState(STATE_OWNERDRAW, value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Enabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the menu
        ///       item is enabled.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(true),
        SRDescription(SR.MenuItemEnabledDescr)
        ]
        public bool Enabled {
            get {
                return(data.State & STATE_DISABLED) == 0;
            }

            set {
                data.SetState(STATE_DISABLED, !value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Index"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the menu item's position in its parent menu.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        ]        
        public int Index {
            get {
                if (menu != null) {
                    for (int i = 0; i < menu.itemCount; i++) {
                        if (menu.items[i] == this) return i;
                    }
                }
                return -1;
            }

            set {
                int oldIndex = Index;
                if (oldIndex >= 0) {
                    if (value < 0 || value >= menu.itemCount) {
                        throw new ArgumentException(SR.GetString(SR.InvalidArgument,"value",(value).ToString()));
                    }

                    if (value != oldIndex) {
                        // this.menu reverts to null when we're removed, so hold onto it in a local variable
                        Menu parent = menu;
                        parent.MenuItems.RemoveAt(oldIndex);
                        parent.MenuItems.Add(value, this);
                    }
                }
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.IsParent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the menu item contains
        ///       child menu items.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        ]         
        public override bool IsParent {
            get {
                bool parent = false;
                if (data != null && MdiList) {
                    for (int i=0; i<itemCount; i++) {
                        if (!(items[i].data.UserData is MdiListUserData)) {
                            parent = true;
                            break;
                        }
                    }
                    if (!parent) {
                        if (FindMdiForms().Length > 0) {
                            parent = true;
                        }
                    }
                    if (!parent) {
                        if (menu != null && !(menu is MenuItem)) {
                            parent = true;
                        }
                    }
                }
                else {
                    parent = base.IsParent;
                }
                return parent;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MdiList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the menu item will be populated
        ///       with a list of the MDI child windows that are displayed within the
        ///       associated form.
        ///    </para>
        /// </devdoc> 
        [
        DefaultValue(false),
        SRDescription(SR.MenuItemMDIListDescr)
        ]
        public bool MdiList {
            get {
                return(data.State & STATE_MDILIST) != 0;
            }
            set {
                data.MdiList = value;
                CleanListItems(this);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuID"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Windows identifier for this menu item.
        ///    </para>
        /// </devdoc> 
        protected int MenuID {
            get { return data.GetMenuID();}
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the zero-based index of this menu
        ///       item in the parent menu, or -1 if this
        ///       menu item is not associated with a 
        ///       parent menu.
        ///    </para>
        /// </devdoc> 
        internal int MenuIndex {
            get {
                if (menu == null) return -1;

                int count = UnsafeNativeMethods.GetMenuItemCount(new HandleRef(menu, menu.Handle));
                int id = MenuID;
                NativeMethods.MENUITEMINFO_T info = new NativeMethods.MENUITEMINFO_T();
                info.cbSize = Marshal.SizeOf(typeof(NativeMethods.MENUITEMINFO_T));
                info.fMask = NativeMethods.MIIM_ID | NativeMethods.MIIM_SUBMENU;
                
                for(int i = 0; i < count; i++) {
                    UnsafeNativeMethods.GetMenuItemInfo(new HandleRef(menu, menu.handle), i, true, info);

                    // For sub menus, the handle is always valid.  For
                    // items, however, it is always zero.
                    //
                    if ((info.hSubMenu == IntPtr.Zero || info.hSubMenu == Handle) && info.wID == id) {
                        return i;
                    }
                }
                return -1;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MergeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates the behavior of this
        ///       menu item when its menu is merged with another.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(MenuMerge.Add),
        SRDescription(SR.MenuItemMergeTypeDescr)
        ]
        public MenuMerge MergeType {
            get {
                return data.mergeType;
            }
            set {
                if (!Enum.IsDefined(typeof(MenuMerge), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(MenuMerge));
                }

                data.MergeType = value;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MergeOrder"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the relative position the menu item when its
        ///       menu is merged with another.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(0),
        SRDescription(SR.MenuItemMergeOrderDescr)
        ]
        public int MergeOrder {
            get {
                return data.mergeOrder;
            }
            set {
                data.MergeOrder = value;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Mnemonic"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Retrieves the hotkey mnemonic that is associated with this menu item.
        ///     The mnemonic is the first character after an ampersand symbol in the menu's text
        ///     that is not itself an ampersand symbol.  If no such mnemonic is defined this
        ///     will return zero.
        ///     </para>
        /// </devdoc>
        [Browsable(false)]
        public char Mnemonic {
            get {
                return data.Mnemonic;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Parent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the menu in which this menu item
        ///       appears.
        ///    </para>
        /// </devdoc> 
        [Browsable(false)]
        public Menu Parent {
            get { return menu;}
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.RadioCheck"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates whether the menu item,
        ///       if checked, displays a radio-button mark instead of a check mark.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.MenuItemCheckedDescr)
        ]
        public bool RadioCheck {
            get {
                return(data.State & STATE_RADIOCHECK) != 0;
            }
            set {
                data.SetState(STATE_RADIOCHECK, value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text of the menu item.
        ///    </para>
        /// </devdoc> 
        [
        Localizable(true),
        SRDescription(SR.MenuItemTextDescr)
        ]
        public string Text {
            get {
                return data.caption;
            }
            set {
                data.SetCaption(value);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Shortcut"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the shortcut key associated with the menu
        ///       item.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(Shortcut.None),
        SRDescription(SR.MenuItemShortCutDescr)
        ]
        public Shortcut Shortcut {
            get {
                return data.shortcut;
            }
            set {
                if (!Enum.IsDefined(typeof(Shortcut), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(Shortcut));
                }

                data.shortcut = value;
                UpdateMenuItem(true);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.ShowShortcut"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates whether the shortcut
        ///       key that is assocaited
        ///       with the menu item is displayed next to the menu item
        ///       caption.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.MenuItemShowShortCutDescr)
        ]
        public bool ShowShortcut {
            get {

                return data.showShortcut;
            }
            set {
                if (value != data.showShortcut) {
                    data.showShortcut = value;
                    UpdateMenuItem(true);
                }
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Visible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates
        ///       whether the menu item is visible on its parent menu.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(true),
        SRDescription(SR.MenuItemVisibleDescr)
        ]
        public bool Visible {
            get {
                return(data.State & STATE_HIDDEN) == 0;
            }
            set {
                data.Visible = value;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Click"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the menu item is clicked or selected using a
        ///       shortcut key defined for the menu item.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.MenuItemOnClickDescr)]
        public event EventHandler Click {
            add {
                data.onClick += value;
            }
            remove {
                data.onClick -= value;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.DrawItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when when the property of a menu item is set
        ///       to
        ///    <see langword='true'/>
        ///    and a request is made to draw the menu item.
        /// </para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.drawItemEventDescr)]
        public event DrawItemEventHandler DrawItem {
            add {
                data.onDrawItem += value;
            }
            remove {
                data.onDrawItem -= value;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MeasureItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when when the menu needs to know the size of a
        ///       menu item before drawing it.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.measureItemEventDescr)]
        public event MeasureItemEventHandler MeasureItem {
            add {
                data.onMeasureItem += value;
            }
            remove {
                data.onMeasureItem -= value;
            }
        }

        private bool ParentIsRightToLeft {
            get {
                Menu parent = GetMainMenu();

                if (parent != null) {
                    return((MainMenu)parent).RightToLeft == RightToLeft.Yes;
                }
                else {
                    parent = GetContextMenu();
                    if (parent != null) {
                        return((ContextMenu)parent).RightToLeft == RightToLeft.Yes;    
                    }
                }

                return false;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Popup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs before a menu item's list of menu items is
        ///       displayed.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.MenuItemOnInitDescr)]
        public event EventHandler Popup {
            add {
                data.onPopup += value;
            }
            remove {
                data.onPopup -= value;
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the user hovers their mouse over a menu
        ///       item
        ///       or selects it with the keyboard but has not activated it.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.MenuItemOnSelectDescr)]
        public event EventHandler Select {
            add {
                data.onSelect += value;
            }
            remove {
                data.onSelect -= value;
            }
        }

        private void CleanListItems(MenuItem senderMenu) {
            // remove any old list items
            //
            MenuItemCollection oldItems = senderMenu.MenuItems;
            ArrayList newItems = new ArrayList();
            bool needUpdate = false;
            for (int i=0; i<oldItems.Count; i++) {
                if (!(oldItems[i].data.UserData is MdiListUserData)) {
                    newItems.Add(oldItems[i]);
                }
                else {
                    needUpdate = true;
                }
            }
            if (needUpdate) {
                senderMenu.MenuItems.Clear();
                foreach(MenuItem item in newItems) {
                    senderMenu.MenuItems.Add(item);
                }
            }
        }

        internal void CleanupHashtable() {
            if (this.data != null) {
                MenuItem bItem = this.data.baseItem;
                MenuItemData menuData = this.data;

                MenuItem menuItem = this.data.firstItem;
                while (menuItem != null) {
                    MenuItem nextItem = menuItem.nextLinkedItem;
                    if (menuItem.uniqueID != -1) {
                        allCreatedMenuItems.Remove(menuItem.uniqueID);
                    }
                    if (menuItem != bItem) {
                        menuData.RemoveItem(menuItem);
                        menuItem.menu = null;
                    }
                    menuItem = nextItem;
                }
                // now get rid of the menu items created at merge
                //
                menuData.baseItem = bItem;
                menuData.firstItem = bItem;
                bItem.nextLinkedItem = null;
            }
            for (int i = 0; i < itemCount; i++) {
                MenuItem menu = items[i];
                menu.CleanupHashtable();
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.CloneMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates and returns an identical copy of this menu item.
        ///    </para>
        /// </devdoc>
        public virtual MenuItem CloneMenu() {
            MenuItem newItem = new MenuItem();
            newItem.CloneMenu(this);
            return newItem;
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.CloneMenu1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a copy of the specified menu item.
        ///    </para>
        /// </devdoc>
        protected void CloneMenu(MenuItem itemSrc) {
            base.CloneMenu(itemSrc);
            int state = itemSrc.data.State;
            new MenuItemData(this,
                             itemSrc.MergeType, itemSrc.MergeOrder, itemSrc.Shortcut, itemSrc.ShowShortcut,
                             itemSrc.Text, itemSrc.data.onClick, itemSrc.data.onPopup, itemSrc.data.onSelect,
                             itemSrc.data.onDrawItem, itemSrc.data.onMeasureItem);
            data.SetState(state & STATE_CLONE_MASK, true);
        }

        internal virtual void CreateMenuItem() {
            if ((data.State & STATE_HIDDEN) == 0) {
                NativeMethods.MENUITEMINFO_T info = CreateMenuItemInfo();
                UnsafeNativeMethods.InsertMenuItem(new HandleRef(menu, menu.handle), -1, true, info);

                hasHandle = info.hSubMenu != IntPtr.Zero;
                dataVersion = data.version;
#if DEBUG
                NativeMethods.MENUITEMINFO_T infoVerify = new NativeMethods.MENUITEMINFO_T();
                infoVerify.cbSize = Marshal.SizeOf(typeof(NativeMethods.MENUITEMINFO_T));
                infoVerify.fMask = NativeMethods.MIIM_ID | NativeMethods.MIIM_STATE |
                                   NativeMethods.MIIM_SUBMENU | NativeMethods.MIIM_TYPE;
                UnsafeNativeMethods.GetMenuItemInfo(new HandleRef(menu, menu.handle), MenuID, false, infoVerify);
#endif
            }
        }

        private NativeMethods.MENUITEMINFO_T CreateMenuItemInfo() {
            NativeMethods.MENUITEMINFO_T info = new NativeMethods.MENUITEMINFO_T();
            info.fMask = NativeMethods.MIIM_ID | NativeMethods.MIIM_STATE |
                         NativeMethods.MIIM_SUBMENU | NativeMethods.MIIM_TYPE | NativeMethods.MIIM_DATA;
            info.fType = data.State & (STATE_BARBREAK | STATE_BREAK | STATE_RADIOCHECK | STATE_OWNERDRAW);

            // V7#646 - Top level menu items shouldn't have barbreak or break
            //          bits set on them...
            //
            bool isTopLevel = false;
            if (menu == GetMainMenu()) {
                isTopLevel = true;
            }

            if (data.caption.Equals("-")) {
                if (isTopLevel) {
                    data.caption = " ";
                    info.fType |= NativeMethods.MFT_MENUBREAK;
                }
                else {
                    info.fType |= NativeMethods.MFT_SEPARATOR;
                }
            }

            if (ParentIsRightToLeft) {
                info.fType |= NativeMethods.MFT_RIGHTJUSTIFY | NativeMethods.MFT_RIGHTORDER;                    
            }      
                                                                     
            info.fState = data.State & (STATE_CHECKED | STATE_DEFAULT | STATE_DISABLED);

            info.wID = MenuID;
            if (IsParent) {
                info.hSubMenu = Handle;
            }
            info.hbmpChecked = IntPtr.Zero;
            info.hbmpUnchecked = IntPtr.Zero;

            // Add this menuitem to the static table of all created menu items,
            // and store the unique ID in the MenuItemInfo struct which is
            // passed to windows.
            // This allows Form to delegate messages straight to this menu item.
            // (See ContainerControl.WmMeasureItem)
            uniqueID = createdMenuItemsCounter++;
            allCreatedMenuItems.Add(uniqueID, this);
            info.dwItemData = uniqueID;

            // We won't render the shortcut if: 1) it's not set, 2) we're a parent, 3) we're toplevel
            //
            if (data.showShortcut && data.shortcut != 0 && !IsParent && !isTopLevel) {
                info.dwTypeData = data.caption + "\t" + TypeDescriptor.GetConverter(typeof(Keys)).ConvertToString((Keys)(int)data.shortcut);
            }
            else {
                // Windows issue: Items with empty captions sometimes block keyboard
                // access to other items in same menu.
                info.dwTypeData = (data.caption.Length == 0 ? " " : data.caption);
            }
            info.cch = 0;

            return info;
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes the <see cref='System.Windows.Forms.MenuItem'/>.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (menu != null)
                    menu.MenuItems.Remove(this);
                if (data != null)
                    data.RemoveItem(this);
                allCreatedMenuItems.Remove(uniqueID);
            }
            base.Dispose(disposing);
        }

        // Given the unique integer ID of a MenuItem, find the MenuItem
        // in the table of all created menuitems.
        internal static MenuItem GetMenuItemFromUniqueID(int uniqueID) {
            return(MenuItem)allCreatedMenuItems[uniqueID];
        }

        internal override void ItemsChanged(int change) {
            base.ItemsChanged(change);
            if (!hasHandle && IsParent)
                UpdateMenuItem(true);
            MainMenu main = GetMainMenu();
            if (main != null && ((data.State & STATE_INMDIPOPUP) == 0)) {
                main.ItemsChanged(change, this);
            }
        }

        private Form[] FindMdiForms() {
            Form[] forms = null;
            MainMenu main = GetMainMenu();
            Form menuForm = null;
            if (main != null) {
                menuForm = main.GetForm();
            }
            if (menuForm != null) {
                forms = menuForm.MdiChildren;
            }
            if (forms == null) {
                forms = new Form[0];
            }
            return forms;
        }

        private void MdiPopup() {
            MenuItem senderMenu = this;
            data.SetState(STATE_INMDIPOPUP, true);
            try {
                CleanListItems(this);

                // add new items
                //
                Form[] forms = FindMdiForms();
                if (forms != null && forms.Length > 0) {

                    bool hitActive = false;
                    int accel = 1;
                    Form active = GetMainMenu().GetForm().ActiveMdiChild;

                    if (senderMenu.MenuItems.Count > 0) {
                        MenuItem sep = (MenuItem)Activator.CreateInstance(this.GetType());
                        sep.data.UserData = new MdiListUserData();
                        sep.Text = "-";
                        senderMenu.MenuItems.Add(sep);
                    }

                    int visibleChildren = 0;
                    for (int i=0; i<forms.Length; i++) {

                        // We only display nine items, so if we're on the last item and haven't listed
                        // the active form, make that the last item.
                        if (!hitActive && visibleChildren==8) {
                            for (int j=i; j<forms.Length; j++) {
                                if (forms[j].Equals(active)) {
                                    i = j;
                                    break;
                                }
                            }
                        }

                        if (forms[i].Visible && visibleChildren < 9) {
                            visibleChildren++;

                            MenuItem windowItem = (MenuItem)Activator.CreateInstance(this.GetType());
                            windowItem.data.UserData = new MdiListFormData(forms[i]);
                            if (forms[i].Equals(active)) {
                                hitActive = true;
                                windowItem.Checked = true;
                            }
                            windowItem.Text = "&" + accel.ToString() + " " + forms[i].Text;
                            accel++;
                            senderMenu.MenuItems.Add(windowItem);

                        }
                    }

                    if (visibleChildren == 9) {
                        MenuItem moreWindows = (MenuItem)Activator.CreateInstance(this.GetType());
                        moreWindows.data.UserData = new MdiListMoreWindowsData(active, forms);
                        moreWindows.Text = SR.GetString(SR.MDIMenuMoreWindows);
                        senderMenu.MenuItems.Add(moreWindows);
                    }
                }
            } finally {
                data.SetState(STATE_INMDIPOPUP, false);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MergeMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges this menu item with another menu item and returns
        ///       the resulting merged <see
        ///       cref='System.Windows.Forms.MenuItem'/>.
        ///    </para>
        /// </devdoc>
        public virtual MenuItem MergeMenu() {
            MenuItem newItem = (MenuItem)Activator.CreateInstance(this.GetType());
            data.AddItem(newItem);
            newItem.MergeMenu(this);
            return newItem;
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MergeMenu1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges another menu item with this menu item.
        ///    </para>
        /// </devdoc>
        public void MergeMenu(MenuItem itemSrc) {
            base.MergeMenu(itemSrc);
            itemSrc.data.AddItem(this);
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OnClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.MenuItem.Click'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnClick(EventArgs e) {
            if (data.UserData is MdiListUserData) {
                ((MdiListUserData)data.UserData).OnClick(e);
            }
            else if (data.baseItem != this) {
                data.baseItem.OnClick(e);
            }
            else if (data.onClick != null) {
                data.onClick.Invoke(this, e);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OnDrawItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.MenuItem.DrawItem'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnDrawItem(DrawItemEventArgs e) {
            if (data.baseItem != this) {
                data.baseItem.OnDrawItem(e);
            }
            else if (data.onDrawItem != null) {
                data.onDrawItem(this, e);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OnMeasureItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.MenuItem.MeasureItem'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnMeasureItem(MeasureItemEventArgs e) {
            if (data.baseItem != this) {
                data.baseItem.OnMeasureItem(e);
            }
            else if (data.onMeasureItem != null) {
                data.onMeasureItem(this, e);
            }

        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OnPopup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.MenuItem.Popup'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnPopup(EventArgs e) {
            bool recreate = false;
            for (int i=0; i<itemCount; i++) {
                if (items[i].MdiList) {
                    recreate = true;
                    items[i].UpdateMenuItem(true);
                }
            }
            if (recreate || (hasHandle && !IsParent)) {
                UpdateMenuItem(true);
            }

            if (data.baseItem != this) {
                data.baseItem.OnPopup(e);
            }
            else if (data.onPopup != null) {
                data.onPopup.Invoke(this, e);
            }

            // Update any subitem states that got changed in the event
            for (int i = 0; i < itemCount; i++) {
                items[i].UpdateMenuItemIfDirty();
            }

            if (MdiList) {
                MdiPopup();
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OnSelect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.MenuItem.Select'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnSelect(EventArgs e) {
            if (data.baseItem != this) {
                data.baseItem.OnSelect(e);
            }
            else if (data.onSelect != null) {
                data.onSelect.Invoke(this, e);
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.OnInitMenuPopup"]/*' />
        /// <internalonly/>
        protected virtual void OnInitMenuPopup(EventArgs e) {
            OnPopup(e);
        }

        // C#r
        internal virtual void _OnInitMenuPopup( EventArgs e ) {
            OnInitMenuPopup( e );
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.PerformClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates a <see cref='System.Windows.Forms.Control.Click'/>
        ///       event for the MenuItem, simulating a click by a
        ///       user.
        ///    </para>
        /// </devdoc>
        public void PerformClick() {
            OnClick(EventArgs.Empty);
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.PerformSelect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.MenuItem.Select'/>
        ///       event for this menu item.
        ///    </para>
        /// </devdoc>
        public virtual void PerformSelect() {
            OnSelect(EventArgs.Empty);
        }

        internal virtual bool ShortcutClick() {
            if (menu is MenuItem) {
                MenuItem parent = (MenuItem)menu;
                if (!parent.ShortcutClick() || menu != parent) return false;
            }
            if ((data.State & STATE_DISABLED) != 0) return false;
            if (itemCount > 0)
                OnPopup(EventArgs.Empty);
            else
                OnClick(EventArgs.Empty);
            return true;
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns a string representation for this control.
        ///    </para>
        /// </devdoc>
        public override string ToString() {

            string s = base.ToString();
            
            String menuItemText = String.Empty;

            if (data != null && data.caption != null)
                menuItemText = data.caption;

            return s + ", Text: " + menuItemText;
        }

        internal void UpdateMenuItemIfDirty() {
            if (dataVersion != data.version)
                UpdateMenuItem(true);
        }
        
        internal void UpdateItemRtl() {
            NativeMethods.MENUITEMINFO_T info = new NativeMethods.MENUITEMINFO_T();
            info.fMask          = NativeMethods.MIIM_TYPE | NativeMethods.MIIM_STATE | NativeMethods.MIIM_SUBMENU;
            info.dwTypeData     = new string('\0', Text.Length + 2);
            info.cbSize         = Marshal.SizeOf(typeof(NativeMethods.MENUITEMINFO_T));
            info.cch            = info.dwTypeData.Length - 1;
            UnsafeNativeMethods.GetMenuItemInfo(new HandleRef(menu, menu.handle), MenuID, false, info);
            info.fType |= NativeMethods.MFT_RIGHTJUSTIFY | NativeMethods.MFT_RIGHTORDER;
            UnsafeNativeMethods.SetMenuItemInfo(new HandleRef(menu, menu.handle), MenuID, false, info);

#if DEBUG
            info.fMask          = NativeMethods.MIIM_TYPE | NativeMethods.MIIM_STATE | NativeMethods.MIIM_SUBMENU;
            info.dwTypeData     = new string('\0', 256);
            info.cbSize         = Marshal.SizeOf(typeof(NativeMethods.MENUITEMINFO_T));
            info.cch            = info.dwTypeData.Length - 1;
            UnsafeNativeMethods.GetMenuItemInfo(new HandleRef(menu, menu.handle), MenuID, false, info);
            Debug.Assert((info.fType & NativeMethods.MFT_RIGHTORDER) != 0, "Failed to set bit!");
#endif
        }


        internal void UpdateMenuItem(bool force) {
            if (menu == null || !menu.created) {
                return;
            }

            if (force || menu is MainMenu || menu is ContextMenu) {
                NativeMethods.MENUITEMINFO_T info = CreateMenuItemInfo();
                UnsafeNativeMethods.SetMenuItemInfo(new HandleRef(menu, menu.handle), MenuID, false, info);
#if DEBUG
                NativeMethods.MENUITEMINFO_T infoVerify = new NativeMethods.MENUITEMINFO_T();
                infoVerify.cbSize = Marshal.SizeOf(typeof(NativeMethods.MENUITEMINFO_T));
                infoVerify.fMask = NativeMethods.MIIM_ID | NativeMethods.MIIM_STATE |
                                   NativeMethods.MIIM_SUBMENU | NativeMethods.MIIM_TYPE;
                UnsafeNativeMethods.GetMenuItemInfo(new HandleRef(menu, menu.handle), MenuID, false, infoVerify);
#endif

                if (hasHandle && info.hSubMenu == IntPtr.Zero)
                    ClearHandles();
                hasHandle = info.hSubMenu != IntPtr.Zero;
                dataVersion = data.version;
                if (menu is MainMenu) {
                    Form f = ((MainMenu)menu).GetForm();
                    SafeNativeMethods.DrawMenuBar(new HandleRef(f, f.Handle));
                }
            }
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.WmDrawItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void WmDrawItem(ref Message m) {

            // Handles the OnDrawItem message sent from ContainerControl

            NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT));
            Debug.WriteLineIf(Control.PaletteTracing.TraceVerbose, Handle + ": Force set palette in MenuItem drawitem");
            IntPtr oldPal = Control.SetUpPalette(dis.hDC, false /*force*/, false);
            try {
                Graphics g = Graphics.FromHdcInternal(dis.hDC);
                try {
                    OnDrawItem(new DrawItemEventArgs(g, SystemInformation.MenuFont, Rectangle.FromLTRB(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, dis.rcItem.bottom), Index, (DrawItemState)dis.itemState));
                }
                finally {
                    g.Dispose();
                }
            }
            finally {
                if (oldPal != IntPtr.Zero) {
                    SafeNativeMethods.SelectPalette(new HandleRef(null, dis.hDC), new HandleRef(null, oldPal), 0);
                }
            }


            m.Result = (IntPtr)1;
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.WmMeasureItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void WmMeasureItem(ref Message m) {

            // Handles the OnMeasureItem message sent from ContainerControl

            // Obtain the measure item struct
            NativeMethods.MEASUREITEMSTRUCT mis = (NativeMethods.MEASUREITEMSTRUCT)m.GetLParam(typeof(NativeMethods.MEASUREITEMSTRUCT));
            // The OnMeasureItem handler now determines the height and width of the item

            IntPtr screendc = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            Graphics graphics = Graphics.FromHdcInternal(screendc);
            MeasureItemEventArgs mie = new MeasureItemEventArgs(graphics, Index);
            try {
                OnMeasureItem(mie);
            }
            finally {
                graphics.Dispose();
            }
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screendc));

            // Update the measure item struct with the new width and height
            mis.itemHeight = mie.ItemHeight;
            mis.itemWidth = mie.ItemWidth;
            Marshal.StructureToPtr(mis, m.LParam, false);

            m.Result = (IntPtr)1;
        }

        /// <include file='doc\MenuItem.uex' path='docs/doc[@for="MenuItem.MenuItemData"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal class MenuItemData : ICommandExecutor {
            internal MenuItem baseItem;
            internal MenuItem firstItem;

            private int state;
            internal int version;
            internal MenuMerge mergeType;
            internal int mergeOrder;
            internal string caption;
            internal short mnemonic;
            internal Shortcut shortcut;
            internal bool showShortcut;
            internal EventHandler onClick;
            internal EventHandler onPopup;
            internal EventHandler onSelect;
            internal DrawItemEventHandler onDrawItem;
            internal MeasureItemEventHandler onMeasureItem;

            private object userData = null;
            internal Command cmd;

            internal MenuItemData(MenuItem baseItem, MenuMerge mergeType, int mergeOrder, Shortcut shortcut, bool showShortcut,
                                  string caption, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, 
                                  DrawItemEventHandler onDrawItem, MeasureItemEventHandler onMeasureItem) {
                AddItem(baseItem);
                this.mergeType = mergeType;
                this.mergeOrder = mergeOrder;
                this.shortcut = shortcut;
                this.showShortcut = showShortcut;
                this.caption = caption == null? "": caption;
                this.onClick = onClick;
                this.onPopup = onPopup;
                this.onSelect = onSelect;
                this.onDrawItem = onDrawItem;
                this.onMeasureItem = onMeasureItem;
                this.version = 1;
                this.mnemonic = -1;
            }


            internal bool MdiList {
                get {
                    return HasState(STATE_MDILIST);
                }
                set {
                    if (((state & STATE_MDILIST) != 0) != value) {
                        SetState(STATE_MDILIST, value);
                        for (MenuItem item = firstItem; item != null; item = item.nextLinkedItem) {
                            item.ItemsChanged(Menu.CHANGE_MDI);
                        }
                    }
                }
            }

            internal MenuMerge MergeType {
                get {
                    return mergeType;
                }
                set {
                    if (mergeType != value) {
                        mergeType = value;
                        ItemsChanged(Menu.CHANGE_MERGE);
                    }
                }
            }

            internal int MergeOrder {
                get {
                    return mergeOrder;
                }
                set {
                    if (mergeOrder != value) {
                        mergeOrder = value;
                        ItemsChanged(Menu.CHANGE_MERGE);
                    }
                }
            }

            internal char Mnemonic {
                get {
                    if (mnemonic == -1) {
                        int len = caption.Length;
                        for (int i = 0; i < len; i++) {
                            if (caption[i] == '&' && i+1 < len && caption[i+1] != '&') {
                                mnemonic = (short)Char.ToUpper(caption[i+1], CultureInfo.CurrentCulture);
                                break;
                            }
                        }

                        if (mnemonic == -1) mnemonic = 0;
                    }
                    return(char)mnemonic;
                }
            }

            internal int State {
                get {
                    return state;
                }
            }

            internal bool Visible  {
                get {
                    return(state & MenuItem.STATE_HIDDEN) == 0;
                }
                set {
                    if (((state & MenuItem.STATE_HIDDEN) == 0) != value) {
                        state = value? state & ~MenuItem.STATE_HIDDEN: state | MenuItem.STATE_HIDDEN;
                        ItemsChanged(Menu.CHANGE_VISIBLE);
                    }
                }
            }


            internal object UserData {
                get {
                    return userData;
                }
                set {
                    userData = value;
                }
            }

            internal virtual void AddItem(MenuItem item) {
                if (item.data != this) {
                    if (item.data != null)
                        item.data.RemoveItem(item);
                    item.nextLinkedItem = firstItem;
                    firstItem = item;
                    if (baseItem == null) baseItem = item;
                    item.data = this;
                    item.dataVersion = 0;
                    item.UpdateMenuItem(false);
                }
            }

            public virtual void Execute() {
                if (baseItem != null) {
                    baseItem.OnClick(EventArgs.Empty);
                }
            }

            internal virtual int GetMenuID() {
                if (null == cmd)
                    cmd = new Command(this);
                return cmd.ID;
            }

            internal virtual void ItemsChanged(int change) {
                for (MenuItem item = firstItem; item != null; item = item.nextLinkedItem) {
                    if (item.menu != null)
                        item.menu.ItemsChanged(change);
                }
            }

            internal virtual void RemoveItem(MenuItem item) {
                Debug.Assert(item.data == this, "bad item passed to MenuItemData.removeItem");

                if (item == firstItem) {
                    firstItem = item.nextLinkedItem;
                }
                else {
                    MenuItem itemT;
                    for (itemT = firstItem; item != itemT.nextLinkedItem;)
                        itemT = itemT.nextLinkedItem;
                    itemT.nextLinkedItem = item.nextLinkedItem;
                }
                item.nextLinkedItem = null;
                item.data = null;
                item.dataVersion = 0;

                if (item == baseItem)
                    baseItem = firstItem;

                if (firstItem == null) {
                    // No longer needed. Toss all references and the Command object.
                    Debug.Assert(baseItem == null, "why isn't baseItem null?");
                    onClick = null;
                    onPopup = null;
                    onSelect = null;
                    onDrawItem = null;
                    onMeasureItem = null;
                    if (cmd != null) {
                        cmd.Dispose();
                        cmd = null;
                    }
                }
            }

            internal virtual void SetCaption(string value) {
                if (value == null)
                    value = "";
                if (!caption.Equals(value)) {
                    caption = value;
                    UpdateMenuItems(false);
                }
            }

            internal virtual bool HasState(int flag) {
                return((State & flag) == flag);
            }

            internal virtual void SetState(int flag, bool value) {
                if (((state & flag) != 0) != value) {
                    state = value? state | flag: state & ~flag;
                    UpdateMenuItems(true);
                }
            }

            internal virtual void UpdateMenuItems(bool force) {
                version++;
                for (MenuItem item = firstItem; item != null; item = item.nextLinkedItem) {
                    item.UpdateMenuItem(force);
                }
            }
        }

        private class MdiListUserData {
            public virtual void OnClick(EventArgs e) {
            }
        }

        private class MdiListFormData : MdiListUserData {
            public Form boundForm = null;

            public MdiListFormData() {
            }

            public MdiListFormData(Form boundForm) {
                this.boundForm = boundForm;
            }

            public override void OnClick(EventArgs e) {
                if (boundForm != null) {
                    // SECREVIEW : User selected a window, that means it is OK 
                    //           : to move focus
                    //
                    IntSecurity.ModifyFocus.Assert();
                    try {
                        boundForm.Activate();
                        if (boundForm.ActiveControl != null && !boundForm.ActiveControl.Focused) {
                            boundForm.ActiveControl.Focus();
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }
        }

        private class MdiListMoreWindowsData : MdiListUserData {
            public Form[] forms = null;
            public Form active = null;

            public MdiListMoreWindowsData() {
            }

            public MdiListMoreWindowsData(Form active, Form[] all) {
                forms = all;
                this.active = active;
            }

            public override void OnClick(EventArgs e) {
                if (forms != null) {
                    // SECREVIEW : "System" style dialog, no user code will execute, and
                    //           : we don't want the restricted dialog options...
                    //
                    IntSecurity.AllWindows.Assert();
                    try {
                        using (MdiWindowDialog dialog = new MdiWindowDialog()) {
                            dialog.SetItems(active, forms);
                            DialogResult result = dialog.ShowDialog();
                            if (result == DialogResult.OK) {

                                // AllWindows Assert above allows this...
                                //
                                dialog.ActiveChildForm.Activate();
                                if (dialog.ActiveChildForm.ActiveControl != null && !dialog.ActiveChildForm.ActiveControl.Focused) {
                                    dialog.ActiveChildForm.ActiveControl.Focus();
                                }
                            }
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\listview.cs ===
//-----------------------------------------------------------------------------
// <copyright file="ListView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.Windows.Forms;    
    using System.ComponentModel.Design;
    using System.Collections;
    using Microsoft.Win32;
    using System.Globalization;


    /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays a list of items in one of four
    ///       views. Each item displays a caption and optionally an image.
    ///
    ///    </para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.ListViewDesigner, " + AssemblyRef.SystemDesign),
    DefaultProperty("Items"),
    DefaultEvent("SelectedIndexChanged"),
    ]
    public class ListView : Control {

        //members

        private static readonly object EVENT_SELECTEDINDEXCHANGED = new object();

        private ItemActivation activation     = ItemActivation.Standard;
        private ListViewAlignment alignStyle  = ListViewAlignment.Top;
        private BorderStyle borderStyle       = System.Windows.Forms.BorderStyle.Fixed3D;
        private ColumnHeaderStyle headerStyle = ColumnHeaderStyle.Clickable;
        private SortOrder sorting             = SortOrder.None;
        private View viewStyle                = System.Windows.Forms.View.LargeIcon;

        private bool allowColumnReorder = false;
        private bool autoArrange = true;
        private bool checkBoxes = false;
        private bool fullRowSelect = false;
        private bool gridLines = false;
        private bool hideSelection = true;
        private bool labelEdit = false;
        private bool labelWrap = true;
        private bool multiSelect = true;
        private bool scrollable = true;
        private bool hoverSelection = false;
        private bool nonclickHdr = false;
        private bool inLabelEdit = false;
        private bool handleDestroyed = false;               // while we are recreating the handle we want to know if we can still get data from the handle
        
        // Ownerdraw data caches...  Only valid inside WM_PAINT.
        // CONSIDER: nkramer: I'd love to see some hard numbers on how much this 
        // crock really saves us
        private Color odCacheForeColor = SystemColors.WindowText;
        private Color odCacheBackColor = SystemColors.Window;
        private Font odCacheFont = null;
        private IntPtr odCacheFontHandle = IntPtr.Zero;

        private ImageList imageListLarge;
        private ImageList imageListSmall;
        private ImageList imageListState;

        private MouseButtons downButton;
        private int itemCount;
        private bool columnClicked = false;
        private int columnIndex = 0;
        private bool doubleclickFired = false;
        private bool mouseUpFired = false;
        private bool expectingMouseUp = false;

        // Invariant: the table always contains all Items in the ListView, and maps IDs -> Items.
        // listItemsArray is null if the handle is created; otherwise, it contains all Items.
        // We do not try to sort listItemsArray as items are added, but during a handle recreate
        // we will make sure we get the items in the same order the ListView displays them.
        private Hashtable listItemsTable = new Hashtable(); // elements are ListViewItem's
        private ArrayList listItemsArray = new ArrayList(); // elements are ListViewItem's

        private ColumnHeader[] columnHeaders;
        private ListViewItemCollection listItemCollection;
        private ColumnHeaderCollection columnHeaderCollection;
        private CheckedIndexCollection checkedIndexCollection;
        private CheckedListViewItemCollection checkedListViewItemCollection;
        private SelectedListViewItemCollection selectedListViewItemCollection;
        private SelectedIndexCollection selectedIndexCollection;

        private LabelEditEventHandler onAfterLabelEdit;
        private LabelEditEventHandler onBeforeLabelEdit;
        private ColumnClickEventHandler onColumnClick;
        private EventHandler onItemActivate;
        private ItemDragEventHandler onItemDrag;
        private ItemCheckEventHandler onItemCheck;
        
        // IDs for identifying ListViewItem's
        private int nextID = 0;

        // We save selected and checked items between handle creates.
        private ListViewItem[] savedSelectedItems;
        private ListViewItem[] savedCheckedItems;        
        
        // Sorting
        private IComparer listItemSorter = null;

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListView"]/*' />
        /// <devdoc>
        ///     Creates an empty ListView with default styles.
        /// </devdoc>
        public ListView()
        : base() {
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.StandardClick, false);
            odCacheFont = Font;
            odCacheFontHandle = FontHandle;
            SetBounds(0,0,121,97);
            listItemCollection = new ListViewItemCollection(this);
            columnHeaderCollection = new ColumnHeaderCollection(this);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Activation"]/*' />
        /// <devdoc>
        ///     The activation style specifies what kind of user action is required to
        ///     activate an item.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(ItemActivation.Standard),
        SRDescription(SR.ListViewActivationDescr)
        ]
        public ItemActivation Activation {
            get {
                return activation;
            }

            set {
                if (!Enum.IsDefined(typeof(ItemActivation), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ItemActivation));
                }

                if (activation != value) {
                    activation = value;
                    UpdateExtendedStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Alignment"]/*' />
        /// <devdoc>
        ///     The alignment style specifies which side of the window items are aligned
        ///     to by default
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(ListViewAlignment.Top),
        Localizable(true),
        SRDescription(SR.ListViewAlignmentDescr)
        ]
        public ListViewAlignment Alignment {
            get {
                return alignStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(ListViewAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ListViewAlignment));
                }
                if (alignStyle != value) {
                    alignStyle = value;
                    
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.AllowColumnReorder"]/*' />
        /// <devdoc>
        ///     Specifies whether the user can drag column headers to
        ///     other column positions, thus changing the order of displayed columns.
        ///     This property is only meaningful in Details view.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ListViewAllowColumnReorderDescr)
        ]
        public bool AllowColumnReorder {
            get {
                return allowColumnReorder;
            }

            set {
                if (allowColumnReorder != value) {
                    allowColumnReorder = value;
                    UpdateExtendedStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.AutoArrange"]/*' />
        /// <devdoc>
        ///     If autoArrange is true items are automatically arranged according to
        ///     the alignment property.  Items are also kept snapped to grid.
        ///     This property is only meaningful in Large Icon or Small Icon views.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.ListViewAutoArrangeDescr)
        ]
        public bool AutoArrange {
            get {
                return autoArrange;
            }

            set {
                if (value != autoArrange) {
                    autoArrange = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }
            set {
                base.BackColor = value;
                if (IsHandleCreated) {
                    SendMessage(NativeMethods.LVM_SETBKCOLOR, 0, ColorTranslator.ToWin32(BackColor));
                    SendMessage(NativeMethods.LVM_SETTEXTBKCOLOR, 0, ColorTranslator.ToWin32(BackColor));
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.BorderStyle"]/*' />
        /// <devdoc>
        ///     Describes the border style of the window.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.Fixed3D),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.borderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }

                if (borderStyle != value) {
                    borderStyle = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckBoxes"]/*' />
        /// <devdoc>
        ///     If checkBoxes is true, every item will display a checkbox next
        ///     to it.  The user can change the state of the item by clicking the checkbox.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(false),
        SRDescription(SR.ListViewCheckBoxesDescr)
        ]
        public bool CheckBoxes {
            get {
                return checkBoxes;
            }

            set {
                if (checkBoxes != value) {
                    
                    if (checkBoxes) {
                        // Save away the checked items just in case we re-activate checkboxes
                        //
                        savedCheckedItems = new ListViewItem[CheckedItems.Count];
                        CheckedItems.CopyTo(savedCheckedItems, 0);
                    }
                
                    checkBoxes = value;
                    UpdateExtendedStyles();
                    
                    if (checkBoxes && savedCheckedItems != null) {
                        // Check the saved checked items.
                        //
                        if (savedCheckedItems.Length > 0) {
                            foreach(ListViewItem item in savedCheckedItems) {
                                item.Checked = true;
                            }
                        }
                        savedCheckedItems = null;
                    }                                       
                                       
                    // Comctl should handle auto-arrange for us, but doesn't
                    if (AutoArrange)
                        ArrangeIcons(Alignment);
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndices"]/*' />
        /// <devdoc>
        ///     The indices of the currently checked list items.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public CheckedIndexCollection CheckedIndices {
            get {
                if (checkedIndexCollection == null) {
                    checkedIndexCollection = new CheckedIndexCollection(this);
                }
                return checkedIndexCollection;
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedItems"]/*' />
        /// <devdoc>
        ///     The currently checked list items.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public CheckedListViewItemCollection CheckedItems {
            get {
                if (checkedListViewItemCollection == null) {
                    checkedListViewItemCollection = new CheckedListViewItemCollection(this);
                }
                return checkedListViewItemCollection;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Columns"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRDescription(SR.ListViewColumnsDescr),
        Localizable(true),
        MergableProperty(false)
        ]
        public ColumnHeaderCollection Columns {
            get {
                return columnHeaderCollection;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CreateParams"]/*' />
        /// <devdoc>
        ///     Computes the handle creation parameters for the ListView control.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;

                cp.ClassName = NativeMethods.WC_LISTVIEW;
                
                // Keep the scrollbar if we are just updating styles...
                //
                if (IsHandleCreated) {
                    int currentStyle = (int) UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE);
                    cp.Style |= (currentStyle & (NativeMethods.WS_HSCROLL | NativeMethods.WS_VSCROLL));
                }
                
                cp.Style |= NativeMethods.LVS_SHAREIMAGELISTS;

                switch (alignStyle) {
                    case ListViewAlignment.Top:
                        cp.Style |= NativeMethods.LVS_ALIGNTOP;
                        break;
                    case ListViewAlignment.Left:
                        cp.Style |= NativeMethods.LVS_ALIGNLEFT;
                        break;
                }

                if (autoArrange)
                    cp.Style |= NativeMethods.LVS_AUTOARRANGE;

                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }

                switch (headerStyle) {
                    case ColumnHeaderStyle.None:
                        cp.Style |= NativeMethods.LVS_NOCOLUMNHEADER;
                        break;
                    case ColumnHeaderStyle.Nonclickable:
                        cp.Style |= NativeMethods.LVS_NOSORTHEADER;
                        break;
                }

                if (labelEdit)
                    cp.Style |= NativeMethods.LVS_EDITLABELS;

                if (!labelWrap)
                    cp.Style |= NativeMethods.LVS_NOLABELWRAP;

                if (!scrollable)
                    cp.Style |= NativeMethods.LVS_NOSCROLL;

                if (!hideSelection)
                    cp.Style |= NativeMethods.LVS_SHOWSELALWAYS;

                if (!multiSelect)
                    cp.Style |= NativeMethods.LVS_SINGLESEL;

                if (listItemSorter == null) {
                    switch (sorting) {
                        case SortOrder.Ascending:
                            cp.Style |= NativeMethods.LVS_SORTASCENDING;
                            break;
                        case SortOrder.Descending:
                            cp.Style |= NativeMethods.LVS_SORTDESCENDING;
                            break;
                    }
                }

                // We can do this 'cuz the viewStyle enums are the same values as the actual LVS styles
                cp.Style |= (int)viewStyle;

                return cp;
            }
        }
        
        private void ForceCheckBoxUpdate() {
            // Force ListView to update its checkbox bitmaps.
            //
            if (checkBoxes && IsHandleCreated) {
                SendMessage(NativeMethods.LVM_SETEXTENDEDLISTVIEWSTYLE, NativeMethods.LVS_EX_CHECKBOXES, 0);
                SendMessage(NativeMethods.LVM_SETEXTENDEDLISTVIEWSTYLE, NativeMethods.LVS_EX_CHECKBOXES, NativeMethods.LVS_EX_CHECKBOXES);
                
                // Comctl should handle auto-arrange for us, but doesn't                           
                if (AutoArrange) {
                    ArrangeIcons(Alignment);
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnEnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnEnabledChanged(EventArgs e) {
            //ForceCheckBoxUpdate();
            base.OnEnabledChanged(e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.FocusedItem"]/*' />
        /// <devdoc>
        ///     Retreives the item which currently has the user focus.  This is the
        ///     item that's drawn with the dotted focus rectangle around it.
        ///     Returns null if no item is currently focused.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListViewFocusedItemDescr)
        ]
        public ListViewItem FocusedItem {
            get {
                if (IsHandleCreated) {
                    int displayIndex = (int)SendMessage(NativeMethods.LVM_GETNEXTITEM, -1, NativeMethods.LVNI_FOCUSED);
                    if (displayIndex > -1)
                        return Items[displayIndex];
                }
                return null;
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize 
        {
            get 
            {
                return new Size(121, 97);
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Color ForeColor 
        {
            get {
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }
            set {
                base.ForeColor = value;
                if (IsHandleCreated) {
                    SendMessage(NativeMethods.LVM_SETTEXTCOLOR, 0, ColorTranslator.ToWin32(ForeColor));
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.FullRowSelect"]/*' />
        /// <devdoc>
        ///     Specifies whether a click on an item will select the entire row instead
        ///     of just the item itself.
        ///     This property is only meaningful in Details view
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(false),
        SRDescription(SR.ListViewFullRowSelectDescr)
        ]
        public bool FullRowSelect {
            get { return fullRowSelect;}
            set {
                if (fullRowSelect != value) {
                    fullRowSelect = value;
                    UpdateExtendedStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.HeaderStyle"]/*' />
        /// <devdoc>
        ///     Column headers can either be invisible, clickable, or non-clickable.
        ///     This property is only meaningful in Details view
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(ColumnHeaderStyle.Clickable),
        SRDescription(SR.ListViewHeaderStyleDescr)
        ]
        public ColumnHeaderStyle HeaderStyle {
            get { return headerStyle;}
            set {
                if (!Enum.IsDefined(typeof(ColumnHeaderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ColumnHeaderStyle));
                }
                if (headerStyle != value) {
                    // We can switch between NONE and either *one* of the other styles without
                    // recreating the handle, but if we change from CLICKABLE to NONCLICKABLE
                    // or vice versa, with or without an intervening setting of NONE, then
                    // the handle needs to be recreated.
                    headerStyle = value;
                    if ((nonclickHdr && value == ColumnHeaderStyle.Clickable) ||
                        (!nonclickHdr && value == ColumnHeaderStyle.Nonclickable)) {
                        nonclickHdr = !nonclickHdr;
                        RecreateHandle();
                    }
                    else
                        UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.GridLines"]/*' />
        /// <devdoc>
        ///     If true, draws grid lines between items and subItems.
        ///     This property is only meaningful in Details view
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(false),
        SRDescription(SR.ListViewGridLinesDescr)
        ]
        public bool GridLines {
            get {
                return gridLines;
            }

            set {
                if (gridLines != value) {
                    gridLines = value;
                    UpdateExtendedStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.HideSelection"]/*' />
        /// <devdoc>
        ///     If false, selected items will still be highlighted (in a
        ///     different color) when focus is moved away from the ListView.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.ListViewHideSelectionDescr)
        ]
        public bool HideSelection {
            get {
                return hideSelection;
            }

            set {
                if (value != hideSelection) {
                    hideSelection = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.HoverSelection"]/*' />
        /// <devdoc>
        ///     Determines whether items can be selected by hovering over them with the mouse.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ListViewHoverSelectDescr)
        ]
        public bool HoverSelection {
            get {
                return hoverSelection;
            }

            set {
                if (hoverSelection != value) {
                    hoverSelection = value;
                    UpdateExtendedStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.LabelEdit"]/*' />
        /// <devdoc>
        ///     Tells whether the EditLabels style is currently set.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ListViewLabelEditDescr)
        ]
        public bool LabelEdit {
            get {
                return labelEdit;
            }
            set {
                if (value != labelEdit) {
                    labelEdit = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.LabelWrap"]/*' />
        /// <devdoc>
        ///     Tells whether the LabelWrap style is currently set.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ListViewLabelWrapDescr)
        ]
        public bool LabelWrap {
            get {
                return labelWrap;
            }
            set {
                if (value != labelWrap) {
                    labelWrap = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.LargeImageList"]/*' />
        /// <devdoc>
        ///     The Currently set ImageList for Large Icon mode.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.ListViewLargeImageListDescr)
        ]
        public ImageList LargeImageList {
            get {
                return imageListLarge;
            }
            set {
                if (value != imageListLarge) {
                
                    EventHandler recreateHandler = new EventHandler(LargeImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    if (imageListLarge != null) {
                        imageListLarge.RecreateHandle -= recreateHandler;
                        imageListLarge.Disposed -= disposedHandler;
                    }

                    imageListLarge = value;

                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;
                    }
                    
                    if (IsHandleCreated) {
                        if (value != null && itemCount > 0) {
                            RecreateHandle();
                        }
                        else {
                            SendMessage(NativeMethods.LVM_SETIMAGELIST, (IntPtr)NativeMethods.LVSIL_NORMAL, value == null ? IntPtr.Zero: value.Handle);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        Localizable(true),
        SRDescription(SR.ListViewItemsDescr),
        MergableProperty(false)
        ]
        public ListViewItemCollection Items {
            get {
                return listItemCollection;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemSorter"]/*' />
        /// <devdoc>
        ///     The sorting comparer for this ListView.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListViewItemSorterDescr)
        ]
        public IComparer ListViewItemSorter {
            get {
                return listItemSorter;
            }
            set {
                if (listItemSorter != value) {
                    listItemSorter = value;
                    Sort();                
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.MultiSelect"]/*' />
        /// <devdoc>
        ///     Tells whether the MultiSelect style is currently set.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.ListViewMultiSelectDescr)
        ]
        public bool MultiSelect {
            get {
                return multiSelect;
            }
            set {
                if (value != multiSelect) {
                    multiSelect = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Scrollable"]/*' />
        /// <devdoc>
        ///     Tells whether the ScrollBars are visible or not.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.ListViewScrollableDescr)
        ]
        public bool Scrollable {
            get {
                return scrollable;
            }
            set {
                if (value != scrollable) {
                    scrollable = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndices"]/*' />
        /// <devdoc>
        ///     The indices of the currently selected list items.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public SelectedIndexCollection SelectedIndices {
            get {
                if (selectedIndexCollection == null) {
                    selectedIndexCollection = new SelectedIndexCollection(this);
                }
                return selectedIndexCollection;
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedItems"]/*' />
        /// <devdoc>
        ///     The currently selected list items.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListViewSelectedItemsDescr)
        ]
        public SelectedListViewItemCollection SelectedItems {
            get {
                if (selectedListViewItemCollection == null) {
                    selectedListViewItemCollection = new SelectedListViewItemCollection(this);
                }
                return selectedListViewItemCollection;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SmallImageList"]/*' />
        /// <devdoc>
        ///     The currently set SmallIcon image list.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.ListViewSmallImageListDescr)
        ]
        public ImageList SmallImageList {
            get {
                return imageListSmall;
            }
            set {
                if (imageListSmall != value) {
                
                    EventHandler recreateHandler = new EventHandler(LargeImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    if (imageListSmall != null) {
                        imageListSmall.RecreateHandle -= recreateHandler;
                        imageListSmall.Disposed -= disposedHandler;
                    }
                    imageListSmall = value;
                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;
                    }
                    
                    if (IsHandleCreated)
                        SendMessage(NativeMethods.LVM_SETIMAGELIST, (IntPtr) NativeMethods.LVSIL_SMALL, value == null ? IntPtr.Zero: value.Handle);
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Sorting"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(SortOrder.None),
        SRDescription(SR.ListViewSortingDescr)
        ]
        public SortOrder Sorting {
            get {
                return sorting;
            }
            set {
                if (!Enum.IsDefined(typeof(SortOrder), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(SortOrder));
                }
                if (sorting != value) {
                    sorting = value;
                    if (listItemSorter == null && (this.View == View.LargeIcon || this.View == View.SmallIcon)) {
                        listItemSorter = new IconComparer(sorting);

                    }
                    // If we're changing to No Sorting, no need to recreate the handle
                    // because none of the existing items need to be rearranged.
                    if (value == SortOrder.None)
                        UpdateStyles();
                    else
                        RecreateHandle();
                }
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.StateImageList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.ListViewStateImageListDescr)
        ]
        public ImageList StateImageList {
            get {
                return imageListState;
            }
            set {
                if (imageListState != value) {
                    
                    EventHandler recreateHandler = new EventHandler(StateImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    if (imageListState != null) {
                        imageListState.RecreateHandle -= recreateHandler;
                        imageListState.Disposed -= disposedHandler;
                    }
                    imageListState = value;
                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;
                    }
                    
                    if (IsHandleCreated)
                        SendMessage(NativeMethods.LVM_SETIMAGELIST, NativeMethods.LVSIL_STATE, value == null ? IntPtr.Zero: value.Handle);
                }
            }
        }
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.TopItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ListViewTopItemDescr)
        ]
        public ListViewItem TopItem {
            get {
                if (viewStyle == View.LargeIcon || viewStyle == View.SmallIcon)
                    throw new InvalidOperationException(SR.GetString(SR.ListViewGetTopItem));

                int topIndex = (int)SendMessage(NativeMethods.LVM_GETTOPINDEX, 0, 0);
                if (topIndex >= 0 && topIndex < Items.Count)
                    return Items[topIndex];

                return null;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.View"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(View.LargeIcon),
        SRDescription(SR.ListViewViewDescr)
        ]
        public View View {
            get {
                return viewStyle;
            }
            set {
                if (!Enum.IsDefined(typeof(View), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(View));
                }

                if (viewStyle != value) {
                    viewStyle = value;
                    UpdateStyles();
                }
            }
        }


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.AfterLabelEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ListViewAfterLabelEditDescr)]
        public event LabelEditEventHandler AfterLabelEdit {
            add {
                onAfterLabelEdit += value;
            }
            remove {
                onAfterLabelEdit -= value;
            }
        }        


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.BeforeLabelEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ListViewBeforeLabelEditDescr)]
        public event LabelEditEventHandler BeforeLabelEdit {
            add {
                onBeforeLabelEdit += value;
            }
            remove {
                onBeforeLabelEdit -= value;
            }
        }        


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnClick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ListViewColumnClickDescr)]
        public event ColumnClickEventHandler ColumnClick {
            add {
                onColumnClick += value;
            }
            remove {
                onColumnClick -= value;
            }
        }        


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ItemActivate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ListViewItemClickDescr)]
        public event EventHandler ItemActivate {
            add {
                onItemActivate += value;
            }
            remove {
                onItemActivate -= value;
            }
        }        


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ItemCheck"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.CheckedListBoxItemCheckDescr)]
        public event ItemCheckEventHandler ItemCheck {
            add {
                onItemCheck += value;
            }
            remove {
                onItemCheck -= value;
            }
        }        


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ItemDrag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ListViewItemDragDescr)]
        public event ItemDragEventHandler ItemDrag {
            add {
                onItemDrag += value;
            }
            remove {
                onItemDrag -= value;
            }
        }        


        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription( SR.ListViewSelectedIndexChangedDescr )]
        public event EventHandler SelectedIndexChanged {
            add {
                Events.AddHandler(EVENT_SELECTEDINDEXCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SELECTEDINDEXCHANGED, value);
            }
        } 

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnPaint"]/*' />
        /// <devdoc>
        ///     ListView Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ArrangeIcons"]/*' />
        /// <devdoc>
        ///     In Large Icon or Small Icon view, arranges the items according to one
        ///     of the following behaviors:
        /// </devdoc>
        public void ArrangeIcons(ListViewAlignment value) {
            if (viewStyle == View.Details) return;

            switch ((int)value) {
                case NativeMethods.LVA_DEFAULT:
                case NativeMethods.LVA_ALIGNLEFT:
                case NativeMethods.LVA_ALIGNTOP:
                case NativeMethods.LVA_SNAPTOGRID:
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.LVM_ARRANGE, (int) value, 0);
                    }
                    break;

                default:
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "value",
                                                              ((value).ToString())));
            }
            if (sorting != SortOrder.None) {
                Sort();
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ArrangeIcons1"]/*' />
        /// <devdoc>
        ///     In Large Icon or Small Icon view, arranges items according to the ListView's
        ///     current alignment style.
        /// </devdoc>
        public void ArrangeIcons() {
            ArrangeIcons((ListViewAlignment)NativeMethods.LVA_DEFAULT);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.BeginUpdate"]/*' />
        /// <devdoc>
        ///     Prevents the ListView from redrawing itself until EndUpdate is called.
        ///     Calling this method before individually adding or removing a large number of Items
        ///     will improve performance and reduce flicker on the ListView as items are
        ///     being updated.  Always call EndUpdate immediately after the last item is updated.
        /// </devdoc>
        public void BeginUpdate() {
            BeginUpdateInternal();
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Clear"]/*' />
        /// <devdoc>
        ///     Removes all items and columns from the ListView.
        /// </devdoc>
        public void Clear() {
            Items.Clear();
            Columns.Clear();
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CompareFunc"]/*' />
        /// <devdoc>
        ///      This is the sorting callback function called by the system ListView control.
        /// </devdoc>
        /// <internalonly/>
        private int CompareFunc(IntPtr lparam1, IntPtr lparam2, IntPtr lparamSort) {

            Debug.Assert(listItemSorter != null, "null sorter!");
            if (listItemSorter != null) {
                return listItemSorter.Compare(listItemsTable[(int)lparam1], listItemsTable[(int)lparam2]);
            }
            else {
                return 0;
            }           
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_LISTVIEW_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }

        //CONSIDER: Does this stuff impact hot-underlining?
        //          Do we even support hot-underlining?
        //          SHOULD we mung the fonts ourselves to support it if necessary?

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CustomDraw"]/*' />
        /// <devdoc>
        ///     Handles custom drawing of list items - for individual item font/color changes.
        /// </devdoc>
        /// <internalonly/>
        unsafe void CustomDraw(ref Message m) {
            bool dontmess = false;

            try {
                NativeMethods.NMLVCUSTOMDRAW* nmcd = (NativeMethods.NMLVCUSTOMDRAW*)m.LParam;

                // Find out which stage we're drawing
                switch (nmcd->nmcd.dwDrawStage) {
                    case NativeMethods.CDDS_PREPAINT:
                        // We want owner draw for this paint cycle
                        m.Result = (IntPtr)(NativeMethods.CDRF_NOTIFYSUBITEMDRAW | NativeMethods.CDRF_NEWFONT);
                        // refresh the cache of the current color & font settings for this paint cycle
                        odCacheBackColor = this.BackColor;
                        odCacheForeColor = this.ForeColor;
                        odCacheFont = this.Font;
                        odCacheFontHandle = this.FontHandle;
                        return;

                        //We have to return a NOTIFYSUBITEMDRAW (called NOTIFYSUBITEMREDRAW in the docs) here to
                        //get it to enter "change all subitems instead of whole rows" mode.

                        //HOWEVER... we only want to do this for report styles...

                    case NativeMethods.CDDS_ITEMPREPAINT:
                        if (viewStyle == View.Details) {
                            m.Result = (IntPtr)(NativeMethods.CDRF_NOTIFYSUBITEMDRAW | NativeMethods.CDRF_NEWFONT);
                            dontmess = true; // don't mess with our return value!

                            //ITEMPREPAINT is used to work out the rect for the first column!!! GAH!!!
                            //(which means we can't just do our color/font work on SUBITEM|ITEM_PREPAINT)
                            //so fall through... and tell the end of SUBITEM|ITEM_PREPAINT not to mess
                            //with our return value...

                        }

                        //If it's not a report, we fall through and change the main item's styles

                        goto
                    case (NativeMethods.CDDS_SUBITEM | NativeMethods.CDDS_ITEMPREPAINT);
                    case (NativeMethods.CDDS_SUBITEM | NativeMethods.CDDS_ITEMPREPAINT):
                        // get the node
                        ListViewItem item = Items[nmcd->nmcd.dwItemSpec];
                        // if we're doing the whole row in one style, change our result!
                        if (dontmess && item.UseItemStyleForSubItems) {
                            m.Result = (IntPtr)NativeMethods.CDRF_NEWFONT;
                        }
                        Debug.Assert(item!=null,"Item was null in ITEMPREPAINT");

                        int state = nmcd->nmcd.uItemState;

                        // There is a known and documented problem in the ListView winctl control -
                        // if the LVS_SHOWSELALWAYS style is set, then the item state will always
                        // have the CDIS_SELECTED bit set. So we need to get the real item state
                        // to be sure.
                        if (!HideSelection) {
                            state = GetItemState(nmcd->nmcd.dwItemSpec);
                        }

                        // subitem is invalid if the flag isn't set -- and we also use this code in
                        // cases where subitems aren't visible (ie. non-Details modes), so if subitem
                        // is invalid, point it at the main item's render info

                        int subitem = ((nmcd->nmcd.dwDrawStage & NativeMethods.CDDS_SUBITEM) !=0 ) ? nmcd->iSubItem : 0;
                        
                        // Work out the style in which to render this item
                        //
                        Font subItemFont = null;
                        Color subItemForeColor = Color.Empty;
                        Color subItemBackColor = Color.Empty;
                        bool haveRenderInfo = false;
                        if (item != null && subitem < item.SubItems.Count) {
                            haveRenderInfo = true;
                            subItemFont = item.SubItems[subitem].Font;
                            if (subitem > 0 || (state & (NativeMethods.CDIS_SELECTED | NativeMethods.CDIS_GRAYED | NativeMethods.CDIS_HOT | NativeMethods.CDIS_DISABLED))==0) {
                                // we only propogate colors if we're displaying things normally
                                // the user can override this method to do all kinds of other crazy things if they
                                // want to though - but we don't support that.
                                subItemForeColor = item.SubItems[subitem].ForeColor;
                                subItemBackColor = item.SubItems[subitem].BackColor;
                            }
                        }

                        // We always have to set font and color data, because of comctl idiosyncracies and lameness

                        //CONSIDER: keeping a local copy of font, foreColor and BackColor, because we use it
                        //          all over here, and going down to Control and expecting it to do the right
                        //          thing FAST is just asking for trouble.
                        //          We currently ARE doing this, but it could be ripped out if anyone objects

                        Color riFore = Color.Empty;
                        Color riBack = Color.Empty;

                        if (haveRenderInfo) {
                            riFore = subItemForeColor;
                            riBack = subItemBackColor;
                        }
                        
                        bool changeColor = true;
                        if ((activation == ItemActivation.OneClick)
                            || (activation == ItemActivation.TwoClick)) {
                            if ((state & (NativeMethods.CDIS_SELECTED
                                        | NativeMethods.CDIS_GRAYED
                                        | NativeMethods.CDIS_HOT
                                        | NativeMethods.CDIS_DISABLED)) != 0) {
                                changeColor = false;
                            }
                        }
                        
                        if (changeColor) {
                            if (!haveRenderInfo || riFore.IsEmpty) {
                                nmcd->clrText = ColorTranslator.ToWin32(odCacheForeColor);
                            }
                            else {
                                nmcd->clrText = ColorTranslator.ToWin32(riFore);
                            }

                            // Work-around for a comctl quirk where,
                            // if clrText is the same as SystemColors.HotTrack,
                            // the subitem's color is not changed to nmcd->clrText.
                            //
                            // Try to tweak the blue component of clrText first, then green, then red.
                            // Basically, if the color component is 0xFF, subtract 1 from it
                            // (adding 1 will overflow), else add 1 to it. If the color component is 0,
                            // skip it and go to the next color (unless it is our last option).
                            if (nmcd->clrText == ColorTranslator.ToWin32(SystemColors.HotTrack))
                            {
                                int totalshift = 0;
                                bool clrAdjusted = false;
                                int mask = 0xFF0000;
                                do 
                                {
                                    int C = nmcd->clrText & mask;
                                    if (C != 0 || (mask == 0x0000FF)) // The color is not 0
                                                            // or this is the last option
                                    {
                                        int n = 16 - totalshift;
                                        // Make sure the value doesn't overflow
                                        if (C == mask) {
                                            C = ((C >> n) - 1) << n;
                                        }
                                        else {
                                            C = ((C >> n) + 1) << n;
                                        }
                                        // Copy the adjustment into nmcd->clrText
                                        nmcd->clrText = (nmcd->clrText & (~mask)) | C;
                                        clrAdjusted = true;
                                    }
                                    else
                                    {
                                        mask >>= 8; // Try the next color.
                                        // We try adjusting Blue, Green, Red in that order,
                                        // since 0x0000FF is the most likely value of
                                        // SystemColors.HotTrack
                                        totalshift += 8;
                                    }
                                } while (!clrAdjusted);
                            }

                            if (!haveRenderInfo || riBack.IsEmpty) {
                                nmcd->clrTextBk = ColorTranslator.ToWin32(odCacheBackColor);
                            }
                            else {
                                nmcd->clrTextBk = ColorTranslator.ToWin32(riBack);
                            }
                        }

                        if (!haveRenderInfo || subItemFont == null) {
                            // safety net code just in case
                            if (odCacheFont != null) SafeNativeMethods.SelectObject(new HandleRef(nmcd->nmcd, nmcd->nmcd.hdc), new HandleRef(null, odCacheFontHandle));
                        }
                        else {
                            Control.FontHandleWrapper fontWrapper = new Control.FontHandleWrapper(subItemFont);
                            SafeNativeMethods.SelectObject(new HandleRef(nmcd->nmcd, nmcd->nmcd.hdc), new HandleRef(fontWrapper, fontWrapper.Handle));
                        }

                        if (!dontmess) m.Result = (IntPtr)NativeMethods.CDRF_NEWFONT;
                        return;

                    default:
                        m.Result = (IntPtr)NativeMethods.CDRF_DODEFAULT;
                        return;
                }
            }
            catch (Exception e) {
                Debug.Fail("Exception occured attempting to setup custom draw. Disabling custom draw for this control", e.ToString());
                m.Result = (IntPtr)NativeMethods.CDRF_DODEFAULT;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.DetachImageList"]/*' />
        /// <devdoc>
        ///     Resets the imageList to null.  We wire this method up to the imageList's
        ///     Dispose event, so that we don't hang onto an imageList that's gone away.
        /// </devdoc>
        private void DetachImageList(object sender, EventArgs e) {
            if (sender == imageListSmall)
                SmallImageList = null;
            else if (sender == imageListLarge)
                LargeImageList = null;
            else if (sender == imageListState)
                StateImageList = null;
            else {
                Debug.Fail("ListView sunk dispose event from unknown component");
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of the component.  Call dispose when the component is no longer needed.
        ///     This method removes the component from its container (if the component has a site)
        ///     and triggers the dispose event.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // Remove any event sinks we have hooked up to imageLists
                if (imageListSmall != null) {
                    imageListSmall.Disposed -= new EventHandler(this.DetachImageList);
                    imageListSmall = null;
                }
                if (imageListLarge != null) {
                    imageListLarge.Disposed -= new EventHandler(this.DetachImageList);
                    imageListLarge = null;
                }
                if (imageListState != null) {
                    imageListState.Disposed -= new EventHandler(this.DetachImageList);
                    imageListState = null;
                }

                // Remove any ColumnHeaders contained in this control
                if (columnHeaders != null) {
                    for (int colIdx = columnHeaders.Length-1; colIdx >= 0; colIdx--) {
                        columnHeaders[colIdx].OwnerListview = null;
                        columnHeaders[colIdx].Dispose();
                    }
                    columnHeaders = null;
                }

                // Remove any items we have                          
                Items.Clear();
            }
            
            base.Dispose(disposing);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.EndUpdate"]/*' />
        /// <devdoc>
        ///     Cancels the effect of BeginUpdate.
        /// </devdoc>
        public void EndUpdate() {
            EndUpdateInternal();
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.EnsureVisible"]/*' />
        /// <devdoc>
        ///     Ensure that the item is visible, scrolling the view as necessary.
        ///     @index  Index of item to scroll into view
        /// </devdoc>
        public void EnsureVisible(int index) {
            if (index < 0 || index >= Items.Count) {
                throw new ArgumentOutOfRangeException("index");
            }
            if (IsHandleCreated)
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_ENSUREVISIBLE, index, 0);
        }

        // IDs for identifying ListViewItem's
        private int GenerateUniqueID() {
            // Okay, if someone adds several billion items to the list and doesn't remove all of them,
            // we can reuse the same ID, but I'm willing to take that risk.  We are even tracking IDs
            // on a per-list view basis to reduce the problem.
            int result = nextID++;
            if (result == -1) {// leave -1 as a "no such value" ID
                result = 0;
                nextID = 1;
            }
            return result;
        }

        /// <devdoc>
        ///     Gets the real index for the given item.  lastIndex is the last return
        ///     value from GetDisplayIndex, or -1 if you don't know.  If provided, 
        ///     the search for the index can be greatly improved.
        /// </devdoc>
        internal int GetDisplayIndex(ListViewItem item, int lastIndex) {
        
            Debug.Assert(item.listView == this, "Can't GetDisplayIndex if the list item doesn't belong to us");
            Debug.Assert(item.ID != -1, "ListViewItem has no ID yet");

            if (IsHandleCreated && !handleDestroyed) {
                Debug.Assert(listItemsArray == null, "listItemsArray not null, even though handle created");
                NativeMethods.LVFINDINFO info = new NativeMethods.LVFINDINFO();
                info.lParam = (IntPtr)item.ID;
                info.flags = NativeMethods.LVFI_PARAM;
                
                int displayIndex = -1;
                
                if (lastIndex != -1) {
                    displayIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_FINDITEM, lastIndex - 1, ref info);
                }
                
                if (displayIndex == -1) {
                    displayIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_FINDITEM, -1 /* beginning */, ref info);
                }
                Debug.Assert(displayIndex != -1, "This item is in the list view -- why can't we find a display index for it?");
                return displayIndex;
            }
            else {
                // PERF: The only reason we should ever call this before the handle is created
                // is if the user calls ListViewItem.Index.
                Debug.Assert(listItemsArray != null, "listItemsArray is null, but the handle isn't created");

                int index = 0;
                foreach (object o in listItemsArray) {
                    if (o == item)
                        return index;
                    index++;
                }
                return -1;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.GetColumnIndex"]/*' />
        /// <devdoc>
        ///     Called by ColumnHeader objects to determine their position
        ///     in the ListView
        /// </devdoc>
        /// <internalonly/>
        internal int GetColumnIndex(ColumnHeader ch) {
            if (columnHeaders == null)
                return -1;

            for (int i = 0; i < columnHeaders.Length; i++) {
                if (columnHeaders[i] == ch)
                    return i;
            }

            return -1;
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.GetItemAt"]/*' />
        /// <devdoc>
        ///     Returns the current ListViewItem corresponding to the specific
        ///     x,y co-ordinate.
        /// </devdoc>
        public ListViewItem GetItemAt(int x, int y) {
            NativeMethods.LVHITTESTINFO lvhi = new NativeMethods.LVHITTESTINFO();

            lvhi.pt_x = x;
            lvhi.pt_y = y;

            int displayIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_HITTEST, 0, lvhi);

            ListViewItem li = null;
            if (displayIndex >= 0 && ((lvhi.flags & NativeMethods.LVHT_ONITEM) != 0))
                li = Items[displayIndex];

            return li;
        }

        internal int GetItemState(int index) {
            return GetItemState(index, NativeMethods.LVIS_FOCUSED | NativeMethods.LVIS_SELECTED | NativeMethods.LVIS_CUT |
                                NativeMethods.LVIS_DROPHILITED | NativeMethods.LVIS_OVERLAYMASK |
                                NativeMethods.LVIS_STATEIMAGEMASK);
        }

        internal int GetItemState(int index, int mask) {
            if (index < 0 || index >= itemCount)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));
            Debug.Assert(IsHandleCreated, "How did we add items without a handle?");

            return (int)SendMessage(NativeMethods.LVM_GETITEMSTATE, index, mask);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.GetItemRect"]/*' />
        /// <devdoc>
        ///     Returns a list item's bounding rectangle, including subitems.
        /// </devdoc>
        public Rectangle GetItemRect(int index) {
            return GetItemRect(index, 0);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.GetItemRect1"]/*' />
        /// <devdoc>
        ///     Returns a specific portion of a list item's bounding rectangle.
        /// </devdoc>
        public Rectangle GetItemRect(int index, ItemBoundsPortion portion) {
            if (index < 0 || index >= itemCount)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));
            
            if (!Enum.IsDefined(typeof(ItemBoundsPortion), portion)) {
                throw new InvalidEnumArgumentException("portion", (int)portion, typeof(ItemBoundsPortion));
            }


            NativeMethods.RECT itemrect = new NativeMethods.RECT();
            itemrect.left = (int)portion;
            if ((int)SendMessage(NativeMethods.LVM_GETITEMRECT, index, ref itemrect) == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));

            return Rectangle.FromLTRB(itemrect.left, itemrect.top, itemrect.right, itemrect.bottom);
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.InsertColumn"]/*' />
        /// <devdoc>
        ///     Inserts a new Column into the ListView
        /// </devdoc>
        internal ColumnHeader InsertColumn(int index, ColumnHeader ch) {
            return InsertColumn(index, ch, true);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.InsertColumn1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal ColumnHeader InsertColumn(int index, ColumnHeader ch, bool refreshSubItems) {
            if (ch == null)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                          "ch",
                                                          "null"));
            if (ch.OwnerListview != null)
                throw new ArgumentException(SR.GetString(SR.OnlyOneControl, ch.Text), "ch");

            int idx;
            if (IsHandleCreated) {
                idx = InsertColumnNative(index, ch);
            }
            else {
                idx = index;
            }

            // First column must be left aligned

            if (-1 == idx)
                throw new InvalidOperationException(SR.GetString(SR.ListViewAddColumnFailed));

            ch.OwnerListview = this;
            
            // Add the column to our internal array
            int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length);
            if (columnCount > 0) {
                ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1];
                if (columnCount > 0)
                    System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount);
                columnHeaders = newHeaders;
            }
            else
                columnHeaders = new ColumnHeader[1];

            if (idx < columnCount) {
                System.Array.Copy(columnHeaders, idx, columnHeaders, idx + 1, columnCount - idx);
            }
            columnHeaders[idx] = ch;

            if (refreshSubItems)
                RealizeAllSubItems();

            return ch;
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.InsertColumn2"]/*' />
        /// <devdoc>
        ///     Same as above, except the ColumnHeader is constructed from the passed-in data
        /// </devdoc>
        internal ColumnHeader InsertColumn(int index, string str, int width, HorizontalAlignment textAlign) {
            ColumnHeader columnHeader = new ColumnHeader();
            columnHeader.Text = str;
            columnHeader.Width = width;
            columnHeader.TextAlign = textAlign;
            return InsertColumn(index, columnHeader);
        }

        private int InsertColumnNative(int index, ColumnHeader ch) {
            NativeMethods.LVCOLUMN_T lvColumn = new NativeMethods.LVCOLUMN_T();
            lvColumn.mask = NativeMethods.LVCF_FMT | NativeMethods.LVCF_TEXT | NativeMethods.LVCF_WIDTH;// | NativeMethods.LVCF_ORDER | NativeMethods.LVCF_IMAGE;
            lvColumn.fmt        = (int)ch.TextAlign;
            lvColumn.cx         = ch.Width;
            lvColumn.pszText    = ch.Text;
            
            return (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_INSERTCOLUMN, index, lvColumn);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.InsertItem"]/*' />
        /// <devdoc>
        ///     Inserts a new ListViewItem into the ListView.  The item will be inserted
        ///     either in the correct sorted position, or, if no sorting is set, at the
        ///     position indicated by the index parameter.
        /// </devdoc>
        internal ListViewItem InsertItem(int displayIndex, ListViewItem item) {
            if (item.listView != null)
                throw new ArgumentException(SR.GetString(SR.OnlyOneControl, item.Text), "item");

            int itemID = GenerateUniqueID();
            Debug.Assert(!listItemsTable.ContainsKey(itemID), "internal hash table inconsistent -- inserting item, but it's already in the hash table");
            listItemsTable.Add(itemID, item);
            
            int actualIndex = -1;

            if (IsHandleCreated) {
                Debug.Assert(listItemsArray == null, "listItemsArray not null, even though handle created");
                
                // Much more efficient to call the native insert with max + 1, than with max.
                //
                if (displayIndex == itemCount) {
                    displayIndex++;
                }
                
                actualIndex = InsertItemNative(displayIndex, itemID, item);
            }
            else {
                Debug.Assert(listItemsArray != null, "listItemsArray is null, but the handle isn't created");
                listItemsArray.Insert(displayIndex, item);
            }

            itemCount++; 
            item.Host(this, itemID, actualIndex);

            // Update sorted order
            Sort();

            return item;
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.InsertItem1"]/*' />
        /// <devdoc>
        ///     Inserts a new ListViewItem into the ListView.  The item will be inserted
        ///     either in the correct sorted position, or, if no sorting is set, at the
        ///     position indicated by the index parameter.    The item is created with
        ///     no associated image or subItems.
        /// </devdoc>
        internal ListViewItem InsertItem(int index, string text) {
            return InsertItem(index, new ListViewItem(text));
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.InsertItem2"]/*' />
        /// <devdoc>
        ///     Inserts a new ListViewItem into the ListView.  The item will be inserted
        ///     either in the correct sorted position, or, if no sorting is set, at the
        ///     position indicated by the index parameter.    The item is created with
        ///     no subItems.
        /// </devdoc>
        internal ListViewItem InsertItem(int index, string text, int imageIndex) {
            return InsertItem(index, new ListViewItem(text, imageIndex));
        }

        private int InsertItemNative(int index, int itemID, ListViewItem li) {
            // Create and add the LVITEM
            NativeMethods.LVITEM lvItem = new NativeMethods.LVITEM();
            lvItem.mask = NativeMethods.LVIF_TEXT | NativeMethods.LVIF_IMAGE | NativeMethods.LVIF_PARAM;
            lvItem.iItem    = index;
            lvItem.pszText  = li.Text;
            lvItem.iImage   = li.ImageIndex;
            lvItem.lParam = (IntPtr)itemID;

            // Inserting an item into a ListView with checkboxes causes one or more
            // item check events to be fired for the newly added item.
            // Therefore, we disable the item check event handler temporarily.
            //
            ItemCheckEventHandler oldOnItemCheck = onItemCheck;
            onItemCheck = null;

            int actualIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_INSERTITEM, 0, ref lvItem);

            // Restore the item check event handler.
            //
            onItemCheck = oldOnItemCheck;

            if (-1 == actualIndex) {
                throw new InvalidOperationException(SR.GetString(SR.ListViewAddItemFailed));
            }

            // add all sub items
            for (int i=0; i < li.SubItems.Count; ++i) {
                SetItemText(actualIndex, i, li.SubItems[i].Text);
            }
            
            return actualIndex;
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.IsInputKey"]/*' />
        /// <devdoc>
        ///      Handling special input keys, such as pgup, pgdown, home, end, etc...
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                    return true;
            }
            
            bool isInputKey = base.IsInputKey(keyData);
            if (isInputKey)
                return true;

            if (inLabelEdit) {
                switch (keyData & Keys.KeyCode) {
                    case Keys.Return:
                    case Keys.Escape:
                        return true;
                }
            }

            return false;
        }
        
        private void LargeImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated) {
                IntPtr handle = (LargeImageList == null) ? IntPtr.Zero : LargeImageList.Handle;
                SendMessage(NativeMethods.LVM_SETIMAGELIST, (IntPtr) NativeMethods.LVSIL_NORMAL, handle);
                
                ForceCheckBoxUpdate();
            }
        }
  
        private void LvnBeginDrag(MouseButtons buttons, NativeMethods.NMLISTVIEW nmlv) {
            ListViewItem item = Items[nmlv.iItem];
            OnItemDrag(new ItemDragEventArgs(buttons, item));
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnAfterLabelEdit"]/*' />
        /// <devdoc>
        ///     Fires the afterLabelEdit event.
        /// </devdoc>
        protected virtual void OnAfterLabelEdit(LabelEditEventArgs e) {
            if (onAfterLabelEdit != null) onAfterLabelEdit(this, e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnBeforeLabelEdit"]/*' />
        /// <devdoc>
        ///     Fires the beforeLabelEdit event.
        /// </devdoc>
        protected virtual void OnBeforeLabelEdit(LabelEditEventArgs e) {
            if (onBeforeLabelEdit != null) onBeforeLabelEdit(this, e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnColumnClick"]/*' />
        /// <devdoc>
        ///     Fires the columnClick event.
        /// </devdoc>
        protected virtual void OnColumnClick(ColumnClickEventArgs e) {
            if (onColumnClick != null) onColumnClick(this, e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);

            // If font changes and we have headers, they need to be expicitly invalidated
            //
            if (viewStyle == View.Details && IsHandleCreated) {
                IntPtr hwndHdr = UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_GETHEADER, 0, 0);
                if (hwndHdr != IntPtr.Zero)
                    SafeNativeMethods.InvalidateRect(new HandleRef(this, hwndHdr), null, true);
            }    
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnHandleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            UpdateExtendedStyles();
            RealizeProperties();
            int color = ColorTranslator.ToWin32(BackColor);
            SendMessage(NativeMethods.LVM_SETBKCOLOR, 0, color);
            SendMessage(NativeMethods.LVM_SETTEXTBKCOLOR, 0, color);
            SendMessage(NativeMethods.LVM_SETTEXTCOLOR, 0, ColorTranslator.ToWin32(base.ForeColor));

            this.handleDestroyed = false;
            
            // Use a copy of the list items array so that we can maintain the (handle created || listItemsArray != null) invariant
            //
            ArrayList copyofListItemsArray = null;
            if (listItemsArray != null) {
                copyofListItemsArray = new ArrayList(listItemsArray);
                listItemsArray = null;
            }

            int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length);
            if (columnCount > 0) {
                int index = 0;
                foreach (ColumnHeader column in columnHeaders) {
                    InsertColumnNative(index++, column);
                    
                }
            
            }
            
            if (itemCount > 0) {
            
                // The list view is more efficient at adding items
                // to the end than inserting.  Always use itemCount + 1
                // for our index.
                //
                SendMessage(NativeMethods.LVM_SETITEMCOUNT, itemCount, 0);
                int index = itemCount + 1;
                
                if (copyofListItemsArray != null ) {
                    foreach (ListViewItem item in copyofListItemsArray) {
                        int itemIndex = InsertItemNative(index, item.ID, item);
                        item.UpdateStateToListView(itemIndex);
                    }
                }
            }
            
            if (columnCount > 0) {
                int index = 0;
                foreach (ColumnHeader column in columnHeaders) {
                    SetColumnWidth(index++, column.WidthInternal);
                }
            }

            ArrangeIcons(alignStyle);
            Sort();            
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            if (!Disposing) {

                int count = Items.Count;
                for (int i = 0; i < count; i++) {
                    Items[i].UpdateStateFromListView(i);
                }

                // Save away the selected and checked items
                // 
                savedSelectedItems = new ListViewItem[SelectedItems.Count];
                SelectedItems.CopyTo(savedSelectedItems, 0);
                
                Debug.Assert(listItemsArray == null, "listItemsArray not null, even though handle created");
                
                ListViewItem[] items = new ListViewItem[Items.Count];
                Items.CopyTo(items, 0);
                
                listItemsArray = new ArrayList(items.Length);
                listItemsArray.AddRange(items);
                handleDestroyed = true;
            }
            
            base.OnHandleDestroyed(e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnItemActivate"]/*' />
        /// <devdoc>
        ///     Fires the itemActivate event.
        /// </devdoc>
        protected virtual void OnItemActivate(EventArgs e) {
            if (onItemActivate != null) onItemActivate.Invoke(this, e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnItemCheck"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the KeyEventArgs.  Don't
        ///     forget to call base.onItemCheck() to ensure that itemCheck vents
        ///     are correctly fired for all other keys.
        /// </devdoc>
        protected virtual void OnItemCheck(ItemCheckEventArgs ice) {
            if (onItemCheck != null) {
                onItemCheck(this, ice);
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnItemDrag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnItemDrag(ItemDragEventArgs e) {
            if (onItemDrag != null) onItemDrag(this, e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the selectedIndexChanged event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler on yourself for this event].  They should,
        ///     however, remember to call base.onSelectedIndexChanged(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected virtual void OnSelectedIndexChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_SELECTEDINDEXCHANGED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.OnSystemColorsChanged"]/*' />
        protected override void OnSystemColorsChanged(EventArgs e) {
            base.OnSystemColorsChanged(e);
        
            if (IsHandleCreated) {
                int color = ColorTranslator.ToWin32(BackColor);
                SendMessage(NativeMethods.LVM_SETBKCOLOR, 0,color);
                SendMessage(NativeMethods.LVM_SETTEXTBKCOLOR, 0, color);
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.RealizeAllSubItems"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void RealizeAllSubItems() {
            for (int i = 0; i < itemCount; i++) {
                int subItemCount = Items[i].SubItems.Count;
                for (int j = 0; j < subItemCount; j++) {
                    SetItemText(i, j, Items[i].SubItems[j].Text);
                }
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.RealizeProperties"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected void RealizeProperties() {
            //Realize state information
            Color c;

            c = BackColor;
            if (c != SystemColors.Window) {
                SendMessage(NativeMethods.LVM_SETBKCOLOR, 0, ColorTranslator.ToWin32(c));
                SendMessage(NativeMethods.LVM_SETTEXTBKCOLOR, 0, ColorTranslator.ToWin32(c));
            }
            c = ForeColor;
            if (c != SystemColors.WindowText)
                SendMessage(NativeMethods.LVM_SETTEXTCOLOR, 0, ColorTranslator.ToWin32(c));


            if (null != imageListLarge)
                SendMessage(NativeMethods.LVM_SETIMAGELIST, NativeMethods.LVSIL_NORMAL, imageListLarge.Handle);

            if (null != imageListSmall)
                SendMessage(NativeMethods.LVM_SETIMAGELIST, NativeMethods.LVSIL_SMALL, imageListSmall.Handle);

            if (null != imageListState)
                SendMessage(NativeMethods.LVM_SETIMAGELIST, NativeMethods.LVSIL_STATE, imageListState.Handle);
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SetColumnInfo"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void SetColumnInfo(int mask, ColumnHeader ch) {
            if (IsHandleCreated) {
                Debug.Assert((mask & ~(NativeMethods.LVCF_FMT | NativeMethods.LVCF_TEXT)) == 0, "Unsupported mask in setColumnInfo");
                NativeMethods.LVCOLUMN lvColumn = new NativeMethods.LVCOLUMN();
                lvColumn.mask  = mask;
                if ((mask & NativeMethods.LVCF_FMT) != 0)
                    lvColumn.fmt        = (int)ch.TextAlign;
                if ((mask & NativeMethods.LVCF_TEXT) != 0)
                    lvColumn.pszText    = Marshal.StringToHGlobalAuto(ch.Text);

                int retval = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_SETCOLUMN, ch.Index, lvColumn);
                if ((mask & NativeMethods.LVCF_TEXT) != 0)
                    Marshal.FreeHGlobal(lvColumn.pszText);

                if (0 == retval)
                    throw new InvalidOperationException(SR.GetString(SR.ListViewColumnInfoSet));
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SetColumnWidth"]/*' />
        /// <devdoc>
        ///     Setting width is a special case 'cuz LVM_SETCOLUMNWIDTH accepts more values
        ///     for width than LVM_SETCOLUMN does.
        /// </devdoc>
        /// <internalonly/>
        internal void SetColumnWidth(int index, int width) {
            if (IsHandleCreated) {
                SendMessage(NativeMethods.LVM_SETCOLUMNWIDTH, index, width);
            }
        }

        internal void SetItemImage(int index, int image) {
            if (index < 0 || index >= itemCount)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));
            Debug.Assert(IsHandleCreated, "How did we add items without a handle?");

            NativeMethods.LVITEM lvItem =  new NativeMethods.LVITEM();
            lvItem.mask = NativeMethods.LVIF_IMAGE;
            lvItem.iItem = index;
            lvItem.iImage = image;
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_SETITEM, 0, ref lvItem);
        }

        internal void SetItemState(int index, int state, int mask) {
            if (index < 0 || index >= itemCount)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));

            Debug.Assert(IsHandleCreated, "How did we add items without a handle?");

            NativeMethods.LVITEM lvItem =  new NativeMethods.LVITEM();
            lvItem.mask = NativeMethods.LVIF_STATE;
            lvItem.state = state;
            lvItem.stateMask = mask;
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_SETITEMSTATE, index, ref lvItem);
        }

        internal void SetItemText(int itemIndex, int subItemIndex, string text) {

            Debug.Assert(IsHandleCreated, "SetItemText with no handle");

            NativeMethods.LVITEM lvItem = new NativeMethods.LVITEM();
            lvItem.mask = NativeMethods.LVIF_TEXT;
            lvItem.iItem    = itemIndex;
            lvItem.iSubItem = subItemIndex;
            lvItem.pszText  = text;

            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_SETITEMTEXT, itemIndex, ref lvItem);
        }
        
        private void SmallImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated) {
                IntPtr handle = (SmallImageList == null) ? IntPtr.Zero : SmallImageList.Handle;
                SendMessage(NativeMethods.LVM_SETIMAGELIST, (IntPtr) NativeMethods.LVSIL_SMALL, handle);
                
                ForceCheckBoxUpdate();
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.Sort"]/*' />
        /// <devdoc>
        ///      Updated the sorted order
        /// </devdoc>
        public void Sort() {
            if (IsHandleCreated && listItemSorter != null) {
                NativeMethods.ListViewCompareCallback callback = new NativeMethods.ListViewCompareCallback(this.CompareFunc);
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_SORTITEMS, IntPtr.Zero, callback);
            }    
        }
        
        private void StateImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated) {
                IntPtr handle = (StateImageList == null) ? IntPtr.Zero : StateImageList.Handle;
                SendMessage(NativeMethods.LVM_SETIMAGELIST, (IntPtr) NativeMethods.LVSIL_STATE, handle);
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            
            string s = base.ToString();
            
            if (listItemsArray != null) {
                s += ", Items.Count: " + listItemsArray.Count.ToString();
                if (listItemsArray.Count > 0) {
                    string z = listItemsArray[0].ToString();
                    string txt = (z.Length > 40) ? z.Substring(0, 40) : z;
                    s += ", Items[0]: " + txt;
                }
            }
            else if (Items != null) {
                s += ", Items.Count: " + Items.Count.ToString();
                if (Items.Count > 0) {
                    string z = Items[0].ToString();
                    string txt = (z.Length > 40) ? z.Substring(0, 40) : z;
                    s += ", Items[0]: " + txt;
                }

            }
            return s;
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.UpdateExtendedStyles"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void UpdateExtendedStyles() {
        
            if (IsHandleCreated) {
                int exStyle = 0;
                int exMask = NativeMethods.LVS_EX_ONECLICKACTIVATE | NativeMethods.LVS_EX_TWOCLICKACTIVATE |
                             NativeMethods.LVS_EX_HEADERDRAGDROP | NativeMethods.LVS_EX_CHECKBOXES |
                             NativeMethods.LVS_EX_FULLROWSELECT | NativeMethods.LVS_EX_GRIDLINES |
                             NativeMethods.LVS_EX_TRACKSELECT;
    
                switch (activation) {
                    case ItemActivation.OneClick:
                        exStyle |= NativeMethods.LVS_EX_ONECLICKACTIVATE;
                        break;
                    case ItemActivation.TwoClick:
                        exStyle |= NativeMethods.LVS_EX_TWOCLICKACTIVATE;
                        break;
                }
    
                if (allowColumnReorder)
                    exStyle |= NativeMethods.LVS_EX_HEADERDRAGDROP;
    
                if (checkBoxes)
                    exStyle |= NativeMethods.LVS_EX_CHECKBOXES;
    
                if (fullRowSelect)
                    exStyle |= NativeMethods.LVS_EX_FULLROWSELECT;
    
                if (gridLines)
                    exStyle |= NativeMethods.LVS_EX_GRIDLINES;
    
                if (hoverSelection)
                    exStyle |= NativeMethods.LVS_EX_TRACKSELECT;
    
                SendMessage(NativeMethods.LVM_SETEXTENDEDLISTVIEWSTYLE, exMask, exStyle);
                
                Invalidate();
            }
        }
        
        private void WmNmClick(ref Message m) {
                
            // If we're checked, hittest to see if we're
            // on the check mark
            
            if (CheckBoxes) {
                Point pos = Cursor.Position;
                pos = PointToClientInternal(pos);
                NativeMethods.LVHITTESTINFO lvhi = new NativeMethods.LVHITTESTINFO();
    
                lvhi.pt_x = pos.X;
                lvhi.pt_y = pos.Y;
    
                int displayIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_HITTEST, 0, lvhi);
                if (displayIndex != -1 && (lvhi.flags & NativeMethods.LVHT_ONITEMSTATEICON) != 0) {
                    ListViewItem clickedItem = Items[displayIndex];
                    
                    if (clickedItem.Selected) {
                        bool check = !clickedItem.Checked;
                        foreach(ListViewItem item in SelectedItems) {
                            if (item != clickedItem) {
                                item.Checked = check;
                            }
                        }
                    }
                }
            }
        }

        private void WmNmDblClick(ref Message m) {
                
            // If we're checked, hittest to see if we're
            // on the item
            
            if (CheckBoxes) {
                Point pos = Cursor.Position;
                pos = PointToClientInternal(pos);
                NativeMethods.LVHITTESTINFO lvhi = new NativeMethods.LVHITTESTINFO();
    
                lvhi.pt_x = pos.X;
                lvhi.pt_y = pos.Y;
    
                int displayIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_HITTEST, 0, lvhi);
                if (displayIndex != -1 && (lvhi.flags & NativeMethods.LVHT_ONITEM) != 0) {
                    ListViewItem clickedItem = Items[displayIndex];
                    clickedItem.Checked = !clickedItem.Checked;
                }
            }
        }

        private void WmMouseDown(ref Message m, MouseButtons button, int clicks) {
            //Always Reset the MouseupFired....
            mouseUpFired = false;
            expectingMouseUp = true;
            
            // Windows ListView pushes its own message loop in WM_xBUTTONDOWN, so fire the
            // event before calling defWndProc or else it won't get fired until the button
            // comes back up.
            OnMouseDown(new MouseEventArgs(button, clicks, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
            DefWndProc(ref m);
        }
        
        private unsafe void WmNotify(ref Message m) {
            NativeMethods.NMHDR* nmhdr = (NativeMethods.NMHDR*)m.LParam;
            
            if (nmhdr->code == NativeMethods.NM_RELEASEDCAPTURE && columnClicked) {
                columnClicked = false;
                OnColumnClick(new ColumnClickEventArgs(columnIndex));
            }
            
            if (nmhdr->code == NativeMethods.HDN_ENDTRACK) {
                NativeMethods.NMHEADER nmheader = (NativeMethods.NMHEADER)m.GetLParam(typeof(NativeMethods.NMHEADER));
                if (columnHeaders != null && nmheader.iItem < columnHeaders.Length) {
                    int w = columnHeaders[nmheader.iItem].Width;
                }
                ISite site = Site;
    
                // SBurke, this seems like a really wierd place to annouce this change...
                if (site != null) {
                    IComponentChangeService cs = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    if (cs != null) {
                        try {
                            cs.OnComponentChanging(this, null);
                        }
                        catch (CheckoutException coEx) {
                            if (coEx == CheckoutException.Canceled) {
                                return;
                            }
                            throw coEx;
                        }
                    }
                }
            }
        }
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.GetIndexOfClickedItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private int GetIndexOfClickedItem(NativeMethods.LVHITTESTINFO lvhi) {
            Point pos = Cursor.Position;
            pos = PointToClientInternal(pos);
            lvhi.pt_x = pos.X;
            lvhi.pt_y = pos.Y;
            return (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LVM_HITTEST, 0, lvhi);

        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.WmNotify"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private unsafe void WmReflectNotify(ref Message m) {
        
            NativeMethods.NMHDR* nmhdr = (NativeMethods.NMHDR*)m.LParam;

            switch (nmhdr->code) {
                case NativeMethods.NM_CUSTOMDRAW:
                    CustomDraw(ref m);
                    break;
                case NativeMethods.LVN_BEGINLABELEDITA:
                case NativeMethods.LVN_BEGINLABELEDITW: {
                        NativeMethods.NMLVDISPINFO_NOTEXT nmlvdp = (NativeMethods.NMLVDISPINFO_NOTEXT)m.GetLParam(typeof(NativeMethods.NMLVDISPINFO_NOTEXT));
                        LabelEditEventArgs e = new LabelEditEventArgs(nmlvdp.item.iItem);
                        OnBeforeLabelEdit(e);
                        m.Result = (IntPtr)(e.CancelEdit ? 1 : 0);
                        inLabelEdit = !e.CancelEdit;
                        break;
                    }

                case NativeMethods.LVN_COLUMNCLICK: {
                        NativeMethods.NMLISTVIEW nmlv = (NativeMethods.NMLISTVIEW)m.GetLParam(typeof(NativeMethods.NMLISTVIEW));
                        columnClicked = true;
                        columnIndex = nmlv.iSubItem;
                        break;
                    }

                case NativeMethods.LVN_ENDLABELEDITA:
                    case NativeMethods.LVN_ENDLABELEDITW: {
                        inLabelEdit = false;
                        NativeMethods.NMLVDISPINFO nmlvdp = (NativeMethods.NMLVDISPINFO)m.GetLParam(typeof(NativeMethods.NMLVDISPINFO));
                        LabelEditEventArgs e = new LabelEditEventArgs(nmlvdp.item.iItem, nmlvdp.item.pszText);
                        OnAfterLabelEdit(e);
                        m.Result = (IntPtr)(e.CancelEdit ? 0 : 1);
                        // from msdn:
                        //   "If the user cancels editing, the pszText member of the LVITEM structure is NULL"
                        if (!e.CancelEdit && nmlvdp.item.pszText != null)
                            Items[nmlvdp.item.iItem].Text = nmlvdp.item.pszText;
                        break;
                    }

                case NativeMethods.LVN_ITEMACTIVATE:
                    OnItemActivate(EventArgs.Empty);
                    break;

                case NativeMethods.LVN_BEGINDRAG: {
                    NativeMethods.NMLISTVIEW nmlv = (NativeMethods.NMLISTVIEW)m.GetLParam(typeof(NativeMethods.NMLISTVIEW));
                    LvnBeginDrag(MouseButtons.Left, nmlv);
                    break;
                }    

                case NativeMethods.LVN_BEGINRDRAG: {
                    NativeMethods.NMLISTVIEW nmlv = (NativeMethods.NMLISTVIEW)m.GetLParam(typeof(NativeMethods.NMLISTVIEW));
                    LvnBeginDrag(MouseButtons.Right, nmlv);
                    break;
                }

                case NativeMethods.LVN_ITEMCHANGING: {
                        NativeMethods.NMLISTVIEW* nmlv = (NativeMethods.NMLISTVIEW*)m.LParam;
                        if ((nmlv->uChanged & NativeMethods.LVIF_STATE) != 0) {
                            // Because the state image mask is 1-based, a value of 1 means unchecked,
                            // anything else means checked.  We convert this to the more standard 0 or 1
                            CheckState oldState = (CheckState)(((nmlv->uOldState & NativeMethods.LVIS_STATEIMAGEMASK) >> 12) == 1 ? 0 : 1);
                            CheckState newState = (CheckState)(((nmlv->uNewState & NativeMethods.LVIS_STATEIMAGEMASK) >> 12) == 1 ? 0 : 1);

                            if (oldState != newState) {
                                ItemCheckEventArgs e = new ItemCheckEventArgs(nmlv->iItem, newState, oldState);
                                OnItemCheck(e);
                                m.Result = (IntPtr)(((int)e.NewValue == 0 ? 0 : 1) == (int)oldState ? 1 : 0);
                            }
                        }
                        break;
                    }

                case NativeMethods.LVN_ITEMCHANGED: {
                        NativeMethods.NMLISTVIEW* nmlv = (NativeMethods.NMLISTVIEW*)m.LParam;
                        // Check for state changes to the selected state...
                        if ((nmlv->uChanged & NativeMethods.LVIF_STATE) != 0) {
                            // Because the state image mask is 1-based, a value of 1 means unchecked,
                            // anything else means checked.  We convert this to the more standard 0 or 1
                            int oldState = nmlv->uOldState & NativeMethods.LVIS_SELECTED;
                            int newState = nmlv->uNewState & NativeMethods.LVIS_SELECTED;

                            // Windows common control always fires
                            // this event twice, once with newState, oldState, and again with
                            // oldState, newState.
                            //Changing this affects the behaviour as the control never
                            //fires the event on a Deselct of an Items from multiple selections.
                            //So leave it as it is...

                            if (newState != oldState) OnSelectedIndexChanged(EventArgs.Empty);
                        }
                        break;
                    }
                case NativeMethods.NM_CLICK:
                    WmNmClick(ref m);
                    // FALL THROUGH //
                    goto case NativeMethods.NM_RCLICK;
                case NativeMethods.NM_RCLICK:
                    NativeMethods.LVHITTESTINFO lvhi = new NativeMethods.LVHITTESTINFO();
                    int displayIndex = GetIndexOfClickedItem(lvhi);
                    if (!ValidationCancelled && displayIndex != -1) {
                        OnClick(EventArgs.Empty);
                    }
                    if (!mouseUpFired)
                    {
                        Point pos = Cursor.Position;
                        pos = PointToClientInternal(pos);
                        MouseButtons button = nmhdr->code == NativeMethods.NM_CLICK
                            ? MouseButtons.Left : MouseButtons.Right;
                        OnMouseUp(new MouseEventArgs(button, 1, pos.X, pos.Y, 0));
                        mouseUpFired = true;
                    }
                    break;

                case NativeMethods.NM_DBLCLK:
                    WmNmDblClick(ref m);
                    // FALL THROUGH //
                    goto case NativeMethods.NM_RDBLCLK;
                    
                case NativeMethods.NM_RDBLCLK:
                    NativeMethods.LVHITTESTINFO lvhip = new NativeMethods.LVHITTESTINFO();
                    int index = GetIndexOfClickedItem(lvhip);
                    
                    if (index != -1) {
                        //just maintain state and fire double click.. in final mouseUp...
                        doubleclickFired = true;
                    }
                    //fire Up in the Wndproc !!
                    mouseUpFired = false;
                    //problem getting the UP... outside the control...
                    //
                    CaptureInternal = true;
                    break;
                    
                case NativeMethods.LVN_KEYDOWN: 
                    if (CheckBoxes) {
                        NativeMethods.NMLVKEYDOWN lvkd = (NativeMethods.NMLVKEYDOWN)m.GetLParam(typeof(NativeMethods.NMLVKEYDOWN));
                        if (lvkd.wVKey == (short)Keys.Space) {
                            ListViewItem focusedItem = FocusedItem;
                            if (focusedItem != null) {
                                bool check = !focusedItem.Checked;
                                foreach(ListViewItem item in SelectedItems) {
                                    if (item != focusedItem) {
                                        item.Checked = check;
                                    }
                                }
                            }
                        }
                    }
                    break;
                
                default:
                    break;
            }
        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.WndProc"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {

            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    WmReflectNotify(ref m);
                    break;
                case NativeMethods.WM_LBUTTONDBLCLK:
                    CaptureInternal = true;
                    WmMouseDown(ref m, MouseButtons.Left, 2);
                    break;
                case NativeMethods.WM_LBUTTONDOWN:
                    WmMouseDown(ref m, MouseButtons.Left, 1);
                    downButton = MouseButtons.Left;
                    break;
                case NativeMethods.WM_LBUTTONUP:
                case NativeMethods.WM_RBUTTONUP:
                case NativeMethods.WM_MBUTTONUP:    
                    // see the mouse is on item
                    //
                    NativeMethods.LVHITTESTINFO lvhip = new NativeMethods.LVHITTESTINFO();
                    int index = GetIndexOfClickedItem(lvhip);
                    
                    if (!ValidationCancelled && doubleclickFired && index != -1) {
                        doubleclickFired = false;
                        OnDoubleClick(EventArgs.Empty);
                    }
                    if (!mouseUpFired)
                    {
                        OnMouseUp(new MouseEventArgs(downButton, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                        expectingMouseUp = false;
                    }
                    mouseUpFired = false;
                    CaptureInternal = false;
                    break;
                case NativeMethods.WM_MBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Middle, 2);
                    break;
                case NativeMethods.WM_MBUTTONDOWN:
                    WmMouseDown(ref m, MouseButtons.Middle, 1);
                    downButton = MouseButtons.Middle;
                    break;
                case NativeMethods.WM_RBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Right, 2);
                    break;
                case NativeMethods.WM_RBUTTONDOWN:
                    WmMouseDown(ref m, MouseButtons.Right, 1);
                    downButton = MouseButtons.Right;
                    break;
                case NativeMethods.WM_MOUSEMOVE:
                    if (expectingMouseUp && !mouseUpFired && MouseButtons == MouseButtons.None)
                    {
                        OnMouseUp(new MouseEventArgs(downButton, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                        mouseUpFired = true;
                    }
                    base.WndProc(ref m);
                    break;
                case NativeMethods.WM_MOUSEHOVER:
                    if (hoverSelection) {
                        base.WndProc(ref m);
                    }
                    else
                        OnMouseHover(EventArgs.Empty);
                    break;
                case NativeMethods.WM_NOTIFY:
                    WmNotify(ref m);
                    // *** FALL THROUGH ***
                    goto default;
                case NativeMethods.WM_SETCURSOR:
                    DefWndProc(ref m);
                    break;
                case NativeMethods.WM_SETFOCUS:
                    base.WndProc(ref m);
                    // We should set focus to the first item,
                    // if none of the items are focused already.
                    if (FocusedItem == null && Items.Count > 0)
                    {
                        Items[0].Focused = true;
                    }
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            };
        }

        ///new class for comparing and sorting Icons ....
        //subhag 
        internal class IconComparer: IComparer {
            private SortOrder sortOrder;

            public IconComparer(SortOrder currentSortOrder) {
                   this.sortOrder = currentSortOrder;
            }

            public int Compare(object obj1, object obj2) {
                //subhag
                ListViewItem currentItem =  (ListViewItem)obj1;
                ListViewItem nextItem =  (ListViewItem)obj2;
                if (sortOrder == SortOrder.Ascending) {
                    return (String.Compare(currentItem.Text,nextItem.Text, false, CultureInfo.CurrentCulture));
                }
                else {
                    return (String.Compare(nextItem.Text,currentItem.Text, false, CultureInfo.CurrentCulture));
                }
            }
        }
        //end subhag

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class CheckedIndexCollection : IList {
            private ListView owner;

            /* C#r: protected */
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.CheckedIndexCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public CheckedIndexCollection(ListView owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of currently selected items.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    if (!owner.CheckBoxes) {
                        return 0;
                    }
                    
                    // Count the number of checked items
                    //
                    int count = 0;
                    foreach(ListViewItem item in owner.Items) {
                        if (item.Checked) {
                            count++;
                        }
                    }
                    return count;
                }
            }

            private int[] IndicesArray {
                get {
                    int[] indices = new int[Count];
                    int index = 0;
                    for(int i=0; i < owner.Items.Count && index < indices.Length; ++i) {
                        if (owner.Items[i].Checked) {
                            indices[index++] = i;
                        }
                    }
                    return indices;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.this"]/*' />
            /// <devdoc>
            ///     Selected item in the list.
            /// </devdoc>
            public int this[int index] {
                get {
                
                    if (index < 0) {
                        throw new ArgumentOutOfRangeException("index");
                    }
                
                    // Loop through the main collection until we find the right index.  
                    //
                    int cnt = owner.Items.Count;
                    int nChecked = 0;
                    for(int i = 0; i < cnt; i++) {
                        ListViewItem item = owner.Items[i];
                        
                        if (item.Checked) {
                            if (nChecked == index) {
                                return i;
                            }
                            nChecked++;
                        }
                    }
                    
                    // Should never get to this point.
                    throw new ArgumentOutOfRangeException("index");
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(int checkedIndex) {
                if (owner.Items[checkedIndex].Checked) {
                    return true;
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object checkedIndex) {
                if (checkedIndex is Int32) {
                    return Contains((int)checkedIndex);
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(int checkedIndex) {
                int[] indices = IndicesArray;
                for(int index=0; index < indices.Length; ++index) {
                    if (indices[index] == checkedIndex) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object checkedIndex) {
                if (checkedIndex is Int32) {
                    return IndexOf((int)checkedIndex);
                }
                else {
                    return -1;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedIndexCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(IndicesArray, 0, dest, index, Count);
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedIndexCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                int[] indices = IndicesArray;
                if (indices != null) {
                    return indices.GetEnumerator();
                }
                else {
                    return new int[0].GetEnumerator();
                }
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class CheckedListViewItemCollection : IList {
            private ListView owner;

            /* C#r: protected */
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.CheckedListViewItemCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public CheckedListViewItemCollection(ListView owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of currently selected items.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.CheckedIndices.Count;
                }
            }

            private ListViewItem[] ItemArray {
                get {
                    ListViewItem[] items = new ListViewItem[Count];
                    int index = 0;
                    for(int i=0; i < owner.Items.Count && index < items.Length; ++i) {
                        if (owner.Items[i].Checked) {
                            items[index++] = owner.Items[i];
                        }
                    }
                    return items;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.this"]/*' />
            /// <devdoc>
            ///     Selected item in the list.
            /// </devdoc>
            public ListViewItem this[int index] {
                get {
                    int itemIndex = owner.CheckedIndices[index];
                    return owner.Items[itemIndex];
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(ListViewItem item) {
                if (item != null && item.ListView == owner && item.Checked) {
                    return true;
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object item) {
                if (item is ListViewItem) {
                    return Contains((ListViewItem)item);
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(ListViewItem item) {
                ListViewItem[] items = ItemArray;
                for(int index=0; index < items.Length; ++index) {
                    if (items[index] == item) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object item) {
                if (item is ListViewItem) {
                    return IndexOf((ListViewItem)item);
                }
                else {
                    return -1;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="CheckedListViewItemCollection.CopyTo"]/*' />
            public void CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(ItemArray, 0, dest, index, Count);
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.CheckedListViewItemCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                ListViewItem[] items = ItemArray;
                if (items != null) {
                    return items.GetEnumerator();
                }
                else {
                    return new ListViewItem[0].GetEnumerator();
                }
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class SelectedIndexCollection : IList {
            private ListView owner;

            /* C#r: protected */
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.SelectedIndexCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public SelectedIndexCollection(ListView owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of currently selected items.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    if (owner.IsHandleCreated) {
                        return (int)owner.SendMessage(NativeMethods.LVM_GETSELECTEDCOUNT, 0, 0);
                    }
                    else {
                        if (owner.savedSelectedItems != null) {
                            return owner.savedSelectedItems.Length;
                        }
                        return 0;
                    }
                }
            }

            private int[] IndicesArray {
                get {
                    int count = Count;
                    int[] indices = new int[count];

                    if (owner.IsHandleCreated) {
                        int displayIndex = -1;
                        for (int i = 0; i < count; i++) {
                            int fidx = (int)owner.SendMessage(NativeMethods.LVM_GETNEXTITEM, displayIndex, NativeMethods.LVNI_SELECTED);

                            if (fidx > -1) {
                                indices[i] = fidx;
                                displayIndex = fidx;
                            }
                            else
                                throw new InvalidOperationException(SR.GetString(SR.SelectedNotEqualActual));
                        }
                    }
                    else {
                        Debug.Assert(owner.savedSelectedItems != null, "Null selected items collection");
                        for (int i = 0; i < count; i++) {
                            indices[i] = owner.savedSelectedItems[i].Index;
                        }
                    }

                    return indices;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.this"]/*' />
            /// <devdoc>
            ///     Selected item in the list.
            /// </devdoc>
            public int this[int index] {
                get {
                
                    if (index < 0 || index >= Count) {
                        throw new ArgumentOutOfRangeException("index");
                    }
                
                    if (owner.IsHandleCreated) {
                        
                        // Count through the selected items in the ListView, until
                        // we reach the 'index'th selected item.
                        //
                        int fidx = -1;
                        for(int count = 0; count <= index; count++) { 
                            fidx = (int)owner.SendMessage(NativeMethods.LVM_GETNEXTITEM, fidx, NativeMethods.LVNI_SELECTED);
                            Debug.Assert(fidx != -1, "Invalid index returned from LVM_GETNEXTITEM");
                        }
                        
                        return fidx;
                    }
                    else {
                        Debug.Assert(owner.savedSelectedItems != null, "Null selected items collection");
                        return owner.savedSelectedItems[index].Index;
                    }
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(int selectedIndex) {
                if (owner.Items[selectedIndex].Selected) {
                    return true;
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object selectedIndex) {
                if (selectedIndex is Int32) {
                    return Contains((int)selectedIndex);
                }
                else {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(int selectedIndex) {
                int[] indices = IndicesArray;
                for(int index=0; index < indices.Length; ++index) {
                    if (indices[index] == selectedIndex) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object selectedIndex) {
                if (selectedIndex is Int32) {
                    return IndexOf((int)selectedIndex);
                }
                else {
                    return -1;
                }
            }

            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedIndexCollection.CopyTo"]/*' />
            public void CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(IndicesArray, 0, dest, index, Count);
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedIndexCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                int[] indices = IndicesArray;
                if (indices != null) {
                    return indices.GetEnumerator();
                }
                else {
                    return new int[0].GetEnumerator();
                }
            }
        }
        
        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class SelectedListViewItemCollection : IList {
            private ListView owner;

            /* C#r: protected */
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.SelectedListViewItemCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public SelectedListViewItemCollection(ListView owner) {
                this.owner = owner;
            }
            
            private ListViewItem[] SelectedItemArray {
                get {
                    if (owner.IsHandleCreated) {
                        int cnt = (int)owner.SendMessage(NativeMethods.LVM_GETSELECTEDCOUNT, 0, 0);

                        ListViewItem[] lvitems = new ListViewItem[cnt];

                        int displayIndex = -1;

                        for (int i = 0; i < cnt; i++) {
                            int fidx = (int)owner.SendMessage(NativeMethods.LVM_GETNEXTITEM, displayIndex, NativeMethods.LVNI_SELECTED);

                            if (fidx > -1) {
                                lvitems[i] = owner.Items[fidx];
                                displayIndex = fidx;
                            }
                            else
                                throw new InvalidOperationException(SR.GetString(SR.SelectedNotEqualActual));
                        }

                        return lvitems;

                    }
                    else {
                        if (owner.savedSelectedItems != null) {
                            ListViewItem[] cloned = new ListViewItem[owner.savedSelectedItems.Length];
                            Array.Copy(owner.savedSelectedItems, cloned, owner.savedSelectedItems.Length);
                            return cloned;
                        }
                        else {
                            return new ListViewItem[0];
                        }
                    }
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of currently selected items.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    if (owner.IsHandleCreated) {
                        return (int)owner.SendMessage(NativeMethods.LVM_GETSELECTEDCOUNT, 0, 0);
                    }
                    else {
                        if (owner.savedSelectedItems != null) {
                            return owner.savedSelectedItems.Length;
                        }
                        return 0;
                    }
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.this"]/*' />
            /// <devdoc>
            ///     Selected item in the list.
            /// </devdoc>
            public ListViewItem this[int index] {
                get {
                
                    if (index < 0 || index >= Count) {
                        throw new ArgumentOutOfRangeException("index");
                    }
                
                    if (owner.IsHandleCreated) {
                        
                        // Count through the selected items in the ListView, until
                        // we reach the 'index'th selected item.
                        //
                        int fidx = -1;
                        for(int count = 0; count <= index; count++) { 
                            fidx = (int)owner.SendMessage(NativeMethods.LVM_GETNEXTITEM, fidx, NativeMethods.LVNI_SELECTED);
                            Debug.Assert(fidx != -1, "Invalid index returned from LVM_GETNEXTITEM");
                        }
                        
                        return owner.Items[fidx];                        
                    }
                    else {
                        Debug.Assert(owner.savedSelectedItems != null, "Null selected items collection");
                        return owner.savedSelectedItems[index];
                    }
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    // SelectedListViewItemCollection is read-only
                    throw new NotSupportedException();
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                // SelectedListViewItemCollection is read-only
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                // SelectedListViewItemCollection is read-only
                throw new NotSupportedException();
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                // SelectedListViewItemCollection is read-only
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                // SelectedListViewItemCollection is read-only
                throw new NotSupportedException();
            }
                                        
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.Clear"]/*' />
            /// <devdoc>
            ///     Unselects all items.
            /// </devdoc>
            public void Clear() {
                ListViewItem[] items = SelectedItemArray;
                for (int i=0; i < items.Length; i++) {
                    items[i].Selected = false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(ListViewItem item) {
                 return (IndexOf(item) != -1);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object item) {
                if (item is ListViewItem) {
                    return Contains((ListViewItem)item);
                }
                else {
                    return false;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(SelectedItemArray, 0, dest, index, Count);
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                ListViewItem[] items = SelectedItemArray;
                if (items != null) {
                    return items.GetEnumerator();
                }
                else {
                    return new ListViewItem[0].GetEnumerator();
                }
           }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.SelectedListViewItemCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(ListViewItem item) {
                ListViewItem[] items = SelectedItemArray;
                for(int index=0; index < items.Length; ++index) {
                    if (items[index] == item) {
                        return index;
                    }
                }                
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="SelectedListViewItemCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object item) {
                if (item is ListViewItem) {
                    return IndexOf((ListViewItem)item);
                }
                else {
                    return -1;
                }
            }

        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class ColumnHeaderCollection : IList {
            private ListView owner;

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.ColumnHeaderCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ColumnHeaderCollection(ListView owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.this"]/*' />
            /// <devdoc>
            ///     Given a Zero based index, returns the ColumnHeader object
            ///     for the column at that index
            /// </devdoc>
            public virtual ColumnHeader this[int index] {
                get {
                    if (owner.columnHeaders == null || index < 0 || index >= owner.columnHeaders.Length)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  (index).ToString()));
                    return owner.columnHeaders[index];
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Count"]/*' />
            /// <devdoc>
            ///     The number of columns the ListView currently has in Details view.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.columnHeaders == null ? 0 : owner.columnHeaders.Length;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Add"]/*' />
            /// <devdoc>
            ///     Adds a column to the end of the Column list
            /// </devdoc>
            public virtual ColumnHeader Add(string str, int width, HorizontalAlignment textAlign) {
                ColumnHeader columnHeader = new ColumnHeader();
                columnHeader.Text = str;
                columnHeader.Width = width;
                columnHeader.TextAlign = textAlign;
                return owner.InsertColumn(Count, columnHeader);
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Add1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual int Add(ColumnHeader value) {
                int index = Count;
                owner.InsertColumn(index, value);
                return index;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void AddRange(ColumnHeader[] values) {
                if (values == null) {
                    throw new ArgumentNullException("values");
                }
                foreach(ColumnHeader column in values) {
                    Add(column);
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                if (value is ColumnHeader) {
                    return Add((ColumnHeader)value);
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.ColumnHeaderCollectionInvalidArgument));
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Clear"]/*' />
            /// <devdoc>
            ///     Removes all columns from the list view.
            /// </devdoc>
            public virtual void Clear() {
                // Delete the columns
                if (owner.columnHeaders != null) {
                    for (int colIdx = owner.columnHeaders.Length-1; colIdx >= 0; colIdx--) {
                        int w = owner.columnHeaders[colIdx].Width; // Update width before detaching from ListView
                        if (owner.IsHandleCreated) {
                            owner.SendMessage(NativeMethods.LVM_DELETECOLUMN, colIdx, 0);
                        }
                        owner.columnHeaders[colIdx].OwnerListview = null;
                    }
                    owner.columnHeaders = null;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(ColumnHeader value) {
                return IndexOf(value) != -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object value) {
                if (value is ColumnHeader) {
                    return Contains((ColumnHeader)value);
                }
                return false;
            } 

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(owner.columnHeaders, 0, dest, index, Count);
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(ColumnHeader value) {
                for(int index=0; index < Count; ++index) {
                    if (this[index] == value) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object value) {
                if (value is ColumnHeader) {
                    return IndexOf((ColumnHeader)value);
                }
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Insert"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Insert(int index, ColumnHeader value) {
                if (index < 0 || index > Count) {
                    throw new ArgumentOutOfRangeException("index");
                }
                owner.InsertColumn(index, value);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                if (value is ColumnHeader) {
                    Insert(index, (ColumnHeader)value);
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Insert1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Insert(int index, string str, int width, HorizontalAlignment textAlign) {
                ColumnHeader columnHeader = new ColumnHeader();
                columnHeader.Text = str;
                columnHeader.Width = width;
                columnHeader.TextAlign = textAlign;
                Insert(index, columnHeader);
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///     removes a column from the ListView
            /// </devdoc>
            public virtual void RemoveAt(int index) {
                if (index < 0 || index >= owner.columnHeaders.Length)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              (index).ToString()));

                int w = owner.columnHeaders[index].Width; // Update width before detaching from ListView

                if (owner.IsHandleCreated) {
                    int retval = (int)owner.SendMessage(NativeMethods.LVM_DELETECOLUMN, index, 0);

                    if (0 == retval)
                        throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  (index).ToString()));
                }

                owner.columnHeaders[index].OwnerListview = null;
                int columnCount = owner.columnHeaders.Length;
                Debug.Assert(columnCount >= 1, "Column mismatch");
                if (columnCount == 1)
                    owner.columnHeaders = null;
                else {
                    ColumnHeader[] newHeaders = new ColumnHeader[--columnCount];
                    if (index > 0)
                        System.Array.Copy(owner.columnHeaders, 0, newHeaders, 0, index);
                    if (index < columnCount)
                        System.Array.Copy(owner.columnHeaders, index+1, newHeaders, index, columnCount - index);
                    owner.columnHeaders = newHeaders;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void Remove(ColumnHeader column) {
                int index = IndexOf(column);
                if (index != -1) {
                    RemoveAt(index);
                }                
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ColumnHeaderCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                if (value is ColumnHeader) {
                    Remove((ColumnHeader)value);
                }                
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ColumnHeaderCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                if (owner.columnHeaders != null) {
                    return owner.columnHeaders.GetEnumerator();
                }
                else
                {
                    return new ColumnHeader[0].GetEnumerator();
                }
            }

        }

        /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class ListViewItemCollection : IList {
            private ListView owner;

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.ListViewItemCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewItemCollection(ListView owner) {
                this.owner = owner;
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Count"]/*' />
            /// <devdoc>
            ///     Returns the total number of items within the list view.
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.itemCount;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.this"]/*' />
            /// <devdoc>
            ///     Returns a ListViewItem given it's zero based index into the ListView.
            /// </devdoc>
            public virtual ListViewItem this[int displayIndex] {
                get {
                    if (displayIndex < 0 || displayIndex >= owner.itemCount)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "displayIndex",
                                                                  (displayIndex).ToString()));

                    if (owner.IsHandleCreated && !owner.handleDestroyed) {
                        Debug.Assert(owner.listItemsArray == null, "listItemsArray not null, even though handle created");
                        return(ListViewItem) owner.listItemsTable[DisplayIndexToID(displayIndex)];
                    }
                    else {
                        Debug.Assert(owner.listItemsArray != null, "listItemsArray is null, but the handle isn't created");
                        return(ListViewItem) owner.listItemsArray[displayIndex];
                    }
                }
                set {
                    if (displayIndex < 0 || displayIndex >= owner.itemCount)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                           "displayIndex",
                                                                           (displayIndex).ToString()));
                
                    RemoveAt(displayIndex);
                    Insert(displayIndex, value);
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    if (value is ListViewItem) {
                        this[index] = (ListViewItem)value;
                    }
                    else if (value != null) {
                        this[index] = new ListViewItem(value.ToString(), -1);
                    }
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Add"]/*' />
            /// <devdoc>
            ///     Add an item to the ListView.  The item will be inserted either in
            ///     the correct sorted position, or, if no sorting is set, at the end
            ///     of the list.
            /// </devdoc>
            public virtual ListViewItem Add(string text) {
                return Add(text, -1);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object item) {
                if (item is ListViewItem) {
                    return IndexOf(Add((ListViewItem)item));
                }
                else if (item != null) {
                    return IndexOf(Add(item.ToString()));                    
                }
                return -1;
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Add1"]/*' />
            /// <devdoc>
            ///     Add an item to the ListView.  The item will be inserted either in
            ///     the correct sorted position, or, if no sorting is set, at the end
            ///     of the list.
            /// </devdoc>
            public virtual ListViewItem Add(string text, int imageIndex) {
                ListViewItem li = new ListViewItem(text, imageIndex);
                Add(li);                
                return li;
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Add2"]/*' />
            /// <devdoc>
            ///     Add an item to the ListView.  The item will be inserted either in
            ///     the correct sorted position, or, if no sorting is set, at the end
            ///     of the list.
            /// </devdoc>
            public virtual ListViewItem Add(ListViewItem value) {
                return owner.InsertItem(owner.itemCount, value);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddRange(ListViewItem[] values) {
                if (values == null) {
                    throw new ArgumentNullException("values");
                }
            
                IComparer comparer = owner.listItemSorter;
                owner.listItemSorter = null;
                
                try {
                    if (owner.IsHandleCreated) {
                        // Allocate all the space in one shot to improve performance
                        //
                        owner.SendMessage(NativeMethods.LVM_SETITEMCOUNT, Count + values.Length, 0);
                    }
                    
                    foreach(ListViewItem item in values) {
                        Add(item);
                    }
                }
                finally {
                    owner.listItemSorter = comparer;
                }
                
                if (comparer != null || (owner.Sorting != SortOrder.None)) {
                    owner.Sort();
                }
            }

            private int DisplayIndexToID(int displayIndex) {
                if (owner.IsHandleCreated && !owner.handleDestroyed) {
                    // Obtain internal index of the item                                              
                    NativeMethods.LVITEM lvItem = new NativeMethods.LVITEM();
                    lvItem.mask = NativeMethods.LVIF_PARAM;
                    lvItem.iItem = displayIndex;
                    UnsafeNativeMethods.SendMessage(new HandleRef(owner, owner.Handle), NativeMethods.LVM_GETITEM, 0, ref lvItem);
                    return (int)lvItem.lParam;
                }
                else
                {
                    return this[displayIndex].ID;
                }
            }                                 

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Clear"]/*' />
            /// <devdoc>
            ///     Removes all items from the list view.
            /// </devdoc>
            public virtual void Clear() {
                if (owner.itemCount > 0) {
                    int count = owner.Items.Count;
                    for (int i = 0; i < count; i++) {
                        owner.Items[i].UnHost(i);
                    }

                    if (owner.IsHandleCreated && !owner.handleDestroyed) {
                        Debug.Assert(owner.listItemsArray == null, "listItemsArray not null, even though handle created");
                        UnsafeNativeMethods.SendMessage(new HandleRef(owner, owner.Handle), NativeMethods.LVM_DELETEALLITEMS, 0, 0);

                        // There's a problem in the list view that if it's in small icon, it won't pick upo the small icon
                        // sizes until it changes from large icon, so we flip it twice here...
                        //
                        if (owner.View == View.SmallIcon) {
                            owner.View = View.LargeIcon;
                            owner.View = View.SmallIcon;
                        }

                    }
                    else {
                        Debug.Assert(owner.listItemsArray != null, "listItemsArray is null, but the handle isn't created");
                        owner.listItemsArray.Clear();
                    }

                    owner.listItemsTable.Clear();
                    owner.itemCount = 0;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(ListViewItem item) {
                return (IndexOf(item) != -1);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object item) {
                if (item is ListViewItem) {
                    return Contains((ListViewItem)item);
                }
                else {
                    return false;
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                if (owner.itemCount > 0) {
                    for(int displayIndex=0; displayIndex < Count; ++displayIndex) {
                        dest.SetValue(this[displayIndex], index++);
                    }                    
                }
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                ListViewItem[] items = new ListViewItem[this.Count];
                this.CopyTo(items, 0);
                
                return items.GetEnumerator();                
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(ListViewItem item) {
                for(int index=0; index < Count; ++index) {
                    if (this[index] == item) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object item) {
                if (item is ListViewItem) {
                    return IndexOf((ListViewItem)item);
                }
                else {
                    return -1;
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Insert"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewItem Insert(int index, ListViewItem item) {
                if (index < 0 || index > Count) {
                    throw new ArgumentOutOfRangeException("index");
                }
                return owner.InsertItem(index, item);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Insert1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewItem Insert(int index, string text) {
                return Insert(index, new ListViewItem(text));
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Insert2"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ListViewItem Insert(int index, string text, int imageIndex) {
                return Insert(index, new ListViewItem(text, imageIndex));
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object item) {
                if (item is ListViewItem) {
                    Insert(index, (ListViewItem)item);
                }
                else if (item != null) {
                    Insert(index, item.ToString());
                }
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///     Removes an item from the ListView
            /// </devdoc>
            public virtual void RemoveAt(int index) {
                if (index < 0 || index >= owner.itemCount)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              (index).ToString()));


                this[index].UnHost();
                int itemID = DisplayIndexToID(index);

                if (owner.IsHandleCreated) {
                    Debug.Assert(owner.listItemsArray == null, "listItemsArray not null, even though handle created");
                    int retval = (int)owner.SendMessage(NativeMethods.LVM_DELETEITEM, index, 0);

                    if (0 == retval)
                        throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  (index).ToString()));
                }
                else {
                    Debug.Assert(owner.listItemsArray != null, "listItemsArray is null, but the handle isn't created");
                    owner.listItemsArray.RemoveAt(index);
                }

                owner.itemCount--;
                owner.listItemsTable.Remove(itemID);
            }

            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListView.ListViewItemCollection.Remove"]/*' />
            /// <devdoc>
            ///     Removes an item from the ListView
            /// </devdoc>
            public virtual void Remove(ListViewItem item) {
                if (item == null) {
                    return;
                }
                    
                int index = item.Index;
                if (index >= 0)
                    RemoveAt(index);
            }
            
            /// <include file='doc\ListView.uex' path='docs/doc[@for="ListViewItemCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object item) {
                if (item == null || !(item is ListViewItem)) {
                    return;
                }
                
                Remove((ListViewItem)item);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\message.cs ===
//------------------------------------------------------------------------------
// <copyright file="Message.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;

    using System.Diagnostics;
    using System.Security;
    using System.Security.Permissions;

    using System;
    using System.Windows.Forms;


    /// <include file='doc\Message.uex' path='docs/doc[@for="Message"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Implements a Windows message.</para>
    /// </devdoc>
    [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
    public struct Message {
#if DEBUG
        static TraceSwitch AllWinMessages = new TraceSwitch("AllWinMessages", "Output every received message");
#endif

        IntPtr hWnd;
        int msg;
        IntPtr wparam;
        IntPtr lparam;
        IntPtr result;
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.HWnd"]/*' />
        /// <devdoc>
        ///    <para>Specifies the window handle of the message.</para>
        /// </devdoc>

        public IntPtr HWnd {
            get { return hWnd; }
            set { hWnd = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Msg"]/*' />
        /// <devdoc>
        ///    <para>Specifies the ID number for the message.</para>
        /// </devdoc>
        public int Msg {
            get { return msg; }
            set { msg = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.WParam"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see cref='System.Windows.Forms.Message.wparam'/> of the message.</para>
        /// </devdoc>
        public IntPtr WParam {
            get { return wparam; }
            set { wparam = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.LParam"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see cref='System.Windows.Forms.Message.lparam'/> of the message.</para>
        /// </devdoc>
        public IntPtr LParam {
            get { return lparam; }
            set { lparam = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Result"]/*' />
        /// <devdoc>
        ///    <para>Specifies the return value of the message.</para>
        /// </devdoc>
        public IntPtr Result {
             get { return result; }
             set { result = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.GetLParam"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Windows.Forms.Message.lparam'/> value, and converts the value to an object.</para>
        /// </devdoc>
        // SECUNDONE : For some reason "PtrToStructure" requires super high permission.. put this 
        //           : assert here until we can get a resolution on this.
        //
        [
        ReflectionPermission(SecurityAction.Assert, Unrestricted=true),
        SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        public object GetLParam(Type cls) {
            return Marshal.PtrToStructure(lparam, cls);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Create"]/*' />
        /// <devdoc>
        /// <para>Creates a new <see cref='System.Windows.Forms.Message'/> object.</para>
        /// </devdoc>
        public static Message Create(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
            Message m = new Message();
            m.hWnd = hWnd;
            m.msg = msg;
            m.wparam = wparam;
            m.lparam = lparam;
            m.result = IntPtr.Zero;
            
#if DEBUG
            if(AllWinMessages.TraceVerbose) {
                Debug.WriteLine(m.ToString());
            }
#endif
            return m;
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Equals"]/*' />
        public override bool Equals(object o) {
            if (!(o is Message)) {
                return false;
            }
            
            Message m = (Message)o;
            return hWnd == m.hWnd && 
                   msg == m.msg && 
                   wparam == m.wparam && 
                   lparam == m.lparam && 
                   result == m.result;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (int)hWnd << 4 | msg;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override string ToString() {
            return MessageDecoder.ToString(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\messageboxbuttons.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageBoxButtons.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum MessageBoxButtons {
        /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons.OK"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains an OK button. This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        OK               = 0x00000000,

        /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons.OKCancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains OK and Cancel buttons. This field
        ///       is
        ///       constant.
        ///    </para>
        /// </devdoc>
        OKCancel         = 0x00000001,

        /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons.AbortRetryIgnore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains Abort, Retry, and Ignore buttons.
        ///       This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        AbortRetryIgnore = 0x00000002,

        /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons.YesNoCancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains Yes, No, and Cancel buttons. This
        ///       field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        YesNoCancel      = 0x00000003,

        /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons.YesNo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains Yes and No buttons. This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        YesNo            = 0x00000004,

        /// <include file='doc\MessageBoxButtons.uex' path='docs/doc[@for="MessageBoxButtons.RetryCancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains Retry and Cancel buttons. This field
        ///       is
        ///       constant.
        ///    </para>
        /// </devdoc>
        RetryCancel      = 0x00000005,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\messageboxoptions.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageBoxOptions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    /// <include file='doc\MessageBoxOptions.uex' path='docs/doc[@for="MessageBoxOptions"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum MessageBoxOptions {
        /// <include file='doc\MessageBoxOptions.uex' path='docs/doc[@for="MessageBoxOptions.ServiceNotification"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the message box is displayed on the active desktop. 
        ///    </para>
        /// </devdoc>
        ServiceNotification = 0x00200000,

        /// <include file='doc\MessageBoxOptions.uex' path='docs/doc[@for="MessageBoxOptions.DefaultDesktopOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the message box is displayed on the active desktop. 
        ///    </para>
        /// </devdoc>
        DefaultDesktopOnly = 0x00020000,

        /// <include file='doc\MessageBoxOptions.uex' path='docs/doc[@for="MessageBoxOptions.RightAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the message box text is right-aligned.
        ///    </para>
        /// </devdoc>
        RightAlign         = 0x00080000,

        /// <include file='doc\MessageBoxOptions.uex' path='docs/doc[@for="MessageBoxOptions.RtlReading"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the message box text is displayed with Rtl reading order.
        ///    </para>
        /// </devdoc>
        RtlReading         = 0x00100000,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\messageboxicon.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageBoxIcon.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum MessageBoxIcon {
        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contain no symbols. 
        ///    </para>
        /// </devdoc>
        None         = 0,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Hand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains a
        ///       hand symbol. 
        ///    </para>
        /// </devdoc>
        Hand         = 0x00000010,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Question"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       that the message
        ///       box contains a question
        ///       mark symbol. 
        ///    </para>
        /// </devdoc>
        Question     = 0x00000020,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Exclamation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains an
        ///       exclamation symbol. 
        ///    </para>
        /// </devdoc>
        Exclamation  = 0x00000030,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Asterisk"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains an
        ///       asterisk symbol. 
        ///    </para>
        /// </devdoc>
        Asterisk     = 0x00000040,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Stop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the message box contains a hand icon. This field is
        ///       constant.
        ///    </para>
        /// </devdoc>
        Stop         = Hand,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains a
        ///       hand icon. 
        ///    </para>
        /// </devdoc>
        Error        = Hand,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Warning"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the message box contains an exclamation icon. 
        ///    </para>
        /// </devdoc>
        Warning      = Exclamation,

        /// <include file='doc\MessageBoxIcon.uex' path='docs/doc[@for="MessageBoxIcon.Information"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the
        ///       message box contains an
        ///       asterisk icon. 
        ///    </para>
        /// </devdoc>
        Information  = Asterisk,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\methodinvoker.cs ===
//------------------------------------------------------------------------------
// <copyright file="MethodInvoker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    
    /// <include file='doc\MethodInvoker.uex' path='docs/doc[@for="MethodInvoker"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='Invoke '/> event for a method.</para>
    /// </devdoc>
    public delegate void MethodInvoker();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\messageboxdefaultbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageBoxDefaultButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    /// <include file='doc\MessageBoxDefaultButton.uex' path='docs/doc[@for="MessageBoxDefaultButton"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum MessageBoxDefaultButton {
        /// <include file='doc\MessageBoxDefaultButton.uex' path='docs/doc[@for="MessageBoxDefaultButton.Button1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the first
        ///       button on the message box should be the default button. 
        ///    </para>
        /// </devdoc>
        Button1       = 0x00000000,
        /// <include file='doc\MessageBoxDefaultButton.uex' path='docs/doc[@for="MessageBoxDefaultButton.Button2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the second
        ///       button on the message box should be the default button. 
        ///    </para>
        /// </devdoc>
        Button2       = 0x00000100,

        /// <include file='doc\MessageBoxDefaultButton.uex' path='docs/doc[@for="MessageBoxDefaultButton.Button3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the third
        ///       button on the message box should be the default button. 
        ///    </para>
        /// </devdoc>
        Button3       = 0x00000200,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mousebuttons.cs ===
//------------------------------------------------------------------------------
// <copyright file="MouseButtons.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies constants that define which mouse button was pressed.
    ///    </para>
    /// </devdoc>
    [Flags]
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum MouseButtons {

        /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The left mouse button was pressed.
        ///       
        ///    </para>
        /// </devdoc>
        Left = 0x00100000,

        /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       No mouse button was pressed.
        ///       
        ///    </para>
        /// </devdoc>
        None = 0x00000000,

        /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The right mouse button was pressed.
        ///       
        ///    </para>
        /// </devdoc>
        Right = 0x00200000,

        /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons.Middle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The middle mouse button was pressed.
        ///       
        ///    </para>        
        /// </devdoc>
        Middle = 0x00400000,        
        
        /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons.XButton1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        XButton1 = 0x00800000,        
        
        /// <include file='doc\MouseButtons.uex' path='docs/doc[@for="MouseButtons.XButton2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        XButton2 = 0x01000000,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\messagedecoder.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageDecoder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Diagnostics;

    using System;
    using System.Windows.Forms;


    /// <include file='doc\MessageDecoder.uex' path='docs/doc[@for="MessageDecoder"]/*' />
    /// <devdoc>
    ///     Decodes Windows messages.  This is in a separate class from Message
    ///     so we can avoid loading it in the 99% case where we don't need it.
    /// </devdoc>
    internal sealed class MessageDecoder {

        /// <include file='doc\MessageDecoder.uex' path='docs/doc[@for="MessageDecoder.MsgToString"]/*' />
        /// <devdoc>
        ///     Returns the symbolic name of the msg value, or null if it
        ///     isn't one of the existing constants.
        /// </devdoc>
        private static string MsgToString(int msg) {
            string text;
            switch (msg) {
                case NativeMethods.WM_NULL: text = "WM_NULL"; break;
                case NativeMethods.WM_CREATE: text = "WM_CREATE"; break;
                case NativeMethods.WM_DESTROY: text = "WM_DESTROY"; break;
                case NativeMethods.WM_MOVE: text = "WM_MOVE"; break;
                case NativeMethods.WM_SIZE: text = "WM_SIZE"; break;
                case NativeMethods.WM_ACTIVATE: text = "WM_ACTIVATE"; break;
                //case NativeMethods.WA_INACTIVE: text = "WA_INACTIVE"; break;
                //case NativeMethods.WA_ACTIVE: text = "WA_ACTIVE"; break;
                //case NativeMethods.WA_CLICKACTIVE: text = "WA_CLICKACTIVE"; break;
                case NativeMethods.WM_SETFOCUS: text = "WM_SETFOCUS"; break;
                case NativeMethods.WM_KILLFOCUS: text = "WM_KILLFOCUS"; break;
                case NativeMethods.WM_ENABLE: text = "WM_ENABLE"; break;
                case NativeMethods.WM_SETREDRAW: text = "WM_SETREDRAW"; break;
                case NativeMethods.WM_SETTEXT: text = "WM_SETTEXT"; break;
                case NativeMethods.WM_GETTEXT: text = "WM_GETTEXT"; break;
                case NativeMethods.WM_GETTEXTLENGTH: text = "WM_GETTEXTLENGTH"; break;
                case NativeMethods.WM_PAINT: text = "WM_PAINT"; break;
                case NativeMethods.WM_CLOSE: text = "WM_CLOSE"; break;
                case NativeMethods.WM_QUERYENDSESSION: text = "WM_QUERYENDSESSION"; break;
                case NativeMethods.WM_QUIT: text = "WM_QUIT"; break;
                case NativeMethods.WM_QUERYOPEN: text = "WM_QUERYOPEN"; break;
                case NativeMethods.WM_ERASEBKGND: text = "WM_ERASEBKGND"; break;
                case NativeMethods.WM_SYSCOLORCHANGE: text = "WM_SYSCOLORCHANGE"; break;
                case NativeMethods.WM_ENDSESSION: text = "WM_ENDSESSION"; break;
                case NativeMethods.WM_SHOWWINDOW: text = "WM_SHOWWINDOW"; break;
                case NativeMethods.WM_WININICHANGE: text = "WM_WININICHANGE"; break;
                //case NativeMethods.WM_SETTINGCHANGE: text = "WM_SETTINGCHANGE"; break;
                case NativeMethods.WM_DEVMODECHANGE: text = "WM_DEVMODECHANGE"; break;
                case NativeMethods.WM_ACTIVATEAPP: text = "WM_ACTIVATEAPP"; break;
                case NativeMethods.WM_FONTCHANGE: text = "WM_FONTCHANGE"; break;
                case NativeMethods.WM_TIMECHANGE: text = "WM_TIMECHANGE"; break;
                case NativeMethods.WM_CANCELMODE: text = "WM_CANCELMODE"; break;
                case NativeMethods.WM_SETCURSOR: text = "WM_SETCURSOR"; break;
                case NativeMethods.WM_MOUSEACTIVATE: text = "WM_MOUSEACTIVATE"; break;
                case NativeMethods.WM_CHILDACTIVATE: text = "WM_CHILDACTIVATE"; break;
                case NativeMethods.WM_QUEUESYNC: text = "WM_QUEUESYNC"; break;
                case NativeMethods.WM_GETMINMAXINFO: text = "WM_GETMINMAXINFO"; break;
                case NativeMethods.WM_PAINTICON: text = "WM_PAINTICON"; break;
                case NativeMethods.WM_ICONERASEBKGND: text = "WM_ICONERASEBKGND"; break;
                case NativeMethods.WM_NEXTDLGCTL: text = "WM_NEXTDLGCTL"; break;
                case NativeMethods.WM_SPOOLERSTATUS: text = "WM_SPOOLERSTATUS"; break;
                case NativeMethods.WM_DRAWITEM: text = "WM_DRAWITEM"; break;
                case NativeMethods.WM_MEASUREITEM: text = "WM_MEASUREITEM"; break;
                case NativeMethods.WM_DELETEITEM: text = "WM_DELETEITEM"; break;
                case NativeMethods.WM_VKEYTOITEM: text = "WM_VKEYTOITEM"; break;
                case NativeMethods.WM_CHARTOITEM: text = "WM_CHARTOITEM"; break;
                case NativeMethods.WM_SETFONT: text = "WM_SETFONT"; break;
                case NativeMethods.WM_GETFONT: text = "WM_GETFONT"; break;
                case NativeMethods.WM_SETHOTKEY: text = "WM_SETHOTKEY"; break;
                case NativeMethods.WM_GETHOTKEY: text = "WM_GETHOTKEY"; break;
                case NativeMethods.WM_QUERYDRAGICON: text = "WM_QUERYDRAGICON"; break;
                case NativeMethods.WM_COMPAREITEM: text = "WM_COMPAREITEM"; break;
                case NativeMethods.WM_GETOBJECT: text = "WM_GETOBJECT"; break;
                case NativeMethods.WM_COMPACTING: text = "WM_COMPACTING"; break;
                case NativeMethods.WM_COMMNOTIFY: text = "WM_COMMNOTIFY"; break;
                case NativeMethods.WM_WINDOWPOSCHANGING: text = "WM_WINDOWPOSCHANGING"; break;
                case NativeMethods.WM_WINDOWPOSCHANGED: text = "WM_WINDOWPOSCHANGED"; break;
                case NativeMethods.WM_POWER: text = "WM_POWER"; break;
                case NativeMethods.WM_COPYDATA: text = "WM_COPYDATA"; break;
                case NativeMethods.WM_CANCELJOURNAL: text = "WM_CANCELJOURNAL"; break;
                case NativeMethods.WM_NOTIFY: text = "WM_NOTIFY"; break;
                case NativeMethods.WM_INPUTLANGCHANGEREQUEST: text = "WM_INPUTLANGCHANGEREQUEST"; break;
                case NativeMethods.WM_INPUTLANGCHANGE: text = "WM_INPUTLANGCHANGE"; break;
                case NativeMethods.WM_TCARD: text = "WM_TCARD"; break;
                case NativeMethods.WM_HELP: text = "WM_HELP"; break;
                case NativeMethods.WM_USERCHANGED: text = "WM_USERCHANGED"; break;
                case NativeMethods.WM_NOTIFYFORMAT: text = "WM_NOTIFYFORMAT"; break;
                case NativeMethods.WM_CONTEXTMENU: text = "WM_CONTEXTMENU"; break;
                case NativeMethods.WM_STYLECHANGING: text = "WM_STYLECHANGING"; break;
                case NativeMethods.WM_STYLECHANGED: text = "WM_STYLECHANGED"; break;
                case NativeMethods.WM_DISPLAYCHANGE: text = "WM_DISPLAYCHANGE"; break;
                case NativeMethods.WM_GETICON: text = "WM_GETICON"; break;
                case NativeMethods.WM_SETICON: text = "WM_SETICON"; break;
                case NativeMethods.WM_NCCREATE: text = "WM_NCCREATE"; break;
                case NativeMethods.WM_NCDESTROY: text = "WM_NCDESTROY"; break;
                case NativeMethods.WM_NCCALCSIZE: text = "WM_NCCALCSIZE"; break;
                case NativeMethods.WM_NCHITTEST: text = "WM_NCHITTEST"; break;
                case NativeMethods.WM_NCPAINT: text = "WM_NCPAINT"; break;
                case NativeMethods.WM_NCACTIVATE: text = "WM_NCACTIVATE"; break;
                case NativeMethods.WM_GETDLGCODE: text = "WM_GETDLGCODE"; break;
                case NativeMethods.WM_NCMOUSEMOVE: text = "WM_NCMOUSEMOVE"; break;
                case NativeMethods.WM_NCLBUTTONDOWN: text = "WM_NCLBUTTONDOWN"; break;
                case NativeMethods.WM_NCLBUTTONUP: text = "WM_NCLBUTTONUP"; break;
                case NativeMethods.WM_NCLBUTTONDBLCLK: text = "WM_NCLBUTTONDBLCLK"; break;
                case NativeMethods.WM_NCRBUTTONDOWN: text = "WM_NCRBUTTONDOWN"; break;
                case NativeMethods.WM_NCRBUTTONUP: text = "WM_NCRBUTTONUP"; break;
                case NativeMethods.WM_NCRBUTTONDBLCLK: text = "WM_NCRBUTTONDBLCLK"; break;
                case NativeMethods.WM_NCMBUTTONDOWN: text = "WM_NCMBUTTONDOWN"; break;
                case NativeMethods.WM_NCMBUTTONUP: text = "WM_NCMBUTTONUP"; break;
                case NativeMethods.WM_NCMBUTTONDBLCLK: text = "WM_NCMBUTTONDBLCLK"; break;
                //case NativeMethods.WM_KEYFIRST: text = "WM_KEYFIRST"; break;
                case NativeMethods.WM_KEYDOWN: text = "WM_KEYDOWN"; break;
                case NativeMethods.WM_KEYUP: text = "WM_KEYUP"; break;
                case NativeMethods.WM_CHAR: text = "WM_CHAR"; break;
                case NativeMethods.WM_DEADCHAR: text = "WM_DEADCHAR"; break;
                case NativeMethods.WM_SYSKEYDOWN: text = "WM_SYSKEYDOWN"; break;
                case NativeMethods.WM_SYSKEYUP: text = "WM_SYSKEYUP"; break;
                case NativeMethods.WM_SYSCHAR: text = "WM_SYSCHAR"; break;
                case NativeMethods.WM_SYSDEADCHAR: text = "WM_SYSDEADCHAR"; break;
                case NativeMethods.WM_KEYLAST: text = "WM_KEYLAST"; break;
                case NativeMethods.WM_IME_STARTCOMPOSITION: text = "WM_IME_STARTCOMPOSITION"; break;
                case NativeMethods.WM_IME_ENDCOMPOSITION: text = "WM_IME_ENDCOMPOSITION"; break;
                case NativeMethods.WM_IME_COMPOSITION: text = "WM_IME_COMPOSITION"; break;
                //case NativeMethods.WM_IME_KEYLAST: text = "WM_IME_KEYLAST"; break;
                case NativeMethods.WM_INITDIALOG: text = "WM_INITDIALOG"; break;
                case NativeMethods.WM_COMMAND: text = "WM_COMMAND"; break;
                case NativeMethods.WM_SYSCOMMAND: text = "WM_SYSCOMMAND"; break;
                case NativeMethods.WM_TIMER: text = "WM_TIMER"; break;
                case NativeMethods.WM_HSCROLL: text = "WM_HSCROLL"; break;
                case NativeMethods.WM_VSCROLL: text = "WM_VSCROLL"; break;
                case NativeMethods.WM_INITMENU: text = "WM_INITMENU"; break;
                case NativeMethods.WM_INITMENUPOPUP: text = "WM_INITMENUPOPUP"; break;
                case NativeMethods.WM_MENUSELECT: text = "WM_MENUSELECT"; break;
                case NativeMethods.WM_MENUCHAR: text = "WM_MENUCHAR"; break;
                case NativeMethods.WM_ENTERIDLE: text = "WM_ENTERIDLE"; break;
                case NativeMethods.WM_CTLCOLORMSGBOX: text = "WM_CTLCOLORMSGBOX"; break;
                case NativeMethods.WM_CTLCOLOREDIT: text = "WM_CTLCOLOREDIT"; break;
                case NativeMethods.WM_CTLCOLORLISTBOX: text = "WM_CTLCOLORLISTBOX"; break;
                case NativeMethods.WM_CTLCOLORBTN: text = "WM_CTLCOLORBTN"; break;
                case NativeMethods.WM_CTLCOLORDLG: text = "WM_CTLCOLORDLG"; break;
                case NativeMethods.WM_CTLCOLORSCROLLBAR: text = "WM_CTLCOLORSCROLLBAR"; break;
                case NativeMethods.WM_CTLCOLORSTATIC: text = "WM_CTLCOLORSTATIC"; break;
                //case NativeMethods.WM_MOUSEFIRST: text = "WM_MOUSEFIRST"; break;
                case NativeMethods.WM_MOUSEMOVE: text = "WM_MOUSEMOVE"; break;
                case NativeMethods.WM_LBUTTONDOWN: text = "WM_LBUTTONDOWN"; break;
                case NativeMethods.WM_LBUTTONUP: text = "WM_LBUTTONUP"; break;
                case NativeMethods.WM_LBUTTONDBLCLK: text = "WM_LBUTTONDBLCLK"; break;
                case NativeMethods.WM_RBUTTONDOWN: text = "WM_RBUTTONDOWN"; break;
                case NativeMethods.WM_RBUTTONUP: text = "WM_RBUTTONUP"; break;
                case NativeMethods.WM_RBUTTONDBLCLK: text = "WM_RBUTTONDBLCLK"; break;
                case NativeMethods.WM_MBUTTONDOWN: text = "WM_MBUTTONDOWN"; break;
                case NativeMethods.WM_MBUTTONUP: text = "WM_MBUTTONUP"; break;
                case NativeMethods.WM_MBUTTONDBLCLK: text = "WM_MBUTTONDBLCLK"; break;
                case NativeMethods.WM_MOUSEWHEEL: text = "WM_MOUSEWHEEL"; break;
                //case NativeMethods.WM_MOUSELAST: text = "WM_MOUSELAST"; break;
                case NativeMethods.WM_PARENTNOTIFY: text = "WM_PARENTNOTIFY"; break;
                case NativeMethods.WM_ENTERMENULOOP: text = "WM_ENTERMENULOOP"; break;
                case NativeMethods.WM_EXITMENULOOP: text = "WM_EXITMENULOOP"; break;
                case NativeMethods.WM_NEXTMENU: text = "WM_NEXTMENU"; break;
                case NativeMethods.WM_SIZING: text = "WM_SIZING"; break;
                case NativeMethods.WM_CAPTURECHANGED: text = "WM_CAPTURECHANGED"; break;
                case NativeMethods.WM_MOVING: text = "WM_MOVING"; break;
                case NativeMethods.WM_POWERBROADCAST: text = "WM_POWERBROADCAST"; break;
                case NativeMethods.WM_DEVICECHANGE: text = "WM_DEVICECHANGE"; break;
                case NativeMethods.WM_IME_SETCONTEXT: text = "WM_IME_SETCONTEXT"; break;
                case NativeMethods.WM_IME_NOTIFY: text = "WM_IME_NOTIFY"; break;
                case NativeMethods.WM_IME_CONTROL: text = "WM_IME_CONTROL"; break;
                case NativeMethods.WM_IME_COMPOSITIONFULL: text = "WM_IME_COMPOSITIONFULL"; break;
                case NativeMethods.WM_IME_SELECT: text = "WM_IME_SELECT"; break;
                case NativeMethods.WM_IME_CHAR: text = "WM_IME_CHAR"; break;
                case NativeMethods.WM_IME_KEYDOWN: text = "WM_IME_KEYDOWN"; break;
                case NativeMethods.WM_IME_KEYUP: text = "WM_IME_KEYUP"; break;
                case NativeMethods.WM_MDICREATE: text = "WM_MDICREATE"; break;
                case NativeMethods.WM_MDIDESTROY: text = "WM_MDIDESTROY"; break;
                case NativeMethods.WM_MDIACTIVATE: text = "WM_MDIACTIVATE"; break;
                case NativeMethods.WM_MDIRESTORE: text = "WM_MDIRESTORE"; break;
                case NativeMethods.WM_MDINEXT: text = "WM_MDINEXT"; break;
                case NativeMethods.WM_MDIMAXIMIZE: text = "WM_MDIMAXIMIZE"; break;
                case NativeMethods.WM_MDITILE: text = "WM_MDITILE"; break;
                case NativeMethods.WM_MDICASCADE: text = "WM_MDICASCADE"; break;
                case NativeMethods.WM_MDIICONARRANGE: text = "WM_MDIICONARRANGE"; break;
                case NativeMethods.WM_MDIGETACTIVE: text = "WM_MDIGETACTIVE"; break;
                case NativeMethods.WM_MDISETMENU: text = "WM_MDISETMENU"; break;
                case NativeMethods.WM_ENTERSIZEMOVE: text = "WM_ENTERSIZEMOVE"; break;
                case NativeMethods.WM_EXITSIZEMOVE: text = "WM_EXITSIZEMOVE"; break;
                case NativeMethods.WM_DROPFILES: text = "WM_DROPFILES"; break;
                case NativeMethods.WM_MDIREFRESHMENU: text = "WM_MDIREFRESHMENU"; break;
                case NativeMethods.WM_MOUSEHOVER: text = "WM_MOUSEHOVER"; break;
                case NativeMethods.WM_MOUSELEAVE: text = "WM_MOUSELEAVE"; break;
                case NativeMethods.WM_CUT: text = "WM_CUT"; break;
                case NativeMethods.WM_COPY: text = "WM_COPY"; break;
                case NativeMethods.WM_PASTE: text = "WM_PASTE"; break;
                case NativeMethods.WM_CLEAR: text = "WM_CLEAR"; break;
                case NativeMethods.WM_UNDO: text = "WM_UNDO"; break;
                case NativeMethods.WM_RENDERFORMAT: text = "WM_RENDERFORMAT"; break;
                case NativeMethods.WM_RENDERALLFORMATS: text = "WM_RENDERALLFORMATS"; break;
                case NativeMethods.WM_DESTROYCLIPBOARD: text = "WM_DESTROYCLIPBOARD"; break;
                case NativeMethods.WM_DRAWCLIPBOARD: text = "WM_DRAWCLIPBOARD"; break;
                case NativeMethods.WM_PAINTCLIPBOARD: text = "WM_PAINTCLIPBOARD"; break;
                case NativeMethods.WM_VSCROLLCLIPBOARD: text = "WM_VSCROLLCLIPBOARD"; break;
                case NativeMethods.WM_SIZECLIPBOARD: text = "WM_SIZECLIPBOARD"; break;
                case NativeMethods.WM_ASKCBFORMATNAME: text = "WM_ASKCBFORMATNAME"; break;
                case NativeMethods.WM_CHANGECBCHAIN: text = "WM_CHANGECBCHAIN"; break;
                case NativeMethods.WM_HSCROLLCLIPBOARD: text = "WM_HSCROLLCLIPBOARD"; break;
                case NativeMethods.WM_QUERYNEWPALETTE: text = "WM_QUERYNEWPALETTE"; break;
                case NativeMethods.WM_PALETTEISCHANGING: text = "WM_PALETTEISCHANGING"; break;
                case NativeMethods.WM_PALETTECHANGED: text = "WM_PALETTECHANGED"; break;
                case NativeMethods.WM_HOTKEY: text = "WM_HOTKEY"; break;
                case NativeMethods.WM_PRINT: text = "WM_PRINT"; break;
                case NativeMethods.WM_PRINTCLIENT: text = "WM_PRINTCLIENT"; break;
                case NativeMethods.WM_HANDHELDFIRST: text = "WM_HANDHELDFIRST"; break;
                case NativeMethods.WM_HANDHELDLAST: text = "WM_HANDHELDLAST"; break;
                case NativeMethods.WM_AFXFIRST: text = "WM_AFXFIRST"; break;
                case NativeMethods.WM_AFXLAST: text = "WM_AFXLAST"; break;
                case NativeMethods.WM_PENWINFIRST: text = "WM_PENWINFIRST"; break;
                case NativeMethods.WM_PENWINLAST: text = "WM_PENWINLAST"; break;
                case NativeMethods.WM_APP: text = "WM_APP"; break;
                case NativeMethods.WM_USER: text = "WM_USER"; break;

                case NativeMethods.WM_CTLCOLOR: text = "WM_CTLCOLOR"; break;

                    // RichEdit messages
                //case RichTextBoxConstants.WM_CONTEXTMENU: text = "WM_CONTEXTMENU"; break;

                //case RichTextBoxConstants.WM_PRINTCLIENT: text = "WM_PRINTCLIENT"; break;

                case RichTextBoxConstants.EM_GETLIMITTEXT: text = "EM_GETLIMITTEXT"; break;

                case RichTextBoxConstants.EM_POSFROMCHAR: text = "EM_POSFROMCHAR"; break;
                case RichTextBoxConstants.EM_CHARFROMPOS: text = "EM_CHARFROMPOS"; break;

                case RichTextBoxConstants.EM_SCROLLCARET: text = "EM_SCROLLCARET"; break;
                case RichTextBoxConstants.EM_CANPASTE: text = "EM_CANPASTE"; break;
                case RichTextBoxConstants.EM_DISPLAYBAND: text = "EM_DISPLAYBAND"; break;
                case RichTextBoxConstants.EM_EXGETSEL: text = "EM_EXGETSEL"; break;
                case RichTextBoxConstants.EM_EXLIMITTEXT: text = "EM_EXLIMITTEXT"; break;
                case RichTextBoxConstants.EM_EXLINEFROMCHAR: text = "EM_EXLINEFROMCHAR"; break;
                case RichTextBoxConstants.EM_EXSETSEL: text = "EM_EXSETSEL"; break;
                case RichTextBoxConstants.EM_FINDTEXT: text = "EM_FINDTEXT"; break;
                case RichTextBoxConstants.EM_FORMATRANGE: text = "EM_FORMATRANGE"; break;
                case RichTextBoxConstants.EM_GETCHARFORMAT: text = "EM_GETCHARFORMAT"; break;
                case RichTextBoxConstants.EM_GETEVENTMASK: text = "EM_GETEVENTMASK"; break;
                case RichTextBoxConstants.EM_GETOLEINTERFACE: text = "EM_GETOLEINTERFACE"; break;
                case RichTextBoxConstants.EM_GETPARAFORMAT: text = "EM_GETPARAFORMAT"; break;
                case RichTextBoxConstants.EM_GETSELTEXT: text = "EM_GETSELTEXT"; break;
                case RichTextBoxConstants.EM_HIDESELECTION: text = "EM_HIDESELECTION"; break;
                case RichTextBoxConstants.EM_PASTESPECIAL: text = "EM_PASTESPECIAL"; break;
                case RichTextBoxConstants.EM_REQUESTRESIZE: text = "EM_REQUESTRESIZE"; break;
                case RichTextBoxConstants.EM_SELECTIONTYPE: text = "EM_SELECTIONTYPE"; break;
                case RichTextBoxConstants.EM_SETBKGNDCOLOR: text = "EM_SETBKGNDCOLOR"; break;
                case RichTextBoxConstants.EM_SETCHARFORMAT: text = "EM_SETCHARFORMAT"; break;
                case RichTextBoxConstants.EM_SETEVENTMASK: text = "EM_SETEVENTMASK"; break;
                case RichTextBoxConstants.EM_SETOLECALLBACK: text = "EM_SETOLECALLBACK"; break;
                case RichTextBoxConstants.EM_SETPARAFORMAT: text = "EM_SETPARAFORMAT"; break;
                case RichTextBoxConstants.EM_SETTARGETDEVICE: text = "EM_SETTARGETDEVICE"; break;
                case RichTextBoxConstants.EM_STREAMIN: text = "EM_STREAMIN"; break;
                case RichTextBoxConstants.EM_STREAMOUT: text = "EM_STREAMOUT"; break;
                case RichTextBoxConstants.EM_GETTEXTRANGE: text = "EM_GETTEXTRANGE"; break;
                case RichTextBoxConstants.EM_FINDWORDBREAK: text = "EM_FINDWORDBREAK"; break;
                case RichTextBoxConstants.EM_SETOPTIONS: text = "EM_SETOPTIONS"; break;
                case RichTextBoxConstants.EM_GETOPTIONS: text = "EM_GETOPTIONS"; break;
                case RichTextBoxConstants.EM_FINDTEXTEX: text = "EM_FINDTEXTEX"; break;
                case RichTextBoxConstants.EM_GETWORDBREAKPROCEX: text = "EM_GETWORDBREAKPROCEX"; break;
                case RichTextBoxConstants.EM_SETWORDBREAKPROCEX: text = "EM_SETWORDBREAKPROCEX"; break;

                    // Richedit v2.0 messages
                case RichTextBoxConstants.EM_SETUNDOLIMIT: text = "EM_SETUNDOLIMIT"; break;
                case RichTextBoxConstants.EM_REDO: text = "EM_REDO"; break;
                case RichTextBoxConstants.EM_CANREDO: text = "EM_CANREDO"; break;
                case RichTextBoxConstants.EM_GETUNDONAME: text = "EM_GETUNDONAME"; break;
                case RichTextBoxConstants.EM_GETREDONAME: text = "EM_GETREDONAME"; break;
                case RichTextBoxConstants.EM_STOPGROUPTYPING: text = "EM_STOPGROUPTYPING"; break;

                case RichTextBoxConstants.EM_SETTEXTMODE: text = "EM_SETTEXTMODE"; break;
                case RichTextBoxConstants.EM_GETTEXTMODE: text = "EM_GETTEXTMODE"; break;

                case RichTextBoxConstants.EM_AUTOURLDETECT: text = "EM_AUTOURLDETECT"; break;
                case RichTextBoxConstants.EM_GETAUTOURLDETECT: text = "EM_GETAUTOURLDETECT"; break;
                case RichTextBoxConstants.EM_SETPALETTE: text = "EM_SETPALETTE"; break;
                case RichTextBoxConstants.EM_GETTEXTEX: text = "EM_GETTEXTEX"; break;
                case RichTextBoxConstants.EM_GETTEXTLENGTHEX: text = "EM_GETTEXTLENGTHEX"; break;

                    // Asia specific messages
                case RichTextBoxConstants.EM_SETPUNCTUATION: text = "EM_SETPUNCTUATION"; break;
                case RichTextBoxConstants.EM_GETPUNCTUATION: text = "EM_GETPUNCTUATION"; break;
                case RichTextBoxConstants.EM_SETWORDWRAPMODE: text = "EM_SETWORDWRAPMODE"; break;
                case RichTextBoxConstants.EM_GETWORDWRAPMODE: text = "EM_GETWORDWRAPMODE"; break;
                case RichTextBoxConstants.EM_SETIMECOLOR: text = "EM_SETIMECOLOR"; break;
                case RichTextBoxConstants.EM_GETIMECOLOR: text = "EM_GETIMECOLOR"; break;
                case RichTextBoxConstants.EM_SETIMEOPTIONS: text = "EM_SETIMEOPTIONS"; break;
                case RichTextBoxConstants.EM_GETIMEOPTIONS: text = "EM_GETIMEOPTIONS"; break;
                case RichTextBoxConstants.EM_CONVPOSITION: text = "EM_CONVPOSITION"; break;

                case RichTextBoxConstants.EM_SETLANGOPTIONS: text = "EM_SETLANGOPTIONS"; break;
                case RichTextBoxConstants.EM_GETLANGOPTIONS: text = "EM_GETLANGOPTIONS"; break;
                case RichTextBoxConstants.EM_GETIMECOMPMODE: text = "EM_GETIMECOMPMODE"; break;

                case RichTextBoxConstants.EM_FINDTEXTW: text = "EM_FINDTEXTW"; break;
                case RichTextBoxConstants.EM_FINDTEXTEXW: text = "EM_FINDTEXTEXW"; break;

                    //Rich Edit 3.0 Asia msgs
                case RichTextBoxConstants.EM_RECONVERSION: text = "EM_RECONVERSION"; break;
                case RichTextBoxConstants.EM_SETIMEMODEBIAS: text = "EM_SETIMEMODEBIAS"; break;
                case RichTextBoxConstants.EM_GETIMEMODEBIAS: text = "EM_GETIMEMODEBIAS"; break;

                    // BiDi Specific messages
                case RichTextBoxConstants.EM_SETBIDIOPTIONS: text = "EM_SETBIDIOPTIONS"; break;
                case RichTextBoxConstants.EM_GETBIDIOPTIONS: text = "EM_GETBIDIOPTIONS"; break;

                case RichTextBoxConstants.EM_SETTYPOGRAPHYOPTIONS: text = "EM_SETTYPOGRAPHYOPTIONS"; break;
                case RichTextBoxConstants.EM_GETTYPOGRAPHYOPTIONS: text = "EM_GETTYPOGRAPHYOPTIONS"; break;

                    // Extended Edit style specific messages
                case RichTextBoxConstants.EM_SETEDITSTYLE: text = "EM_SETEDITSTYLE"; break;
                case RichTextBoxConstants.EM_GETEDITSTYLE: text = "EM_GETEDITSTYLE"; break;

                default: text = null; break;
            }

            if (text == null && ((msg & NativeMethods.WM_REFLECT) == NativeMethods.WM_REFLECT)) {
                string subtext = MsgToString(msg - NativeMethods.WM_REFLECT);
                if (subtext == null) subtext = "???";
                text = "WM_REFLECT + " + subtext;
            }

            return text;
        }

        private static string Parenthesize(string input) {
            if (input == null)
                return "";
            else
                return " (" + input + ")";
        }

        public static string ToString(int msg) {
            string ID = Parenthesize(MsgToString(msg));
            return "msg=0x" + Convert.ToString(msg, 16) + ID;
        }
        
        public static string ToString(Message message) {
            return ToString(message.HWnd, message.Msg, message.WParam, message.LParam, message.Result);
        }

        public static string ToString(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam, IntPtr result) {
            string ID = Parenthesize(MsgToString(msg));

            string lDescription = "";
            if (msg == NativeMethods.WM_PARENTNOTIFY)
                lDescription = Parenthesize(MsgToString(NativeMethods.Util.LOWORD(wparam)));

            return "msg=0x" + Convert.ToString(msg, 16) + ID
            + " hwnd=0x" + Convert.ToString((long)hWnd, 16)
            + " wparam=0x" + Convert.ToString((long)wparam, 16)
            + " lparam=0x" + Convert.ToString((long)lparam, 16) + lDescription
            + " result=0x" + Convert.ToString((long)result, 16);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mouseevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="MouseEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see langword='MouseUp'/>,
    ///    <see langword='MouseDown'/>, and <see langword='MouseMove '/>
    ///    events.
    /// </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class MouseEventArgs : EventArgs {

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.button"]/*' />
        /// <devdoc>
        ///     Which button generated this event [if applicable]
        /// </devdoc>
        private readonly MouseButtons button;

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.clicks"]/*' />
        /// <devdoc>
        ///     If the user has clicked the mouse more than once, this contains the
        ///     count of clicks so far.
        /// </devdoc>
        private readonly int clicks;

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.x"]/*' />
        /// <devdoc>
        ///     The x portion of the coordinate where this event occurred.
        /// </devdoc>
        private readonly int x;

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.y"]/*' />
        /// <devdoc>
        ///     The y portion of the coordinate where this event occurred.
        /// </devdoc>
        private readonly int y;

        private readonly int delta;

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.MouseEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.MouseEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public MouseEventArgs(MouseButtons button, int clicks, int x, int y, int delta) {
            Debug.Assert((button & (MouseButtons.Left | MouseButtons.None | MouseButtons.Right | MouseButtons.Middle | MouseButtons.XButton1 | MouseButtons.XButton2)) ==
                         button, "Invalid information passed into MouseEventArgs constructor!");

            this.button = button;
            this.clicks = clicks;
            this.x = x;
            this.y = y;
            this.delta = delta;
        }

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.Button"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets which mouse button was pressed.
        ///    </para>
        /// </devdoc>
        public MouseButtons Button {
            get {
                return button;
            }
        }

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.Clicks"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       number of times the mouse
        ///       button was pressed and released.
        ///    </para>
        /// </devdoc>
        public int Clicks {
            get {
                return clicks;
            }
        }

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate
        ///       of a mouse click.
        ///    </para>
        /// </devdoc>
        public int X {
            get {
                return x;
            }
        }

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of a mouse click.
        ///    </para>
        /// </devdoc>
        public int Y {
            get {
                return y;
            }
        }

        /// <include file='doc\MouseEvent.uex' path='docs/doc[@for="MouseEventArgs.Delta"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a signed count of the number of detents the mouse wheel has rotated.
        ///    </para>
        /// </devdoc>
        public int Delta {
            get {
                return delta;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\monthcalendar.cs ===
//------------------------------------------------------------------------------
// <copyright file="MonthCalendar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Globalization;

    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using ArrayList = System.Collections.ArrayList;

    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar"]/*' />
    /// <devdoc>
    ///     This control is an encapsulateion of the Windows month calendar control.
    ///     A month calendar control implements a calendar-like user interface, that
    ///     provides the user with a very intuitive and recognizable method of entering
    ///     or selecting a date.
    ///     Users can also select which days bold.  The most efficient way to add the
    ///     bolded dates is via an array all at once.  (The below descriptions can be applied
    ///     equally to annually and monthly bolded dates as well)
    ///     The following is an example of this:
    /// <code>
    ///     MonthCalendar mc = new MonthCalendar();
    ///     //     add specific dates to bold
    ///     DateTime[] time = new DateTime[3];
    ///     time[0] = DateTime.Now;
    ///     time[1] = time[0].addDays(2);
    ///     time[2] = time[1].addDays(2);
    ///     mc.setBoldedDates(time);
    /// </code>
    ///     Removal of all bolded dates is accomplished with:
    /// <code>
    ///     mc.removeAllBoldedDates();
    /// </code>
    ///     Although less efficient, the user may need to add or remove bolded dates one at
    ///     a time.  To improve the performance of this, neither addBoldedDate nor
    ///     removeBoldedDate repaints the monthcalendar.  The user must call updateBoldedDates
    ///     to force the repaint of the bolded dates, otherwise the monthCalendar will not
    ///     paint properly.
    ///     The following is an example of this:
    /// <code>
    ///     DateTime time1 = new DateTime("3/5/98");
    ///     DateTime time2 = new DateTime("4/19/98");
    ///     mc.addBoldedDate(time1);
    ///     mc.addBoldedDate(time2);
    ///     mc.removeBoldedDate(time1);
    ///     mc.updateBoldedDates();
    /// </code>
    ///     The same applies to addition and removal of annual and monthly bolded dates.
    /// </devdoc>
    [
    DefaultProperty("SelectionRange"),
    DefaultEvent("DateChanged"),
    Designer("System.Windows.Forms.Design.MonthCalendarDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class MonthCalendar : Control {
        const long DAYS_TO_1601 = 548229; 
        const long DAYS_TO_10000 = 3615900; 
        static readonly Color DEFAULT_TITLE_BACK_COLOR = SystemColors.ActiveCaption;
        static readonly Color DEFAULT_TITLE_FORE_COLOR = SystemColors.ActiveCaptionText;
        static readonly Color DEFAULT_TRAILING_FORE_COLOR = SystemColors.GrayText;
        private const int MINIMUM_ALLOC_SIZE = 12;  // minimum size to expand the buffer by
        private const long TICKS_PER_DAY = 24*60*60*1000L*10000L; // number of 100ns ticks per day
        private const int MONTHS_IN_YEAR = 12;
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.INSERT_WIDTH_SIZE"]/*' />
        /// <devdoc>
        ///     This is the arbitrary number of pixels that the Win32 control
        ///     inserts between calendars horizontally, regardless of font.
        /// </devdoc>
        /// <internalonly/>
        private const int   INSERT_WIDTH_SIZE = 6;
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.INSERT_HEIGHT_SIZE"]/*' />
        /// <devdoc>
        ///     This is the arbitrary number of pixels that the Win32 control
        ///     inserts between calendars vertically, regardless of font.
        /// </devdoc>
        /// <internalonly/>
        private const int         INSERT_HEIGHT_SIZE = 6;       // From comctl32 MonthCalendar sources CALBORDER
        private const Day    DEFAULT_FIRST_DAY_OF_WEEK = Day.Default;
        private const int         DEFAULT_MAX_SELECTION_COUNT = 7;
        private const int         DEFAULT_SCROLL_CHANGE = 0;
        private const int         UNIQUE_DATE = 0;
        private const int         ANNUAL_DATE = 1;
        private const int         MONTHLY_DATE = 2;

        private static readonly Size           DefaultSingleMonthSize = new Size(176, 153);
        
        private const int   MaxScrollChange = 20000;
        
        private const int   ExtraPadding = 2;

        private IntPtr         mdsBuffer = IntPtr.Zero;
        private int         mdsBufferSize = 0;

        // styles
        private Color       titleBackColor = DEFAULT_TITLE_BACK_COLOR;
        private Color       titleForeColor = DEFAULT_TITLE_FORE_COLOR;
        private Color       trailingForeColor = DEFAULT_TRAILING_FORE_COLOR;
        private bool     showToday = true;
        private bool     showTodayCircle = true;
        private bool     showWeekNumbers = false;

        // properties
        private Size        dimensions = new Size(1, 1);
        private int         maxSelectionCount = DEFAULT_MAX_SELECTION_COUNT;
        private DateTime    maxDate = DateTimePicker.MaxDateTime;
        private DateTime    minDate = DateTimePicker.MinDateTime;
        private int         scrollChange = DEFAULT_SCROLL_CHANGE;
        private bool        todayDateSet = false;           // Has TodayDate been explicitly set?
        private DateTime    todayDate = DateTime.Now.Date;
        private DateTime    selectionStart;
        private DateTime    selectionEnd;
        private Day     firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK;

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.monthsOfYear"]/*' />
        /// <devdoc>
        ///     Bitmask for the annually bolded dates.  Months start on January.
        /// </devdoc>
        /// <internalonly/>
        private int[]       monthsOfYear = new int[12];
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.datesToBoldMonthly"]/*' />
        /// <devdoc>
        ///     Bitmask for the dates bolded monthly.
        /// </devdoc>
        /// <internalonly/>
        private int         datesToBoldMonthly = 0;
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.arrayOfDates"]/*' />
        /// <devdoc>
        ///     Lists are slow, so this section can be optimized.
        ///     Implementation is such that inserts are fast, removals are slow.
        /// </devdoc>
        /// <internalonly/>
        private ArrayList   arrayOfDates = new ArrayList();
        private ArrayList   annualArrayOfDates = new ArrayList(); // we have to maintain these lists too.
        private ArrayList   monthlyArrayOfDates = new ArrayList();

        // notifications
        private DateRangeEventHandler       onDateChanged;
        private DateRangeEventHandler       onDateSelected;

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.MonthCalendar"]/*' />
        /// <devdoc>
        ///     Creates a new MonthCalendar object.  Styles are the default for a
        ///     regular month calendar control.
        /// </devdoc>
        public MonthCalendar()
        : base() {

            selectionStart = todayDate;
            selectionEnd = todayDate;
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.StandardClick, false);
            
            TabStop = true;    
            
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
        }
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.AnnuallyBoldedDates"]/*' />
        /// <devdoc>
        ///     The array of DateTime objects that determines which annual days are shown
        ///     in bold.
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.MonthCalendarAnnuallyBoldedDatesDescr)
        ]
        public DateTime[] AnnuallyBoldedDates {
            get {
                DateTime[] dateTimes = new DateTime[annualArrayOfDates.Count];

                for (int i=0;i < annualArrayOfDates.Count; ++i) {
                    dateTimes[i] = (DateTime)this.annualArrayOfDates[i];
                }
                return dateTimes;
            }
            set {
                // CONSIDER: consistency would suggest this be a collection property,
                // but the fact that we need to re-create the handle with every change
                // makes it difficult to collectionize it.
                
                this.annualArrayOfDates.Clear();
                for (int i=0; i<MONTHS_IN_YEAR; ++i)
                    monthsOfYear[i] = 0;

                if (value != null && value.Length > 0) {

                    //add each boldeddate to our ArrayList...
                    for (int i = 0; i < value.Length; i++) {
                        this.annualArrayOfDates.Add(value[i]);
                    }

                    for (int i = 0; i < value.Length; ++i) {
                        monthsOfYear[value[i].Month-1] |= 0x00000001<<(value[i].Day-1);
                    }

                }
                RecreateHandle();
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRDescription(SR.MonthCalendarMonthBackColorDescr)]
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }
            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.BoldedDates"]/*' />
        /// <devdoc>
        ///     The array of DateTime objects that determines which non-recurring
        ///     specified dates are shown in bold.
        /// </devdoc>
        /*Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),*/
        [Localizable(true)]
        public DateTime[] BoldedDates {
            get {
                DateTime[] dateTimes = new DateTime[arrayOfDates.Count];

                for (int i=0;i < arrayOfDates.Count; ++i) {
                    dateTimes[i] = (DateTime)this.arrayOfDates[i];
                }
                return dateTimes;
            }
            set {
                // CONSIDER: consistency would suggest this be a collection property,
                // but the fact that we need to re-create the handle with every change
                // makes it difficult to collectionize it.
                
                this.arrayOfDates.Clear();
                if (value != null && value.Length > 0) {

                    //add each boldeddate to our ArrayList...
                    for (int i = 0; i < value.Length; i++) {
                        this.arrayOfDates.Add(value[i]);
                    }

                }
                RecreateHandle();
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.CalendarDimensions"]/*' />
        /// <devdoc>
        ///     The number of columns and rows of months that will be displayed
        ///     in the MonthCalendar control.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        SRDescription(SR.MonthCalendarDimensionsDescr)
        ]
        public Size CalendarDimensions {
            get {
                return dimensions;
            }
            set {
                if (!this.dimensions.Equals(value))
                    SetCalendarDimensions(value.Width, value.Height);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.CreateParams"]/*' />
        /// <devdoc>
        ///     This is called when creating a window.  Inheriting classes can ovveride
        ///     this to add extra functionality, but should not forget to first call
        ///     base.getCreateParams() to make sure the control continues to work
        ///     correctly.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_MONTHCAL;
                cp.Style |= NativeMethods.MCS_MULTISELECT | NativeMethods.MCS_DAYSTATE;
                if (!showToday) cp.Style |= NativeMethods.MCS_NOTODAY;
                if (!showTodayCircle) cp.Style |= NativeMethods.MCS_NOTODAYCIRCLE;
                if (showWeekNumbers) cp.Style |= NativeMethods.MCS_WEEKNUMBERS;
                return cp;
            }
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.DefaultSize"]/*' />
        protected override Size DefaultSize {
            get {
                return GetMinReqRect();
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.FirstDayOfWeek"]/*' />
        /// <devdoc>
        ///     The first day of the week for the month calendar control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(DEFAULT_FIRST_DAY_OF_WEEK),
        SRDescription(SR.MonthCalendarFirstDayOfWeekDescr)
        ]
        public Day FirstDayOfWeek {
            get {
                return firstDayOfWeek;
            }

            set {
                if (!Enum.IsDefined(typeof(Day), value)) {
                    throw new InvalidEnumArgumentException("FirstDayOfWeek", (int)value, typeof(Day));
                }

                if (value != firstDayOfWeek) {
                    firstDayOfWeek = value;
                    if (IsHandleCreated) {
                        if (value == Day.Default) {
                            RecreateHandle();
                        }
                        else {
                            SendMessage(NativeMethods.MCM_SETFIRSTDAYOFWEEK, 0, (int) value);
                        }
                    }
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRDescription(SR.MonthCalendarForeColorDescr)]
        public override Color ForeColor {
            get {
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }
            set {
                base.ForeColor = value;
            }
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.MaxDate"]/*' />
        /// <devdoc>
        ///     The maximum allowable date that can be selected.  By default, there
        ///     is no maximum date.  The maximum date is not set if max less than the
        ///     current minimum date.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.MonthCalendarMaxDateDescr)
        ]
        public DateTime MaxDate {
            get {
                return maxDate;
            }
            set {
                if (DateTime.Compare(value,maxDate) !=0) {
                    if (DateTime.Compare(value, minDate)==-1) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "MaxDate", FormatDate(value), "MinDate"));
                    }
                    maxDate = value;
                    SetRange();
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.MaxSelectionCount"]/*' />
        /// <devdoc>
        ///     The maximum number of days that can be selected in a
        ///     month calendar control.  This method does not affect the current
        ///     selection range.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DEFAULT_MAX_SELECTION_COUNT),
        SRDescription(SR.MonthCalendarMaxSelectionCountDescr)
        ]
        public int MaxSelectionCount {
            get {
                return maxSelectionCount;
            }
            set {
                if (value < 1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString("D"), "1"));
                }
            
                if (value != maxSelectionCount) {
                    if (IsHandleCreated) {
                        if ((int)SendMessage(NativeMethods.MCM_SETMAXSELCOUNT, value, 0) == 0)
                            throw new ArgumentException(SR.GetString(SR.MonthCalendarMaxSelCount, (value).ToString("D")), "value");
                    }
                    maxSelectionCount = value;
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.MinDate"]/*' />
        /// <devdoc>
        ///     The minimum allowable date that can be selected.  By default, there
        ///     is no minimum date.  The minimum date is not set if min greater than the
        ///     current maximum date.  MonthCalendar does not support dates prior to 1753.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.MonthCalendarMinDateDescr)
        ]
        public DateTime MinDate {
            get {
                return minDate;
            }
            set {
                if (DateTime.Compare(value, minDate) !=0) {
                    if (DateTime.Compare(value, maxDate)!=-1) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgument, "MinDate", FormatDate(value), "MaxDate"));
                    }

                    // If trying to set the minimum less than DateTimePicker.MinDateTime, set
                    // it to MinDateTime.
                    if (DateTime.Compare(value, DateTimePicker.MinDateTime) == -1) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "MinDate", FormatDate(value), 
                            FormatDate(DateTimePicker.MinDateTime)));
                    }

                    minDate = value;
                    SetRange();
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.MonthlyBoldedDates"]/*' />
        /// <devdoc>
        ///     The array of DateTime objects that determine which monthly days to bold.
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.MonthCalendarMonthlyBoldedDatesDescr)
        ]
        public DateTime[] MonthlyBoldedDates {
            get {
                DateTime[] dateTimes = new DateTime[monthlyArrayOfDates.Count];

                for (int i=0;i < monthlyArrayOfDates.Count; ++i) {
                    dateTimes[i] = (DateTime)this.monthlyArrayOfDates[i];
                }
                return dateTimes;
            }
            set {
                // CONSIDER: consistency would suggest this be a collection property,
                // but the fact that we need to re-create the handle with every change
                // makes it difficult to collectionize it.
                
                this.monthlyArrayOfDates.Clear();
                datesToBoldMonthly = 0;

                if (value != null && value.Length > 0) {

                    //add each boldeddate to our ArrayList...
                    for (int i = 0; i < value.Length; i++) {
                        this.monthlyArrayOfDates.Add(value[i]);
                    }

                    for (int i = 0; i < value.Length; ++i) {
                        datesToBoldMonthly |= 0x00000001<<(value[i].Day-1);
                    }

                }
                RecreateHandle();
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.Now"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private DateTime Now {
            get {
                return DateTime.Now.Date;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ScrollChange"]/*' />
        /// <devdoc>
        ///     The scroll rate for a month calendar control. The scroll
        ///     rate is the number of months that the control moves its display
        ///     when the user clicks a scroll button.  If this value is zero,
        ///     the month delta is reset to the default, which is the number of
        ///     months displayed in the control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DEFAULT_SCROLL_CHANGE),
        SRDescription(SR.MonthCalendarScrollChangeDescr)
        ]
        public int ScrollChange {
            get {
                return scrollChange;
            }
            set {
                if (scrollChange != value) {

                    if (value < 0) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "ScrollChange",
                                                                 (value).ToString("D"), "0"));
                    }
                    if (value > MaxScrollChange) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "ScrollChange",
                                                                 (value).ToString("D"), (MaxScrollChange).ToString("D")));
                    }

                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.MCM_SETMONTHDELTA, value, 0);
                    }
                    scrollChange = value;
                }
            }
        }


        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SelectionEnd"]/*' />
        /// <devdoc>
        ///    <para>Indicates the end date of the selected range of dates.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.MonthCalendarSelectionEndDescr)
        ]
        public DateTime SelectionEnd {
            get {
                return selectionEnd;
            }
            set {
                if (DateTime.Compare(selectionEnd, value) != 0) {

                    // Keep SelectionEnd within min and max
                    if (value.Ticks < minDate.Ticks) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "SelectionEnd", FormatDate(value), "MinDate"));
                    }
                    if (value.Ticks > maxDate.Ticks) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "SelectionEnd", FormatDate(value), "MaxDate"));
                    }

                    // If we've moved SelectionEnd before SelectionStart, move SelectionStart back
                    if (selectionStart.Ticks > value.Ticks) {
                        selectionStart = value;
                    }

                    // If we've moved SelectionEnd too far beyond SelectionStart, move SelectionStart forward
                    if (((value.Ticks - selectionStart.Ticks)/TICKS_PER_DAY) >= maxSelectionCount) {
                        selectionStart = value;
                        selectionStart = selectionStart.AddDays(1 - maxSelectionCount);
                    }

                    // Set the new selection range
                    SetSelRange(selectionStart, value);
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SelectionStart"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates
        ///       the start date of the selected range of dates.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.MonthCalendarSelectionStartDescr)
        ]
        public DateTime SelectionStart {
            get {
                return selectionStart;
            }
            set {
                if (DateTime.Compare(selectionStart, value) != 0) {

                    // Keep SelectionStart within min and max
                    //
                    if (value.Ticks < minDate.Ticks) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "SelectionStart", FormatDate(value), "MinDate"));
                    }
                    if (value.Ticks > maxDate.Ticks) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "SelectionStart", FormatDate(value), "MaxDate"));
                    }

                    // If we've moved SelectionStart beyond SelectionEnd, move SelectionEnd forward
                    if (selectionEnd.Ticks < value.Ticks) {
                        selectionEnd = value;
                    }

                    // If we've moved SelectionStart too far back from SelectionEnd, move SelectionEnd back
                    if (((selectionEnd.Ticks - value.Ticks)/TICKS_PER_DAY) >= maxSelectionCount) {
                        selectionEnd = value;
                        selectionEnd = selectionEnd.AddDays(maxSelectionCount - 1);
                    }

                    // Set the new selection range
                    SetSelRange(value, selectionEnd);
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SelectionRange"]/*' />
        /// <devdoc>
        ///     Retrieves the selection range for a month calendar control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.MonthCalendarSelectionRangeDescr)
        ]
        public SelectionRange SelectionRange {
            get { 
                return new SelectionRange(SelectionStart, SelectionEnd);
            }
            set {
                SetSelectionRange(value.Start, value.End);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShowToday"]/*' />
        /// <devdoc>
        ///     Indicates whether the month calendar control will display
        ///     the "today" date at the bottom of the control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.MonthCalendarShowTodayDescr)
        ]
        public bool ShowToday {
            get {
                return showToday;
            }
            set {
                if (showToday != value) {
                    showToday = value;
                    UpdateStyles();
                    AdjustSize();
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShowTodayCircle"]/*' />
        /// <devdoc>
        ///     Indicates whether the month calendar control will circle
        ///     the "today" date.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.MonthCalendarShowTodayCircleDescr)
        ]
        public bool ShowTodayCircle {
            get {
                return showTodayCircle;
            }
            set {
                if (showTodayCircle != value) {
                    showTodayCircle = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShowWeekNumbers"]/*' />
        /// <devdoc>
        ///     Indicates whether the month calendar control will the display
        ///     week numbers (1-52) to the left of each row of days.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(false),
        SRDescription(SR.MonthCalendarShowWeekNumbersDescr)
        ]
        public bool ShowWeekNumbers {
            get {
                return showWeekNumbers;
            }
            set {
                if (showWeekNumbers != value) {
                    showWeekNumbers = value;
                    UpdateStyles();
                    AdjustSize();
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SingleMonthSize"]/*' />
        /// <devdoc>
        ///     The minimum size required to display a full month.  The size
        ///     information is presented in the form of a Point, with the x
        ///     and y members representing the minimum width and height required
        ///     for the control.  The minimum required window size for a month calendar
        ///     control depends on the currently selected font.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.MonthCalendarSingleMonthSizeDescr)
        ]
        public Size SingleMonthSize {
            get {
                NativeMethods.RECT rect = new NativeMethods.RECT();
                
                if (IsHandleCreated) {
                
                    if ((int)SendMessage(NativeMethods.MCM_GETMINREQRECT, 0, ref rect) == 0)
                        throw new InvalidOperationException(SR.GetString(SR.InvalidSingleMonthSize));
                
                    return new Size(rect.right, rect.bottom);
                }
                
                return DefaultSingleMonthSize;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]        
        public override string Text {            
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.TodayDate"]/*' />
        /// <devdoc>
        ///     The date shown as "Today" in the Month Calendar control.
        ///     By default, "Today" is the current date at the time
        ///     the MonthCalendar control is created.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.MonthCalendarTodayDateDescr)
        ]
        public DateTime TodayDate {
            get {
                if (todayDateSet) return todayDate;
                if (IsHandleCreated) {
                    NativeMethods.SYSTEMTIME st = new NativeMethods.SYSTEMTIME();
                    int res = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_GETTODAY, 0, st);
                    Debug.Assert(res != 0, "MCM_GETTODAY failed");
                    return DateTimePicker.SysTimeToDateTime(st).Date;
                }
                else return Now.Date;
            }
            set {
                if (!(todayDateSet) || (DateTime.Compare(value, todayDate) != 0)) {
                    todayDate = value.Date;
                    todayDateSet = true;
                    UpdateTodayDate();
                }
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.TodayDateSet"]/*' />
        /// <devdoc>
        ///     Indicates whether or not the TodayDate property has been explicitly
        ///     set by the user. If TodayDateSet is true, TodayDate will return whatever
        ///     the user has set it to. If TodayDateSet is false, TodayDate will follow 
        ///     wall-clock time; ie. TodayDate will always equal the current system date.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.MonthCalendarTodayDateSetDescr)
        ]
        public bool TodayDateSet {
            get {
                return todayDateSet;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.TitleBackColor"]/*' />
        /// <devdoc>
        ///     The background color displayed in the month calendar's
        ///     title.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.MonthCalendarTitleBackColorDescr)
        ]
        public Color TitleBackColor {
            get {
                return titleBackColor;
            }
            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                titleBackColor = value;
                SetControlColor(NativeMethods.MCSC_TITLEBK, value);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.TitleForeColor"]/*' />
        /// <devdoc>
        ///     The foreground color used to display text within the month
        ///     calendar's title.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.MonthCalendarTitleForeColorDescr)
        ]
        public Color TitleForeColor {
            get {
                return titleForeColor;
            }
            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                titleForeColor = value;
                SetControlColor(NativeMethods.MCSC_TITLETEXT, value);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.TrailingForeColor"]/*' />
        /// <devdoc>
        ///     The color used to display the previous and following months that
        ///     appear on the current month calendar.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.MonthCalendarTrailingForeColorDescr)
        ]
        public Color TrailingForeColor {
            get {
                return trailingForeColor;
            }
            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                trailingForeColor = value;
                SetControlColor(NativeMethods.MCSC_TRAILINGTEXT, value);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.AddAnnuallyBoldedDate"]/*' />
        /// <devdoc>
        ///     Adds a day that will be bolded annually on the month calendar.
        ///     Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void AddAnnuallyBoldedDate(DateTime date) {
            annualArrayOfDates.Add(date);
            monthsOfYear[date.Month-1] |= 0x00000001<<(date.Day-1);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.AddBoldedDate"]/*' />
        /// <devdoc>
        ///     Adds a day that will be bolded on the month calendar.
        ///     Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void AddBoldedDate(DateTime date) {
            if (!this.arrayOfDates.Contains(date)) {
                this.arrayOfDates.Add(date);            
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.AddMonthlyBoldedDate"]/*' />
        /// <devdoc>
        ///     Adds a day that will be bolded monthly on the month calendar.
        ///     Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void AddMonthlyBoldedDate(DateTime date) {
            this.monthlyArrayOfDates.Add(date);
            datesToBoldMonthly |= 0x00000001<<(date.Day-1);
        }

        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.Click"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.DateChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.MonthCalendarOnDateChangedDescr)]
        public event DateRangeEventHandler DateChanged {
            add {
                onDateChanged += value;
            }
            remove {
                onDateChanged -= value;
            }
        }        


        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.DateSelected"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.MonthCalendarOnDateSelectedDescr)]
        public event DateRangeEventHandler DateSelected {
            add {
                onDateSelected += value;
            }
            remove {
                onDateSelected -= value;
            }
        }        

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnPaint"]/*' />
        /// <devdoc>
        ///     MonthCalendar Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.AdjustSize"]/*' />
        /// <devdoc>
        ///     Used to auto-size the control.  The requested number of rows and columns are
        ///     restricted by the maximum size of the parent control, hence the requested number
        ///     of rows and columns may not be what you get.
        /// </devdoc>
        /// <internalonly/>
        private void AdjustSize() {
            Size minSize = GetMinReqRect();
            Size = minSize;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.BoldDates"]/*' />
        /// <devdoc>
        ///     Event handler that bolds dates indicated by arrayOfDates
        /// </devdoc>
        /// <internalonly/>
        private void BoldDates(DateBoldEventArgs e) {
            int months = e.Size;
            e.DaysToBold = new int[months];
            SelectionRange range = GetDisplayRange(false);
            int startMonth = range.Start.Month;
            int startYear = range.Start.Year;
            int numDates = arrayOfDates.Count;
            for (int i=0; i<numDates; ++i) {
                DateTime date = (DateTime) arrayOfDates[i];
                if (DateTime.Compare(date, range.Start) >= 0 && DateTime.Compare(date, range.End) <= 0) {
                    int month = date.Month;
                    int year = date.Year;
                    int index = (year == startYear) ? month - startMonth : month + year*MONTHS_IN_YEAR - startYear*MONTHS_IN_YEAR - startMonth;
                    e.DaysToBold[index] |= (0x00000001<<(date.Day-1));
                }
            }
            //now we figure out which monthly and annual dates to bold
            --startMonth;
            for (int i=0; i<months; ++i, ++startMonth)
                e.DaysToBold[i] |= monthsOfYear[startMonth % MONTHS_IN_YEAR] | datesToBoldMonthly;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.CompareDayAndMonth"]/*' />
        /// <devdoc>
        ///     Compares only the day and month of each time.
        /// </devdoc>
        /// <internalonly/>
        private bool CompareDayAndMonth(DateTime t1, DateTime t2) {
            return(t1.Day == t2.Day && t1.Month == t2.Month);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_DATE_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.Dispose"]/*' />
        /// <devdoc>
        ///     Called to cleanup a MonthCalendar.  Normally you do not need
        ///     to call this as the garbage collector will cleanup the buffer
        ///     for you.  However, there may be times when you may want to expedite
        ///     the garbage collectors cleanup.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (mdsBuffer != IntPtr.Zero) {
                Marshal.FreeHGlobal(mdsBuffer);
                mdsBuffer = IntPtr.Zero;
            }
            if (disposing)
            {
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
            }
            base.Dispose(disposing);
        }
        
        // Return a localized string representation of the given DateTime value.
        // Used for throwing exceptions, etc.
        //                       
        private static string FormatDate(DateTime value) {
            return value.ToString("d");
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetDisplayRange"]/*' />
        /// <devdoc>
        ///     Retrieves date information that represents the low and high limits of the
        ///     control's display.
        /// </devdoc>
        public SelectionRange GetDisplayRange(bool visible) {
            if (visible)
                return GetMonthRange(NativeMethods.GMR_VISIBLE);
            else
                return GetMonthRange(NativeMethods.GMR_DAYSTATE);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetHitArea"]/*' />
        /// <devdoc>
        ///     Retrieves the enumeration value corresponding to the hit area.
        /// </devdoc>
        /// <internalonly/>
        private HitArea GetHitArea(int hit) {
            switch (hit) {
                case NativeMethods.MCHT_TITLEBK:
                    return HitArea.TitleBackground;
                case NativeMethods.MCHT_TITLEMONTH:
                    return HitArea.TitleMonth;
                case NativeMethods.MCHT_TITLEYEAR:
                    return HitArea.TitleYear;
                case NativeMethods.MCHT_TITLEBTNNEXT:
                    return HitArea.NextMonthButton;
                case NativeMethods.MCHT_TITLEBTNPREV:
                    return HitArea.PrevMonthButton;
                case NativeMethods.MCHT_CALENDARBK:
                    return HitArea.CalendarBackground;
                case NativeMethods.MCHT_CALENDARDATE:
                    return HitArea.Date;
                case NativeMethods.MCHT_CALENDARDATENEXT:
                    return HitArea.NextMonthDate;
                case NativeMethods.MCHT_CALENDARDATEPREV:
                    return HitArea.PrevMonthDate;
                case NativeMethods.MCHT_CALENDARDAY:
                    return HitArea.DayOfWeek;
                case NativeMethods.MCHT_CALENDARWEEKNUM:
                    return HitArea.WeekNumbers;
                case NativeMethods.MCHT_TODAYLINK:
                    return HitArea.TodayLink;
                default:
                    return HitArea.Nowhere;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetMinReqRect"]/*' />
        /// <devdoc>
        ///     stub for getMinReqRect (int, boolean)
        /// </devdoc>
        /// <internalonly/>
        private Size GetMinReqRect() {
            return GetMinReqRect(0, false, false);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetMinReqRect1"]/*' />
        /// <devdoc>
        ///     Used internally to get the minimum size needed to display the
        ///     MonthCalendar.  This is needed because
        ///     NativeMethods.MCM_GETMINREQRECT returns an incorrect value if showToday
        ///     is set to false.  If updateRows is true, then the
        ///     number of rows will be updated according to height.
        /// </devdoc>
        /// <internalonly/>
        private Size GetMinReqRect(int newDimensionLength, bool updateRows, bool updateCols) {
            Size minSize = SingleMonthSize;
            
            // Calculate calendar height
            //                                                
            int todayHeight = Font.Height + 4;  // The constant 4 is from the comctl32 TreeView source code
            int calendarHeight = minSize.Height;
            if (ShowToday) {
                // If ShowToday is true, then minSize already includes the height of the today string.
                // So we remove it to get the actual calendar height.
                //
                calendarHeight -= todayHeight;
            } 
            
            if (updateRows) {
                Debug.Assert(calendarHeight > INSERT_HEIGHT_SIZE, "Divide by 0");
                int nRows = (newDimensionLength - todayHeight + INSERT_HEIGHT_SIZE)/(calendarHeight + INSERT_HEIGHT_SIZE);
                this.dimensions.Height = (nRows < 1) ? 1 : nRows;
            }
            
            if (updateCols) {
                Debug.Assert(minSize.Width > INSERT_WIDTH_SIZE, "Divide by 0");
                int nCols = (newDimensionLength - ExtraPadding)/minSize.Width;
                this.dimensions.Width = (nCols < 1) ? 1 : nCols;
            }
            
            minSize.Width = (minSize.Width + INSERT_WIDTH_SIZE) * dimensions.Width - INSERT_WIDTH_SIZE;
            minSize.Height = (calendarHeight + INSERT_HEIGHT_SIZE) * dimensions.Height - INSERT_HEIGHT_SIZE + todayHeight;
            
            // If the width we've calculated is too small to fit the Today string, enlarge the width to fit
            //    
            if (IsHandleCreated) {
                int maxTodayWidth = (int)SendMessage(NativeMethods.MCM_GETMAXTODAYWIDTH, 0, 0);
                if (maxTodayWidth > minSize.Width) {
                    minSize.Width = maxTodayWidth;
                }
            }
            
            // Fudge factor
            //                                
            minSize.Width += ExtraPadding;
            minSize.Height += ExtraPadding;
            
            return minSize;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetMonthRange"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private SelectionRange GetMonthRange(int flag) {
            NativeMethods.SYSTEMTIMEARRAY sa = new NativeMethods.SYSTEMTIMEARRAY();
            SelectionRange range = new SelectionRange();
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_GETMONTHRANGE, flag, sa);

            NativeMethods.SYSTEMTIME st = new NativeMethods.SYSTEMTIME();
            st.wYear = sa.wYear1;
            st.wMonth = sa.wMonth1;
            st.wDayOfWeek = sa.wDayOfWeek1;
            st.wDay = sa.wDay1;

            range.Start = DateTimePicker.SysTimeToDateTime(st);
            st.wYear = sa.wYear2;
            st.wMonth = sa.wMonth2;
            st.wDayOfWeek = sa.wDayOfWeek2;
            st.wDay = sa.wDay2;
            range.End = DateTimePicker.SysTimeToDateTime(st);

            return range;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetPreferredHeight"]/*' />
        /// <devdoc>
        ///     Called by setBoundsCore.  If updateRows is true, then the
        ///     number of rows will be updated according to height.
        /// </devdoc>
        /// <internalonly/>
        private int GetPreferredHeight(int height, bool updateRows) {
            Size preferredSize = GetMinReqRect(height, updateRows, false);
            return preferredSize.Height;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.GetPreferredWidth"]/*' />
        /// <devdoc>
        ///     Called by setBoundsCore.  If updateCols is true, then the
        ///     number of columns will be updated according to width.
        /// </devdoc>
        /// <internalonly/>
        private int GetPreferredWidth(int width, bool updateCols) {
            Size preferredSize = GetMinReqRect(width, false, updateCols);
            return preferredSize.Width;                       
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTest"]/*' />
        /// <devdoc>
        ///     Determines which portion of a month calendar control is at
        ///     at a given point on the screen.
        /// </devdoc>
        public HitTestInfo HitTest(int x, int y) {
            NativeMethods.MCHITTESTINFO mchi = new NativeMethods.MCHITTESTINFO();
            mchi.pt_x = x;
            mchi.pt_y = y;
            mchi.cbSize = Marshal.SizeOf(typeof(NativeMethods.MCHITTESTINFO));
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_HITTEST, 0, mchi);

            // If the hit area has an associated valid date, get it
            //
            HitArea hitArea = GetHitArea(mchi.uHit);
            if (HitTestInfo.HitAreaHasValidDateTime(hitArea)) {
                NativeMethods.SYSTEMTIME sys = new NativeMethods.SYSTEMTIME();
                sys.wYear = mchi.st_wYear;
                sys.wMonth = mchi.st_wMonth;
                sys.wDayOfWeek = mchi.st_wDayOfWeek;
                sys.wDay = mchi.st_wDay;
                sys.wHour = mchi.st_wHour;
                sys.wMinute = mchi.st_wMinute;
                sys.wSecond = mchi.st_wSecond;
                sys.wMilliseconds = mchi.st_wMilliseconds;
                return new HitTestInfo(new Point(mchi.pt_x, mchi.pt_y), hitArea, DateTimePicker.SysTimeToDateTime(sys));
            }
            else {
                return new HitTestInfo(new Point(mchi.pt_x, mchi.pt_y), hitArea);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTest1"]/*' />
        /// <devdoc>
        ///     Determines which portion of a month calendar control is at
        ///     at a given point on the screen.
        /// </devdoc>
        public HitTestInfo HitTest(Point point) {
            return HitTest(point.X, point.Y);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.IsInputKey"]/*' />
        /// <devdoc>
        ///      Handling special input keys, such as pgup, pgdown, home, end, etc...
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                    return true;
            }
            return base.IsInputKey(keyData);
        }
  
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Overrides Control.OnHandleCreated()
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SetSelRange(selectionStart, selectionEnd);
            if (maxSelectionCount != DEFAULT_MAX_SELECTION_COUNT)
                SendMessage(NativeMethods.MCM_SETMAXSELCOUNT, maxSelectionCount, 0);

            AdjustSize();

            if (todayDateSet) {
                NativeMethods.SYSTEMTIME st = DateTimePicker.DateTimeToSysTime(todayDate);
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_SETTODAY, 0, st);
            }

            SetControlColor(NativeMethods.MCSC_TEXT, ForeColor);
            SetControlColor(NativeMethods.MCSC_MONTHBK, BackColor);
            SetControlColor(NativeMethods.MCSC_TITLEBK, titleBackColor);
            SetControlColor(NativeMethods.MCSC_TITLETEXT, titleForeColor);
            SetControlColor(NativeMethods.MCSC_TRAILINGTEXT, trailingForeColor);

            int firstDay;
            if (firstDayOfWeek == Day.Default) {
                firstDay = NativeMethods.LOCALE_IFIRSTDAYOFWEEK;
            }
            else {
                firstDay = (int)firstDayOfWeek;
            }
            SendMessage(NativeMethods.MCM_SETFIRSTDAYOFWEEK, 0, firstDay);
            
            SetRange();
            if (scrollChange != DEFAULT_SCROLL_CHANGE)
                SendMessage(NativeMethods.MCM_SETMONTHDELTA, scrollChange, 0);                            
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnDateChanged"]/*' />
        /// <devdoc>
        ///     Fires the event indicating that the currently selected date
        ///     or range of dates has changed.
        /// </devdoc>
        protected virtual void OnDateChanged(DateRangeEventArgs drevent) {
            if (onDateChanged != null) {
                onDateChanged(this, drevent);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnDateSelected"]/*' />
        /// <devdoc>
        ///     Fires the event indicating that the user has changed his\her selection.
        /// </devdoc>
        protected virtual void OnDateSelected(DateRangeEventArgs drevent) {
            if (onDateSelected != null) {
                onDateSelected(this, drevent);
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            AdjustSize();
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnForeColorChanged(EventArgs e) {
            base.OnForeColorChanged(e);
            SetControlColor(NativeMethods.MCSC_TEXT, ForeColor);
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBackColorChanged(EventArgs e) {
            base.OnBackColorChanged(e);
            SetControlColor(NativeMethods.MCSC_MONTHBK, BackColor);
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RemoveAllAnnuallyBoldedDates"]/*' />
        /// <devdoc>
        ///     Removes all annually bolded days.  Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void RemoveAllAnnuallyBoldedDates() {
            this.annualArrayOfDates.Clear();
            for (int i=0; i<MONTHS_IN_YEAR; ++i)
                monthsOfYear[i] = 0;
        }


        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RemoveAllBoldedDates"]/*' />
        /// <devdoc>
        ///     Removes all the bolded days.  Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void RemoveAllBoldedDates() {
            this.arrayOfDates.Clear();
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RemoveAllMonthlyBoldedDates"]/*' />
        /// <devdoc>
        ///     Removes all monthly bolded days.  Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void RemoveAllMonthlyBoldedDates() {
            this.monthlyArrayOfDates.Clear();
            datesToBoldMonthly = 0;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RemoveAnnuallyBoldedDate"]/*' />
        /// <devdoc>
        ///     Removes an annually bolded date.  If the date is not found in the
        ///     bolded date list, then no action is taken.  If date occurs more than
        ///     once in the bolded date list, then only the first date is removed.  When
        ///     comparing dates, only the day and month are used. Be sure to call
        ///     updateBoldedDates afterwards.
        /// </devdoc>
        public void RemoveAnnuallyBoldedDate(DateTime date) {
            int length = annualArrayOfDates.Count;
            int i=0;
            for (; i<length; ++i) {
                if (CompareDayAndMonth((DateTime) annualArrayOfDates[i], date)) {
                    annualArrayOfDates.RemoveAt(i);
                    break;
                }
            }
            --length;
            for (int j=i; j<length; ++j) {
                if (CompareDayAndMonth((DateTime) annualArrayOfDates[j], date)) {
                    return;
                }
            }
            monthsOfYear[date.Month-1] &= ~(0x00000001<<(date.Day-1));
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RemoveBoldedDate"]/*' />
        /// <devdoc>
        ///     Removes a bolded date.  If the date is not found in the
        ///     bolded date list, then no action is taken.  If date occurs more than
        ///     once in the bolded date list, then only the first date is removed.
        ///     Be sure to call updateBoldedDates() afterwards.
        /// </devdoc>
        public void RemoveBoldedDate(DateTime date) {
            int length = arrayOfDates.Count;
            for (int i=0; i<length; ++i) {
                if (DateTime.Compare( ((DateTime)arrayOfDates[i]).Date, date.Date) == 0) {
                    arrayOfDates.RemoveAt(i);
                    Invalidate();
                    return;
                }
            }            
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RemoveMonthlyBoldedDate"]/*' />
        /// <devdoc>
        ///     Removes a monthly bolded date.  If the date is not found in the
        ///     bolded date list, then no action is taken.  If date occurs more than
        ///     once in the bolded date list, then only the first date is removed.  When
        ///     comparing dates, only the day and month are used.  Be sure to call
        ///     updateBoldedDates afterwards.
        /// </devdoc>
        public void RemoveMonthlyBoldedDate(DateTime date) {
            int length = monthlyArrayOfDates.Count;
            int i=0;
            for (; i<length; ++i) {
                if (CompareDayAndMonth((DateTime) monthlyArrayOfDates[i], date)) {
                    monthlyArrayOfDates.RemoveAt(i);
                    break;
                }
            }
            --length;
            for (int j=i; j<length; ++j) {
                if (CompareDayAndMonth((DateTime) monthlyArrayOfDates[j], date)) {
                    return;
                }
            }
            datesToBoldMonthly &= ~(0x00000001<<(date.Day-1));
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ResetMaxDate"]/*' />
        /// <devdoc>
        ///     Resets the maximum selectable date.  By default value, there is no
        ///     upper limit.
        /// </devdoc>
        private void ResetMaxDate() {
            MaxDate = DateTimePicker.MaxDateTime;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ResetMinDate"]/*' />
        /// <devdoc>
        ///     Resets the minimum selectable date.  By default value, there is no
        ///     lower limit.
        /// </devdoc>
        private void ResetMinDate() {
            MinDate = DateTimePicker.MinDateTime;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ResetSelectionRange"]/*' />
        /// <devdoc>
        ///     Resets the limits of the selection range.  By default value, the upper
        ///     and lower limit is the current date.
        /// </devdoc>
        private void ResetSelectionRange() {
            SetSelectionRange(Now, Now);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ResetTodayDate"]/*' />
        /// <devdoc>
        ///     Resets the "today"'s date.  By default value, "today" is the
        ///     current date (and is automatically updated when the clock crosses
        ///     over to the next day).
        ///     If you set the today date yourself (using the TodayDate property)
        ///     the control will no longer automatically update the current day
        ///     for you. To re-enable this behavior, ResetTodayDate() is used.
        /// </devdoc>
        private void ResetTodayDate() {
            todayDateSet = false;
            UpdateTodayDate();
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.RequestBuffer"]/*' />
        /// <devdoc>
        ///     reqSize = # elements in int[] array
        ///
        ///     The size argument should be greater than 0.
        ///     Because of the nature of MonthCalendar, we can expect that
        ///     the requested size will not be ridiculously large, hence
        ///     it is not necessary to decrease the size of an allocated
        ///     block if the new requested size is smaller.
        /// </devdoc>
        /// <internalonly/>
        private IntPtr RequestBuffer(int reqSize) {
            Debug.Assert(reqSize > 0, "Requesting a ridiculously small buffer");
            int intSize = 4;
            // if the current buffer size is insufficient...
            if (reqSize * intSize > mdsBufferSize) {
                // free and expand the buffer,
                if (mdsBuffer != IntPtr.Zero) {
                    Marshal.FreeHGlobal(mdsBuffer);
                    mdsBuffer = IntPtr.Zero;
                }

                // Round up to the nearest multiple of MINIMUM_ALLOC_SIZE
                float quotient = (float) (reqSize-1) / MINIMUM_ALLOC_SIZE;
                int actualSize = ((int) (quotient+1)) * MINIMUM_ALLOC_SIZE;
                Debug.Assert(actualSize >= reqSize, "Tried to round up, but got it wrong");

                mdsBufferSize = actualSize * intSize; 
                mdsBuffer = Marshal.AllocHGlobal(mdsBufferSize);
                return mdsBuffer;
            }
            return mdsBuffer;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Overrides Control.SetBoundsCore to enforce auto-sizing.
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            Rectangle oldBounds = Bounds;
            Size max = SystemInformation.MaxWindowTrackSize;

            if (width != oldBounds.Width) {
                if (width > max.Width)
                    width = max.Width;
                width = GetPreferredWidth(width, true);
            }
            if (height != oldBounds.Height) {
                if (height > max.Height)
                    height = max.Height;
                height = GetPreferredHeight(height, true);
            }
            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetControlColor"]/*' />
        /// <devdoc>
        ///     If the handle has been created, this applies the color to the control
        /// </devdoc>
        /// <internalonly/>
        private void SetControlColor(int colorIndex, Color value) {
            if (IsHandleCreated) {
                SendMessage(NativeMethods.MCM_SETCOLOR, colorIndex, ColorTranslator.ToWin32(value));
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetRange"]/*' />
        /// <devdoc>
        ///     Updates the window handle with the min/max ranges if it has been
        ///     created.
        /// </devdoc>
        /// <internalonly/>
        private void SetRange() {

            // Keep selection range within minDate and maxDate
            if (selectionStart < minDate) {
                selectionStart = minDate;
            }
            if (selectionStart > maxDate) {
                selectionStart = maxDate;
            }
            if (selectionEnd < minDate) {
                selectionEnd = minDate;
            }
            if (selectionEnd > maxDate) {
                selectionEnd = maxDate;
            }
            SetSelRange(selectionStart, selectionEnd);

            // Updated the calendar range
            //
            if (IsHandleCreated) {
                int flag = 0;

                NativeMethods.SYSTEMTIMEARRAY sa = new NativeMethods.SYSTEMTIMEARRAY();
                flag |= NativeMethods.GDTR_MIN | NativeMethods.GDTR_MAX;
                NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(minDate);
                sa.wYear1 = sys.wYear;
                sa.wMonth1 = sys.wMonth;
                sa.wDayOfWeek1 = sys.wDayOfWeek;
                sa.wDay1 = sys.wDay;
                sys = DateTimePicker.DateTimeToSysTime(maxDate);
                sa.wYear2 = sys.wYear;
                sa.wMonth2 = sys.wMonth;
                sa.wDayOfWeek2 = sys.wDayOfWeek;
                sa.wDay2 = sys.wDay;

                if ((int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_SETRANGE, flag, sa) == 0)
                    throw new InvalidOperationException(SR.GetString(SR.MonthCalendarRange, minDate.ToShortDateString(), maxDate.ToShortDateString()));
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetCalendarDimensions"]/*' />
        /// <devdoc>
        ///     Sets the number of columns and rows to display.
        /// </devdoc>
        public void SetCalendarDimensions(int x, int y) {
            if (x < 1 || y < 1) {
                throw new ArgumentException(SR.GetString(SR.MonthCalendarInvalidDimensions, (x).ToString("D"), (y).ToString("D")));
            }

            // MonthCalendar limits the dimensions to x * y <= 12
            // i.e. a maximum of twelve months can be displayed at a time
            // The following code emulates what is done inside monthcalendar (in comctl32.dll):
            // The dimensions are gradually reduced until the inequality above holds.
            //
            while (x * y > 12) {
                if (x > y) {
                    x--;
                }
                else {
                    y--;
                }
            }

            if (dimensions.Width != x || dimensions.Height != y) {
                this.dimensions.Width = x;
                this.dimensions.Height = y;
                AdjustSize();
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetDate"]/*' />
        /// <devdoc>
        ///     Sets date as the current selected date.  The start and begin of
        ///     the selection range will both be equal to date.
        /// </devdoc>
        public void SetDate(DateTime date) {
        
            if (date.Ticks < minDate.Ticks) {
                throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "date", FormatDate(date), "MinDate"));
            }
            if (date.Ticks > maxDate.Ticks) {
                throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "date", FormatDate(date), "MaxDate"));
            }
        
            SetSelectionRange(date, date);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetSelectionRange"]/*' />
        /// <devdoc>
        ///     Sets the selection for a month calendar control to a given date range.
        ///     The selection range will not be set if the selection range exceeds the
        ///     maximum selection count.
        /// </devdoc>
        public void SetSelectionRange(DateTime date1, DateTime date2) {

            // Keep the dates within the min and max dates
            if (date1.Ticks < minDate.Ticks) {
                throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "SelectionStart", FormatDate(date1), "MinDate"));
            }
            if (date1.Ticks > maxDate.Ticks) {
                throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "SelectionEnd", FormatDate(date1), "MaxDate"));
            }
            if (date2.Ticks < minDate.Ticks) {
                throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "SelectionStart", FormatDate(date2), "MinDate"));
            }
            if (date2.Ticks > maxDate.Ticks) {
                throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "SelectionEnd", FormatDate(date2), "MaxDate"));
            }

            // Swap the dates if they're the wrong way around
            //
            if (date1.Ticks > date2.Ticks) {
                date2 = date1;
            }

            // If the range exceeds maxSelectionCount, compare with the previous range and adjust whichever
            // limit hasn't changed.
            //
            if ((date2.Ticks - date1.Ticks)/TICKS_PER_DAY >= maxSelectionCount) {
            
                if (date1.Ticks == selectionStart.Ticks) {
                    // Bring start date forward
                    //
                    date1 = date2.AddDays(1 - maxSelectionCount);
                }
                else {
                    // Bring end date back
                    //
                    date2 = date1.AddDays(maxSelectionCount - 1);
                }
            }

            // Set the range
            SetSelRange(date1, date2);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.SetSelRange"]/*' />
        /// <devdoc>
        ///     Upper must be greater than Lower
        /// </devdoc>
        /// <internalonly/>
        private void SetSelRange(DateTime lower, DateTime upper) {

            Debug.Assert(lower.Ticks <= upper.Ticks, "lower must be less than upper");

            bool changed = false;
            if (selectionStart != lower || selectionEnd != upper) {
                changed = true;
                selectionStart = lower;
                selectionEnd = upper;
            }

            // always set the value on the control, to ensure that
            // it is up to date.
            //
            if (IsHandleCreated) {
                NativeMethods.SYSTEMTIMEARRAY sa = new NativeMethods.SYSTEMTIMEARRAY();

                NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(lower);
                sa.wYear1 = sys.wYear;
                sa.wMonth1 = sys.wMonth;
                sa.wDayOfWeek1 = sys.wDayOfWeek;
                sa.wDay1 = sys.wDay;
                sys = DateTimePicker.DateTimeToSysTime(upper);
                sa.wYear2 = sys.wYear;
                sa.wMonth2 = sys.wMonth;
                sa.wDayOfWeek2 = sys.wDayOfWeek;
                sa.wDay2 = sys.wDay;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_SETSELRANGE , 0, sa);
            }
            
            if (changed) {
                OnDateChanged(new DateRangeEventArgs(lower, upper));
            }
        }

        private bool ShouldSerializeAnnuallyBoldedDates() {
            return annualArrayOfDates.Count > 0;
        }
        
        private bool ShouldSerializeBoldedDates() {
            return arrayOfDates.Count > 0;
        }

        private bool ShouldSerializeCalendarDimensions() {
            return !dimensions.Equals(new Size(1, 1));
        }
        
        private bool ShouldSerializeTrailingForeColor() {
            return !TrailingForeColor.Equals(DEFAULT_TRAILING_FORE_COLOR);
        }

        private bool ShouldSerializeTitleForeColor() {
            return !TitleForeColor.Equals(DEFAULT_TITLE_FORE_COLOR);
        }

        private bool ShouldSerializeTitleBackColor() {
            return !TitleBackColor.Equals(DEFAULT_TITLE_BACK_COLOR);
        }

        private bool ShouldSerializeMonthlyBoldedDates() {
            return monthlyArrayOfDates.Count > 0;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShouldSerializeMaxDate"]/*' />
        /// <devdoc>
        ///     Retrieves true if the maxDate should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeMaxDate() {
            return(maxDate != DateTimePicker.MaxDateTime);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShouldSerializeMinDate"]/*' />
        /// <devdoc>
        ///     Retrieves true if the minDate should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeMinDate() {
            return(minDate != DateTimePicker.MinDateTime);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShouldSerializeSelectionRange"]/*' />
        /// <devdoc>
        ///     Retrieves true if the selectionRange should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeSelectionRange() {
            return !DateTime.Equals(selectionEnd, selectionStart);
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ShouldSerializeTodayDate"]/*' />
        /// <devdoc>
        ///     Retrieves true if the todayDate should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeTodayDate() {
            return todayDateSet;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", " + SelectionRange.ToString();
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.UpdateBoldedDates"]/*' />
        /// <devdoc>
        ///     Forces month calendar to display the current set of bolded dates.
        /// </devdoc>
        public void UpdateBoldedDates() {
            RecreateHandle();
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.UpdateTodayDate"]/*' />
        /// <devdoc>
        ///     Updates the current setting for "TODAY" in the MonthCalendar control
        ///     If the today date is set, the control will be set to that. Otherwise,
        ///     it will be set to null (running clock mode - the today date will be
        ///     automatically updated).
        /// </devdoc>
        private void UpdateTodayDate() {
            if (IsHandleCreated) {
                NativeMethods.SYSTEMTIME st = null;
                if (todayDateSet) {
                    st = DateTimePicker.DateTimeToSysTime(todayDate);
                }
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.MCM_SETTODAY, 0, st);
            }
        }
        
        private void UserPreferenceChanged(object sender, UserPreferenceChangedEventArgs pref) {
            if (pref.Category == UserPreferenceCategory.Locale) {
                // We need to recreate the monthcalendar handle when the locale changes, because
                // the day names etc. are only updated on a handle recreate (comctl32 limitation).
                //
                RecreateHandle();
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.WmDateChanged"]/*' />
        /// <devdoc>
        ///     Handles the MCN_SELCHANGE notification
        /// </devdoc>
        /// <internalonly/>
        private void WmDateChanged(ref Message m) {
            NativeMethods.NMSELCHANGE nmmcsc = (NativeMethods.NMSELCHANGE)m.GetLParam(typeof(NativeMethods.NMSELCHANGE));
            DateTime start = selectionStart = DateTimePicker.SysTimeToDateTime(nmmcsc.stSelStart);
            DateTime end = selectionEnd = DateTimePicker.SysTimeToDateTime(nmmcsc.stSelEnd);
            //subhag
            if (start.Ticks < minDate.Ticks || end.Ticks < minDate.Ticks) 
                SetSelRange(minDate,minDate);
            else if (start.Ticks > maxDate.Ticks || end.Ticks > maxDate.Ticks)
                SetSelRange(maxDate,maxDate);
            //end subhag
            OnDateChanged(new DateRangeEventArgs(start, end));
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.WmDateBold"]/*' />
        /// <devdoc>
        ///     Handles the MCN_GETDAYSTATE notification
        /// </devdoc>
        /// <internalonly/>
        private void WmDateBold(ref Message m) {
            NativeMethods.NMDAYSTATE nmmcds = (NativeMethods.NMDAYSTATE)m.GetLParam(typeof(NativeMethods.NMDAYSTATE));
            DateTime start = DateTimePicker.SysTimeToDateTime(nmmcds.stStart);
            DateBoldEventArgs boldEvent = new DateBoldEventArgs(start, nmmcds.cDayState);
            BoldDates(boldEvent);
            mdsBuffer = RequestBuffer(boldEvent.Size);
            // copy boldEvent into mdsBuffer
            Marshal.Copy(boldEvent.DaysToBold, 0, mdsBuffer, boldEvent.Size);
            // now we replug DateBoldEventArgs info into NMDAYSTATE
            nmmcds.prgDayState = mdsBuffer;
            Marshal.StructureToPtr(nmmcds, m.LParam, true);
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.WmDateSelected"]/*' />
        /// <devdoc>
        ///     Handles the MCN_SELECT notification
        /// </devdoc>
        /// <internalonly/>
        private void WmDateSelected(ref Message m) {
            NativeMethods.NMSELCHANGE nmmcsc = (NativeMethods.NMSELCHANGE)m.GetLParam(typeof(NativeMethods.NMSELCHANGE));
            DateTime start = selectionStart = DateTimePicker.SysTimeToDateTime(nmmcsc.stSelStart);
            DateTime end = selectionEnd = DateTimePicker.SysTimeToDateTime(nmmcsc.stSelEnd);
            
            //subhag
            if (start.Ticks < minDate.Ticks || end.Ticks < minDate.Ticks) 
                SetSelRange(minDate,minDate);
            else if (start.Ticks > maxDate.Ticks || end.Ticks > maxDate.Ticks)
                SetSelRange(maxDate,maxDate);
            
            //end subhag
            OnDateSelected(new DateRangeEventArgs(start, end));
            
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.WmGetDlgCode"]/*' />
        /// <devdoc>
        ///     Handles the WM_GETDLGCODE message
        /// </devdoc>
        /// <internalonly/>
        private void WmGetDlgCode(ref Message m) {
            // The MonthCalendar does its own handling of arrow keys
            m.Result = (IntPtr)NativeMethods.DLGC_WANTARROWS;
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.WmReflectCommand"]/*' />
        /// <devdoc>
        ///     Handles the WM_COMMAND messages reflected from the parent control.
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectCommand(ref Message m) {
            if (m.HWnd == Handle) {
                NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR));
                switch (nmhdr.code) {
                    case NativeMethods.MCN_SELECT:
                        WmDateSelected(ref m);
                        break;
                    case NativeMethods.MCN_SELCHANGE:
                        WmDateChanged(ref m);
                        break;
                    case NativeMethods.MCN_GETDAYSTATE:
                        WmDateBold(ref m);
                        break;
                }
            }
        }
        
        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.WndProc"]/*' />
        /// <devdoc>
        ///     Overrided wndProc
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_LBUTTONDOWN:
                    FocusInternal();
                    if (!ValidationCancelled) {
                        base.WndProc(ref m);
                    }
                    break;
                case NativeMethods.WM_GETDLGCODE:
                    WmGetDlgCode(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    WmReflectCommand(ref m);
                    base.WndProc(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo"]/*' />
        /// <devdoc>
        ///     HitTestInfo objects are returned by MonthCalendar in response to the hitTest method.
        ///     HitTestInfo is for informational purposes only; the user should not construct these objects, and
        ///     cannot modify any of the members.
        /// </devdoc>
        public sealed class HitTestInfo {
            readonly Point       point;
            readonly HitArea     hitArea;
            readonly DateTime    time;

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo.HitTestInfo"]/*' />
            /// <devdoc>
            /// </devdoc>
            /// <internalonly/>
            internal HitTestInfo(Point pt, HitArea area, DateTime time) {
                this.point = pt;
                this.hitArea = area;
                this.time = time;
            }

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo.HitTestInfo1"]/*' />
            /// <devdoc>
            ///      This constructor is used when the DateTime member is invalid.
            /// </devdoc>
            /// <internalonly/>
            internal HitTestInfo(Point pt, HitArea area) {
                this.point = pt;
                this.hitArea = area;
            }

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo.Point"]/*' />
            /// <devdoc>
            ///     The point that was hit-tested
            /// </devdoc>
            public Point Point { 
                get { return point; }
            }

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo.HitArea"]/*' />
            /// <devdoc>
            ///     Output member that receives an enumeration value from System.Windows.Forms.MonthCalendar.HitArea
            ///     representing the result of the hit-test operation.
            /// </devdoc>
            public HitArea HitArea {
                get { return hitArea; }
            }

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo.Time"]/*' />
            /// <devdoc>
            ///     The time information specific to the location that was hit-tested.  This value
            ///     will only be valid at certain values of hitArea.
            /// </devdoc>
            public DateTime Time {
                get { return time; }
            }

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="MonthCalendar.HitTestInfo.HitAreaHasValidDateTime"]/*' />
            /// <devdoc>
            ///      Determines whether a given HitArea should have a corresponding valid DateTime
            /// </devdoc>
            /// <internalonly/>
            internal static bool HitAreaHasValidDateTime(HitArea hitArea) {
                switch (hitArea) {
                    case HitArea.Date:
                        //case HitArea.DayOfWeek:   comCtl does not provide a valid date
                    case HitArea.WeekNumbers:
                        return true;
                }
                return false;
            }
        }

        /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea"]/*' />
        /// <devdoc>
        /// This enumeration has specific areas of the MonthCalendar control as its enumerated values.
        /// The hitArea member of System.Windows.Forms.Win32.HitTestInfo will be one of these enumerated values, and
        /// indicates which portion of a month calendar is under a specific point.
        /// </devdoc>
        public enum HitArea {
            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.Nowhere"]/*' />
            /// <devdoc>
            /// The given point was not on the month calendar control, or it was in an inactive portion of the control.
            /// </devdoc>
            Nowhere = 0,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.TitleBackground"]/*' />
            /// <devdoc>
            /// The given point was over the background of a month's title
            /// </devdoc>
            TitleBackground = 1,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.TitleMonth"]/*' />
            /// <devdoc>
            /// The given point was in a month's title bar, over a month name
            /// </devdoc>
            TitleMonth = 2,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.TitleYear"]/*' />
            /// <devdoc>
            /// The given point was in a month's title bar, over the year value
            /// </devdoc>
            TitleYear = 3,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.NextMonthButton"]/*' />
            /// <devdoc>
            /// The given point was over the button at the top right corner of the control.
            /// If the user clicks here, the month calendar will scroll its display to the next
            /// month or set of months
            /// </devdoc>
            NextMonthButton = 4,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.PrevMonthButton"]/*' />
            /// <devdoc>
            /// The given point was over the button at the top left corner of the control. If the
            /// user clicks here, the month calendar will scroll its display to the previous month
            /// or set of months
            /// </devdoc>
            PrevMonthButton = 5,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.CalendarBackground"]/*' />
            /// <devdoc>
            /// The given point was in the calendar's background
            /// </devdoc>
            CalendarBackground = 6,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.Date"]/*' />
            /// <devdoc>
            /// The given point was on a particular date within the calendar, and the time member of
            /// HitTestInfo will be set to the date at the given point.
            /// </devdoc>
            Date = 7,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.NextMonthDate"]/*' />
            /// <devdoc>
            /// The given point was over a date from the next month (partially displayed at the end of
            /// the currently displayed month). If the user clicks here, the month calendar will scroll
            /// its display to the next month or set of months.
            /// </devdoc>
            NextMonthDate = 8,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.PrevMonthDate"]/*' />
            /// <devdoc>
            /// The given point was over a date from the previous month (partially displayed at the end
            /// of the currently displayed month). If the user clicks here, the month calendar will scroll
            /// its display to the previous month or set of months.
            /// </devdoc>
            PrevMonthDate = 9,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.DayOfWeek"]/*' />
            /// <devdoc>
            /// The given point was over a day abbreviation ("Fri", for example). The time member
            /// of HitTestInfo will be set to the corresponding date on the top row.
            /// </devdoc>
            DayOfWeek = 10,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.WeekNumbers"]/*' />
            /// <devdoc>
            /// The given point was over a week number.  This will only occur if the showWeekNumbers
            /// property of MonthCalendar is enabled.  The time member of HitTestInfo will be set to
            /// the corresponding date in the leftmost column.
            /// </devdoc>
            WeekNumbers = 11,

            /// <include file='doc\MonthCalendar.uex' path='docs/doc[@for="HitArea.TodayLink"]/*' />
            /// <devdoc>
            /// The given point was on the "today" link at the bottom of the month calendar control
            /// </devdoc>
            TodayLink = 12,
        }

    } // end class MonthCalendar
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\mouseeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="MouseEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\MouseEventHandler.uex' path='docs/doc[@for="MouseEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the
    ///    <see langword='MouseDown'/>, <see langword='MouseUp'/>, or <see langword='MouseMove '/>event of a form, control, or other component.
    ///    </para>
    /// </devdoc>
    public delegate void MouseEventHandler(object sender, MouseEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\navigateevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="NavigateEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;

    /// <include file='doc\NavigateEvent.uex' path='docs/doc[@for="NavigateEventArgs"]/*' />
    /// <devdoc>
    ///
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class NavigateEventArgs : EventArgs {
        private bool isForward = true;

        /// <include file='doc\NavigateEvent.uex' path='docs/doc[@for="NavigateEventArgs.Forward"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Forward {
            get {
                return isForward;
            }
        }

        /// <include file='doc\NavigateEvent.uex' path='docs/doc[@for="NavigateEventArgs.NavigateEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public NavigateEventArgs(bool isForward) {
            this.isForward = isForward;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\nodelabeleditevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="NodeLabelEditEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\NodeLabelEditEvent.uex' path='docs/doc[@for="NodeLabelEditEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.TreeView.OnBeforeLabelEdit'/>
    ///       or <see cref='System.Windows.Forms.TreeView.OnAfterLabelEdit'/> event.
    ///    </para>
    /// </devdoc>
    public class NodeLabelEditEventArgs : EventArgs {
        private readonly string label;
        private readonly TreeNode node;
        private bool cancelEdit = false;

        /// <include file='doc\NodeLabelEditEvent.uex' path='docs/doc[@for="NodeLabelEditEventArgs.NodeLabelEditEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public NodeLabelEditEventArgs(TreeNode node) {
            this.node = node;
            this.label = null;
        }

        /// <include file='doc\NodeLabelEditEvent.uex' path='docs/doc[@for="NodeLabelEditEventArgs.NodeLabelEditEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public NodeLabelEditEventArgs(TreeNode node, string label) {
            this.node = node;
            this.label = label;
        }

        /// <include file='doc\NodeLabelEditEvent.uex' path='docs/doc[@for="NodeLabelEditEventArgs.CancelEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool CancelEdit {
            get {
                return cancelEdit;
            }
            set {
                cancelEdit = value;
            }
        }

        /// <include file='doc\NodeLabelEditEvent.uex' path='docs/doc[@for="NodeLabelEditEventArgs.Label"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Label {
            get {
                return label;
            }
        }

        /// <include file='doc\NodeLabelEditEvent.uex' path='docs/doc[@for="NodeLabelEditEventArgs.Node"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeNode Node {
            get {
                return node;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\navigateeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="NavigateEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
        
    /// <include file='doc\NavigateEventHandler.uex' path='docs/doc[@for="NavigateEventHandler"]/*' />
    /// <devdoc>
    ///      
    /// </devdoc>
    public delegate void NavigateEventHandler(object sender, NavigateEventArgs ne);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\openfiledialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="OpenFileDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using CodeAccessPermission = System.Security.CodeAccessPermission;
    using System.Security.Permissions;
    using System.IO;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a common dialog box
    ///       that displays the control that allows the user to open a file. This class
    ///       cannot be inherited.
    ///    </para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.OpenFileDialogDesigner, " + AssemblyRef.SystemDesign)
    ]
    public sealed class OpenFileDialog : FileDialog {

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.CheckFileExists"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box displays a
        ///       warning if the user specifies a file name that does not exist.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.OFDcheckFileExistsDescr)
        ]
        public override bool CheckFileExists {
            get {
                return base.CheckFileExists;
            }
            set {
                base.CheckFileExists = value;
            }
        }

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.Multiselect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the dialog box allows multiple files to be selected.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.OFDmultiSelectDescr)
        ]
        public bool Multiselect {
            get {
                return GetOption(NativeMethods.OFN_ALLOWMULTISELECT);
            }
            set {
                SetOption(NativeMethods.OFN_ALLOWMULTISELECT, value);
            }
        }

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.ReadOnlyChecked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether
        ///       the read-only check box is selected.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.OFDreadOnlyCheckedDescr)
        ]
        public bool ReadOnlyChecked {
            get {
                return GetOption(NativeMethods.OFN_READONLY);
            }
            set {
                SetOption(NativeMethods.OFN_READONLY, value);
            }
        }

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.ShowReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog contains a read-only check box.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.OFDshowReadOnlyDescr)
        ]
        public bool ShowReadOnly {
            get {
                return !GetOption(NativeMethods.OFN_HIDEREADONLY);
            }
            set {
                SetOption(NativeMethods.OFN_HIDEREADONLY, !value);
            }
        }

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.OpenFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Opens the file selected by the user with read-only permission.  The file
        ///       attempted is specified by the <see cref='System.Windows.Forms.FileDialog.FileName'/> property.
        ///    </para>
        /// </devdoc>
        public Stream OpenFile() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogOpenFile Demanded");
            IntSecurity.FileDialogOpenFile.Demand();

            string filename = FileNamesInternal[0];

            if (filename == null || filename == "")
                throw new ArgumentNullException( "FileName" );
                
            Stream s = null;

            // SECREVIEW : We demanded the FileDialog permission above, so it is safe
            //           : to assert this here. Since the user picked the file, it
            //           : is OK to give them readonly access to the stream.
            //
            new FileIOPermission(FileIOPermissionAccess.Read, IntSecurity.UnsafeGetFullPath(filename)).Assert();
            try {
                s = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return s;
        }

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all properties to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            base.Reset();
            SetOption(NativeMethods.OFN_FILEMUSTEXIST, true);
        }

        /// <include file='doc\OpenFileDialog.uex' path='docs/doc[@for="OpenFileDialog.RunFileDialog"]/*' />
        /// <devdoc>
        ///     Displays a file open dialog.
        /// </devdoc>
        /// <internalonly/>
        internal override bool RunFileDialog(NativeMethods.OPENFILENAME_I ofn) {
        
            bool result = UnsafeNativeMethods.GetOpenFileName(ofn);
            
            if (!result) {
                // Something may have gone wrong - check for error condition
                //
                int errorCode = SafeNativeMethods.CommDlgExtendedError();
                switch(errorCode) {
                    case NativeMethods.FNERR_INVALIDFILENAME:
                        throw new InvalidOperationException(SR.GetString(SR.FileDialogInvalidFileName, FileName));
                    
                    case NativeMethods.FNERR_SUBCLASSFAILURE: 
                        throw new InvalidOperationException(SR.GetString(SR.FileDialogSubLassFailure));
                        
                    case NativeMethods.FNERR_BUFFERTOOSMALL:
                        throw new InvalidOperationException(SR.GetString(SR.FileDialogBufferTooSmall));
                }
            }
            
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\osfeature.cs ===
//------------------------------------------------------------------------------
// <copyright file="OSFeature.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\OSFeature.uex' path='docs/doc[@for="OSFeature"]/*' />
    /// <devdoc>
    ///    <para>Provides operating-system specific feature queries.</para>
    /// </devdoc>
    public class OSFeature : FeatureSupport {

        /// <include file='doc\OSFeature.uex' path='docs/doc[@for="OSFeature.LayeredWindows"]/*' />
        /// <devdoc>
        ///    <para>Represents the layered, top-level windows feature. This
        ///    <see langword='static'/> field is read-only.</para>
        /// </devdoc>
        public static readonly object LayeredWindows = new object();
        
        /// <include file='doc\OSFeature.uex' path='docs/doc[@for="OSFeature.Themes"]/*' />
        /// <devdoc>
        ///    <para>Determines if the OS supports themes</para>
        /// </devdoc>
        public static readonly object Themes = new object();

        private static OSFeature feature = null;

        private static bool themeSupportTested = false;
        private static bool themeSupport = false;

        /// <include file='doc\OSFeature.uex' path='docs/doc[@for="OSFeature.OSFeature"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.OSFeature'/> class.
        ///       
        ///    </para>
        /// </devdoc>
        protected OSFeature() {
        }

        /// <include file='doc\OSFeature.uex' path='docs/doc[@for="OSFeature.Feature"]/*' />
        /// <devdoc>
        /// <para>Represents the <see langword='static'/> instance of <see cref='System.Windows.Forms.OSFeature'/> to use for feature queries. This property is read-only.</para>
        /// </devdoc>
        public static OSFeature Feature {
            get {
                if (feature == null)
                    feature = new OSFeature();
                    
                return feature;
            }
        }
        
        /// <include file='doc\OSFeature.uex' path='docs/doc[@for="OSFeature.GetVersionPresent"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the version of the specified feature currently available on the system.</para>
        /// </devdoc>
        public override Version GetVersionPresent(object feature) {
            Version featureVersion = null;


            // SECREVIEW : We need to sniff the OS to check for Win2K... currently
            //           : the only OS that supports transparent windows.
            //
            IntSecurity.UnrestrictedEnvironment.Assert();
            try {
                if (feature == LayeredWindows) {
                    if (Environment.OSVersion.Platform == System.PlatformID.Win32NT
                       && Environment.OSVersion.Version.CompareTo(new Version(5, 0, 0, 0)) >= 0) {

                        featureVersion = new Version(0, 0, 0, 0);
                    }
                }
                else if (feature == Themes) {
                    if (!themeSupportTested) {
                        try {
                            SafeNativeMethods.IsAppThemed();
                            themeSupport = true;
                        }
                        catch {
                            themeSupport = false;
                        }
                        themeSupportTested = true;
                    }

                    if (themeSupport) {
                        featureVersion = new Version(0, 0, 0, 0);
                    }
                }
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            return featureVersion;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\orientation.cs ===
//------------------------------------------------------------------------------
// <copyright file="Orientation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\Orientation.uex' path='docs/doc[@for="Orientation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the orientation of controls or elements of controls.
    ///       
    ///    </para>
    /// </devdoc>
    public enum Orientation {
        /// <include file='doc\Orientation.uex' path='docs/doc[@for="Orientation.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control or element is oriented horizontally.
        ///    </para>
        /// </devdoc>
        Horizontal = 0,

        /// <include file='doc\Orientation.uex' path='docs/doc[@for="Orientation.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control or element is oriented vertically.
        ///    </para>
        /// </devdoc>
        Vertical = 1,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\opacityconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="OpacityConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\OpacityConverter.uex' path='docs/doc[@for="OpacityConverter"]/*' />
    /// <devdoc>
    ///      OpacityConverter is a class that can be used to convert
    ///      opacity values from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class OpacityConverter : TypeConverter {
    
        /// <include file='doc\OpacityConverter.uex' path='docs/doc[@for="OpacityConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\OpacityConverter.uex' path='docs/doc[@for="OpacityConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {

                string text = ((string)value).Replace('%', ' ').Trim();
                double val = Double.Parse(text);
                int indexOfPercent = ((string)value).IndexOf("%");
                if (indexOfPercent > 0 && (val >= 0.0 && val <= 1.0)) {
                    val /= 100.0;
                    text = val.ToString();
                }
                double percent = 1.0;

                try {
                    percent = (double)TypeDescriptor.GetConverter(typeof(double)).ConvertFrom(context, culture, text);
                    
                    // assume they meant a percentage if it is > 1.0, else
                    // they actually typed the correct double...
                    //
                    if (percent > 1.0) {
                        percent /= 100.0;
                    }
                }
                catch (FormatException e) {
                    throw new FormatException(SR.GetString(SR.InvalidBoundArgument,
                                                                    "Opacity",
                                                                    text,
                                                                    "0%",
                                                                    "100%"), e);
                }
                
                // Now check to see if it is within our bounds.
                //
                if (percent < 0.0 || percent > 1.0) {
                    throw new FormatException(SR.GetString(SR.InvalidBoundArgument,
                                                                    "Opacity",
                                                                    text,
                                                                    "0%",
                                                                    "100%"));
                }

                return percent;
            }
            
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <include file='doc\OpacityConverter.uex' path='docs/doc[@for="OpacityConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                double val = (double)value;
                int perc = (int)(val * 100.0);
                return perc.ToString() + "%";
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\numericupdown.cs ===
//------------------------------------------------------------------------------
// <copyright file="NumericUpDown.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Globalization;
    using System.Drawing;
    using System.Windows.Forms;
    using System.ComponentModel.Design;

    /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown"]/*' />
    /// <devdoc>
    ///    <para>Represents a Windows up-down control that displays numeric values.</para>
    /// </devdoc>
    [
    DefaultProperty("Value"),
    DefaultEvent("ValueChanged")
    ]
    public class NumericUpDown : UpDownBase, ISupportInitialize {

        private static readonly Decimal    DefaultValue = (Decimal)0.0;
        private static readonly Decimal    DefaultMinimum = (Decimal)0.0;
        private static readonly Decimal    DefaultMaximum = (Decimal)100.0;
        private const           int        DefaultDecimalPlaces = 0;
        private static readonly Decimal    DefaultIncrement = (Decimal)1.0;
        private const bool       DefaultThousandsSeparator = false;
        private const bool       DefaultHexadecimal = false;

        //////////////////////////////////////////////////////////////
        // Member variables
        //
        //////////////////////////////////////////////////////////////

        /// <devdoc>
        ///     The number of decimal places to display.
        /// </devdoc>
        private int decimalPlaces = DefaultDecimalPlaces;

        /// <devdoc>
        ///     The amount to increment by.
        /// </devdoc>
        private Decimal increment = DefaultIncrement;

        // Display the thousands separator?
        private bool thousandsSeparator = DefaultThousandsSeparator;

        // Minimum and maximum values
        private Decimal minimum = DefaultMinimum;
        private Decimal maximum = DefaultMaximum;

        // Hexadecimal
        private bool hexadecimal = DefaultHexadecimal;

        // Internal storage of the current value
        private Decimal currentValue = DefaultValue;

        // Event handler for the onValueChanged event
        private EventHandler onValueChanged = null;

        // Disable value range checking while initializing the control
        private bool initializing = false;

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.NumericUpDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public NumericUpDown() : base() {
            Text = "0";                                     
        }

        //////////////////////////////////////////////////////////////
        // Properties
        //
        //////////////////////////////////////////////////////////////

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.DecimalPlaces"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number of decimal places to display in the up-down control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DefaultValue(NumericUpDown.DefaultDecimalPlaces),
        SRDescription(SR.NumericUpDownDecimalPlacesDescr)
        ]
        public int DecimalPlaces {

            get {
                return decimalPlaces;
            }

            set {
                if (value < 0 || value > 99) {
                    throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "value", value.ToString(), "0", "99"));
                }
                decimalPlaces = value;
                UpdateEditText();
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.Hexadecimal"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets a value indicating whether the up-down control should
        ///       display the value it contains in hexadecimal format.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(NumericUpDown.DefaultHexadecimal),
        SRDescription(SR.NumericUpDownHexadecimalDescr)
        ]
        public bool Hexadecimal {

            get {
                return hexadecimal;
            }

            set {
                hexadecimal = value;
                UpdateEditText();
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.Increment"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value
        ///       to increment or
        ///       decrement the up-down control when the up or down buttons are clicked.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        SRDescription(SR.NumericUpDownIncrementDescr)
        ]
        public Decimal Increment {

            get {
                return increment;
            }

            set {
                if (value < (Decimal)0.0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "Increment", value.ToString()));
                }
                else {
                    increment = value;
                }
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.Maximum"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the maximum value for the up-down control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.NumericUpDownMaximumDescr)
        ]
        public Decimal Maximum {

            get {
                return maximum;
            }

            set {
                maximum = value;
                if (minimum > maximum) {
                    minimum = maximum;
                }
                
                Value = Constrain(currentValue);
                
                Debug.Assert(maximum == value, "Maximum != what we just set it to!");
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.Minimum"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the minimum allowed value for the up-down control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.NumericUpDownMinimumDescr)
        ]
        public Decimal Minimum {

            get {
                return minimum;
            }

            set {
                minimum = value;
                if (minimum > maximum) {
                    maximum = value;
                }
                
                Value = Constrain(currentValue);

                Debug.Assert(minimum.Equals(value), "Minimum != what we just set it to!");
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.Text"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       The text displayed in the control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        Bindable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)        
        ]
        // We're just overriding this to make it non-browsable.
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.ThousandsSeparator"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether a thousands
        ///       separator is displayed in the up-down control when appropriate.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DefaultValue(NumericUpDown.DefaultThousandsSeparator),
        Localizable(true),
        SRDescription(SR.NumericUpDownThousandsSeparatorDescr)
        ]
        public bool ThousandsSeparator {

            get {
                return thousandsSeparator;
            }

            set {
                thousandsSeparator = value;
                UpdateEditText();
            }
        }

        /*
         * The current value of the control
         */
        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.Value"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value
        ///       assigned to the up-down control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Bindable(true),
        SRDescription(SR.NumericUpDownValueDescr)
        ]
        public Decimal Value {

            get {
                if (UserEdit) {
                    ValidateEditText();
                }
                return currentValue;
            }

            set {
                if (value != currentValue) {
                
                    if (!initializing && ((value < minimum) || (value > maximum))) {
                        throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument,
                                                                  "Value", value.ToString(),
                                                                  "'Minimum'", "'Maximum'"));
                    }
                    else {
                        currentValue = value;
                        
                        OnValueChanged(EventArgs.Empty);
    
                        UpdateEditText();
                    }
                }
            }
        }


        //////////////////////////////////////////////////////////////
        // Methods
        //
        //////////////////////////////////////////////////////////////

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.ValueChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the <see cref='System.Windows.Forms.NumericUpDown.Value'/> property has been changed in some way.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.NumericUpDownOnValueChangedDescr)]
        public event EventHandler ValueChanged {
            add {
                onValueChanged += value;
            }
            remove {
                onValueChanged -= value;
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.BeginInit"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Handles tasks required when the control is being initialized.
        /// </devdoc>
        public void BeginInit() {
            initializing = true;
        }

        //
        // Returns the provided value constrained to be within the min and max.
        //
        private Decimal Constrain(Decimal value) {

            Debug.Assert(minimum <= maximum,
                         "minimum > maximum");

            if (value < minimum) {
                value = minimum;
            }

            if (value > maximum) {
                value = maximum;
            }
            
            return value;
        }
        
        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.CreateAccessibilityInstance"]/*' />
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new NumericUpDownAccessibleObject(this);
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.DownButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Decrements the value of the up-down control.
        ///    </para>
        /// </devdoc>
        public override void DownButton() {

            if (UserEdit) {
                ParseEditText();
            }

            Decimal newValue = currentValue;                          
                          
            // Check for underflow
            //
            if (newValue < Decimal.MinValue + increment) {
                newValue = Decimal.MinValue;
            }
            else {
                newValue -= increment;

                if (newValue < minimum)
                    newValue = minimum;
            }
            
            Value = newValue;
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.EndInit"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Called when initialization of the control is complete.
        ///    </para>
        /// </devdoc>
        public void EndInit() {
            initializing = false;
            Value = Constrain(currentValue);
            UpdateEditText();
        }
        
        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.OnTextBoxKeyPress"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Restricts the entry of characters to digits (including hex), the negative sign,
        ///       the decimal point, and editing keystrokes (backspace).
        ///    </para>
        /// </devdoc>
        protected override void OnTextBoxKeyPress(object source, KeyPressEventArgs e) {

            base.OnTextBoxKeyPress(source, e);
            
            NumberFormatInfo numberFormatInfo = System.Globalization.CultureInfo.CurrentCulture.NumberFormat;                                
            string decimalSeparator = numberFormatInfo.NumberDecimalSeparator;
            string groupSeparator = numberFormatInfo.NumberGroupSeparator;
            string negativeSign = numberFormatInfo.NegativeSign;
                
            string keyInput = e.KeyChar.ToString();
                
            if (Char.IsDigit(e.KeyChar)) {
                // Digits are OK
            }
            else if (keyInput.Equals(decimalSeparator) || keyInput.Equals(groupSeparator) || 
                     keyInput.Equals(negativeSign)) {
                // Decimal separator is OK
            }
            else if (e.KeyChar == '\b') {
                // Backspace key is OK
            }
            else if (Hexadecimal && ((e.KeyChar >= 'a' && e.KeyChar <= 'f') || e.KeyChar >= 'A' && e.KeyChar <= 'F')) {
                // Hexadecimal digits are OK
            }
            else if ((ModifierKeys & (Keys.Control | Keys.Alt)) != 0) {
                // Let the edit control handle control and alt key combinations
            }
            else {
                // Eat this invalid key and beep
                e.Handled = true;
                SafeNativeMethods.MessageBeep(0);
            }
        }
                                  
        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.OnValueChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.NumericUpDown.OnValueChanged'/> event.</para>
        /// </devdoc>        
        protected virtual void OnValueChanged(EventArgs e) {

            // Call the event handler
            if (onValueChanged != null) {
                onValueChanged(this, e);
            }
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.ParseEditText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the text displayed in the up-down control to a
        ///       numeric value and evaluates it.
        ///    </para>
        /// </devdoc>
        protected void ParseEditText() {

            Debug.Assert(UserEdit == true, "ParseEditText() - UserEdit == false");

            try {
                if (Hexadecimal) {                    
                    Value = Constrain(Convert.ToDecimal(Convert.ToInt32(Text, 16)));
                }
                else {
                    Value = Constrain(Decimal.Parse(Text));                
                }
            }
            catch (Exception) {
                // Leave value as it is
            }
            finally {
               UserEdit = false;
            }
        }

        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.NumericUpDown.Increment'/> property should be
        ///    persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeIncrement() {
            return !Increment.Equals(NumericUpDown.DefaultIncrement);
        }

        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.NumericUpDown.Maximum'/> property should be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeMaximum() {
            return !Maximum.Equals(NumericUpDown.DefaultMaximum);
        }

        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.NumericUpDown.Minimum'/> property should be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeMinimum() {
            return !Minimum.Equals(NumericUpDown.DefaultMinimum);
        }

        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.NumericUpDown.Value'/> property should be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeValue() {
            return !Value.Equals(NumericUpDown.DefaultValue);
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.ToString"]/*' />
        /// <devdoc>
        ///     Provides some interesting info about this control in String form.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            s += ", Minimum = " + Minimum.ToString() + ", Maximum = " + Maximum.ToString();
            return s;
        }
        
        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.UpButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Increments the value of the up-down control.
        ///    </para>
        /// </devdoc>
        public override void UpButton() {

            if (UserEdit) {
                ParseEditText();
            }
            
            Decimal newValue = currentValue;

            // Check for overflow
            //
            if (newValue > Decimal.MaxValue - increment) {
                newValue = Decimal.MaxValue;
            }
            else {
                newValue += increment;

                if (newValue > maximum)
                    newValue = maximum;
            }

            Value = newValue;
        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.UpdateEditText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the current value of the up-down control in the appropriate format.
        ///    </para>
        /// </devdoc>
        protected override void UpdateEditText() {
            // If we're initializing, we don't want to update the edit text yet,
            // just in case the value is invalid.
            if (initializing) {
                return;
            }

            // If the current value is user-edited, then parse this value before reformatting
            if (UserEdit) {
                ParseEditText();
            }

            ChangingText = true;

            // Make sure the current value is within the min/max
            Debug.Assert(minimum <= currentValue && currentValue <= maximum,
                         "DecimalValue lies outside of [minimum, maximum]");

            if (Hexadecimal) {
                Text = ((Int64)currentValue).ToString("X");
            }
            else {
                Text = currentValue.ToString((ThousandsSeparator ? "N" : "F") + DecimalPlaces.ToString());
            }

            Debug.Assert(ChangingText == false, "ChangingText should have been set to false");

        }

        /// <include file='doc\NumericUpDown.uex' path='docs/doc[@for="NumericUpDown.ValidateEditText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Validates and updates
        ///       the text displayed in the up-down control.
        ///    </para>
        /// </devdoc>
        protected override void ValidateEditText() {

            // See if the edit text parses to a valid decimal
            ParseEditText();
            UpdateEditText();
        }
        
        [System.Runtime.InteropServices.ComVisible(true)]        
        internal class NumericUpDownAccessibleObject : ControlAccessibleObject {

            public NumericUpDownAccessibleObject(NumericUpDown owner) : base(owner) {
            }
            
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.ComboBox;
                }
            }
            
            public override AccessibleObject GetChild(int index) {
                if (index >= 0 && index < GetChildCount()) {
                    
                    // TextBox child
                    //
                    if (index == 0) {
                        return ((UpDownBase)Owner).TextBox.AccessibilityObject.Parent;
                    }
                    
                    // Up/down buttons
                    //
                    if (index == 1) {
                        return ((UpDownBase)Owner).UpDownButtonsInternal.AccessibilityObject.Parent;
                    }
                }
                
                return null;
            }

            public override int GetChildCount() {
                return 2;
            }            
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\nodelabelediteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="NodeLabelEditEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\NodeLabelEditEventHandler.uex' path='docs/doc[@for="NodeLabelEditEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.TreeView.OnBeforeLabelEdit'/> or <see cref='System.Windows.Forms.TreeView.OnAfterLabelEdit'/>
    ///       
    ///       event of a <see cref='System.Windows.Forms.TreeView'/>.
    ///       
    ///    </para>
    /// </devdoc>
    public delegate void NodeLabelEditEventHandler(object sender, NodeLabelEditEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\nativewindow.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeWindow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Drawing;
    using System.Windows.Forms;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a low-level encapsulation of a window handle
    ///       and a window procedure. The class automatically manages window class creation and registration.
    ///    </para>
    /// </devdoc>
    [
        SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
        SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
    ]
    public class NativeWindow : MarshalByRefObject {
#if DEBUG
        private static readonly BooleanSwitch AlwaysUseNormalWndProc = new BooleanSwitch("AlwaysUseNormalWndProc", "Skips checking for the debugger when choosing the debuggable WndProc handler");
        private static readonly TraceSwitch WndProcChoice = new TraceSwitch("WndProcChoice", "Info about choice of WndProc");
#else
        private static readonly TraceSwitch WndProcChoice;
#endif

        /**
         * Table of prime numbers to use as hash table sizes. Each entry is the
         * smallest prime number larger than twice the previous entry.
         */
        private readonly static int[] primes = {
            11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,
            1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,
            17519,21023,25229,30293,36353,43627,52361,62851,75431,90523, 108631, 130363, 
            156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403,
            968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 
            4999559, 5999471, 7199369 
        };

        const int InitializedFlags         = 0x01;
        const int DebuggerPresent          = 0x02;
        const int UseDebuggableWndProc     = 0x04;
        const int LoadConfigSettings       = 0x08;
        const int AssemblyIsDebuggable     = 0x10;

        const float hashLoadFactor = .72F;
        
        private static int              handleCount;
        private static int              hashLoadSize;
        private static HandleBucket[]   hashBuckets;
        private static IntPtr           userDefWindowProc;
        private static byte             wndProcFlags = 0;

        //nned to Store Table of Ids and Handles
        private static short            globalID = 1;
        private static Hashtable        hashForIdHandle;
        private static Hashtable        hashForHandleId;
#if DEBUG
        AppDomain               handleCreatedIn = null;
        string                  subclassStatus = "None";
#endif
        IntPtr                  handle;
        NativeMethods.WndProc   windowProc;
        IntPtr                  windowProcPtr;
        IntPtr                  defWindowProc;
        bool                    suppressedGC;
        bool                    ownHandle;
        NativeWindow            previousWindow; // doubly linked list of subclasses.
        NativeWindow            nextWindow;
        
        static NativeWindow() {
            EventHandler shutdownHandler = new EventHandler(OnShutdown);
            AppDomain.CurrentDomain.ProcessExit += shutdownHandler;
            AppDomain.CurrentDomain.DomainUnload += shutdownHandler;

            // Initialize our static hash of handles.  I have chosen
            // a prime bucket based on a typical number of window handles
            // needed to start up a decent sized app.
                int hashSize = primes[4];
                hashBuckets = new HandleBucket[hashSize];

                hashLoadSize = (int)(hashLoadFactor * hashSize);
                if (hashLoadSize >= hashSize) {
                    hashLoadSize = hashSize-1;
                }

          //Intilialize the Hashtable for Id...
          hashForIdHandle = new Hashtable();
          hashForHandleId = new Hashtable();
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.Finalize"]/*' />
        /// <devdoc>
        ///     Override's the base object's finalize method.
        /// </devdoc>
        ~NativeWindow() {
            if (handle != IntPtr.Zero) {
                UnSubclass(true);
                RemoveWindowFromTable(handle, this);
                defWindowProc = IntPtr.Zero;
                windowProc = null;
                if (ownHandle) {
                    HandleCollector.Remove(handle, NativeMethods.CommonHandles.Window);
                }
                handle = IntPtr.Zero;
            }
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.Handle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the handle for this window.
        ///    </para>
        /// </devdoc>
        public IntPtr Handle {
            get { 
#if DEBUG
                Debug.Assert(handle == IntPtr.Zero || (handleCreatedIn != null && handleCreatedIn == AppDomain.CurrentDomain),
                             "Attempt to access a handle created in a different domain");
                Debug.Assert(handle == IntPtr.Zero || UnsafeNativeMethods.IsWindow(new HandleRef(this, handle)), 
                             "Attempt to access a non-valid handle ");
#endif
                return handle;
            }
        }

        /// <devdoc>
        ///     This returns the previous NativeWindow in the chain of subclasses.
        ///     Generally it returns null, but if someone has subclassed a control
        ///     through the use of a NativeWindow class, this will return the 
        ///     previous NativeWindow subclass.
        ///
        ///     This should be public, but it is way too late for that.
        /// </devdoc>
        internal NativeWindow PreviousWindow {
            get {
                return previousWindow;
            }
        }

        private static int WndProcFlags {
            get {
                // upcast for easy bit masking...
                //
                int intWndProcFlags = wndProcFlags;

                // Check to see if a debugger is installed.  If there is, then use
                // DebuggableCallback instead; this callback has no try/catch around it
                // so exceptions go to the debugger.
                //
                if (intWndProcFlags == 0) {
                    Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Init wndProcFlags");
                    Debug.Indent();

                    if (!Application.CustomThreadExceptionHandlerAttached) {
                        if (Debugger.IsAttached) {
                            Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Debugger is attached, using debuggable WndProc");
                            intWndProcFlags |= UseDebuggableWndProc;
                        }
                        else {
                            intWndProcFlags = AdjustWndProcFlagsFromRegistry(intWndProcFlags);
                            Debug.WriteLineIf(WndProcChoice.TraceVerbose, "After reg check 0x" + intWndProcFlags.ToString("X"));
                            if ((intWndProcFlags & DebuggerPresent) != 0) {
                                Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Debugger present");

                                intWndProcFlags = AdjustWndProcFlagsFromMetadata(intWndProcFlags);

                                if ((intWndProcFlags & AssemblyIsDebuggable) != 0) {
                                    if ((intWndProcFlags & LoadConfigSettings) != 0) {
                                        intWndProcFlags = AdjustWndProcFlagsFromConfig(intWndProcFlags);
                                        Debug.WriteLineIf(WndProcChoice.TraceVerbose, "After config check 0x" + intWndProcFlags.ToString("X"));
                                    }
                                    else {
                                        intWndProcFlags |= UseDebuggableWndProc;
                                    }
                                }
                            }

                            Debug.WriteLineIf(WndProcChoice.TraceVerbose, "After config & debugger check 0x" + intWndProcFlags.ToString("X"));
                        }
                    }


#if DEBUG
                    if (AlwaysUseNormalWndProc.Enabled) {
                        Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Stripping debuggablewndproc due to AlwaysUseNormalWndProc switch");
                        intWndProcFlags &= ~UseDebuggableWndProc;
                    }
#endif
                    intWndProcFlags |= InitializedFlags;
                    Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Final 0x" + intWndProcFlags.ToString("X"));
                    wndProcFlags = (byte)intWndProcFlags;
                    Debug.Unindent();
                }

                return intWndProcFlags;
            }
        }

        internal static bool WndProcShouldBeDebuggable {
            get {
                return (WndProcFlags & UseDebuggableWndProc) != 0;
            }
        }

        /// <devdoc>
        ///     Inserts an entry into this hashtable.
        /// </devdoc>
        private static void AddWindowToTable(IntPtr handle, NativeWindow window) {

            Debug.Assert(handle != IntPtr.Zero, "Should never insert a zero handle into the hash");

            lock(typeof(NativeWindow)) {

                if (handleCount >= hashLoadSize) {
                    ExpandTable();
                }

                uint seed;
                uint incr;
                // Assume we only have one thread writing concurrently.  Modify
                // buckets to contain new data, as long as we insert in the right order.
                uint hashcode = InitHash(handle, hashBuckets.Length, out seed, out incr);

                int  ntry = 0;
                int emptySlotNumber = -1; // We use the empty slot number to cache the first empty slot. We chose to reuse slots
                                          // create by remove that have the collision bit set over using up new slots.

                GCHandle root = GCHandle.Alloc(window, GCHandleType.Weak);

                do {
                    int bucketNumber = (int) (seed % (uint)hashBuckets.Length);

                    if (emptySlotNumber == -1 && (hashBuckets[bucketNumber].handle == new IntPtr(-1)) && (hashBuckets[bucketNumber].hash_coll < 0))
                        emptySlotNumber = bucketNumber;

                    //We need to check if the collision bit is set because we have the possibility where the first
                    //item in the hash-chain has been deleted.
                    if ((hashBuckets[bucketNumber].handle == IntPtr.Zero) || 
                        (hashBuckets[bucketNumber].handle == new IntPtr(-1) && ((hashBuckets[bucketNumber].hash_coll & unchecked(0x80000000))==0))) {

                        if (emptySlotNumber != -1) { // Reuse slot
                            bucketNumber = emptySlotNumber;
                        }

                        // Always set the hash_coll last because there may be readers
                        // reading the table right now on other threads.
                        hashBuckets[bucketNumber].window = root;
                        hashBuckets[bucketNumber].handle  = handle;
                        #if DEBUG
                        hashBuckets[bucketNumber].owner = window.ToString();
                        #endif
                        hashBuckets[bucketNumber].hash_coll |= (int) hashcode;
                        handleCount++;
                        return;
                    }

                    // If there is an existing window in this slot, reuse it.  Be sure to hook up the previous and next
                    // window pointers so we can get back to the right window.
                    //
                    if (((hashBuckets[bucketNumber].hash_coll & 0x7FFFFFFF) == hashcode) && handle == hashBuckets[bucketNumber].handle) {
                        GCHandle prevWindow = hashBuckets[bucketNumber].window;
                        if (prevWindow.IsAllocated) {
                            window.previousWindow = ((NativeWindow)prevWindow.Target);
                            Debug.Assert(window.previousWindow.nextWindow == null, "Last window in chain should have null next ptr");
                            window.previousWindow.nextWindow = window;
                            prevWindow.Free();
                        }
                        hashBuckets[bucketNumber].window = root;
                        #if DEBUG
                        string ownerString = string.Empty;
                        NativeWindow w = window;
                        while(w != null) {
                            ownerString += ("->" + w.ToString());
                            w = w.previousWindow;
                        }
                        hashBuckets[bucketNumber].owner = ownerString;
                        #endif
                        return;
                    }

                    if (emptySlotNumber == -1) {// We don't need to set the collision bit here since we already have an empty slot
                        hashBuckets[bucketNumber].hash_coll |= unchecked((int)0x80000000);
                    }

                    seed += incr;

                } while (++ntry < hashBuckets.Length);

                if (emptySlotNumber != -1)
                {                       
                        // Always set the hash_coll last because there may be readers
                        // reading the table right now on other threads.
                        hashBuckets[emptySlotNumber].window = root;
                        hashBuckets[emptySlotNumber].handle  = handle;
                        #if DEBUG
                        hashBuckets[emptySlotNumber].owner = window.ToString();
                        #endif
                        hashBuckets[emptySlotNumber].hash_coll |= (int) hashcode;
                        handleCount++;
                        return;
                }
            }
    
                    // If you see this assert, make sure load factor & count are reasonable.
            // Then verify that our double hash function (h2, described at top of file)
            // meets the requirements described above. You should never see this assert.
            Debug.Fail("native window hash table insert failed!  Load factor too high, or our double hashing function is incorrect.");
        }

        /// <devdoc>
        ///     Inserts an entry into this ID hashtable.
        /// </devdoc>
        internal void AddWindowToIDTable(IntPtr handle) {
            NativeWindow.hashForIdHandle[NativeWindow.globalID] = handle;
            NativeWindow.hashForHandleId[handle] = NativeWindow.globalID;
            UnsafeNativeMethods.SetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_ID, new HandleRef(this, (IntPtr)globalID));
            globalID++;
            
        }

        private static int AdjustWndProcFlagsFromConfig(int wndProcFlags) {
            if (ConfigData.JitDebugging) {
                wndProcFlags |= UseDebuggableWndProc;
            }
            return wndProcFlags;
        }

        private static int AdjustWndProcFlagsFromRegistry(int wndProcFlags) {
            // This is the enum used to define the meaning of the debug flag...
            //

            /*
            //
            // We split the value of DbgJITDebugLaunchSetting between the value for whether or not to ask the user and between a
            // mask of places to ask. The places to ask are specified in the UnhandledExceptionLocation enum in excep.h.
            //
            enum DebuggerLaunchSetting
            {
                DLS_ASK_USER          = 0x00000000,
                DLS_TERMINATE_APP     = 0x00000001,
                DLS_ATTACH_DEBUGGER   = 0x00000002,
                DLS_QUESTION_MASK     = 0x0000000F,
                DLS_ASK_WHEN_SERVICE  = 0x00000010,
                DLS_MODIFIER_MASK     = 0x000000F0,
                DLS_LOCATION_MASK     = 0xFFFFFF00,
                DLS_LOCATION_SHIFT    = 8 // Shift right 8 bits to get a UnhandledExceptionLocation value from the location part.
            };
            */

            new RegistryPermission(PermissionState.Unrestricted).Assert();
            try {

                Debug.Assert(wndProcFlags == 0x00, "Re-entrancy into IsDebuggerInstalled()");

                RegistryKey debugKey = Registry.LocalMachine.OpenSubKey(@"Software\Microsoft\.NETFramework");
                if (debugKey == null) {
                    Debug.WriteLineIf(WndProcChoice.TraceVerbose, ".NETFramework key not found");
                    return wndProcFlags;
                }
                try {
                    object value = debugKey.GetValue("DbgJITDebugLaunchSetting");
                    if (value != null) {
                        Debug.WriteLineIf(WndProcChoice.TraceVerbose, "DbgJITDebugLaunchSetting value found, debugger is installed");
                        int dbgJit = 0;
                        try {
                            dbgJit = (int)value;
                        }
                        catch (InvalidCastException) {
                            // If the value isn't a DWORD, then we will 
                            // continue to use the non-debuggable wndproc
                            //
                            dbgJit = 1;
                        }

                        // From the enum above, 0x01 == "Terminate App"... for
                        // anything else, we should flag that the debugger
                        // will catch unhandled exceptions
                        //
                        if (dbgJit != 1) {
                            wndProcFlags |= DebuggerPresent;
                            wndProcFlags |= LoadConfigSettings;
                        }
                    }
                }
                finally {
                    debugKey.Close();
                }
            }
            finally {
                System.Security.CodeAccessPermission.RevertAssert();
            }

            return wndProcFlags;
        }

        static int AdjustWndProcFlagsFromMetadata(int wndProcFlags) {
            if ((wndProcFlags & DebuggerPresent) != 0) {
                Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Debugger present, checking for debuggable entry assembly");
                Assembly entry = Assembly.GetEntryAssembly();
                if (entry != null) {
                    if (Attribute.IsDefined(entry, typeof(DebuggableAttribute))) {
                        Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Debuggable attribute on assembly");
                        Attribute[] attr = Attribute.GetCustomAttributes(entry, typeof(DebuggableAttribute));
                        if (attr.Length > 0) {
                            DebuggableAttribute dbg = (DebuggableAttribute)attr[0];
                            if (dbg.IsJITTrackingEnabled) {
                                // Only if the assembly is really setup for debugging
                                // does it really make sense to enable the jitDebugging
                                //
                                Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Entry assembly is debuggable");
                                wndProcFlags |= AssemblyIsDebuggable;
                            }
                        }
                    }
                }
            }
            return wndProcFlags;
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.AssignHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Assigns a handle to this
        ///       window.
        ///    </para>
        /// </devdoc>
        public void AssignHandle(IntPtr handle) {
            AssignHandle(handle, true);
        }

        // CONSIDER: The assignUniqueID should probably be a ControlStyle so 
        // other controls can also prevent setting the GWL_ID. Currently, some
        // ActiveX controls use GWL_ID to identify themselves, and since we change
        // it underneath them, the control will start misbehaving.
        //
        internal void AssignHandle(IntPtr handle, bool assignUniqueID) {
            lock(this) {
                CheckReleased();
                Debug.Assert(handle != IntPtr.Zero, "handle is 0");
#if DEBUG
                handleCreatedIn = AppDomain.CurrentDomain;
#endif
                this.handle = handle;

                if (userDefWindowProc == IntPtr.Zero) {
                    string defproc = (Marshal.SystemDefaultCharSize == 1? "DefWindowProcA": "DefWindowProcW");

                    userDefWindowProc = UnsafeNativeMethods.GetProcAddress(new HandleRef(null, UnsafeNativeMethods.GetModuleHandle("user32.dll")), defproc);
                    if (userDefWindowProc == IntPtr.Zero) {
                        throw new Win32Exception();
                    }
                }

                defWindowProc = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC);
                Debug.Assert(defWindowProc != IntPtr.Zero, "defWindowProc is 0");
                

                if (WndProcShouldBeDebuggable) {
                    Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Using debuggable wndproc");
                    windowProc = new NativeMethods.WndProc(this.DebuggableCallback);
                }
                else {
                    Debug.WriteLineIf(WndProcChoice.TraceVerbose, "Using normal wndproc");
                    windowProc = new NativeMethods.WndProc(this.Callback);
                }

                AddWindowToTable(handle, this);

                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC, windowProc);
                windowProcPtr = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC);
                Debug.Assert(defWindowProc != windowProcPtr, "Uh oh! Subclassed ourselves!!!");
                if (assignUniqueID &&
                    ((int) UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_STYLE) & NativeMethods.WS_CHILD) != 0 &&
                    (int)UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_ID) == 0) {
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_ID, new HandleRef(this, handle));
                }
                
                OnHandleChange();
            }
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.Callback"]/*' />
        /// <devdoc>
        ///     Window message callback method. Control arrives here when a window
        ///     message is sent to this Window. This method packages the window message
        ///     in a Message object and invokes the wndProc() method. A WM_NCDESTROY
        ///     message automatically causes the releaseHandle() method to be called.
        /// </devdoc>
        /// <internalonly/>
        private IntPtr Callback(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
        
            // Note: if you change this code be sure to change the 
            // corresponding code in DebuggableCallback below!
            
            Message m = Message.Create(hWnd, msg, wparam, lparam);
            try {
                WndProc(ref m);
            }
            catch (Exception e) {
                OnThreadException(e);
            }
            if (msg == NativeMethods.WM_NCDESTROY) ReleaseHandle(false);
            return m.Result;
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.CheckReleased"]/*' />
        /// <devdoc>
        ///     Raises an exception if the window handle is not zero.
        /// </devdoc>
        /// <internalonly/>
        private void CheckReleased() {
            if (handle != IntPtr.Zero) {
                throw new InvalidOperationException(SR.GetString(SR.HandleAlreadyExists));
            }
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.CreateHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a window handle for this
        ///       window.
        ///    </para>
        /// </devdoc>
        public virtual void CreateHandle(CreateParams cp) {

            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "CreateAnyWindow Demanded");
            IntSecurity.CreateAnyWindow.Demand();

            if ((cp.Style & NativeMethods.WS_CHILD) != NativeMethods.WS_CHILD
                || cp.Parent == IntPtr.Zero) {

                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "TopLevelWindow Demanded");
                IntSecurity.TopLevelWindow.Demand();
            }

            lock(this) {
                CheckReleased();
                WindowClass windowClass = WindowClass.Create(cp.ClassName, cp.ClassStyle);
                lock (windowClass) {
                    windowClass.targetWindow = this;
                    IntPtr modHandle = UnsafeNativeMethods.GetModuleHandle(null);

                    IntPtr createResult = IntPtr.Zero;
                    
                    // Win98 apparently doesn't believe in returning E_OUTOFMEMORY.  They'd much
                    // rather just AV.  So we catch this and then we re-throw an out of memory error.
                    //
                    try {
                        
                        //(bug 109840)
                        //CreateWindowEx() is throwing because we're passing the WindowText arg with a string of length  > 32767.  
                        //It looks like the Windows call (CreateWindowEx) will only work 
                        //for string lengths no greater than the max length of a 16 bit int (32767).
                        
                        //We need to check the length of the string we're passing into CreateWindowEx().  
                        //If it exceeds the max, we should take the substring....

                        if (cp.Caption != null && cp.Caption.Length > Int16.MaxValue) {
                            cp.Caption = cp.Caption.Substring(0, Int16.MaxValue);
                        }
                        

                        createResult = UnsafeNativeMethods.CreateWindowEx(cp.ExStyle, windowClass.windowClassName,
                                                                          cp.Caption, cp.Style, cp.X, cp.Y, cp.Width, cp.Height, new HandleRef(cp, cp.Parent), NativeMethods.NullHandleRef,
                                                                          new HandleRef(null, modHandle), cp.Param);
                    }
                    catch (NullReferenceException e) {
                        throw new OutOfMemoryException(SR.GetString(SR.ErrorCreatingHandle), e);
                    }

                    windowClass.targetWindow = null;

                    Debug.WriteLineIf(CoreSwitches.PerfTrack.Enabled, "Handle created of type '" + cp.ClassName + "' with caption '" + cp.Caption + "' from NativeWindow of type '" + GetType().FullName + "'");

                    if (createResult == IntPtr.Zero) {
                        int error = Marshal.GetLastWin32Error();
                        throw new Win32Exception(error, SR.GetString(SR.ErrorCreatingHandle));
                    }
                    ownHandle = true;
                    HandleCollector.Add(createResult, NativeMethods.CommonHandles.Window);
                }

                if (suppressedGC) {
                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();  
                    try {
                        GC.ReRegisterForFinalize(this);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    suppressedGC = false;
                }
            }
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.DebuggableCallback"]/*' />
        /// <devdoc>
        ///     Window message callback method. Control arrives here when a window
        ///     message is sent to this Window. This method packages the window message
        ///     in a Message object and invokes the wndProc() method. A WM_NCDESTROY
        ///     message automatically causes the releaseHandle() method to be called.
        /// </devdoc>
        /// <internalonly/>
        private IntPtr DebuggableCallback(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
        
            // Note: if you change this code be sure to change the 
            // corresponding code in Callback above!
            
            Message m = Message.Create(hWnd, msg, wparam, lparam);
            WndProc(ref m);
            if (msg == NativeMethods.WM_NCDESTROY) ReleaseHandle(false);
            return m.Result;
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.DefWndProc"]/*' />
        /// <devdoc>
        ///     Invokes the default window procedure associated with this Window. It is
        ///     an error to call this method when the Handle property is zero.
        /// </devdoc>
        public void DefWndProc(ref Message m) {
            if (previousWindow == null) {
                if (defWindowProc == IntPtr.Zero) {

                    #if DEBUG
                    Debug.Fail("Can't find a default window procedure for message " + m.ToString() + " on class " + GetType().Name + " subclass status: " + subclassStatus);
                    #endif

                    // At this point, there isn't much we can do.  There's a
                    // small chance the following line will allow the rest of
                    // the program to run, but don't get your hopes up.
                    m.Result = UnsafeNativeMethods.DefWindowProc(m.HWnd, m.Msg, m.WParam, m.LParam);
                    return;
                }
                m.Result = UnsafeNativeMethods.CallWindowProc(defWindowProc, m.HWnd, m.Msg, m.WParam, m.LParam);
            }
            else {
                Debug.Assert(previousWindow != this, "Looping in our linked list");
                m.Result = previousWindow.Callback(m.HWnd, m.Msg, m.WParam, m.LParam);
            }
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.DestroyHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Destroys the
        ///       handle associated with this window.
        ///    </para>
        /// </devdoc>
        public virtual void DestroyHandle() {
            lock(this) {
                if (handle != IntPtr.Zero) {
                    UnsafeNativeMethods.DestroyWindow(new HandleRef(this, handle));
                    handle = IntPtr.Zero;
                    ownHandle = false;
                }

                // Now that we have disposed, there is no need to finalize us any more.  So
                // Mark to the garbage collector that we no longer need finalization.
                //
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();  
                try {
                    GC.SuppressFinalize(this);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                suppressedGC = true;
            }
        }
        
        /// <devdoc>
        ///     Increases the bucket count of this hashtable. This method is called from
        ///     the Insert method when the actual load factor of the hashtable reaches
        ///     the upper limit specified when the hashtable was constructed. The number
        ///     of buckets in the hashtable is increased to the smallest prime number
        ///     that is larger than twice the current number of buckets, and the entries
        ///     in the hashtable are redistributed into the new buckets using the cached
        ///     hashcodes.
        /// </devdoc>
        private static void ExpandTable()  {
            // Allocate new Array 
            int oldhashsize = hashBuckets.Length;
        
            int hashsize = GetPrime (1 + oldhashsize *2);
        
            // Don't replace any internal state until we've finished adding to the 
            // new bucket[].  This serves two purposes: 1) Allow concurrent readers
            // to see valid hashtable contents at all times and 2) Protect against
            // an OutOfMemoryException while allocating this new bucket[].
            HandleBucket[] newBuckets = new HandleBucket[hashsize];
        
            // rehash table into new buckets
            int nb;
            for (nb = 0; nb < oldhashsize; nb++) {
                HandleBucket oldb = hashBuckets[nb];
                if ((oldb.handle != IntPtr.Zero) && (oldb.handle != new IntPtr(-1))) {
        
                    // Now re-fit this entry into the table
                    //
                    uint seed = (uint) oldb.hash_coll & 0x7FFFFFFF;
                    uint incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)newBuckets.Length - 1)));
        
                    do {
                        int bucketNumber = (int) (seed % (uint)newBuckets.Length);
        
                        if ((newBuckets[bucketNumber].handle == IntPtr.Zero) || (newBuckets[bucketNumber].handle == new IntPtr(-1))) {
                            newBuckets[bucketNumber].window = oldb.window;
                            newBuckets[bucketNumber].handle = oldb.handle;
                            newBuckets[bucketNumber].hash_coll |= oldb.hash_coll & 0x7FFFFFFF;
                            break;
                        }
                        newBuckets[bucketNumber].hash_coll |= unchecked((int)0x80000000);
                        seed += incr;
                    } while (true);
                }
            }
        
            // New bucket[] is good to go - replace buckets and other internal state.
            hashBuckets = newBuckets;
        
            hashLoadSize = (int)(hashLoadFactor * hashsize);
            if (hashLoadSize >= hashsize) {
                hashLoadSize = hashsize-1;
            }
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.FromHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the window associated with the specified
        ///    <paramref name="handle"/>.
        ///    </para>
        /// </devdoc>
        public static NativeWindow FromHandle(IntPtr handle) {
            if (handle != IntPtr.Zero && handleCount > 0) {
                return GetWindowFromTable(handle);
            }
            return null;
        }
        
        /// <devdoc>
        ///     Calculates a prime number of at least minSize using a static table, and
        ///     if we overflow it, we calculate directly.
        /// </devdoc>
        private static int GetPrime(int minSize) {
            if (minSize < 0) {
                Debug.Fail("NativeWindow hashtable capacity overflow");
                throw new OutOfMemoryException();
            }
            for (int i = 0; i < primes.Length; i++) {
                int size = primes[i];
                if (size >= minSize) return size;
            }
            //outside of our predefined table. 
            //compute the hard way. 
            for (int j = ((minSize - 2) | 1);j < Int32.MaxValue;j+=2) {
                bool prime = true;

                if ((j & 1) != 0) {
                    for (int divisor = 3; divisor < (int)Math.Sqrt (j); divisor+=2) {
                        if ((j % divisor) == 0) {
                            prime = false;
                            break;
                        }
                    }
                    if (prime) return j;
                }
                else {
                    if (j == 2) {
                        return j;
                    }
                }
            }
            return minSize;
        }

        /// <devdoc>
        ///     Returns the native window for the given handle, or null if 
        ///     the handle is not in our hash table.
        /// </devdoc>
        private static NativeWindow GetWindowFromTable(IntPtr handle) {

            Debug.Assert(handle != IntPtr.Zero, "Zero handles cannot be stored in the table");

            // Take a snapshot of buckets, in case another thread does a resize
            HandleBucket[] buckets = hashBuckets;
            uint seed;
            uint incr;
                int  ntry = 0;
            uint hashcode = InitHash(handle, buckets.Length, out seed, out incr);
    
                HandleBucket b;
                do {
                int bucketNumber = (int) (seed % (uint)buckets.Length);
                        b = buckets[bucketNumber];
                        if (b.handle == IntPtr.Zero) {
                          return null;
                        }
                        if (((b.hash_coll & 0x7FFFFFFF) == hashcode) && handle == b.handle) {
                    if (b.window.IsAllocated) {
                        return (NativeWindow)b.window.Target;
                    }
                }
                        seed += incr;
                }
            while (b.hash_coll < 0 && ++ntry < buckets.Length);
                return null;
        }

        internal IntPtr GetHandleFromID(short id)
        {
            if (NativeWindow.hashForIdHandle != null) {
                return (IntPtr)(NativeWindow.hashForIdHandle[id]);
            }
            else
                return IntPtr.Zero;
            
        }

        /// <devdoc>
        ///     Computes the hash function:  H(key, i) = h1(key) + i*h2(key, hashSize).
        ///     The out parameter 'seed' is h1(key), while the out parameter 
        ///     'incr' is h2(key, hashSize).  Callers of this function should 
        ///     add 'incr' each time through a loop.
        /// </devdoc>
        private static uint InitHash(IntPtr handle, int hashsize, out uint seed, out uint incr) {
            // Hashcode must be positive.  Also, we must not use the sign bit, since
            // that is used for the collision bit.
            uint hashcode = (uint)handle & 0x7FFFFFFF;
            seed = (uint) hashcode;
            // Restriction: incr MUST be between 1 and hashsize - 1, inclusive for
            // the modular arithmetic to work correctly.  This guarantees you'll
            // visit every bucket in the table exactly once within hashsize 
            // iterations.  Violate this and it'll cause obscure bugs forever.
            // If you change this calculation for h2(key), update putEntry too!
            incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));
            return hashcode;
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.OnHandleChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a notification method that is called when the handle for a
        ///       window is changed.
        ///    </para>
        /// </devdoc>
        protected virtual void OnHandleChange() {
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.OnShutdown"]/*' />
        /// <devdoc>
        ///     On class load, we connect an event to Application to let us know when
        ///     the main application thread exits.  When this happens, we attempt to
        ///     clear our window class cache.
        /// </devdoc>
        private static void OnShutdown(object sender, EventArgs e) {

            // If we still have windows allocated, we must sling them to userDefWindowProc
            // or else they will AV if they get a message after the managed code has been
            // removed.  In debug builds, we assert and give the "ToString" of the native
            // window. In retail we just detatch the window proc and let it go.  Note that
            // we cannot call DestroyWindow because this API will fail if called from
            // an incorrect thread.
            //
            if (handleCount > 0) {
                
                Debug.Assert(userDefWindowProc != IntPtr.Zero, "We have active windows but no user window proc?");

                lock(typeof(NativeWindow)) {
                    for (int i = 0; i < hashBuckets.Length; i++) {
                        HandleBucket b = hashBuckets[i];
                        if (b.handle != IntPtr.Zero && b.handle != new IntPtr(-1)) {
                            UnsafeNativeMethods.SetWindowLong(new HandleRef(b, b.handle), NativeMethods.GWL_WNDPROC, new HandleRef(null, userDefWindowProc));
                            
                            #if DEBUG && FINALIZATION_WATCH
                            Debug.Fail("Window did not clean itself up: " + b.owner);
                            #endif
                            
                            b.window.Free();
                        }
                        hashBuckets[i].handle = IntPtr.Zero;
                        hashBuckets[i].hash_coll = 0;
                    }
                }

                handleCount = 0;
            }


            WindowClass.DisposeCache();
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.OnThreadException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class,
        ///       manages an unhandled thread
        ///       exception.
        ///    </para>
        /// </devdoc>
        protected virtual void OnThreadException(Exception e) {
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.ReleaseHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Releases the handle associated with this window.
        ///    </para>
        /// </devdoc>
        public virtual void ReleaseHandle() {
            ReleaseHandle(true);
        }

        /// <devdoc>
        ///     Releases the handle associated with this window.  If handleValid
        ///     is true, this will unsubclass the window as well.  HandleValid
        ///     should be false if we are releasing in response to a 
        ///     WM_DESTROY.  Unsubclassing during this message can cause problems
        ///     with XP's theme manager and it's not needed anyway.
        /// </devdoc>
        private void ReleaseHandle(bool handleValid) {
            lock(this) {
                if (handle != IntPtr.Zero) {
                    if (handleValid) {
                        UnSubclass(false);
                    }

                    RemoveWindowFromTable(handle, this);
                    defWindowProc = IntPtr.Zero;
                    windowProc = null;
                    if (ownHandle) {
                        HandleCollector.Remove(handle, NativeMethods.CommonHandles.Window);
                    }
                    handle = IntPtr.Zero;
                    ownHandle = false;
                    OnHandleChange();

                    // Now that we have disposed, there is no need to finalize us any more.  So
                    // Mark to the garbage collector that we no longer need finalization.
                    //
                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();  
                    try {
                        GC.SuppressFinalize(this);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    suppressedGC = true;
                }
            }
        }

        /// <devdoc>
        ///     Removes an entry from this hashtable. If an entry with the specified
        ///     key exists in the hashtable, it is removed.
        /// </devdoc>
        private static void RemoveWindowFromTable(IntPtr handle, NativeWindow window) {

            Debug.Assert(handle != IntPtr.Zero, "Incorrect handle");

            lock(typeof(NativeWindow)) {

                uint seed;
                uint incr;
                // Assuming only one concurrent writer, write directly into buckets.
                uint hashcode = InitHash(handle, hashBuckets.Length, out seed, out incr);
                int ntry = 0;
		NativeWindow nextWindow = window.nextWindow;


                HandleBucket b;
                int bn; // bucketNumber
                do {
                    bn = (int) (seed % (uint)hashBuckets.Length);  // bucketNumber
                    b = hashBuckets[bn];
                    if (((b.hash_coll & 0x7FFFFFFF) == hashcode) && handle == b.handle) {

                        bool shouldNukeBucket    = IsRootWindowInListWithNoChildren(window);
                        bool shouldReplaceBucket = IsRootWindowInListWithChildren(window);

                        // We need to fixup the link pointers of window here.
                        //
                        if (window.previousWindow != null) {
                            window.previousWindow.nextWindow = window.nextWindow;
                        }
                        if (window.nextWindow != null) {
                            window.nextWindow.defWindowProc = window.defWindowProc;
                            window.nextWindow.previousWindow = window.previousWindow;
                        }

                        window.nextWindow = null;
                        window.previousWindow = null;

                        if (shouldReplaceBucket) {
                            hashBuckets[bn].window = GCHandle.Alloc(nextWindow, GCHandleType.Weak);
                        }
                        else if (shouldNukeBucket) {

                            // Clear hash_coll field, then key, then value
                            hashBuckets[bn].hash_coll &= unchecked((int)0x80000000);
                            if (hashBuckets[bn].hash_coll != 0) {
                                hashBuckets[bn].handle = new IntPtr(-1);
                            } 
                            else {
                                hashBuckets[bn].handle = IntPtr.Zero;
                            }

                            if (hashBuckets[bn].window.IsAllocated) {
                                hashBuckets[bn].window.Free();
                            }

                            Debug.Assert(handleCount > 0, "Underflow on handle count");
                            handleCount--;
                        }

                        return;
                   }
                   seed += incr;
                } while (hashBuckets[bn].hash_coll < 0 && ++ntry < hashBuckets.Length);
            }
        }


       	/// <devdoc>
        ///   Determines if the given window is the first member of the linked list
        /// </devdoc>
        private static bool IsRootWindowInListWithChildren(NativeWindow window)
        {
            return ((window.PreviousWindow == null) && (window.nextWindow != null));   
        }   

	/// <devdoc>
        ///   Determines if the given window is the first member of the linked list
	///   and has no children
        /// </devdoc>
        private static bool IsRootWindowInListWithNoChildren(NativeWindow window)
        {
            return ((window.PreviousWindow == null) && (window.nextWindow == null));     
        }       


        /// <devdoc>
        ///     Inserts an entry into this ID hashtable.
        /// </devdoc>
        internal void RemoveWindowFromIDTable(IntPtr handle) {
            short id = (short)NativeWindow.hashForHandleId[handle];
            NativeWindow.hashForHandleId.Remove(handle);
            NativeWindow.hashForIdHandle.Remove(id);
        }
        
        /// <devdoc>
        ///     Unsubclassing is a tricky business.  We need to account for
        ///     some border cases:
        ///     
        ///     1) User has done multiple subclasses but has un-subclassed out of order.
        ///     2) User has done multiple subclasses but now our defWindowProc points to
        ///        a NativeWindow that has GC'd
        ///     3) User releasing this handle but this NativeWindow is not the current
        ///        window proc.
        /// </devdoc>
        private void UnSubclass(bool finalizing) {
            HandleRef href = new HandleRef(this, handle);

            // Don't touch if the current window proc is not ours.
            //
            if (windowProcPtr == UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC)) {
                if (previousWindow == null) {

                #if DEBUG
                subclassStatus = "Unsubclassing back to native defWindowProc";
                #endif

                    // If the defWindowProc points to a native window proc, previousWindow will
                    // be null.  In this case, it is completely safe to assign defWindowProc
                    // to the current wndproc.
                    //
                    UnsafeNativeMethods.SetWindowLong(href, NativeMethods.GWL_WNDPROC, new HandleRef(this, defWindowProc));
                }
                else {
                    if (finalizing) {

                        #if DEBUG
                        subclassStatus = "Setting back to userDefWindowProc -- next chain is managed";
                        #endif

                        // Here, we are finalizing and defWindowProc is pointing to a managed object.  We must assume
                        // that the object defWindowProc is pointing to is also finalizing.  Why?  Because we're
                        // holding a ref to it, and it is holding a ref to us.  The only way this cycle will
                        // finalize is if no one else is hanging onto it.  So, we re-assign the window proc to
                        // userDefWindowProc.
                        UnsafeNativeMethods.SetWindowLong(href, NativeMethods.GWL_WNDPROC, new HandleRef(this, userDefWindowProc));
                    }
                    else {

                        #if DEBUG
                        subclassStatus = "Setting back to next managed subclass object";
                        #endif

                        // Here we are not finalizing so we use the windowProc for our previous window.  This may
                        // DIFFER from the value we are currently storing in defWindowProc because someone may
                        // have re-subclassed.
                        UnsafeNativeMethods.SetWindowLong(href, NativeMethods.GWL_WNDPROC, previousWindow.windowProc);
                    }
                }
            }
            #if DEBUG
            else {
                subclassStatus = "CANNOT unsubclass -- we do not own the subclass";
            }
            #endif
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.WndProc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invokes the default window procedure associated with
        ///       this window.
        ///    </para>
        /// </devdoc>
        protected virtual void WndProc(ref Message m) {
            DefWndProc(ref m);
        }

        /// <devdoc>
        ///     A struct that contains a single bucket for our handle / GCHandle hash table.
        ///     The hash table algorithm we use here was stolen selfishly from the framework's
        ///     Hashtable class.  We don't use Hashtable directly, however, because of boxing
        ///     concerns.  It's algorithm is perfect for our needs, however:  Multiple
        ///     reader, single writer without the need for locks and constant lookup time.
        ///
        ///     Differences between this implementation and Hashtable:
        ///
        ///     Keys are IntPtrs; their hash code is their value.  Collision is still
        ///     marked with the high bit.
        ///
        ///     Reclaimed buckets store -1 in their handle, not the hash table reference.
        /// </devdoc>
        private struct HandleBucket {
            public IntPtr   handle; // Win32 window handle
            public GCHandle window; // a weak GC handle to the NativeWindow class
            public int hash_coll;   // Store hash code; sign bit means there was a collision.
            #if DEBUG
            public string owner;    // owner of this handle
            #endif
        }

        /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.WindowClass"]/*' />
        /// <devdoc>
        ///     WindowClass encapsulates a window class.
        /// </devdoc>
        /// <internalonly/>
        [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class WindowClass {
            internal static WindowClass cache;

            internal WindowClass    next;
            internal string         className;
            internal int            classStyle;
            internal string         windowClassName;
            internal int            hashCode;
            internal IntPtr         defWindowProc;
            internal NativeMethods.WndProc windowProc;
            internal bool           registered;
            internal NativeWindow   targetWindow;

            internal WindowClass(string className, int classStyle) {
                this.className = className;
                this.classStyle = classStyle;
                RegisterClass();
            }

            public IntPtr Callback(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
                Debug.Assert(hWnd != IntPtr.Zero, "Windows called us with an HWND of 0");
                try {
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(null, hWnd), NativeMethods.GWL_WNDPROC, new HandleRef(this, defWindowProc));
                    targetWindow.AssignHandle(hWnd);
                    IntPtr n = targetWindow.Callback(hWnd, msg, wparam, lparam);
                    return n;
                }
                catch (Exception t) {
                    Debug.WriteLine("exception: " + t.ToString());
                }
                return IntPtr.Zero;
            }

            /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.WindowClass.Create"]/*' />
            /// <devdoc>
            ///     Retrieves a WindowClass object for use.  This will create a new
            ///     object if there is no such class/style available, or retrun a
            ///     cached object if one exists.
            /// </devdoc>
            internal static WindowClass Create(string className, int classStyle) {
                lock(typeof(WindowClass)) {
                    WindowClass wc = cache;
                    if (className == null) {
                        while (wc != null && (wc.className != null ||
                                              wc.classStyle != classStyle)) wc = wc.next;
                    }
                    else {
                        int hashCode = className.GetHashCode();
                        while (wc != null && (wc.hashCode != hashCode ||
                                              !className.Equals(wc.className))) wc = wc.next;
                    }
                    if (wc == null) {
                        wc = new WindowClass(className, classStyle);
                        wc.next = cache;
                        cache = wc;
                    }
                    else {
                        if (!wc.registered) {
                            wc.RegisterClass();
                        }
                    }
                    return wc;
                }
            }

            /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.WindowClass.DisposeCache"]/*' />
            /// <devdoc>
            ///     Disposes our window class cache.  This doesn't free anything
            ///     from the actual cache; it merely attempts to unregister
            ///     the classes of everything in the cache.  This allows the unused
            ///     classes to be unrooted. They can later be re-rooted and reused.
            /// </devdoc>
            internal static void DisposeCache() {
                lock(typeof(WindowClass)) {
                    WindowClass wc = cache;

                    while (wc != null) {
                        wc.UnregisterClass();
                        wc = wc.next;
                    }
                }
            }

            /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.WindowClass.RegisterClass"]/*' />
            /// <devdoc>
            ///     Once the classname and style bits have been set, this can
            ///     be called to register the class.
            /// </devdoc>
            private void RegisterClass() {
                NativeMethods.WNDCLASS_D wndclass = new NativeMethods.WNDCLASS_D();

                if (userDefWindowProc == IntPtr.Zero) {
                    string defproc = (Marshal.SystemDefaultCharSize == 1? "DefWindowProcA": "DefWindowProcW");

                    userDefWindowProc = UnsafeNativeMethods.GetProcAddress(new HandleRef(null, UnsafeNativeMethods.GetModuleHandle("user32.dll")), defproc);
                    if (userDefWindowProc == IntPtr.Zero) {
                        throw new Win32Exception();
                    }
                }

                if (className == null) {
                
                    // If we don't use a hollow brush here, Windows will "pre paint" us with COLOR_WINDOW which
                    // creates a little bit if flicker.  This happens even though we are overriding wm_erasebackgnd.
                    // Make this hollow to avoid all flicker.
                    //
                    wndclass.hbrBackground  = UnsafeNativeMethods.GetStockObject(NativeMethods.HOLLOW_BRUSH); //(IntPtr)(NativeMethods.COLOR_WINDOW + 1);
                    wndclass.style = classStyle;

                    defWindowProc = userDefWindowProc;
                    windowClassName = "Window." + Convert.ToString(classStyle, 16);
                    hashCode = 0;
                }
                else {
                    NativeMethods.WNDCLASS_I wcls = new NativeMethods.WNDCLASS_I();
                    bool ok = UnsafeNativeMethods.GetClassInfo(NativeMethods.NullHandleRef, className, wcls);
                    int error = SafeNativeMethods.GetLastError();
                    if (!ok) {
                        throw new Win32Exception(error, SR.GetString(SR.InvalidWndClsName));
                    }
                    wndclass.style = wcls.style;
                    wndclass.cbClsExtra = wcls.cbClsExtra;
                    wndclass.cbWndExtra = wcls.cbWndExtra;
                    wndclass.hIcon = wcls.hIcon;
                    wndclass.hCursor = wcls.hCursor;
                    wndclass.hbrBackground  = wcls.hbrBackground;
                    wndclass.lpszMenuName = Marshal.PtrToStringAuto(wcls.lpszMenuName);
                    defWindowProc = wcls.lpfnWndProc;
                    windowClassName = className;
                    hashCode = className.GetHashCode();
                }

                // Our static data is different for different app domains, so we include the app domain in with
                // our window class name.  This way our static table always matches what Win32 thinks.
                // CONSIDER: since we have the app domain goo, I'm not sure the "WinForms10" part is necessary.
                windowClassName = Application.WindowsFormsVersion + "." +
                                  windowClassName + 
                                  ".app" + Convert.ToString(AppDomain.CurrentDomain.GetHashCode(), 16);

                windowProc = new NativeMethods.WndProc(this.Callback);
                wndclass.lpfnWndProc = windowProc;
                wndclass.hInstance = UnsafeNativeMethods.GetModuleHandle(null);
                wndclass.lpszClassName = windowClassName;
                if (UnsafeNativeMethods.RegisterClass(wndclass) == IntPtr.Zero) {
                    windowProc = null;
                    throw new Win32Exception();
                }
                registered = true;
            }

            /// <include file='doc\NativeWindow.uex' path='docs/doc[@for="NativeWindow.WindowClass.UnregisterClass"]/*' />
            /// <devdoc>
            ///     Unregisters this window class.  Unregistration is not a
            ///     last resort; the window class may be re-registered through
            ///     a call to registerClass.
            /// </devdoc>
            private void UnregisterClass() {
                if (registered && UnsafeNativeMethods.UnregisterClass(windowClassName, new HandleRef(null, UnsafeNativeMethods.GetModuleHandle(null)))) {
                    windowProc = null;
                    registered = false;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\pictureboxsizemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="PictureBoxSizeMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\PictureBoxSizeMode.uex' path='docs/doc[@for="PictureBoxSizeMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how an image is positioned within a <see cref='System.Windows.Forms.PictureBox'/>.
    ///    </para>
    /// </devdoc>
    public enum PictureBoxSizeMode {

        /// <include file='doc\PictureBoxSizeMode.uex' path='docs/doc[@for="PictureBoxSizeMode.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The image is placed in the top-left corner of the
        ///    <see cref='System.Windows.Forms.PictureBox'/>. The image is clipped if
        ///       the <see cref='System.Windows.Forms.PictureBox'/>
        ///       is to small.
        ///    </para>
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\PictureBoxSizeMode.uex' path='docs/doc[@for="PictureBoxSizeMode.StretchImage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The image within the <see cref='System.Windows.Forms.PictureBox'/> is stretched or shrunk to fit the
        ///       current size of the <see cref='System.Windows.Forms.PictureBox'/>.
        ///    </para>
        /// </devdoc>
        StretchImage = 1,

        /// <include file='doc\PictureBoxSizeMode.uex' path='docs/doc[@for="PictureBoxSizeMode.AutoSize"]/*' />
        /// <devdoc>
        ///    The <see cref='System.Windows.Forms.PictureBox'/> is sized to fit the
        ///    size of the image that is displayed.
        /// </devdoc>
        AutoSize = 2,

        /// <include file='doc\PictureBoxSizeMode.uex' path='docs/doc[@for="PictureBoxSizeMode.CenterImage"]/*' />
        /// <devdoc>
        ///    The image is displayed in the center if the <see cref='System.Windows.Forms.PictureBox'/> is larger than the image. If the image
        ///    is larger than the <see cref='System.Windows.Forms.PictureBox'/>, the center of the picture is placed in the
        ///    center of the <see cref='System.Windows.Forms.PictureBox'/> and the outside edges are clipped.
        /// </devdoc>
        CenterImage = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\painteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaintEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\PaintEventHandler.uex' path='docs/doc[@for="PaintEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.Control.Paint'/>event of a <see cref='System.Windows.Forms.Control'/>class.
    ///    </para>
    /// </devdoc>
    public delegate void PaintEventHandler(object sender, PaintEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\paintevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaintEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.Paint'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    // NOTE: Please keep this class consistent with PrintPageEventArgs.
    public class PaintEventArgs : EventArgs, IDisposable {
        /// <devdoc>
        ///     Graphics object with which painting should be done.
        /// </devdoc>
        private Graphics graphics = null;

        // See ResetGraphics()
        private GraphicsState savedGraphicsState = null;

        /// <devdoc>
        ///     DC (Display context) for obtaining the graphics object. Used to delay getting the graphics
        ///     object until absolutely necessary (for perf reasons)
        /// </devdoc>
        private readonly IntPtr dc = IntPtr.Zero;
        IntPtr oldPal = IntPtr.Zero;

        /// <devdoc>
        ///     Rectangle into which all painting should be done.
        /// </devdoc>
        private readonly Rectangle clipRect;
        private Control paletteSource;

        /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs.PaintEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.PaintEventArgs'/> class with the specified graphics and
        ///       clipping rectangle.
        ///    </para>
        /// </devdoc>
        public PaintEventArgs(Graphics graphics, Rectangle clipRect) {
            this.graphics = graphics;
            this.clipRect = clipRect;
        }

        // Internal version of constructor for performance
        // We try to avoid getting the graphics object until needed
        internal PaintEventArgs(IntPtr dc, Control paletteSource, Rectangle clipRect) {
            this.dc = dc;
            this.clipRect = clipRect;
            this.paletteSource = paletteSource;
        }

        /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs.Finalize"]/*' />
        ~PaintEventArgs() {
            Dispose(false);
        }

        /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs.ClipRectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       rectangle in which to paint.
        ///    </para>
        /// </devdoc>
        public Rectangle ClipRectangle {
            get {
                return clipRect;
            }
        }

        /// <devdoc>
        ///     Gets the HDC this paint event is connected to.  If there is no associated
        ///     HDC, or the GDI+ Graphics object has been created (meaning GDI+ now owns the
        ///     HDC), 0 is returned.
        ///
        /// </devdoc>
        internal IntPtr HDC {
            get {
                if (graphics == null)
                    return dc;
                else
                    return IntPtr.Zero;
            }
        }

        /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs.Graphics"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Drawing.Graphics'/>
        ///       object used to
        ///       paint.
        ///    </para>
        /// </devdoc>
        public System.Drawing.Graphics Graphics {
            get {
                if (graphics == null && dc != IntPtr.Zero) {
                    oldPal = Control.SetUpPalette(dc, false /*force*/, false /*realize*/);
                    graphics = Graphics.FromHdcInternal(dc);
                    graphics.PageUnit = GraphicsUnit.Pixel;
                    savedGraphicsState = graphics.Save(); // See ResetGraphics() below
                }
                return graphics;
            }
        }

        // We want a way to dispose the GDI+ Graphics, but we don't want to create one
        // simply to dispose it
        // cpr: should be internal
        /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes
        ///       of the resources (other than memory) used by the <see cref='System.Windows.Forms.PaintEventArgs'/>.
        ///    </para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\PaintEvent.uex' path='docs/doc[@for="PaintEventArgs.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (graphics != null) {
                    graphics.Dispose();
                }
            }

            if (oldPal != IntPtr.Zero && dc != IntPtr.Zero) {
                SafeNativeMethods.SelectPalette(new HandleRef(this, dc), new HandleRef(this, oldPal), 0);
                oldPal = IntPtr.Zero;
            }
        }

        // If ControlStyles.AllPaintingInWmPaint, we call this method
        // after OnPaintBackground so it appears to OnPaint that it's getting a fresh
        // Graphics.  We want to make sure AllPaintingInWmPaint is purely an optimization,
        // and doesn't change behavior, so we need to make sure any clipping regions established
        // in OnPaintBackground don't apply to OnPaint. See ASURT 44682.
        internal void ResetGraphics() {
            if (graphics != null) {
                Debug.Assert(savedGraphicsState != null, "Called ResetGraphics more than once?");
                graphics.Restore(savedGraphicsState);
                savedGraphicsState = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\ownerdrawpropertybag.cs ===
//------------------------------------------------------------------------------
// <copyright file="OwnerDrawPropertyBag.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;



    /// <include file='doc\OwnerDrawPropertyBag.uex' path='docs/doc[@for="OwnerDrawPropertyBag"]/*' />
    /// <devdoc>
    ///
    ///     Class used to pass new font/color information around for "partial" ownerdraw list/treeview items.
    /// </devdoc>
    /// <internalonly/>
    // CONSIDER: This class is not used. We should remove it.
    [Serializable]
    public class OwnerDrawPropertyBag : MarshalByRefObject, ISerializable {
        Font font = null;
        Color foreColor = Color.Empty;
        Color backColor = Color.Empty;
        Control.FontHandleWrapper fontWrapper = null;

          /**
         * Constructor used in deserialization
         */
        internal OwnerDrawPropertyBag(SerializationInfo info, StreamingContext context) {
            foreach (SerializationEntry entry in info) {
                if (entry.Name == "Font") {
                    font = (Font) entry.Value;
                }
                else if (entry.Name =="ForeColor") {
                    foreColor =(Color)entry.Value;
                }
                else if (entry.Name =="BackColor") {
                    backColor = (Color)entry.Value;
                }
            }
        }

        internal OwnerDrawPropertyBag(){
        }

        /// <include file='doc\OwnerDrawPropertyBag.uex' path='docs/doc[@for="OwnerDrawPropertyBag.Font"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Font Font {
            get { 
                return font;
            }
            set {
                font = value;
            }
        }

        /// <include file='doc\OwnerDrawPropertyBag.uex' path='docs/doc[@for="OwnerDrawPropertyBag.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Color ForeColor {
            get {
                return foreColor;
            }
            set {
                foreColor = value;
            }
        }

        /// <include file='doc\OwnerDrawPropertyBag.uex' path='docs/doc[@for="OwnerDrawPropertyBag.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Color BackColor {
            get {
                return backColor;
            }
            set {
                backColor = value;
            }
        }

        internal IntPtr FontHandle {
            get {
                if (fontWrapper == null)
                    fontWrapper = new Control.FontHandleWrapper(Font);
                return fontWrapper.Handle;
            }
        }

        /// <include file='doc\OwnerDrawPropertyBag.uex' path='docs/doc[@for="OwnerDrawPropertyBag.IsEmpty"]/*' />
        /// <devdoc>
        ///     Returns whether or not this property bag contains all default values (is empty)
        /// </devdoc>
        public virtual bool IsEmpty() {
            return (Font == null && foreColor.IsEmpty && backColor.IsEmpty);
        }

        /// <include file='doc\OwnerDrawPropertyBag.uex' path='docs/doc[@for="OwnerDrawPropertyBag.Copy"]/*' />
        /// <devdoc>
        ///     Copies the bag. Always returns a valid ODPB object
        /// </devdoc>
        public static OwnerDrawPropertyBag Copy(OwnerDrawPropertyBag value) {
            lock(typeof(OwnerDrawPropertyBag)) {
                OwnerDrawPropertyBag ret = new OwnerDrawPropertyBag();
                if (value == null) return ret;
                ret.backColor = value.backColor;
                ret.foreColor = value.foreColor;
                ret.Font = value.font;
                return ret;
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        /// ISerializable private implementation
        /// </devdoc>
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            si.AddValue("BackColor", BackColor);
            si.AddValue("ForeColor", ForeColor);
            si.AddValue("Font", Font);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\progressbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProgressBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a Windows progress bar control.      
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("Value"),
    ]
    public sealed class ProgressBar : Control {


        //# VS7 205: simcooke
        //REMOVED: AddOnValueChanged, RemoveOnValueChanged, OnValueChanged and all designer plumbing associated with it.
        //         OnValueChanged event no longer exists.

        // these four values define the range of possible values, how to navigate
        // through them, and the current position
        //
        private int minimum = 0;
        private int maximum = 100;
        private int step = 10;
        private int value = 0;

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.ProgressBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ProgressBar'/> class in its default
        ///       state.
        ///    </para>
        /// </devdoc>
        public ProgressBar()
        : base() {
            SetStyle(ControlStyles.UserPaint |
                     ControlStyles.Selectable, false);
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This is called when creating a window. Inheriting classes can ovveride
        ///       this to add extra functionality, but should not forget to first call
        ///       base.getCreateParams() to make sure the control continues to work
        ///       correctly.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_PROGRESS;
                return cp;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.AllowDrop"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override bool AllowDrop {
            get {
                return base.AllowDrop;
            }
            set {
                base.AllowDrop = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.BackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color of the control.      
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                return base.BackColor;
            }
            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.BackgroundImage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }
        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.CausesValidation"]/*' />
        /// <internalonly/>
        /// <devdoc/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new bool CausesValidation {
            get {
                return base.CausesValidation;
            }
            set {
                base.CausesValidation = value;
            }
        }
        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.CausesValidationChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler CausesValidationChanged {
            add {
                base.CausesValidationChanged += value;
            }
            remove {
                base.CausesValidationChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(100, 23);
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color of the control.      
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Font"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the font of text in the <see cref='System.Windows.Forms.ProgressBar'/>.      
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                base.Font = value;
            }
        }
        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.FontChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                base.FontChanged += value;
            }
            remove {
                base.FontChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Maximum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum value of the <see cref='System.Windows.Forms.ProgressBar'/>.      
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(100),
        SRCategory(SR.CatBehavior),
        RefreshProperties(RefreshProperties.Repaint),
        SRDescription(SR.ProgressBarMaximumDescr)
        ]
        public int Maximum {
            get {
                return maximum;
            }
            set {
                if (maximum != value) {
                    // Ensure that value is in the Win32 control's acceptable range
                    // Message: '%1' is not a valid value for '%0'. '%0' must be greater than %2.
                    // Should this set a boundary for the top end too?
                    if (value < 0)
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "maximum", value.ToString(), "0"));

                    if (minimum > value) minimum = value;

                    maximum = value;

                    if (this.value > maximum) this.value = maximum;

                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.PBM_SETRANGE32, minimum, maximum);
                        UpdatePos() ;
                    }
                }
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Minimum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the minimum value of the <see cref='System.Windows.Forms.ProgressBar'/>.      
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(0),
        SRCategory(SR.CatBehavior),
        RefreshProperties(RefreshProperties.Repaint),
        SRDescription(SR.ProgressBarMinimumDescr)
        ]
        public int Minimum {
            get {
                return minimum;
            }
            set {
                if (minimum != value) {
                    // Ensure that value is in the Win32 control's acceptable range
                    // Message: '%1' is not a valid value for '%0'. '%0' must be greater than %2.
                    // Should this set a boundary for the top end too?
                    if (value < 0)
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "minimum", value.ToString(), "0"));
                    if (maximum < value) maximum = value;

                    minimum = value;

                    if (this.value < minimum) this.value = minimum;

                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.PBM_SETRANGE32, minimum, maximum);
                        UpdatePos() ;
                    }
                }
            }
        }
        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.RightToLeft"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override RightToLeft RightToLeft {
            get {
                return base.RightToLeft;
            }
            set {
                base.RightToLeft = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.RightToLeftChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler RightToLeftChanged {
            add {
                base.RightToLeftChanged += value;
            }
            remove {
                base.RightToLeftChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Step"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the amount that a call to <see cref='System.Windows.Forms.ProgressBar.PerformStep'/>
        ///       increases the progress bar's current position.      
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(10),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.ProgressBarStepDescr)
        ]
        public int Step {
            get {
                return step;
            }
            set {
                step = value;
                if (IsHandleCreated) SendMessage(NativeMethods.PBM_SETSTEP, step, 0);
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.TabStop"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Text"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current position of the <see cref='System.Windows.Forms.ProgressBar'/>.      
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(0),
        SRCategory(SR.CatBehavior),
        Bindable(true),
        SRDescription(SR.ProgressBarValueDescr)
        ]
        public int Value {
            get {
                return value;
            }
            set {
                if (this.value != value) {
                    if ((value < minimum) || (value > maximum))
                        throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument,
                                                                  "value", value.ToString(),
                                                                  "'minimum'", "'maximum'"));
                    this.value = value;
                    UpdatePos() ;
                }
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.KeyUp"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyUp {
            add {
                base.KeyUp += value;
            }
            remove {
                base.KeyUp -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.KeyDown"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyDown {
            add {
                base.KeyDown += value;
            }
            remove {
                base.KeyDown -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.KeyPress"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyPressEventHandler KeyPress {
            add {
                base.KeyPress += value;
            }
            remove {
                base.KeyPress -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Enter"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Enter {
            add {
                base.Enter += value;
            }
            remove {
                base.Enter -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Leave"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Leave {
            add {
                base.Leave += value;
            }
            remove {
                base.Leave -= value;
            }
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.OnPaint"]/*' />
        /// <devdoc>
        ///     ProgressBar Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_PROGRESS_CLASS;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }
        
        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.Increment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Advances the current position of the <see cref='System.Windows.Forms.ProgressBar'/> by the
        ///       specified increment and redraws the control to reflect the new position.      
        ///    </para>
        /// </devdoc>
        public void Increment(int value) {
            this.value += value;

            // Enforce that value is within the range (minimum, maximum)
            if (this.value < minimum) {
                this.value = minimum;
            }
            if (this.value > maximum) {
                this.value = maximum;
            }

            UpdatePos();
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.OnHandleCreated"]/*' />
        /// <devdoc>
        ///    Overridden to set up our properties.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SendMessage(NativeMethods.PBM_SETRANGE32, minimum, maximum);
            SendMessage(NativeMethods.PBM_SETSTEP, step, 0);
            SendMessage(NativeMethods.PBM_SETPOS, value, 0);
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.PerformStep"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Advances the current position of the <see cref='System.Windows.Forms.ProgressBar'/>
        ///       by the amount of the <see cref='System.Windows.Forms.ProgressBar.Step'/>
        ///       property, and redraws the control to reflect the new position.
        ///    </para>
        /// </devdoc>
        public void PerformStep() {
            Increment(step);
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.ToString"]/*' />
        /// <devdoc>
        ///    Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Minimum: " + Minimum.ToString() + ", Maximum: " + Maximum.ToString() + ", Value: " + Value.ToString();
        }

        /// <include file='doc\ProgressBar.uex' path='docs/doc[@for="ProgressBar.UpdatePos"]/*' />
        /// <devdoc>
        ///     Sends the underlying window a PBM_SETPOS message to update
        ///     the current value of the progressbar.
        /// </devdoc>
        /// <internalonly/>
        private void UpdatePos() {
            if (IsHandleCreated) SendMessage(NativeMethods.PBM_SETPOS, value, 0);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\picturebox.cs ===
//------------------------------------------------------------------------------
// <copyright file="PictureBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.ComponentModel;
    using System.ComponentModel.Design;    
    using Microsoft.Win32;

    /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox"]/*' />
    /// <devdoc>
    ///    <para> Displays an image that can be a graphic from a bitmap, 
    ///       icon, or metafile, as well as from
    ///       an enhanced metafile, JPEG, or GIF files.</para>
    /// </devdoc>
    [
    DefaultProperty("Image"),
    Designer("System.Windows.Forms.Design.PictureBoxDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class PictureBox : Control {

        // SECUNDONE : We should add a "LoadImage" that loads an image from a filename for
        // untrusted applications. This would be totally safe, provided that we still return
        // NULL from the Image property in this case...
        //


        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.borderStyle"]/*' />
        /// <devdoc>
        ///     The type of border this control will have.
        /// </devdoc>
        private BorderStyle borderStyle = System.Windows.Forms.BorderStyle.None;

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.image"]/*' />
        /// <devdoc>
        ///     The image being displayed.
        /// </devdoc>
        private Image image;

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.sizeMode"]/*' />
        /// <devdoc>
        ///     Controls how the image is placed within our bounds, or how we are
        ///     sized to fit said image.
        /// </devdoc>
        private PictureBoxSizeMode sizeMode = PictureBoxSizeMode.Normal;

        bool currentlyAnimating;

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.PictureBox"]/*' />
        /// <devdoc>
        ///    <para>Creates a new picture with all default properties and no 
        ///       Image. The default PictureBox.SizeMode will be PictureBoxSizeMode.NORMAL.
        ///    </para>
        /// </devdoc>
        public PictureBox() {
            SetStyle(ControlStyles.Opaque, false);
            SetStyle(ControlStyles.DoubleBuffer, true);
            SetStyle(ControlStyles.Selectable, false);
            SetStyle(ControlStyles.SupportsTransparentBackColor, true);
            
            TabStop = false;
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.AllowDrop"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override bool AllowDrop {
            get {
                return base.AllowDrop;
            }
            set {
                base.AllowDrop = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para> Indicates the
        ///       border style for the control.</para>
        /// </devdoc>
        [
        DefaultValue(BorderStyle.None),
        SRCategory(SR.CatAppearance),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.PictureBoxBorderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }

                if (borderStyle != value) {
                    borderStyle = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.CausesValidation"]/*' />
        /// <internalonly/>
        /// <devdoc/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new bool CausesValidation {
            get {
                return base.CausesValidation;
            }
            set {
                base.CausesValidation = value;
            }
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.CausesValidationChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler CausesValidationChanged {
            add {
                base.CausesValidationChanged += value;
            }
            remove {
                base.CausesValidationChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Returns the parameters needed to create the handle. Inheriting classes
        ///       can override this to provide extra functionality. They should not,
        ///       however, forget to call base.getCreateParams() first to get the struct
        ///       filled up with the basic info.</para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;

                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }

                return cp;
            }
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(100, 50);
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.ForeColor"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.Font"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                base.Font = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.FontChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                base.FontChanged += value;
            }
            remove {
                base.FontChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.Image"]/*' />
        /// <devdoc>
        /// <para>Retrieves the Image that the <see cref='System.Windows.Forms.PictureBox'/> is currently displaying.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        DefaultValue(null),
        SRDescription(SR.PictureBoxImageDescr)
        ]
        public Image Image {
            get {
                return image;
            }
            set {
                StopAnimate();
                this.image = value;
                Form form = FindFormInternal();

                Animate();
                AdjustSize();
                Invalidate();
            }
        }

        // The area occupied by the image
        private Rectangle ImageRectangle {
            get {
                Rectangle result = new Rectangle(0, 0, 0, 0);

                if (image != null) {
                    switch (sizeMode) {
                        case PictureBoxSizeMode.Normal:
                        case PictureBoxSizeMode.AutoSize:
                            result.Size = image.Size;
                            break;

                        case PictureBoxSizeMode.StretchImage:
                            result.Size = ClientSize;
                            break;

                        case PictureBoxSizeMode.CenterImage:
                            result.Size = image.Size;
                            Size szCtl = ClientSize;

                            result.X = (szCtl.Width - result.Width) / 2;
                            result.Y = (szCtl.Height - result.Height) / 2;

                            break;
                    }
                }

                return result;
            }
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.RightToLeft"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override RightToLeft RightToLeft {
            get {
                return base.RightToLeft;
            }
            set {
                base.RightToLeft = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.RightToLeftChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler RightToLeftChanged {
            add {
                base.RightToLeftChanged += value;
            }
            remove {
                base.RightToLeftChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.SizeMode"]/*' />
        /// <devdoc>
        ///    <para>Indicates how the image is displayed.</para>
        /// </devdoc>
        [
        DefaultValue(PictureBoxSizeMode.Normal),
        SRCategory(SR.CatBehavior),
        Localizable(true),
        SRDescription(SR.PictureBoxSizeModeDescr),
        RefreshProperties(RefreshProperties.Repaint)        
        ]
        public PictureBoxSizeMode SizeMode {
            get {
                return sizeMode;
            }
            set {
                if (!Enum.IsDefined(typeof(PictureBoxSizeMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(PictureBoxSizeMode));
                }
                if (this.sizeMode != value) {
                    sizeMode = value;
                    AdjustSize();
                    Invalidate();
                    
                    OnSizeModeChanged(EventArgs.Empty);
                }
            }
        }
        
        private static readonly object EVENT_SIZEMODECHANGED = new object();

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.SizeModeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.PictureBoxOnSizeModeChangedDescr)]
        public event EventHandler SizeModeChanged {
            add {
                Events.AddHandler(EVENT_SIZEMODECHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_SIZEMODECHANGED, value);
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.TabStop"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.TabIndex"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public int TabIndex {
            get {
                return base.TabIndex;
            }
            set {
                base.TabIndex = value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.TabIndexChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabIndexChanged {
            add {
                base.TabIndexChanged += value;
            }
            remove {
                base.TabIndexChanged -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.Text"]/*' />
        /// <internalonly/><hideinheritance/>        
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.Enter"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Enter {
            add {
                base.Enter += value;
            }
            remove {
                base.Enter -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.KeyUp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyUp {
            add {
                base.KeyUp += value;
            }
            remove {
                base.KeyUp -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.KeyDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyDown {
            add {
                base.KeyDown += value;
            }
            remove {
                base.KeyDown -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.KeyPress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyPressEventHandler KeyPress {
            add {
                base.KeyPress += value;
            }
            remove {
                base.KeyPress -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.Leave"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Leave {
            add {
                base.Leave += value;
            }
            remove {
                base.Leave -= value;
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.AdjustSize"]/*' />
        /// <devdoc>
        ///     If the PictureBox has the SizeMode property set to AutoSize, this makes
        ///     sure that the picturebox is large enough to hold the image.
        /// </devdoc>
        /// <internalonly/>
        private void AdjustSize() {
            if (sizeMode == PictureBoxSizeMode.AutoSize) {
                ClientSize = GetPreferredSize();
            }
        }

        private void Animate() {
            Animate(Visible && Enabled && ParentInternal != null);
        }

        private void StopAnimate() {
            Animate(false);
        }

        private void Animate(bool animate) {
            if (animate != this.currentlyAnimating) {
                if (animate) {
                    if (this.image != null) {
                        ImageAnimator.Animate(this.image, new EventHandler(this.OnFrameChanged));
                        this.currentlyAnimating = animate;
                    }
                }
                else {
                    if (this.image != null) {
                        ImageAnimator.StopAnimate(this.image, new EventHandler(this.OnFrameChanged));
                        this.currentlyAnimating = animate;
                    }
                }
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                StopAnimate();
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.GetPreferredSize"]/*' />
        /// <devdoc>
        ///     Returns the preferred size of this control, were it supposed to fit
        ///     the current image perfectly.
        /// </devdoc>
        /// <internalonly/>
        private Size GetPreferredSize() {
            if (image == null)
                return Size;
            else
                return image.Size;
        }
        
        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.OnEnabledChanged"]/*' />
        protected override void OnEnabledChanged(EventArgs e) {
            base.OnEnabledChanged(e);
            Animate();
        }
        
        private void OnFrameChanged(object o, EventArgs e) {
            if (IsWindowObscured) {
                StopAnimate();
                return;
            }

            Invalidate();  
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.OnPaint"]/*' />
        /// <devdoc>
        ///     Overridden onPaint to make sure that the image is painted correctly.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnPaint(PaintEventArgs pe) {
            if (image != null) {
                Animate();
                ImageAnimator.UpdateFrames();

                pe.Graphics.DrawImage(image, ImageRectangle);
            }

            // Windows draws the border for us (see CreateParams)
            base.OnPaint(pe); // raise Paint event
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.OnVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnVisibleChanged(EventArgs e) {
            base.OnVisibleChanged(e);
            Animate();
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.OnParentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnParentChanged(EventArgs e) {
            base.OnParentChanged(e);
            Animate();
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.OnResize"]/*' />
        /// <devdoc>
        ///     OnResize override to invalidate entire control in Stetch mode
        /// </devdoc>
        /// <internalonly/>
        protected override void OnResize(EventArgs e) {
            base.OnResize(e);
            if (sizeMode == PictureBoxSizeMode.StretchImage || sizeMode == PictureBoxSizeMode.CenterImage) {
                Invalidate();
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.OnSizeModeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSizeModeChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_SIZEMODECHANGED] as EventHandler;
            if (eh != null) {
                eh(this, e);
            }
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Overrides Control.setBoundsCore to enforce autoSize.
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            Rectangle oldBounds = Bounds;

            if (sizeMode == PictureBoxSizeMode.AutoSize) {
                Size sz = GetPreferredSize();
                width = sz.Width;
                height = sz.Height;
            }
            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\PictureBox.uex' path='docs/doc[@for="PictureBox.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", SizeMode: " + sizeMode.ToString("G");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\panel.cs ===
//------------------------------------------------------------------------------
// <copyright file="Panel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Represents a <see cref='System.Windows.Forms.Panel'/>
    ///       control.</para>
    /// </devdoc>
    [
    DefaultProperty("BorderStyle"),
    DefaultEvent("Paint"),
    Designer("System.Windows.Forms.Design.PanelDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class Panel : ScrollableControl {

        private BorderStyle borderStyle = System.Windows.Forms.BorderStyle.None;

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.Panel"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Panel'/> class.</para>
        /// </devdoc>
        public Panel()
        : base() {
            TabStop = false;
            SetStyle(ControlStyles.Selectable |
                     ControlStyles.AllPaintingInWmPaint, false);
            SetStyle(ControlStyles.SupportsTransparentBackColor, true);
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para> Indicates the
        ///       border style for the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.None),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.PanelBorderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (borderStyle != value) {
                    if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                    }

                    borderStyle = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Returns the parameters needed to create the handle.  Inheriting classes
        ///    can override this to provide extra functionality.  They should not,
        ///    however, forget to call base.getCreateParams() first to get the struct
        ///    filled up with the basic info.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= NativeMethods.WS_EX_CONTROLPARENT;

                cp.ExStyle &= (~NativeMethods.WS_EX_CLIENTEDGE);
                cp.Style &= (~NativeMethods.WS_BORDER);

                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }
                return cp;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(200, 100);
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.KeyUp"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyUp {
            add {
                base.KeyUp += value;
            }
            remove {
                base.KeyUp -= value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.KeyDown"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyDown {
            add {
                base.KeyDown += value;
            }
            remove {
                base.KeyDown -= value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.KeyPress"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyPressEventHandler KeyPress {
            add {
                base.KeyPress += value;
            }
            remove {
                base.KeyPress -= value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.TabStop"]/*' />
        /// <devdoc>
        /// </devdoc>
        [DefaultValue(false)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.Text"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.OnResize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Fires the event indicating that the panel has been resized.
        ///       Inheriting controls should use this in favour of actually listening to
        ///       the event, but should not forget to call base.onResize() to
        ///       ensure that the event is still fired for external listeners.</para>
        /// </devdoc>
        protected override void OnResize(EventArgs eventargs) {
            if (DesignMode && borderStyle == BorderStyle.None) {
                Invalidate();
            }
            base.OnResize(eventargs);
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.StringFromBorderStyle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private static string StringFromBorderStyle(BorderStyle value) {
            switch (value) {
                case BorderStyle.None:
                    return "System.Windows.Forms.BorderStyle.NONE";
                case BorderStyle.Fixed3D:
                    return "BorderStyle.FIXED_3D";
                case BorderStyle.FixedSingle:
                    return "BorderStyle.FIXED_SINGLE";
            }
            return "[invalid BorderStyle]";
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", BorderStyle: " + StringFromBorderStyle(borderStyle);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   NativeMethods.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using Accessibility;
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using Microsoft.Win32;
    
    /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods"]/*' />
    internal class NativeMethods {

        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));
        public static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
        
        public const int BITMAPINFO_MAX_COLORSIZE = 256;
        public const int BI_BITFIELDS = 3;

        public const int ARW_BOTTOMLEFT = 0x0000,
        ARW_BOTTOMRIGHT = 0x0001,
        ARW_TOPLEFT = 0x0002,
        ARW_TOPRIGHT = 0x0003,
        ARW_LEFT = 0x0000,
        ARW_RIGHT = 0x0000,
        ARW_UP = 0x0004,
        ARW_DOWN = 0x0004,
        ARW_HIDE = 0x0008,
        ACM_OPENA = (0x0400+100),
        ACM_OPENW = (0x0400+103),
        ADVF_ONLYONCE = 2,
        ADVF_PRIMEFIRST = 4;

        public const int BI_RGB = 0,
        BS_PATTERN = 3,
        BITSPIXEL = 12,
        BDR_RAISEDOUTER = 0x0001,
        BDR_SUNKENOUTER = 0x0002,
        BDR_RAISEDINNER = 0x0004,
        BDR_SUNKENINNER = 0x0008,
        BDR_RAISED = 0x0005,
        BDR_SUNKEN = 0x000a,
        BF_LEFT = 0x0001,
        BF_TOP = 0x0002,
        BF_RIGHT = 0x0004,
        BF_BOTTOM = 0x0008,
        BF_ADJUST = 0x2000,
        BF_FLAT = 0x4000,
        BF_MIDDLE = 0x0800,
        BFFM_INITIALIZED = 1,
        BFFM_SELCHANGED = 2,
        BFFM_SETSELECTION = 0x400+103,
        BFFM_ENABLEOK = 0x400+101,
        BS_PUSHBUTTON = 0x00000000,
        BS_DEFPUSHBUTTON = 0x00000001,
        BS_MULTILINE = 0x00002000,
        BS_PUSHLIKE = 0x00001000,
        BS_OWNERDRAW = 0x0000000B,
        BS_RADIOBUTTON = 0x00000004,
        BS_3STATE = 0x00000005,
        BS_GROUPBOX = 0x00000007,
        BS_LEFT = 0x00000100,
        BS_RIGHT = 0x00000200,
        BS_CENTER = 0x00000300,
        BS_TOP = 0x00000400,
        BS_BOTTOM = 0x00000800,
        BS_VCENTER = 0x00000C00,
        BS_RIGHTBUTTON = 0x00000020,
        BN_CLICKED = 0,
        BM_SETCHECK = 0x00F1,
        BM_SETSTATE = 0x00F3;

        public const int CDERR_DIALOGFAILURE = 0xFFFF,
        CDERR_STRUCTSIZE = 0x0001,
        CDERR_INITIALIZATION = 0x0002,
        CDERR_NOTEMPLATE = 0x0003,
        CDERR_NOHINSTANCE = 0x0004,
        CDERR_LOADSTRFAILURE = 0x0005,
        CDERR_FINDRESFAILURE = 0x0006,
        CDERR_LOADRESFAILURE = 0x0007,
        CDERR_LOCKRESFAILURE = 0x0008,
        CDERR_MEMALLOCFAILURE = 0x0009,
        CDERR_MEMLOCKFAILURE = 0x000A,
        CDERR_NOHOOK = 0x000B,
        CDERR_REGISTERMSGFAIL = 0x000C,
        CFERR_NOFONTS = 0x2001,
        CFERR_MAXLESSTHANMIN = 0x2002,
        CC_RGBINIT = 0x00000001,
        CC_FULLOPEN = 0x00000002,
        CC_PREVENTFULLOPEN = 0x00000004,
        CC_SHOWHELP = 0x00000008,
        CC_ENABLEHOOK = 0x00000010,
        CC_SOLIDCOLOR = 0x00000080,
        CC_ANYCOLOR = 0x00000100,
        CF_SCREENFONTS = 0x00000001,
        CF_SHOWHELP = 0x00000004,
        CF_ENABLEHOOK = 0x00000008,
        CF_INITTOLOGFONTSTRUCT = 0x00000040,
        CF_EFFECTS = 0x00000100,
        CF_APPLY = 0x00000200,
        CF_SCRIPTSONLY = 0x00000400,
        CF_NOVECTORFONTS = 0x00000800,
        CF_NOSIMULATIONS = 0x00001000,
        CF_LIMITSIZE = 0x00002000,
        CF_FIXEDPITCHONLY = 0x00004000,
        CF_FORCEFONTEXIST = 0x00010000,
        CF_TTONLY = 0x00040000,
        CF_SELECTSCRIPT = 0x00400000,
        CF_NOVERTFONTS = 0x01000000,
        CP_WINANSI = 1004;
        
        public const int cmb4 = 0x0473,
        CS_DBLCLKS = 0x0008,
        CF_TEXT = 1,
        CF_BITMAP = 2,
        CF_METAFILEPICT = 3,
        CF_SYLK = 4,
        CF_DIF = 5,
        CF_TIFF = 6,
        CF_OEMTEXT = 7,
        CF_DIB = 8,
        CF_PALETTE = 9,
        CF_PENDATA = 10,
        CF_RIFF = 11,
        CF_WAVE = 12,
        CF_UNICODETEXT = 13,
        CF_ENHMETAFILE = 14,
        CF_HDROP = 15,
        CF_LOCALE = 16,
        CW_USEDEFAULT = (unchecked((int)0x80000000)),
        CWP_SKIPINVISIBLE = 0x0001,
        COLOR_WINDOW = 5,
        CB_ERR = (-1),
        CBN_SELCHANGE = 1,
        CBN_DBLCLK = 2,
        CBN_EDITCHANGE = 5,
        CBN_DROPDOWN = 7,
        CBN_SELENDOK = 9,
        CBS_SIMPLE = 0x0001,
        CBS_DROPDOWN = 0x0002,
        CBS_DROPDOWNLIST = 0x0003,
        CBS_OWNERDRAWFIXED = 0x0010,
        CBS_OWNERDRAWVARIABLE = 0x0020,
        CBS_AUTOHSCROLL = 0x0040,
        CBS_HASSTRINGS = 0x0200,
        CBS_NOINTEGRALHEIGHT = 0x0400,
        CB_GETEDITSEL = 0x0140,
        CB_LIMITTEXT = 0x0141,
        CB_SETEDITSEL = 0x0142,
        CB_ADDSTRING = 0x0143,
        CB_DELETESTRING = 0x0144,
        CB_GETCURSEL = 0x0147,
        CB_INSERTSTRING = 0x014A,
        CB_RESETCONTENT = 0x014B,
        CB_FINDSTRING = 0x014C,
        CB_SETCURSEL = 0x014E,
        CB_SHOWDROPDOWN = 0x014F,
        CB_GETITEMDATA = 0x0150,
        CB_SETITEMHEIGHT = 0x0153,
        CB_GETITEMHEIGHT = 0x0154,
        CB_GETDROPPEDSTATE = 0x0157,
        CB_FINDSTRINGEXACT = 0x0158,
        CB_SETDROPPEDWIDTH = 0x0160,
        CDRF_DODEFAULT = 0x00000000,
        CDRF_NEWFONT = 0x00000002,
        CDRF_SKIPDEFAULT = 0x00000004,
        CDRF_NOTIFYPOSTPAINT = 0x00000010,
        CDRF_NOTIFYITEMDRAW = 0x00000020,
        CDRF_NOTIFYSUBITEMDRAW = CDRF_NOTIFYITEMDRAW,
        CDDS_PREPAINT = 0x00000001,
        CDDS_POSTPAINT = 0x00000002,
        CDDS_ITEM = 0x00010000,
        CDDS_SUBITEM = 0x00020000,
        CDDS_ITEMPREPAINT = (0x00010000|0x00000001),
        CDIS_SELECTED = 0x0001,
        CDIS_GRAYED = 0x0002,
        CDIS_DISABLED = 0x0004,
        CDIS_CHECKED = 0x0008,
        CDIS_FOCUS = 0x0010,
        CDIS_DEFAULT = 0x0020,
        CDIS_HOT = 0x0040,
        CDIS_MARKED = 0x0080,
        CDIS_INDETERMINATE = 0x0100,
        CLR_NONE = unchecked((int)0xFFFFFFFF),
        CLR_DEFAULT = unchecked((int)0xFF000000),
        CCS_NORESIZE = 0x00000004,
        CCS_NOPARENTALIGN = 0x00000008,
        CCS_NODIVIDER = 0x00000040,
        CBEM_INSERTITEMA = (0x0400+1),
        CBEM_GETITEMA = (0x0400+4),
        CBEM_SETITEMA = (0x0400+5),
        CBEM_INSERTITEMW = (0x0400+11),
        CBEM_SETITEMW = (0x0400+12),
        CBEM_GETITEMW = (0x0400+13),
        CBEN_ENDEDITA = ((0-800)-5),
        CBEN_ENDEDITW = ((0-800)-6),
        CONNECT_E_NOCONNECTION = unchecked((int)0x80040200),
        CONNECT_E_CANNOTCONNECT = unchecked((int)0x80040202),
        CTRLINFO_EATS_RETURN    = 1,
        CTRLINFO_EATS_ESCAPE    = 2,
        CSIDL_DESKTOP                    = 0x0000,        // <desktop>
        CSIDL_INTERNET                   = 0x0001,        // Internet Explorer (icon on desktop)
        CSIDL_PROGRAMS                   = 0x0002,        // Start Menu\Programs
        CSIDL_PERSONAL                   = 0x0005,        // My Documents
        CSIDL_FAVORITES                  = 0x0006,        // <user name>\Favorites
        CSIDL_STARTUP                    = 0x0007,        // Start Menu\Programs\Startup
        CSIDL_RECENT                     = 0x0008,        // <user name>\Recent
        CSIDL_SENDTO                     = 0x0009,        // <user name>\SendTo
        CSIDL_STARTMENU                  = 0x000b,        // <user name>\Start Menu
        CSIDL_DESKTOPDIRECTORY           = 0x0010,        // <user name>\Desktop
        CSIDL_TEMPLATES                  = 0x0015,
        CSIDL_APPDATA                    = 0x001a,        // <user name>\Application Data
        CSIDL_LOCAL_APPDATA              = 0x001c,        // <user name>\Local Settings\Applicaiton Data (non roaming)
        CSIDL_INTERNET_CACHE             = 0x0020,
        CSIDL_COOKIES                    = 0x0021,
        CSIDL_HISTORY                    = 0x0022,
        CSIDL_COMMON_APPDATA             = 0x0023,        // All Users\Application Data
        CSIDL_SYSTEM                     = 0x0025,        // GetSystemDirectory()
        CSIDL_PROGRAM_FILES              = 0x0026,        // C:\Program Files
        CSIDL_PROGRAM_FILES_COMMON       = 0x002b;        // C:\Program Files\Common

        public const int DUPLICATE = 0x06,
        DISPID_UNKNOWN = (-1),
        DISPID_PROPERTYPUT = (-3),
        DISPATCH_METHOD = 0x1,
        DISPATCH_PROPERTYGET = 0x2,
        DISPATCH_PROPERTYPUT = 0x4,
        DV_E_DVASPECT = unchecked((int)0x8004006B),
        DISP_E_MEMBERNOTFOUND = unchecked((int)0x80020003),
        DISP_E_PARAMNOTFOUND = unchecked((int)0x80020004),
        DISP_E_EXCEPTION = unchecked((int)0x80020009),
        DEFAULT_GUI_FONT = 17,
        DIB_RGB_COLORS = 0,
        DRAGDROP_E_NOTREGISTERED = unchecked((int)0x80040100),
        DRAGDROP_E_ALREADYREGISTERED = unchecked((int)0x80040101),
        DUPLICATE_SAME_ACCESS = 0x00000002,
        DFC_CAPTION = 1,
        DFC_MENU = 2,
        DFC_SCROLL = 3,
        DFC_BUTTON = 4,
        DFCS_CAPTIONCLOSE = 0x0000,
        DFCS_CAPTIONMIN = 0x0001,
        DFCS_CAPTIONMAX = 0x0002,
        DFCS_CAPTIONRESTORE = 0x0003,
        DFCS_CAPTIONHELP = 0x0004,
        DFCS_MENUARROW = 0x0000,
        DFCS_MENUCHECK = 0x0001,
        DFCS_MENUBULLET = 0x0002,
        DFCS_SCROLLUP = 0x0000,
        DFCS_SCROLLDOWN = 0x0001,
        DFCS_SCROLLLEFT = 0x0002,
        DFCS_SCROLLRIGHT = 0x0003,
        DFCS_SCROLLCOMBOBOX = 0x0005,
        DFCS_BUTTONCHECK = 0x0000,
        DFCS_BUTTONRADIO = 0x0004,
        DFCS_BUTTON3STATE = 0x0008,
        DFCS_BUTTONPUSH = 0x0010,
        DFCS_INACTIVE = 0x0100,
        DFCS_PUSHED = 0x0200,
        DFCS_CHECKED = 0x0400,
        DFCS_FLAT = 0x4000,
        DT_LEFT = 0x00000000,
        DT_RIGHT = 0x00000002,
        DT_VCENTER = 0x00000004,
        DT_SINGLELINE = 0x00000020,
        DT_NOCLIP = 0x00000100,
        DT_CALCRECT = 0x00000400,
        DT_NOPREFIX = 0x00000800,
        DT_EDITCONTROL = 0x00002000,
        DT_EXPANDTABS  = 0x00000040,
        DT_END_ELLIPSIS = 0x00008000,
        DT_RTLREADING = 0x00020000,
        DCX_WINDOW = 0x00000001,
        DCX_CACHE = 0x00000002,
        DCX_LOCKWINDOWUPDATE = 0x00000400,
        DI_NORMAL = 0x0003,
        DLGC_WANTARROWS = 0x0001,
        DLGC_WANTTAB = 0x0002,
        DLGC_WANTALLKEYS = 0x0004,
        DLGC_WANTCHARS = 0x0080,
        DTM_SETSYSTEMTIME = (0x1000+2),
        DTM_SETRANGE = (0x1000+4),
        DTM_SETFORMATA = (0x1000+5),
        DTM_SETFORMATW = (0x1000+50),
        DTM_SETMCCOLOR = (0x1000+6),
        DTM_SETMCFONT = (0x1000+9),
        DTS_UPDOWN = 0x0001,
        DTS_SHOWNONE = 0x0002,
        DTS_LONGDATEFORMAT = 0x0004,
        DTS_TIMEFORMAT = 0x0009,
        DTS_RIGHTALIGN = 0x0020,
        DTN_DATETIMECHANGE = ((0-760)+1),
        DTN_USERSTRINGA = ((0-760)+2),
        DTN_USERSTRINGW = ((0-760)+15),
        DTN_WMKEYDOWNA = ((0-760)+3),
        DTN_WMKEYDOWNW = ((0-760)+16),
        DTN_FORMATA = ((0-760)+4),
        DTN_FORMATW = ((0-760)+17),
        DTN_FORMATQUERYA = ((0-760)+5),
        DTN_FORMATQUERYW = ((0-760)+18),
        DTN_DROPDOWN = ((0-760)+6),
        DTN_CLOSEUP = ((0-760)+7),
        DVASPECT_CONTENT   = 1,
        DVASPECT_TRANSPARENT = 32,
        DVASPECT_OPAQUE    = 16;

        public const int E_NOTIMPL = unchecked((int)0x80004001),
        E_OUTOFMEMORY = unchecked((int)0x8007000E),
        E_INVALIDARG = unchecked((int)0x80070057),
        E_NOINTERFACE = unchecked((int)0x80004002),
        E_FAIL = unchecked((int)0x80004005),
        E_ABORT = unchecked((int)0x80004004),
        E_UNEXPECTED = unchecked((int)0x8000FFFF),
        ETO_OPAQUE = 0x0002,
        ETO_CLIPPED = 0x0004,
        EMR_POLYTEXTOUTA = 96,
        EMR_POLYTEXTOUTW = 97,
        EDGE_RAISED = (0x0001|0x0004),
        EDGE_SUNKEN = (0x0002|0x0008),
        EDGE_ETCHED = (0x0002|0x0004),
        EDGE_BUMP = (0x0001|0x0008),
        ES_LEFT = 0x0000,
        ES_CENTER = 0x0001,
        ES_RIGHT = 0x0002,
        ES_MULTILINE = 0x0004,
        ES_UPPERCASE = 0x0008,
        ES_LOWERCASE = 0x0010,
        ES_AUTOVSCROLL = 0x0040,
        ES_AUTOHSCROLL = 0x0080,
        ES_NOHIDESEL = 0x0100,
        ES_READONLY = 0x0800,
        EN_CHANGE = 0x0300,
        EN_HSCROLL = 0x0601,
        EN_VSCROLL = 0x0602,
        EN_ALIGN_LTR_EC = 0x0700,
        EN_ALIGN_RTL_EC = 0x0701,
        EC_LEFTMARGIN = 0x0001,
        EC_RIGHTMARGIN = 0x0002,
        EM_GETSEL = 0x00B0,
        EM_SETSEL = 0x00B1,
        EM_SCROLL = 0x00B5,
        EM_SCROLLCARET = 0x00B7,
        EM_GETMODIFY = 0x00B8,
        EM_SETMODIFY = 0x00B9,
        EM_GETLINECOUNT = 0x00BA,
        EM_REPLACESEL = 0x00C2,
        EM_GETLINE = 0x00C4,
        EM_LIMITTEXT = 0x00C5,
        EM_CANUNDO = 0x00C6,
        EM_UNDO = 0x00C7,
        EM_SETPASSWORDCHAR = 0x00CC,
        EM_EMPTYUNDOBUFFER = 0x00CD,
        EM_SETREADONLY = 0x00CF,
        EM_SETMARGINS = 0x00D3,
        EM_POSFROMCHAR = 0x00D6,
        EM_CHARFROMPOS = 0x00D7;

        public const int FNERR_SUBCLASSFAILURE = 0x3001,
        FNERR_INVALIDFILENAME = 0x3002,
        FNERR_BUFFERTOOSMALL = 0x3003,
        FRERR_BUFFERLENGTHZERO = 0x4001,
        FADF_BSTR = (0x100),
        FADF_UNKNOWN = (0x200),
        FADF_DISPATCH = (0x400),
        FADF_VARIANT = (unchecked((int)0x800)),
        FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000,
        FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200,
        FVIRTKEY = 0x01,
        FSHIFT = 0x04,
        FALT = 0x10;
        
        public const int GMEM_MOVEABLE = 0x0002,
        GMEM_ZEROINIT = 0x0040,
        GMEM_DDESHARE = 0x2000,
        GWL_WNDPROC = (-4),
        GWL_HWNDPARENT = (-8),
        GWL_STYLE = (-16),
        GWL_EXSTYLE = (-20),
        GWL_ID = (-12),
        GW_HWNDNEXT = 2,
        GW_HWNDPREV = 3,
        GW_CHILD = 5,
        GMR_VISIBLE = 0,
        GMR_DAYSTATE = 1,
        GDI_ERROR = (unchecked((int)0xFFFFFFFF)),
        GDTR_MIN = 0x0001,
        GDTR_MAX = 0x0002,
        GDT_VALID = 0,
        GDT_NONE = 1;
        
        public const int HOLLOW_BRUSH = 5,
        HC_ACTION = 0,
        HC_GETNEXT = 1,
        HC_SKIP = 2,
        HTNOWHERE = 0,
        HTCLIENT = 1,
        HTBOTTOM = 15,
        HTBOTTOMRIGHT = 17,
        HELPINFO_WINDOW = 0x0001,
        HCF_HIGHCONTRASTON = 0x00000001,
        HDM_GETITEMCOUNT = (0x1200+0),
        HDM_INSERTITEMA = (0x1200+1),
        HDM_INSERTITEMW = (0x1200+10),
        HDM_GETITEMA = (0x1200+3),
        HDM_GETITEMW = (0x1200+11),
        HDM_SETITEMA = (0x1200+4),
        HDM_SETITEMW = (0x1200+12),
        HDN_ITEMCHANGINGA = ((0-300)-0),
        HDN_ITEMCHANGINGW = ((0-300)-20),
        HDN_ITEMCHANGEDA = ((0-300)-1),
        HDN_ITEMCHANGEDW = ((0-300)-21),
        HDN_ITEMCLICKA = ((0-300)-2),
        HDN_ITEMCLICKW = ((0-300)-22),
        HDN_ITEMDBLCLICKA = ((0-300)-3),
        HDN_ITEMDBLCLICKW = ((0-300)-23),
        HDN_DIVIDERDBLCLICKA = ((0-300)-5),
        HDN_DIVIDERDBLCLICKW = ((0-300)-25),
        HDN_BEGINTRACKA = ((0-300)-6),
        HDN_BEGINTRACKW = ((0-300)-26),
        HDN_ENDTRACKA = ((0-300)-7),
        HDN_ENDTRACKW = ((0-300)-27),
        HDN_TRACKA = ((0-300)-8),
        HDN_TRACKW = ((0-300)-28),
        HDN_GETDISPINFOA = ((0-300)-9),
        HDN_GETDISPINFOW = ((0-300)-29);

        public static HandleRef HWND_TOP = new HandleRef(null, (IntPtr)0);
        public static HandleRef HWND_BOTTOM = new HandleRef(null, (IntPtr)1);
        public static HandleRef HWND_TOPMOST = new HandleRef(null, new IntPtr(-1));
        public static HandleRef HWND_NOTOPMOST = new HandleRef(null, new IntPtr(-2));

        public const int IME_CMODE_NATIVE = 0x0001,
        IME_CMODE_KATAKANA = 0x0002,
        IME_CMODE_FULLSHAPE = 0x0008,
        INPLACE_E_NOTOOLSPACE = unchecked((int)0x800401A1),
        ICON_SMALL = 0,
        ICON_BIG = 1,
        IDC_ARROW = 32512,
        IDC_IBEAM = 32513,
        IDC_WAIT = 32514,
        IDC_CROSS = 32515,
        IDC_SIZEALL = 32646,
        IDC_SIZENWSE = 32642,
        IDC_SIZENESW = 32643,
        IDC_SIZEWE = 32644,
        IDC_SIZENS = 32645,
        IDC_UPARROW = 32516,
        IDC_NO = 32648,
        IDC_APPSTARTING = 32650,
        IDC_HELP = 32651,
        IMAGE_ICON = 1,
        IMAGE_CURSOR = 2,
        ICC_LISTVIEW_CLASSES = 0x00000001,
        ICC_TREEVIEW_CLASSES = 0x00000002,
        ICC_BAR_CLASSES = 0x00000004,
        ICC_TAB_CLASSES = 0x00000008,
        ICC_PROGRESS_CLASS = 0x00000020,
        ICC_DATE_CLASSES = 0x00000100,
        ILC_MASK = 0x0001,
        ILC_COLOR = 0x0000,
        ILC_COLOR4 = 0x0004,
        ILC_COLOR8 = 0x0008,
        ILC_COLOR16 = 0x0010,
        ILC_COLOR24 = 0x0018,
        ILC_COLOR32 = 0x0020,
        ILD_NORMAL = 0x0000,
        ILD_TRANSPARENT = 0x0001,
        ILD_MASK = 0x0010,
        ILD_ROP = 0x0040;
        
        public const int KEYEVENTF_KEYUP = 0x0002;

        public const int LOGPIXELSX = 88,
        LOGPIXELSY = 90,
        LB_ERR = (-1),
        LB_ERRSPACE = (-2),
        LBN_SELCHANGE = 1,
        LBN_DBLCLK = 2,
        LB_ADDSTRING = 0x0180,
        LB_INSERTSTRING = 0x0181,
        LB_DELETESTRING = 0x0182,
        LB_RESETCONTENT = 0x0184,
        LB_SETSEL = 0x0185,
        LB_SETCURSEL = 0x0186,
        LB_GETSEL = 0x0187,
        LB_GETCARETINDEX = 0x019F,
        LB_GETCURSEL = 0x0188,
        LB_GETTEXT = 0x0189,
        LB_GETTEXTLEN = 0x018A,
        LB_GETTOPINDEX = 0x018E,
        LB_FINDSTRING = 0x018F,
        LB_GETSELCOUNT = 0x0190,
        LB_GETSELITEMS = 0x0191,
        LB_SETHORIZONTALEXTENT = 0x0194,
        LB_SETCOLUMNWIDTH = 0x0195,
        LB_SETTOPINDEX = 0x0197,
        LB_GETITEMRECT = 0x0198,
        LB_SETITEMHEIGHT = 0x01A0,
        LB_GETITEMHEIGHT = 0x01A1,
        LB_FINDSTRINGEXACT = 0x01A2,
        LB_ITEMFROMPOINT = 0x01A9,
        LB_SETLOCALE = 0x01A5;
        
        public const int LBS_NOTIFY = 0x0001,
        LBS_MULTIPLESEL = 0x0008,
        LBS_OWNERDRAWFIXED = 0x0010,
        LBS_OWNERDRAWVARIABLE = 0x0020,
        LBS_HASSTRINGS = 0x0040,
        LBS_USETABSTOPS = 0x0080,
        LBS_NOINTEGRALHEIGHT = 0x0100,
        LBS_MULTICOLUMN = 0x0200,
        LBS_WANTKEYBOARDINPUT = 0x0400,
        LBS_EXTENDEDSEL = 0x0800,
        LBS_DISABLENOSCROLL = 0x1000,
        LBS_NOSEL = 0x4000,
        LOCK_WRITE = 0x1,
        LOCK_EXCLUSIVE = 0x2,
        LOCK_ONLYONCE = 0x4,
        LVS_ICON = 0x0000,
        LVS_REPORT = 0x0001,
        LVS_SMALLICON = 0x0002,
        LVS_LIST = 0x0003,
        LVS_SINGLESEL = 0x0004,
        LVS_SHOWSELALWAYS = 0x0008,
        LVS_SORTASCENDING = 0x0010,
        LVS_SORTDESCENDING = 0x0020,
        LVS_SHAREIMAGELISTS = 0x0040,
        LVS_NOLABELWRAP = 0x0080,
        LVS_AUTOARRANGE = 0x0100,
        LVS_EDITLABELS = 0x0200,
        LVS_NOSCROLL = 0x2000,
        LVS_ALIGNTOP = 0x0000,
        LVS_ALIGNLEFT = 0x0800,
        LVS_NOCOLUMNHEADER = 0x4000,
        LVS_NOSORTHEADER = unchecked((int)0x8000),
        LVM_SETBKCOLOR = (0x1000+1),
        LVSIL_NORMAL = 0,
        LVSIL_SMALL = 1,
        LVSIL_STATE = 2,
        LVM_SETIMAGELIST = (0x1000+3),
        LVIF_TEXT = 0x0001,
        LVIF_IMAGE = 0x0002,
        LVIF_PARAM = 0x0004,
        LVIF_STATE = 0x0008,
        LVIS_FOCUSED = 0x0001,
        LVIS_SELECTED = 0x0002,
        LVIS_CUT = 0x0004,
        LVIS_DROPHILITED = 0x0008,
        LVIS_OVERLAYMASK = 0x0F00,
        LVIS_STATEIMAGEMASK = 0xF000,
        LVM_GETITEMA = (0x1000+5),
        LVM_GETITEMW = (0x1000+75),
        LVM_SETITEMA = (0x1000+6),
        LVM_SETITEMW = (0x1000+76),
        LVM_INSERTITEMA = (0x1000+7),
        LVM_INSERTITEMW = (0x1000+77),
        LVM_DELETEITEM = (0x1000+8),
        LVM_DELETECOLUMN = (0x1000+28),
        LVM_DELETEALLITEMS = (0x1000+9),
        LVNI_FOCUSED = 0x0001,
        LVNI_SELECTED = 0x0002,
        LVM_GETNEXTITEM = (0x1000+12),
        LVFI_PARAM = 0x0001,
        LVM_FINDITEMA = (0x1000+13),
        LVM_FINDITEMW = (0x1000+83),
        LVIR_BOUNDS = 0,
        LVIR_ICON = 1,
        LVIR_LABEL = 2,
        LVIR_SELECTBOUNDS = 3,
        LVM_GETITEMRECT = (0x1000+14),
        LVM_GETSTRINGWIDTHA = (0x1000+17),
        LVM_GETSTRINGWIDTHW = (0x1000+87),
        LVHT_ONITEM = (0x0002|0x0004|0x0008),
        LVHT_ONITEMSTATEICON = 0x0008,
        LVM_HITTEST = (0x1000+18),
        LVM_ENSUREVISIBLE = (0x1000+19),
        LVA_DEFAULT = 0x0000,
        LVA_ALIGNLEFT = 0x0001,
        LVA_ALIGNTOP = 0x0002,
        LVA_SNAPTOGRID = 0x0005,
        LVM_ARRANGE = (0x1000+22),
        LVM_EDITLABELA = (0x1000+23),
        LVM_EDITLABELW = (0x1000+118),
        LVCF_FMT = 0x0001,
        LVCF_WIDTH = 0x0002,
        LVCF_TEXT = 0x0004,
        LVCF_IMAGE = 0x0010,
        LVCF_ORDER = 0x0020,
        LVM_GETCOLUMNA = (0x1000+25),
        LVM_GETCOLUMNW = (0x1000+95),
        LVM_SETCOLUMNA = (0x1000+26),
        LVM_SETCOLUMNW = (0x1000+96),
        LVM_INSERTCOLUMNA = (0x1000+27),
        LVM_INSERTCOLUMNW = (0x1000+97),
        LVM_GETCOLUMNWIDTH = (0x1000+29),
        LVM_SETCOLUMNWIDTH = (0x1000+30),
        LVM_GETHEADER = (0x1000+31),
        LVM_SETTEXTCOLOR = (0x1000+36),
        LVM_SETTEXTBKCOLOR = (0x1000+38),
        LVM_GETTOPINDEX = (0x1000+39),
        LVM_SETITEMSTATE = (0x1000+43),
        LVM_GETITEMSTATE = (0x1000+44),
        LVM_GETITEMTEXTA = (0x1000+45),
        LVM_GETITEMTEXTW = (0x1000+115),
        LVM_GETHOTITEM = (0x1000+61),
        LVM_SETITEMTEXTA = (0x1000+46),
        LVM_SETITEMTEXTW = (0x1000+116),
        LVM_SETITEMCOUNT = (0x1000+47),
        LVM_SORTITEMS = (0x1000+48),
        LVM_GETSELECTEDCOUNT = (0x1000+50),
        LVM_GETISEARCHSTRINGA = (0x1000+52),
        LVM_GETISEARCHSTRINGW = (0x1000+117),
        LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000+54),
        LVS_EX_GRIDLINES = 0x00000001,
        LVS_EX_CHECKBOXES = 0x00000004,
        LVS_EX_TRACKSELECT = 0x00000008,
        LVS_EX_HEADERDRAGDROP = 0x00000010,
        LVS_EX_FULLROWSELECT = 0x00000020,
        LVS_EX_ONECLICKACTIVATE = 0x00000040,
        LVS_EX_TWOCLICKACTIVATE = 0x00000080,
        LVN_ITEMCHANGING = ((0-100)-0),
        LVN_ITEMCHANGED = ((0-100)-1),
        LVN_BEGINLABELEDITA = ((0-100)-5),
        LVN_BEGINLABELEDITW = ((0-100)-75),
        LVN_ENDLABELEDITA = ((0-100)-6),
        LVN_ENDLABELEDITW = ((0-100)-76),
        LVN_COLUMNCLICK = ((0-100)-8),
        LVN_BEGINDRAG = ((0-100)-9),
        LVN_BEGINRDRAG = ((0-100)-11),
        LVN_ODFINDITEMA = ((0-100)-52),
        LVN_ODFINDITEMW = ((0-100)-79),
        LVN_ITEMACTIVATE = ((0-100)-14),
        LVN_GETDISPINFOA = ((0-100)-50),
        LVN_GETDISPINFOW = ((0-100)-77),
        LVN_SETDISPINFOA = ((0-100)-51),
        LVN_SETDISPINFOW = ((0-100)-78),
        LVN_KEYDOWN = ((0-100)-55),
        
        LWA_COLORKEY            = 0x00000001,
        LWA_ALPHA               = 0x00000002;

        public const int LANG_NEUTRAL = 0x00,
                         LOCALE_IFIRSTDAYOFWEEK = 0x0000100C;   /* first day of week specifier */

        public static readonly int LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT);
        public static readonly int LANG_USER_DEFAULT   = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

        public static int MAKELANGID(int primary, int sub) {
            return ((((short)(sub)) << 10) | (short)(primary));
        }
        
        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.Lang.MAKELCID"]/*' />
        /// <devdoc>
        ///     Creates an LCID from a LangId
        /// </devdoc>
        public static int MAKELCID(int lgid) {
            return MAKELCID(lgid, SORT_DEFAULT);
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.Lang.MAKELCID1"]/*' />
        /// <devdoc>
        ///     Creates an LCID from a LangId
        /// </devdoc>
        public static int MAKELCID(int lgid, int sort) {
            return ((0xFFFF & lgid) | (((0x000f) & sort) << 16));
        }
    
        public const int MEMBERID_NIL = (-1),
        MAX_PATH = 260,
        MM_TEXT = 1,
        MM_ANISOTROPIC = 8,
        MK_LBUTTON = 0x0001,
        MK_RBUTTON = 0x0002,
        MK_SHIFT = 0x0004,
        MK_CONTROL = 0x0008,
        MK_MBUTTON = 0x0010,
        MNC_EXECUTE = 2,
        MIIM_STATE = 0x00000001,
        MIIM_ID = 0x00000002,
        MIIM_SUBMENU = 0x00000004,
        MIIM_TYPE = 0x00000010,
        MIIM_DATA = 0x00000020,
        MB_OK = 0x00000000,
        MF_BYCOMMAND = 0x00000000,
        MF_BYPOSITION = 0x00000400,
        MF_ENABLED = 0x00000000,
        MF_GRAYED = 0x00000001,
        MF_POPUP = 0x00000010,
        MF_SYSMENU = 0x00002000,
        MFT_MENUBREAK = 0x00000040,
        MFT_SEPARATOR = 0x00000800,
        MFT_RIGHTORDER = 0x00002000,
        MFT_RIGHTJUSTIFY = 0x00004000,
        MDITILE_VERTICAL = 0x0000,
        MDITILE_HORIZONTAL = 0x0001,
        MCM_SETMAXSELCOUNT = (0x1000+4),
        MCM_SETSELRANGE = (0x1000+6),
        MCM_GETMONTHRANGE = (0x1000+7),
        MCM_GETMINREQRECT = (0x1000+9),
        MCM_SETCOLOR = (0x1000+10),
        MCM_SETTODAY = (0x1000+12),
        MCM_GETTODAY = (0x1000+13),
        MCM_HITTEST = (0x1000+14),
        MCM_SETFIRSTDAYOFWEEK = (0x1000+15),
        MCM_SETRANGE = (0x1000+18),
        MCM_SETMONTHDELTA = (0x1000+20),
        MCM_GETMAXTODAYWIDTH = (0x1000+21),
        MCHT_TITLE = 0x00010000,
        MCHT_CALENDAR = 0x00020000,
        MCHT_TODAYLINK = 0x00030000,
        MCHT_TITLEBK = (0x00010000),
        MCHT_TITLEMONTH = (0x00010000|0x0001),
        MCHT_TITLEYEAR = (0x00010000|0x0002),
        MCHT_TITLEBTNNEXT = (0x00010000|0x01000000|0x0003),
        MCHT_TITLEBTNPREV = (0x00010000|0x02000000|0x0003),
        MCHT_CALENDARBK = (0x00020000),
        MCHT_CALENDARDATE = (0x00020000|0x0001),
        MCHT_CALENDARDATENEXT = ((0x00020000|0x0001)|0x01000000),
        MCHT_CALENDARDATEPREV = ((0x00020000|0x0001)|0x02000000),
        MCHT_CALENDARDAY = (0x00020000|0x0002),
        MCHT_CALENDARWEEKNUM = (0x00020000|0x0003),
        MCSC_TEXT = 1,
        MCSC_TITLEBK = 2,
        MCSC_TITLETEXT = 3,
        MCSC_MONTHBK = 4,
        MCSC_TRAILINGTEXT = 5,
        MCN_SELCHANGE = ((0-750)+1),
        MCN_GETDAYSTATE = ((0-750)+3),
        MCN_SELECT = ((0-750)+4),
        MCS_DAYSTATE = 0x0001,
        MCS_MULTISELECT = 0x0002,
        MCS_WEEKNUMBERS = 0x0004,
        MCS_NOTODAYCIRCLE = 0x0008,
        MCS_NOTODAY = 0x0010;

        public const int NIM_ADD = 0x00000000,
        NIM_MODIFY = 0x00000001,
        NIM_DELETE = 0x00000002,
        NIF_MESSAGE = 0x00000001,
        NIF_ICON = 0x00000002,
        NIF_TIP = 0x00000004,
        NFR_ANSI = 1,
        NFR_UNICODE = 2,
        NM_CLICK = ((0-0)-2),
        NM_DBLCLK = ((0-0)-3),
        NM_RCLICK = ((0-0)-5),
        NM_RDBLCLK = ((0-0)-6),
        NM_CUSTOMDRAW = ((0-0)-12),
        NM_RELEASEDCAPTURE = ((0-0)-16);

        public const int OFN_READONLY = 0x00000001,
        OFN_OVERWRITEPROMPT = 0x00000002,
        OFN_HIDEREADONLY = 0x00000004,
        OFN_NOCHANGEDIR = 0x00000008,
        OFN_SHOWHELP = 0x00000010,
        OFN_ENABLEHOOK = 0x00000020,
        OFN_NOVALIDATE = 0x00000100,
        OFN_ALLOWMULTISELECT = 0x00000200,
        OFN_PATHMUSTEXIST = 0x00000800,
        OFN_FILEMUSTEXIST = 0x00001000,
        OFN_CREATEPROMPT = 0x00002000,
        OFN_EXPLORER = 0x00080000,
        OFN_NODEREFERENCELINKS = 0x00100000,
        OFN_ENABLESIZING = 0x00800000,
        OFN_USESHELLITEM = 0x01000000,
        OLEIVERB_PRIMARY = 0,
        OLEIVERB_SHOW = -1,
        OLEIVERB_HIDE = -3,
        OLEIVERB_UIACTIVATE = -4,
        OLEIVERB_INPLACEACTIVATE = -5,
        OLEIVERB_PROPERTIES = -7,
        OLE_E_NOCONNECTION = unchecked((int)0x80040004),
        OLE_E_PROMPTSAVECANCELLED = unchecked((int)0x8004000C),
        OLEMISC_RECOMPOSEONRESIZE = 0x00000001,
        OLEMISC_INSIDEOUT = 0x00000080,
        OLEMISC_ACTIVATEWHENVISIBLE = 0x0000100,
        OLEMISC_ACTSLIKEBUTTON = 0x00001000,
        OLEMISC_SETCLIENTSITEFIRST = 0x00020000,
        OBJ_PEN = 1,
        OBJ_BRUSH = 2,
        OBJ_DC = 3,
        OBJ_METADC = 4,
        OBJ_PAL = 5,
        OBJ_FONT = 6,
        OBJ_BITMAP = 7,
        OBJ_REGION = 8,
        OBJ_METAFILE = 9,
        OBJ_MEMDC = 10,
        OBJ_EXTPEN = 11,
        OBJ_ENHMETADC = 12,
        ODS_CHECKED = 0x0008,
        ODS_COMBOBOXEDIT = 0x1000,
        ODS_DEFAULT = 0x0020,
        ODS_DISABLED = 0x0004,
        ODS_FOCUS = 0x0010,
        ODS_GRAYED = 0x0002,
        ODS_HOTLIGHT       = 0x0040,
        ODS_INACTIVE       = 0x0080,
        ODS_NOACCEL        = 0x0100,
        ODS_NOFOCUSRECT    = 0x0200,
        ODS_SELECTED = 0x0001,
        OLECLOSE_SAVEIFDIRTY = 0,
        OLECLOSE_PROMPTSAVE = 2;

        public const int PDERR_SETUPFAILURE = 0x1001,
        PDERR_PARSEFAILURE = 0x1002,
        PDERR_RETDEFFAILURE = 0x1003,
        PDERR_LOADDRVFAILURE = 0x1004,
        PDERR_GETDEVMODEFAIL = 0x1005,
        PDERR_INITFAILURE = 0x1006,
        PDERR_NODEVICES = 0x1007,
        PDERR_NODEFAULTPRN = 0x1008,
        PDERR_DNDMMISMATCH = 0x1009,
        PDERR_CREATEICFAILURE = 0x100A,
        PDERR_PRINTERNOTFOUND = 0x100B,
        PDERR_DEFAULTDIFFERENT = 0x100C,
        PD_NOSELECTION = 0x00000004,
        PD_NOPAGENUMS = 0x00000008,
        PD_NOCURRENTPAGE = 0x00800000,
        PD_COLLATE = 0x00000010,
        PD_PRINTTOFILE = 0x00000020,
        PD_SHOWHELP = 0x00000800,
        PD_ENABLEPRINTHOOK = 0x00001000,
        PD_DISABLEPRINTTOFILE = 0x00080000,
        PD_NONETWORKBUTTON = 0x00200000,
        PSD_MINMARGINS = 0x00000001,
        PSD_MARGINS = 0x00000002,
        PSD_INHUNDREDTHSOFMILLIMETERS = 0x00000008,
        PSD_DISABLEMARGINS = 0x00000010,
        PSD_DISABLEPRINTER = 0x00000020,
        PSD_DISABLEORIENTATION = 0x00000100,
        PSD_DISABLEPAPER = 0x00000200,
        PSD_SHOWHELP = 0x00000800,
        PSD_ENABLEPAGESETUPHOOK = 0x00002000,
        PSD_NONETWORKBUTTON = 0x00200000,
        PS_SOLID = 0,
        PS_DOT = 2,
        PLANES = 14,
        PRF_CHECKVISIBLE = 0x00000001,
        PRF_NONCLIENT = 0x00000002,
        PRF_CLIENT = 0x00000004,
        PRF_ERASEBKGND = 0x00000008,
        PRF_CHILDREN = 0x00000010,
        PM_NOREMOVE = 0x0000,
        PM_REMOVE = 0x0001,
        PM_NOYIELD = 0x0002,
        PBM_SETRANGE = (0x0400+1),
        PBM_SETPOS = (0x0400+2),
        PBM_SETSTEP = (0x0400+4),
        PBM_SETRANGE32 = (0x0400+6),
        PSM_SETTITLEA = (0x0400+111),
        PSM_SETTITLEW = (0x0400+120),
        PSM_SETFINISHTEXTA = (0x0400+115),
        PSM_SETFINISHTEXTW = (0x0400+121),
        PATCOPY = 0x00F00021,
        PATINVERT = 0x005A0049;

        public const int QS_KEY = 0x0001,
        QS_MOUSEMOVE = 0x0002,
        QS_MOUSEBUTTON = 0x0004,
        QS_POSTMESSAGE = 0x0008,
        QS_TIMER = 0x0010,
        QS_PAINT = 0x0020,
        QS_SENDMESSAGE = 0x0040,
        QS_HOTKEY = 0x0080,
        QS_ALLPOSTMESSAGE = 0x0100,
        QS_MOUSE = QS_MOUSEMOVE | QS_MOUSEBUTTON,
        QS_INPUT = QS_MOUSE | QS_KEY,
        QS_ALLEVENTS = QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY,
        QS_ALLINPUT = QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE;
        
    //public const int RECO_PASTE = 0x00000000;   // paste from clipboard
    public const int RECO_DROP  = 0x00000001;    // drop
    //public const int RECO_COPY  = 0x00000002;    // copy to the clipboard
    //public const int RECO_CUT   = 0x00000003; // cut to the clipboard
    //public const int RECO_DRAG  = 0x00000004;    // drag
        
    public const int RPC_E_CHANGED_MODE = unchecked((int)0x80010106),
        RGN_DIFF = 4,
        RDW_INVALIDATE = 0x0001,
        RDW_ERASE = 0x0004,
        RDW_ALLCHILDREN = 0x0080,
        RDW_FRAME = 0x0400,
        RB_INSERTBANDA = (0x0400+1),
        RB_INSERTBANDW = (0x0400+10);
        
        public const int stc4 = 0x0443,
        SHGFP_TYPE_CURRENT = 0,
        STGM_READ = 0x00000000,
        STGM_WRITE = 0x00000001,
        STGM_READWRITE = 0x00000002,
        STGM_SHARE_EXCLUSIVE = 0x00000010,
        STGM_CREATE = 0x00001000,
        STARTF_USESHOWWINDOW = 0x00000001,
        SB_HORZ = 0,
        SB_VERT = 1,
        SB_CTL = 2,
        SB_LINEUP = 0,
        SB_LINELEFT = 0,
        SB_LINEDOWN = 1,
        SB_LINERIGHT = 1,
        SB_PAGEUP = 2,
        SB_PAGELEFT = 2,
        SB_PAGEDOWN = 3,
        SB_PAGERIGHT = 3,
        SB_THUMBPOSITION = 4,
        SB_THUMBTRACK = 5,
        SB_LEFT = 6,
        SB_RIGHT = 7,
        SB_ENDSCROLL = 8,
        SB_TOP = 6,
        SB_BOTTOM = 7,
        SORT_DEFAULT =0x0,
        SUBLANG_DEFAULT = 0x01,
        SW_HIDE = 0,
        SW_NORMAL = 1,
        SW_SHOWMINIMIZED = 2,
        SW_SHOWMAXIMIZED = 3,
        SW_MAXIMIZE = 3,
        SW_SHOWNOACTIVATE = 4,
        SW_SHOW = 5,
        SW_MINIMIZE = 6,
        SW_SHOWMINNOACTIVE = 7,
        SW_SHOWNA = 8,
        SW_RESTORE = 9,
        SW_MAX = 10,
        SWP_NOSIZE = 0x0001,
        SWP_NOMOVE = 0x0002,
        SWP_NOZORDER = 0x0004,
        SWP_NOACTIVATE = 0x0010,
        SWP_SHOWWINDOW = 0x0040,
        SWP_HIDEWINDOW = 0x0080,
        SWP_DRAWFRAME = 0x0020,
        SM_CXSCREEN = 0,
        SM_CYSCREEN = 1,
        SM_CXVSCROLL = 2,
        SM_CYHSCROLL = 3,
        SM_CYCAPTION = 4,
        SM_CXBORDER = 5,
        SM_CYBORDER = 6,
        SM_CYVTHUMB = 9,
        SM_CXHTHUMB = 10,
        SM_CXICON = 11,
        SM_CYICON = 12,
        SM_CXCURSOR = 13,
        SM_CYCURSOR = 14,
        SM_CYMENU = 15,
        SM_CYKANJIWINDOW = 18,
        SM_MOUSEPRESENT = 19,
        SM_CYVSCROLL = 20,
        SM_CXHSCROLL = 21,
        SM_DEBUG = 22,
        SM_SWAPBUTTON = 23,
        SM_CXMIN = 28,
        SM_CYMIN = 29,
        SM_CXSIZE = 30,
        SM_CYSIZE = 31,
        SM_CXFRAME = 32,
        SM_CYFRAME = 33,
        SM_CXMINTRACK = 34,
        SM_CYMINTRACK = 35,
        SM_CXDOUBLECLK = 36,
        SM_CYDOUBLECLK = 37,
        SM_CXICONSPACING = 38,
        SM_CYICONSPACING = 39,
        SM_MENUDROPALIGNMENT = 40,
        SM_PENWINDOWS = 41,
        SM_DBCSENABLED = 42,
        SM_CMOUSEBUTTONS = 43,
        SM_CXFIXEDFRAME = 7,
        SM_CYFIXEDFRAME = 8,
        SM_SECURE = 44,
        SM_CXEDGE = 45,
        SM_CYEDGE = 46,
        SM_CXMINSPACING = 47,
        SM_CYMINSPACING = 48,
        SM_CXSMICON = 49,
        SM_CYSMICON = 50,
        SM_CYSMCAPTION = 51,
        SM_CXSMSIZE = 52,
        SM_CYSMSIZE = 53,
        SM_CXMENUSIZE = 54,
        SM_CYMENUSIZE = 55,
        SM_ARRANGE = 56,
        SM_CXMINIMIZED = 57,
        SM_CYMINIMIZED = 58,
        SM_CXMAXTRACK = 59,
        SM_CYMAXTRACK = 60,
        SM_CXMAXIMIZED = 61,
        SM_CYMAXIMIZED = 62,
        SM_NETWORK = 63,
        SM_CLEANBOOT = 67,
        SM_CXDRAG = 68,
        SM_CYDRAG = 69,
        SM_SHOWSOUNDS = 70,
        SM_CXMENUCHECK = 71,
        SM_CYMENUCHECK = 72,
        SM_MIDEASTENABLED = 74,
        SM_MOUSEWHEELPRESENT = 75,
        SM_XVIRTUALSCREEN = 76,
        SM_YVIRTUALSCREEN = 77,
        SM_CXVIRTUALSCREEN = 78,
        SM_CYVIRTUALSCREEN = 79,
        SM_CMONITORS = 80,
        SM_SAMEDISPLAYFORMAT = 81,
        SM_REMOTESESSION = 0x1000;
        
        public const int SW_SCROLLCHILDREN = 0x0001,
        SW_INVALIDATE = 0x0002,
        SW_ERASE = 0x0004,
        SC_SIZE = 0xF000,
        SC_MINIMIZE = 0xF020,
        SC_MAXIMIZE = 0xF030,
        SC_CLOSE = 0xF060,
        SC_KEYMENU = 0xF100,
        SC_RESTORE = 0xF120,
        SS_LEFT = 0x00000000,
        SS_CENTER = 0x00000001,
        SS_RIGHT = 0x00000002,
        SS_OWNERDRAW = 0x0000000D,
        SS_NOPREFIX = 0x00000080,
        SS_SUNKEN = 0x00001000,
        SBS_HORZ = 0x0000,
        SBS_VERT = 0x0001,
        SIF_RANGE = 0x0001,
        SIF_PAGE = 0x0002,
        SIF_POS = 0x0004,
        SIF_TRACKPOS = 0x0010,
        SIF_ALL = (0x0001|0x0002|0x0004|0x0010),
        SPI_GETDRAGFULLWINDOWS = 38,
        SPI_GETNONCLIENTMETRICS = 41,
        SPI_GETWORKAREA = 48,
        SPI_GETHIGHCONTRAST = 66,
        SPI_GETDEFAULTINPUTLANG = 89,
        SPI_GETSNAPTODEFBUTTON = 95,
        SPI_GETWHEELSCROLLLINES = 104,
        SBARS_SIZEGRIP = 0x0100,
        SB_SETTEXTA = (0x0400+1),
        SB_SETTEXTW = (0x0400+11),
        SB_GETTEXTA = (0x0400+2),
        SB_GETTEXTW = (0x0400+13),
        SB_GETTEXTLENGTHA = (0x0400+3),
        SB_GETTEXTLENGTHW = (0x0400+12),
        SB_SETPARTS = (0x0400+4),
        SB_SIMPLE = (0x0400+9),
        SB_GETRECT = (0x0400+10),
        SB_SETICON = (0x0400+15),
        SB_SETTIPTEXTA = (0x0400+16),
        SB_SETTIPTEXTW = (0x0400+17),
        SB_GETTIPTEXTA = (0x0400+18),
        SB_GETTIPTEXTW = (0x0400+19),
        SBT_OWNERDRAW = 0x1000,
        SBT_NOBORDERS = 0x0100,
        SBT_POPOUT = 0x0200,
        SBT_RTLREADING = 0x0400,
        SRCCOPY = 0x00CC0020,
        STATFLAG_DEFAULT = 0x0,
        STATFLAG_NONAME = 0x1,
        STATFLAG_NOOPEN = 0x2,
        STGC_DEFAULT = 0x0,
        STGC_OVERWRITE = 0x1,
        STGC_ONLYIFCURRENT = 0x2,
        STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 0x4,
        STREAM_SEEK_SET = 0x0,
        STREAM_SEEK_CUR = 0x1,
        STREAM_SEEK_END = 0x2;

        public const int S_OK =      0x00000000;
        public const int S_FALSE =   0x00000001;

        public static bool Succeeded(int hr) {
            return(hr >= 0);
        }

        public static bool Failed(int hr) {
            return(hr < 0);
        }

        public const int TRANSPARENT = 1,
        TME_HOVER = 0x00000001,
        TME_LEAVE = 0x00000002,
        TPM_LEFTBUTTON = 0x0000,
        TPM_LEFTALIGN = 0x0000,
        TPM_VERTICAL = 0x0040,
        TV_FIRST = 0x1100,
        TBSTATE_CHECKED = 0x01,
        TBSTATE_ENABLED = 0x04,
        TBSTATE_HIDDEN = 0x08,
        TBSTATE_INDETERMINATE = 0x10,
        TBSTYLE_BUTTON = 0x00,
        TBSTYLE_SEP = 0x01,
        TBSTYLE_CHECK = 0x02,
        TBSTYLE_DROPDOWN = 0x08,
        TBSTYLE_TOOLTIPS = 0x0100,
        TBSTYLE_FLAT = 0x0800,
        TBSTYLE_LIST = 0x1000,
        TBSTYLE_EX_DRAWDDARROWS = 0x00000001,
        TB_ENABLEBUTTON = (0x0400+1),
        TB_ISBUTTONCHECKED = (0x0400+10),
        TB_ISBUTTONINDETERMINATE = (0x0400+13),
        TB_ADDBUTTONSA = (0x0400+20),
        TB_ADDBUTTONSW = (0x0400+68),
        TB_INSERTBUTTONA = (0x0400+21),
        TB_INSERTBUTTONW = (0x0400+67),
        TB_DELETEBUTTON = (0x0400+22),
        TB_GETBUTTON = (0x0400+23),
        TB_SAVERESTOREA = (0x0400+26),
        TB_SAVERESTOREW = (0x0400+76),
        TB_ADDSTRINGA = (0x0400+28),
        TB_ADDSTRINGW = (0x0400+77),
        TB_BUTTONSTRUCTSIZE = (0x0400+30),
        TB_SETBUTTONSIZE = (0x0400+31),
        TB_AUTOSIZE = (0x0400+33),
        TB_GETROWS = (0x0400+40),
        TB_GETBUTTONTEXTA = (0x0400+45),
        TB_GETBUTTONTEXTW = (0x0400+75),
        TB_SETIMAGELIST = (0x0400+48),
        TB_GETRECT = (0x0400+51),
        TB_GETBUTTONSIZE = (0x0400+58),
        TB_GETBUTTONINFOW = (0x0400+63),
        TB_SETBUTTONINFOW = (0x0400+64),
        TB_GETBUTTONINFOA = (0x0400+65),
        TB_SETBUTTONINFOA = (0x0400+66),
        TB_MAPACCELERATORA = (0x0400+78),
        TB_SETEXTENDEDSTYLE = (0x0400+84),
        TB_MAPACCELERATORW = (0x0400+90),
        TBIF_IMAGE = 0x00000001,
        TBIF_TEXT = 0x00000002,
        TBIF_STATE = 0x00000004,
        TBIF_STYLE = 0x00000008,
        TBIF_COMMAND = 0x00000020,
        TBIF_SIZE = 0x00000040,
        TBN_GETBUTTONINFOA = ((0-700)-0),
        TBN_GETBUTTONINFOW = ((0-700)-20),
        TBN_QUERYINSERT = ((0-700)-6),
        TBN_DROPDOWN = ((0-700)-10),
        TBN_GETDISPINFOA = ((0-700)-16),
        TBN_GETDISPINFOW = ((0-700)-17),
        TBN_GETINFOTIPA = ((0-700)-18),
        TBN_GETINFOTIPW = ((0-700)-19),
        TTS_ALWAYSTIP = 0x01,
        //TTS_NOANIMATE           =0x10,
        //TTS_NOFADE              =0x20,
        TTS_BALLOON             =0x40,
        //TTI_NONE                =0,
        //TTI_INFO                =1,
        TTI_WARNING             =2,
        //TTI_ERROR               =3,
        TTF_IDISHWND = 0x0001,
        TTF_RTLREADING = 0x0004,
        TTF_TRACK = 0x0020,
        TTF_SUBCLASS = 0x0010,
        TTF_TRANSPARENT = 0x0100,
        TTDT_AUTOMATIC = 0,
        TTDT_RESHOW = 1,
        TTDT_AUTOPOP = 2,
        TTDT_INITIAL = 3,
        TTM_TRACKACTIVATE = (0x0400+17),
        TTM_TRACKPOSITION = (0x0400+18),
        TTM_ACTIVATE = (0x0400+1),
        TTM_ADJUSTRECT = (0x400 + 31),
        TTM_SETDELAYTIME = (0x0400+3),
        TTM_SETTITLEA           =(WM_USER + 32),  // wParam = TTI_*, lParam = char* szTitle
        TTM_SETTITLEW           =(WM_USER + 33), // wParam = TTI_*, lParam = wchar* szTitle
        TTM_ADDTOOLA = (0x0400+4),
        TTM_ADDTOOLW = (0x0400+50),
        TTM_DELTOOLA = (0x0400+5),
        TTM_DELTOOLW = (0x0400+51),
        TTM_NEWTOOLRECTA = (0x0400+6),
        TTM_NEWTOOLRECTW = (0x0400+52),
        TTM_RELAYEVENT = (0x0400+7),
        TTM_GETTOOLINFOA = (0x0400+8),
        TTM_GETTOOLINFOW = (0x0400+53),
        TTM_SETTOOLINFOA = (0x0400+9),
        TTM_SETTOOLINFOW = (0x0400+54),
        TTM_HITTESTA = (0x0400+10),
        TTM_HITTESTW = (0x0400+55),
        TTM_GETTEXTA = (0x0400+11),
        TTM_GETTEXTW = (0x0400+56),
        TTM_UPDATE = (0x0400+29),
        TTM_UPDATETIPTEXTA = (0x0400+12),
        TTM_UPDATETIPTEXTW = (0x0400+57),
        TTM_ENUMTOOLSA = (0x0400+14),
        TTM_ENUMTOOLSW = (0x0400+58),
        TTM_GETCURRENTTOOLA = (0x0400+15),
        TTM_GETCURRENTTOOLW = (0x0400+59),
        TTM_WINDOWFROMPOINT = (0x0400+16),
        TTM_GETDELAYTIME = (0x0400+21),
        TTM_SETMAXTIPWIDTH = (0x0400+24),
        TTN_GETDISPINFOA = ((0-520)-0),
        TTN_GETDISPINFOW = ((0-520)-10),
        TTN_SHOW = ((0-520)-1),
        TTN_POP = ((0-520)-2),
        TTN_NEEDTEXTA = ((0-520)-0),
        TTN_NEEDTEXTW = ((0-520)-10),
        TBS_AUTOTICKS = 0x0001,
        TBS_VERT = 0x0002,
        TBS_TOP = 0x0004,
        TBS_BOTTOM = 0x0000,
        TBS_BOTH = 0x0008,
        TBS_NOTICKS = 0x0010,
        TBM_GETPOS = (0x0400),
        TBM_SETTIC = (0x0400+4),
        TBM_SETPOS = (0x0400+5),
        TBM_SETRANGE = (0x0400+6),
        TBM_SETRANGEMIN = (0x0400+7),
        TBM_SETRANGEMAX = (0x0400+8),
        TBM_SETTICFREQ = (0x0400+20),
        TBM_SETPAGESIZE = (0x0400+21),
        TBM_SETLINESIZE = (0x0400+23),
        TB_LINEUP = 0,
        TB_LINEDOWN = 1,
        TB_PAGEUP = 2,
        TB_PAGEDOWN = 3,
        TB_THUMBPOSITION = 4,
        TB_THUMBTRACK = 5,
        TB_TOP = 6,
        TB_BOTTOM = 7,
        TB_ENDTRACK = 8,
        TVS_HASBUTTONS = 0x0001,
        TVS_HASLINES = 0x0002,
        TVS_LINESATROOT = 0x0004,
        TVS_EDITLABELS = 0x0008,
        TVS_SHOWSELALWAYS = 0x0020,
        TVS_RTLREADING = 0x0040,
        TVS_CHECKBOXES = 0x0100,
        TVS_TRACKSELECT = 0x0200,
        TVS_FULLROWSELECT = 0x1000,
        TVIF_TEXT = 0x0001,
        TVIF_IMAGE = 0x0002,
        TVIF_STATE = 0x0008,
        TVIF_HANDLE = 0x0010,
        TVIF_SELECTEDIMAGE = 0x0020,
        TVIS_SELECTED = 0x0002,
        TVIS_EXPANDED = 0x0020,
        TVIS_EXPANDEDONCE = 0x0040,
        TVIS_STATEIMAGEMASK = 0xF000,
        TVI_ROOT = (unchecked((int)0xFFFF0000)),
        TVI_FIRST = (unchecked((int)0xFFFF0001)),
        TVM_INSERTITEMA = (0x1100+0),
        TVM_INSERTITEMW = (0x1100+50),
        TVM_DELETEITEM = (0x1100+1),
        TVM_EXPAND = (0x1100+2),
        TVE_COLLAPSE = 0x0001,
        TVE_EXPAND = 0x0002,
        TVM_GETITEMRECT = (0x1100+4),
        TVM_GETINDENT = (0x1100+6),
        TVM_SETINDENT = (0x1100+7),
        TVM_SETIMAGELIST = (0x1100+9),
        TVM_GETNEXTITEM = (0x1100+10),
        TVGN_NEXT = 0x0001,
        TVGN_PREVIOUS = 0x0002,
        TVGN_FIRSTVISIBLE = 0x0005,
        TVGN_NEXTVISIBLE = 0x0006,
        TVGN_PREVIOUSVISIBLE = 0x0007,
        TVGN_CARET = 0x0009,
        TVM_SELECTITEM = (0x1100+11),
        TVM_GETITEMA = (0x1100+12),
        TVM_GETITEMW = (0x1100+62),
        TVM_SETITEMA = (0x1100+13),
        TVM_SETITEMW = (0x1100+63),
        TVM_EDITLABELA = (0x1100+14),
        TVM_EDITLABELW = (0x1100+65),
        TVM_GETEDITCONTROL = (0x1100+15),
        TVM_GETVISIBLECOUNT = (0x1100+16),
        TVM_HITTEST = (0x1100+17),
        TVHT_ONITEMSTATEICON = 0x0040,
        TVM_ENSUREVISIBLE = (0x1100+20),
        TVM_ENDEDITLABELNOW = (0x1100+22),
        TVM_GETISEARCHSTRINGA = (0x1100+23),
        TVM_GETISEARCHSTRINGW = (0x1100+64),
        TVM_SETITEMHEIGHT = (0x1100+27),
        TVM_GETITEMHEIGHT = (0x1100+28),
        TVN_SELCHANGINGA = ((0-400)-1),
        TVN_SELCHANGINGW = ((0-400)-50),
        TVN_SELCHANGEDA = ((0-400)-2),
        TVN_SELCHANGEDW = ((0-400)-51),
        TVC_UNKNOWN = 0x0000,
        TVC_BYMOUSE = 0x0001,
        TVC_BYKEYBOARD = 0x0002,
        TVN_GETDISPINFOA = ((0-400)-3),
        TVN_GETDISPINFOW = ((0-400)-52),
        TVN_SETDISPINFOA = ((0-400)-4),
        TVN_SETDISPINFOW = ((0-400)-53),
        TVN_ITEMEXPANDINGA = ((0-400)-5),
        TVN_ITEMEXPANDINGW = ((0-400)-54),
        TVN_ITEMEXPANDEDA = ((0-400)-6),
        TVN_ITEMEXPANDEDW = ((0-400)-55),
        TVN_BEGINDRAGA = ((0-400)-7),
        TVN_BEGINDRAGW = ((0-400)-56),
        TVN_BEGINRDRAGA = ((0-400)-8),
        TVN_BEGINRDRAGW = ((0-400)-57),
        TVN_BEGINLABELEDITA = ((0-400)-10),
        TVN_BEGINLABELEDITW = ((0-400)-59),
        TVN_ENDLABELEDITA = ((0-400)-11),
        TVN_ENDLABELEDITW = ((0-400)-60),
        TCS_BOTTOM = 0x0002,
        TCS_RIGHT = 0x0002,
        TCS_FLATBUTTONS = 0x0008,
        TCS_HOTTRACK = 0x0040,
        TCS_VERTICAL = 0x0080,
        TCS_TABS = 0x0000,
        TCS_BUTTONS = 0x0100,
        TCS_MULTILINE = 0x0200,
        TCS_RIGHTJUSTIFY = 0x0000,
        TCS_FIXEDWIDTH = 0x0400,
        TCS_RAGGEDRIGHT = 0x0800,
        TCS_OWNERDRAWFIXED = 0x2000,
        TCS_TOOLTIPS = 0x4000,
        TCM_SETIMAGELIST = (0x1300+3),
        TCIF_TEXT = 0x0001,
        TCIF_IMAGE = 0x0002,
        TCM_GETITEMA = (0x1300+5),
        TCM_GETITEMW = (0x1300+60),
        TCM_SETITEMA = (0x1300+6),
        TCM_SETITEMW = (0x1300+61),
        TCM_INSERTITEMA = (0x1300+7),
        TCM_INSERTITEMW = (0x1300+62),
        TCM_DELETEITEM = (0x1300+8),
        TCM_DELETEALLITEMS = (0x1300+9),
        TCM_GETITEMRECT = (0x1300+10),
        TCM_GETCURSEL = (0x1300+11),
        TCM_SETCURSEL = (0x1300+12),
        TCM_ADJUSTRECT = (0x1300+40),
        TCM_SETITEMSIZE = (0x1300+41),
        TCM_SETPADDING = (0x1300+43),
        TCM_GETROWCOUNT = (0x1300+44),
        TCM_GETTOOLTIPS = (0x1300+45),
        TCN_SELCHANGE = ((0-550)-1),
        TCN_SELCHANGING = ((0-550)-2),
        TVHT_ONITEM = (0x0002|0x0004|0x0040),
        TBSTYLE_WRAPPABLE = 0x0200,
        TVM_SETBKCOLOR = (TV_FIRST + 29),
        TVM_SETTEXTCOLOR = (TV_FIRST + 30);

        public const int UIS_SET = 1,
        UIS_CLEAR = 2,
        UIS_INITIALIZE = 3,
        UISF_HIDEFOCUS = 0x1,
        UISF_HIDEACCEL = 0x2,
        USERCLASSTYPE_FULL = 1,
        UOI_FLAGS = 1;
        
        public const int VIEW_E_DRAW = unchecked((int)0x80040140),
        VK_TAB = 0x09,
        VK_SHIFT = 0x10,
        VK_CONTROL = 0x11,
        VK_MENU = 0x12;

        public const int WH_JOURNALPLAYBACK = 1,
        WH_GETMESSAGE = 3,
        WH_MOUSE = 7,
        WSF_VISIBLE = 0x0001,
        WM_NULL = 0x0000,
        WM_CREATE = 0x0001,
        WM_DELETEITEM = 0x002D,
        WM_DESTROY = 0x0002,
        WM_MOVE = 0x0003,
        WM_SIZE = 0x0005,
        WM_ACTIVATE = 0x0006,
        WA_INACTIVE = 0,
        WA_ACTIVE = 1,
        WA_CLICKACTIVE = 2,
        WM_SETFOCUS = 0x0007,
        WM_KILLFOCUS = 0x0008,
        WM_ENABLE = 0x000A,
        WM_SETREDRAW = 0x000B,
        WM_SETTEXT = 0x000C,
        WM_GETTEXT = 0x000D,
        WM_GETTEXTLENGTH = 0x000E,
        WM_PAINT = 0x000F,
        WM_CLOSE = 0x0010,
        WM_QUERYENDSESSION = 0x0011,
        WM_QUIT = 0x0012,
        WM_QUERYOPEN = 0x0013,
        WM_ERASEBKGND = 0x0014,
        WM_SYSCOLORCHANGE = 0x0015,
        WM_ENDSESSION = 0x0016,
        WM_SHOWWINDOW = 0x0018,
        WM_WININICHANGE = 0x001A,
        WM_SETTINGCHANGE = 0x001A,
        WM_DEVMODECHANGE = 0x001B,
        WM_ACTIVATEAPP = 0x001C,
        WM_FONTCHANGE = 0x001D,
        WM_TIMECHANGE = 0x001E,
        WM_CANCELMODE = 0x001F,
        WM_SETCURSOR = 0x0020,
        WM_MOUSEACTIVATE = 0x0021,
        WM_CHILDACTIVATE = 0x0022,
        WM_QUEUESYNC = 0x0023,
        WM_GETMINMAXINFO = 0x0024,
        WM_PAINTICON = 0x0026,
        WM_ICONERASEBKGND = 0x0027,
        WM_NEXTDLGCTL = 0x0028,
        WM_SPOOLERSTATUS = 0x002A,
        WM_DRAWITEM = 0x002B,
        WM_MEASUREITEM = 0x002C,
        WM_VKEYTOITEM = 0x002E,
        WM_CHARTOITEM = 0x002F,
        WM_SETFONT = 0x0030,
        WM_GETFONT = 0x0031,
        WM_SETHOTKEY = 0x0032,
        WM_GETHOTKEY = 0x0033,
        WM_QUERYDRAGICON = 0x0037,
        WM_COMPAREITEM = 0x0039,
        WM_GETOBJECT = 0x003D,
        WM_COMPACTING = 0x0041,
        WM_COMMNOTIFY = 0x0044,
        WM_WINDOWPOSCHANGING = 0x0046,
        WM_WINDOWPOSCHANGED = 0x0047,
        WM_POWER = 0x0048,
        WM_COPYDATA = 0x004A,
        WM_CANCELJOURNAL = 0x004B,
        WM_NOTIFY = 0x004E,
        WM_INPUTLANGCHANGEREQUEST = 0x0050,
        WM_INPUTLANGCHANGE = 0x0051,
        WM_TCARD = 0x0052,
        WM_HELP = 0x0053,
        WM_USERCHANGED = 0x0054,
        WM_NOTIFYFORMAT = 0x0055,
        WM_CONTEXTMENU = 0x007B,
        WM_STYLECHANGING = 0x007C,
        WM_STYLECHANGED = 0x007D,
        WM_DISPLAYCHANGE = 0x007E,
        WM_GETICON = 0x007F,
        WM_SETICON = 0x0080,
        WM_NCCREATE = 0x0081,
        WM_NCDESTROY = 0x0082,
        WM_NCCALCSIZE = 0x0083,
        WM_NCHITTEST = 0x0084,
        WM_NCPAINT = 0x0085,
        WM_NCACTIVATE = 0x0086,
        WM_GETDLGCODE = 0x0087,
        WM_NCMOUSEMOVE = 0x00A0,
        WM_NCLBUTTONDOWN = 0x00A1,
        WM_NCLBUTTONUP = 0x00A2,
        WM_NCLBUTTONDBLCLK = 0x00A3,
        WM_NCRBUTTONDOWN = 0x00A4,
        WM_NCRBUTTONUP = 0x00A5,
        WM_NCRBUTTONDBLCLK = 0x00A6,
        WM_NCMBUTTONDOWN = 0x00A7,
        WM_NCMBUTTONUP = 0x00A8,
        WM_NCMBUTTONDBLCLK = 0x00A9,
        WM_NCXBUTTONDOWN               = 0x00AB,
        WM_NCXBUTTONUP                 = 0x00AC,
        WM_NCXBUTTONDBLCLK             = 0x00AD,
        WM_KEYFIRST = 0x0100,
        WM_KEYDOWN = 0x0100,
        WM_KEYUP = 0x0101,
        WM_CHAR = 0x0102,
        WM_DEADCHAR = 0x0103,
        WM_CTLCOLOR = 0x0019,
        WM_SYSKEYDOWN = 0x0104,
        WM_SYSKEYUP = 0x0105,
        WM_SYSCHAR = 0x0106,
        WM_SYSDEADCHAR = 0x0107,
        WM_KEYLAST = 0x0108,
        WM_IME_STARTCOMPOSITION = 0x010D,
        WM_IME_ENDCOMPOSITION = 0x010E,
        WM_IME_COMPOSITION = 0x010F,
        WM_IME_KEYLAST = 0x010F,
        WM_INITDIALOG = 0x0110,
        WM_COMMAND = 0x0111,
        WM_SYSCOMMAND = 0x0112,
        WM_TIMER = 0x0113,
        WM_HSCROLL = 0x0114,
        WM_VSCROLL = 0x0115,
        WM_INITMENU = 0x0116,
        WM_INITMENUPOPUP = 0x0117,
        WM_MENUSELECT = 0x011F,
        WM_MENUCHAR = 0x0120,
        WM_ENTERIDLE = 0x0121,
        WM_CHANGEUISTATE = 0x0127,
        WM_UPDATEUISTATE = 0x0128,
        WM_QUERYUISTATE = 0x0129,
        WM_CTLCOLORMSGBOX = 0x0132,
        WM_CTLCOLOREDIT = 0x0133,
        WM_CTLCOLORLISTBOX = 0x0134,
        WM_CTLCOLORBTN = 0x0135,
        WM_CTLCOLORDLG = 0x0136,
        WM_CTLCOLORSCROLLBAR = 0x0137,
        WM_CTLCOLORSTATIC = 0x0138,
        WM_MOUSEFIRST = 0x0200,
        WM_MOUSEMOVE = 0x0200,
        WM_LBUTTONDOWN = 0x0201,
        WM_LBUTTONUP = 0x0202,
        WM_LBUTTONDBLCLK = 0x0203,
        WM_RBUTTONDOWN = 0x0204,
        WM_RBUTTONUP = 0x0205,
        WM_RBUTTONDBLCLK = 0x0206,
        WM_MBUTTONDOWN = 0x0207,
        WM_MBUTTONUP = 0x0208,
        WM_MBUTTONDBLCLK = 0x0209,
        WM_XBUTTONDOWN                 = 0x020B,
        WM_XBUTTONUP                   = 0x020C,
        WM_XBUTTONDBLCLK               = 0x020D,
        WM_MOUSEWHEEL = 0x020A,
        WM_MOUSELAST = 0x020A;
        
        public const int WHEEL_DELTA = 120,
        WM_PARENTNOTIFY = 0x0210,
        WM_ENTERMENULOOP = 0x0211,
        WM_EXITMENULOOP = 0x0212,
        WM_NEXTMENU = 0x0213,
        WM_SIZING = 0x0214,
        WM_CAPTURECHANGED = 0x0215,
        WM_MOVING = 0x0216,
        WM_POWERBROADCAST = 0x0218,
        WM_DEVICECHANGE = 0x0219,
        WM_IME_SETCONTEXT = 0x0281,
        WM_IME_NOTIFY = 0x0282,
        WM_IME_CONTROL = 0x0283,
        WM_IME_COMPOSITIONFULL = 0x0284,
        WM_IME_SELECT = 0x0285,
        WM_IME_CHAR = 0x0286,
        WM_IME_KEYDOWN = 0x0290,
        WM_IME_KEYUP = 0x0291,
        WM_MDICREATE = 0x0220,
        WM_MDIDESTROY = 0x0221,
        WM_MDIACTIVATE = 0x0222,
        WM_MDIRESTORE = 0x0223,
        WM_MDINEXT = 0x0224,
        WM_MDIMAXIMIZE = 0x0225,
        WM_MDITILE = 0x0226,
        WM_MDICASCADE = 0x0227,
        WM_MDIICONARRANGE = 0x0228,
        WM_MDIGETACTIVE = 0x0229,
        WM_MDISETMENU = 0x0230,
        WM_ENTERSIZEMOVE = 0x0231,
        WM_EXITSIZEMOVE = 0x0232,
        WM_DROPFILES = 0x0233,
        WM_MDIREFRESHMENU = 0x0234,
        WM_MOUSEHOVER = 0x02A1,
        WM_MOUSELEAVE = 0x02A3,
        WM_CUT = 0x0300,
        WM_COPY = 0x0301,
        WM_PASTE = 0x0302,
        WM_CLEAR = 0x0303,
        WM_UNDO = 0x0304,
        WM_RENDERFORMAT = 0x0305,
        WM_RENDERALLFORMATS = 0x0306,
        WM_DESTROYCLIPBOARD = 0x0307,
        WM_DRAWCLIPBOARD = 0x0308,
        WM_PAINTCLIPBOARD = 0x0309,
        WM_VSCROLLCLIPBOARD = 0x030A,
        WM_SIZECLIPBOARD = 0x030B,
        WM_ASKCBFORMATNAME = 0x030C,
        WM_CHANGECBCHAIN = 0x030D,
        WM_HSCROLLCLIPBOARD = 0x030E,
        WM_QUERYNEWPALETTE = 0x030F,
        WM_PALETTEISCHANGING = 0x0310,
        WM_PALETTECHANGED = 0x0311,
        WM_HOTKEY = 0x0312,
        WM_PRINT = 0x0317,
        WM_PRINTCLIENT = 0x0318,
        WM_HANDHELDFIRST = 0x0358,
        WM_HANDHELDLAST = 0x035F,
        WM_AFXFIRST = 0x0360,
        WM_AFXLAST = 0x037F,
        WM_PENWINFIRST = 0x0380,
        WM_PENWINLAST = 0x038F,
        WM_APP = unchecked((int)0x8000),
        WM_USER = 0x0400,
        WM_REFLECT = NativeMethods.WM_USER + 0x1C00,
        WS_OVERLAPPED = 0x00000000,
        WS_POPUP = unchecked((int)0x80000000),
        WS_CHILD = 0x40000000,
        WS_MINIMIZE = 0x20000000,
        WS_VISIBLE = 0x10000000,
        WS_DISABLED = 0x08000000,
        WS_CLIPSIBLINGS = 0x04000000,
        WS_CLIPCHILDREN = 0x02000000,
        WS_MAXIMIZE = 0x01000000,
        WS_CAPTION = 0x00C00000,
        WS_BORDER = 0x00800000,
        WS_DLGFRAME = 0x00400000,
        WS_VSCROLL = 0x00200000,
        WS_HSCROLL = 0x00100000,
        WS_SYSMENU = 0x00080000,
        WS_THICKFRAME = 0x00040000,
        WS_TABSTOP = 0x00010000,
        WS_MINIMIZEBOX = 0x00020000,
        WS_MAXIMIZEBOX = 0x00010000,
        WS_EX_DLGMODALFRAME = 0x00000001,
        WS_EX_MDICHILD = 0x00000040,
        WS_EX_TOOLWINDOW = 0x00000080,
        WS_EX_CLIENTEDGE = 0x00000200,
        WS_EX_CONTEXTHELP = 0x00000400,
        WS_EX_RIGHT = 0x00001000,
        WS_EX_LEFT = 0x00000000,
        WS_EX_RTLREADING = 0x00002000,
        WS_EX_LEFTSCROLLBAR = 0x00004000,
        WS_EX_CONTROLPARENT = 0x00010000,
        WS_EX_STATICEDGE = 0x00020000,
        WS_EX_APPWINDOW = 0x00040000,
        WS_EX_LAYERED           = 0x00080000,
        WS_EX_TOPMOST = 0x00000008,
        WPF_SETMINPOSITION = 0x0001,
        WM_CHOOSEFONT_GETLOGFONT = (0x0400+1);

        private static int wmMouseEnterMessage = -1;
        public static int WM_MOUSEENTER {
           get {
              if (wmMouseEnterMessage == -1) {
                  wmMouseEnterMessage = SafeNativeMethods.RegisterWindowMessage("WinFormsMouseEnter");
              }
              return wmMouseEnterMessage;
           }
        }

        public const int XBUTTON1    =  0x0001;
        public const int XBUTTON2    =  0x0002;


        // These are initialized in a static constructor for speed.  That way we don't have to
        // evaluate the char size each time.
        //
        public static readonly int CBEM_GETITEM;
        public static readonly int CBEM_SETITEM;
        public static readonly int CBEN_ENDEDIT;
        public static readonly int CBEM_INSERTITEM;
        public static readonly int LVM_GETITEMTEXT;
        public static readonly int LVM_SETITEMTEXT;
        public static readonly int ACM_OPEN;
        public static readonly int DTM_SETFORMAT;
        public static readonly int DTN_USERSTRING;
        public static readonly int DTN_WMKEYDOWN;
        public static readonly int DTN_FORMAT;
        public static readonly int DTN_FORMATQUERY;
        public static readonly int EMR_POLYTEXTOUT;
        public static readonly int HDM_INSERTITEM;
        public static readonly int HDM_GETITEM;
        public static readonly int HDM_SETITEM;
        public static readonly int HDN_ITEMCHANGING;
        public static readonly int HDN_ITEMCHANGED;
        public static readonly int HDN_ITEMCLICK;
        public static readonly int HDN_ITEMDBLCLICK;
        public static readonly int HDN_DIVIDERDBLCLICK;
        public static readonly int HDN_BEGINTRACK;
        public static readonly int HDN_ENDTRACK;
        public static readonly int HDN_TRACK;
        public static readonly int HDN_GETDISPINFO;
        public static readonly int LVM_GETITEM;
        public static readonly int LVM_SETITEM;
        public static readonly int LVM_INSERTITEM;
        public static readonly int LVM_FINDITEM;
        public static readonly int LVM_GETSTRINGWIDTH;
        public static readonly int LVM_EDITLABEL;
        public static readonly int LVM_GETCOLUMN;
        public static readonly int LVM_SETCOLUMN;
        public static readonly int LVM_GETISEARCHSTRING;
        public static readonly int LVM_INSERTCOLUMN;
        public static readonly int LVN_BEGINLABELEDIT;
        public static readonly int LVN_ENDLABELEDIT;
        public static readonly int LVN_ODFINDITEM;
        public static readonly int LVN_GETDISPINFO;
        public static readonly int LVN_SETDISPINFO;
        public static readonly int PSM_SETTITLE;
        public static readonly int PSM_SETFINISHTEXT;
        public static readonly int RB_INSERTBAND;
        public static readonly int SB_SETTEXT;
        public static readonly int SB_GETTEXT;
        public static readonly int SB_GETTEXTLENGTH;
        public static readonly int SB_SETTIPTEXT;
        public static readonly int SB_GETTIPTEXT;
        public static readonly int TB_SAVERESTORE;
        public static readonly int TB_ADDSTRING;
        public static readonly int TB_GETBUTTONTEXT;
        public static readonly int TB_MAPACCELERATOR;
        public static readonly int TB_GETBUTTONINFO;
        public static readonly int TB_SETBUTTONINFO;
        public static readonly int TB_INSERTBUTTON;
        public static readonly int TB_ADDBUTTONS;
        public static readonly int TBN_GETBUTTONINFO;
        public static readonly int TBN_GETINFOTIP;
        public static readonly int TBN_GETDISPINFO;
        public static readonly int TTM_ADDTOOL;
        public static readonly int TTM_SETTITLE;
        public static readonly int TTM_DELTOOL;
        public static readonly int TTM_NEWTOOLRECT;
        public static readonly int TTM_GETTOOLINFO;
        public static readonly int TTM_SETTOOLINFO;
        public static readonly int TTM_HITTEST;
        public static readonly int TTM_GETTEXT;
        public static readonly int TTM_UPDATETIPTEXT;
        public static readonly int TTM_ENUMTOOLS;
        public static readonly int TTM_GETCURRENTTOOL;
        public static readonly int TTN_GETDISPINFO;
        public static readonly int TTN_NEEDTEXT;
        public static readonly int TVM_INSERTITEM;
        public static readonly int TVM_GETITEM;
        public static readonly int TVM_SETITEM;
        public static readonly int TVM_EDITLABEL;
        public static readonly int TVM_GETISEARCHSTRING;
        public static readonly int TVN_SELCHANGING;
        public static readonly int TVN_SELCHANGED;
        public static readonly int TVN_GETDISPINFO;
        public static readonly int TVN_SETDISPINFO;
        public static readonly int TVN_ITEMEXPANDING;
        public static readonly int TVN_ITEMEXPANDED;
        public static readonly int TVN_BEGINDRAG;
        public static readonly int TVN_BEGINRDRAG;
        public static readonly int TVN_BEGINLABELEDIT;
        public static readonly int TVN_ENDLABELEDIT;
        public static readonly int TCM_GETITEM;
        public static readonly int TCM_SETITEM;
        public static readonly int TCM_INSERTITEM;

        public const string TOOLTIPS_CLASS = "tooltips_class32";
        
        public const string WC_DATETIMEPICK = "SysDateTimePick32",
        WC_LISTVIEW = "SysListView32",
        WC_MONTHCAL = "SysMonthCal32",
        WC_PROGRESS = "msctls_progress32",
        WC_STATUSBAR = "msctls_statusbar32",
        WC_TOOLBAR = "ToolbarWindow32",
        WC_TRACKBAR = "msctls_trackbar32",
        WC_TREEVIEW = "SysTreeView32",
        WC_TABCONTROL = "SysTabControl32",
        MSH_MOUSEWHEEL = "MSWHEEL_ROLLMSG",
        MSH_SCROLL_LINES = "MSH_SCROLL_LINES_MSG",
        MOUSEZ_CLASSNAME = "MouseZ",
        MOUSEZ_TITLE = "Magellan MSWHEEL";

        public const int CHILDID_SELF = 0;
        public const int OBJID_CLIENT = unchecked(unchecked((int)0xFFFFFFFC));
        public const string uuid_IAccessible  = "{618736E0-3C3D-11CF-810C-00AA00389B71}";
        public const string uuid_IEnumVariant = "{00020404-0000-0000-C000-000000000046}";
        
        static NativeMethods() {
            if (Marshal.SystemDefaultCharSize == 1) {
                CBEM_GETITEM = NativeMethods.CBEM_GETITEMA;
                CBEM_SETITEM = NativeMethods.CBEM_SETITEMA;
                CBEN_ENDEDIT = NativeMethods.CBEN_ENDEDITA;
                CBEM_INSERTITEM = NativeMethods.CBEM_INSERTITEMA;
                LVM_GETITEMTEXT = NativeMethods.LVM_GETITEMTEXTA;
                LVM_SETITEMTEXT = NativeMethods.LVM_SETITEMTEXTA;
                ACM_OPEN = NativeMethods.ACM_OPENA;
                DTM_SETFORMAT = NativeMethods.DTM_SETFORMATA;
                DTN_USERSTRING = NativeMethods.DTN_USERSTRINGA;
                DTN_WMKEYDOWN = NativeMethods.DTN_WMKEYDOWNA;
                DTN_FORMAT = NativeMethods.DTN_FORMATA;
                DTN_FORMATQUERY = NativeMethods.DTN_FORMATQUERYA;
                EMR_POLYTEXTOUT = NativeMethods.EMR_POLYTEXTOUTA;
                HDM_INSERTITEM = NativeMethods.HDM_INSERTITEMA;
                HDM_GETITEM = NativeMethods.HDM_GETITEMA;
                HDM_SETITEM = NativeMethods.HDM_SETITEMA;
                HDN_ITEMCHANGING = NativeMethods.HDN_ITEMCHANGINGA;
                HDN_ITEMCHANGED = NativeMethods.HDN_ITEMCHANGEDA;
                HDN_ITEMCLICK = NativeMethods.HDN_ITEMCLICKA;
                HDN_ITEMDBLCLICK = NativeMethods.HDN_ITEMDBLCLICKA;
                HDN_DIVIDERDBLCLICK = NativeMethods.HDN_DIVIDERDBLCLICKA;
                HDN_BEGINTRACK = NativeMethods.HDN_BEGINTRACKA;
                HDN_ENDTRACK = NativeMethods.HDN_ENDTRACKA;
                HDN_TRACK = NativeMethods.HDN_TRACKA;
                HDN_GETDISPINFO = NativeMethods.HDN_GETDISPINFOA;
                LVM_GETITEM = NativeMethods.LVM_GETITEMA;
                LVM_SETITEM = NativeMethods.LVM_SETITEMA;
                LVM_INSERTITEM = NativeMethods.LVM_INSERTITEMA;
                LVM_FINDITEM = NativeMethods.LVM_FINDITEMA;
                LVM_GETSTRINGWIDTH = NativeMethods.LVM_GETSTRINGWIDTHA;
                LVM_EDITLABEL = NativeMethods.LVM_EDITLABELA;
                LVM_GETCOLUMN = NativeMethods.LVM_GETCOLUMNA;
                LVM_SETCOLUMN = NativeMethods.LVM_SETCOLUMNA;
                LVM_GETISEARCHSTRING = NativeMethods.LVM_GETISEARCHSTRINGA;
                LVM_INSERTCOLUMN = NativeMethods.LVM_INSERTCOLUMNA;
                LVN_BEGINLABELEDIT = NativeMethods.LVN_BEGINLABELEDITA;
                LVN_ENDLABELEDIT = NativeMethods.LVN_ENDLABELEDITA;
                LVN_ODFINDITEM = NativeMethods.LVN_ODFINDITEMA;
                LVN_GETDISPINFO = NativeMethods.LVN_GETDISPINFOA;
                LVN_SETDISPINFO = NativeMethods.LVN_SETDISPINFOA;
                PSM_SETTITLE = NativeMethods.PSM_SETTITLEA;
                PSM_SETFINISHTEXT = NativeMethods.PSM_SETFINISHTEXTA;
                RB_INSERTBAND = NativeMethods.RB_INSERTBANDA;
                SB_SETTEXT = NativeMethods.SB_SETTEXTA;
                SB_GETTEXT = NativeMethods.SB_GETTEXTA;
                SB_GETTEXTLENGTH = NativeMethods.SB_GETTEXTLENGTHA;
                SB_SETTIPTEXT = NativeMethods.SB_SETTIPTEXTA;
                SB_GETTIPTEXT = NativeMethods.SB_GETTIPTEXTA;
                TB_SAVERESTORE = NativeMethods.TB_SAVERESTOREA;
                TB_ADDSTRING = NativeMethods.TB_ADDSTRINGA;
                TB_GETBUTTONTEXT = NativeMethods.TB_GETBUTTONTEXTA;
                TB_MAPACCELERATOR = NativeMethods.TB_MAPACCELERATORA;
                TB_GETBUTTONINFO = NativeMethods.TB_GETBUTTONINFOA;
                TB_SETBUTTONINFO = NativeMethods.TB_SETBUTTONINFOA;
                TB_INSERTBUTTON = NativeMethods.TB_INSERTBUTTONA;
                TB_ADDBUTTONS = NativeMethods.TB_ADDBUTTONSA;
                TBN_GETBUTTONINFO = NativeMethods.TBN_GETBUTTONINFOA;
                TBN_GETINFOTIP = NativeMethods.TBN_GETINFOTIPA;
                TBN_GETDISPINFO = NativeMethods.TBN_GETDISPINFOA;
                TTM_ADDTOOL = NativeMethods.TTM_ADDTOOLA;
                TTM_SETTITLE = NativeMethods.TTM_SETTITLEA;
                TTM_DELTOOL = NativeMethods.TTM_DELTOOLA;
                TTM_NEWTOOLRECT = NativeMethods.TTM_NEWTOOLRECTA;
                TTM_GETTOOLINFO = NativeMethods.TTM_GETTOOLINFOA;
                TTM_SETTOOLINFO = NativeMethods.TTM_SETTOOLINFOA;
                TTM_HITTEST = NativeMethods.TTM_HITTESTA;
                TTM_GETTEXT = NativeMethods.TTM_GETTEXTA;
                TTM_UPDATETIPTEXT = NativeMethods.TTM_UPDATETIPTEXTA;
                TTM_ENUMTOOLS = NativeMethods.TTM_ENUMTOOLSA;
                TTM_GETCURRENTTOOL = NativeMethods.TTM_GETCURRENTTOOLA;
                TTN_GETDISPINFO = NativeMethods.TTN_GETDISPINFOA;
                TTN_NEEDTEXT = NativeMethods.TTN_NEEDTEXTA;
                TVM_INSERTITEM = NativeMethods.TVM_INSERTITEMA;
                TVM_GETITEM = NativeMethods.TVM_GETITEMA;
                TVM_SETITEM = NativeMethods.TVM_SETITEMA;
                TVM_EDITLABEL = NativeMethods.TVM_EDITLABELA;
                TVM_GETISEARCHSTRING = NativeMethods.TVM_GETISEARCHSTRINGA;
                TVN_SELCHANGING = NativeMethods.TVN_SELCHANGINGA;
                TVN_SELCHANGED = NativeMethods.TVN_SELCHANGEDA;
                TVN_GETDISPINFO = NativeMethods.TVN_GETDISPINFOA;
                TVN_SETDISPINFO = NativeMethods.TVN_SETDISPINFOA;
                TVN_ITEMEXPANDING = NativeMethods.TVN_ITEMEXPANDINGA;
                TVN_ITEMEXPANDED = NativeMethods.TVN_ITEMEXPANDEDA;
                TVN_BEGINDRAG = NativeMethods.TVN_BEGINDRAGA;
                TVN_BEGINRDRAG = NativeMethods.TVN_BEGINRDRAGA;
                TVN_BEGINLABELEDIT = NativeMethods.TVN_BEGINLABELEDITA;
                TVN_ENDLABELEDIT = NativeMethods.TVN_ENDLABELEDITA;
                TCM_GETITEM = NativeMethods.TCM_GETITEMA;
                TCM_SETITEM = NativeMethods.TCM_SETITEMA;
                TCM_INSERTITEM = NativeMethods.TCM_INSERTITEMA;
            }
            else {
                CBEM_GETITEM = NativeMethods.CBEM_GETITEMW;
                CBEM_SETITEM = NativeMethods.CBEM_SETITEMW;
                CBEN_ENDEDIT = NativeMethods.CBEN_ENDEDITW;
                CBEM_INSERTITEM = NativeMethods.CBEM_INSERTITEMW;
                LVM_GETITEMTEXT = NativeMethods.LVM_GETITEMTEXTW;
                LVM_SETITEMTEXT = NativeMethods.LVM_SETITEMTEXTW;
                ACM_OPEN = NativeMethods.ACM_OPENW;
                DTM_SETFORMAT = NativeMethods.DTM_SETFORMATW;
                DTN_USERSTRING = NativeMethods.DTN_USERSTRINGW;
                DTN_WMKEYDOWN = NativeMethods.DTN_WMKEYDOWNW;
                DTN_FORMAT = NativeMethods.DTN_FORMATW;
                DTN_FORMATQUERY = NativeMethods.DTN_FORMATQUERYW;
                EMR_POLYTEXTOUT = NativeMethods.EMR_POLYTEXTOUTW;
                HDM_INSERTITEM = NativeMethods.HDM_INSERTITEMW;
                HDM_GETITEM = NativeMethods.HDM_GETITEMW;
                HDM_SETITEM = NativeMethods.HDM_SETITEMW;
                HDN_ITEMCHANGING = NativeMethods.HDN_ITEMCHANGINGW;
                HDN_ITEMCHANGED = NativeMethods.HDN_ITEMCHANGEDW;
                HDN_ITEMCLICK = NativeMethods.HDN_ITEMCLICKW;
                HDN_ITEMDBLCLICK = NativeMethods.HDN_ITEMDBLCLICKW;
                HDN_DIVIDERDBLCLICK = NativeMethods.HDN_DIVIDERDBLCLICKW;
                HDN_BEGINTRACK = NativeMethods.HDN_BEGINTRACKW;
                HDN_ENDTRACK = NativeMethods.HDN_ENDTRACKW;
                HDN_TRACK = NativeMethods.HDN_TRACKW;
                HDN_GETDISPINFO = NativeMethods.HDN_GETDISPINFOW;
                LVM_GETITEM = NativeMethods.LVM_GETITEMW;
                LVM_SETITEM = NativeMethods.LVM_SETITEMW;
                LVM_INSERTITEM = NativeMethods.LVM_INSERTITEMW;
                LVM_FINDITEM = NativeMethods.LVM_FINDITEMW;
                LVM_GETSTRINGWIDTH = NativeMethods.LVM_GETSTRINGWIDTHW;
                LVM_EDITLABEL = NativeMethods.LVM_EDITLABELW;
                LVM_GETCOLUMN = NativeMethods.LVM_GETCOLUMNW;
                LVM_SETCOLUMN = NativeMethods.LVM_SETCOLUMNW;
                LVM_GETISEARCHSTRING = NativeMethods.LVM_GETISEARCHSTRINGW;
                LVM_INSERTCOLUMN = NativeMethods.LVM_INSERTCOLUMNW;
                LVN_BEGINLABELEDIT = NativeMethods.LVN_BEGINLABELEDITW;
                LVN_ENDLABELEDIT = NativeMethods.LVN_ENDLABELEDITW;
                LVN_ODFINDITEM = NativeMethods.LVN_ODFINDITEMW;
                LVN_GETDISPINFO = NativeMethods.LVN_GETDISPINFOW;
                LVN_SETDISPINFO = NativeMethods.LVN_SETDISPINFOW;
                PSM_SETTITLE = NativeMethods.PSM_SETTITLEW;
                PSM_SETFINISHTEXT = NativeMethods.PSM_SETFINISHTEXTW;
                RB_INSERTBAND = NativeMethods.RB_INSERTBANDW;
                SB_SETTEXT = NativeMethods.SB_SETTEXTW;
                SB_GETTEXT = NativeMethods.SB_GETTEXTW;
                SB_GETTEXTLENGTH = NativeMethods.SB_GETTEXTLENGTHW;
                SB_SETTIPTEXT = NativeMethods.SB_SETTIPTEXTW;
                SB_GETTIPTEXT = NativeMethods.SB_GETTIPTEXTW;
                TB_SAVERESTORE = NativeMethods.TB_SAVERESTOREW;
                TB_ADDSTRING = NativeMethods.TB_ADDSTRINGW;
                TB_GETBUTTONTEXT = NativeMethods.TB_GETBUTTONTEXTW;
                TB_MAPACCELERATOR = NativeMethods.TB_MAPACCELERATORW;
                TB_GETBUTTONINFO = NativeMethods.TB_GETBUTTONINFOW;
                TB_SETBUTTONINFO = NativeMethods.TB_SETBUTTONINFOW;
                TB_INSERTBUTTON = NativeMethods.TB_INSERTBUTTONW;
                TB_ADDBUTTONS = NativeMethods.TB_ADDBUTTONSW;
                TBN_GETBUTTONINFO = NativeMethods.TBN_GETBUTTONINFOW;
                TBN_GETINFOTIP = NativeMethods.TBN_GETINFOTIPW;
                TBN_GETDISPINFO = NativeMethods.TBN_GETDISPINFOW;
                TTM_ADDTOOL = NativeMethods.TTM_ADDTOOLW;
                TTM_SETTITLE = NativeMethods.TTM_SETTITLEW;
                TTM_DELTOOL = NativeMethods.TTM_DELTOOLW;
                TTM_NEWTOOLRECT = NativeMethods.TTM_NEWTOOLRECTW;
                TTM_GETTOOLINFO = NativeMethods.TTM_GETTOOLINFOW;
                TTM_SETTOOLINFO = NativeMethods.TTM_SETTOOLINFOW;
                TTM_HITTEST = NativeMethods.TTM_HITTESTW;
                TTM_GETTEXT = NativeMethods.TTM_GETTEXTW;
                TTM_UPDATETIPTEXT = NativeMethods.TTM_UPDATETIPTEXTW;
                TTM_ENUMTOOLS = NativeMethods.TTM_ENUMTOOLSW;
                TTM_GETCURRENTTOOL = NativeMethods.TTM_GETCURRENTTOOLW;
                TTN_GETDISPINFO = NativeMethods.TTN_GETDISPINFOW;
                TTN_NEEDTEXT = NativeMethods.TTN_NEEDTEXTW;
                TVM_INSERTITEM = NativeMethods.TVM_INSERTITEMW;
                TVM_GETITEM = NativeMethods.TVM_GETITEMW;
                TVM_SETITEM = NativeMethods.TVM_SETITEMW;
                TVM_EDITLABEL = NativeMethods.TVM_EDITLABELW;
                TVM_GETISEARCHSTRING = NativeMethods.TVM_GETISEARCHSTRINGW;
                TVN_SELCHANGING = NativeMethods.TVN_SELCHANGINGW;
                TVN_SELCHANGED = NativeMethods.TVN_SELCHANGEDW;
                TVN_GETDISPINFO = NativeMethods.TVN_GETDISPINFOW;
                TVN_SETDISPINFO = NativeMethods.TVN_SETDISPINFOW;
                TVN_ITEMEXPANDING = NativeMethods.TVN_ITEMEXPANDINGW;
                TVN_ITEMEXPANDED = NativeMethods.TVN_ITEMEXPANDEDW;
                TVN_BEGINDRAG = NativeMethods.TVN_BEGINDRAGW;
                TVN_BEGINRDRAG = NativeMethods.TVN_BEGINRDRAGW;
                TVN_BEGINLABELEDIT = NativeMethods.TVN_BEGINLABELEDITW;
                TVN_ENDLABELEDIT = NativeMethods.TVN_ENDLABELEDITW;
                TCM_GETITEM = NativeMethods.TCM_GETITEMW;
                TCM_SETITEM = NativeMethods.TCM_SETITEMW;
                TCM_INSERTITEM = NativeMethods.TCM_INSERTITEMW;
            }
        }

        /*
        * MISCELLANEOUS
        */


        public static int SignedHIWORD(int n) {
            int i = (int)(short)((n >> 16) & 0xffff);

            return i;
        }

        public static int SignedLOWORD(int n) {
            int i = (int)(short)(n & 0xFFFF);
            
            return i;
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.FONTDESC"]/*' />
        /// <devdoc>
        /// </devdoc>
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        public class FONTDESC {
            public int      cbSizeOfStruct = Marshal.SizeOf(typeof(FONTDESC));
            public string   lpstrName;
            public long     cySize;
            public short    sWeight;
            public short    sCharset;
            public bool     fItalic;
            public bool     fUnderline;
            public bool     fStrikethrough;
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.PICTDESCbmp"]/*' />
        /// <devdoc>
        /// </devdoc>
        [StructLayout(LayoutKind.Sequential)]
        public class PICTDESCbmp {
            internal int cbSizeOfStruct = Marshal.SizeOf(typeof(PICTDESCbmp));
            internal int picType = Ole.PICTYPE_BITMAP;
            internal IntPtr hbitmap = IntPtr.Zero;
            internal IntPtr hpalette = IntPtr.Zero;
            internal int unused = 0;

            public PICTDESCbmp(System.Drawing.Bitmap bitmap) {
                hbitmap = bitmap.GetHbitmap();
                // gpr: What about palettes?
            }
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.PICTDESCicon"]/*' />
        /// <devdoc>
        /// </devdoc>
        [StructLayout(LayoutKind.Sequential)]
        public class PICTDESCicon {
            internal int cbSizeOfStruct = Marshal.SizeOf(typeof(PICTDESCicon));
            internal int picType = Ole.PICTYPE_ICON;
            internal IntPtr hicon = IntPtr.Zero;
            internal int unused1 = 0;
            internal int unused2 = 0;

            public PICTDESCicon(System.Drawing.Icon icon) {
                hicon = SafeNativeMethods.CopyImage(new HandleRef(icon, icon.Handle), NativeMethods.IMAGE_ICON, icon.Size.Width, icon.Size.Height, 0);
            }
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.PICTDESCemf"]/*' />
        /// <devdoc>
        /// </devdoc>
        [StructLayout(LayoutKind.Sequential)]
        public class PICTDESCemf {
            internal int cbSizeOfStruct = Marshal.SizeOf(typeof(PICTDESCemf));
            internal int picType = Ole.PICTYPE_ENHMETAFILE;
            internal IntPtr hemf = IntPtr.Zero;
            internal int unused1 = 0;
            internal int unused2 = 0;

            public PICTDESCemf(System.Drawing.Imaging.Metafile metafile) {
                //gpr                hemf = metafile.CopyHandle();
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public class USEROBJECTFLAGS {
            public int fInherit = 0;
            public int fReserved = 0;
            public int dwFlags = 0;
        }

        [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
        internal class SYSTEMTIMEARRAY {
            public short wYear1;
            public short wMonth1;
            public short wDayOfWeek1;
            public short wDay1;
            public short wHour1;
            public short wMinute1;
            public short wSecond1;
            public short wMilliseconds1;
            public short wYear2;
            public short wMonth2;
            public short wDayOfWeek2;
            public short wDay2;
            public short wHour2;
            public short wMinute2;
            public short wSecond2;
            public short wMilliseconds2;
        }
        
        public delegate bool EnumChildrenCallback(IntPtr hwnd, IntPtr lParam);

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class HH_AKLINK {
            internal int       cbStruct=Marshal.SizeOf(typeof(HH_AKLINK));
            internal bool      fReserved;            
            internal string    pszKeywords;
            internal string    pszUrl;
            internal string    pszMsgText;
            internal string    pszMsgTitle;
            internal string    pszWindow;
            internal bool      fIndexOnFail;
        }

      [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class HH_POPUP {
            internal int       cbStruct=Marshal.SizeOf(typeof(HH_POPUP));
            internal IntPtr    hinst = IntPtr.Zero;
            internal int       idString = 0;            
            internal IntPtr    pszText;
            internal POINT     pt;
            internal int       clrForeground = -1;
            internal int       clrBackground = -1;
            internal RECT      rcMargins = RECT.FromXYWH(-1, -1, -1, -1);     // amount of space between edges of window and text, -1 for each member to ignore            
            internal string    pszFont = null;
        }

        public static readonly int HH_FTS_DEFAULT_PROXIMITY = -1;

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class HH_FTS_QUERY {
            internal int       cbStruct = Marshal.SizeOf(typeof(HH_FTS_QUERY));
            internal bool      fUniCodeStrings;
            [MarshalAs(UnmanagedType.LPStr)]
            internal string    pszSearchQuery;
            internal int       iProximity = NativeMethods.HH_FTS_DEFAULT_PROXIMITY;
            internal bool      fStemmedSearch;
            internal bool      fTitleOnly;
            internal bool      fExecute = true;
            [MarshalAs(UnmanagedType.LPStr)]
            internal string    pszWindow;
        }

        [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
        public class MONITORINFOEX {
            internal int     cbSize = Marshal.SizeOf(typeof(MONITORINFOEX));
            internal RECT    rcMonitor = new RECT();
            internal RECT    rcWork = new RECT();
            internal int     dwFlags = 0;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
            internal char[]  szDevice = new char[32];
        }

        [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
        public class MONITORINFO {
            internal int     cbSize = Marshal.SizeOf(typeof(MONITORINFO));
            internal RECT    rcMonitor = new RECT();
            internal RECT    rcWork = new RECT();
            internal int     dwFlags = 0;
        }
        
        public delegate bool EnumChildrenProc(IntPtr hwnd, IntPtr lParam);
        public delegate int EditStreamCallback(IntPtr dwCookie, IntPtr buf, int cb, out int transferred);

        [StructLayout(LayoutKind.Sequential)]
        public class EDITSTREAM {
            public int  dwCookie = 0;
            public int  dwError = 0;
            public EditStreamCallback   pfnCallback = null;
        }

        [ComImport(), Guid("0FF510A3-5FA5-49F1-8CCC-190D71083F3E"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IVsPerPropertyBrowsing {
            // hides the property at the given dispid from the properties window
            // implmentors should can return E_NOTIMPL to show all properties that
            // are otherwise browsable.
            
            [PreserveSig]
            int HideProperty(int dispid,ref bool pfHide);
          
            // will have the "+" expandable glyph next to them and can be expanded or collapsed by the user
            // Returning a non-S_OK return code or false for pfDisplay will suppress this feature
            
            [PreserveSig]
            int DisplayChildProperties(int dispid, 
                                       ref bool pfDisplay);
          
            // retrieves the localized name and description for a property.
            // returning a non-S_OK return code will display the default values
            
            [PreserveSig]
            int GetLocalizedPropertyInfo(int dispid, int localeID, 
                                         [Out, MarshalAs(UnmanagedType.LPArray)]
                                         string[] pbstrLocalizedName, 
                                         [Out, MarshalAs(UnmanagedType.LPArray)]
                                         string[] pbstrLocalizeDescription);
          
            // determines if the given (usually current) value for a property is the default.  If it is not default,
            // the property will be shown as bold in the browser to indcate that it has been modified from the default.
            
            [PreserveSig]
            int HasDefaultValue(int dispid,
                               ref bool fDefault);
          
            // determines if a property should be made read only.  This only applies to properties that are writeable,
            [PreserveSig]
            int IsPropertyReadOnly(int dispid, 
                                   ref bool fReadOnly);
                                   
            
            // returns the classname for this object.  The class name is the non-bolded text that appears in the 
            // properties window selection combo.  If this method returns a non-S_OK return code, the default
            // will be used.  The default is the name string from a call to ITypeInfo::GetDocumentation(MEMID_NIL, ...);
            [PreserveSig]
            int GetClassName([In, Out]ref string pbstrClassName);
    
            // checks whether the given property can be reset to some default value.  If return value is non-S_OK or *pfCanReset is 
            //
            [PreserveSig]
            int CanResetPropertyValue(int dispid, [In, Out]ref bool pfCanReset);
    
            // given property.  If the return value is S_OK, the property's value will then be refreshed to the new default
            // values.
            [PreserveSig]
            int ResetPropertyValue(int dispid);                               
       }
       
        [ComImport(), Guid("7494683C-37A0-11d2-A273-00C04F8EF4FF"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IManagedPerPropertyBrowsing {
    
            
            [PreserveSig]
            int GetPropertyAttributes(int dispid, 
                                      ref int  pcAttributes,
                                      ref IntPtr pbstrAttrNames,
                                      ref IntPtr pvariantInitValues);
        }
        
        [ComImport(), Guid("33C0C1D8-33CF-11d3-BFF2-00C04F990235"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IProvidePropertyBuilder {
    
             [PreserveSig]
             int MapPropertyToBuilder(
                int dispid,
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                int[] pdwCtlBldType,
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                string[] pbstrGuidBldr,
              
            [In, Out, MarshalAs(UnmanagedType.Bool)]
                ref bool builderAvailable);
    
            [PreserveSig]
            int ExecuteBuilder(
                int dispid,
                [In, MarshalAs(UnmanagedType.BStr)]
                string bstrGuidBldr,
                [In, MarshalAs(UnmanagedType.Interface)]
                object pdispApp,
                
                HandleRef hwndBldrOwner,
                [Out, In, MarshalAs(UnmanagedType.Struct)]
                ref object pvarValue,
                [In, Out, MarshalAs(UnmanagedType.Bool)]
                ref bool actionCommitted);
        }

        [StructLayout(LayoutKind.Sequential, Pack=1)]
        public class INITCOMMONCONTROLSEX {
            public int  dwSize = 8; //ndirect.DllLib.sizeOf(this);
            public int  dwICC;
        }

        [StructLayout(LayoutKind.Sequential, Pack=1)]
        public class IMAGELISTDRAWPARAMS {
            public int      cbSize = Marshal.SizeOf(typeof(IMAGELISTDRAWPARAMS));
            public IntPtr   himl;
            public int      i;
            public IntPtr   hdcDst;
            public int      x;
            public int      y;
            public int      cx;
            public int      cy;
            public int      xBitmap;
            public int      yBitmap;
            public int      rgbBk;
            public int      rgbFg;
            public int      fStyle;
            public int      dwRop;
        }

        [StructLayout(LayoutKind.Sequential, Pack=1)]
        public class IMAGEINFO {
            public IntPtr   hbmImage;
            public IntPtr   hbmMask;
            public int      Unused1;
            public int      Unused2;
            // rcImage was a by-value RECT structure
            public int      rcImage_left;
            public int      rcImage_top;
            public int      rcImage_right;
            public int      rcImage_bottom;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class TRACKMOUSEEVENT {
                public int      cbSize = Marshal.SizeOf(typeof(TRACKMOUSEEVENT));
                public int      dwFlags;
                public IntPtr   hwndTrack;
                public int      dwHoverTime;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class POINT {
            public int x;
            public int y;

            public POINT() {
            }
            
            public POINT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }

        public delegate IntPtr WndProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public RECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static RECT FromXYWH(int x, int y, int width, int height) {
                return new RECT(x, y, x + width, y + height);
            }
        }

        public delegate int ListViewCompareCallback(IntPtr lParam1, IntPtr lParam2, IntPtr lParamSort);

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class WNDCLASS {
            public int      style;
            public IntPtr   lpfnWndProc;
            public int      cbClsExtra;
            public int      cbWndExtra;
            public IntPtr   hInstance;
            public IntPtr   hIcon;
            public IntPtr   hCursor;
            public IntPtr   hbrBackground;
            public string   lpszMenuName;
            public string   lpszClassName;
        }

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class WNDCLASS_I {
            public int      style;
            public IntPtr   lpfnWndProc;
            public int      cbClsExtra;
            public int      cbWndExtra;
            public IntPtr   hInstance;
            public IntPtr   hIcon;
            public IntPtr   hCursor;
            public IntPtr   hbrBackground;
            public IntPtr   lpszMenuName;
            public IntPtr   lpszClassName;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class NONCLIENTMETRICS {
            public int      cbSize = Marshal.SizeOf(typeof(NONCLIENTMETRICS));
            public int      iBorderWidth; 
            public int      iScrollWidth; 
            public int      iScrollHeight; 
            public int      iCaptionWidth; 
            public int      iCaptionHeight; 
            [MarshalAs(UnmanagedType.Struct)]
            public LOGFONT  lfCaptionFont; 
            public int      iSmCaptionWidth; 
            public int      iSmCaptionHeight; 
            [MarshalAs(UnmanagedType.Struct)]
            public LOGFONT  lfSmCaptionFont; 
            public int      iMenuWidth; 
            public int      iMenuHeight; 
            [MarshalAs(UnmanagedType.Struct)]
            public LOGFONT  lfMenuFont; 
            [MarshalAs(UnmanagedType.Struct)]
            public LOGFONT  lfStatusFont; 
            [MarshalAs(UnmanagedType.Struct)]
            public LOGFONT  lfMessageFont; 
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct MSG {
            public IntPtr   hwnd;
            public int      message;
            public IntPtr   wParam;
            public IntPtr   lParam;
            public int      time;
            // pt was a by-value POINT structure
            public int      pt_x;
            public int      pt_y;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct PAINTSTRUCT {
            public IntPtr   hdc;
            public bool     fErase;
            // rcPaint was a by-value RECT structure
            public int      rcPaint_left;
            public int      rcPaint_top;
            public int      rcPaint_right;
            public int      rcPaint_bottom;
            public bool     fRestore;
            public bool     fIncUpdate;    
            public int      reserved1;
            public int      reserved2;
            public int      reserved3;
            public int      reserved4;
            public int      reserved5;
            public int      reserved6;
            public int      reserved7;
            public int      reserved8;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class SCROLLINFO {
            public int cbSize = Marshal.SizeOf(typeof(SCROLLINFO));
            public int fMask;
            public int nMin;
            public int nMax;
            public int nPage;
            public int nPos;
            public int nTrackPos;
            
            public SCROLLINFO() {
            }

            public SCROLLINFO(int mask, int min, int max, int page, int pos) {
                fMask = mask;
                nMin = min;
                nMax = max;
                nPage = page;
                nPos = pos;
            }
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class TPMPARAMS {
            public int  cbSize = Marshal.SizeOf(typeof(TPMPARAMS));
            // rcExclude was a by-value RECT structure
            public int  rcExclude_left;
            public int  rcExclude_top;
            public int  rcExclude_right;
            public int  rcExclude_bottom;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class SIZE {
            public int cx;
            public int cy;
            
            public SIZE() {
            }

            public SIZE(int cx, int cy) {
                this.cx = cx;
                this.cy = cy;
            }
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct WINDOWPLACEMENT {
            public int  length;
            public int  flags;
            public int  showCmd;
            // ptMinPosition was a by-value POINT structure
            public int  ptMinPosition_x;
            public int  ptMinPosition_y;
            // ptMaxPosition was a by-value POINT structure
            public int  ptMaxPosition_x;
            public int  ptMaxPosition_y;
            // rcNormalPosition was a by-value RECT structure
            public int  rcNormalPosition_left;
            public int  rcNormalPosition_top;
            public int  rcNormalPosition_right;
            public int  rcNormalPosition_bottom;
        }
        
        [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
        public class STARTUPINFO {
            public int      cb;
            public string   lpReserved;
            public string   lpDesktop;
            public string   lpTitle;
            public int      dwX;
            public int      dwY;
            public int      dwXSize;
            public int      dwYSize;
            public int      dwXCountChars;
            public int      dwYCountChars;
            public int      dwFillAttribute;
            public int      dwFlags;
            public short    wShowWindow;
            public short    cbReserved2;
            public IntPtr   lpReserved2;
            public IntPtr   hStdInput;
            public IntPtr   hStdOutput;
            public IntPtr   hStdError;
        }
        
        [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
        public class STARTUPINFO_I {
            public int      cb;
            public IntPtr   lpReserved;
            public IntPtr   lpDesktop;
            public IntPtr   lpTitle;
            public int      dwX;
            public int      dwY;
            public int      dwXSize;
            public int      dwYSize;
            public int      dwXCountChars;
            public int      dwYCountChars;
            public int      dwFillAttribute;
            public int      dwFlags;
            public short    wShowWindow;
            public short    cbReserved2;
            public IntPtr   lpReserved2;
            public IntPtr   hStdInput;
            public IntPtr   hStdOutput;
            public IntPtr   hStdError;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class PAGESETUPDLG {
            public int      lStructSize; 
            public IntPtr   hwndOwner; 
            public IntPtr   hDevMode; 
            public IntPtr   hDevNames; 
            public int      Flags; 

            //POINT           ptPaperSize; 
            public int      paperSizeX;
            public int      paperSizeY;

            // RECT            rtMinMargin; 
            public int      minMarginLeft;
            public int      minMarginTop;
            public int      minMarginRight;
            public int      minMarginBottom;

            // RECT            rtMargin; 
            public int      marginLeft;
            public int      marginTop;
            public int      marginRight;
            public int      marginBottom;

            public IntPtr   hInstance; 
            public IntPtr   lCustData; 
            public WndProc  lpfnPageSetupHook; 
            public WndProc  lpfnPagePaintHook; 
            public string   lpPageSetupTemplateName; 
            public IntPtr   hPageSetupTemplate; 
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class PRINTDLG {
            public   int    lStructSize;
            public   IntPtr hwndOwner;
            public   IntPtr hDevMode;
            public   IntPtr hDevNames;
            public   IntPtr hDC;
            public   int    Flags;
            public   short  nFromPage;
            public   short  nToPage;
            public   short  nMinPage;
            public   short  nMaxPage;
            public   short  nCopies;
            public   IntPtr hInstance;
            public   IntPtr lCustData;
            public   WndProc lpfnPrintHook;
            public   WndProc lpfnSetupHook;
            public   string lpPrintTemplateName;
            public   string lpSetupTemplateName;
            public   IntPtr hPrintTemplate;
            public   IntPtr hSetupTemplate;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class PICTDESC
        {
            internal int cbSizeOfStruct;
            public int picType;
            internal IntPtr union1;
            internal int union2;
            internal int union3;

            public static PICTDESC CreateBitmapPICTDESC(IntPtr hbitmap, IntPtr hpal) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 16;
                pictdesc.picType = Ole.PICTYPE_BITMAP;
                pictdesc.union1 = hbitmap;
                pictdesc.union2 = (int)(((long)hpal) & 0xffffffff);
                pictdesc.union3 = (int)(((long)hpal) >> 32);
                return pictdesc;
            }

            public static PICTDESC CreateIconPICTDESC(IntPtr hicon) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 12;
                pictdesc.picType = Ole.PICTYPE_ICON;
                pictdesc.union1 = hicon;
                return pictdesc;
            }

            public static PICTDESC CreateEnhMetafilePICTDESC(IntPtr hEMF) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 12;
                pictdesc.picType = Ole.PICTYPE_ENHMETAFILE;
                pictdesc.union1 = hEMF;
                return pictdesc;
            }

            public static PICTDESC CreateWinMetafilePICTDESC(IntPtr hmetafile, int x, int y) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 20;
                pictdesc.picType = Ole.PICTYPE_METAFILE;
                pictdesc.union1 = hmetafile;
                pictdesc.union2 = x;
                pictdesc.union3 = y;
                return pictdesc;
            }

            public virtual IntPtr GetHandle() {
                return union1;
            }

            public virtual IntPtr GetHPal() {
                if (picType == Ole.PICTYPE_BITMAP)
                    return (IntPtr)(union2 | (((long)union3) << 32));
                else
                    return IntPtr.Zero;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public  sealed class tagFONTDESC {
             public int cbSizeofstruct = Marshal.SizeOf(typeof(tagFONTDESC)); 
             
             [MarshalAs(UnmanagedType.LPWStr)]
             public string lpstrName; 
             
             [MarshalAs(UnmanagedType.U8)] 
             public long cySize; 
             
             [MarshalAs(UnmanagedType.U2)] 
             public short sWeight; 
             
             [MarshalAs(UnmanagedType.U2)] 
             public short sCharset;
             
             [MarshalAs(UnmanagedType.Bool)] 
             public bool  fItalic; 
             
             [MarshalAs(UnmanagedType.Bool)] 
             public bool  fUnderline; 
             
             [MarshalAs(UnmanagedType.Bool)] 
             public bool fStrikethrough; 
        }


        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class CHOOSECOLOR {
            public int      lStructSize = 36; //ndirect.DllLib.sizeOf(this);
            public IntPtr   hwndOwner;
            public IntPtr   hInstance;
            public int      rgbResult;
            public IntPtr   lpCustColors;
            public int      Flags;
            public IntPtr   lCustData;
            public WndProc  lpfnHook;
            public string   lpTemplateName;
        }
        
        public delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);
        
        [StructLayout(LayoutKind.Sequential)]
        public class BITMAP {
            public int bmType;
            public int bmWidth;
            public int bmHeight;
            public int bmWidthBytes;
            public short bmPlanes;
            public short bmBitsPixel;
            public int bmBits;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class DIBSECTION {
            public BITMAP dsBm;
            public BITMAPINFOHEADER dsBmih;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=3)]
            public int[] dsBitfields;
            public IntPtr dshSection;
            public int dsOffset;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class LOGPEN {
            public int  lopnStyle;
            // lopnWidth was a by-value POINT structure
            public int  lopnWidth_x;
            public int  lopnWidth_y;
            public int  lopnColor;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class LOGBRUSH {
                public int lbStyle;
                public int lbColor;
                public IntPtr lbHatch;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class LOGFONT {
            public int lfHeight;
            public int lfWidth;
            public int lfEscapement;
            public int lfOrientation;
            public int lfWeight;
            public byte lfItalic;
            public byte lfUnderline;
            public byte lfStrikeOut;
            public byte lfCharSet;
            public byte lfOutPrecision;
            public byte lfClipPrecision;
            public byte lfQuality;
            public byte lfPitchAndFamily;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)]
            public string   lfFaceName;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class LOGPALETTE {
            public short palVersion;
            public short palNumEntries;
            public int palPalEntry;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class TEXTMETRIC {
            public int tmHeight;
            public int tmAscent;
            public int tmDescent;
            public int tmInternalLeading;
            public int tmExternalLeading;
            public int tmAveCharWidth;
            public int tmMaxCharWidth;
            public int tmWeight;
            public int tmOverhang;
            public int tmDigitizedAspectX;
            public int tmDigitizedAspectY;
            public char tmFirstChar;
            public char tmLastChar;
            public char tmDefaultChar;
            public char tmBreakChar;
            public byte tmItalic;
            public byte tmUnderlined;
            public byte tmStruckOut;
            public byte tmPitchAndFamily;
            public byte tmCharSet;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class NOTIFYICONDATA {
            public int      cbSize = Marshal.SizeOf(typeof(NOTIFYICONDATA));
            public IntPtr   hWnd;
            public int      uID;
            public int      uFlags;
            public int      uCallbackMessage;
            public IntPtr   hIcon;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
            public string   szTip;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class MENUITEMINFO_T
        {
            public int      cbSize = Marshal.SizeOf(typeof(MENUITEMINFO_T));
            public int      fMask;
            public int      fType;
            public int      fState;
            public int      wID;
            public IntPtr   hSubMenu;
            public IntPtr   hbmpChecked;
            public IntPtr   hbmpUnchecked;
            public int      dwItemData;
            public string   dwTypeData;
            public int      cch;
        }
        
        public delegate bool EnumThreadWindowsCallback(IntPtr hWnd, IntPtr lParam);
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class OPENFILENAME_I
        {
            public int      lStructSize = 0x58; //ndirect.DllLib.sizeOf(this);
            public IntPtr   hwndOwner;
            public IntPtr   hInstance;
            public string   lpstrFilter;   // use embedded nulls to separate filters
            public IntPtr   lpstrCustomFilter;
            public int      nMaxCustFilter;
            public int      nFilterIndex;
            public IntPtr   lpstrFile;
            public int      nMaxFile = NativeMethods.MAX_PATH;
            public IntPtr   lpstrFileTitle;
            public int      nMaxFileTitle = NativeMethods.MAX_PATH;
            public string   lpstrInitialDir;
            public string   lpstrTitle;
            public int      Flags;
            public short    nFileOffset;
            public short    nFileExtension;
            public string   lpstrDefExt;
            public IntPtr   lCustData;
            public WndProc  lpfnHook;
            public string   lpTemplateName;
            public IntPtr   pvReserved;
            public int      dwReserved;
            public int      FlagsEx;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto), CLSCompliantAttribute(false)]
        public class CHOOSEFONT {
            public int      lStructSize = 60;   // ndirect.DllLib.sizeOf(this);
            public IntPtr   hwndOwner;
            public IntPtr   hDC;
            public IntPtr   lpLogFont;
            public int      iPointSize;
            public int      Flags;
            public int      rgbColors;
            public IntPtr   lCustData;
            public WndProc  lpfnHook;
            public string   lpTemplateName;
            public IntPtr   hInstance;
            public string   lpszStyle;
            public short    nFontType;
            public short    ___MISSING_ALIGNMENT__;
            public int      nSizeMin;
            public int      nSizeMax;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class BITMAPINFO {
            // bmiHeader was a by-value BITMAPINFOHEADER structure
            public int      bmiHeader_biSize = 40;  // ndirect.DllLib.sizeOf( BITMAPINFOHEADER.class );
            public int      bmiHeader_biWidth;
            public int      bmiHeader_biHeight;
            public short    bmiHeader_biPlanes;
            public short    bmiHeader_biBitCount;
            public int      bmiHeader_biCompression;
            public int      bmiHeader_biSizeImage;
            public int      bmiHeader_biXPelsPerMeter;
            public int      bmiHeader_biYPelsPerMeter;
            public int      bmiHeader_biClrUsed;
            public int      bmiHeader_biClrImportant;

            // bmiColors was an embedded array of RGBQUAD structures
            public byte     bmiColors_rgbBlue;
            public byte     bmiColors_rgbGreen;
            public byte     bmiColors_rgbRed;
            public byte     bmiColors_rgbReserved;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class BITMAPINFOHEADER {
            public int      biSize = 40;    // ndirect.DllLib.sizeOf( this );
            public int      biWidth;
            public int      biHeight;
            public short    biPlanes;
            public short    biBitCount;
            public int      biCompression;
            public int      biSizeImage;
            public int      biXPelsPerMeter;
            public int      biYPelsPerMeter;
            public int      biClrUsed;
            public int      biClrImportant;
        }
        
        public class Ole {
            public const int PICTYPE_UNINITIALIZED = -1;
            public const int PICTYPE_NONE          =  0;
            public const int PICTYPE_BITMAP        =  1;
            public const int PICTYPE_METAFILE      =  2;
            public const int PICTYPE_ICON          =  3;
            public const int PICTYPE_ENHMETAFILE   =  4;
            public const int STATFLAG_DEFAULT = 0;
            public const int STATFLAG_NONAME = 1;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class FORMATETC {
            public   short cfFormat;
            public   short dummy;
            public   IntPtr ptd;
            public   int dwAspect;
            public   int lindex;
            public   int tymed;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class STATSTG {

            [MarshalAs(UnmanagedType.LPWStr)]
            public   string pwcsName;
            
            public   int type;
            [MarshalAs(UnmanagedType.I8)]
            public   long cbSize;
            [MarshalAs(UnmanagedType.I8)]
            public   long mtime;
            [MarshalAs(UnmanagedType.I8)]
            public   long ctime;
            [MarshalAs(UnmanagedType.I8)]
            public   long atime;
            [MarshalAs(UnmanagedType.I4)]
            public   int grfMode;
            [MarshalAs(UnmanagedType.I4)]
            public   int grfLocksSupported;
            
            public   int clsid_data1;
            [MarshalAs(UnmanagedType.I2)]
            public   short clsid_data2;
            [MarshalAs(UnmanagedType.I2)]
            public   short clsid_data3;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b0;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b1;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b2;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b3;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b4;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b5;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b6;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b7;
            [MarshalAs(UnmanagedType.I4)]
            public   int grfStateBits;
            [MarshalAs(UnmanagedType.I4)]
            public   int reserved;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class FILETIME {
            public int dwLowDateTime;
            public int dwHighDateTime;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class OVERLAPPED {
            public int Internal;
            public int InternalHigh;
            public int Offset;
            public int OffsetHigh;
            public IntPtr hEvent;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class SYSTEMTIME {
            public short wYear;
            public short wMonth;
            public short wDayOfWeek;
            public short wDay;
            public short wHour;
            public short wMinute;
            public short wSecond;
            public short wMilliseconds;

            public override string ToString() {
                return "[SYSTEMTIME: " 
                + wDay.ToString() +"/" + wMonth.ToString() + "/" + wYear.ToString() 
                + " " + wHour.ToString() + ":" + wMinute.ToString() + ":" + wSecond.ToString()
                + "]";
            }
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class STGMEDIUM {
            public   int tymed;
            public   IntPtr unionmember;
            public   IntPtr pUnkForRelease;
        }
        
        [
        StructLayout(LayoutKind.Sequential),
        CLSCompliantAttribute(false)
        ]
        public sealed class  _POINTL {
            public   int x;
            public   int y;

        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class tagSIZE {
            public   int cx;
            public   int cy;

        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class COMRECT {
            public int left;
            public int top;
            public int right;
            public int bottom;
            
            public COMRECT() {
            }

            public COMRECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static COMRECT FromXYWH(int x, int y, int width, int height) {
                return new COMRECT(x, y, x + width, y + height);
            }

            public override string ToString() {
                return "Left = " + left + " Top " + top + " Right = " + right + " Bottom = " + bottom;
            }
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagOleMenuGroupWidths {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=6)/*leftover(offset=0, widths)*/]
            public int[] widths = new int[6];
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class MSOCRINFOSTRUCT {
            public int cbSize = Marshal.SizeOf(typeof(MSOCRINFOSTRUCT));              // size of MSOCRINFO structure in bytes.
            public int uIdleTimeInterval;   // If olecrfNeedPeriodicIdleTime is registered
                                            // in grfcrf, component needs to perform
                                            // periodic idle time tasks during an idle phase
                                            // every uIdleTimeInterval milliseconds.
            public int grfcrf;              // bit flags taken from olecrf values (above)
            public int grfcadvf;            // bit flags taken from olecadvf values (above)
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct NMLISTVIEW
        {
            public NMHDR hdr;
            public int   iItem;
            public int   iSubItem;
            public int   uNewState;
            public int   uOldState;
            public int   uChanged;
            public IntPtr lParam;
        }
        
        public class ConnectionPointCookie
        {
            private UnsafeNativeMethods.IConnectionPoint connectionPoint;
            private int cookie;
            #if DEBUG
            private string callStack;
            #endif
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.ConnectionPointCookie"]/*' />
            /// <devdoc>
            /// Creates a connection point to of the given interface type.
            /// which will call on a managed code sink that implements that interface.
            /// </devdoc>
            public ConnectionPointCookie(object source, object sink, Type eventInterface) : this(source, sink, eventInterface, true){
            }
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.ConnectionPointCookie1"]/*' />
            /// <devdoc>
            /// Creates a connection point to of the given interface type.
            /// which will call on a managed code sink that implements that interface.
            /// </devdoc>
            public ConnectionPointCookie(object source, object sink, Type eventInterface, bool throwException){
                Exception ex = null;
                if (source is UnsafeNativeMethods.IConnectionPointContainer) {
                    UnsafeNativeMethods.IConnectionPointContainer cpc = (UnsafeNativeMethods.IConnectionPointContainer)source;
    
                    try {
                        Guid tmp = eventInterface.GUID;
                        connectionPoint = cpc.FindConnectionPoint(ref tmp);
                    }
                    catch (Exception) {
                        connectionPoint = null;
                    }
    
                    if (connectionPoint == null) {
                        ex = new ArgumentException(SR.GetString(SR.ConnPointSourceIF, eventInterface.Name ));
                    }
                    else if (sink == null || !eventInterface.IsInstanceOfType(sink)) {
                        ex = new InvalidCastException(SR.GetString(SR.ConnPointSinkIF));
                    }
                    else {
                        int hr = connectionPoint.Advise(sink, ref cookie);
                        if (hr != S_OK) {
                            cookie = 0;
                            Marshal.ReleaseComObject(connectionPoint);
                            connectionPoint = null;
                            ex = new ExternalException(SR.GetString(SR.ConnPointAdviseFailed, eventInterface.Name, hr ));
                        }
                    }
                }
                else {
                    ex = new InvalidCastException(SR.GetString(SR.ConnPointSourceIF, "IConnectionPointContainer"));
                }
    
    
                if (throwException && (connectionPoint == null || cookie == 0)) {
                    if (connectionPoint != null) {
                        Marshal.ReleaseComObject(connectionPoint);
                    }

                    if (ex == null) {
                        throw new ArgumentException(SR.GetString(SR.ConnPointCouldNotCreate, eventInterface.Name ));
                    }
                    else {
                        throw ex;
                    }
                }
                
                #if DEBUG
                callStack = Environment.StackTrace;
                #endif
            }
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.Disconnect"]/*' />
            /// <devdoc>
            /// Disconnect the current connection point.  If the object is not connected,
            /// this method will do nothing.
            /// </devdoc>
            public void Disconnect() {
                Disconnect(false);
            }
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.Disconnect1"]/*' />
            /// <devdoc>
            /// Disconnect the current connection point.  If the object is not connected,
            /// this method will do nothing.
            /// </devdoc>
            public void Disconnect(bool release) {
                if (connectionPoint != null && cookie != 0) {
                    connectionPoint.Unadvise(cookie);
                    cookie = 0;
    
                    if (release) {
                        Marshal.ReleaseComObject(connectionPoint);
                    }
    
                    connectionPoint = null;
                }
            }
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.ConnectionPointCookie.Finalize"]/*' />
            /// <internalonly/>
            ~ConnectionPointCookie(){
                System.Diagnostics.Debug.Assert(connectionPoint == null || cookie == 0, "We should never finalize an active connection point");
                Disconnect();
            }
        }

        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagPOINTF
        {
          [MarshalAs(UnmanagedType.R4)/*leftover(offset=0, x)*/]
          public float x;

          [MarshalAs(UnmanagedType.R4)/*leftover(offset=4, y)*/]
          public float y;

        }

        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagOIFI
        {
          [MarshalAs(UnmanagedType.U4)/*leftover(offset=0, cb)*/]
          public int cb;
          
          public int fMDIApp;
          public IntPtr hwndFrame;
          public IntPtr hAccel;

          [MarshalAs(UnmanagedType.U4)/*leftover(offset=16, cAccelEntries)*/]
          public int cAccelEntries;

        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct NMHDR
        {
            public IntPtr hwndFrom;
            public int idFrom;
            public int code;
        }
        
        [ComVisible(true),Guid("626FC520-A41E-11CF-A731-00A0C9082637"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLDocument {

            [return: MarshalAs(UnmanagedType.Interface)]
              object GetScript();

        }

        [ComImport(), Guid("376BD3AA-3845-101B-84ED-08002B2EC713"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPerPropertyBrowsing {
             [PreserveSig]
             int GetDisplayString(
                int dispID,
                [Out, MarshalAs(UnmanagedType.LPArray)]
                string[] pBstr);
            
             [PreserveSig]
             int MapPropertyToPage(
                int dispID,
                [Out]
                out Guid pGuid);
            
             [PreserveSig]
             int GetPredefinedStrings(
                int dispID,
                [Out]
                CA_STRUCT pCaStringsOut,
                [Out]
                CA_STRUCT pCaCookiesOut);

             [PreserveSig]
             int GetPredefinedValue(
                int dispID,
                [In, MarshalAs(UnmanagedType.U4)]
                int dwCookie,
                [Out]
                VARIANT pVarOut);
        }
        
        [ComImport(), Guid("4D07FC10-F931-11CE-B001-00AA006884E5"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface ICategorizeProperties {
            
             [PreserveSig]
             int MapPropertyToCategory(
                int dispID,
                ref int categoryID);

             [PreserveSig]
             int GetCategoryName(
                int propcat,
                [In, MarshalAs(UnmanagedType.U4)]
                int lcid,
                out string categoryName);
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagSIZEL
        {
            public int cx;
            public int cy;
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagOLEVERB
        {
            public int lVerb;
            
            [MarshalAs(UnmanagedType.LPWStr)/*leftover(offset=4, customMarshal="UniStringMarshaller", lpszVerbName)*/]
            public string lpszVerbName;
            
            [MarshalAs(UnmanagedType.U4)/*leftover(offset=8, fuFlags)*/]
            public int fuFlags;
            
            [MarshalAs(UnmanagedType.U4)/*leftover(offset=12, grfAttribs)*/]
            public int grfAttribs;
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagLOGPALETTE
        {
            [MarshalAs(UnmanagedType.U2)/*leftover(offset=0, palVersion)*/]
            public short palVersion;
            
            [MarshalAs(UnmanagedType.U2)/*leftover(offset=2, palNumEntries)*/]
            public short palNumEntries;
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagCONTROLINFO
        {
            [MarshalAs(UnmanagedType.U4)/*leftover(offset=0, cb)*/]
            public int cb = Marshal.SizeOf(typeof(tagCONTROLINFO));
            
            public IntPtr hAccel;
            
            [MarshalAs(UnmanagedType.U2)/*leftover(offset=8, cAccel)*/]
            public short cAccel;
            
            [MarshalAs(UnmanagedType.U4)/*leftover(offset=10, dwFlags)*/]
            public int dwFlags;
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class CA_STRUCT
        {
            public int cElems;
            public IntPtr pElems;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class VARIANT {
            [MarshalAs(UnmanagedType.I2)]
            public short vt;
            [MarshalAs(UnmanagedType.I2)]
            public short reserved1;
            [MarshalAs(UnmanagedType.I2)]
            public short reserved2;
            [MarshalAs(UnmanagedType.I2)]
            public short reserved3;
            
            public IntPtr data1;
            
            public IntPtr data2;


            public bool Byref{
                get{
                    return 0 != (vt & (int)tagVT.VT_BYREF);
                }
            }

            public void Clear() {
                if ((this.vt == (int)tagVT.VT_UNKNOWN || this.vt == (int)tagVT.VT_DISPATCH) && this.data1 != IntPtr.Zero) {
                    Marshal.Release(this.data1);
                }

                if (this.vt == (int)tagVT.VT_BSTR && this.data1 != IntPtr.Zero) {
                    SysFreeString(this.data1);
                }

                this.data1 = this.data2 = IntPtr.Zero;
                this.vt = (int)tagVT.VT_EMPTY;
            }

            ~VARIANT() {
                Clear();
            }

            public static VARIANT FromObject(Object var) {
                VARIANT v = new VARIANT();

                if (var == null) {
                    v.vt = (int)tagVT.VT_EMPTY;
                }
                else if (Convert.IsDBNull(var)) {
                }
                else {
                    Type t = var.GetType();

                    if (t == typeof(bool)) {
                        v.vt = (int)tagVT.VT_BOOL;
                    }
                    else if (t == typeof(byte)) {
                        v.vt = (int)tagVT.VT_UI1;
                        v.data1 = (IntPtr)Convert.ToByte(var);
                    }
                    else if (t == typeof(char)) {
                        v.vt = (int)tagVT.VT_UI2;
                        v.data1 = (IntPtr)Convert.ToChar(var);
                    }
                    else if (t == typeof(string)) {
                        v.vt = (int)tagVT.VT_BSTR;
                        v.data1 = SysAllocString(Convert.ToString(var));
                    }
                    else if (t == typeof(short)) {
                        v.vt = (int)tagVT.VT_I2;
                        v.data1 = (IntPtr)Convert.ToInt16(var);
                    }
                    else if (t == typeof(int)) {
                        v.vt = (int)tagVT.VT_I4;
                        v.data1 = (IntPtr)Convert.ToInt32(var);
                    }
                    else if (t == typeof(long)) {
                        v.vt = (int)tagVT.VT_I8;
                        v.SetLong(Convert.ToInt64(var));
                    }
                    else if (t == typeof(Decimal)) {
                        v.vt = (int)tagVT.VT_CY;
                        Decimal c = (Decimal)var;
                        // SBUrke, it's bizzare that we need to call this as a static!
                        v.SetLong(Decimal.ToInt64(c));
                    }
                    else if (t == typeof(decimal)) {
                        v.vt = (int)tagVT.VT_DECIMAL;
                        Decimal d = Convert.ToDecimal(var);
                        v.SetLong(Decimal.ToInt64(d));
                    }
                    else if (t == typeof(double)) {
                        v.vt = (int)tagVT.VT_R8;
                        // how do we handle double?
                    }
                    else if (t == typeof(float) || t == typeof(Single)) {
                        v.vt = (int)tagVT.VT_R4;
                        // how do we handle float?
                    }
                    else if (t == typeof(DateTime)) {
                        v.vt = (int)tagVT.VT_DATE;
                        v.SetLong(Convert.ToDateTime(var).ToFileTime());
                    }
                    else if (t == typeof(SByte)) {
                        v.vt = (int)tagVT.VT_I1;
                        v.data1 = (IntPtr)Convert.ToSByte(var);
                    }
                    else if (t == typeof(UInt16)) {
                        v.vt = (int)tagVT.VT_UI2;
                        v.data1 = (IntPtr)Convert.ToUInt16(var);
                    }
                    else if (t == typeof(UInt32)) {
                        v.vt = (int)tagVT.VT_UI4;
                        v.data1 = (IntPtr)Convert.ToUInt32(var);
                    }
                    else if (t == typeof(UInt64)) {
                        v.vt = (int)tagVT.VT_UI8;
                        v.SetLong((long)Convert.ToUInt64(var));
                    }
                    else if (t == typeof(object) || t == typeof(UnsafeNativeMethods.IDispatch) || t.IsCOMObject) {
                        v.vt = (t == typeof(UnsafeNativeMethods.IDispatch) ? (short)tagVT.VT_DISPATCH : (short)tagVT.VT_UNKNOWN);
                        v.data1 = Marshal.GetIUnknownForObject(var);
                    }
                    else {
                        throw new ArgumentException(SR.GetString(SR.ConnPointUnhandledType, t.Name));
                    }
                }
                return v;
            }

            [DllImport(ExternDll.Oleaut32,CharSet=CharSet.Auto)]
            private static extern IntPtr SysAllocString([In, MarshalAs(UnmanagedType.LPWStr)]string s);

            [DllImport(ExternDll.Oleaut32,CharSet=CharSet.Auto)]
            private static extern void SysFreeString(IntPtr pbstr);

            public void SetLong(long lVal) {
                data1 = (IntPtr)(lVal & 0xFFFFFFFF);
                data2 = (IntPtr)((lVal >> 32) & 0xFFFFFFFF);
            }

            public IntPtr ToCoTaskMemPtr() {
                IntPtr mem = Marshal.AllocCoTaskMem(16);
                Marshal.WriteInt16(mem, vt);
                Marshal.WriteInt16(mem, 2, reserved1);
                Marshal.WriteInt16(mem, 4, reserved2);
                Marshal.WriteInt16(mem, 6, reserved3);
                Marshal.WriteInt32(mem, 8, (int) data1);
                Marshal.WriteInt32(mem, 12, (int) data2);
                return mem;
            }

            public object ToObject() {
                IntPtr val = data1;
                long longVal;

                int vtType = (int)(this.vt & (short)tagVT.VT_TYPEMASK);

                switch (vtType) {
                case (int)tagVT.VT_EMPTY:
                    return null;
                case (int)tagVT.VT_NULL:
                    return Convert.DBNull;

                case (int)tagVT.VT_I1:
                    if (Byref) {
                        val = (IntPtr) Marshal.ReadByte(val);
                    }
                    return (SByte) (0xFF & (SByte) val);

                case (int)tagVT.VT_UI1:
                    if (Byref) {
                        val = (IntPtr) Marshal.ReadByte(val);
                    }

                    return (byte) (0xFF & (byte) val);

                case (int)tagVT.VT_I2:
                    if (Byref) {
                        val = (IntPtr) Marshal.ReadInt16(val);
                    }
                    return (short)(0xFFFF & (short) val);

                case (int)tagVT.VT_UI2:
                    if (Byref) {
                        val = (IntPtr) Marshal.ReadInt16(val);
                    }
                    return (UInt16)(0xFFFF & (UInt16) val);

                case (int)tagVT.VT_I4:
                case (int)tagVT.VT_INT:
                    if (Byref) {
                        val = (IntPtr) Marshal.ReadInt32(val);
                    }
                    return (int)val;

                case (int)tagVT.VT_UI4:
                case (int)tagVT.VT_UINT:
                    if (Byref) {
                        val = (IntPtr) Marshal.ReadInt32(val);
                    }
                    return (UInt32)val;

                case (int)tagVT.VT_I8:
                case (int)tagVT.VT_UI8:
                    if (Byref) {
                        longVal = Marshal.ReadInt64(val);
                    }
                    else {
                        longVal = ((int)data1 & 0xffffffff) | ((int)data2 << 32);
                    }

                    if (vt == (int)tagVT.VT_I8) {
                        return (long)longVal;
                    }
                    else {
                        return (UInt64)longVal;
                    }
                }

                if (Byref) {
                    val = GetRefInt(val);
                }

                switch (vtType) {
                case (int)tagVT.VT_R4:
                case (int)tagVT.VT_R8:

                    // can I use unsafe here?
                    throw new FormatException(SR.GetString(SR.CannotConvertIntToFloat));

                case (int)tagVT.VT_CY:
                    // internally currency is 8-byte int scaled by 10,000
                    longVal = ((int)data1 & 0xffffffff) | ((int)data2 << 32);
                    return new Decimal(longVal);
                case (int)tagVT.VT_DATE:
                    throw new FormatException(SR.GetString(SR.CannotConvertDoubleToDate));

                case (int)tagVT.VT_BSTR:
                case (int)tagVT.VT_LPWSTR:
                    return Marshal.PtrToStringUni(val);

                case (int)tagVT.VT_LPSTR:
                    return Marshal.PtrToStringAnsi(val);

                case (int)tagVT.VT_DISPATCH:
                case (int)tagVT.VT_UNKNOWN:
                    {
                        return Marshal.GetObjectForIUnknown(val);
                    }

                case (int)tagVT.VT_HRESULT:
                    return val;

                case (int)tagVT.VT_DECIMAL:
                    longVal = ((int)data1 & 0xffffffff) | ((int)data2 << 32);
                    return new Decimal(longVal);

                case (int)tagVT.VT_BOOL:
                    return (val != IntPtr.Zero);

                case (int)tagVT.VT_VARIANT:
                    VARIANT varStruct = (VARIANT)UnsafeNativeMethods.PtrToStructure(val, typeof(VARIANT));
                    return varStruct.ToObject();
                case (int)tagVT.VT_CLSID:
                    //Debug.Fail("PtrToStructure will not work with System.Guid...");
                    Guid guid =(Guid)UnsafeNativeMethods.PtrToStructure(val, typeof(Guid));
                    return guid;

                case (int)tagVT.VT_FILETIME:
                    longVal = ((int)data1 & 0xffffffff) | ((int)data2 << 32);
                    return new DateTime(longVal);

                case (int)tagVT.VT_USERDEFINED:
                    throw new ArgumentException(SR.GetString(SR.COM2UnhandledVT, "VT_USERDEFINED"));

                case (int)tagVT.VT_ARRAY:
                    //gSAFEARRAY sa = (tagSAFEARRAY)Marshal.PtrToStructure(val), typeof(tagSAFEARRAY));
                    //return GetArrayFromSafeArray(sa);

                case (int)tagVT.VT_VOID:
                case (int)tagVT.VT_PTR:
                case (int)tagVT.VT_SAFEARRAY:
                case (int)tagVT.VT_CARRAY:

                case (int)tagVT.VT_RECORD:
                case (int)tagVT.VT_BLOB:
                case (int)tagVT.VT_STREAM:
                case (int)tagVT.VT_STORAGE:
                case (int)tagVT.VT_STREAMED_OBJECT:
                case (int)tagVT.VT_STORED_OBJECT:
                case (int)tagVT.VT_BLOB_OBJECT:
                case (int)tagVT.VT_CF:
                case (int)tagVT.VT_BSTR_BLOB:
                case (int)tagVT.VT_VECTOR:
                case (int)tagVT.VT_BYREF:
                    //case (int)tagVT.VT_RESERVED:
                default:
                    int iVt = this.vt;
                    throw new ArgumentException(SR.GetString(SR.COM2UnhandledVT, iVt.ToString()));
                }
            }

            private static IntPtr GetRefInt(IntPtr value) {
                return Marshal.ReadIntPtr(value);
            }
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagLICINFO
        {
          [MarshalAs(UnmanagedType.U4)/*leftover(offset=0, cb)*/]
          public int cbLicInfo = Marshal.SizeOf(typeof(tagLICINFO));
          
          public int fRuntimeAvailable;
          public int fLicVerified;
        }
        
        public enum  tagVT {
            VT_EMPTY = 0,
            VT_NULL = 1,
            VT_I2 = 2,
            VT_I4 = 3,
            VT_R4 = 4,
            VT_R8 = 5,
            VT_CY = 6,
            VT_DATE = 7,
            VT_BSTR = 8,
            VT_DISPATCH = 9,
            VT_ERROR = 10,
            VT_BOOL = 11,
            VT_VARIANT = 12,
            VT_UNKNOWN = 13,
            VT_DECIMAL = 14,
            VT_I1 = 16,
            VT_UI1 = 17,
            VT_UI2 = 18,
            VT_UI4 = 19,
            VT_I8 = 20,
            VT_UI8 = 21,
            VT_INT = 22,
            VT_UINT = 23,
            VT_VOID = 24,
            VT_HRESULT = 25,
            VT_PTR = 26,
            VT_SAFEARRAY = 27,
            VT_CARRAY = 28,
            VT_USERDEFINED = 29,
            VT_LPSTR = 30,
            VT_LPWSTR = 31,
            VT_RECORD = 36,
            VT_FILETIME = 64,
            VT_BLOB = 65,
            VT_STREAM = 66,
            VT_STORAGE = 67,
            VT_STREAMED_OBJECT = 68,
            VT_STORED_OBJECT = 69,
            VT_BLOB_OBJECT = 70,
            VT_CF = 71,
            VT_CLSID = 72,
            VT_BSTR_BLOB = 4095,
            VT_VECTOR = 4096,
            VT_ARRAY = 8192,
            VT_BYREF = 16384,
            VT_RESERVED = 32768,
            VT_ILLEGAL = 65535,
            VT_ILLEGALMASKED = 4095,
            VT_TYPEMASK = 4095
        }
        
        public delegate void TimerProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class WNDCLASS_D {
            public int      style;
            public WndProc  lpfnWndProc;
            public int      cbClsExtra = 0;
            public int      cbWndExtra = 0;
            public IntPtr   hInstance = IntPtr.Zero;
            public IntPtr   hIcon = IntPtr.Zero;
            public IntPtr   hCursor = IntPtr.Zero;
            public IntPtr   hbrBackground = IntPtr.Zero;
            public string   lpszMenuName = null;
            public string   lpszClassName = null;
        }
    
        public class MSOCM {
            // MSO Component registration flags
            public const int msocrfNeedIdleTime         = 1;
            public const int msocrfNeedPeriodicIdleTime = 2;
            public const int msocrfPreTranslateKeys     = 4;
            public const int msocrfPreTranslateAll      = 8;
            public const int msocrfNeedSpecActiveNotifs = 16;
            public const int msocrfNeedAllActiveNotifs  = 32;
            public const int msocrfExclusiveBorderSpace = 64;
            public const int msocrfExclusiveActivation = 128;
            public const int msocrfNeedAllMacEvents = 256;
            public const int msocrfMaster           = 512;
    
            // MSO Component registration advise flags (see msocstate enumeration)
            public const int msocadvfModal              = 1;
            public const int msocadvfRedrawOff          = 2;
            public const int msocadvfWarningsOff        = 4;
            public const int msocadvfRecording          = 8;
    
            // MSO Component Host flags
            public const int msochostfExclusiveBorderSpace = 1;
    
            // MSO idle flags, passed to IMsoComponent::FDoIdle and 
            // IMsoStdComponentMgr::FDoIdle.
            public const int msoidlefPeriodic    = 1;
            public const int msoidlefNonPeriodic = 2;
            public const int msoidlefPriority    = 4;
            public const int msoidlefAll         = -1;
    
            // MSO Reasons for pushing a message loop, passed to 
            // IMsoComponentManager::FPushMessageLoop and 
            // IMsoComponentHost::FPushMessageLoop.  The host should remain in message
            // loop until IMsoComponent::FContinueMessageLoop 
            public const int msoloopMain      = -1; // Note this is not an official MSO loop -- it just must be distinct.
            public const int msoloopFocusWait = 1;
            public const int msoloopDoEvents  = 2;
            public const int msoloopDebug     = 3;
            public const int msoloopModalForm = 4;
            public const int msoloopModalAlert = 5;
    
    
            /* msocstate values: state IDs passed to 
                IMsoComponent::OnEnterState, 
                IMsoComponentManager::OnComponentEnterState/FOnComponentExitState/FInState,
                IMsoComponentHost::OnComponentEnterState,
                IMsoStdComponentMgr::OnHostEnterState/FOnHostExitState/FInState.
                When the host or a component is notified through one of these methods that 
                another entity (component or host) is entering or exiting a state 
                identified by one of these state IDs, the host/component should take
                appropriate action:
                    msocstateModal (modal state):
                        If app is entering modal state, host/component should disable
                        its toplevel windows, and reenable them when app exits this
                        state.  Also, when this state is entered or exited, host/component
                        should notify approprate inplace objects via 
                        IOleInPlaceActiveObject::EnableModeless.
                    msocstateRedrawOff (redrawOff state):
                        If app is entering redrawOff state, host/component should disable
                        repainting of its windows, and reenable repainting when app exits
                        this state.
                    msocstateWarningsOff (warningsOff state):
                        If app is entering warningsOff state, host/component should disable
                        the presentation of any user warnings, and reenable this when
                        app exits this state.
                    msocstateRecording (Recording state):
                        Used to notify host/component when Recording is turned on or off. */
            public const int msocstateModal       = 1;
            public const int msocstateRedrawOff   = 2;
            public const int msocstateWarningsOff = 3;
            public const int msocstateRecording   = 4;
    
    
            /*             ** Comments on State Contexts **
            IMsoComponentManager::FCreateSubComponentManager allows one to create a 
            hierarchical tree of component managers.  This tree is used to maintain 
            multiple contexts with regard to msocstateXXX states.  These contexts are 
            referred to as 'state contexts'.
            Each component manager in the tree defines a state context.  The
            components registered with a particular component manager or any of its
            descendents live within that component manager's state context.  Calls
            to IMsoComponentManager::OnComponentEnterState/FOnComponentExitState
            can be used to  affect all components, only components within the component
            manager's state context, or only those components that are outside of the
            component manager's state context.  IMsoComponentManager::FInState is used
            to query the state of the component manager's state context at its root.
        
            msoccontext values: context indicators passed to 
            IMsoComponentManager::OnComponentEnterState/FOnComponentExitState.
            These values indicate the state context that is to be affected by the
            state change. 
            In IMsoComponentManager::OnComponentEnterState/FOnComponentExitState,
            the comp mgr informs only those components/host that are within the
            specified state context. */
            public const int msoccontextAll    = 0;
            public const int msoccontextMine   = 1;
            public const int msoccontextOthers = 2; 
    
            /*     ** WM_MOUSEACTIVATE Note (for top level compoenents and host) **
            If the active (or tracking) comp's reg info indicates that it
            wants mouse messages, then no MA_xxxANDEAT value should be returned 
            from WM_MOUSEACTIVATE, so that the active (or tracking) comp will be able
            to process the resulting mouse message.  If one does not want to examine
            the reg info, no MA_xxxANDEAT value should be returned from 
            WM_MOUSEACTIVATE if any comp is active (or tracking).
            One can query the reg info of the active (or tracking) component at any
            time via IMsoComponentManager::FGetActiveComponent. */
    
            /* msogac values: values passed to 
            IMsoComponentManager::FGetActiveComponent. */
            public const int msogacActive    = 0;
            public const int msogacTracking   = 1;
            public const int msogacTrackingOrActive = 2; 
    
            /* msocWindow values: values passed to IMsoComponent::HwndGetWindow. */
            public const int msocWindowFrameToplevel = 0;
            public const int msocWindowFrameOwner = 1;
            public const int msocWindowComponent = 2;
            public const int msocWindowDlgOwner = 3;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class TOOLINFO_T
        {
            public int      cbSize = Marshal.SizeOf(typeof(TOOLINFO_T));
            public int      uFlags;
            public IntPtr   hwnd;
            public IntPtr   uId;
            public RECT     rect;
            public IntPtr   hinst;
            public string   lpszText;
            public IntPtr   lParam;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class tagDVTARGETDEVICE {
            [MarshalAs(UnmanagedType.U4)]
            public   int tdSize;
            [MarshalAs(UnmanagedType.U2)]
            public   short tdDriverNameOffset;
            [MarshalAs(UnmanagedType.U2)]
            public   short tdDeviceNameOffset;
            [MarshalAs(UnmanagedType.U2)]
            public   short tdPortNameOffset;
            [MarshalAs(UnmanagedType.U2)]
            public   short tdExtDevmodeOffset;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public struct TV_ITEM {
            public int      mask;
            public IntPtr   hItem;
            public int      state;
            public int      stateMask;
            public IntPtr /* LPTSTR */ pszText;
            public int      cchTextMax;
            public int      iImage;
            public int      iSelectedImage;
            public int      cChildren;
            public IntPtr   lParam;
        }

        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public struct TV_INSERTSTRUCT {
            public IntPtr   hParent;
            public IntPtr   hInsertAfter;
            public int      item_mask;
            public int      item_hItem;
            public int      item_state;
            public int      item_stateMask;
            public IntPtr /* LPTSTR */ item_pszText;
            public int      item_cchTextMax;
            public int      item_iImage;
            public int      item_iSelectedImage;
            public int      item_cChildren;
            public IntPtr   item_lParam;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct NMTREEVIEW
        {
            public NMHDR    nmhdr;
            public int      action;
            public TV_ITEM  itemOld;
            public TV_ITEM  itemNew;
            public int      ptDrag_X; // This should be declared as POINT
            public int      ptDrag_Y; // we use unsafe blocks to manipulate 
                                      // NMTREEVIEW quickly, and POINT is declared
                                      // as a class.  Too much churn to change POINT
                                      // now.
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class NMTVDISPINFO
        {
            public NMHDR    hdr;
            public TV_ITEM  item;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class POINTL {
            public   int x;
            public   int y;
        }
    
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public struct HIGHCONTRAST {
            public int cbSize;
            public int dwFlags;
            public string lpszDefaultScheme;
        }

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public struct HIGHCONTRAST_I {
            public int cbSize;
            public int dwFlags;
            public IntPtr lpszDefaultScheme;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class TCITEM_T
        {
            public int      mask;
            public int      dwState;
            public int      dwStateMask;
            public string   pszText;
            public int      cchTextMax;
            public int      iImage;
            public IntPtr   lParam;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class STATDATA {
            [MarshalAs(UnmanagedType.U4)]
            public   int advf;
            [MarshalAs(UnmanagedType.U4)]
            public   int dwConnection;
        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagDISPPARAMS
        {
          public IntPtr rgvarg;
          public IntPtr rgdispidNamedArgs;
          [MarshalAs(UnmanagedType.U4)/*leftover(offset=8, cArgs)*/]
          public int cArgs;
          [MarshalAs(UnmanagedType.U4)/*leftover(offset=12, cNamedArgs)*/]
          public int cNamedArgs;
        }
        
        public enum  tagINVOKEKIND {
            INVOKE_FUNC = 1,
            INVOKE_PROPERTYGET = 2,
            INVOKE_PROPERTYPUT = 4,
            INVOKE_PROPERTYPUTREF = 8
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class tagEXCEPINFO {
            [MarshalAs(UnmanagedType.U2)]
            public short wCode;
            [MarshalAs(UnmanagedType.U2)]
            public short wReserved;
            [MarshalAs(UnmanagedType.BStr)]
            public string bstrSource;
            [MarshalAs(UnmanagedType.BStr)]
            public string bstrDescription;
            [MarshalAs(UnmanagedType.BStr)]
            public string bstrHelpFile;
            [MarshalAs(UnmanagedType.U4)]
            public int dwHelpContext;
            
            public IntPtr pvReserved;
            
            public IntPtr pfnDeferredFillIn;
            [MarshalAs(UnmanagedType.U4)]
            public int scode;
        }
        
        public enum  tagDESCKIND {
            DESCKIND_NONE = 0,
            DESCKIND_FUNCDESC = 1,
            DESCKIND_VARDESC = 2,
            DESCKIND_TYPECOMP = 3,
            DESCKIND_IMPLICITAPPOBJ = 4,
            DESCKIND_MAX = 5
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class tagFUNCDESC {
            public   int memid;
            [MarshalAs(UnmanagedType.U2)]
            public   short lprgscode;

            // This is marked as NATIVE_TYPE_PTR,
            // but the EE doesn't look for that, tries to handle it as
            // a ELEMENT_TYPE_VALUECLASS and fails because it
            // isn't a NATIVE_TYPE_NESTEDSTRUCT
            /*[MarshalAs(UnmanagedType.PTR)]*/
            
            public    /*NativeMethods.tagELEMDESC*/ IntPtr lprgelemdescParam;

            // cpb, SBurke, the EE chokes on Enums in structs
            
            public    /*NativeMethods.tagFUNCKIND*/ int funckind;
            
            public    /*NativeMethods.tagINVOKEKIND*/ int invkind;
            
            public    /*NativeMethods.tagCALLCONV*/ int callconv;
            [MarshalAs(UnmanagedType.I2)]
            public   short cParams;
            [MarshalAs(UnmanagedType.I2)]
            public   short cParamsOpt;
            [MarshalAs(UnmanagedType.I2)]
            public   short oVft;
            [MarshalAs(UnmanagedType.I2)]
            public   short cScodes;
            public   NativeMethods.value_tagELEMDESC elemdescFunc;
            [MarshalAs(UnmanagedType.U2)]
            public   short wFuncFlags;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public sealed class tagVARDESC {
            public   int memid;
            public   IntPtr lpstrSchema;
            public   IntPtr unionMember;
            public   NativeMethods.value_tagELEMDESC elemdescVar;
            [MarshalAs(UnmanagedType.U2)]
            public   short wVarFlags;
            public    /*NativeMethods.tagVARKIND*/ int varkind;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct  value_tagELEMDESC {
            public    NativeMethods.tagTYPEDESC tdesc;
            public    NativeMethods.tagPARAMDESC paramdesc;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct WINDOWPOS {
            public IntPtr hwnd;
            public IntPtr hwndInsertAfter;
            public int x;
            public int y;
            public int cx;
            public int cy;
            public int flags;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class DRAWITEMSTRUCT {
            public int CtlType;
            public int CtlID;
            public int itemID;
            public int itemAction;
            public int itemState;
            public IntPtr hwndItem;
            public IntPtr hDC;
            public RECT   rcItem;
            public IntPtr itemData;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class MEASUREITEMSTRUCT {
            public int CtlType;
            public int CtlID;
            public int itemID;
            public int itemWidth;
            public int itemHeight;
            public IntPtr itemData;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class HELPINFO {
            public int      cbSize = Marshal.SizeOf(typeof(HELPINFO));
            public int      iContextType;
            public int      iCtrlId;
            public IntPtr   hItemHandle;
            public int      dwContextId;
            public POINT    MousePos;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public class ACCEL {
            public byte fVirt;
            public short key;
            public short cmd;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class MINMAXINFO {
            public POINT    ptReserved;
            public POINT    ptMaxSize;
            public POINT    ptMaxPosition;
            public POINT    ptMinTrackSize;
            public POINT    ptMaxTrackSize;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class CREATESTRUCT {
            public IntPtr lpCreateParams;
            public IntPtr hInstance;
            public IntPtr hMenu;
            public IntPtr hwndParent;
            public int cy;
            public int cx;
            public int y;
            public int x;
            public int style;
            public string lpszName;
            public string lpszClass;
            public int dwExStyle;
        }
    
        [ComImport(), Guid("B196B28B-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface ISpecifyPropertyPages {
             void GetPages(
                [Out] 
                NativeMethods.tagCAUUID pPages);

        }
        
        [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagCAUUID
        {
            [MarshalAs(UnmanagedType.U4)/*leftover(offset=0, cElems)*/]
            public int cElems;
            public IntPtr pElems;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct NMTOOLBAR
        {
            public NMHDR    hdr;
            public int      iItem;
            public TBBUTTON tbButton;
            public int      cchText;
            public IntPtr   pszText;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1)]
        public struct TBBUTTON {
            public int      iBitmap;
            public int      idCommand;
            public byte     fsState;
            public byte     fsStyle;
            public byte     bReserved0;
            public byte     bReserved1;
            public int      dwData;
            public int      iString;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class TOOLTIPTEXT
        {
            public NMHDR  hdr;
            public IntPtr lpszText;
            
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
            public string szText;
            
            public IntPtr hinst;
            public int    uFlags;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]
        public class TOOLTIPTEXTA
        {
            public NMHDR  hdr;
            public IntPtr lpszText;
            
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
            public string szText;
            
            public IntPtr hinst;
            public int    uFlags;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public struct TBBUTTONINFO
        {
            public int      cbSize;
            public int      dwMask;
            public int      idCommand;
            public int      iImage;
            public byte     fsState;
            public byte     fsStyle;
            public short    cx;
            public IntPtr   lParam;
            public IntPtr   pszText;
            public int      cchTest;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class TV_HITTESTINFO {
            public int      pt_x;
            public int      pt_y;
            public int      flags;
            public IntPtr   hItem;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class NMTVCUSTOMDRAW
        {
            public NMCUSTOMDRAW    nmcd;
            public int clrText;
            public int clrTextBk;
            public int iLevel;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct NMCUSTOMDRAW {
            public NMHDR    nmcd;
            public int      dwDrawStage;
            public IntPtr   hdc;
            public RECT     rc;
            public int      dwItemSpec;
            public int      uItemState;
            public IntPtr   lItemlParam;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class MCHITTESTINFO {
            public int      cbSize = Marshal.SizeOf(typeof(MCHITTESTINFO));
            public int      pt_x;
            public int      pt_y;
            public int      uHit;
            public short st_wYear;
            public short st_wMonth;
            public short st_wDayOfWeek;
            public short st_wDay;
            public short st_wHour;
            public short st_wMinute;
            public short st_wSecond;
            public short st_wMilliseconds;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMSELCHANGE
        {
            public NMHDR        nmhdr;
            public SYSTEMTIME   stSelStart;
            public SYSTEMTIME   stSelEnd;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMDAYSTATE
        {
            public NMHDR        nmhdr;
            public SYSTEMTIME   stStart;
            public int          cDayState;
            public IntPtr       prgDayState;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct NMLVCUSTOMDRAW
        {
            public NMCUSTOMDRAW    nmcd;
            public int clrText;
            public int clrTextBk;
            public int iSubItem;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class NMLVKEYDOWN
        {
            public NMHDR hdr;
            public short wVKey;
            public uint flags;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class LVHITTESTINFO {
            public int      pt_x;
            public int      pt_y;
            public int      flags;
            public int      iItem;
            public int      iSubItem;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class LVCOLUMN_T
        {
            public int      mask;
            public int      fmt;
            public int      cx;
            public string   pszText;
            public int      cchTextMax;
            public int      iSubItem;
            public int      iImage;
            public int      iOrder;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public struct LVFINDINFO {
            public int      flags;
            public string   psz;
            public IntPtr   lParam;
            public int      ptX; // was POINT pt
            public int      ptY;
            public int      vkDirection;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public struct LVITEM {
            public int      mask;
            public int      iItem;
            public int      iSubItem;
            public int      state;
            public int      stateMask;
            public string   pszText;
            public int      cchTextMax;
            public int      iImage;
            public IntPtr   lParam;
            public int      iIndent;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public struct LVITEM_NOTEXT {
            public int      mask;
            public int      iItem;
            public int      iSubItem;
            public int      state;
            public int      stateMask;
            public IntPtr /*string*/   pszText;
            public int      cchTextMax;
            public int      iImage;
            public IntPtr   lParam;
            public int      iIndent;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
        public class LVCOLUMN {
            public int      mask;
            public int      fmt;
            public int      cx;
            public IntPtr /* LPWSTR */ pszText;
            public int      cchTextMax;
            public int      iSubItem;
            public int      iImage;
            public int      iOrder;
        }
    
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMLVDISPINFO
        {
            public NMHDR  hdr;
            public LVITEM item;
        }
    
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMLVDISPINFO_NOTEXT
        {
            public NMHDR  hdr;
            public LVITEM_NOTEXT item;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public class CLIENTCREATESTRUCT {
            public IntPtr hWindowMenu;
            public int idFirstChild;
        
            public CLIENTCREATESTRUCT(IntPtr hmenu, int idFirst) {
                hWindowMenu = hmenu;
                idFirstChild = idFirst;
            }
        }
    
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMDATETIMECHANGE
        {
            public NMHDR        nmhdr;
            public int          dwFlags;
            public SYSTEMTIME   st;
        }

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMDATETIMEFORMAT
        {
            public NMHDR      nmhdr;
            public string     pszFormat;
            public SYSTEMTIME st;
            public string     pszDisplay;
    
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)]
            public string     szDisplay;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMDATETIMEFORMATQUERY
        {
            public NMHDR  nmhdr;
            public string pszFormat;
            public SIZE   szMax;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class NMDATETIMEWMKEYDOWN
        {
            public NMHDR      nmhdr;
            public int        nVirtKey;
            public string     pszFormat;
            public SYSTEMTIME st;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class COPYDATASTRUCT {
            public int dwData;
            public int cbData;
            public IntPtr lpData;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class NMHEADER {
            public IntPtr hwndFrom; 
            public int idFrom; 
            public int code; 
            public int iItem;
            public int iButton;
            public IntPtr pItem;  // HDITEM*
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class MOUSEHOOKSTRUCT {
            // pt was a by-value POINT structure
            public int      pt_x;
            public int      pt_y;
            public IntPtr   hWnd;
            public int      wHitTestCode;
            public int      dwExtraInfo;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class CHARRANGE
        {
            public int  cpMin;
            public int  cpMax;
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public class CHARFORMATW
        {
            public int      cbSize = Marshal.SizeOf(typeof(CHARFORMATW));
            public int      dwMask;
            public int      dwEffects;
            public int      yHeight;
            public int      yOffset;
            public int      crTextColor;
            public byte     bCharSet;
            public byte     bPitchAndFamily;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=64)]
            public byte[]   szFaceName = new byte[64];
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public class CHARFORMATA
        {
            public int      cbSize = Marshal.SizeOf(typeof(CHARFORMATA));
            public int      dwMask;
            public int      dwEffects;
            public int      yHeight;
            public int      yOffset;
            public int      crTextColor;
            public byte     bCharSet;
            public byte     bPitchAndFamily;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
            public byte[]   szFaceName = new byte[32];
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class TEXTRANGE
        {
            public CHARRANGE    chrg;
            public IntPtr       lpstrText; /* allocated by caller, zero terminated by RichEdit */
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi, Pack=4)]
        public class SELCHANGE {
            public NMHDR nmhdr;
            public CHARRANGE chrg;
            public int seltyp;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class PARAFORMAT
        {
            public int      cbSize = Marshal.SizeOf(typeof(PARAFORMAT));
            public int      dwMask;
            public short    wNumbering;
            public short    wReserved;
            public int      dxStartIndent;
            public int      dxRightIndent;
            public int      dxOffset;
            public short    wAlignment;
            public short    cTabCount;
    
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
            public int[]    rgxTabs;
        }
    
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class FINDTEXT
        {
            public CHARRANGE    chrg;
            public string       lpstrText;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class REPASTESPECIAL
        {
            public int  dwAspect;
            public int  dwParam;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class ENLINK
        {
            public NMHDR    nmhdr;
            public int      msg;
            public IntPtr   wParam;
            public IntPtr   lParam;
            public CHARRANGE charrange;
        }
    
        public abstract class CharBuffer {
    
            public static CharBuffer CreateBuffer(int size) {
                if (Marshal.SystemDefaultCharSize == 1) {
                    return new AnsiCharBuffer(size);
                }
                return new UnicodeCharBuffer(size);
            }
    
            public abstract IntPtr AllocCoTaskMem();
            public abstract string GetString();
            public abstract void PutCoTaskMem(IntPtr ptr);
            public abstract void PutString(string s);
        }
    
        public class AnsiCharBuffer : CharBuffer {
    
            internal byte[] buffer;
            internal int offset;
    
            public AnsiCharBuffer(int size) {
                buffer = new byte[size];
            }
    
            public override IntPtr AllocCoTaskMem() {
                IntPtr result = Marshal.AllocCoTaskMem(buffer.Length);
                Marshal.Copy(buffer, 0, result, buffer.Length);
                return result;
            }
    
            public override string GetString() {
                int i = offset;
                while (i < buffer.Length && buffer[i] != 0)
                    i++;
                string result = Encoding.Default.GetString(buffer, offset, i - offset);
                if (i < buffer.Length)
                    i++;
                offset = i;
                return result;
            }
    
            public override void PutCoTaskMem(IntPtr ptr) {
                Marshal.Copy(ptr, buffer, 0, buffer.Length);
                offset = 0;
            }
    
            public override void PutString(string s) {
                byte[] bytes = Encoding.Default.GetBytes(s);
                int count = Math.Min(bytes.Length, buffer.Length - offset);
                Array.Copy(bytes, 0, buffer, offset, count);
                offset += count;
                if (offset < buffer.Length) buffer[offset++] = 0;
            }
        }
    
        public class UnicodeCharBuffer : CharBuffer {
    
            internal char[] buffer;
            internal int offset;
    
            public UnicodeCharBuffer(int size) {
                buffer = new char[size];
            }
    
            public override IntPtr AllocCoTaskMem() {
                IntPtr result = Marshal.AllocCoTaskMem(buffer.Length * 2);
                Marshal.Copy(buffer, 0, result, buffer.Length);
                return result;
            }
    
            public override String GetString() {
                int i = offset;
                while (i < buffer.Length && buffer[i] != 0) i++;
                string result = new string(buffer, offset, i - offset);
                if (i < buffer.Length) i++;
                offset = i;
                return result;
            }
    
            public override void PutCoTaskMem(IntPtr ptr) {
                Marshal.Copy(ptr, buffer, 0, buffer.Length);
                offset = 0;
            }
    
            public override void PutString(string s) {
                int count = Math.Min(s.Length, buffer.Length - offset);
                s.CopyTo(0, buffer, offset, count);
                offset += count;
                if (offset < buffer.Length) buffer[offset++] = (char)0;
            }
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class ENDROPFILES
        {
            public NMHDR    nmhdr;
            public IntPtr   hDrop;
            public int      cp;
            public bool     fProtected;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class REQRESIZE
        {
            public NMHDR    nmhdr;
            public RECT     rc;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class ENPROTECTED
        {
            public NMHDR    nmhdr;
            public int      msg;
            public IntPtr   wParam;
            public IntPtr   lParam;
            public CHARRANGE chrg;
        }
    
        public class ActiveX {
            public const   int OCM__BASE = 0x2000;
            public const   int DISPID_VALUE = unchecked((int)0x0);
            public const   int DISPID_UNKNOWN = unchecked((int)0xFFFFFFFF);
            public const   int DISPID_AUTOSIZE = unchecked((int)0xFFFFFE0C);
            public const   int DISPID_BACKCOLOR = unchecked((int)0xFFFFFE0B);
            public const   int DISPID_BACKSTYLE = unchecked((int)0xFFFFFE0A);
            public const   int DISPID_BORDERCOLOR = unchecked((int)0xFFFFFE09);
            public const   int DISPID_BORDERSTYLE = unchecked((int)0xFFFFFE08);
            public const   int DISPID_BORDERWIDTH = unchecked((int)0xFFFFFE07);
            public const   int DISPID_DRAWMODE = unchecked((int)0xFFFFFE05);
            public const   int DISPID_DRAWSTYLE = unchecked((int)0xFFFFFE04);
            public const   int DISPID_DRAWWIDTH = unchecked((int)0xFFFFFE03);
            public const   int DISPID_FILLCOLOR = unchecked((int)0xFFFFFE02);
            public const   int DISPID_FILLSTYLE = unchecked((int)0xFFFFFE01);
            public const   int DISPID_FONT = unchecked((int)0xFFFFFE00);
            public const   int DISPID_FORECOLOR = unchecked((int)0xFFFFFDFF);
            public const   int DISPID_ENABLED = unchecked((int)0xFFFFFDFE);
            public const   int DISPID_HWND = unchecked((int)0xFFFFFDFD);
            public const   int DISPID_TABSTOP = unchecked((int)0xFFFFFDFC);
            public const   int DISPID_TEXT = unchecked((int)0xFFFFFDFB);
            public const   int DISPID_CAPTION = unchecked((int)0xFFFFFDFA);
            public const   int DISPID_BORDERVISIBLE = unchecked((int)0xFFFFFDF9);
            public const   int DISPID_APPEARANCE = unchecked((int)0xFFFFFDF8);
            public const   int DISPID_MOUSEPOINTER = unchecked((int)0xFFFFFDF7);
            public const   int DISPID_MOUSEICON = unchecked((int)0xFFFFFDF6);
            public const   int DISPID_PICTURE = unchecked((int)0xFFFFFDF5);
            public const   int DISPID_VALID = unchecked((int)0xFFFFFDF4);
            public const   int DISPID_READYSTATE = unchecked((int)0xFFFFFDF3);
            public const   int DISPID_REFRESH = unchecked((int)0xFFFFFDDA);
            public const   int DISPID_DOCLICK = unchecked((int)0xFFFFFDD9);
            public const   int DISPID_ABOUTBOX = unchecked((int)0xFFFFFDD8);
            public const   int DISPID_CLICK = unchecked((int)0xFFFFFDA8);
            public const   int DISPID_DBLCLICK = unchecked((int)0xFFFFFDA7);
            public const   int DISPID_KEYDOWN = unchecked((int)0xFFFFFDA6);
            public const   int DISPID_KEYPRESS = unchecked((int)0xFFFFFDA5);
            public const   int DISPID_KEYUP = unchecked((int)0xFFFFFDA4);
            public const   int DISPID_MOUSEDOWN = unchecked((int)0xFFFFFDA3);
            public const   int DISPID_MOUSEMOVE = unchecked((int)0xFFFFFDA2);
            public const   int DISPID_MOUSEUP = unchecked((int)0xFFFFFDA1);
            public const   int DISPID_ERROREVENT = unchecked((int)0xFFFFFDA0);
            public const   int DISPID_RIGHTTOLEFT = unchecked((int)0xFFFFFD9D);
            public const   int DISPID_READYSTATECHANGE = unchecked((int)0xFFFFFD9F);
            public const   int DISPID_AMBIENT_BACKCOLOR = unchecked((int)0xFFFFFD43);
            public const   int DISPID_AMBIENT_DISPLAYNAME = unchecked((int)0xFFFFFD42);
            public const   int DISPID_AMBIENT_FONT = unchecked((int)0xFFFFFD41);
            public const   int DISPID_AMBIENT_FORECOLOR = unchecked((int)0xFFFFFD40);
            public const   int DISPID_AMBIENT_LOCALEID = unchecked((int)0xFFFFFD3F);
            public const   int DISPID_AMBIENT_MESSAGEREFLECT = unchecked((int)0xFFFFFD3E);
            public const   int DISPID_AMBIENT_SCALEUNITS = unchecked((int)0xFFFFFD3D);
            public const   int DISPID_AMBIENT_TEXTALIGN = unchecked((int)0xFFFFFD3C);
            public const   int DISPID_AMBIENT_USERMODE = unchecked((int)0xFFFFFD3B);
            public const   int DISPID_AMBIENT_UIDEAD = unchecked((int)0xFFFFFD3A);
            public const   int DISPID_AMBIENT_SHOWGRABHANDLES = unchecked((int)0xFFFFFD39);
            public const   int DISPID_AMBIENT_SHOWHATCHING = unchecked((int)0xFFFFFD38);
            public const   int DISPID_AMBIENT_DISPLAYASDEFAULT = unchecked((int)0xFFFFFD37);
            public const   int DISPID_AMBIENT_SUPPORTSMNEMONICS = unchecked((int)0xFFFFFD36);
            public const   int DISPID_AMBIENT_AUTOCLIP = unchecked((int)0xFFFFFD35);
            public const   int DISPID_AMBIENT_APPEARANCE = unchecked((int)0xFFFFFD34);
            public const   int DISPID_AMBIENT_PALETTE = unchecked((int)0xFFFFFD2A);
            public const   int DISPID_AMBIENT_TRANSFERPRIORITY = unchecked((int)0xFFFFFD28);
            public const   int DISPID_AMBIENT_RIGHTTOLEFT = unchecked((int)0xFFFFFD24);
            public const   int DISPID_Name = unchecked((int)0xFFFFFCE0);
            public const   int DISPID_Delete = unchecked((int)0xFFFFFCDF);
            public const   int DISPID_Object = unchecked((int)0xFFFFFCDE);
            public const   int DISPID_Parent = unchecked((int)0xFFFFFCDD);
            public const   int DVASPECT_CONTENT = 0x1;
            public const   int DVASPECT_THUMBNAIL = 0x2;
            public const   int DVASPECT_ICON = 0x4;
            public const   int DVASPECT_DOCPRINT = 0x8;
            public const   int OLEMISC_RECOMPOSEONRESIZE = 0x1;
            public const   int OLEMISC_ONLYICONIC = 0x2;
            public const   int OLEMISC_INSERTNOTREPLACE = 0x4;
            public const   int OLEMISC_STATIC = 0x8;
            public const   int OLEMISC_CANTLINKINSIDE = 0x10;
            public const   int OLEMISC_CANLINKBYOLE1 = 0x20;
            public const   int OLEMISC_ISLINKOBJECT = 0x40;
            public const   int OLEMISC_INSIDEOUT = 0x80;
            public const   int OLEMISC_ACTIVATEWHENVISIBLE = 0x100;
            public const   int OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x200;
            public const   int OLEMISC_INVISIBLEATRUNTIME = 0x400;
            public const   int OLEMISC_ALWAYSRUN = 0x800;
            public const   int OLEMISC_ACTSLIKEBUTTON = 0x1000;
            public const   int OLEMISC_ACTSLIKELABEL = 0x2000;
            public const   int OLEMISC_NOUIACTIVATE = 0x4000;
            public const   int OLEMISC_ALIGNABLE = 0x8000;
            public const   int OLEMISC_SIMPLEFRAME = 0x10000;
            public const   int OLEMISC_SETCLIENTSITEFIRST = 0x20000;
            public const   int OLEMISC_IMEMODE = 0x40000;
            public const   int OLEMISC_IGNOREACTIVATEWHENVISIBLE = 0x80000;
            public const   int OLEMISC_WANTSTOMENUMERGE = 0x100000;
            public const   int OLEMISC_SUPPORTSMULTILEVELUNDO = 0x200000;
            public const   int QACONTAINER_SHOWHATCHING = 0x1;
            public const   int QACONTAINER_SHOWGRABHANDLES = 0x2;
            public const   int QACONTAINER_USERMODE = 0x4;
            public const   int QACONTAINER_DISPLAYASDEFAULT = 0x8;
            public const   int QACONTAINER_UIDEAD = 0x10;
            public const   int QACONTAINER_AUTOCLIP = 0x20;
            public const   int QACONTAINER_MESSAGEREFLECT = 0x40;
            public const   int QACONTAINER_SUPPORTSMNEMONICS = 0x80;
            public const   int XFORMCOORDS_POSITION = 0x1;
            public const   int XFORMCOORDS_SIZE = 0x2;
            public const   int XFORMCOORDS_HIMETRICTOCONTAINER = 0x4;
            public const   int XFORMCOORDS_CONTAINERTOHIMETRIC = 0x8;
            public const   int PROPCAT_Nil = unchecked((int)0xFFFFFFFF);
            public const   int PROPCAT_Misc = unchecked((int)0xFFFFFFFE);
            public const   int PROPCAT_Font = unchecked((int)0xFFFFFFFD);
            public const   int PROPCAT_Position = unchecked((int)0xFFFFFFFC);
            public const   int PROPCAT_Appearance = unchecked((int)0xFFFFFFFB);
            public const   int PROPCAT_Behavior = unchecked((int)0xFFFFFFFA);
            public const   int PROPCAT_Data = unchecked((int)0xFFFFFFF9);
            public const   int PROPCAT_List = unchecked((int)0xFFFFFFF8);
            public const   int PROPCAT_Text = unchecked((int)0xFFFFFFF7);
            public const   int PROPCAT_Scale = unchecked((int)0xFFFFFFF6);
            public const   int PROPCAT_DDE = unchecked((int)0xFFFFFFF5);
            public const   int GC_WCH_SIBLING = 0x1;
            public const   int GC_WCH_CONTAINER = 0x2;
            public const   int GC_WCH_CONTAINED = 0x3;
            public const   int GC_WCH_ALL = 0x4;
            public const   int GC_WCH_FREVERSEDIR = 0x8000000;
            public const   int GC_WCH_FONLYNEXT = 0x10000000;
            public const   int GC_WCH_FONLYPREV = 0x20000000;
            public const   int GC_WCH_FSELECTED = 0x40000000;
            public const   int OLECONTF_EMBEDDINGS = 0x1;
            public const   int OLECONTF_LINKS = 0x2;
            public const   int OLECONTF_OTHERS = 0x4;
            public const   int OLECONTF_ONLYUSER = 0x8;
            public const   int OLECONTF_ONLYIFRUNNING = 0x10;
            public const   int ALIGN_MIN = 0x0;
            public const   int ALIGN_NO_CHANGE = 0x0;
            public const   int ALIGN_TOP = 0x1;
            public const   int ALIGN_BOTTOM = 0x2;
            public const   int ALIGN_LEFT = 0x3;
            public const   int ALIGN_RIGHT = 0x4;
            public const   int ALIGN_MAX = 0x4;
            public const   int OLEVERBATTRIB_NEVERDIRTIES = 0x1;
            public const   int OLEVERBATTRIB_ONCONTAINERMENU = 0x2;
    
            public static Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");
        }
    
        [
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        public class Util {
            public static int MAKELONG(int low, int high) {
                return (high << 16) | (low & 0xffff);
            }
    
            public static IntPtr MAKELPARAM(int low, int high) {
                return (IntPtr) ((high << 16) | (low & 0xffff));
            }
    
            public static int HIWORD(int n) {
                return (n >> 16) & 0xffff;
            }
    
            public static int HIWORD(IntPtr n) {
                return HIWORD( (int) n );
            }
    
            public static int LOWORD(int n) {
                return n & 0xffff;
            }
    
            public static int LOWORD(IntPtr n) {
                return LOWORD( (int) n );
            }
    
            public static int SignedHIWORD(IntPtr n) {
                return SignedHIWORD( (int) n );
            }
            public static int SignedLOWORD(IntPtr n) {
                return SignedLOWORD( (int) n );
            }
            
            public static int SignedHIWORD(int n) {
                int i = (int)(short)((n >> 16) & 0xffff);
    
                return i;
            }
    
            public static int SignedLOWORD(int n) {
                int i = (int)(short)(n & 0xFFFF);
                
                return i;
            }
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.Util.GetPInvokeStringLength"]/*' />
            /// <devdoc>
            ///     Computes the string size that should be passed to a typical Win32 call.
            ///     This will be the character count under NT, and the ubyte count for Windows 95.
            /// </devdoc>
            public static int GetPInvokeStringLength(String s) {
                if (s == null) {
                    return 0;
                }
    
                if (Marshal.SystemDefaultCharSize == 2) {
                    return s.Length;
                }
                else {
                    if (s.Length == 0) {
                        return 0;
                    }
                    if (s.IndexOf('\0') > -1) {
                        return GetEmbededNullStringLengthAnsi(s);
                    }
                    else {
                        return lstrlen(s);
                    }
                }
            }
    
            private static int GetEmbededNullStringLengthAnsi(String s) {
                int n = s.IndexOf('\0');
                if (n > -1) {
                    String left = s.Substring(0, n);
                    String right = s.Substring(n+1);
                    return GetPInvokeStringLength(left) + GetEmbededNullStringLengthAnsi(right) + 1;
                }
                else {
                    return GetPInvokeStringLength(s);
                }
            }
    
            [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
            private static extern int lstrlen(String s);
    
            [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
            internal static extern int RegisterWindowMessage(string msg);
        }
    
        public enum  tagTYPEKIND {
            TKIND_ENUM = 0,
            TKIND_RECORD = 1,
            TKIND_MODULE = 2,
            TKIND_INTERFACE = 3,
            TKIND_DISPATCH = 4,
            TKIND_COCLASS = 5,
            TKIND_ALIAS = 6,
            TKIND_UNION = 7,
            TKIND_MAX = 8
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public class  tagTLIBATTR {
            public   Guid guid;
            [MarshalAs(UnmanagedType.U4)]
            public   int lcid;
            public   NativeMethods.tagSYSKIND syskind;
            [MarshalAs(UnmanagedType.U2)]
            public   short wMajorVerNum;
            [MarshalAs(UnmanagedType.U2)]
            public   short wMinorVerNum;
            [MarshalAs(UnmanagedType.U2)]
            public   short wLibFlags;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public  class  tagTYPEDESC {
            public   IntPtr unionMember;
            public   short vt;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public struct  tagPARAMDESC {
            public   IntPtr pparamdescex;
            
            [MarshalAs(UnmanagedType.U2)]
            public   short wParamFlags;
        }
    
        public sealed class CommonHandles {
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Accelerator"]/*' />
            /// <devdoc>
            ///     Handle type for accelerator tables.
            /// </devdoc>
            public static readonly int Accelerator  = HandleCollector.RegisterType("Accelerator", 80, 50);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Cursor"]/*' />
            /// <devdoc>
            ///     handle type for cursors.
            /// </devdoc>
            public static readonly int Cursor       = HandleCollector.RegisterType("Cursor", 20, 500);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.EMF"]/*' />
            /// <devdoc>
            ///     Handle type for enhanced metafiles.
            /// </devdoc>
            public static readonly int EMF          = HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Find"]/*' />
            /// <devdoc>
            ///     Handle type for file find handles.
            /// </devdoc>
            public static readonly int Find         = HandleCollector.RegisterType("Find", 0, 1000);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.GDI"]/*' />
            /// <devdoc>
            ///     Handle type for GDI objects.
            /// </devdoc>
            public static readonly int GDI          = HandleCollector.RegisterType("GDI", 90, 50);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.HDC"]/*' />
            /// <devdoc>
            ///     Handle type for HDC's that count against the Win98 limit of five DC's.  HDC's
            ///     which are not scarce, such as HDC's for bitmaps, are counted as GDIHANDLE's.
            /// </devdoc>
            public static readonly int HDC          = HandleCollector.RegisterType("HDC", 100, 2); // wait for 2 dc's before collecting
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Icon"]/*' />
            /// <devdoc>
            ///     Handle type for icons.
            /// </devdoc>
            public static readonly int Icon         = HandleCollector.RegisterType("Icon", 20, 500);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Kernel"]/*' />
            /// <devdoc>
            ///     Handle type for kernel objects.
            /// </devdoc>
            public static readonly int Kernel       = HandleCollector.RegisterType("Kernel", 0, 1000);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Menu"]/*' />
            /// <devdoc>
            ///     Handle type for files.
            /// </devdoc>
            public static readonly int Menu         = HandleCollector.RegisterType("Menu", 30, 1000);
    
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Window"]/*' />
            /// <devdoc>
            ///     Handle type for windows.
            /// </devdoc>
            public static readonly int Window       = HandleCollector.RegisterType("Window", 5, 1000);
        }
    
        public enum  tagSYSKIND {
            SYS_WIN16 = 0,
            SYS_MAC = 2
        }
    
        public delegate bool MonitorEnumProc(IntPtr monitor, IntPtr hdc, IntPtr lprcMonitor, IntPtr lParam);
    
        [ComImport(), Guid("A7ABA9C1-8983-11cf-8F20-00805F2CD064"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IProvideMultipleClassInfo {
             // since the inheritance doesn't seem to work...
             // these are from IProvideClassInfo & IProvideClassInfo2
             [PreserveSig]
             UnsafeNativeMethods.ITypeInfo GetClassInfo();
             
             [PreserveSig]
             int GetGUID(int dwGuidKind, [In, Out] ref Guid pGuid);
         
             [PreserveSig]
             int GetMultiTypeInfoCount([In, Out] ref int pcti);
         
             // we use arrays for most of these since we never use them anyway.
             [PreserveSig]
             int GetInfoOfIndex(int iti, int dwFlags, 
                                [In, Out]
                                ref UnsafeNativeMethods.ITypeInfo pTypeInfo, 
                                int       pTIFlags,
                                int       pcdispidReserved,
                                IntPtr piidPrimary,
                                IntPtr piidSource);
       }
   
        [StructLayout(LayoutKind.Sequential)]
            public class EVENTMSG {
            public int message;
            public IntPtr paramL;
            public IntPtr paramH;
            public int time;
            public IntPtr hwnd;
        }
    
        [ComImport(), Guid("B196B283-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IProvideClassInfo {
            [return: MarshalAs(UnmanagedType.Interface)]
            UnsafeNativeMethods.ITypeInfo GetClassInfo();
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public  sealed class  tagTYPEATTR {
            public Guid guid;
            [MarshalAs(UnmanagedType.U4)]
            public   int lcid;
            [MarshalAs(UnmanagedType.U4)]
            public   int dwReserved;
            public   int memidConstructor;
            public   int memidDestructor;
            public   IntPtr lpstrSchema;
            [MarshalAs(UnmanagedType.U4)]
            public   int cbSizeInstance;
            public    /*NativeMethods.tagTYPEKIND*/ int typekind;
            [MarshalAs(UnmanagedType.U2)]
            public   short cFuncs;
            [MarshalAs(UnmanagedType.U2)]
            public   short cVars;
            [MarshalAs(UnmanagedType.U2)]
            public   short cImplTypes;
            [MarshalAs(UnmanagedType.U2)]
            public   short cbSizeVft;
            [MarshalAs(UnmanagedType.U2)]
            public   short cbAlignment;
            [MarshalAs(UnmanagedType.U2)]
            public   short wTypeFlags;
            [MarshalAs(UnmanagedType.U2)]
            public   short wMajorVerNum;
            [MarshalAs(UnmanagedType.U2)]
            public   short wMinorVerNum;
            
            // SBurke these are inline too
            //public    NativeMethods.tagTYPEDESC tdescAlias;
            [MarshalAs(UnmanagedType.U4)]
            public   int tdescAlias_unionMember;
            
            [MarshalAs(UnmanagedType.U2)]
            public   short tdescAlias_vt;
            
            //public    NativeMethods.tagIDLDESC idldescType;
            [MarshalAs(UnmanagedType.U4)]
            public   int idldescType_dwReserved;
            
            [MarshalAs(UnmanagedType.U2)]
            public   short idldescType_wIDLFlags;
            
            
            public tagTYPEDESC Get_tdescAlias(){
                tagTYPEDESC td = new tagTYPEDESC();
                td.unionMember = (IntPtr)this.tdescAlias_unionMember;
                td.vt = this.tdescAlias_vt;
                return td;
            }
            
            public tagIDLDESC Get_idldescType(){
                tagIDLDESC id = new tagIDLDESC();
                id.dwReserved = this.idldescType_dwReserved;
                id.wIDLFlags = this.idldescType_wIDLFlags;
                return id;
            } 
        }
            
        public enum tagVARFLAGS {
             VARFLAG_FREADONLY         =    1,
             VARFLAG_FSOURCE           =    0x2,
             VARFLAG_FBINDABLE         =    0x4,
             VARFLAG_FREQUESTEDIT      =    0x8,
             VARFLAG_FDISPLAYBIND      =    0x10,
             VARFLAG_FDEFAULTBIND      =    0x20,
             VARFLAG_FHIDDEN           =    0x40,
             VARFLAG_FDEFAULTCOLLELEM  =    0x100,
             VARFLAG_FUIDEFAULT        =    0x200,
             VARFLAG_FNONBROWSABLE     =    0x400,
             VARFLAG_FREPLACEABLE      =    0x800,
             VARFLAG_FIMMEDIATEBIND    =    0x1000
       }
   
        [StructLayout(LayoutKind.Sequential)]
        public sealed class tagELEMDESC {
            public    NativeMethods.tagTYPEDESC tdesc;
            public    NativeMethods.tagPARAMDESC paramdesc;
        }
        
        public enum  tagVARKIND {
            VAR_PERINSTANCE = 0,
            VAR_STATIC = 1,
            VAR_CONST = 2,
            VAR_DISPATCH = 3
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct  tagIDLDESC {
            [MarshalAs(UnmanagedType.U4)]
            public   int dwReserved;
            [MarshalAs(UnmanagedType.U2)]
            public   short wIDLFlags;
        }

        public struct RGBQUAD {
            public byte rgbBlue;
            public byte rgbGreen;
            public byte rgbRed;
            public byte rgbReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class BITMAPINFO_ARRAY {
            public BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst=BITMAPINFO_MAX_COLORSIZE*4)]
            public byte[] bmiColors; // RGBQUAD structs... Blue-Green-Red-Reserved, repeat...
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PALETTEENTRY {
            public byte peRed;
            public byte peGreen;
            public byte peBlue;
            public byte peFlags;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BITMAPINFO_FLAT {
            public int      bmiHeader_biSize;// = Marshal.SizeOf(typeof(BITMAPINFOHEADER));
            public int      bmiHeader_biWidth;
            public int      bmiHeader_biHeight;
            public short    bmiHeader_biPlanes;
            public short    bmiHeader_biBitCount;
            public int      bmiHeader_biCompression;
            public int      bmiHeader_biSizeImage;
            public int      bmiHeader_biXPelsPerMeter;
            public int      bmiHeader_biYPelsPerMeter;
            public int      bmiHeader_biClrUsed;
            public int      bmiHeader_biClrImportant;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst=BITMAPINFO_MAX_COLORSIZE*4)]
            public byte[] bmiColors; // RGBQUAD structs... Blue-Green-Red-Reserved, repeat...
        }

        /// <devdoc>
        ///     This method takes a file URL and converts it to a local path.  The trick here is that
        ///     if there is a '#' in the path, everything after this is treated as a fragment.  So
        ///     we need to append the fragment to the end of the path.
        /// </devdoc>
        internal static string GetLocalPath(string fileName) {
            System.Diagnostics.Debug.Assert(fileName != null && fileName.Length > 0, "Cannot get local path, fileName is not valid");

            Uri uri = new Uri(fileName, true);
            return uri.LocalPath + uri.Fragment;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertytabchangedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyTabChangedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;

    /// <include file='doc\PropertyTabChangedEvent.uex' path='docs/doc[@for="PropertyTabChangedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class PropertyTabChangedEventArgs : EventArgs{
        
        private PropertyTab oldTab;
        private PropertyTab newTab;

        /// <include file='doc\PropertyTabChangedEvent.uex' path='docs/doc[@for="PropertyTabChangedEventArgs.PropertyTabChangedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyTabChangedEventArgs(PropertyTab oldTab, PropertyTab newTab) {
            this.oldTab = oldTab;
            this.newTab = newTab;
        }
        
        /// <include file='doc\PropertyTabChangedEvent.uex' path='docs/doc[@for="PropertyTabChangedEventArgs.OldTab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyTab OldTab {
            get {
                return oldTab;
            }
        }
        
        /// <include file='doc\PropertyTabChangedEvent.uex' path='docs/doc[@for="PropertyTabChangedEventArgs.NewTab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyTab NewTab {
            get {
                return newTab;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertysort.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertySort.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    
    /// <include file='doc\PropertySort.uex' path='docs/doc[@for="PropertySort"]/*' />
    /// <devdoc>
    /// Possible values for property grid sorting mode 
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum PropertySort{
            
            /// <include file='doc\PropertySort.uex' path='docs/doc[@for="PropertySort.NoSort"]/*' />
            /// <devdoc>
            /// Properties will not be sorted, rather they
            /// will be displayed in the order that they are retrieved
            /// from the TypeDescriptor.
            /// </devdoc>
            NoSort = 0,
            
            /// <include file='doc\PropertySort.uex' path='docs/doc[@for="PropertySort.Alphabetical"]/*' />
            /// <devdoc>
            /// Properties are sorted as a flat, alphabetical list.
            /// </devdoc>
            Alphabetical = 1,
            
            /// <include file='doc\PropertySort.uex' path='docs/doc[@for="PropertySort.Categorized"]/*' />
            /// <devdoc>
            /// Properties are under category groups, which are defined 
            /// by the properties themselves.
            /// </devdoc>
            Categorized = 2, 
            
            /// <include file='doc\PropertySort.uex' path='docs/doc[@for="PropertySort.CategorizedAlphabetical"]/*' />
            /// <devdoc>
            /// Properties are under category groups, which are defined 
            /// by the properties themselves, and are alphabetical
            /// within those groups.
            /// </devdoc>
            
            CategorizedAlphabetical = Alphabetical | Categorized,
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertystore.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyStore.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using System.Diagnostics;
    
    /// <devdoc>
    ///     This is a small class that can efficiently store property values.
    ///     It tries to optimize for size first, "get" access second, and
    ///     "set" access third.  
    /// </devdoc>
    internal class PropertyStore {
    
        private static int currentKey;
    
        private IntegerEntry[] intEntries;
        private ObjectEntry[]  objEntries;
    
        /// <devdoc>
        ///     Retrieves an integer value from our property list.
        ///     This will set value to zero and return false if the 
        ///     list does not contain the given key.
        /// </devdoc>
        public bool ContainsInteger(int key) {
            bool found;
            GetInteger(key, out found);
            return found;
        }
        
        /// <devdoc>
        ///     Retrieves an integer value from our property list.
        ///     This will set value to zero and return false if the 
        ///     list does not contain the given key.
        /// </devdoc>
        public bool ContainsObject(int key) {
            bool found;
            GetObject(key, out found);
            return found;
        }
        
        /// <devdoc>
        ///     Creates a new key for this property store.  This is NOT
        ///     guarded by any thread safety so if you are calling it on
        ///     multiple threads you should guard.  For our purposes,
        ///     we're fine because this is designed to be called in a class
        ///     initializer, and we never have the same class hierarchy
        ///     initializing on multiple threads at once.
        /// </devdoc>
        public static int CreateKey() {
            return currentKey++;
        }
    
        /// <devdoc>
        ///     Retrieves an integer value from our property list.
        ///     This will set value to zero and return false if the 
        ///     list does not contain the given key.
        /// </devdoc>
        public int GetInteger(int key) {
            bool found;
            return GetInteger(key, out found);
        }
        
        /// <devdoc>
        ///     Retrieves an integer value from our property list.
        ///     This will set value to zero and return false if the 
        ///     list does not contain the given key.
        /// </devdoc>
        public int GetInteger(int key, out bool found) {
        
            int   value = 0;
            int   index;
            short element;
            short keyIndex = SplitKey(key, out element);
            
            found = false;
            
            if (LocateIntegerEntry(keyIndex, element, out index)) {
                // We have found the relevant entry.  See if
                // the bitmask indicates the value is used.
                //
                if (((1 << element) & intEntries[index].Mask) != 0) {
                
                    found = true;
                    
                    switch(element) {
                        case 0:
                            value = intEntries[index].Value1;
                            break;
                            
                        case 1:
                            value = intEntries[index].Value2;
                            break;
                            
                        case 2:
                            value = intEntries[index].Value3;
                            break;
                            
                        case 3:
                            value = intEntries[index].Value4;
                            break;
                            
                        default:
                            Debug.Fail("Invalid element obtained from LocateEntry");
                            break;
                    }
                }
            }
        
            return value;
        }
    
        /// <devdoc>
        ///     Retrieves an object value from our property list.
        ///     This will set value to null and return false if the 
        ///     list does not contain the given key.
        /// </devdoc>
        public object GetObject(int key) {
            bool found;
            return GetObject(key, out found);
        }
        
        /// <devdoc>
        ///     Retrieves an object value from our property list.
        ///     This will set value to null and return false if the 
        ///     list does not contain the given key.
        /// </devdoc>
        public object GetObject(int key, out bool found) {
        
            object value = null;
            int   index;
            short element;
            short keyIndex = SplitKey(key, out element);
            
            found = false;
            
            if (LocateObjectEntry(keyIndex, element, out index)) {
                // We have found the relevant entry.  See if
                // the bitmask indicates the value is used.
                //
                if (((1 << element) & objEntries[index].Mask) != 0) {
                    
                    found = true;
                    
                    switch(element) {
                        case 0:
                            value = objEntries[index].Value1;
                            break;
                            
                        case 1:
                            value = objEntries[index].Value2;
                            break;
                            
                        case 2:
                            value = objEntries[index].Value3;
                            break;
                            
                        case 3:
                            value = objEntries[index].Value4;
                            break;
                            
                        default:
                            Debug.Fail("Invalid element obtained from LocateEntry");
                            break;
                    }
                }
            }
        
            return value;
        }
        
        /// <devdoc>
        ///     Locates the requested entry in our array if entries.  This does
        ///     not do the mask check to see if the entry is currently being used,
        ///     but it does locate the entry.  If the entry is found, this returns
        ///     true and fills in index and element.  If the entry is not found,
        ///     this returns false.  If the entry is not found, index will contain
        ///     the insert point at which one would add a new element.
        /// </devdoc>
        private bool LocateIntegerEntry(short entryKey, short element, out int index) {
            if (intEntries != null) {
                
                // Entries are stored in numerical order by key index so we can
                // do a binary search on them.
                //
                int max = intEntries.Length - 1;
                int min = 0;
                int idx = 0;
                
                do {
                    idx = (max + min) / 2;
                    short currentKeyIndex = intEntries[idx].Key;
                    
                    if (currentKeyIndex == entryKey) {
                        index = idx;
                        return true;
                    }
                    else if (entryKey < currentKeyIndex) {
                        max = idx - 1;
                    }
                    else {
                        min = idx + 1;
                    }
                }
                while (max >= min);
                
                // Didn't find the index.  Setup our output
                // appropriately
                //
                index = idx;
                if (entryKey > intEntries[idx].Key) {
                    index++;
                }
                return false;
            }
            else {
                index = 0;
                return false;
            }
        }
    
        /// <devdoc>
        ///     Locates the requested entry in our array if entries.  This does
        ///     not do the mask check to see if the entry is currently being used,
        ///     but it does locate the entry.  If the entry is found, this returns
        ///     true and fills in index and element.  If the entry is not found,
        ///     this returns false.  If the entry is not found, index will contain
        ///     the insert point at which one would add a new element.
        /// </devdoc>
        private bool LocateObjectEntry(short entryKey, short element, out int index) {
            if (objEntries != null) {
                
                // Entries are stored in numerical order by key index so we can
                // do a binary search on them.
                //
                int max = objEntries.Length - 1;
                int min = 0;
                int idx = 0;
                
                do {
                    idx = (max + min) / 2;
                    short currentKeyIndex = objEntries[idx].Key;
                    
                    if (currentKeyIndex == entryKey) {
                        index = idx;
                        return true;
                    }
                    else if (entryKey < currentKeyIndex) {
                        max = idx - 1;
                    }
                    else {
                        min = idx + 1;
                    }
                }
                while (max >= min);
                
                // Didn't find the index.  Setup our output
                // appropriately
                //
                index = idx;
                if (entryKey > objEntries[idx].Key) {
                    index++;
                }
                return false;
            }
            else {
                index = 0;
                return false;
            }
        }
    
        /// <devdoc>
        ///     Stores the given value in the key.
        /// </devdoc>
        public void SetInteger(int key, int value) {
            int   index;
            short element;
            short entryKey = SplitKey(key, out element);
            
            if (!LocateIntegerEntry(entryKey, element, out index)) {
                
                // We must allocate a new entry.
                //
                if (intEntries != null) {
                    IntegerEntry[] newEntries = new IntegerEntry[intEntries.Length + 1];
                    
                    if (index > 0) {
                        Array.Copy(intEntries, 0, newEntries, 0, index);
                    }
                    
                    if (intEntries.Length - index > 0) {
                        Array.Copy(intEntries, index, newEntries, index + 1, intEntries.Length - index);
                    }
                    
                    intEntries = newEntries;
                }
                else {
                    intEntries = new IntegerEntry[1];
                    Debug.Assert(index == 0, "LocateIntegerEntry should have given us a zero index.");
                }
            
                intEntries[index].Key = entryKey;
            }
        
            // Now determine which value to set.
            //
            switch(element) {
                case 0:
                    intEntries[index].Value1 = value;
                    break;
                    
                case 1:
                    intEntries[index].Value2 = value;
                    break;
                    
                case 2:
                    intEntries[index].Value3 = value;
                    break;
                    
                case 3:
                    intEntries[index].Value4 = value;
                    break;
                    
                default:
                    Debug.Fail("Invalid element obtained from LocateEntry");
                    break;
            }
            
            intEntries[index].Mask |= (short)(1 << element);
        }
    
        /// <devdoc>
        ///     Stores the given value in the key.
        /// </devdoc>
        public void SetObject(int key, object value) {
            int   index;
            short element;
            short entryKey = SplitKey(key, out element);
            
            if (!LocateObjectEntry(entryKey, element, out index)) {
                
                // We must allocate a new entry.
                //
                if (objEntries != null) {
                    ObjectEntry[] newEntries = new ObjectEntry[objEntries.Length + 1];
                    
                    if (index > 0) {
                        Array.Copy(objEntries, 0, newEntries, 0, index);
                    }
                    
                    if (objEntries.Length - index > 0) {
                        Array.Copy(objEntries, index, newEntries, index + 1, objEntries.Length - index);
                    }
                    
                    objEntries = newEntries;
                }
                else {
                    objEntries = new ObjectEntry[1];
                    Debug.Assert(index == 0, "LocateObjectEntry should have given us a zero index.");
                }
            
                objEntries[index].Key = entryKey;
            }
        
            // Now determine which value to set.
            //
            switch(element) {
                case 0:
                    objEntries[index].Value1 = value;
                    break;
                    
                case 1:
                    objEntries[index].Value2 = value;
                    break;
                    
                case 2:
                    objEntries[index].Value3 = value;
                    break;
                    
                case 3:
                    objEntries[index].Value4 = value;
                    break;
                    
                default:
                    Debug.Fail("Invalid element obtained from LocateEntry");
                    break;
            }
            
            objEntries[index].Mask |= (short)(1 << element);
        }
        
        /// <devdoc>
        ///     Takes the given key and splits it into an index
        ///     and an element.
        /// </devdoc>
        private short SplitKey(int key, out short element) {
            element = (short)(key & 0x00000003);
            return (short)(key & 0xFFFFFFFC);
        }
        
        /// <devdoc>
        ///     Stores the relationship between a key and a value.
        ///     We do not want to be so inefficient that we require
        ///     four bytes for each four byte property, so use an algorithm
        ///     that uses the bottom two bits of the key to identify
        ///     one of four elements in an entry.
        /// </devdoc>
        private struct IntegerEntry {
            public short Key;
            public short Mask;  // only lower four bits are used; mask of used values.
            public int Value1;
            public int Value2;
            public int Value3;
            public int Value4;
        }
        
        /// <devdoc>
        ///     Stores the relationship between a key and a value.
        ///     We do not want to be so inefficient that we require
        ///     four bytes for each four byte property, so use an algorithm
        ///     that uses the bottom two bits of the key to identify
        ///     one of four elements in an entry.
        /// </devdoc>
        private struct ObjectEntry {
            public short Key;
            public short Mask;  // only lower four bits are used; mask of used values.
            public object Value1;
            public object Value2;
            public object Value3;
            public object Value4;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertytabchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyTabChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;

    /// <include file='doc\PropertyTabChangedEventHandler.uex' path='docs/doc[@for="PropertyTabChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void PropertyTabChangedEventHandler(object s, PropertyTabChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertymanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PropertyManager.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms {

    using System;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Collections;

    /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PropertyManager : BindingManagerBase {

        // PropertyManager class
        //

        private object dataSource;
        private PropertyDescriptor propInfo;
        private bool bound;


        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.Current"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Object Current {
            get {
                return this.dataSource;
            }
        }

        private void PropertyChanged(object sender, EventArgs ea) {
            EndCurrentEdit();
            OnCurrentChanged(EventArgs.Empty);
        }

        internal override void SetDataSource(Object dataSource) {
            this.dataSource = dataSource;
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.PropertyManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyManager() {}

        internal PropertyManager(Object dataSource) : base(dataSource){}

        internal PropertyManager(Object dataSource, string propName) : this(dataSource) {
            propInfo = TypeDescriptor.GetProperties(dataSource).Find(propName, true);
            if (propInfo == null)
                throw new ArgumentException(SR.GetString(SR.PropertyManagerPropDoesNotExist, propName, dataSource.ToString()));
            propInfo.AddValueChanged(dataSource, new EventHandler(PropertyChanged));
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.GetItemProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetItemProperties() {
            PropertyDescriptorCollection res  = TypeDescriptor.GetProperties(dataSource);
            return res;
        }

        internal override Type BindType {
            get {
                return dataSource.GetType();
            }
        }

        internal override String GetListName() {
            return TypeDescriptor.GetClassName(dataSource) + "." + propInfo.Name;
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.SuspendBinding"]/*' />
        public override void SuspendBinding() {
            EndCurrentEdit();
            if (bound) {
                try {
                    bound = false;
                    UpdateIsBinding();
                } catch (Exception e) {
                    bound = true;
                    UpdateIsBinding();
                    throw e;
                }
            }
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.ResumeBinding"]/*' />
        public override void ResumeBinding() {
            OnCurrentChanged(new EventArgs());
            if (!bound) {
                try {
                    bound = true;
                    UpdateIsBinding();
                } catch (Exception e) {
                    bound = false;
                    UpdateIsBinding();
                    throw e;
                }
            }
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.GetListName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal override String GetListName(ArrayList listAccessors) {
            return "";
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.CancelCurrentEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void CancelCurrentEdit() {
            IEditableObject obj = this.Current as IEditableObject;
            if (obj != null)
                obj.CancelEdit();
            PushData();
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.EndCurrentEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void EndCurrentEdit() {
            PullData();
            IEditableObject obj = this.Current as IEditableObject;
            if (obj != null)
                obj.EndEdit();
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.UpdateIsBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void UpdateIsBinding() {
            for (int i = 0; i < this.Bindings.Count; i++)
                this.Bindings[i].UpdateIsBinding();
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.OnCurrentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal protected override void OnCurrentChanged(EventArgs ea) {
            PushData();
            if (this.onCurrentChangedHandler != null)
                this.onCurrentChangedHandler(this, ea);
        }

        internal override object DataSource {
            get {
                return this.dataSource;
            }
        }

        internal override bool IsBinding {
            get {
                return true;
            }
        }

        // no op on the propertyManager
        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.Position"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int Position {
            get {
                return 0;
            }
            set {
            }
        }

        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.Count"]/*' />
        public override int Count {
            get {
                return 1;
            }
        }

        // no-op on the propertyManager
        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.AddNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void AddNew() {
            throw new NotSupportedException(SR.GetString(SR.DataBindingAddNewNotSupportedOnPropertyManager));
        }

        // no-op on the propertyManager
        /// <include file='doc\PropertyManager.uex' path='docs/doc[@for="PropertyManager.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void RemoveAt(int index) {
            throw new NotSupportedException(SR.GetString(SR.DataBindingRemoveAtNotSupportedOnPropertyManager));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertyvaluechangedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueChangedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;

    /// <include file='doc\PropertyValueChangedEvent.uex' path='docs/doc[@for="PropertyValueChangedEventArgs"]/*' />
    /// <devdoc>
    /// The event class that is created when a property
    /// in the grid is modified by the user.
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class PropertyValueChangedEventArgs : EventArgs {
        private readonly GridItem changedItem;
        private object oldValue;
                /// <include file='doc\PropertyValueChangedEvent.uex' path='docs/doc[@for="PropertyValueChangedEventArgs.PropertyValueChangedEventArgs"]/*' />
                /// <devdoc>
        /// Constructor
        /// </devdoc>
        public PropertyValueChangedEventArgs(GridItem changedItem, object oldValue) {
            this.changedItem = changedItem;
            this.oldValue = oldValue;
        }

        /// <include file='doc\PropertyValueChangedEvent.uex' path='docs/doc[@for="PropertyValueChangedEventArgs.ChangedItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public GridItem ChangedItem {
            get {
                return changedItem;
            }
        }
        
        /// <include file='doc\PropertyValueChangedEvent.uex' path='docs/doc[@for="PropertyValueChangedEventArgs.OldValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object OldValue {
            get {
                return oldValue;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertyvaluechangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    
    

    /// <include file='doc\PropertyValueChangedEventHandler.uex' path='docs/doc[@for="PropertyValueChangedEventHandler"]/*' />
    /// <devdoc>
    /// The event handler class that is invoked when a property
    /// in the grid is modified by the user.
    /// </devdoc>
    public delegate void PropertyValueChangedEventHandler(object s, PropertyValueChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\queryaccessibilityhelpeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryAccessibilityHelpEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\QueryAccessibilityHelpEventHandler.uex' path='docs/doc[@for="QueryAccessibilityHelpEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void QueryAccessibilityHelpEventHandler(object sender, QueryAccessibilityHelpEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\queryaccessibilityhelpevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryAccessibilityHelpEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\QueryAccessibilityHelpEvent.uex' path='docs/doc[@for="QueryAccessibilityHelpEventArgs"]/*' />
    /// <devdoc>
    ///     The QueryAccessibilityHelpEventArgs is fired when AccessibleObject
    ///     is providing help to accessibility applications.    
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class QueryAccessibilityHelpEventArgs  : EventArgs {
        
        private string helpNamespace;
        private string helpString;
        private string helpKeyword;
        
        /// <include file='doc\QueryAccessibilityHelpEvent.uex' path='docs/doc[@for="QueryAccessibilityHelpEventArgs.QueryAccessibilityHelpEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public QueryAccessibilityHelpEventArgs() {
        }
        
        /// <include file='doc\QueryAccessibilityHelpEvent.uex' path='docs/doc[@for="QueryAccessibilityHelpEventArgs.QueryAccessibilityHelpEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public QueryAccessibilityHelpEventArgs(string helpNamespace, string helpString, string helpKeyword) {
            this.helpNamespace = helpNamespace;
            this.helpString = helpString;
            this.helpKeyword = helpKeyword;
        }

        /// <include file='doc\QueryAccessibilityHelpEvent.uex' path='docs/doc[@for="QueryAccessibilityHelpEventArgs.HelpNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string HelpNamespace { 
            get {
                return helpNamespace;
            }
            set {
                helpNamespace = value;
            }
        }
        
        /// <include file='doc\QueryAccessibilityHelpEvent.uex' path='docs/doc[@for="QueryAccessibilityHelpEventArgs.HelpString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string HelpString { 
            get {
                return helpString;
            }
            set {
                helpString = value;
            }
        }
        
        /// <include file='doc\QueryAccessibilityHelpEvent.uex' path='docs/doc[@for="QueryAccessibilityHelpEventArgs.HelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string HelpKeyword { 
            get {
                return helpKeyword;
            }
            set {
                helpKeyword = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\querycontinuedrageventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryContinueDragEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\QueryContinueDragEventHandler.uex' path='docs/doc[@for="QueryContinueDragEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.Control.QueryContinueDrag'/>
    ///       event of a
    ///    <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void QueryContinueDragEventHandler(object sender, QueryContinueDragEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\querycontinuedragevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryContinueDragEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\QueryContinueDragEvent.uex' path='docs/doc[@for="QueryContinueDragEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.QueryContinueDrag'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class QueryContinueDragEventArgs : EventArgs {

        private readonly int keyState;
        private readonly bool escapePressed;
        private DragAction action;

        /// <include file='doc\QueryContinueDragEvent.uex' path='docs/doc[@for="QueryContinueDragEventArgs.QueryContinueDragEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.QueryContinueDragEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public QueryContinueDragEventArgs(int keyState, bool escapePressed, DragAction action) {
            this.keyState = keyState;
            this.escapePressed = escapePressed;
            this.action = action;
        }

        /// <include file='doc\QueryContinueDragEvent.uex' path='docs/doc[@for="QueryContinueDragEventArgs.KeyState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating
        ///       the current state of the SHIFT, CTRL, and ALT keys.
        ///  </para>
        /// </devdoc>
        public int KeyState {
            get {
                return keyState;
            }
        }

        /// <include file='doc\QueryContinueDragEvent.uex' path='docs/doc[@for="QueryContinueDragEventArgs.EscapePressed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the user pressed the ESC key.
        ///    </para>
        /// </devdoc>
        public bool EscapePressed {
            get {
                return escapePressed;
            }
        }

        /// <include file='doc\QueryContinueDragEvent.uex' path='docs/doc[@for="QueryContinueDragEventArgs.Action"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the status of a drag-and-drop operation.
        ///    </para>
        /// </devdoc>
        public DragAction Action {
            get {
                return action;
            }
            set {
                action = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\relatedcurrencymanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="RelatedCurrencyManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Collections;

    /// <include file='doc\RelatedListManager.uex' path='docs/doc[@for="RelatedCurrencyManager"]/*' />
    /// <devdoc>
    /// <para>Represents the child version of the System.Windows.Forms.ListManager
    /// that is used when a parent/child relationship exists in a System.Windows.Forms.DataSet.</para>
    /// </devdoc>
    internal class RelatedCurrencyManager : CurrencyManager {

        BindingManagerBase parentManager;
        string dataField;
        PropertyDescriptor fieldInfo;
        
        internal RelatedCurrencyManager(BindingManagerBase parentManager, string dataField) : base(null) {
            Debug.Assert(parentManager != null, "How could this be a null parentManager.");
            this.parentManager = parentManager;
            this.dataField = dataField;
            this.fieldInfo = parentManager.GetItemProperties().Find(dataField, true);
            if (fieldInfo == null || !typeof(IList).IsAssignableFrom(fieldInfo.PropertyType)) {
                throw new ArgumentException(SR.GetString(SR.RelatedListManagerChild, dataField));
            }
            this.finalType = fieldInfo.PropertyType;
            parentManager.CurrentChanged += new EventHandler(ParentManager_CurrentChanged);
            ParentManager_CurrentChanged(parentManager, EventArgs.Empty);
        }

        /// <include file='doc\RelatedListManager.uex' path='docs/doc[@for="RelatedCurrencyManager.GetItemProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties of the item.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetItemProperties() {
            PropertyDescriptorCollection sublistProperties = GetItemProperties(new ArrayList(), new ArrayList());
            if (sublistProperties != null) {
                return sublistProperties;
            }
            // If the dataSource is an IList (L1), that indexes a type (T1) which has a property (P1) that
            // returns an IList, then the following combination was possible:
            // L1.P1.P1.P1....
            return new PropertyDescriptorCollection(null);
            // return base.GetItemProperties();
        }
        
        /// <include file='doc\RelatedListManager.uex' path='docs/doc[@for="RelatedCurrencyManager.GetItemProperties1"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties of the item using the specified list.</para>
        /// </devdoc>
        protected internal override PropertyDescriptorCollection GetItemProperties(ArrayList dataSources, ArrayList listAccessors) {
            listAccessors.Insert(0, fieldInfo);
            dataSources.Insert(0, this.DataSource);
            return parentManager.GetItemProperties(dataSources, listAccessors);
        }

        // <devdoc>
        //    <para>Gets the name of the list.</para>
        // </devdoc>
        internal override string GetListName() {
            string name = GetListName(new ArrayList());
            if (name.Length > 0) {
                return name;
            }
            return base.GetListName();
        }
        
        /// <include file='doc\RelatedListManager.uex' path='docs/doc[@for="RelatedCurrencyManager.GetListName1"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the specified list.</para>
        /// </devdoc>
        protected internal override string GetListName(ArrayList listAccessors) {
            listAccessors.Insert(0, fieldInfo);
            return parentManager.GetListName(listAccessors);
        }
        
        private void ParentManager_CurrentChanged(object sender, EventArgs e) {
            int oldlistposition = this.listposition;

            // we only pull the data from the controls into the backEnd. we do not care about keeping the lastGoodKnownRow
            // when we are about to change the entire list in this currencymanager.
            try {
                PullData();
            } catch {}

            if (parentManager is CurrencyManager) {
                CurrencyManager curManager = (CurrencyManager) parentManager;
                if (curManager.Count > 0) {
                    SetDataSource(fieldInfo.GetValue(curManager.Current));
                    listposition = (Count > 0 ? 0 : -1);
                } else {
                    // really, really hocky.
                    // will throw if the list in the curManager is not IBindingList
                    // and this will fail if the IBindingList does not have list change notification. read on....
                    // when a new item will get added to an empty parent table, 
                    // the table will fire OnCurrentChanged and this method will get executed again
                    curManager.AddNew();
                    curManager.CancelCurrentEdit();
                }
            } else {
                SetDataSource(fieldInfo.GetValue(parentManager.Current));
                listposition = (Count > 0 ? 0 : -1);
            }
            if (oldlistposition != listposition)
                OnPositionChanged(EventArgs.Empty);
            OnCurrentChanged(EventArgs.Empty);
        }

        internal CurrencyManager ParentManager {
            get {
                return this.parentManager as CurrencyManager;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\requestresizeevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequestResizeEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\RequestResizeEvent.uex' path='docs/doc[@for="ContentsResizedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.RichTextBox.ContentsResized'/> event.
    ///    </para>
    /// </devdoc>
    public class ContentsResizedEventArgs : EventArgs {
        readonly Rectangle newRectangle;

        /// <include file='doc\RequestResizeEvent.uex' path='docs/doc[@for="ContentsResizedEventArgs.ContentsResizedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ContentsResizedEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>

        public ContentsResizedEventArgs(Rectangle newRectangle) {
            this.newRectangle = newRectangle;
        }
        
        /// <include file='doc\RequestResizeEvent.uex' path='docs/doc[@for="ContentsResizedEventArgs.NewRectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the requested size of the <see cref='System.Windows.Forms.RichTextBox'/> control.
        ///    </para>
        /// </devdoc>
        public Rectangle NewRectangle {
            get {
                return newRectangle;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\radiobutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="RadioButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;

    using System.ComponentModel;
    using System.ComponentModel.Design;

    using System.Drawing;
    using System.Drawing.Drawing2D;
    using Microsoft.Win32;

    /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Encapsulates a
    ///       standard
    ///       Windows radio button (option button).
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("Checked"),
    DefaultEvent("CheckedChanged")
    ]
    public class RadioButton : ButtonBase {

        private static readonly object EVENT_CHECKEDCHANGED = new object();
        static readonly ContentAlignment anyRight  = ContentAlignment.TopRight | ContentAlignment.MiddleRight | ContentAlignment.BottomRight;

        private const int standardCheckSize = 13;
        private const int flatCheckSize = 12;

        // Used to see if we need to iterate through the autochecked items and modify their tabstops.
        private bool firstfocus = true;
        private bool isChecked;
        private bool autoCheck = true;
        private ContentAlignment checkAlign = ContentAlignment.MiddleLeft;
        private Appearance appearance        = System.Windows.Forms.Appearance.Normal;

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.RadioButton'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public RadioButton()
        : base() {
            // Radiobuttons shouldn't respond to right clicks, so we need to do all our own click logic
            SetStyle(ControlStyles.StandardClick, false);

            TextAlign = ContentAlignment.MiddleLeft;
            TabStop = false;
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.AutoCheck"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether the <see cref='System.Windows.Forms.RadioButton.Checked'/>
        /// value and the appearance of
        /// the control automatically change when the control is clicked.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.RadioButtonAutoCheckDescr)
        ]
        public bool AutoCheck {
            get {
                return autoCheck;
            }

            set {
                if (autoCheck != value) {
                    autoCheck = value;
                    PerformAutoUpdates();
                }
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.Appearance"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the appearance of the radio
        ///       button
        ///       control is drawn.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(Appearance.Normal),
        SRCategory(SR.CatAppearance),
        Localizable(true),
        SRDescription(SR.RadioButtonAppearanceDescr)
        ]
        public Appearance Appearance {
            get {
                return appearance;
            }

            set {
                if (appearance != value) {
                    if (!Enum.IsDefined(typeof(Appearance), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(Appearance));
                    }

                    appearance = value;
                    if (OwnerDraw) {
                        Refresh();
                    }
                    else {
                        UpdateStyles();
                    }
                    OnAppearanceChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_APPEARANCECHANGED = new object();

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.AppearanceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.RadioButtonOnAppearanceChangedDescr)]
        public event EventHandler AppearanceChanged {
            add {
                Events.AddHandler(EVENT_APPEARANCECHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_APPEARANCECHANGED, value);
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.CheckAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the location of the check box portion of the
        ///       radio button control.
        ///       
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        Localizable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(ContentAlignment.MiddleLeft),
        SRDescription(SR.RadioButtonCheckAlignDescr)
        ]
        public ContentAlignment CheckAlign {
            get {
                return checkAlign;
            }
            set {
                if (!Enum.IsDefined(typeof(ContentAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ContentAlignment));
                }

                checkAlign = value;
                if (OwnerDraw) {
                    Invalidate();
                }
                else {
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the
        ///       control is checked or not.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.RadioButtonCheckedDescr)
        ]
        public bool Checked {
            get {
                return isChecked;
            }

            set {
                if (isChecked != value) {
                    isChecked = value;

                    if (IsHandleCreated) SendMessage(NativeMethods.BM_SETCHECK, value? 1: 0, 0);
                    Invalidate();
                    Update();
                    PerformAutoUpdates();
                    OnCheckedChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.CreateParams"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "BUTTON";
                if (OwnerDraw) {
                    cp.Style |= NativeMethods.BS_OWNERDRAW;
                }
                else {
                    cp.Style |= NativeMethods.BS_RADIOBUTTON;
                    if (Appearance == Appearance.Button) {
                        cp.Style |= NativeMethods.BS_PUSHLIKE;
                    }
                    
                    // Determine the alignment of the radio button
                    //
                    ContentAlignment align = RtlTranslateContent(CheckAlign);                              
                    if ((int)(align & anyRight) != 0) {
                        cp.Style |= NativeMethods.BS_RIGHTBUTTON;
                    }
                }
                return cp;
            }
        }
        
        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(104, 24);
            }
        }

        internal override Rectangle OverChangeRectangle {
            get {
                if (Appearance == Appearance.Button) {
                    return base.OverChangeRectangle;
                }
                else {
                    if (FlatStyle == FlatStyle.Standard) {
                        // this Rectangle will cause no Invalidation
                        // can't use Rectangle.Empty because it will cause Invalidate(ClientRectangle)
                        return new Rectangle(-1, -1, 1, 1);
                    }
                    else {
                        return CommonLayout().Layout().checkBounds;
                    }
                }
            }
        }

        internal override Rectangle DownChangeRectangle {
            get {
                if (Appearance == Appearance.Button) {
                    return base.DownChangeRectangle;
                }
                else {
                    return CommonLayout().Layout().checkBounds;
                }
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.TabStop"]/*' />
        [DefaultValue(false)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.TextAlign"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value indicating whether the user can give the focus to this
        ///       control using the TAB key.
        ///       
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(ContentAlignment.MiddleLeft)
        ]
        public override ContentAlignment TextAlign {
            get {
                return base.TextAlign;
            }
            set {
                base.TextAlign = value;
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.CheckedChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the
        ///       value of the <see cref='System.Windows.Forms.RadioButton.Checked'/>
        ///       property changes.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.RadioButtonOnCheckedChangedDescr)]
        public event EventHandler CheckedChanged {
            add {
                Events.AddHandler(EVENT_CHECKEDCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CHECKEDCHANGED, value);
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.CreateAccessibilityInstance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Constructs the new instance of the accessibility object for this control. Subclasses
        ///       should not call base.CreateAccessibilityObject.
        ///    </para>
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new RadioButtonAccessibleObject(this);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.OnHandleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SendMessage(NativeMethods.BM_SETCHECK, isChecked? 1: 0, 0);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.OnCheckedChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.CheckBox.CheckedChanged'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnCheckedChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_CHECKEDCHANGED];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.OnClick"]/*' />
        /// <devdoc>
        ///     We override this to implement the autoCheck functionality.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnClick(EventArgs e) {
            if (autoCheck) {
                Checked = true;
            }
            base.OnClick(e);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.OnEnter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnEnter(EventArgs e) {
            // Just like the Win32 RadioButton, fire a click if the
            // user arrows onto the control..
            //
            if (MouseButtons == MouseButtons.None) {
                //Paint in raised state...
                //
                ResetFlagsandPaint();
                if(!ValidationCancelled){ 
                    OnClick(e);
                }
            }
            base.OnEnter(e);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.PerformAutoUpdates"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void PerformAutoUpdates() {
            if (autoCheck) {
                if (firstfocus) wipeTabStops();
                TabStop = isChecked;
                if (isChecked) {
                    Control parent = ParentInternal;
                    if (parent != null) {
                        for (int i = 0; i < parent.Controls.Count; i++) {
                            Control ctl = parent.Controls[i];
                            if (ctl != this && ctl is RadioButton) {
                                RadioButton button = (RadioButton)ctl;
                                if (button.autoCheck && button.Checked) {
                                    PropertyDescriptor propDesc = TypeDescriptor.GetProperties(this)["Checked"];
                                    propDesc.SetValue(button, false);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.wipeTabStops"]/*' />
        /// <devdoc>
        ///     Removes tabstops from all radio buttons, other than the one that currently has the focus.
        /// </devdoc>
        /// <internalonly/>
        private void wipeTabStops() {
            Control parent = ParentInternal;
            if (parent != null) {
                for (int i = 0; i < parent.Controls.Count; i++) {
                    Control ctl = parent.Controls[i];
                    if (ctl is RadioButton) {
                        RadioButton button = (RadioButton) ctl;
                        button.firstfocus = false;
                        if (button.autoCheck) button.TabStop = false;
                    }
                }
            }
        }

        void DrawCheckFlat(PaintEventArgs e, LayoutData layout, Color checkColor, Color checkBackground, Color checkBorder) {
            DrawCheckBackgroundFlat(e, layout.checkBounds, checkBorder, checkBackground, true);
            DrawCheckOnly(e, layout, checkColor, checkBackground, true);
        }

        void DrawCheckPopup(PaintEventArgs e, LayoutData layout, Color checkColor, Color checkBackground, bool disabledColors) {
            //DrawCheckBackground(e, layout.checkBounds, checkColor, checkBackground, disabledColors);
            DrawCheckOnly(e, layout, checkColor, checkBackground, disabledColors);
        }

        void DrawCheckBackground3DLite(PaintEventArgs e, Rectangle bounds, Color checkColor, Color checkBackground, ColorData colors, bool disabledColors) {
            Graphics g = e.Graphics;

            Color field = checkBackground;
            if (!Enabled && disabledColors) {
                field = SystemColors.Control;
            }
            using (Brush fieldBrush = new SolidBrush(field)) {
                using (Pen dark = new Pen(colors.buttonShadow),
                       light = new Pen(colors.buttonFace),
                       lightlight = new Pen(colors.highlight)) {

                    bounds.Width--;
                    bounds.Height--;
                    // fall a little short of SW, NW, NE, SE because corners come out nasty
                    g.DrawPie(dark, bounds, (float)(135 + 1), (float)(90 - 2));
                    g.DrawPie(dark, bounds, (float)(225 + 1), (float)(90 - 2));
                    g.DrawPie(lightlight, bounds, (float)(315 + 1), (float)(90 - 2));
                    g.DrawPie(lightlight, bounds, (float)(45 + 1), (float)(90 - 2));
                    bounds.Inflate(-1, -1);
                    g.FillEllipse(fieldBrush, bounds);
                    g.DrawEllipse(light, bounds);
                }
            }
        }

        void DrawCheckBackgroundFlat(PaintEventArgs e, Rectangle bounds, Color borderColor, Color checkBackground, bool disabledColors) {
            Graphics g = e.Graphics;

            Color field = checkBackground;
            Color border = borderColor;
            if (!Enabled && disabledColors) {
                border = ControlPaint.ContrastControlDark;
                field = SystemColors.Control;
            }
            Pen borderPen = new Pen(border);
            Brush fieldBrush = new SolidBrush(field);

            bounds.Width--;
            bounds.Height--;
            g.FillEllipse(fieldBrush, bounds);
            g.DrawEllipse(borderPen, bounds);

            borderPen.Dispose();
            fieldBrush.Dispose();
        }

        void DrawCheckOnly(PaintEventArgs e, LayoutData layout, Color checkColor, Color checkBackground, bool disabledColors) {

            // check
            //
            if (Checked) {
                if (!Enabled && disabledColors) {
                    checkColor = SystemColors.ControlDark;
                }

                using (Brush brush = new SolidBrush(checkColor)) {
                    // circle drawing doesn't work at this size
                    int offset = 5;

                    Rectangle vCross = new Rectangle (layout.checkBounds.X + offset, layout.checkBounds.Y + offset - 1, 2, 4);
                    e.Graphics.FillRectangle(brush, vCross);
                    Rectangle hCross = new Rectangle (layout.checkBounds.X + offset - 1, layout.checkBounds.Y + offset, 4, 2);
                    e.Graphics.FillRectangle(brush, hCross);
                }
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.Draw3DLiteBorder"]/*' />
        /// <devdoc>
        ///     Draws the border of the checkbox for the 3d look of popup buttons.
        /// </devdoc>
        Rectangle Draw3DLiteBorder(Graphics g, Rectangle r) {
            g.DrawLine(SystemPens.ControlLightLight, r.Right, r.Top, r.Right, r.Bottom + 1);
            g.DrawLine(SystemPens.ControlLightLight, r.Left, r.Bottom, r.Right + 1, r.Bottom);
            g.DrawLine(SystemPens.ControlDark, r.Left, r.Top, r.Left , r.Bottom);
            g.DrawLine(SystemPens.ControlDark, r.Left, r.Top, r.Right, r.Top);
            g.DrawLine(SystemPens.ControlLight, r.Right - 1, r.Top + 1, r.Right - 1, r.Bottom);
            g.DrawLine(SystemPens.ControlLight, r.Left + 1, r.Bottom - 1, r.Right, r.Bottom - 1);
            r.Inflate(-1, -1);
            return r;
        }

        void DrawCheckBox(PaintEventArgs e, LayoutData layout) {
            Graphics g = e.Graphics;

            Rectangle check = layout.checkBounds;
            check.X--;      // compensate for Windows drawing slightly offset to right

            ButtonState style = (ButtonState)0;

            if (isChecked) {
                style |= ButtonState.Checked;
            }
            else {
                style |= ButtonState.Normal;
            }

            if (!Enabled) {
                style |= ButtonState.Inactive;
            }

            if (base.MouseIsDown) {
                style |= ButtonState.Pushed;
            }

            ControlPaint.DrawRadioButton(g, check, style);

        }

        internal override void PaintUp(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintUp(e, Checked ? CheckState.Checked : CheckState.Unchecked);
            }
            else {
                ColorData colors = PaintRender(e.Graphics).Calculate();
                LayoutData layout = PaintLayout(e).Layout();
                PaintButtonBackground(e, ClientRectangle, null);

                PaintImage(e, layout);
                DrawCheckBox(e, layout);
                PaintField(e, layout, colors, colors.windowText, true);
            }
        }

        internal override void PaintDown(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintDown(e, Checked ? CheckState.Checked : CheckState.Unchecked);
            }
            else {
                PaintUp(e, state);
            }
        }

        internal override void PaintOver(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintOver(e, Checked ? CheckState.Checked : CheckState.Unchecked);
            }
            else {
                PaintUp(e, state);
            }
        }

        LayoutOptions CommonLayout() {
            LayoutOptions layout = new LayoutOptions();
            layout.client            = ClientRectangle;
            layout.onePixExtraBorder = false;
            layout.borderSize        = 0;
            layout.paddingSize       = 0;
            layout.maxFocus          = false;
            layout.focusOddEvenFixup = true;
            layout.font              = Font;
            layout.text              = Text;
            layout.image             = Image;
            layout.checkSize         = standardCheckSize;
            layout.checkPaddingSize  = 0;
            layout.checkAlign        = CheckAlign;
            layout.imageAlign        = ImageAlign;
            layout.textAlign         = TextAlign;
            layout.hintTextUp        = false;
            layout.textOffset        = false;
            layout.shadowedText      = !Enabled;
            layout.layoutRTL         = RightToLeft.Yes == RightToLeft && RenderRightToLeft;

            return layout;
        }

        LayoutOptions PaintLayout(PaintEventArgs e) {
            LayoutOptions layout = CommonLayout();
            layout.graphics          = e.Graphics;
            layout.hintTextUp        = false;

            return layout;
        }

        LayoutOptions PaintPopupLayout(PaintEventArgs e) {
            LayoutOptions layout = CommonLayout();
            layout.graphics          = e.Graphics;
            layout.checkSize         = flatCheckSize;

            return layout;
        }

        LayoutOptions PaintFlatLayout(PaintEventArgs e) {
            LayoutOptions layout = CommonLayout();
            layout.graphics          = e.Graphics;
            layout.checkSize         = flatCheckSize;
            layout.shadowedText      = false;

            return layout;
        }

        internal override void PaintFlatDown(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintFlatDown(e, Checked ? CheckState.Checked : CheckState.Unchecked);
                return;
            }

            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            if (Enabled) {
                PaintFlatWorker(e, colors.windowText, colors.highlight, colors.windowFrame, colors);
            }
            else {
                PaintFlatWorker(e, colors.buttonShadow, colors.buttonFace, colors.buttonShadow, colors);
            }
        } 

        internal override void PaintFlatOver(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintFlatOver(e, Checked ? CheckState.Checked : CheckState.Unchecked);
                return;
            }

            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            if (Enabled) {
                PaintFlatWorker(e, colors.windowText, colors.lowHighlight, colors.windowFrame, colors);
            }
            else {
                PaintFlatWorker(e, colors.buttonShadow, colors.buttonFace, colors.buttonShadow, colors);
            }
        }

        internal override void PaintFlatUp(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintFlatUp(e, Checked ? CheckState.Checked : CheckState.Unchecked);
                return;
            }

            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            if (Enabled) {
                PaintFlatWorker(e, colors.windowText, colors.highlight, colors.windowFrame, colors);
            }
            else {
                PaintFlatWorker(e, colors.buttonShadow, colors.buttonFace, colors.buttonShadow, colors);
            }
        }

        void PaintFlatWorker(PaintEventArgs e, Color checkColor, Color checkBackground, Color checkBorder, ColorData colors) {
            System.Drawing.Graphics g = e.Graphics;
            LayoutData layout = PaintFlatLayout(e).Layout();
            PaintButtonBackground(e, ClientRectangle, null);

            PaintImage(e, layout);
            DrawCheckFlat(e, layout, checkColor, colors.options.highContrast ? colors.buttonFace : checkBackground, checkBorder);
            PaintField(e, layout, colors, checkColor, true);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.PaintPopupUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Paints a popup checkbox in the up state.
        /// </devdoc>
        internal override void PaintPopupUp(PaintEventArgs e, CheckState state) {
            System.Drawing.Graphics g = e.Graphics;
            if (appearance == Appearance.Button) {
                base.PaintPopupUp(e, Checked ? CheckState.Checked : CheckState.Unchecked);
            }
            else {
                ColorData colors = PaintPopupRender(e.Graphics).Calculate();
                LayoutData layout = PaintPopupLayout(e).Layout();

                PaintButtonBackground(e, ClientRectangle, null);
                
                PaintImage(e, layout);
                
                DrawCheckBackgroundFlat(e, layout.checkBounds, colors.buttonShadow, colors.options.highContrast ? colors.buttonFace : colors.highlight, true);
                DrawCheckOnly(e, layout, colors.windowText, colors.highlight, true);

                PaintField(e, layout, colors, colors.windowText, true);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.PaintPopupOver"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Paints a popup checkbox in the over state.
        /// </devdoc>
        internal override void PaintPopupOver(PaintEventArgs e, CheckState state) {
            System.Drawing.Graphics g = e.Graphics;
            if (appearance == Appearance.Button) {
                base.PaintPopupOver(e, Checked ? CheckState.Checked : CheckState.Unchecked);
            }
            else {
                ColorData colors = PaintPopupRender(e.Graphics).Calculate();
                LayoutData layout = PaintFlatLayout(e).Layout();

                PaintButtonBackground(e, ClientRectangle, null);
                
                PaintImage(e, layout);
                
                DrawCheckBackground3DLite(e, layout.checkBounds, colors.windowText, colors.options.highContrast ? colors.buttonFace : colors.highlight, colors, true);
                DrawCheckOnly(e, layout, colors.windowText, colors.highlight, true);

                PaintField(e, layout, colors, colors.windowText, true);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.PaintPopupDown"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Paints a popup checkbox in the down state.
        /// </devdoc>
        internal override void PaintPopupDown(PaintEventArgs e, CheckState state) {
            System.Drawing.Graphics g = e.Graphics;
            if (appearance == Appearance.Button) {
                base.PaintPopupDown(e, Checked ? CheckState.Checked : CheckState.Unchecked);
            }
            else {
                ColorData colors = PaintPopupRender(e.Graphics).Calculate();
                LayoutData layout = PaintFlatLayout(e).Layout();

                PaintButtonBackground(e, ClientRectangle, null);
                
                PaintImage(e, layout);
                
                DrawCheckBackground3DLite(e, layout.checkBounds, colors.windowText, colors.highlight, colors, true);
                DrawCheckOnly(e, layout, colors.buttonShadow, colors.highlight, true);

                PaintField(e, layout, colors, colors.windowText, true);
            }
        }


        void OnAppearanceChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_APPEARANCECHANGED] as EventHandler;
            if (eh != null) {
                eh(this, e);
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.OnMouseUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnMouseUp'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs mevent) {
            if (mevent.Button == MouseButtons.Left && GetStyle(ControlStyles.UserPaint)) {
                if (base.MouseIsDown) {
                    Point pt = PointToScreen(new Point(mevent.X, mevent.Y));
                    if (UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                        //Paint in raised state...
                        //
                        ResetFlagsandPaint();
                        if (!ValidationCancelled) {
                            OnClick(EventArgs.Empty);
                        }
                        
                    }
                }
            }
            base.OnMouseUp(mevent);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.PerformClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates a <see cref='System.Windows.Forms.Control.Click'/> event for the
        ///       button, simulating a click by a user.
        ///    </para>
        /// </devdoc>
        public void PerformClick() {
            if (CanSelect) {
                //Paint in raised state...
                //
                ResetFlagsandPaint();
                if (!ValidationCancelled) {
                    OnClick(EventArgs.Empty);
                }
            }
                
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.ProcessMnemonic"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override bool ProcessMnemonic(char charCode) {
            if (IsMnemonic(charCode, Text) && CanSelect) {
                if (!Focused) {
                    FocusInternal();    // This will cause an OnEnter event, which in turn will fire the click event
                }
                else {
                    PerformClick();     // Generate a click if already focused
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Checked: " + Checked.ToString();
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButtonAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        public class RadioButtonAccessibleObject : ControlAccessibleObject {

            /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButtonAccessibleObject.RadioButtonAccessibleObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public RadioButtonAccessibleObject(RadioButton owner) : base(owner) {
            }

            /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButtonAccessibleObject.DefaultAction"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string DefaultAction {
                get {
                    return SR.GetString(SR.AccessibleActionCheck);
                }
            }

            /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButtonAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.RadioButton;
                }
            }

            /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButtonAccessibleObject.State"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleStates State {
                get {
                    if (((RadioButton)Owner).Checked) {
                        return AccessibleStates.Checked | base.State;
                    }
                    return base.State;
                }
            }

            /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButtonAccessibleObject.DoDefaultAction"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override void DoDefaultAction() {
                ((RadioButton)Owner).PerformClick();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\relatedpropertymanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="RelatedPropertyManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Collections;

    internal class RelatedPropertyManager : PropertyManager {

        BindingManagerBase parentManager;
        string dataField;
        PropertyDescriptor fieldInfo;
        
        internal RelatedPropertyManager(BindingManagerBase parentManager, string dataField) : base(parentManager.Current, dataField) {
            Debug.Assert(parentManager != null, "How could this be a null parentManager.");
            this.parentManager = parentManager;
            this.dataField = dataField;
            this.fieldInfo = parentManager.GetItemProperties().Find(dataField, true);
            if (fieldInfo == null)
                throw new ArgumentException(SR.GetString(SR.RelatedListManagerChild, dataField));
            // this.finalType = fieldInfo.PropertyType;
            parentManager.CurrentChanged += new EventHandler(ParentManager_CurrentChanged);
            ParentManager_CurrentChanged(parentManager, EventArgs.Empty);
        }

        public override PropertyDescriptorCollection GetItemProperties() {
            PropertyDescriptorCollection sublistProperties = GetItemProperties(new ArrayList(), new ArrayList());
            if (sublistProperties != null) {
                return sublistProperties;
            }
            // If the dataSource is an IList (L1), that indexes a type (T1) which has a property (P1) that
            // returns an IList, then the following combination was possible:
            // L1.P1.P1.P1....
            return new PropertyDescriptorCollection(null);
            // return base.GetItemProperties();
        }
        
        protected internal override PropertyDescriptorCollection GetItemProperties(ArrayList dataSources, ArrayList listAccessors) {
            dataSources.Insert(0, this.DataSource);
            listAccessors.Insert(0, fieldInfo);
            return parentManager.GetItemProperties(dataSources, listAccessors);
        }
        
        internal override string GetListName() {
            string name = GetListName(new ArrayList());
            if (name.Length > 0) {
                return name;
            }
            return base.GetListName();
        }
        
        protected internal override string GetListName(ArrayList listAccessors) {
            listAccessors.Insert(0, fieldInfo);
            return parentManager.GetListName(listAccessors);
        }
        
        private void ParentManager_CurrentChanged(object sender, EventArgs e) {
            EndCurrentEdit();
            SetDataSource(fieldInfo.GetValue(parentManager.Current));
            OnCurrentChanged(EventArgs.Empty);
        }

        internal override Type BindType {
            get {
                return fieldInfo.PropertyType;
            }
        }

        internal protected override void OnCurrentChanged(EventArgs e) {
            SetDataSource(fieldInfo.GetValue(parentManager.Current));
            base.OnCurrentChanged(e);
        }

        /*
        public override object Current {
            get {
                return fieldInfo.GetValue(parentManager.Current);
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\requestresizeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequestResizeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\RequestResizeEventHandler.uex' path='docs/doc[@for="ContentsResizedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Windows.Forms.RichTextBox.ContentsResized'/> event of
    ///    a <see cref='System.Windows.Forms.RichTextBox'/>.</para>
    /// </devdoc>
    public delegate void ContentsResizedEventHandler(object sender, ContentsResizedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxfinds.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxFinds.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\RichTextBoxFinds.uex' path='docs/doc[@for="RichTextBoxFinds"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how the <see cref='System.Windows.Forms.RichTextBox.Find'/> method works.
    ///
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum RichTextBoxFinds {

        /// <include file='doc\RichTextBoxFinds.uex' path='docs/doc[@for="RichTextBoxFinds.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Find the text without any special characteristics.
        ///
        ///    </para>
        /// </devdoc>
        None               = 0x00000000,

        /// <include file='doc\RichTextBoxFinds.uex' path='docs/doc[@for="RichTextBoxFinds.WholeWord"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Match only a whole word.
        ///    </para>
        /// </devdoc>
        WholeWord           = 0x00000002,

        /// <include file='doc\RichTextBoxFinds.uex' path='docs/doc[@for="RichTextBoxFinds.MatchCase"]/*' />
        /// <devdoc>
        ///     Match the case exactly.
        /// </devdoc>
        MatchCase           = 0x00000004,

        /// <include file='doc\RichTextBoxFinds.uex' path='docs/doc[@for="RichTextBoxFinds.NoHighlight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       If the text is found, do not highlight it.
        ///    </para>
        /// </devdoc>
        NoHighlight         = 0x00000008,
        
        /// <include file='doc\RichTextBoxFinds.uex' path='docs/doc[@for="RichTextBoxFinds.Reverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Search from the end of the current selection to the beginning of the document.
        ///    </para>
        /// </devdoc>
        Reverse             = 0x00000010,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygrid.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyGrid.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.Security.Permissions;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Drawing.Imaging;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.PropertyGridInternal;

    /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Designer("System.Windows.Forms.Design.PropertyGridDesigner, " + AssemblyRef.SystemDesign)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class PropertyGrid : ContainerControl, IComPropertyBrowser, UnsafeNativeMethods.IPropertyNotifySink {
    
        private DocComment                          doccomment;
        private int                                 dcSizeRatio = -1;
        private int                                 hcSizeRatio = -1;
        private HotCommands                         hotcommands;
        private GridToolBar                         toolbar;
        
        private ImageList[]                         imageList = new ImageList[2];
        private Bitmap                              bmpAlpha;
        private Bitmap                              bmpCategory;
        private Bitmap                              bmpPropPage;

        // our array of viewTabs
        private bool                                viewTabsDirty = true;
        private PropertyTab[]                       viewTabs = new PropertyTab[0];
        private PropertyTabScope[]                  viewTabScopes = new PropertyTabScope[0];
        private Hashtable                           viewTabProps;

        // the tab view buttons
        private ToolBarButton[]                     viewTabButtons;
        // the index of the currently selected tab view
        private int                                 selectedViewTab;
        
        
        // our view type buttons (Alpha vs. categorized)
        private ToolBarButton[]                     viewSortButtons; //new ToolBarButton[0];
        private int                                 selectedViewSort;   
        private PropertySort                        propertySortValue;

        // this guy's kind of an odd one...he gets special treatment
        private ToolBarButton                       btnViewPropertyPages;
        private ToolBarButton                       separator1;
        private ToolBarButton                       separator2;
        private int                                 buttonType = NORMAL_BUTTONS;

        // our main baby
        private PropertyGridView                    gridView;

        
        private IDesignerHost    designerHost;
        
        private Hashtable        designerSelections;

        private GridEntry peDefault;
        private GridEntry peMain;
        private GridEntryCollection currentPropEntries;
        private Object[]   currentObjects;
        
        private int     paintFrozen;
        private Color   lineColor = SystemColors.ScrollBar;
        //private Color   textColor = SystemColors.WindowText;
        //private Color   outlineColor = SystemColors.GrayText;
        internal Brush  lineBrush = null;

        private AttributeCollection browsableAttributes;

        private SnappableControl                    targetMove = null;
        private int                                 dividerMoveY = -1;
        private const int                    CYDIVIDER = 3;
        private const int                    CXINDENT = 0;
        private const int                    CYINDENT = 2;
        private const int                    MIN_GRID_HEIGHT = 20;

        private const int                    PROPERTIES = 0;
        private const int                    EVENTS = 1;
        private const int                    ALPHA = 1;
        private const int                    CATEGORIES = 0;
        private const int                    NO_SORT = 2;

        private const int                    NORMAL_BUTTONS = 0;
        private const int                    LARGE_BUTTONS = 1;

        private const ushort                  PropertiesChanged          = 0x0001;
        private const ushort                  GotDesignerEventService    = 0x0002;
        private const ushort                  InternalChange             = 0x0004;
        private const ushort                  TabsChanging               = 0x0008;
        private const ushort                  BatchMode                  = 0x0010;
        private const ushort                  ReInitTab                  = 0x0020;
        private const ushort                  SysColorChangeRefresh      = 0x0040;
        private const ushort                  FullRefreshAfterBatch      = 0x0080;
        private const ushort                  BatchModeChange            = 0x0100;

        private ushort                  flags;

        private bool GetFlag(ushort flag) {
            return (flags & flag) != (ushort)0;
        }

        private void SetFlag(ushort flag, bool value) {
            if (value) {
                flags |= flag;
            }
            else {
                flags &= (ushort)~flag;
            }
        }


        private readonly ComponentEventHandler                  onComponentAdd;
        private readonly ComponentEventHandler                  onComponentRemove;
        private readonly ComponentChangedEventHandler           onComponentChanged;
        
        // the cookies for our connection points on objects that support IPropertyNotifySink
        //
        private NativeMethods.ConnectionPointCookie[] connectionPointCookies = null;

        private static object          EventPropertyValueChanged = new object();
        private static object          EventComComponentNameChanged = new object();
        private static object          EventPropertyTabChanged = new object();
        private static object          EventSelectedGridItemChanged = new object();
        private static object          EventPropertySortChanged = new object();
        private static object          EventSelectedObjectsChanged = new object();
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyGrid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyGrid()  {

            

            if (TypeDescriptor.ComNativeDescriptorHandler == null) {
                TypeDescriptor.ComNativeDescriptorHandler = new System.Windows.Forms.ComponentModel.Com2Interop.ComNativeDescriptor();
            }

            onComponentAdd = new ComponentEventHandler(OnComponentAdd);
            onComponentRemove = new ComponentEventHandler(OnComponentRemove);
            onComponentChanged = new ComponentChangedEventHandler(OnComponentChanged);
            
            try {
                gridView = CreateGridView(null);
                gridView.TabStop = true;
                gridView.MouseMove += new MouseEventHandler(this.OnChildMouseMove);
                gridView.MouseDown += new MouseEventHandler(this.OnChildMouseDown);
                gridView.TabIndex = 2;

                separator1 = CreateSeparatorButton();
                separator2 = CreateSeparatorButton();

                toolbar = new GridToolBar();
                toolbar.AccessibleName = SR.GetString(SR.PropertyGridToolbarAccessibleName);
                toolbar.Dock = DockStyle.None;
                toolbar.TabStop = true;
                toolbar.AutoSize = true;
                toolbar.Appearance = ToolBarAppearance.Flat;
                toolbar.Divider = false;
                toolbar.ButtonClick += new ToolBarButtonClickEventHandler(this.OnButtonClick);
                toolbar.TabIndex = 1;

                // always add the property tab here
                AddRefTab(DefaultTabType, null, PropertyTabScope.Static, true);

                doccomment = new DocComment();
                doccomment.TabStop = false;
                doccomment.Dock = DockStyle.None;
                doccomment.BackColor = SystemColors.Control;
                doccomment.ForeColor = SystemColors.ControlText;
                doccomment.MouseMove += new MouseEventHandler(this.OnChildMouseMove);
                doccomment.MouseDown += new MouseEventHandler(this.OnChildMouseDown);
                
                

                hotcommands = new HotCommands();
                hotcommands.TabIndex = 3;
                hotcommands.Dock = DockStyle.None;
                SetHotCommandColors(false);
                hotcommands.Visible = false;
                hotcommands.MouseMove += new MouseEventHandler(this.OnChildMouseMove);
                hotcommands.MouseDown += new MouseEventHandler(this.OnChildMouseDown);

                Controls.Add(toolbar);
                Controls.Add(gridView);
                Controls.Add(hotcommands);
                Controls.Add(doccomment);
                
                SetActiveControlInternal(gridView);
                SetupToolbar();
                this.PropertySort = PropertySort.Categorized | PropertySort.Alphabetical;
                this.Text = "PropertyGrid";
                SetSelectState(0);
            }
            catch (Exception ex) {
                Debug.WriteLine(ex.ToString());
            }
            
            
        }
   
        internal IDesignerHost ActiveDesigner {
            get{
                if (this.designerHost == null) {
                    designerHost = (IDesignerHost)GetService(typeof(IDesignerHost));
                }
                return this.designerHost;
            }
            set{
                if (value != designerHost) {
                    SetFlag(ReInitTab, true);
                    if (this.designerHost != null) {
                        IComponentChangeService cs = (IComponentChangeService)designerHost.GetService(typeof(IComponentChangeService));
                        if (cs != null) {
                            cs.ComponentAdded -= onComponentAdd;
                            cs.ComponentRemoved -= onComponentRemove;
                            cs.ComponentChanged -= onComponentChanged;
                        }
                        
                        IPropertyValueUIService pvSvc = (IPropertyValueUIService)designerHost.GetService(typeof(IPropertyValueUIService));
                        if (pvSvc != null) {
                            pvSvc.PropertyUIValueItemsChanged -= new EventHandler(this.OnNotifyPropertyValueUIItemsChanged);
                        }
                        
                        designerHost.TransactionOpened -= new EventHandler(this.OnTransactionOpened);
                        designerHost.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                        SetFlag(BatchMode, false);
                        RemoveTabs(PropertyTabScope.Document, true);
                        this.designerHost = null;
                    }

                    

                    if (value != null) {
                        IComponentChangeService cs = (IComponentChangeService)value.GetService(typeof(IComponentChangeService));
                        if (cs != null) {
                            cs.ComponentAdded += onComponentAdd;
                            cs.ComponentRemoved += onComponentRemove;
                            cs.ComponentChanged += onComponentChanged;
                        }

                        value.TransactionOpened += new EventHandler(this.OnTransactionOpened);
                        value.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                        SetFlag(BatchMode, false);
                        
                        IPropertyValueUIService pvSvc = (IPropertyValueUIService)value.GetService(typeof(IPropertyValueUIService));
                        if (pvSvc != null) {
                            pvSvc.PropertyUIValueItemsChanged += new EventHandler(this.OnNotifyPropertyValueUIItemsChanged);
                        }
                    }
                    
                    designerHost = value;
                    if (peMain != null) {
                        peMain.DesignerHost = value;
                    }
                    RefreshTabs(PropertyTabScope.Document);
                }
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.AutoScroll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override bool AutoScroll {
            get {
                return base.AutoScroll;
            }
            set {
                base.AutoScroll = value;
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Color BackColor {
            get {
                return base.BackColor;
            }
            set {
                base.BackColor = value;
                toolbar.BackColor = value;
                toolbar.Invalidate(true);
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.BrowsableAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ] 
        public AttributeCollection BrowsableAttributes {
            set {
                if (value == null || value == AttributeCollection.Empty) {
                    browsableAttributes = new AttributeCollection(new Attribute[]{BrowsableAttribute.Yes});
                }
                else {
                    Attribute[] attributes = new Attribute[value.Count];
                    value.CopyTo(attributes, 0);
                    browsableAttributes = new AttributeCollection(attributes);
                }
                if (currentObjects != null && currentObjects.Length > 0) {
                    if (peMain != null) {
                        peMain.BrowsableAttributes = BrowsableAttributes;
                        Refresh(true);
                    }
                }
            }
            get {
                if (browsableAttributes == null) {
                    browsableAttributes = new AttributeCollection(new Attribute[]{new BrowsableAttribute(true)});
                }
                return browsableAttributes;
            }
        }
        
        private bool CanCopy {
            get {
                return gridView.CanCopy;
            }
        }
        
        private bool CanCut {
            get {
                return gridView.CanCut;
            }
        }
        
        private bool CanPaste {
            get {
                return gridView.CanPaste;
            }
        }
        
        private bool CanUndo {
            get {
                return gridView.CanUndo;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CanShowCommands"]/*' />
        /// <devdoc>
        /// true if the commands pane will be can be made visible
        /// for the currently selected objects.  Objects that
        /// expose verbs can show commands.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
         SRDescription(SR.PropertyGridCanShowCommandsDesc)]
        public virtual bool CanShowCommands {
            get {
                return hotcommands.WouldBeVisible;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CommandsBackColor"]/*' />
        /// <devdoc>
        /// The background color for the hot commands region.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridCommandsBackColorDesc)
        ]
        public Color CommandsBackColor {
            get {
                return hotcommands.BackColor;
            }
            set {
                hotcommands.BackColor = value;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CommandsForeColor"]/*' />
        /// <devdoc>
        /// The forground color for the hot commands region.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridCommandsForeColorDesc)
        ]
        public Color CommandsForeColor {
            get {
                return hotcommands.ForeColor;
            }
            set {
                hotcommands.ForeColor = value;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CommandsVisible"]/*' />
        /// <devdoc>
        /// Returns true if the commands pane is currently shown.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public virtual bool CommandsVisible {
            get {
                return hotcommands.Visible;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CommandsVisibleIfAvailable"]/*' />
        /// <devdoc>
        /// Returns true if the commands pane will be shown for objects
        /// that expose verbs.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(false),
        SRDescription(SR.PropertyGridCommandsVisibleIfAvailable)
        ]
        public virtual bool CommandsVisibleIfAvailable {
            get {
                return hotcommands.AllowVisible;
            }
            set {
                bool hotcommandsVisible = hotcommands.Visible;
                hotcommands.AllowVisible = value;
                //PerformLayout();
                if (hotcommandsVisible != hotcommands.Visible) {
                    OnLayoutInternal(false);
                    hotcommands.Invalidate();
                }
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ContextMenuDefaultLocation"]/*' />
        /// <devdoc>
        /// Returns a default location for showing the context menu.  This
        /// location is the center of the active property label in the grid, and
        /// is used useful to position the context menu when the menu is invoked
        /// via the keyboard.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Point ContextMenuDefaultLocation {
            get {
                return GetPropertyGridView().ContextMenuDefaultLocation;
            }
        }
        
         /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.Controls"]/*' />
         /// <devdoc>
        ///     Collection of child controls.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public new ControlCollection Controls {
            get {
                return base.Controls;
            }
        }

        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.DefaultSize"]/*' />
        protected override Size DefaultSize {
            get {
                return new Size(130, 130);
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.DefaultTabType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected virtual Type DefaultTabType {
            get {
               return typeof(PropertiesTab);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.DrawFlatToolbar"]/*' />
        ///<internalonly/>
        protected bool DrawFlatToolbar {
            get {
                return toolbar.MsoPaint;
            }
            set {
                toolbar.MsoPaint = value;
                SetHotCommandColors(value);
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ForeColor"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        private bool FreezePainting {
            get {
               return paintFrozen > 0;
            }
            set {
               
               if (value && IsHandleCreated && this.Visible) {
                  if (0 == paintFrozen++) {
                     SendMessage(NativeMethods.WM_SETREDRAW, 0, 0);
                  }
               }
               if (!value) {
                  if (paintFrozen == 0) {
                     return;
                  }
               
                  if (0 == --paintFrozen) {
                     SendMessage(NativeMethods.WM_SETREDRAW, 1, 0);
                     Invalidate(true);
                  }
                  
               }
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.HelpBackColor"]/*' />
        /// <devdoc>
        /// The background color for the help region.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridHelpBackColorDesc)
        ]
        public Color HelpBackColor {
            get {
                return doccomment.BackColor;
            }
            set {
                doccomment.BackColor = value;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.HelpForeColor"]/*' />
        /// <devdoc>
        /// The forground color for the help region.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridHelpForeColorDesc)
        ]
        public Color HelpForeColor {
            get {
                return doccomment.ForeColor;
            }
            set {
                doccomment.ForeColor = value;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.HelpVisible"]/*' />
        /// <devdoc>
        /// Sets or gets the visiblity state of the help pane.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.PropertyGridHelpVisibleDesc)
        ]
        public virtual bool HelpVisible {
            get {
                return doccomment.Visible;
            }
            set {
                doccomment.Visible = value;
                OnLayoutInternal(false);
                Invalidate();
                doccomment.Invalidate();
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.InPropertySet"]/*' />
        /// <internalonly/>
        bool IComPropertyBrowser.InPropertySet {
            get {
                return GetPropertyGridView().GetInPropertySet();
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.LineColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridLineColorDesc)
        ]
        public Color LineColor {
            get {
                return lineColor;
            }
            set {
                if (lineColor != value) {
                    lineColor = value;
                    if (lineBrush != null) {
                        lineBrush.Dispose();
                        lineBrush = null;
                    }
                    gridView.Invalidate();
                }
            }
        }
    
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertySort"]/*' />
        /// <devdoc>
        /// Sets or gets the current property sort type, which can be
        /// PropertySort.Categorized or PropertySort.Alphabetical.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(PropertySort.CategorizedAlphabetical),
        SRDescription(SR.PropertyGridPropertySortDesc)
        ]
        public PropertySort PropertySort {
            get {
                return propertySortValue;
            }
            set {
                
                ToolBarButton newButton;
                
                if ((value & PropertySort.Categorized) != 0) {
                    newButton = viewSortButtons[CATEGORIES];
                }
                else if ((value & PropertySort.Alphabetical) != 0) {
                    newButton = viewSortButtons[ALPHA];
                }
                else {
                    newButton = viewSortButtons[NO_SORT];
                }
                
                GridItem selectedGridItem = SelectedGridItem;
               
               
                OnViewSortButtonClick(newButton, EventArgs.Empty);
            
                this.propertySortValue = value;
                
                if (selectedGridItem != null) {
                    SelectedGridItem = selectedGridItem;
                }
                
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public PropertyTabCollection PropertyTabs {
            get {
                return new PropertyTabCollection(this);
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.SelectedObject"]/*' />
        /// <devdoc>
        /// Sets a single Object into the grid to be browsed.  If multiple
        /// objects are being browsed, this property will return the first
        /// one in the list.  If no objects are selected, null is returned.
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.PropertyGridSelectedObjectDesc),
        SRCategory(SR.CatBehavior),
        TypeConverter(typeof(SelectedObjectConverter))
        ]
        public Object SelectedObject {
            get {
                if (currentObjects == null || currentObjects.Length == 0) {
                    return null;
                }
                return currentObjects[0];
            }
            set {
                if (value == null) {
                    SelectedObjects = new object[0];
                }
                else {
                    SelectedObjects = new Object[]{value};
                }
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.SelectedObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public object [] SelectedObjects {
            set {   
                try {
            
               this.FreezePainting = true;

               SetFlag(FullRefreshAfterBatch, false);
               if (GetFlag(BatchMode)) {
                   SetFlag(BatchModeChange, false);
               }
               
            
               gridView.EnsurePendingChangesCommitted();
   
               CheckDesignerEventService();
   
               bool isSame = false;
               bool classesSame = false;
               bool showEvents = GetFlag(GotDesignerEventService);
   
               // validate the array coming in
               if (value != null && value.Length > 0) {
                   for (int count = 0; count < value.Length; count++) {
                       if (value[count] == null) {
                           throw new ArgumentException(SR.GetString(SR.PropertyGridSetNull, count.ToString(), value.Length.ToString()));
                       }
                   }
               }
               else {
                    showEvents = false;
               }
   
               // make sure we actually changed something before we inspect tabs
               if (currentObjects != null && value != null &&
                   currentObjects.Length == value.Length) {
                   isSame = true;
                   classesSame = true;
                   for (int i = 0; i < value.Length && (isSame || classesSame); i++) {
                       if (isSame && currentObjects[i] != value[i]) {
                           isSame = false;
                       }
   
                       Type oldType = GetUnwrappedObject(i).GetType();
   
                       Object objTemp = value[i];
   
                       if (objTemp is ICustomTypeDescriptor) {
                           objTemp = ((ICustomTypeDescriptor)objTemp).GetPropertyOwner(null);
                       }
                       Type newType = objTemp.GetType();        
   
                       // check if the types are the same.  If they are, and they 
                       // are COM objects, check their GUID's.  If they are different
                       // or Guid.Emtpy, assume the classes are different.
                       //
                       if (classesSame && 
                           (oldType != newType || oldType.IsCOMObject && newType.IsCOMObject)) {
                           classesSame = false;
                       }
                   }
               }
   
               if (!isSame) {
               
                   SetStatusBox("", "");
                   
                   ClearCachedProps();
                   if (value == null) {
                       currentObjects = new Object[0];
                   }
                   else {
                       currentObjects = (object[])value.Clone();
                   }
                   
                   SinkPropertyNotifyEvents();
                   SetFlag(PropertiesChanged, true);
                   
                   if (peMain != null) {
                        peMain.Dispose();
                   }
   
                   // throw away any extra component only tabs
                   if (!classesSame && !GetFlag(TabsChanging) && selectedViewTab < viewTabButtons.Length) {

                       Type tabType = selectedViewTab == -1 ? null : viewTabs[selectedViewTab].GetType();
                       ToolBarButton viewTabButton = null;
                       RefreshTabs(PropertyTabScope.Component);
                       EnableTabs();
                       if (tabType != null) {
                           for (int i = 0; i < viewTabs.Length;i++) {
                               if (viewTabs[i].GetType() == tabType && viewTabButtons[i].Visible) {
                                   viewTabButton = viewTabButtons[i];
                                   break;
                               }
                           }
                       }
                       SelectViewTabButtonDefault(viewTabButton);
                   }
                   
                   // make sure we've also got events on all the objects
                   if (showEvents && viewTabs != null && viewTabs.Length > EVENTS && (viewTabs[EVENTS] is EventsTab)) {
                       showEvents = viewTabButtons[EVENTS].Visible;
                       Object tempObj;
                       PropertyDescriptorCollection events;
                       Attribute[] attrs = new Attribute[BrowsableAttributes.Count];
                       BrowsableAttributes.CopyTo(attrs, 0);

                       Hashtable eventTypes = null;

                       if (currentObjects.Length > 10) {
                           eventTypes = new Hashtable();
                       }
       
                       for (int i = 0; i < currentObjects.Length && showEvents; i++) {
                           tempObj = currentObjects[i];
                           
                           if (tempObj is ICustomTypeDescriptor) {
                               tempObj = ((ICustomTypeDescriptor)tempObj).GetPropertyOwner(null);
                           }

                           Type objType = tempObj.GetType();

                           if (eventTypes != null && eventTypes.Contains(objType)) {
                               continue;
                           }
                           
                           // make sure these things are sited components as well
                           showEvents = showEvents && (tempObj is IComponent && ((IComponent)tempObj).Site != null);
       
                           // make sure we've also got events on all the objects
                           events =  ((EventsTab)viewTabs[EVENTS]).GetProperties(tempObj, attrs);
                           showEvents = showEvents && events != null && events.Count > 0;

                           if (showEvents && eventTypes != null) {
                               eventTypes[objType] = objType;
                           }
                       }
                   }
                   ShowEventsButton(showEvents && currentObjects.Length > 0);
                   DisplayHotCommands();
   
                   if (currentObjects.Length == 1) {
                       EnablePropPageButton(currentObjects[0]);
                   }
                   else {
                       EnablePropPageButton(null);
                   }

                   OnSelectedObjectsChanged(EventArgs.Empty);
               }
   
   
               /*
   
               SBurke, hopefully this won't be a big perf problem, but it looks like we
                       need to refresh even if we didn't change the selected objects.
   
               if (propertiesChanged) {*/
               if (!GetFlag(TabsChanging)) {
                  if (currentObjects.Length > 0 && GetFlag(ReInitTab)) {
                        object designerKey = ActiveDesigner;
                         if (designerKey != null && designerSelections != null && designerSelections.ContainsKey(designerKey.GetHashCode())) {
                           int nButton = (int)designerSelections[designerKey.GetHashCode()];
                           if (nButton < viewTabs.Length) {
                              SelectViewTabButton(viewTabButtons[nButton], true);
                           }
                         }
                         else  {
                           Refresh(false);
                         }
                         SetFlag(ReInitTab, false);
                  }
                  else {
                     Refresh(true);
                  }

                  if (currentObjects.Length > 0) {
                       SaveTabSelection();
                  }
               }
               /*}else {
                   Invalidate();
                   gridView.Invalidate();
               //}*/
            }
            finally {
               this.FreezePainting = false;
            }
          }
          get {
              if (currentObjects == null) {
                  return new object[0];
              }
              return (object[])currentObjects.Clone();
          }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.SelectedTab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public PropertyTab SelectedTab {
            get {
                Debug.Assert(selectedViewTab < viewTabs.Length && selectedViewTab >= 0, "Invalid tab selection!");
                return viewTabs[selectedViewTab];
            }
        }



        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.SelectedGridItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public GridItem SelectedGridItem {
            get {
                GridItem g = gridView.SelectedGridEntry;
                if (g == null) {
                    return this.peMain;
                }
                return g;
            }
            set {
                gridView.SelectedGridEntry = (GridEntry)value;
            }
        }
       
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ShowFocusCues"]/*' />
        ///<internalonly/>        
        protected override bool ShowFocusCues {
            get {
                return true;
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.Site"]/*' />
        public override ISite Site {
            get {
                return base.Site;
            }
            set {
                base.Site = value;
                gridView.ServiceProvider = value;

                if (value == null) {
                    this.ActiveDesigner = null;
                }
                else {
                    this.ActiveDesigner = (IDesignerHost)value.GetService(typeof(IDesignerHost));
                }
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.LargeButtons"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridLargeButtonsDesc)
        ]
        public bool LargeButtons{
            get {
                return buttonType == LARGE_BUTTONS;
            }
            set {
                if (value == (buttonType == LARGE_BUTTONS)) {
                    return;
                }

                this.buttonType = (value ?  LARGE_BUTTONS : NORMAL_BUTTONS);
                if (value) {
                    EnsureLargeButtons();
                }
                toolbar.ImageList = imageList[this.buttonType];
                OnLayoutInternal(false);
                Invalidate();
                toolbar.Invalidate();
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ToolbarVisible"]/*' />
        /// <devdoc>
        /// Sets or gets the visiblity state of the toolbar.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(true),
        SRDescription(SR.PropertyGridToolbarVisibleDesc)
        ]
        public virtual bool ToolbarVisible {
            get {
                return toolbar.Visible;
            }
            set {
                toolbar.Visible = value;
                OnLayoutInternal(false);
                if (value) {
                    SetupToolbar(this.viewTabsDirty);
                }
                Invalidate();
                toolbar.Invalidate();
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ViewBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridViewBackColorDesc)
        ]
        public Color ViewBackColor {
            get {
                return gridView.BackColor;
            }
            set {
                gridView.BackColor = value;
                gridView.Invalidate();
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ViewForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
                [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.PropertyGridViewForeColorDesc)
        ]
        public Color ViewForeColor {
            get {
                return gridView.ForeColor;
            }
            set {
                gridView.ForeColor = value;
                gridView.Invalidate();
            
            }
        }
  
        private int AddImage(Bitmap image) {
            
            image.MakeTransparent();
            
            if (SystemColors.Control.ToArgb() == Color.Black.ToArgb()) {
               Bitmap newImage = new Bitmap(image.Size.Width, image.Size.Height);
               Graphics g = Graphics.FromImage(newImage);
               ControlPaint.DrawImageReplaceColor(g, image, new Rectangle(0,0, newImage.Size.Width, newImage.Size.Height), Color.Black, Color.White);
               g.Dispose();
               image = newImage;
            }
            
            
            int result = imageList[NORMAL_BUTTONS].Images.Count;
            imageList[NORMAL_BUTTONS].Images.Add(image);
            return result;
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyValueChanged"]/*' />
        /// <devdoc> Event that is fired when a property value is modified.</devdoc>
        public event PropertyValueChangedEventHandler PropertyValueChanged {
            add {
                Events.AddHandler(EventPropertyValueChanged, value);
            }
            remove {
                Events.RemoveHandler(EventPropertyValueChanged, value);
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.ComComponentNameChanged"]/*' />
        ///<internalonly/>        
        event ComponentRenameEventHandler IComPropertyBrowser.ComComponentNameChanged {
            add {
                Events.AddHandler(EventComComponentNameChanged, value);
            }
            remove {
                Events.RemoveHandler(EventComComponentNameChanged, value);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabChanged"]/*' />
        /// <devdoc> Event that is fired when the current view tab is changed, such as changing from Properties to Events</devdoc>
        public event PropertyTabChangedEventHandler PropertyTabChanged {
            add {
                Events.AddHandler(EventPropertyTabChanged, value);
            }
            remove {
                Events.RemoveHandler(EventPropertyTabChanged, value);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertySortChanged"]/*' />
        /// <devdoc> Event that is fired when the sort mode is changed.</devdoc>
        public event EventHandler PropertySortChanged {
            add {
                Events.AddHandler(EventPropertySortChanged, value);
            }
            remove {
                Events.RemoveHandler(EventPropertySortChanged, value);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.SelectedGridItemChanged"]/*' />
        /// <devdoc> Event that is fired when the selected GridItem is changed</devdoc>
        public event SelectedGridItemChangedEventHandler SelectedGridItemChanged {
            add {
                Events.AddHandler(EventSelectedGridItemChanged, value);
            }
            remove {
                Events.RemoveHandler(EventSelectedGridItemChanged, value);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.SelecteObjectsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler SelectedObjectsChanged {
            add {
                Events.AddHandler(EventSelectedObjectsChanged, value);
            }
            remove {
                Events.RemoveHandler(EventSelectedObjectsChanged, value);
            }
        }
        
        internal void AddTab(Type tabType) {
            AddRefTab(tabType, null, PropertyTabScope.Global, true);
        }
        
        internal void AddTab(Type tabType, PropertyTabScope scope) {
            AddRefTab(tabType, null, scope, true);
        }

        internal void AddRefTab(Type tabType, Object component) {
            AddRefTab(tabType, component, PropertyTabScope.Global, true);
        }

        internal void AddRefTab(Type tabType, Object component, PropertyTabScope type, bool setupToolbar) {
            PropertyTab tab = null;
            int tabIndex = -1;

            if (viewTabs != null) {
                // check to see if we've already got a tab of this type
                for (int i = 0; i < viewTabs.Length; i++) {
                    Debug.Assert(viewTabs[i] != null, "Null item in tab array!");
                    if (tabType == viewTabs[i].GetType()) {
                        tab = viewTabs[i];
                        tabIndex = i;
                        break;
                    }
                }
            }
            else {
                tabIndex = 0;
            }

            if (tab == null) {
                // the tabs need service providers. The one we hold onto is not good enough,
                // so try to get the one off of the component's site.
                IDesignerHost host = null;
                if (component != null && component is IComponent && ((IComponent) component).Site != null)
                    host = (IDesignerHost) ((IComponent) component).Site.GetService(typeof(IDesignerHost));

                try {
                    tab = CreateTab(tabType, host);
                }
                catch (Exception e) {
                    Debug.Fail("Bad Tab.  We're not going to show it. ", e.ToString());
                    return;
                }

                // add it at the end of the array
                if (viewTabs != null) {
                    tabIndex = viewTabs.Length;

                    // find the insertion position...special case for event's and properties
                    if (tabType == DefaultTabType) {
                        tabIndex = PROPERTIES;
                    }
                    else if (typeof(EventsTab).IsAssignableFrom(tabType)) {
                        tabIndex = EVENTS;
                    }
                    else {
                        // order tabs alphabetically, we've always got a property tab, so
                        // start after that
                        for (int i = 1; i < viewTabs.Length; i++) {

                            // skip the event tab
                            if (viewTabs[i] is EventsTab) {
                                continue;
                            }

                            if (String.Compare(tab.TabName, viewTabs[i].TabName, false, CultureInfo.InvariantCulture) < 0) {
                                tabIndex = i;
                                break;
                            }
                        }
                    }
                }

                // now add the tab to the tabs array
                PropertyTab[] newTabs = new PropertyTab[viewTabs.Length + 1];
                Array.Copy(viewTabs, 0, newTabs, 0, tabIndex);
                Array.Copy(viewTabs, tabIndex, newTabs, tabIndex + 1, viewTabs.Length - tabIndex);
                newTabs[tabIndex] = tab;
                viewTabs = newTabs;

                viewTabsDirty = true;

                PropertyTabScope[] newTabScopes = new PropertyTabScope[viewTabScopes.Length + 1];
                Array.Copy(viewTabScopes, 0, newTabScopes, 0, tabIndex);
                Array.Copy(viewTabScopes, tabIndex, newTabScopes, tabIndex + 1, viewTabScopes.Length - tabIndex);
                newTabScopes[tabIndex] = type;
                viewTabScopes = newTabScopes;

                Debug.Assert(viewTabs != null, "Tab array destroyed!");
            }

            if (tab != null && component != null) {
                try {
                    Object[] tabComps = tab.Components;
                    int oldArraySize = tabComps == null ? 0 : tabComps.Length;

                    Object[] newComps = new Object[oldArraySize + 1];
                    if (oldArraySize > 0) {
                        Array.Copy(tabComps, newComps, oldArraySize);
                    }
                    newComps[oldArraySize] = component;
                    tab.Components = newComps;
                }
                catch (Exception e) {
                    Debug.Fail("Bad tab. We're going to remove it.", e.ToString());
                    RemoveTab(tabIndex, false);
                }
            }

            if (setupToolbar) {
                SetupToolbar();
                ShowEventsButton(false);
            }
        }

        private void CheckDesignerEventService() {
            if (GetFlag(GotDesignerEventService))
                return;
            IDesignerEventService eventService = (IDesignerEventService)GetService(typeof(IDesignerEventService));
            if (eventService != null) {
                SetFlag(GotDesignerEventService, true);
                eventService.ActiveDesignerChanged += new ActiveDesignerEventHandler(this.OnActiveDesignerChanged);
                OnActiveDesignerChanged(null, new ActiveDesignerEventArgs(null, eventService.ActiveDesigner));
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CollapseAllGridItems"]/*' />
        /// <devdoc> Collapses all the nodes in the PropertyGrid</devdoc>
        public void CollapseAllGridItems() {
            gridView.RecursivelyExpand(peMain, false, false, -1);
        }
          
        private void ClearCachedProps() {
            if (viewTabProps != null) {
               viewTabProps.Clear();                       
            }
        }  
        
        internal void ClearValueCaches() {
            if (peMain != null) {
               peMain.ClearCachedValues();
            }
        }


        /// <devdoc>
        /// Clears the tabs of the given scope or smaller.
        /// tabScope must be PropertyTabScope.Component or PropertyTabScope.Document.
        /// </devdoc>
        internal void ClearTabs(PropertyTabScope tabScope) {
            if (tabScope < PropertyTabScope.Document) {
                throw new ArgumentException(SR.GetString(SR.PropertyGridTabScope));
            }
            RemoveTabs(tabScope, true);
        }

        #if DEBUG
            internal bool inGridViewCreate = false;
        #endif

        private /*protected virtual*/ PropertyGridView CreateGridView(IServiceProvider sp) {
#if DEBUG
            try {
                    inGridViewCreate = true;
#endif
            return new PropertyGridView(sp, this);
#if DEBUG
            }
            finally {
                    inGridViewCreate = false;
            }   
#endif
        }

        private ToolBarButton CreateSeparatorButton() {
            ToolBarButton button = new ToolBarButton();
            button.Style = ToolBarButtonStyle.Separator;
            return button;
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.CreatePropertyTab"]/*' />
        protected virtual PropertyTab CreatePropertyTab(Type tabType) {
            return null; 
        }

        private PropertyTab CreateTab(Type tabType, IDesignerHost host) {
            PropertyTab tab = CreatePropertyTab(tabType);

            if (tab == null) {
                ConstructorInfo constructor = tabType.GetConstructor(new Type[] {typeof(IServiceProvider)});
                Object param = null;
                if (constructor == null) {
    
                    // try a IDesignerHost ctor
                    constructor = tabType.GetConstructor(new Type[] {typeof(IDesignerHost)});
    
                    if (constructor != null) {
                        param = host;
                    }
                }
                else {
                    param = this.Site;
                }
    
    
                if (param != null && constructor != null) {
                    tab = (PropertyTab) constructor.Invoke(new Object[] {param});
                }
                else {
                    // just call the default ctor
                    tab = (PropertyTab)Activator.CreateInstance(tabType);
                }
            }

            Debug.Assert(tab != null, "Failed to create tab!");

            if (tab != null) {
                // ensure it's a valid tab
                Bitmap bitmap = tab.Bitmap;
                
                if (bitmap == null)
                    throw new ArgumentException(SR.GetString(SR.PropertyGridNoBitmap, tab.GetType().FullName));

                Size size = bitmap.Size;
                if (size.Width != 16 || size.Height != 16) {
                    // resize it to 16x16 if it isn't already.
                    //
                    bitmap = new Bitmap(bitmap, new Size(16,16));
                }

                string name = tab.TabName;
                if (name == null || "".Equals(name))
                    throw new ArgumentException(SR.GetString(SR.PropertyGridTabName, tab.GetType().FullName));

                // we're good to go!
            }
            return tab;
        }


        private ToolBarButton CreateToggleButton(string toolTipText, int imageIndex, Object itemData) {
            ToolBarButton button = new ToolBarButton();
            button.ToolTipText = toolTipText;
            button.ImageIndex = imageIndex;
            button.Tag = itemData;
            button.Style = ToolBarButtonStyle.ToggleButton;
            return button;
        }

        private ToolBarButton CreatePushButton(string toolTipText, int imageIndex, Object itemData) {
            ToolBarButton button = new ToolBarButton();
            button.ToolTipText = toolTipText;
            button.ImageIndex = imageIndex;
            button.Tag = itemData;
            button.Style = ToolBarButtonStyle.PushButton;
            return button;
        }
        
        ///<internalonly/>        
        internal void DumpPropsToConsole() {
            gridView.DumpPropsToConsole(peMain, "");
        }

        private void DisplayHotCommands() {
            bool hotCommandsDisplayed = hotcommands.Visible;

            IComponent component = null;
            DesignerVerb[] verbs = null;

            // We favor the menu command service, since it can give us
            // verbs.  If we fail that, we will go straight to the
            // designer.
            //
            if (currentObjects != null && currentObjects.Length > 0) {
                for (int i = 0; i < currentObjects.Length; i++) {
                    object obj = GetUnwrappedObject(i);
                    if (obj is IComponent) {
                        component = (IComponent)obj;
                        break;
                    }
                }

                if (component != null) {
                    ISite site = component.Site;

                    if (site != null) {

                        IMenuCommandService mcs = (IMenuCommandService)site.GetService(typeof(IMenuCommandService));
                        if (mcs != null) {

                            // Got the menu command service.  Let it deal with the set of verbs for
                            // this component.
                            //
                            verbs = new DesignerVerb[mcs.Verbs.Count];
                            mcs.Verbs.CopyTo(verbs, 0);
                        }
                        else {

                            // No menu command service.  Go straight to the component's designer.  We
                            // can only do this if the Object count is 1, because desginers do not
                            // support verbs across a multi-selection.
                            //
                            if (currentObjects.Length == 1 && GetUnwrappedObject(0) is IComponent) {

                                IDesignerHost designerHost = (IDesignerHost) site.GetService(typeof(IDesignerHost));
                                if (designerHost != null) {
                                    IDesigner designer = designerHost.GetDesigner(component);
                                    if (designer != null) {
                                        verbs = new DesignerVerb[designer.Verbs.Count];
                                        designer.Verbs.CopyTo(verbs, 0);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (verbs != null && verbs.Length > 0) {
                hotcommands.SetVerbs(component, verbs);
            }
            else {
                hotcommands.SetVerbs(null, null);
            }

            if (hotCommandsDisplayed != hotcommands.Visible) {
                OnLayoutInternal(false);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {

                IDesignerEventService eventService = (IDesignerEventService)GetService(typeof(IDesignerEventService));
                if (eventService != null && GetFlag(GotDesignerEventService)) {
                        eventService.ActiveDesignerChanged -= new ActiveDesignerEventHandler(this.OnActiveDesignerChanged);
                }
                this.ActiveDesigner = null;

                if (viewTabs != null) {
                    for (int i = 0; i < viewTabs.Length; i++) {
                        viewTabs[i].Dispose();
                    }
                    viewTabs = null;
                }

                if (imageList != null) {
                    for (int i = 0; i < imageList.Length; i++) {
                        if(imageList[i] != null) {
                            imageList[i].Dispose();
                        }
                    }
                    imageList = null;
                }

                if (bmpAlpha != null) {
                    bmpAlpha.Dispose();
                    bmpAlpha = null;
                }
                
                if (bmpCategory != null) {
                    bmpCategory.Dispose();
                    bmpCategory = null;
                }
                
                if (bmpPropPage != null) {
                    bmpPropPage.Dispose();
                    bmpPropPage = null;
                }

                if (lineBrush != null) {
                    lineBrush.Dispose();
                    lineBrush = null;
                }
           
                if (peMain != null) {
                    peMain.Dispose();
                    peMain = null;
                }

                if (currentObjects != null) {
                    currentObjects = null;
                    SinkPropertyNotifyEvents();
                }

                ClearCachedProps();
                currentPropEntries = null;            
            base.Dispose(disposing);
        }

        private void DividerDraw(int y) {
            if (y == -1)
                return;

            Rectangle rectangle = gridView.Bounds;
            rectangle.Y = y-CYDIVIDER;
            rectangle.Height = CYDIVIDER;

            DrawXorBar(this,rectangle);
        }

        private SnappableControl DividerInside(int x, int y) {

            int useGrid = -1;

            if (hotcommands.Visible) {
                Point locDoc = hotcommands.Location;
                if (y >= (locDoc.Y - CYDIVIDER) &&
                    y <= (locDoc.Y + 1)) {
                    return hotcommands;
                }
                useGrid = 0;
            }

            if (doccomment.Visible) {
                Point locDoc = doccomment.Location;
                if (y >= (locDoc.Y - CYDIVIDER) &&
                    y <= (locDoc.Y+1)) {
                    return doccomment;
                }

                if (useGrid == -1) {
                    useGrid = 1;
                }
            }

            // also the bottom line of the grid
            if (useGrid != -1) {
                int gridTop = gridView.Location.Y;
                int gridBottom = gridTop + gridView.Size.Height;

                if (Math.Abs(gridBottom - y) <= 1 && y > gridTop) {
                    switch (useGrid) {
                        case 0:
                            return hotcommands;
                        case 1:
                            return doccomment;
                    }
                }
            }
            return null;
        }

        private int DividerLimitHigh(SnappableControl target) {
            int high = gridView.Location.Y + MIN_GRID_HEIGHT;
            if (target == doccomment && hotcommands.Visible)
                high += hotcommands.Size.Height + 2;
            return high;
        }

        private int DividerLimitMove(SnappableControl target, int y) {
            Rectangle rectTarget = target.Bounds;

            int cyNew = y;

            // make sure we're not going to make ourselves zero height -- make 15 the min size
            cyNew = Math.Min((rectTarget.Y + rectTarget.Height - 15),cyNew);

            // make sure we're not going to make ourselves cover up the gr