r = LdapMapErrorToWin32(dwErr);
            PrintMessage(SEV_ALWAYS,
                         L"[%s] LDAP bind failed with error %d. %s\n",
                         pDsInfo->pServers[i].pszName,
                         dwErr,
                         Win32ErrToString(dwErr));
            RetErr=dwErr;
            continue;
        }
        dwErr=FinddefaultNamingContext(targethLdap,&targetdefaultNamingContext);
        if ( dwErr != NO_ERROR )
        {
           RetErr=dwErr;
        }
        if(LimitToSite)
        {
            //if the server is in the same site as the target server then do the if
            if(pDsInfo->pServers[ulCurrTargetServer].iSite ==
               pDsInfo->pServers[i].iSite &&
               _wcsicmp(defaultNamingContext,
                        targetdefaultNamingContext) == 0)
            {
                dwErr=COSC_CheckOutboundTrusts(targethLdap,
                                               pDsInfo->pServers[i].pszName,
                                               Domain,
                                               defaultNamingContext,
                                               targetdefaultNamingContext,
                                               gpCreds);
                if(dwErr != NO_ERROR) 
                {
                    RetErr=dwErr;
                }
            }
        }
        else
        {
            if(_wcsicmp(defaultNamingContext,
                        targetdefaultNamingContext) == 0)
            {
                dwErr=COSC_CheckOutboundTrusts(targethLdap,
                                               pDsInfo->pServers[i].pszName,
                                               Domain,
                                               defaultNamingContext,
                                               targetdefaultNamingContext,
                                               gpCreds);
                if(dwErr != NO_ERROR) 
                {
                    RetErr=dwErr;
                }
            }
        }
        if(targetdefaultNamingContext)
            free(targetdefaultNamingContext);
    }

    cleanup:
    if(Domain)
        free(Domain);
    if(defaultNamingContext)
        free(defaultNamingContext);
    
    
    return RetErr;                         
}

DWORD 
COSC_CheckOutboundTrusts(
                    IN  LDAP                                *hLdap,
                    IN  WCHAR                               *ServerName,
                    IN  WCHAR                               *Domain,
                    IN  WCHAR                               *defaultNamingContext,
                    IN  WCHAR                               *targetdefaultNamingContext,
                    IN  SEC_WINNT_AUTH_IDENTITY_W *         gpCreds)
/*++

Routine Description:

    will display all domain that current domain has outbound trusts with
    Will check to see if domain has secure channels with all domains that
    it has an outbound trust with.  Will give reason why a secure channel is not present
    Will see if the trust is uplevel and if both a trust object and an interdomain trust
    object exists.  Helper functions of this function all begin with "COSC_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all tests checked out.
    A Win32 Error if any tests failed to check out.

--*/
{
    NTSTATUS                        Status;
    LSAPR_HANDLE                    PolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES           ObjectAttributes;
    LSA_UNICODE_STRING              ServerString;
    PLSA_UNICODE_STRING             Server;
    NETRESOURCE                     NetResource;
    //LSA_ENUMERATION_HANDLE          EnumerationContext=0;
    PTRUSTED_DOMAIN_INFORMATION_EX  Buffer=NULL;
    LSA_UNICODE_STRING              DomainString;
    PLSA_UNICODE_STRING             pDomain;
    //ULONG                           CountReturned=0;
    WCHAR                           *remotename = NULL;
    WCHAR                           *lpPassword = NULL;
    WCHAR                           *lpUsername = NULL;
    WCHAR                           *temp=NULL;
    DWORD                           dwErr=NO_ERROR,dwRet=NO_ERROR;
    DWORD                           i=0;
    
    #pragma prefast(disable: 255, "alloca can throw, but Prefast doesn't see the exception block in main.c::DcDiagRunTest")

    if(!gpCreds)
    {
        lpUsername=NULL;
        lpPassword=NULL;
    }
    else
    {
        lpUsername=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Domain)+wcslen(gpCreds->User)+2));
        wsprintf(lpUsername,L"%s\\%s",gpCreds->Domain,gpCreds->User);
        
        lpPassword=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Password)+1));
        wcscpy(lpPassword,gpCreds->Password);
    }

    remotename=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(L"\\\\\\ipc$")+wcslen(ServerName)+1));
    wsprintf(remotename,L"\\\\%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    dwErr=WNetAddConnection2(&NetResource,
                             lpPassword,
                             lpUsername,
                             0);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Remote ipc to [%s]:failed with %d: %s\n",
                     ServerName,
                     dwErr,
                     Win32ErrToString(dwErr));
        remotename = NULL;
        goto cleanup;
    }

    //test secure channel with netlogon api
    dwErr=COT_CheckSercureChannel(ServerName,Domain);
    if ( dwErr != NO_ERROR )
    {
        dwRet=dwErr;
    }

    //look for the uplevel and downlevel trusts
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));



    if ( ServerName != NULL )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        DInitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    } else
    {
        Server = NULL; // default to local machine
    }

    // Open a Policy
    Status = LsaOpenPolicy(
                          Server,
                          &ObjectAttributes,
                          TRUSTED_READ,
                          &PolicyHandle
                          );
    //Assert(PolicyHandle);
    if ( !NT_SUCCESS(Status) )
    {
        dwErr = RtlNtStatusToDosError(Status);
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Lsa Policy to [%s] : %s\n",
                     ServerName,
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        goto cleanup;
    }

    
       
    DInitLsaString(&DomainString, Domain);
    pDomain = &DomainString;
                        
    
    Status=LsaQueryTrustedDomainInfoByName(
                                PolicyHandle,
                                pDomain,
                                TrustedDomainInformationEx,
                                &Buffer
                                );
    if ( !NT_SUCCESS(Status) )
    {
        dwErr = RtlNtStatusToDosError(Status);
        //wprintf(L"\n%x",Status);
        PrintMessage(SEV_ALWAYS,
                     L"Could not Query Trusted Domain :%s\n",
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        goto cleanup;
    }
    
    if((Buffer->TrustDirection&TRUST_TYPE_UPLEVEL) == TRUST_TYPE_UPLEVEL)
    {
        dwErr=COT_FindDownLevelTrustObjects(hLdap,
                                   ServerName,
                                   Domain,
                                   defaultNamingContext);
        dwRet=dwErr;
        dwErr=COT_FindUpLevelTrustObjects(hLdap,
                                   ServerName,
                                   Domain,
                                   defaultNamingContext,
                                   targetdefaultNamingContext);
        if ( dwErr != NO_ERROR )
        {
            dwRet=dwErr;
            goto cleanup;
        }
    }


    //cleanup
cleanup:
    if ( Buffer )
    {
        LsaFreeMemory(Buffer);
    }
    if ( PolicyHandle )
    {
            Status = LsaClose( PolicyHandle );
            Assert( NT_SUCCESS(Status) );
    }
    if( remotename )
        WNetCancelConnection2(remotename,
                              0,
                              TRUE);
    

    return dwRet;
}


DWORD
COT_CheckSercureChannel(
                     WCHAR *                             server,
                     WCHAR *                             domain
                     )
/*++

Routine Description:

    will check to see if there is a secure channel between the 
    server and the domain
    
Arguments:

    server - The name of the server that we will check
    domain - the domain we will be check to see if we have a 
             secure channel to.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    DWORD dwErr=NO_ERROR;
    PNETLOGON_INFO_2 Buffer=NULL;
    LPBYTE bDomain=NULL;

    bDomain=(LPBYTE)domain;

    dwErr=I_NetLogonControl2(server,
                             NETLOGON_CONTROL_REDISCOVER,
                             2,
                             (LPBYTE)&bDomain,
                             (LPBYTE*)&Buffer);
    if(NO_ERROR!=dwErr)
    {
        PrintMessage(SEV_ALWAYS,
                         L"Could not Check secure channel from %s to %s: %s\n",
                         server,
                         domain,
                         Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
    }
    else if(Buffer->netlog2_tc_connection_status != NO_ERROR)
    {
        PrintMessage(SEV_ALWAYS,
                         L"Error with Secure channel from [%s] to [%s] :%s\n",
                         server,
                         Buffer->netlog2_trusted_dc_name,
                         Win32ErrToString(Buffer->netlog2_tc_connection_status));
        dwErr=Buffer->netlog2_tc_connection_status;
    }
    else
    {
        PrintMessage(SEV_VERBOSE,
                         L"* Secure channel from [%s] to [%s] is working properly.\n",
                         server,
                         Buffer->netlog2_trusted_dc_name);
    }

    
    return dwErr;

}

DWORD
COT_FindDownLevelTrustObjects(
              LDAP                                  *hLdap,
              WCHAR                                 *ServerName,
              WCHAR                                 *DomainName,
              WCHAR                                 *defaultNamingContext
              )
/*++

Routine Description:

    will check to see if there is a downlevel trust object in the DS
    
Arguments:

    hLdap - handle to the ldap server
    ServerName - the name of the server that you are check
    DomainName - the name of the domain used to build the filter
    defaultNamingContext - used as the base of the search


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *filter=NULL;
    
    DWORD        WinError=NO_ERROR;

    DWORD        userAccountControl=0;

    ULONG        Length;
    BOOL         hasDownLevel=FALSE;


    Assert(hLdap);
    Assert(ServerName);
    Assert(DomainName);
    Assert(defaultNamingContext);
    
    AttrsToSearch[0] = L"userAccountControl";
    AttrsToSearch[1] = NULL;


    //build the filter
    Length = wcslen( L"sAMAccountName=$" ) +
             wcslen( DomainName );
             
    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s$",DomainName);

    LdapError = ldap_search_sW( hLdap,
                                defaultNamingContext,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        userAccountControl=_wtoi(Values[0]);
                        //check to see if the UF_TRUSTED_FOR_DELEGATION is set
                        if (  !((userAccountControl & UF_INTERDOMAIN_TRUST_ACCOUNT)  == 
                               UF_INTERDOMAIN_TRUST_ACCOUNT) )
                        {
                            PrintMessage(SEV_VERBOSE,
                                         L"* [%s] has downlevel trust object for [%s]\n",
                                         ServerName,
                                         DomainName);
                            hasDownLevel=TRUE;
                            goto cleanup;
                        }
                        else
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"[%s] Does not have UF_INTERDOMAIN_TRUST_ACCOUNT set on downlevel trust object for [%s]\n",
                                         ServerName,
                                         DomainName);
                            WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
                            goto cleanup;
                        }
                    }
                }
            }
        }
    }

    cleanup:
    if(!hasDownLevel)
    {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] Does not have downlevel trust object for [%s]\n",
                     ServerName,
                     DomainName);
        WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
    }


    
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    return WinError;
}

DWORD
COT_FindUpLevelTrustObjects(
              LDAP                                  *hLdap,
              WCHAR                                 *ServerName,
              WCHAR                                 *DomainName,
              WCHAR                                 *defaultNamingContext,
              WCHAR                                 *targetdefaultNamingContext
              )
/*++

Routine Description:

    will check to see if there is a secure channel between the 
    server and the domain
    
Arguments:

    hLdap - handle to the ldap server
    domain - the domain we will be check to see if we have a 
             secure channel to.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *Base=NULL;
    WCHAR        *filter=NULL;
    WCHAR        *schemaNamingContext=NULL;
    WCHAR        *objectCategory=NULL;

    DWORD        WinError=NO_ERROR;

    DWORD        userAccountControl=0;

    ULONG        Length;
    BOOL         hasUpLevel=FALSE;


    Assert(hLdap);
    Assert(ServerName);
    Assert(DomainName);
    Assert(defaultNamingContext);
    Assert(targetdefaultNamingContext);

    WinError=FindschemaNamingContext(hLdap,&schemaNamingContext);
    if(WinError != NO_ERROR)
    {
        goto cleanup;
    }

    
    AttrsToSearch[0] = L"LDAPDisplayName";
    AttrsToSearch[1] = NULL;

    filter=L"objectClass=*";

    //build the base
    Length = wcslen( L"CN=Trusted-Domain," ) +
             wcslen( schemaNamingContext );
             
    Base=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(Base,L"CN=Trusted-Domain,%s",schemaNamingContext);

    //find the ObjectCategory for trusted domains
    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        #pragma prefast(suppress: 263, "Using alloca in a loop; this is a small loop and these are small allocations")
                        objectCategory = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy( objectCategory, Values[0] );    
                    }
                }
            }
        }
    }
    if(!objectCategory)
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not find objectCatagory for Trusted Domains");
        WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
        goto cleanup;
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
        SearchResult=NULL;
    }

    AttrsToSearch[0] = NULL;

    //build the base
    Length = wcslen( L"CN=System," ) +
             wcslen( targetdefaultNamingContext );
             
    Base=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(Base,L"CN=System,%s",targetdefaultNamingContext);

    //build the filter
    Length = wcslen( L"(&(flatName=)(objectCategory=))" ) +
             wcslen( DomainName ) +
             wcslen( objectCategory );
             
    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"(&(flatName=%s)(objectCategory=%s))",DomainName,objectCategory);


    //find the ObjectCategory for trusted domains
    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                NULL,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                //
                // Found it - these are NULL-terminated strings
                //
                PrintMessage(SEV_VERBOSE,
                             L"* [%s] has uplevel trust object for [%s]\n",
                             ServerName,
                             DomainName);
                hasUpLevel=TRUE;
                goto cleanup;
                
            }
        }
    }



    cleanup:
    if(!hasUpLevel)
    {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] Does not have uplevel trust object for [%s]\n",
                     ServerName,
                     DomainName);
        WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
    }

    
    if(schemaNamingContext)
        free(schemaNamingContext);
    
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\frs\frsevent.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    frs\frsevent.c

ABSTRACT:

    Check the File Replication System (frs) eventlog to see that certain 
    critical events have occured and to signal that any fatal events that 
    might have occured.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

#include <ntdspch.h>
#include <netevent.h>

#include "dcdiag.h"
#include "utils.h"

// Notes on some FRS events.
//  EVENT_FRS_SYSVOL_READY 0x400034CC
//  EVENT_FRS_STARTING
//  EVENT_FRS_ERROR 0xC00034BC
//  EVENT_FRS_SYSVOL_NOT_READY_PRIMARY 0x800034CB
//  EVENT_FRS_SYSVOL_NOT_READY 0x800034CA

#define PrintMessage             This_file_is_PrintMessage_clean_please_use_msg_dot_mc_file_and_PrintMsg

#define LOGFILENAME              L"File Replication Service"

VOID
FileReplicationEventlogPrint(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This function will be called by the event tests library common\events.c,
    whenever an event of interest comes up.  An event of interest for this
    test is any error or the warnings EVENT_FRS_SYSVOL_NOT_READY and 
    EVENT_FRS_SYSVOL_NOT_READY_PRIMARY.

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    Assert((pEvent != NULL) && (pvContext != NULL));

    if(! *((BOOL *)pvContext) ){
        PrintMsg(SEV_ALWAYS, DCDIAG_FRSEVENTS_WARNING_OR_ERRORS);
        * ((BOOL *)pvContext) = TRUE;
    }
    
    if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            GenericPrintEvent(LOGFILENAME, pEvent, TRUE);
    }
}


DWORD
CheckFileReplicationEventlogMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

ERoutine Description:

    This checks that the SYSVOL has started, and is allowing netlogon to 
    advertise this machine as a DC.  First it checks the registry failing
    this, it checks the eventlog.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    // Setup variables for PrintSelectEvents
    DWORD                paEmptyEvents [] = { 0 };
    DWORD                paBegin [] = 
        { EVENT_FRS_STARTING,
          EVENT_FRS_SYSVOL_READY,
          0 };
    DWORD                dwRet;
    DWORD                dwTimeLimit;
    DWORD                bFrsEventTestErrors = FALSE;

    PrintMsg(SEV_VERBOSE, DCDIAG_FRSEVENT_TEST_BANNER);

    // We only want events from the last 24 hours, because FRS re-logs 
    // events every 24 hours, if the problem or error condition persists.
    time( (time_t *) &dwTimeLimit  );
    dwTimeLimit -= (24 * 60 * 60);

    dwRet = PrintSelectEvents(&(pDsInfo->pServers[ulCurrTargetServer]),
                                  pDsInfo->gpCreds,
                                  LOGFILENAME,
                                  EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE,
                                  paEmptyEvents,
                                  paBegin,
                                  dwTimeLimit,
                                  FileReplicationEventlogPrint,
                                  NULL,
                                  &bFrsEventTestErrors );

    return( dwRet ? dwRet : (bFrsEventTestErrors ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS) );
}


DWORD
CheckSysVolReadyMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

ERoutine Description:

    This checks that the SYSVOL has started, and is allowing netlogon to 
    advertise this machine as a DC.  It does this by checking the sysvol
    ready key in the registry.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    DWORD                dwRet;
    DWORD                bSysVolReady = FALSE;

    PrintMsg(SEV_VERBOSE, DCDIAG_SYSVOLREADY_TEST_BANNER);

    // Note: This returns ERROR_FILE_NOT_FOUND when there is no SysvolReady reg key.
    dwRet = GetRegistryDword(&(pDsInfo->pServers[ulCurrTargetServer]),
                             gpCreds,
                             L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                             L"SysvolReady",
                             &bSysVolReady);

    if(dwRet == ERROR_SUCCESS && bSysVolReady){
        // The sysvol is ready according to the registry.
        PrintMsg(SEV_VERBOSE, DCDIAG_SYSVOLREADY_SYSVOL_READY);
    } else {
        // Either the registry couldn't be contacted or the registry said
        //   that the SYSVOL was not up.  So check the evenlog for errors
        //   and specific warnings.

        if(dwRet != ERROR_FILE_NOT_FOUND){  
            PrintMsg(SEV_VERBOSE, DCDIAG_SYSVOLREADY_REGISTRY_ERROR, 
                     dwRet, Win32ErrToString(dwRet));
        } else {
            dwRet = ERROR_FILE_NOT_FOUND; // dwRet might be 0
            PrintMsg(SEV_ALWAYS, DCDIAG_SYSVOLREADY_SYSVOL_NOT_READY);
        }
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\frs\frsref.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag/frs/frsref.c

ABSTRACT:

    This is the first use of dcdiag's refences API (in dcdiag/common/references.c)
    This tests that the linkage to the Server object and the FRS System volume
    object remain current and in tact.

DETAILS:

CREATED:

    11/15/2001    Brett Shirley (brettsh)
    
        Created the frsref test.

REVISION HISTORY:


--*/

#include <ntdspch.h>
#include <objids.h>

#include "dcdiag.h"
#include "references.h"
#include "utils.h"
#include "ldaputil.h"
#include "dsutil.h"

#ifdef DBG
extern BOOL  gDsInfo_NcList_Initialized;
#endif

#define VERIFY_PHASE_I   (1)
#define VERIFY_PHASE_II  (2)

#define VERIFY_DSAS      (1)
#define VERIFY_DCS       (2)
#define VERIFY_FRS       (3)
#define VERIFY_CRS       (4)

void
VerifyPrintFirstError(
    ULONG            ulPhase,
    LPWSTR           szObj,
    BOOL *           pfPrintedError
    );
                        
DWORD
ReadWellKnownObject (
        LDAP  *ld,
        WCHAR *pHostObject,
        WCHAR *pWellKnownGuid,
        WCHAR **ppObjName
        );

DWORD
GetSysVolBase(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iServer,
    LDAP *                           hLdap,
    LPWSTR                           szDomain,
    LPWSTR *                         pszSysVolBaseDn
    );

DWORD
VerifySystemObjs(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iServer,
    LDAP *                           hLdap,
    DWORD                            dwTest,
    BOOL *                           pfPrintedError,
    ULONG *                          piProblem
    );

DWORD
VerifySystemReferences(
    PDC_DIAG_DSINFO               pDsInfo,
    ULONG                         iServer,
    SEC_WINNT_AUTH_IDENTITY_W *   gpCreds
    )
/*++

Routine Description:

    Routine is a test to check whether certain DN references are
    pointing to where they should be pointing.
    
Arguments:

    ServerName - The name of the server that we will check
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    REF_INT_LNK_ENTRY   aFrsTable [] = {

        // 
        // Basically to prime the table.
        // 
        {REF_INT_TEST_SRC_BASE | REF_INT_TEST_FORWARD_LINK,
            NULL, 0, 0, NULL,
            L"dsServiceName", NULL,
            0, NULL, NULL},
        {REF_INT_TEST_SRC_BASE | REF_INT_TEST_FORWARD_LINK,
            NULL, 0, 0, NULL,
            L"serverName", NULL,
            0, NULL, NULL},
    
        //
        // Check links to the DC Account Object from the Server Object and back
        //
#define FRS_TABLE_SERVER_OBJ_TO_DC_ACCOUNT_OBJ  (2)
        {REF_INT_TEST_SRC_INDEX | REF_INT_TEST_FORWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL, 1, 0, NULL,
            L"serverReference", L"serverReferenceBL",
            0, NULL, NULL},

        //
        // Check links to the FRS SysVol Computer Object from the DC Account Object and back (intra-NC should always succed)
        //
#define FRS_TABLE_DC_ACCOUNT_OBJ_TO_FRS_SYSVOL_OBJ  (3)
        {REF_INT_TEST_SRC_INDEX | REF_INT_TEST_FORWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL, 2, 0, NULL,
            L"frsComputerReferenceBL", L"frsComputerReference",
            0, NULL, NULL},

        //
        // Check links to the FRS SysVol Computer Object from the NTDS Settings Object and back.
        //
#define FRS_TABLE_DSA_OBJ_TO_FRS_SYSVOL_OBJ  (4)
        {REF_INT_TEST_SRC_INDEX | REF_INT_TEST_FORWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL, 0, 0, NULL,
            L"serverReferenceBL", L"serverReference", 
            0, NULL, NULL},

    };
    ULONG    cFrsTable = sizeof(aFrsTable) / sizeof(REF_INT_LNK_ENTRY);
    ULONG    dwRet, dwFirstErr;
    LDAP *   hLdap = NULL;
    ULONG    iEntry, iValue;
    LPWSTR   szOriginalDn;
    BOOL     fPrintedError = TRUE;
    ULONG    iProblem = 1;
    ULONG    dwPrintMsg = 0;
    DC_DIAG_SERVERINFO * pServer = &(pDsInfo->pServers[iServer]);

    //
    // Get binding.
    //
    dwRet = DcDiagGetLdapBinding(pServer,
                                 gpCreds,
                                 FALSE, 
                                 &hLdap);
    if (dwRet || hLdap == NULL) {
        Assert(dwRet);
        return(dwRet);
    }

    //
    // Get data.
    //
    dwRet = ReferentialIntegrityEngine(pServer, 
                                       hLdap, 
                                       pServer->bIsGlobalCatalogReady, 
                                       cFrsTable,
                                       aFrsTable);
    if (dwRet ||
        aFrsTable[0].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING ||
        aFrsTable[1].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
        // Critical error.
        if (dwRet) {
            dwRet = ERROR_DS_MISSING_EXPECTED_ATT;
        }
        DcDiagException(dwRet);
    }

    //
    // Analyze data
    //

    dwFirstErr = ERROR_SUCCESS;

    fPrintedError = FALSE;
    for (iEntry = FRS_TABLE_SERVER_OBJ_TO_DC_ACCOUNT_OBJ; iEntry < cFrsTable; iEntry++) {

        if (aFrsTable[iEntry].dwResultFlags & REF_INT_RES_DEPENDENCY_FAILURE) {
            // There is nothing we can do here, and a previous reference reported
            // an error.
            continue;
        }

        szOriginalDn = aFrsTable[aFrsTable[iEntry].iSource].pszValues[0];

        if (aFrsTable[iEntry].dwResultFlags == 0) {
            PrintMsg(SEV_VERBOSE, DCDIAG_SYS_REF_VALUE_CHECKED_OUT,
                      aFrsTable[iEntry].szFwdDnAttr, 
                      aFrsTable[iEntry].pszValues[0],
                      szOriginalDn);
            continue;
        }

        if (aFrsTable[iEntry].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
            VerifyPrintFirstError(VERIFY_PHASE_I, pServer->pszName, &fPrintedError);
            switch (iEntry) {
            case FRS_TABLE_SERVER_OBJ_TO_DC_ACCOUNT_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_SERVER_OBJ_MISSING_DC_ACCOUNT_REF;
                break;
            case FRS_TABLE_DC_ACCOUNT_OBJ_TO_FRS_SYSVOL_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_DC_ACCOUNT_OBJ_MISSING_FRS_MEMBER_BL_REF;
                break;
            case FRS_TABLE_DSA_OBJ_TO_FRS_SYSVOL_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_DSA_OBJ_MISSING_FRS_MEMBER_BL_REF;
                break;
            default:
                Assert(!"Huh");
            }
            PrintMsg(SEV_ALWAYS,
                     dwPrintMsg,
                     iProblem,
                     aFrsTable[aFrsTable[iEntry].iSource].pszValues[0],
                     aFrsTable[iEntry].szFwdDnAttr);
            dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
            // With this kind of error, we can't/don't need to check for the
            // other errors.
            continue;
        }
        Assert(aFrsTable[iEntry].pszValues[0]);
                            
        if (aFrsTable[iEntry].dwResultFlags & REF_INT_RES_DELETE_MANGLED) {

            VerifyPrintFirstError(VERIFY_PHASE_I, pServer->pszName, &fPrintedError);
            switch (iEntry) {
            case FRS_TABLE_SERVER_OBJ_TO_DC_ACCOUNT_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_SERVER_OBJ_HAS_MANGLED_DC_ACCOUNT_REF;
                break;
            case FRS_TABLE_DC_ACCOUNT_OBJ_TO_FRS_SYSVOL_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_DC_ACCOUNT_OBJ_HAS_MANGLED_FRS_MEMBER_REF;
                break;
            case FRS_TABLE_DSA_OBJ_TO_FRS_SYSVOL_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_DSA_OBJ_HAS_MANGLED_FRS_MEMBER_REF;
                break;
            default:
                Assert(!"Huh");
            }
            PrintMsg(SEV_ALWAYS, DCDIAG_SYS_REF_ERR_DELETE_MANGLED_PROB, iProblem);
            PrintMsg(SEV_ALWAYS, 
                     dwPrintMsg,
                     aFrsTable[aFrsTable[iEntry].iSource].pszValues[0],
                     aFrsTable[iEntry].szFwdDnAttr,
                     aFrsTable[iEntry].pszValues[0]);

            dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
        }

        if (aFrsTable[iEntry].dwResultFlags & REF_INT_RES_CONFLICT_MANGLED) {

            VerifyPrintFirstError(VERIFY_PHASE_I, pServer->pszName, &fPrintedError);
            switch (iEntry) {
            case FRS_TABLE_SERVER_OBJ_TO_DC_ACCOUNT_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_SERVER_OBJ_HAS_MANGLED_DC_ACCOUNT_REF;
                break;
            case FRS_TABLE_DC_ACCOUNT_OBJ_TO_FRS_SYSVOL_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_DC_ACCOUNT_OBJ_HAS_MANGLED_FRS_MEMBER_REF;
                break;
            case FRS_TABLE_DSA_OBJ_TO_FRS_SYSVOL_OBJ:
                dwPrintMsg = DCDIAG_SYS_REF_ERR_DSA_OBJ_HAS_MANGLED_FRS_MEMBER_REF;
                break;
            default:
                Assert(!"Huh");
            }
            PrintMsg(SEV_ALWAYS, DCDIAG_SYS_REF_ERR_CONFLICT_MANGLED_PROB, iProblem);
            PrintMsg(SEV_ALWAYS, 
                     dwPrintMsg,
                     aFrsTable[aFrsTable[iEntry].iSource].pszValues[0],
                     aFrsTable[iEntry].szFwdDnAttr,
                     aFrsTable[iEntry].pszValues[0]);

            dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
        }

        if (aFrsTable[iEntry].dwResultFlags & REF_INT_RES_BACK_LINK_NOT_MATCHED) {
            VerifyPrintFirstError(VERIFY_PHASE_I, pServer->pszName, &fPrintedError);
            PrintMsg(SEV_ALWAYS, DCDIAG_SYS_REF_ERR_BACK_LINK_NOT_MATCHED,
                     aFrsTable[iEntry].szFwdDnAttr,
                     szOriginalDn);
            dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
        }
    }
    if (fPrintedError) {
        PrintIndentAdj(-1);
    }

    return(dwFirstErr);
}

DWORD
VerifyEnterpriseSystemReferences(
    PDC_DIAG_DSINFO               pDsInfo,
    ULONG                         iServer,
    SEC_WINNT_AUTH_IDENTITY_W *   gpCreds
    )
/*++

Routine Description:

    Routine is a test to check whether certain DN references are
    pointing to where they should be pointing.
    
Arguments:

    ServerName - The name of the server that we will check
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    ULONG    dwRet, dwFirstErr;
    LDAP *   hLdap = NULL;
    BOOL     fPrintedError = TRUE;
    ULONG    iProblem = 1;
    ULONG    dwPrintMsg;

    //
    // Get binding.
    //
    dwRet = DcDiagGetLdapBinding(&(pDsInfo->pServers[iServer]),
                                 gpCreds,
                                 FALSE, 
                                 &hLdap);
    if (dwRet || hLdap == NULL) {
        Assert(dwRet);
        return(dwRet);
    }

    //
    // Check other servers' references
    //

    fPrintedError = FALSE;
    dwFirstErr = ERROR_SUCCESS;
    
    // For each of these calls we don't need to bail, they except if we need 
    // to bail.  They print the appropriate advice/error for us as well.
    dwRet = VerifySystemObjs(pDsInfo, iServer, hLdap, VERIFY_DSAS, &fPrintedError, &iProblem);
    if (dwFirstErr == ERROR_SUCCESS && dwRet) {
        dwFirstErr = dwRet;
    }
    dwRet = VerifySystemObjs(pDsInfo, iServer, hLdap, VERIFY_DCS, &fPrintedError, &iProblem);
    if (dwFirstErr == ERROR_SUCCESS && dwRet) {
        dwFirstErr = dwRet;
    }
    dwRet = VerifySystemObjs(pDsInfo, iServer, hLdap, VERIFY_FRS, &fPrintedError, &iProblem);
    if (dwFirstErr == ERROR_SUCCESS && dwRet) {
        dwFirstErr = dwRet;
    }

    dwRet = VerifySystemObjs(pDsInfo, iServer, hLdap, VERIFY_CRS, &fPrintedError, &iProblem);
    if (dwFirstErr == ERROR_SUCCESS && dwRet) {
        dwFirstErr = dwRet;
    }

    if (fPrintedError) {
        PrintIndentAdj(-1);
        fPrintedError = FALSE;
    }

    return(dwFirstErr);
}

DWORD
VerifyOldCrossRef(
    PDC_DIAG_DSINFO  pDsInfo, 
    ULONG            iNc,
    BOOL *           pfIsOldCrossRef
    )
/*++

Routine Description:

    This routine tells the caller whether the cross-ref corresponding to
    NC name is older than 2 days old.
    
Arguments
    
    pDsInfo (IN/OUT) -
    pszNcName (IN) - NC name of cross-ref we're interested in.
    pfIsOldCrossRef (OUT) - Whether cross-ref is older than 2 days old.
                                                                      
Return Values:

    LDAP Error, if error fIsOldCrossRef is not valid, otherwise it is.
    
--*/    
{
    #define          DAY     (24 * 60 *60 * ((LONGLONG) (10 * 1000 * 1000L)))
    BOOL             bSingleServer;
    DWORD            dwFlags, dwError, dwRet;
    ULONG            iCr;

    Assert(pfIsOldCrossRef);
    *pfIsOldCrossRef = TRUE; // Safer to claim it's old.

    bSingleServer = !((pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE)
                      || (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE));

    dwFlags = CRINFO_RETRIEVE_IF_NEC;
    if (bSingleServer){
        dwFlags |= CRINFO_SOURCE_HOME;
    } else {
        dwFlags |= CRINFO_SOURCE_AUTHORITATIVE;
    }
    dwFlags |= CRINFO_DATA_BASIC | CRINFO_DATA_EXTENDED;

    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNc,
                                  dwFlags,
                                  &iCr,
                                  &dwError);

    if(dwRet){       
        // Don't print just quit with an error.
        return(ERROR_DS_NO_SUCH_OBJECT);
    }
    
    *pfIsOldCrossRef = fIsOldCrossRef(&(pDsInfo->pNCs[iNc].aCrInfo[iCr]), 
                                      2 * DAY);

    return(dwRet);
    #undef DAY
}


void
VerifyPrintFirstError(
    ULONG            ulPhase,
    LPWSTR           szObj,
    BOOL *           pfPrintedError
    )
/*++

Routine Description:

    This routine simply centralizes the printing of this one warning,
    and indenting.
    
Arguments
    
    pfPrintedError - IN/OUT Whether or not we've printed and error already.
    
--*/    
{
    Assert(pfPrintedError);

    if (*pfPrintedError) {
        return;
    }
    *pfPrintedError = TRUE;

    if (ulPhase == VERIFY_PHASE_II) {
        PrintMsg(SEV_ALWAYS, DCDIAG_SYS_REF_ERR_PRINT_FIRST);
    } else {
        Assert(ulPhase == VERIFY_PHASE_I);
        PrintMsg(SEV_ALWAYS, DCDIAG_SYS_REF_ERR_OBJ_PROB, szObj);
    }
    PrintIndentAdj(1);
}
                        
DWORD
ReadWellKnownObject (
        LDAP  *ld,
        WCHAR *pHostObject,
        WCHAR *pWellKnownGuid,
        WCHAR **ppObjName
        )
/*++

Routine Description:
    
    Does the special well known GUID type search "<WKGUID=guid,dn>", to find 
    well know attributes.
    
    NOTE: This routine was basically taken from util\tapicfg which was 
    basically taken from util\ntdsutil

Arguments:

    ld - LDAP handle
    pHostObject - Object wellKnownObjects attribute exists on.
    pWellKnownGuid - GUID to match in the wellKnownObjects attribute
    ppObjName - DN value matching the pWellKnownGuid, use ldap_memfreeW() to
        free this value.

Return Value:

    LDAP Error.

--*/
{
    DWORD        dwErr;
    PWSTR        attrs[2];
    PLDAPMessage res = NULL;
    PLDAPMessage e;
    WCHAR       *pSearchBase;
    WCHAR       *pDN=NULL;
    
    // First, make the well known guid string
    pSearchBase = (WCHAR *)malloc(sizeof(WCHAR) * (11 +
                                                   wcslen(pHostObject) +
                                                   wcslen(pWellKnownGuid)));
    if(!pSearchBase) {
        return(LDAP_NO_MEMORY);
    }
    wsprintfW(pSearchBase,L"<WKGUID=%s,%s>",pWellKnownGuid,pHostObject);

    attrs[0] = L"1.1";
    attrs[1] = NULL;
    
    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
            ld,
            pSearchBase,
            LDAP_SCOPE_BASE,
            L"(objectClass=*)",
            attrs,
            0,
            &res)) )
    {
        free(pSearchBase);
        if (res) { ldap_msgfree(res); }
        return(dwErr);
    }
    free(pSearchBase);
    
    // OK, now, get the dsname from the return value.
    e = ldap_first_entry(ld, res);
    if(!e) {
        if (res) { ldap_msgfree(res); }
        return(LDAP_NO_SUCH_ATTRIBUTE);
    }
    pDN = ldap_get_dnW(ld, e);
    if(!pDN) {
        if (res) { ldap_msgfree(res); }
        return(LDAP_NO_SUCH_ATTRIBUTE);
    }

    *ppObjName = pDN;
    
    ldap_msgfree(res);
    return 0;
}



DWORD
GetSysVolBase(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iServer,
    LDAP *                           hLdap,
    LPWSTR                           szDomain,
    LPWSTR *                         pszSysVolBaseDn
    )
/*++

Routine Description:

    This gets the DN of the base DN of the SysVol replica set for the given
    domain.

Arguments:

    pDsInfo - Contains the pServers array to create.
    iServer - Index of the server to test.
    hLdap - the ldap binding to server to analyze.
    szDomain - The domain to find the SysVol replica set for.
    pszSysVolBaseDn - The DN that we're looking for.  Note that this memory
        must be freed with ldap_memfreeW().

Return Value:

    LDAP Error.

--*/
{
    DWORD                            dwRet;
    LPWSTR                           szSystemDn = NULL;
    WCHAR                            szPrefix [] = L"CN=File Replication Service,";
    ULONG                            cbSizeP1;
    ULONG                            cbSizeP2;
    LPWSTR                           szFrsBaseDn = NULL;
    LDAPMessage *                    pldmResults = NULL;
    LDAPMessage *                    pldmEntry;
    LPWSTR                           aszAttrs [] = {
        L"distinguishedName",
        NULL
    };
    LPWSTR                           szLdapError;

    Assert(pszSysVolBaseDn);
    *pszSysVolBaseDn = NULL;

    dwRet = ReadWellKnownObject(hLdap, szDomain, GUID_SYSTEMS_CONTAINER_W, &szSystemDn);
    if (dwRet || szSystemDn == NULL) {
        Assert(dwRet && szSystemDn == NULL);
        return(dwRet);
    }

    __try {
        cbSizeP1 = wcslen(szPrefix) * sizeof(WCHAR);
        cbSizeP2 = wcslen(szSystemDn) * sizeof(WCHAR);
        szFrsBaseDn = (LPWSTR) LocalAlloc(LMEM_FIXED, cbSizeP1 + cbSizeP2 + sizeof(WCHAR));
        DcDiagChkNull(szFrsBaseDn);

        memcpy(szFrsBaseDn, szPrefix, cbSizeP1);
        memcpy(&((szFrsBaseDn)[cbSizeP1/sizeof(WCHAR)]), szSystemDn, cbSizeP2);
        (szFrsBaseDn)[ (cbSizeP1 + cbSizeP2) / sizeof(WCHAR) ] = L'\0';
    } __finally {
        ldap_memfreeW(szSystemDn);
        szSystemDn = NULL;
    }
    
    dwRet = ldap_search_sW(hLdap,
                           szFrsBaseDn,
                           LDAP_SCOPE_ONELEVEL,
                           L"(&(objectCategory=nTFRSReplicaSet)(fRSReplicaSetType=2))",
                           aszAttrs,
                           FALSE,
                           &pldmResults);
    // Don't need this anymore, so lets free it before checking our error.
    LocalFree(szFrsBaseDn); 
    szFrsBaseDn = NULL;
    if (dwRet || pldmResults == NULL) {
        Assert(dwRet);
        szLdapError = ldap_err2stringW(dwRet);
        PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GENERIC_FATAL_LDAP_ERROR, dwRet, szLdapError);
        if (pldmResults) { ldap_msgfree(pldmResults); }
        return(dwRet);
    }

    pldmEntry = ldap_first_entry(hLdap, pldmResults);
    if (pldmEntry) {

        *pszSysVolBaseDn = ldap_get_dnW(hLdap, pldmEntry);
        if (*pszSysVolBaseDn == NULL) {
            dwRet = LdapGetLastError();
            if (dwRet == LDAP_SUCCESS) {
                Assert(!"I don't think this can happen");
                dwRet = LDAP_NO_SUCH_ATTRIBUTE;
            }
            szLdapError = ldap_err2stringW(dwRet);
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GENERIC_FATAL_LDAP_ERROR, dwRet, szLdapError);
            if (pldmResults) { ldap_msgfree(pldmResults); }
            return(dwRet);
        }

        //
        // Check that there is no 2nd SysVol Replicat set for sanity.
        //
        pldmEntry = ldap_next_entry(hLdap, pldmEntry);
        if (pldmEntry) {
            // This means there are two SYSVOL Replica Sets!!!
            PrintMsg(SEV_ALWAYS, DCDIAG_SYS_REF_ERR_TWO_SYSVOL_REPLICA_SETS);
            if (*pszSysVolBaseDn) { ldap_memfreeW(*pszSysVolBaseDn); *pszSysVolBaseDn = NULL; }
            dwRet = LDAP_PARAM_ERROR;
            if (pldmResults) { ldap_msgfree(pldmResults); }
            return(dwRet);
        }

    } else {
        dwRet = LdapGetLastError();
        if (dwRet == LDAP_SUCCESS) {
            dwRet = LDAP_NO_RESULTS_RETURNED;
        }
        szLdapError = ldap_err2stringW(dwRet);
        PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GENERIC_FATAL_LDAP_ERROR, dwRet, szLdapError);
        if (pldmResults) { ldap_msgfree(pldmResults); }
        return(dwRet);
    }
    
    if (pldmResults) { ldap_msgfree(pldmResults); }

    Assert(*pszSysVolBaseDn);
    return(ERROR_SUCCESS);
}

DWORD
VerifySystemObjs(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iServer,
    LDAP *                           hLdap,
    DWORD                            dwTest,
    BOOL *                           pfPrintedError,
    ULONG *                          piProblem
    )
/*++

Routine Description:

    VerifySystemObjs is a test that will perform one of three tests specified
    in the dwTest field.  The function, basically finds every DSA, DC Account,
    and FRS SysVol Replica object in the local domain and config NC and 
    verifies any references to the other objects.

Arguments:

    pDsInfo - Contains the pServers array to create.
    iServer - Index of the server to test.
    hLdap - the ldap binding to server to analyze.
    dwTest - Test to perform, valid values are:
        VERIFY_DSAS
            // This verifies all the DSA ("NTDS Settings") objects that
            // this server currently has.  This verification is a phantom
            // level only verification, because the DC Account object and
            // FRS SysVol object may not be local.
            //
            // Code.Improvement, there exists the possibility for improving
            // this based on the GCness of the target, but I don't think its
            // worth it, because we'd only add the ability to check a couple
            // back link attributes, that should have thier forward links
            // already checked.
            // look for string "Code.Improvement - DSA Object Level Verification"
                   
        VERIFY_DCS
            // This verifies all the DC Account objects that this server
            // has in it's current domain.  This verification is an object
            // level verification, it will check each DC Account object,
            // and the back links/existance of the DSA and FRS SysVol 
            // objects.
        
        VERIFY_FRS
            // This verifies all the FRS SysVol objects that this server
            // has in it's current domain.  This verification is an object
            // level verificaation, it will check each DC FRS SysVol object
            // and the back links/existance of the DC Account and FRS 
            // SysVol objects.
            
        VERIFY_CRS
            // This verifies all Cross-Ref objects in the configuration
            // directory partition.  This verification checks the nCName
            // attribute of every cross-ref for correctness, such as a lack
            // of mangledness, single valuedness, present GUID, and present 
            // SID.
            
    pfPrintedError - This tells the caller whether we printed errors and
        consequently indented 1.

Return Value:

    Win32 Error.  Function prints out appropriate messages.

--*/
{
    LPWSTR                      aszSrchAttrs [] = {
        NULL
    };
    LDAPMessage *               pldmResult = NULL;
    LDAPMessage *               pldmEntry = NULL;
    LPWSTR                      szSrchBaseDn = NULL;
    DWORD                       dwSrchScope = 0;
    LPWSTR                      szSrchFilter = NULL;
    DWORD                       dwRet;
    DWORD                       dwFirstErr = ERROR_SUCCESS;

    LPWSTR                     pszDn = NULL;
    ULONG                      ul;
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    DWORD                      dwLdapErr;
    ULONG                      ulSize;
    ULONG                      ulCount = 0;
    BOOL                       fSrchDnLdapAllocated = FALSE;
    BOOL                       fSrchDnLocalAllocated = FALSE;
    LPWSTR                     szLdapError;
    LPWSTR                     szTemp = NULL;
    DSNAME *                   pdnNcName = NULL;
    ULONG                      iNc;
    BOOL                       fIsOldCrossRef;

    //
    // DSA Test
    //
    REF_INT_LNK_ENTRY           aDsaTable [] = {
        // The 2nd field in the these two entries gets filled in each
        // time we run this test on a new server.
    
        //
        // Check links to the DC Account Object from the Server Object.
        //
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_FORWARD_LINK,
            NULL /* To Be Filled In */, 0, 1, NULL,
            L"serverReference", L"serverReferenceBL",
            0, NULL, NULL},

        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_FORWARD_LINK,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"msDS-HasMasterNCs", NULL,
            0, NULL, NULL},
    
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_FORWARD_LINK,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"hasMasterNCs", NULL,
            0, NULL, NULL},

        // Code.Improvement - DSA Object Level Verification.
        // Add the flag REF_INT_TEST_BOTH_LINKS to the above entry.

    };

    //
    // DC Test
    //
    REF_INT_LNK_ENTRY           aDcTable [] = {
        // The 2nd field in the these two entries gets filled in each
        // time we run this test on a new server.

        // 
        // Check links to the Server Object from the DC Account Object and back.
        // 
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_BACKWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"serverReference", L"serverReferenceBL",
            0, NULL, NULL},
    
        //
        // Check links to the FRS SysVol Object from the DC Account Object and back. (intra, should work)
        //
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_BACKWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"frsComputerReference", L"frsComputerReferenceBL",
            0, NULL, NULL},

    };
    
    //
    // FRS Test
    //
    REF_INT_LNK_ENTRY           aFrsTable [] = {
        // The 2nd field in the these two entries gets filled in each
        // time we run this test on a new server.

        // 
        // Check links to the DC Account Object from the FRS SysVol Object and back.
        // 
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_FORWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"frsComputerReference", L"frsComputerReferenceBL",
            0, NULL, NULL},
    
        //
        // Check links to the NTDS Settings from the FRS SysVol Object and back.
        //
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_FORWARD_LINK | REF_INT_TEST_BOTH_LINKS,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"serverReference", L"serverReferenceBL",
            0, NULL, NULL},

    };
    
    //
    // Cross-Ref Test
    //
    REF_INT_LNK_ENTRY           aCrTable [] = {
        // The 2nd field in the these two entries gets filled in each
        // time we run this test on a new server.

        // 
        // Check nCName references on all cross-refs.
        // 
        {REF_INT_TEST_SRC_STRING | REF_INT_TEST_FORWARD_LINK | REF_INT_TEST_GUID_AND_SID,
            NULL /* To Be Filled In */, 0, 0, NULL,
            L"nCName", NULL,
            0, NULL, NULL},
    
    };

    REF_INT_LNK_TABLE           aRefTable = NULL;
    ULONG                       cRefTable;

    Assert(dwTest);

    //
    // First, setup this sub-test depending on what was specified.
    //
    switch (dwTest) {
    
    case VERIFY_DSAS:
        szSrchBaseDn = pDsInfo->pNCs[pDsInfo->iConfigNc].pszDn;
        dwSrchScope = LDAP_SCOPE_SUBTREE;
        szSrchFilter = L"(objectCategory=ntdsDsa)";
        aRefTable = aDsaTable;
        cRefTable = sizeof(aDsaTable) / sizeof(REF_INT_LNK_ENTRY);
        break;

    case VERIFY_DCS:
        // Find the primary domain of the target server
        // Code.Improvement, it'd be a good idea to optimize this code
        // for high NDNC environments, it'd be very very simple to write
        // a little access routine that gets the domain for a given
        // server and caches it for quick returns on subsequent calls.
        for( ul = 0; pDsInfo->pServers[iServer].ppszMasterNCs[ul] != NULL; ul++ ) {
            if ( IsDomainNC( pDsInfo, pDsInfo->pServers[iServer].ppszMasterNCs[ul]) ) {
                szSrchBaseDn = pDsInfo->pServers[iServer].ppszMasterNCs[ul];
                break;
            }
        }
        if (szSrchBaseDn == NULL) {
            Assert(!"Errr, figure this out.  Can this reasonably happen?  I would think so, but then what's the assert at 888 in repl\\objects.c");
            DcDiagException(ERROR_DS_CANT_FIND_EXPECTED_NC);
        }

        // Code.Improvement szSrchBaseDn
        // Hmmm, looks like we've got a specific container for Domain 
        // Controllers, but I was once told that I shouldn't  expect DC 
        // Account objects to always be in here?  Was I mis-informed?  Anyway,
        // for now we search the whole domain.
        //
        // B:32:A361B2FFFFD211D1AA4B00C04FD7D83A:OU=Domain Controllers,DC=ntdev,DC=microsoft,DC=com
        //

        dwSrchScope = LDAP_SCOPE_SUBTREE;
        Assert(516 == DOMAIN_GROUP_RID_CONTROLLERS); // This is because the primaryGroupID should be 516 in the filter below.
        // operatingSystem for a Win2k(Win NT 5.0) server is "Windows 2000 Server",
        //   for Windows Server 2003 (Win NT 5.1) is "Windows Server 2003", and 
        //   only for Windows NT 4.5 and previous does the attribute actually read
        //   "Windows NT", so this filter excludes all NT BDCs
        szSrchFilter = L"(&(objectCategory=computer)(sAMAccountType=805306369)(!operatingSystem=Windows NT)(primaryGroupID=516))";
        aRefTable = aDcTable;
        cRefTable = sizeof(aDcTable) / sizeof(REF_INT_LNK_ENTRY);
        break;

    case VERIFY_FRS:
        szSrchBaseDn = NULL;
        for( ul = 0; pDsInfo->pServers[iServer].ppszMasterNCs[ul] != NULL; ul++ ) {
            if ( IsDomainNC( pDsInfo, pDsInfo->pServers[iServer].ppszMasterNCs[ul]) ) {
                Assert(szSrchBaseDn == NULL); // Expect to find one domain
                dwLdapErr = GetSysVolBase(pDsInfo,
                                          iServer,
                                          hLdap,
                                          pDsInfo->pServers[iServer].ppszMasterNCs[ul],
                                          &szSrchBaseDn);
                if (dwLdapErr || szSrchBaseDn == NULL) {
                    // GetSysVolBase() should have printed an error already.
                    Assert(dwLdapErr && szSrchBaseDn == NULL);
                    dwRet = LdapMapErrorToWin32(dwLdapErr);
                    return(dwRet);
                }
                break;
            }
        }
        if (szSrchBaseDn == NULL) {
            Assert(!"Errr, figure this out.  Can this reasonably happen?  I would think so, but then what's the assert at 888 in repl\\objects.c");
            DcDiagException(ERROR_DS_CANT_FIND_EXPECTED_NC);
        }
        // Note: GetSysVolBase() allocation must be freed with ldap_memfree()
        fSrchDnLdapAllocated = TRUE;
        dwSrchScope = LDAP_SCOPE_ONELEVEL;
        szSrchFilter = L"(objectCategory=nTFRSMember)";
        aRefTable = aFrsTable;
        cRefTable = sizeof(aFrsTable) / sizeof(REF_INT_LNK_ENTRY);
        break;

    case VERIFY_CRS:
        szSrchBaseDn = pDsInfo->pszPartitionsDn;
        Assert( !fSrchDnLocalAllocated );
        dwSrchScope = LDAP_SCOPE_ONELEVEL;
        szSrchFilter = L"(objectCategory=crossRef)";
        aRefTable = aCrTable;
        cRefTable = sizeof(aCrTable) / sizeof(REF_INT_LNK_ENTRY);
        break;

    default:
        Assert(!"Bad programmer");
    }

    // Make sure we set everything up we were supposed to.
    Assert(szSrchFilter);
    Assert(dwSrchScope == LDAP_SCOPE_SUBTREE || dwSrchScope == LDAP_SCOPE_ONELEVEL);
    Assert(szSrchBaseDn);
    Assert(aRefTable);
    Assert(cRefTable);
    
    //
    // Second, iterate over all the test objects.
    //

    __try{

        pSearch = ldap_search_init_page(hLdap,
                                        szSrchBaseDn,
                                        dwSrchScope,
                                        szSrchFilter,
                                        aszSrchAttrs,
                                        FALSE,
                                        NULL,    // ServerControls
                                        NULL,    // ClientControls
                                        0,       // PageTimeLimit
                                        0,       // TotalSizeLimit
                                        NULL);   // sort key

        if (pSearch == NULL) {
            dwLdapErr = LdapGetLastError();
            szLdapError = ldap_err2stringW(dwLdapErr);
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GENERIC_FATAL_LDAP_ERROR, dwLdapErr, szLdapError);
            dwRet = LdapMapErrorToWin32(dwLdapErr);
            __leave;
        }

        dwLdapErr = ldap_get_next_page_s(hLdap,
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmResult);
        if (dwLdapErr != LDAP_SUCCESS) {
            szLdapError = ldap_err2stringW(dwLdapErr);
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GENERIC_FATAL_LDAP_ERROR, dwLdapErr, szLdapError);
            dwRet = LdapMapErrorToWin32(dwLdapErr);
            __leave;
        }

        while (dwLdapErr == LDAP_SUCCESS) {

            pldmEntry = ldap_first_entry (hLdap, pldmResult);

            for (; pldmEntry != NULL; ulCount++) {
                
                if ((pszDn = ldap_get_dnW (hLdap, pldmEntry)) == NULL) {
                    // Critical error, except out.
                    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
                }

                //
                // Third, actually test the object of interest.
                //

                // These fields need filling in each time ...
                for (ul = 0; ul < cRefTable; ul++) {
                    aRefTable[ul].szSource = pszDn;
                }

                dwRet = ReferentialIntegrityEngine(&(pDsInfo->pServers[iServer]), 
                                                   hLdap, 
                                                   pDsInfo->pServers[iServer].bIsGlobalCatalogReady, 
                                                   cRefTable,
                                                   aRefTable);
                if (dwRet) {
                    // Critical error, probably out of memory.

                    DcDiagException(dwRet);
                }

                //
                // Fourth, print out/decode error from the results.
                //

                switch (dwTest) {
                case VERIFY_DSAS:
                    szTemp = DcDiagTrimStringDnBy(pszDn, aRefTable[0].cTrimBy);
                    if (szTemp == NULL) {
                        DcDiagException(ERROR_NOT_ENOUGH_MEMORY); // Or maybe invalid DN
                    }
                    if (aRefTable[0].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
                        // Missing serverReference attribute on Server Object.
                        VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);

                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_SYS_REF_ERR_SERVER_OBJ_MISSING_DC_ACCOUNT_REF,
                                 (*piProblem)++,
                                 szTemp,
                                 aRefTable[0].szFwdDnAttr);
                        dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                        LocalFree(szTemp);
                    } else {
                        if (aRefTable[0].dwResultFlags & REF_INT_RES_DELETE_MANGLED) {
                            VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                            PrintMsg(SEV_ALWAYS, 
                                     DCDIAG_SYS_REF_ERR_DELETE_MANGLED_PROB, 
                                     (*piProblem)++);
                            PrintMsg(SEV_ALWAYS,
                                     DCDIAG_SYS_REF_ERR_DSA_OBJ_HAS_MANGLED_FRS_MEMBER_REF,
                                     szTemp,
                                     aRefTable[0].szFwdDnAttr,
                                     aRefTable[0].pszValues[0]);
                            // BUGBUG we could have a better error here.
                            dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                        }
                        if (aRefTable[0].dwResultFlags & REF_INT_RES_CONFLICT_MANGLED) {
                            VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                            PrintMsg(SEV_ALWAYS, 
                                     DCDIAG_SYS_REF_ERR_CONFLICT_MANGLED_PROB, 
                                     (*piProblem)++);
                            PrintMsg(SEV_ALWAYS,
                                     DCDIAG_SYS_REF_ERR_DSA_OBJ_HAS_MANGLED_FRS_MEMBER_REF,
                                     szTemp,
                                     aRefTable[0].szFwdDnAttr,
                                     aRefTable[0].pszValues[0]);
                            // BUGBUG we could have a better error here.
                            dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                        }
                    }
                    if ((aRefTable[1].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING ||
                         aRefTable[1].pszValues[0] == NULL ||
                         aRefTable[1].pszValues[1] == NULL ||
                         aRefTable[1].pszValues[2] == NULL) &&
                        (aRefTable[2].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING ||
                         aRefTable[2].pszValues[0] == NULL ||
                         aRefTable[2].pszValues[1] == NULL ||
                         aRefTable[2].pszValues[2] == NULL)
                        ) {
                        VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_SYS_REF_ERR_NOT_ENOUGH_MASTER_NCS,
                                 (*piProblem)++,
                                 pszDn);
                        dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                    }
                    // Code.Improvement - DSA Object Level Verification.
                    // We'd need to add some code to verify that the back link was verified
                    //  "! (dwResultFlags &  REF_INT_RES_BACK_LINK_NOT_MATCHED), and if
                    // not we need to not error unless we're on a GC and the NC has
                    // been replicated in locally.
                    break;

                case VERIFY_DCS:
                    if (aRefTable[0].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
                        // Missing serverReferenceBL attribute on DC Account
                        // Object.
                        VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_SYS_REF_ERR_DC_ACCOUNT_OBJ_MISSING_SERVER_BL_REF,
                                 (*piProblem)++,
                                 pszDn,
                                 aRefTable[0].szBwdDnAttr);
                        dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                    }
                    if (aRefTable[1].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
                        // Missing frsComputerReferenceBL attribute on DC Account Object.
                        VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_SYS_REF_ERR_DC_ACCOUNT_OBJ_MISSING_FRS_MEMBER_BL_REF,
                                 (*piProblem)++,
                                 pszDn,
                                 aRefTable[1].szBwdDnAttr);
                        dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                    }
                    break;

                case VERIFY_FRS:
                    if (aRefTable[0].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
                        // Missing frsComputerReference attribute on FRS SysVol Object.
                        VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_SYS_REF_ERR_FRS_MEMBER_OBJ_MISSING_DC_ACCOUNT_REF,
                                 (*piProblem)++,
                                 pszDn,
                                 aRefTable[0].szFwdDnAttr);
                        dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                    }
                    if (aRefTable[1].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
                        // Missing serverReference attribute of FRS SysVol Object.
                        VerifyPrintFirstError(VERIFY_PHASE_II, NULL, pfPrintedError);
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_SYS_REF_ERR_FRS_MEMBER_OBJ_MISSING_DSA_REF,
                                 (*piProblem)++,
                                 pszDn,
                                 aRefTable[1].szFwdDnAttr);
                        dwFirstErr = ERROR_DS_MISSING_EXPECTED_ATT;
                    }
                    break;

                case VERIFY_CRS:
                    if (aRefTable[0].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {

                        // This would simply mean that the cross-ref was deleted in
                        // a slim timing window.  Ignore this case.
                        break;

                    } else {

                        Assert(aRefTable[0].pszValues[0] != NULL &&
                               aRefTable[0].pszValues[1] == NULL);

                        // Gosh I love DSNAME structures ...
                        dwRet = LdapMakeDSNameFromStringDSName(aRefTable[0].pszValues[0], &pdnNcName);
                        Assert(dwRet == ERROR_SUCCESS && pdnNcName);
                        if (dwRet || pdnNcName == NULL) {
                            break;
                        }

                        iNc = DcDiagGetNCNum(pDsInfo, pdnNcName->StringName, NULL);
                        if (iNc == NO_NC) {
                            // Can't do anything if we don't have this NC in our
                            // DS/NC cache.
                            break;         
                        }

                        dwRet = VerifyOldCrossRef(pDsInfo, 
                                                  iNc, 
                                                  &fIsOldCrossRef);
                        if (dwRet) {

                            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_REF_VALIDATION_WARN_CANT_DETERMINE_AGE,
                                     pszDn, pdnNcName->StringName);
                            fIsOldCrossRef = TRUE; // Pretend this CR is old.
                        }

                        if (fNullUuid(&(pdnNcName->Guid)) &&
                            fIsOldCrossRef) {

                            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_NULL_GUID,
                                     pdnNcName->StringName, pszDn);

                        }

                        if ((DcDiagGetCrSystemFlags(pDsInfo, iNc) & FLAG_CR_NTDS_DOMAIN) &&
                            fIsOldCrossRef) {
                            // We have a cross-ref for a domain that was created long
                            // enough ago, that replication latency shouldn't be an issue.

                            if (pdnNcName->SidLen == 0) {
                                // Missing SID.

                                PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_MISSING_SID,
                                         pdnNcName->StringName, pszDn);

                                // Code.Improvement We could also check for the validity
                                // of the SID with RtlValidSid(&(pdnOut->Sid)), but I'm 
                                // not sure what we should recommend to the user in that
                                // extremely unlikely scenario.  If this is implemented,
                                // we should also do this in ValidateCrossRefTest().
                            }
                        }
                        if (aRefTable[0].dwResultFlags & REF_INT_RES_DELETE_MANGLED) {

                            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_DEL_MANGLED_NC_NAME,
                                     pdnNcName->StringName, pszDn);

                        }
                        if (aRefTable[0].dwResultFlags & REF_INT_RES_CONFLICT_MANGLED) {

                            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_CNF_MANGLED_NC_NAME,
                                     pdnNcName->StringName, pszDn);

                        }


                        LocalFree(pdnNcName);
                        pdnNcName = NULL;
                    }
                    break;

                default:
                    Assert(!"Huh?");
                }

                // If we allocated this, free it.
                if (pdnNcName) { 
                    LocalFree(pdnNcName); 
                    pdnNcName = NULL; 
                }
                
                ReferentialIntegrityEngineCleanTable(cRefTable, aRefTable);
                ldap_memfreeW (pszDn);
                pszDn = NULL;

                pldmEntry = ldap_next_entry (hLdap, pldmEntry);
            } // end for each server for this page.

            ldap_msgfree(pldmResult);
            pldmResult = NULL;

            dwLdapErr = ldap_get_next_page_s(hLdap,
                                             pSearch,
                                             0,
                                             DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                             &ulTotalEstimate,
                                             &pldmResult);
        } // end while there are more pages ...
        
        if (dwLdapErr != LDAP_NO_RESULTS_RETURNED) {
            szLdapError = ldap_err2stringW(dwLdapErr);
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GENERIC_FATAL_LDAP_ERROR, dwLdapErr, szLdapError);
            dwRet = LdapMapErrorToWin32(dwLdapErr);
            __leave;
        }

    } finally {
        if (pSearch != NULL) { ldap_search_abandon_page(hLdap, pSearch); }
        if (pldmResult != NULL) { ldap_msgfree (pldmResult); }
        if (pszDn != NULL) { ldap_memfreeW (pszDn); }
        if (fSrchDnLdapAllocated) { ldap_memfreeW(szSrchBaseDn); }
        if (fSrchDnLocalAllocated) { LocalFree(szSrchBaseDn); }
        if (pdnNcName != NULL) { LocalFree(pdnNcName); }
    }

    return(dwFirstErr ? dwFirstErr : dwRet);
} // End DcDiagGenerateServersList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\ds\services.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    services.c

ABSTRACT:

    Will test to see if critical DC services are running
    
DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        
    20 August 1999 Brett Shirley (brettsh) - Generalized this file to do many
    services instead of just netlogon.

--*/



#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <lmsname.h>
#include <lsarpc.h>                     // PLSAPR_foo

#include "dcdiag.h"
#include "ldaputil.h"
#include "dstest.h"


DWORD
CNLR_QueryResults(
                 WCHAR *                ServerName,
                 SC_HANDLE              hService,
                 LPSERVICE_STATUS       lpServiceStatus,
                 LPWSTR                 pszService
                 );

DWORD
CFSR_CheckForService(
                PDC_DIAG_SERVERINFO                 prgServer,
                SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
                SC_HANDLE                           hSCManager,
                LPWSTR                              pszService
                )
/*++

Routine Description:

    Will check to see if the specified service is running.
    
Arguments:

    ServerName - The name of the server that we will check
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/

{
    SC_HANDLE        hService=NULL;
    SERVICE_STATUS   lpServiceStatus;
    BOOL             success=FALSE;
    DWORD            dwErr=NO_ERROR;

    //open the requested service (pszService)
    hService=OpenService(hSCManager,
                         pszService,
                         SERVICE_QUERY_STATUS);
    if ( hService == NULL )
    {
        dwErr = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"Could not open %s Service on [%s]:failed with %d: %s\n",
                     pszService,
                     prgServer->pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        goto cleanup;
    } 

    //query Netlogon
    success=QueryServiceStatus(hService,
                               &lpServiceStatus);
    if ( !success )
    {
        dwErr = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"Could not query %s Service on [%s]:failed with %d: %s\n",
                     pszService,
                     prgServer->pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        goto cleanup;
    } 
    
    dwErr=CNLR_QueryResults(prgServer->pszName,
                            hService,
                            &lpServiceStatus,
                            pszService);
    
      
    //cleanup
cleanup:
    
    if(hService)
        CloseServiceHandle(hService);

    return dwErr;
}


DWORD
CNLR_QueryResults(WCHAR *                ServerName,
                  SC_HANDLE              hService,
                  LPSERVICE_STATUS       lpServiceStatus,
                  LPWSTR                 pszService)
/*++

Routine Description:

    Will report the state of Service.  And will report if
    Service is hung in a pending state
    
Arguments:

    ServerName - The name of the server running the service
    hService - A handle to the service being tested
    lpServiceStatus - the stucture that will be queried


Return Value:

    A Win32 Error if any tests failed to check out.

--*/

{
    DWORD dwErr=NO_ERROR;
    BOOL  success=TRUE;

    //look at the results of the query
    if (lpServiceStatus->dwCurrentState == SERVICE_RUNNING)
    {
        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED)
    {
        PrintMessage(SEV_ALWAYS,
                     L"%s Service is stopped on [%s]\n",
                     pszService, 
                     ServerName);
        dwErr = ERROR_SERVICE_NOT_ACTIVE;
        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_PAUSED)
    {
        PrintMessage(SEV_ALWAYS,
                     L"%s Service is paused on [%s]\n",
                     pszService, 
                     ServerName);
        dwErr = ERROR_SERVICE_NOT_ACTIVE;
        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_START_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to start on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_START_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_START_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung starting on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_VERBOSE,
                     L"* %s Service has started on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_CONTINUE_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to continue on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_CONTINUE_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_CONTINUE_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung pending continue on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_VERBOSE,
                     L"* %s Service has started on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_STOP_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to stop on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,                   
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_STOP_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_STOP_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung pending stop on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_ALWAYS,
                     L"* %s Service has stopped on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_PAUSE_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to pause on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_PAUSE_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_PAUSE_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung pending pause on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_ALWAYS,
                     L"* %s Service has paused on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    dwErr=ERROR_SERVICE_START_HANG;
    PrintMessage(SEV_ALWAYS,
                 L"Error: %s Service is in an unknown state [%s]\n",
                 pszService, 
                 ServerName);
    return dwErr;
}

DWORD
DoesThisServerRequireSmtp(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    BOOL *                              pbHasSmtpReplicas
    )
{
    DS_REPL_NEIGHBORSW *        pNeighbors = NULL;
    DS_REPL_NEIGHBORW *         pNeighbor = NULL;
    PDC_DIAG_SERVERINFO         pServer = &pDsInfo->pServers[iServer];
    HANDLE                      hDS = NULL;
    ULONG                       ulRepFrom;
    DWORD                       dwRet;

    Assert(pbHasSmtpReplicas);
    Assert(pDsInfo->pszSmtpTransportDN);

    *pbHasSmtpReplicas = FALSE;

    dwRet = DcDiagGetDsBinding(&pDsInfo->pServers[iServer],
                               gpCreds,
                               &hDS);
    if (ERROR_SUCCESS != dwRet) {
        return dwRet;
    }

    dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, NULL, NULL, &pNeighbors);
    if (ERROR_SUCCESS != dwRet) {
        PrintMessage(SEV_VERBOSE,
                     L"[%s,%s] DsReplicaGetInfo(NEIGHBORS) failed with error %d,\n",
                     REPLICATIONS_CHECK_STRING,
                     pDsInfo->pServers[iServer].pszName,
                     dwRet);
        PrintMessage(SEV_VERBOSE, L"%s.\n",
                     Win32ErrToString(dwRet));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwRet);
        return dwRet;
    }

    // Walk through all the repsFrom neighbors ... then done.
    for (ulRepFrom = 0; ulRepFrom < pNeighbors->cNumNeighbors; ulRepFrom++) {
        if (pNeighbors->rgNeighbor[ulRepFrom].pszAsyncIntersiteTransportDN &&
            0 == _wcsicmp(pNeighbors->rgNeighbor[ulRepFrom].pszAsyncIntersiteTransportDN,
                          pDsInfo->pszSmtpTransportDN)){
            // Yeah!  We have a mail based replica.
            dwRet = ERROR_SUCCESS;
            *pbHasSmtpReplicas = TRUE;
            goto Cleanup;
        }

    } // Move on to the next neighbor

  Cleanup:
    
    if (pNeighbors != NULL){
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    dwRet = ERROR_SUCCESS;
    return(dwRet);
}


DWORD
CheckForServicesRunning(
                PDC_DIAG_DSINFO                     pDsInfo,
                ULONG                               ulCurrTargetServer,
                SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
                )
/*++

Routine Description:

    Routine is a test to check whether various services that are 
    critical to a DC are running.
    
Arguments:

    ServerName - The name of the server that we will check
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/

{
    NETRESOURCE      NetResource;
    WCHAR            *remotename=NULL;
    WCHAR            *lpPassword=NULL;
    WCHAR            *lpUsername=NULL;
    WCHAR            *ServerName=NULL;
    SC_HANDLE        hSCManager=NULL;
    ULONG            iService;
    DWORD            dwRet;
    DWORD            dwErr;
    // These are the services to check, I used the constants when
    //    they could be found, and otherwise I used the string that
    //    specifies them.  Sorry it is ugly, but I wanted to keep
    //    the history.
    // Critical DC Services
    LPWSTR           ppszCritDcSrvs [] = {
        L"Dnscache",
        SERVICE_NTFRS,        //  L"NtFrs",
        SERVICE_ISMSERV,      //  L"IsmServ",
        SERVICE_KDC,          //  L"kdc",
        L"SamSs",
        SERVICE_SERVER,       //  L"lanmanserver",
        SERVICE_WORKSTATION,  //  L"LanmanWorkstation",
        L"RpcSs",
        SERVICE_W32TIME,      //  L"W32Time",
        SERVICE_NETLOGON,     //  L"Netlogon",
        NULL
    };
    // Critical Services to a DC that uses Mail Based Repl
    BOOL             bServerUsesMBR = FALSE;
    LPWSTR           ppszCritMailSrvs [] = {
        L"IISADMIN",
        L"SMTPSVC",
        NULL
    };
    
    ServerName=pDsInfo->pServers[ulCurrTargetServer].pszName;

    dwErr = DoesThisServerRequireSmtp(pDsInfo,
                                      ulCurrTargetServer,
                                      gpCreds,
                                      &bServerUsesMBR);
    if (dwErr) {
        PrintMsg(SEV_NORMAL, DCDIAG_COULDNT_VERIFY_SMTP_REPLICAS);
    } 

    #pragma prefast(disable: 255, "alloca can throw, but Prefast doesn't see the exception block in main.c::DcDiagRunTest")

    if(!gpCreds)
    {
        lpUsername=NULL;
        lpPassword=NULL;
    }
    else
    {
        lpUsername=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Domain)+wcslen(gpCreds->User)+2));
        wsprintf(lpUsername,L"%s\\%s",gpCreds->Domain,gpCreds->User);
        
        lpPassword=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Password)+1));
        wcscpy(lpPassword,gpCreds->Password);           
    }

    remotename=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(L"\\\\\\ipc$")+wcslen(ServerName)+1));

    wsprintf(remotename,L"\\\\%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    dwRet=WNetAddConnection2(&NetResource,
                             lpPassword,
                             lpUsername,
                             0);

    if ( dwRet != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Remote ipc to [%s]:failed with %d: %s\n",
                     ServerName,
                     dwRet,
                     Win32ErrToString(dwRet));
        remotename = NULL;
        goto cleanup;
    } 

    //open the service control manager
    hSCManager=OpenSCManager(
                      ServerName,
                      SERVICES_ACTIVE_DATABASE,
                      GENERIC_READ);
    if ( hSCManager == NULL )
    {
        dwRet = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Service Control Manager on [%s]:failed with %d: %s\n",
                     ServerName,
                     dwRet,
                     Win32ErrToString(dwRet));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwRet);
        goto cleanup;
    } 

    // Check for the critical DC services.
    for(iService = 0; ppszCritDcSrvs[iService] != NULL; iService++){
        PrintMessage(SEV_VERBOSE, L"* Checking Service: %s\n", ppszCritDcSrvs[iService]);
        PrintIndentAdj(1);
        dwErr = CFSR_CheckForService(&(pDsInfo->pServers[ulCurrTargetServer]),
                                     gpCreds,
                                     hSCManager,
                                     ppszCritDcSrvs[iService]);
        PrintIndentAdj(-1);
        if(dwErr != ERROR_SUCCESS){
            dwRet = dwErr;
        }
    }

    // If this server uses MBR (mail based replication) then check for critical MBR DC services.
    if(bServerUsesMBR){
        //    if(ServerUsesMBR(pDsInfo, ulCurrTargetServer)){
        for(iService = 0; ppszCritMailSrvs[iService] != NULL; iService++){
            PrintMessage(SEV_VERBOSE, L"* Checking Service: %s\n", ppszCritMailSrvs[iService]);
            PrintIndentAdj(1);
            dwErr = CFSR_CheckForService(&(pDsInfo->pServers[ulCurrTargetServer]),
                                         gpCreds,
                                         hSCManager,
                                         ppszCritMailSrvs[iService]);
            PrintIndentAdj(-1);
            if(dwErr != ERROR_SUCCESS){
                dwRet = dwErr;
            }
        }
    }
      
    //cleanup
cleanup:
    if(hSCManager)
        CloseServiceHandle(hSCManager);
    if(remotename)
        WNetCancelConnection2(remotename, 0, TRUE);

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\frs\sysevent.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    frs\sysevent.c

ABSTRACT:

    Check the System eventlog to see that certain 
    critical events have occured and to signal that any fatal events that 
    might have occured.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

MODIFIED:

    29 Oct 1999 William Lees (wlees)

--*/

#include <ntdspch.h>
#include <netevent.h>
#include <time.h>
#include "mdcodes.h"

#include "dcdiag.h"
#include "utils.h"

typedef DWORD MessageId;

typedef struct _EVENT_CALLBACK_CONTEXT {
    BOOL fEventsFound;
    ULONG ulDsInfoFlags;
} EVENT_CALLBACK_CONTEXT, *PEVENT_CALLBACK_CONTEXT;

#define   LOGFILENAME            L"System"

#define EVENTLOG_STARTED 6005
#define EVENTLOG_SESSION_SETUP_FAILURE 0x0000165A
#define EVENTLOG_SESSION_SETUP_CANCELLED 0x00001697
#define EVENTLOG_KDC_MULTIPLE_ACCOUNTS 0XC000000B
#define EVENTLOG_TIME_SECURITY_FALLBACK 0x8000003F
#define EVENTLOG_COMPUTER_LOST_TRUST 0x00001589
#define EVENTLOG_IPSEC_PACKET_IN_CLEAR 0xC00010BC
#define EVENTLOG_MRXSMB_ELECTION_FORCED 0xC0001F43
#define EVENTLOG_NO_DC_FOR_DOMAIN 0x00001657

static VOID
foundBeginningEvent(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This file will be called by the event tests library common\events.c, when
    the beginning event. If the event is
    not found, then the function is called with pEvent = NULL;

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    NOTHING;
}

static VOID
eventlogPrint(
    PVOID                           pvContextArgument,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This function will be called by the event tests library common\events.c,
    whenever an event of interest comes up.  An event of interest for this
    test is any error or the warnings.

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    PEVENT_CALLBACK_CONTEXT pContext = (PEVENT_CALLBACK_CONTEXT) pvContextArgument;
    DWORD paSuppressedEvents [] = {
        // Put your events that can be skipped here
        EVENTLOG_SESSION_SETUP_FAILURE,
        EVENTLOG_SESSION_SETUP_CANCELLED,
        EVENTLOG_KDC_MULTIPLE_ACCOUNTS,
        EVENTLOG_COMPUTER_LOST_TRUST,
        EVENTLOG_IPSEC_PACKET_IN_CLEAR,
        EVENTLOG_MRXSMB_ELECTION_FORCED,
        EVENTLOG_NO_DC_FOR_DOMAIN,
        0
    };
    DWORD paIgnorableEvents [] = {
        // Put your events that can be optionally ignored here
        0
    };
    Assert(pEvent != NULL);

    // Handle events we want to suppress
    if (EventIsInList( pEvent->EventID, paSuppressedEvents ) ) {
        return;
    }

    // Handle ignorable errors
    if ( (pContext->ulDsInfoFlags & DC_DIAG_IGNORE) &&
         (EventIsInList( pEvent->EventID, paIgnorableEvents ) ) ) {
        return;
    }

    GenericPrintEvent(LOGFILENAME, pEvent, (gMainInfo.ulSevToPrint >= SEV_VERBOSE) );

    pContext->fEventsFound = TRUE;
}



DWORD
CheckSysEventlogMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

Routine Description:

    Check whether the Sys is currently in an error state. That is, we check
    whether the Sys logged any errors on its last run.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    // Setup variables for PrintSelectEvents
    DWORD paSelectEvents [] = { 
        // Put special selected events here
        // For future use
        0 };
    DWORD paBegin [] = {
        // These events will cause the search to stop
        EVENTLOG_STARTED,
        0 };
    DWORD dwRet;
    DWORD dwMinutesPast, dwTimeLimit;
    EVENT_CALLBACK_CONTEXT context;
    time_t tLimit;

    PrintMessage(SEV_VERBOSE, L"* The System Event log test\n");

    context.fEventsFound = FALSE;
    context.ulDsInfoFlags = pDsInfo->ulFlags;

    dwMinutesPast = 60;

    // Calculate time limit of minutes in the past
    time( &tLimit );
    dwTimeLimit = (DWORD)tLimit;
    dwTimeLimit -= (dwMinutesPast * 60);

    // We will select events as follows:
    // a. Must be within 60 minutes
    // b. Will stop searching at computer start
    // c. Any error severity event in the log will be selected,
    // d. Any non-error in the select list will be flagged

    dwRet = PrintSelectEvents(&(pDsInfo->pServers[ulCurrTargetServer]),
                              pDsInfo->gpCreds,
                              LOGFILENAME,
                              EVENTLOG_ERROR_TYPE,
                              NULL, // paSelectEvents,
                              paBegin,
                              dwTimeLimit,
                              eventlogPrint,
                              foundBeginningEvent,
                              &context );

    if (dwRet) {
        PrintMessage( SEV_ALWAYS, L"Failed to enumerate event log records, error %s\n",
                      Win32ErrToString(dwRet) );
        return dwRet;
    } else if (context.fEventsFound) {
        return ERROR_DS_GENERIC_ERROR;
    } else {
	PrintMessage(SEV_VERBOSE, L"Found no errors in System Event log in the last %d minutes.\n", dwMinutesPast);
        return ERROR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\dcdiag.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag.h

ABSTRACT:

    This is the header for the globally useful data structures for the entire
    dcdiag.exe utility.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

    8  Aug 2001 Brett Shirley (BrettSh)
        Added support for CR cache.

--*/

#ifndef _DCDIAG_H_
#define _DCDIAG_H_

#include <winldap.h>
#include <tchar.h>

#include <ntlsa.h>

#include "debug.h"

#include "msg.h"

// This is the main caching structure for dcdiag containing the 
// DC_DIAG_DSINFO structure and constituents.
#include "dscache.h"
       
#define DC_DIAG_EXCEPTION    ((0x3 << 30) | (0x1 << 27) | (0x1 << 1))
#define DC_DIAG_VERSION_INFO L"Domain Controller Diagnosis\n"

#define DEFAULT_PAGED_SEARCH_PAGE_SIZE   (1000)

#define SZUUID_LEN 40

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0 | (y))

// Code to suppress invalid prefast pragma warnings
#ifndef _PREFAST_
#   pragma warning(disable:4068)
#endif

// In Whister Beta 2, the handling of \n in RDNs changed. It used to be that
// embedded newlines were not quoted.  Now, they are quoted like this: \\0A.
//#define IsDeletedRDNW( s ) ((s) && (wcsstr( (s), L"\nDEL:" ) || wcsstr( (s), L"\\0ADEL:" )))
#define IsDeletedRDNW( s ) (DsIsMangledDnW((s),DS_MANGLE_OBJECT_RDN_FOR_DELETION))
#define IsConflictedRDNW( s ) (DsIsMangledDnW((s), DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT))

// Level of detail to display.
enum {
    SEV_ALWAYS,
    SEV_NORMAL,
    SEV_VERBOSE,
    SEV_DEBUG
};

typedef struct {
    FILE *  streamOut;      // Output stream
    FILE *  streamErr;      // Error stream
    ULONG   ulFlags;        // Flags
    ULONG   ulSevToPrint;   // Level of detail to display
    LONG    lTestAt;        // The current test
    INT     iCurrIndent;    // The current number of intents to precede each line
    DWORD   dwScreenWidth;  // Width of console
} DC_DIAG_MAININFO, * PDC_DIAG_MAININFO;

extern DC_DIAG_MAININFO gMainInfo;

// Flags

// Flags for scope of testing
#define DC_DIAG_TEST_SCOPE_SITE          0x00000010
#define DC_DIAG_TEST_SCOPE_ENTERPRISE    0x00000020

// Flags, other
#define DC_DIAG_IGNORE                   0x00000040
#define DC_DIAG_FIX                      0x00000080

// Pseudofunctions

#if 1
#define IF_DEBUG(x)               if(gMainInfo.ulSevToPrint >= SEV_DEBUG) x;
#else
#define IF_DEBUG(x)               
#endif

#define DcDiagChkErr(x)  {   ULONG _ulWin32Err; \
                if ((_ulWin32Err = (x)) != 0) \
                    DcDiagException (_ulWin32Err); \
                }

#define DcDiagChkLdap(x)    DcDiagChkErr (LdapMapErrorToWin32 (x));

#define DcDiagChkNull(x)    if (NULL == (x)) \
                    DcDiagChkErr (GetLastError ());

#define  DCDIAG_PARTITIONS_RDN    L"CN=Partitions,"

// Function prototypes


DWORD
DcDiagCacheServerRootDseAttrs(
    IN LDAP *hLdapBinding,
    IN PDC_DIAG_SERVERINFO pServer
    );

DWORD
DcDiagGetLdapBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   BOOL                                bUseGcPort,
    OUT  LDAP * *                            phLdapBinding
    );

DWORD
DcDiagGetDsBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  HANDLE *                            phDsBinding
    );

BOOL
DcDiagIsMemberOfStringList(
    LPWSTR pszTarget, 
    LPWSTR * ppszSources, 
    INT iNumSources
    );

ULONG
DcDiagExceptionHandler(
    IN const  EXCEPTION_POINTERS * prgExInfo,
    OUT PDWORD                     pdwWin32Err
    );

VOID
DcDiagException (
    ULONG            ulWin32Err
    );

LPWSTR
DcDiagAllocNameFromDn (
    LPWSTR            pszDn
    );

LPWSTR
Win32ErrToString(
    ULONG            ulWin32Err
    );

INT PrintIndentAdj (INT i);
INT PrintIndentSet (INT i);

void 
ConvertToWide (LPWSTR lpszDestination,
               LPCSTR lpszSource,
               const int iDestSize);

void
PrintMessage(
    IN  ULONG   ulSev,
    IN  LPCWSTR pszFormat,
    IN  ...
    );

void
PrintMessageID(
    IN  ULONG   ulSev,
    IN  ULONG   uMessageID,
    IN  ...
    );

void
PrintMsg(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintMsg0(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintMessageSz(
    IN  ULONG   ulSev,
    IN  LPCTSTR pszMessage
    );

void
PrintRpcExtendedInfo(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode
    );

VOID *
GrowArrayBy(
    VOID *            pArray, 
    ULONG             cGrowBy, 
    ULONG             cbElem
    );

LPWSTR
findServerForDomain(
    LPWSTR pszDomainDn
    );

LPWSTR
findDefaultServer(BOOL fMustBeDC);

PVOID
CopyAndAllocWStr(
    WCHAR * pszOrig 
    );

BOOL
DcDiagEqualDNs (
    LPWSTR            pszDn1,
    LPWSTR            pszDn2
    );

#include "alltests.h"

#endif  // _DCDIAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\frs\kccevent.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    frs\kccevent.c

ABSTRACT:

    Check the Knowledge Consistency Checker eventlog to see that certain 
    critical events have occured and to signal that any fatal events that 
    might have occured.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

MODIFIED:

    29 Oct 1999 William Lees (wlees)

--*/

#include <ntdspch.h>
#include <netevent.h>
#include <time.h>
#include "mdcodes.h"

#include "dcdiag.h"
#include "utils.h"

typedef DWORD MessageId;

typedef struct _EVENT_CALLBACK_CONTEXT {
    BOOL fEventsFound;
    ULONG ulDsInfoFlags;
} EVENT_CALLBACK_CONTEXT, *PEVENT_CALLBACK_CONTEXT;

#define   LOGFILENAME            L"Directory Service"

VOID
foundBeginningEvent(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This file will be called by the event tests library common\events.c, when
    the beginning event. If the event is
    not found, then the function is called with pEvent = NULL;

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    NOTHING;
}

VOID
eventlogPrint(
    PVOID                           pvContextArgument,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This function will be called by the event tests library common\events.c,
    whenever an event of interest comes up.  An event of interest for this
    test is any error or the warnings.

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    PEVENT_CALLBACK_CONTEXT pContext = (PEVENT_CALLBACK_CONTEXT) pvContextArgument;
    DWORD paIgnorableEvents [] = {
        DIRLOG_CHK_LINK_ADD_MASTER_FAILURE,
	DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
        DIRLOG_KCC_REPLICA_LINK_DOWN,
        DIRLOG_ISM_SMTP_DSN,
        DIRLOG_EXCEPTION,
        DIRLOG_DRA_CALL_EXIT_BAD,
        DIRLOG_DRA_NOTIFY_FAILED,
        0
    };
    Assert(pEvent != NULL);

    // Handle ignorable errors
    if ( (pContext->ulDsInfoFlags & DC_DIAG_IGNORE) &&
         (EventIsInList( pEvent->EventID, paIgnorableEvents ) ) ) {
        return;
    }

    GenericPrintEvent(LOGFILENAME, pEvent, (gMainInfo.ulSevToPrint >= SEV_VERBOSE) );

    pContext->fEventsFound = TRUE;
}



DWORD
CheckKccEventlogMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

Routine Description:

    Check whether the KCC is currently in an error state. That is, we check
    whether the KCC logged any errors on its last run.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    // Setup variables for PrintSelectEvents
    DWORD paSelectEvents [] = { 
        DIRLOG_KCC_NO_SPANNING_TREE,
        DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
        DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
        DIRLOG_KCC_CONNECTION_OBJECT_DELETION_FAILED,
        DIRLOG_KCC_KEEPING_INTERSITE_CONN,
        DIRLOG_KCC_DIR_OP_FAILURE,
        DIRLOG_KCC_TRANSPORT_ADDRESS_MISSING,
        DIRLOG_KCC_TRANSPORT_BRIDGEHEAD_NOT_FOUND,
        DIRLOG_KCC_ALL_TRANSPORT_BRIDGEHEADS_STALE,
        DIRLOG_KCC_EXPLICIT_BRIDGEHEAD_LIST_INCOMPLETE,
        DIRLOG_KCC_NO_BRIDGEHEADS_ENABLED_FOR_TRANSPORT,
        DIRLOG_KCC_REPLICA_LINK_DOWN,
        DIRLOG_CHK_INIT_FAILURE,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_ABNORMAL,
        DIRLOG_CHK_LINK_DEL_NONC_BUSY,
        DIRLOG_CHK_LINK_DEL_NOTGC_BUSY,
        DIRLOG_CHK_LINK_DEL_DOMDEL_BUSY,
        DIRLOG_CHK_LINK_DEL_NOCONN_BUSY,
        DIRLOG_CHK_LINK_DEL_NOSRC_BUSY,
        DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC,
        DIRLOG_CHK_CANT_REPLICATE_FROM_SELF,
        DIRLOG_CHK_REPSTO_DEL_FAILURE,
        DIRLOG_CHK_ALL_CONNECTIONS_FOR_NC_DISABLED,
        DIRLOG_CHK_NO_LOCAL_SOURCE_FOR_NC,
        DIRLOG_CHK_BAD_SCHEDULE,
        DIRLOG_CHK_DUPLICATE_CONNECTION,
        DIRLOG_CHK_LINK_ADD_MASTER_FAILURE,
	DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
        DIRLOG_CHK_LINK_DEL_NOSRC_FAILURE,
        DIRLOG_CHK_LINK_DEL_NOTGC_FAILURE,
        DIRLOG_CHK_LINK_DEL_DOMDEL_FAILURE,
        DIRLOG_CHK_LINK_DEL_NOCONN_FAILURE,
        DIRLOG_CHK_LINK_DEL_NONC_FAILURE,
        DIRLOG_CHK_CONFIG_PARAM_TOO_LOW,
        DIRLOG_CHK_CONFIG_PARAM_TOO_HIGH,
        DIRLOG_CHK_SITE_HAS_NO_NTDS_SETTINGS,
        DIRLOG_GC_PROMOTION_DELAYED,
        DIRLOG_DRA_DISABLED_OUTBOUND_REPL,
        DIRLOG_DRA_DELETED_PARENT,
        DIRLOG_SCHEMA_CREATE_INDEX_FAILED,
        DIRLOG_SCHEMA_INVALID_RDN,
        DIRLOG_SCHEMA_INVALID_MUST,
        DIRLOG_SCHEMA_INVALID_MAY,
        DIRLOG_PRIVILEGED_OPERATION_FAILED,
        DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
        DIRLOG_SCHEMA_DELETED_COLUMN_IN_USE,
        DIRLOG_SCHEMA_DELETE_INDEX_FAIL,
        DIRLOG_RECOVER_RESTORED_FAILED,
        DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL,
        DIRLOG_DRA_SCHEMA_MISMATCH,
        DIRLOG_SDPROP_TOO_BUSY_TO_PROPAGATE,
        DIRLOG_DSA_NOT_ADVERTISE_DC,
        DIRLOG_ADUPD_GC_NC_MISSING,
        DIRLOG_GC_OCCUPANCY_NOT_MET,
        DIRLOG_DS_DNS_HOST_RESOLUTION_FAILED,
        DIRLOG_RPC_PROTSEQ_FAILED,
        DIRLOG_DRA_NC_TEARDOWN_BEGIN,
        DIRLOG_DRA_NC_TEARDOWN_RESUME,
        DIRLOG_DRA_NC_TEARDOWN_SUCCESS,
        DIRLOG_DRA_NC_TEARDOWN_FAILURE,
        DIRLOG_ADUPD_NC_SYNC_NO_PROGRESS,
        0 };
    DWORD paBegin [] = {
        DIRLOG_KCC_TASK_ENTRY,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_BEGIN,
        DIRLOG_STARTED,
        0 };
    DWORD dwRet;
    DWORD dwMinutesPast, dwTimeLimit;
    time_t tLimit;
    EVENT_CALLBACK_CONTEXT context;

    PrintMessage(SEV_VERBOSE, L"* The KCC Event log test\n");

    context.fEventsFound = FALSE;
    context.ulDsInfoFlags = pDsInfo->ulFlags;

    // BUGBUG: use actual kcc frequency on that system
    dwMinutesPast = 15;

    // Calculate time limit of minutes in the past
    time( &tLimit );
    dwTimeLimit = (DWORD)tLimit;
    dwTimeLimit -= (dwMinutesPast * 60);

    // We will select events as follows:
    // a. Must be within 15 minutes
    // b. Will stop searching at directory start
    // c. Any error in the log will be selected, kcc or not
    // d. Any non-error in my list will be flagged

    dwRet = PrintSelectEvents(&(pDsInfo->pServers[ulCurrTargetServer]),
                              pDsInfo->gpCreds,
                              LOGFILENAME,
                              EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE,
                              paSelectEvents,
                              paBegin,
                              dwTimeLimit,
                              eventlogPrint,
                              foundBeginningEvent,
                              &context );

    if (dwRet) {
        PrintMessage( SEV_ALWAYS, L"Failed to enumerate event log records, error %s\n",
                      Win32ErrToString(dwRet) );
        return dwRet;
    } else if (context.fEventsFound) {
        return ERROR_DS_GENERIC_ERROR;
    } else {
	PrintMessage(SEV_VERBOSE, L"Found no KCC errors in Directory Service Event log in the last %d minutes.\n", dwMinutesPast);
        return ERROR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\ldaputil.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldaputil.h

ABSTRACT:

    This gives shortcuts to common ldap code.

DETAILS:

    This is a work in progress to have convienent functions added as needed
    for simplyfying the massive amounts of LDAP code that must be written for
    dcdiag.

CREATED:

    23 Aug 1999  Brett Shirley

--*/

extern FILETIME gftimeZero;

#include <ntdsa.h>

DWORD
DcDiagGetStringDsAttributeEx(
    LDAP *                          hld,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

LPWSTR
DcDiagTrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    );

BOOL
DcDiagIsStringDnMangled(
    IN  LPWSTR                      pszInDn,
    IN  MANGLE_FOR *                peMangleFor
    );

DWORD
DcDiagGetStringDsAttribute(
    IN  PDC_DIAG_SERVERINFO         prgServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

DWORD
DcDiagGeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime);

// Note this function is destructive in that it modifies the pszStrDn passed in.
DWORD
LdapMakeDSNameFromStringDSName(
    LPWSTR        pszStrDn,
    DSNAME **     ppdnOut
    );

DWORD
LdapFillGuidAndSid(
    LDAP *      hld,
    LPWSTR      pszDn,
    LPWSTR      pszAttr,
    DSNAME **   ppdnOut
    );

void
LdapGetStringDSNameComponents(
    LPWSTR       pszStrDn,
    LPWSTR *     ppszGuid,
    LPWSTR *     ppszSid,
    LPWSTR *     ppszDn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\dstest.h ===
#ifndef DSTEST_H
#define DSTEST_H

DWORD
FinddefaultNamingContext (
    IN  LDAP  *		                hLdap,
	OUT WCHAR **                    ReturnString);


DWORD
FindServerRef (
    IN  LDAP *		                hLdap,
	OUT WCHAR**                     ReturnString);

DWORD
GetMachineReference(
    IN  LDAP  *		                hLdap,
    IN  WCHAR *                     name,
    IN  WCHAR *                     defaultNamingContext,
    OUT WCHAR **                    ReturnString);

DWORD
WrappedTrimDSNameBy(
    IN  WCHAR                       *InString,
    IN  DWORD                       NumbertoCut,
    OUT WCHAR                       **OutString);

void
DInitLsaString(
              PLSA_UNICODE_STRING LsaString,
              LPWSTR String);

DWORD
FindschemaNamingContext (
    IN  LDAP *                      hLdap,
    OUT WCHAR**                     ReturnString);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\alltests.h ===
//+----------------------------------------------------------------------------  
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    alltests.h

ABSTRACT:

    Contains information about each test.

DETAILS:

    To add a new test:
    
    1. Add new DC_DIAG_ID_* for your test.
    2. Add a prototype for new function.
    3. Add entry in allTests[].
    4. Add test specific command line options in to the clOptions array
    
CREATED:

    09 Jul 98    Aaron Siegel (t-asiege)

REVISION HISTORY:

    22 Aug 99    Dmitry Dukat (dmitrydu)
    
        Added support for test specific command line args

--*/

// Prototypes for the test entry functions

#ifndef _ALLTESTS_H_
#define _ALLTESTS_H_

#define DNS_DOMAIN_ARG L"/DnsDomain:"
#define NEW_FOREST_ARG L"/NewForest"
#define NEW_TREE_ARG L"/NewTree"
#define CHILD_DOMAIN_ARG L"/ChildDomain"
#define REPLICA_DC_ARG L"/ReplicaDC"
#define FOREST_ROOT_DOMAIN_ARG L"/ForestRoot:"
#define RECREATE_MACHINE_ACCT_ARG L"/RecreateMachineAccount"
#define FIX_MACHINE_ACCT_ARG L"/FixMachineAccount"

// Constants for names of tests
#define RPC_SERVICE_CHECK_STRING          L"RPC Service Check"
#define REPLICATIONS_CHECK_STRING         L"Replications Check"
#define TOPOLOGY_INTEGRITY_CHECK_STRING   L"Topology Integrity Check"

// Test flags
//    The 4 flags RUN_TEST_PER_SERVER, RUN_TEST_PER_SITE, 
//    RUN_TEST_PER_ENTERPRISE, RUN_TEST_PER_PARTITION should not be used
//    together, or the test will be called once per server, once per site,
//    and once for the enterprise.
//    The 2 flags, CAN_NOT_SKIP_TEST and DO_NOT_RUN_TEST_BY_DEFAULT are also
//    mutually exclusive for obvious reasons.
//    NON_DC_TEST means the test applies to machines that are not (yet) DCs.
#define RUN_TEST_PER_SERVER               0x00000001
#define RUN_TEST_PER_SITE                 0x00000002
#define RUN_TEST_PER_ENTERPRISE           0x00000004
#define CAN_NOT_SKIP_TEST                 0x00000010
#define DO_NOT_RUN_TEST_BY_DEFAULT        0x00000020
#define NON_DC_TEST                       0x00000040
#define RUN_TEST_PER_PARTITION            0x00000080

#define MAX_NUM_OF_ARGS                   50

// Type definitions
typedef enum _DC_DIAG_ID {
    DC_DIAG_ID_INITIAL_CHECK,
    DC_DIAG_ID_REPLICATIONS_CHECK,
    DC_DIAG_ID_TOPOLOGY_INTEGRITY,
    DC_DIAG_ID_CHECK_NC_HEADS,
    DC_DIAG_ID_CHECK_NET_LOGONS,
    DC_DIAG_ID_INTERSITE_HEALTH,
    DC_DIAG_ID_LOCATOR_GET_DC,
    DC_DIAG_ID_GATHER_KNOWN_ROLES,
    DC_DIAG_ID_CHECK_ROLES,
    DC_DIAG_ID_CHECK_RID_MANAGER,
    DC_DIAG_ID_CHECK_DC_MACHINE_ACCOUNT,
    DC_DIAG_ID_CHECK_SERVICES_RUNNING,
    DC_DIAG_ID_CHECK_DC_OUTBOUND_SECURE_CHANNELS,
    DC_DIAG_ID_CHECK_OBJECTS,
    DC_DIAG_ID_TOPOLOGY_CUTOFF,
    DC_DIAG_ID_CHECK_SYSVOL_READY,
    DC_DIAG_ID_CHECK_FILE_REPLICATION_EVENTLOG,
    DC_DIAG_ID_CHECK_KCC_EVENTLOG,
    DC_DIAG_ID_CHECK_SYSTEM_EVENTLOG,
    //DC_DIAG_ID_DNS_JOIN_CHECK, postponed, functionality in netdiag
    DC_DIAG_ID_PRE_PROMO_DNS_CHECK,
    DC_DIAG_ID_REGISTER_DNS_CHECK,
    DC_DIAG_ID_DEAD_CROSS_REF_TEST,
    DC_DIAG_ID_CHECK_SD_REFERENCE_DOMAIN,
    DC_DIAG_ID_VERIFY_INSTANTIATED_REPLICAS,
    DC_DIAG_ID_VERIFY_SYSTEM_REFERENCES,
    DC_DIAG_ID_VERIFY_ENTERPRISE_SYSTEM_REFERENCES,
    // <-- insert new tests here
    DC_DIAG_ID_EXAMPLE,
    DC_DIAG_ID_FINISHED // This MUST be the last enum.
} DC_DIAG_ID;

DWORD ReplUpCheckMain                         (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplReplicationsCheckMain               (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplToplIntegrityMain                   (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplToplCutoffMain                      (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckNcHeadSecurityDescriptorsMain  (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckLogonPrivilegesMain            (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplIntersiteHealthTestMain             (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplLocatorGetDcMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckFsmoRoles                          (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckRolesMain                      (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ExampleMain                             (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckRidManager                         (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckDCMachineAccount                   (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckForServicesRunning                 (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckOutboundSecureChannels             (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckObjectsMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckSysVolReadyMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckFileReplicationEventlogMain        (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckKccEventlogMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckSysEventlogMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
//DWORD JoinDomainDnsCheck                      (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD PrePromoDnsCheck                        (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD RegisterLocatorDnsCheck                 (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ValidateCrossRefTest                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckSDRefDom                           (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD VerifyInstantiatedReplicas              (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD VerifySystemReferences                  (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD VerifyEnterpriseSystemReferences        (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);

#ifdef INCLUDE_ALLTESTS_DEFINITION
const DC_DIAG_TESTINFO allTests[] = {

    // DNS Registration Test -- checks if the DNS names are properly 
    // registered.  This tries to DsBind to each target server by GUID DNS 
    // name.  If it fails, the corresponding pDsInfo->pServers[i].bResponding
    // flag is set FALSE. It then tries other (LDAP) method of binding, and 
    // checks for the DNS name, pingability, etc.
    { DC_DIAG_ID_INITIAL_CHECK, ReplUpCheckMain, 
      RUN_TEST_PER_SERVER | CAN_NOT_SKIP_TEST,
      L"Connectivity",
      L"Tests whether DCs are DNS registered, pingeable, and\n"
      L"\t\thave LDAP/RPC connectivity." },

    // Replications Check Test -- checks to make sure that LDAP is responding 
    // on all servers.  Also checks all replications in all NCs on all 
    // servers, to make sure they are functioning properly.
    { DC_DIAG_ID_REPLICATIONS_CHECK, ReplReplicationsCheckMain,
      RUN_TEST_PER_SERVER,
      L"Replications",
      L"Checks for timely replication between domain controllers." },

    // Topology integrity check -- checks if the topology is properly 
    // connected. This test runs DsReplicaSyncAll on all servers with option
    // DS_REPSYNCALL_DO_NOT_SYNC.  This will check to make sure all servers
    // are "visible" along the graph from all other servers.  The test looks 
    // only at the actual topology defined by each server's config container,
    // without taking into account unresponsive servers (those are handled by
    // earlier tests.)
    { DC_DIAG_ID_TOPOLOGY_INTEGRITY, ReplToplIntegrityMain,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"Topology",
      L"Checks that the generated topology is fully connected for\n"
      L"\t\tall DCs." },

    // Check for servers that are cutoff from changes
    { DC_DIAG_ID_TOPOLOGY_CUTOFF, ReplToplCutoffMain,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"CutoffServers",
      L"Check for servers that won't receive replications\n"
      L"\t\tbecause its partners are down"},

    // Check the Naming Context Heads for appropriate security descriptors 
    // that allow the 3 replication rights (DS-Replication-Get-Changes, 
    // DS-Replication-Syncronize, and DS-Replication-Manage-Topology) to the
    // Enterprise Domain Controllers and the Builtin Administrators.  These 
    // are needed for replication to happen correctly.
    { DC_DIAG_ID_CHECK_NC_HEADS, ReplCheckNcHeadSecurityDescriptorsMain,
      RUN_TEST_PER_SERVER,
      L"NCSecDesc",
      L"Checks that the security descriptosrs on the naming\n"
      L"\t\tcontext heads have appropriate permissions for replication." },

    // Check that 3 users (Authenticated Users, Builtin Administrators, and 
    // World) have the network logon right.  Truely we only should check if
    // Authenticated Users need
    // it for replication purposes.
    { DC_DIAG_ID_CHECK_NET_LOGONS, ReplCheckLogonPrivilegesMain,
      RUN_TEST_PER_SERVER,
      L"NetLogons",
      L"Checks that the appropriate logon priviledges allow\n"
      L"\t\treplication to proceed." },

    // Check whether each DC is advertising itself.
    { DC_DIAG_ID_LOCATOR_GET_DC, ReplLocatorGetDcMain,
      RUN_TEST_PER_SERVER,
      L"Advertising",
      L"Checks whether each DC is advertising itself, and whether\n"
      L"\t\tit is advertising itself as having the capabilities of a DC." },

    // Code.Improvement ...
    // This should be the per server portion of the RoleHolders test, what
    // really needs to happen is that these need to be recorded in pDsInfo,
    // so that later the ENTERPRISE portion of RoleHolders test can be used
    // to verify that everyone things the role holders are the same.
    { DC_DIAG_ID_GATHER_KNOWN_ROLES, CheckFsmoRoles,
      RUN_TEST_PER_SERVER,
      L"KnowsOfRoleHolders",
      L"Check whether the DC thinks it knows the role\n"
      L"\t\tholders, and prints these roles out in verbose mode." },

    // Check for the health of intersite replication. This test will report 
    // any failures in intersite replication, any failures likely to affect
    // intersite replication, and finally when to expect those errors to be
    // corrected.
    { DC_DIAG_ID_INTERSITE_HEALTH, ReplIntersiteHealthTestMain,
      RUN_TEST_PER_ENTERPRISE,
      L"Intersite",
      L"Checks for failures that would prevent or temporarily\n"
      L"\t\thold up intersite replication." },

    // Verify whether role holders can be found via the locator
    // Also verify that FSMO roles are actively held
    { DC_DIAG_ID_CHECK_ROLES, ReplCheckRolesMain,
      RUN_TEST_PER_ENTERPRISE,
      L"FsmoCheck",
      L"Checks that global role-holders are known, can be\n"
      L"\t\tlocated, and are responding." },

    // Check to see if the Rid Manager is accessable and does sanity checks on it
    // Preforms a DsBind with the RID master of the domain.
    // Check to see the target DC's current rid pool is valid, and if there is another
    // rid pool set if the DC is short on RIDs
    { DC_DIAG_ID_CHECK_RID_MANAGER, CheckRidManager,
      RUN_TEST_PER_SERVER, 
      L"RidManager",
      L"Check to see if RID master is accessable and to see if\n"
      L"\t\tit contains the proper information." },
    
    // Does sanity checks on the Domain Controller Machine Account in the ds
    // Check to see if Current DC is in the domain controller's OU
    // Check that useraccountcontrol has UF_SERVER_TRUST_ACCOUNT
    // Check to see if the machine account is trusted for delegation
    // Check's to see if the minimum SPN's are there
    // Makes sure that that the server reference is set up correctly
    { DC_DIAG_ID_CHECK_DC_MACHINE_ACCOUNT, CheckDCMachineAccount,
      RUN_TEST_PER_SERVER,  
      L"MachineAccount",
      L"Check to see if the Machine Account has the proper\n"
      L"\t\tinformation. Use /RecreateMachineAccount to attempt a repair\n"
      L"\t\tif the local machine account is missing. Use /FixMachineAccount\n"
      L"\t\tif the machine account flags are incorrect" },

    //will check to see if the appropriate services are running on a DC.
    { DC_DIAG_ID_CHECK_SERVICES_RUNNING, CheckForServicesRunning,
      RUN_TEST_PER_SERVER,
      L"Services",
      L"Check to see if appropriate DC services are running." },

    // Will check to see if domain has secure channels with the domain that
    // it has an outbound trust with.  Will give reason why a secure channel is not present
    // Will see if the trust is uplevel and if both a trust object and an interdomain trust
    // object exists
    { DC_DIAG_ID_CHECK_DC_OUTBOUND_SECURE_CHANNELS, CheckOutboundSecureChannels,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"OutboundSecureChannels",
      L"See if we have secure channels from all of the\n"
      L"\t\tDC's in the domain the domains specified by /testdomain:.\n"
      L"\t\t/nositerestriction will prevent the test from\n"
      L"\t\tbeing limited to the DC's in the site." },

    // Verify that important objects and their attributes have replicated
    { DC_DIAG_ID_CHECK_OBJECTS, ReplCheckObjectsMain,
      RUN_TEST_PER_SERVER,
      L"ObjectsReplicated",
      L"Check that Machine Account and DSA objects have\n"
      L"\t\treplicated. Use /objectdn:<dn> with /n:<nc> to specify an\n"
      L"\t\tadditional object to check."
    },

    // Check that the File Replication System (frs) SysVol share has been successfully
    // started, and is no longer blocking dcpromo or netlogon advertising.
    { DC_DIAG_ID_CHECK_SYSVOL_READY, CheckSysVolReadyMain,
      RUN_TEST_PER_SERVER,
      L"frssysvol",
      L"This test checks that the file replication system (FRS)\n"
      L"\t\tSYSVOL is ready" }, 

    // Check the File Replication System (frs) eventlog to see that certain critical
    // events have occured and to signal that any fatal events that might have
    // occured.
    { DC_DIAG_ID_CHECK_FILE_REPLICATION_EVENTLOG, CheckFileReplicationEventlogMain,
      RUN_TEST_PER_SERVER,
      L"frsevent",
      L"This test checks to see if there are any operation errors\n"
      L"\t\tin the file replication system (FRS).  Failing replication\n"
      L"\t\tof the SYSVOL share, can cause Policy problems." },

    // Check the Knowledge Consistency Checker (kcc) eventlog to see that certain critical
    // events have occured and to signal that any fatal events that might have
    // occured.
    { DC_DIAG_ID_CHECK_KCC_EVENTLOG, CheckKccEventlogMain,
      RUN_TEST_PER_SERVER,
      L"kccevent",
      L"This test checks that the Knowledge Consistency Checker\n"
      L"\t\tis completing without errors." }, 

    // Check the System eventlog to see that certain critical
    // events have occured and to signal that any fatal events that might have
    // occured.
    { DC_DIAG_ID_CHECK_SYSTEM_EVENTLOG, CheckSysEventlogMain,
      RUN_TEST_PER_SERVER,
      L"systemlog",
      L"This test checks that the system is running without errors." }, 

    // Tests whether the existing DNS infrastructure is sufficient to allow the
    // computer to be joined to a domain specified in <Active Directory Domain
    // DNS Name> and reports if any modifications to the existing infrastructure
    // is required.
    //{ DC_DIAG_ID_DNS_JOIN_CHECK, JoinDomainDnsCheck,
    //  NON_DC_TEST,
    //  L"JoinTest",
    //  L"Tests whether the existing DNS infrastructure is sufficient\n"
    //  L"\t\tto allow the computer to be joined to a domain." },

    // Tests whether the existing DNS infrastructure is sufficient to allow the
    // computer to be promoted to a Domain Controller in a domain specified in
    // <Active Directory Domain DNS Name> and reports if any modifications to
    // the existing infrastructure is required.
    { DC_DIAG_ID_PRE_PROMO_DNS_CHECK, PrePromoDnsCheck,
      NON_DC_TEST,
      L"DcPromo",
      L"Tests the existing DNS infrastructure for promotion to domain\n"
      L"\t\tcontroller. If the infrastructure is sufficient, the computer\n"
      L"\t\tcan be promoted to domain controller in a domain specified in\n"
      L"\t\t<Active_Directory_Domain_DNS_Name>. Reports whether any\n"
      L"\t\tmodifications to the existing DNS infrastructure are required.\n"
      L"\t\tRequired argument:\n"
      L"\t\t/DnsDomain:<Active_Directory_Domain_DNS_Name>\n"
      L"\t\tOne of the following arguments is required:\n"
      L"\t\t/NewForest\n"
      L"\t\t/NewTree\n"
      L"\t\t/ChildDomain\n"
      L"\t\t/ReplicaDC\n"
      L"\t\tIf NewTree is specified, then the ForestRoot argument is\n"
      L"\t\trequired:\n"
      L"\t\t/ForestRoot:<Forest_Root_Domain_DNS_Name>" },

    // Test whether this Domain Controller will be able to register the Domain
    // Controller Locator DNS records that are required to be present in DNS to
    // allow other computers to locate this Domain Controller for the domain.
    { DC_DIAG_ID_REGISTER_DNS_CHECK, RegisterLocatorDnsCheck,
      NON_DC_TEST,
      L"RegisterInDNS",
      L"Tests whether this domain controller can register the\n"
      L"\t\tDomain Controller Locator DNS records. These records must be\n"
      L"\t\tpresent in DNS in order for other computers to locate this\n"
      L"\t\tdomain controller for the <Active_Directory_Domain_DNS_Name>\n"
      L"\t\tdomain. Reports whether any modifications to the existing DNS\n"
      L"\t\tinfrastructure are required.\n"
      L"\t\tRequired argument:\n"
      L"\t\t/DnsDomain:<Active_Directory_Domain_DNS_Name>" },
    
    // Test
    { DC_DIAG_ID_DEAD_CROSS_REF_TEST, ValidateCrossRefTest,
      RUN_TEST_PER_PARTITION,
      L"CrossRefValidation",
      L"This test looks for cross-refs that are in some\n"
      L"\t\tway invalid." },

    // Test
    { DC_DIAG_ID_CHECK_SD_REFERENCE_DOMAIN, CheckSDRefDom,
      RUN_TEST_PER_PARTITION,
      L"CheckSDRefDom",
      L"This test checks that all application directory\n"
      L"\t\tpartitions have appropriate security descriptor reference\n"
      L"\t\tdomains." },

    // Test
    { DC_DIAG_ID_VERIFY_INSTANTIATED_REPLICAS, VerifyInstantiatedReplicas,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"VerifyReplicas",
      L"This test verifys that all application directory\n"
      L"\t\tpartitions are fully instantiated on all replica servers." },

    // Test
    { DC_DIAG_ID_VERIFY_SYSTEM_REFERENCES, VerifySystemReferences,
      RUN_TEST_PER_SERVER,
      L"VerifyReferences",
      L"This test verifys that certain system references\n"
      L"\t\tare intact for the FRS and Replication infrastructure." },

    { DC_DIAG_ID_VERIFY_SYSTEM_REFERENCES, VerifyEnterpriseSystemReferences,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"VerifyEnterpriseReferences",
      L"This test verifys that certain system\n"
      L"\t\treferences are intact for the FRS and Replication\n"
      L"\t\tinfrastructure across all objects in the enterprise\n"
      L"\t\ton each DC." },


#if 0
    // Example:
    // { First field is an enum from DC_DIAG_ID above, 
    //   Second field is a string to reference the function from the command line with,
    //   Third field is the name of a the function that actually performs the test }
    { DC_DIAG_ID_EXAMPLE, ExampleMain,
      0 /* Test flags */,
      L"ShortExampleTestName", L"Long example description ...." },
#endif


    // Finished signal -- not a test; informs the main program to terminate execution
    { DC_DIAG_ID_FINISHED, NULL,
      0,
      NULL, NULL } 
};

//list of command line switches that are specific to individual tests.
const WCHAR *clOptions[] = 
{
    //command for CheckOutboundSecureChannels allows you to enter the domain flatname
    {L"/testdomain:"},
    
    //command for CheckOutboundSecureChannels allows you test all the DC even the 
    //ones outside the site
    {L"/nositerestriction"},

    // User specified object dn to check during CheckObjects
    { L"/objectdn:" },

    // User has asked for the machine account to be fixed
    { RECREATE_MACHINE_ACCT_ARG }, { FIX_MACHINE_ACCT_ARG },

    // JoinTest, DCPromo require a DNS domain name
    { DNS_DOMAIN_ARG },

    // DCPromo test requires one of the following options.
    { NEW_FOREST_ARG }, { NEW_TREE_ARG }, { CHILD_DOMAIN_ARG }, { REPLICA_DC_ARG },

    // DCPromo test option required if NEW_TREE_ARG is specified
    { FOREST_ROOT_DOMAIN_ARG },

    //add more options here
    
    //terminator
    {NULL}
};

#else // #ifdef INCLUDE_ALLTESTS_DEFINITION
extern const DC_DIAG_TESTINFO allTests[];
#endif // #else // #ifdef INCLUDE_ALLTESTS_DEFINITION

#endif    // _ALLTESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\list.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    list.h

ABSTRACT:

    Function decls, for list functions.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:


NOTES:

    This is a "pure" list function, in that it returns NULL, or a memory address.  If
    it returns NULL, then GetLastError() should have the error, even if another pure
    list function was called in the mean time.  If not it is almost certainly a memory
    error, as this is the only thing that can go wrong in pure list functions.  The pure
    list functions return a NO_SERVER terminated list.  The function always returns the
    pointer to the list.  Note most of the list functions modify one of the lists they
    are passed and passes back that pointer, so if you want the original contents, make
    a copy with IHT_CopyServerList().

--*/


DWORD
IHT_PrintListError(
    DWORD                               dwErr
    );

VOID
IHT_PrintServerList(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );

PULONG
IHT_GetServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

PULONG
IHT_GetEmptyServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

BOOL
IHT_ServerIsInServerList(
    PULONG                              piServers,
    ULONG                               iTarget
    );

PULONG
IHT_AddToServerList(
    PULONG                             piServers,
    ULONG                              iTarget
    );

PULONG
IHT_TrimServerListBySite(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iSite,
    PULONG                              piServers
    );

PULONG
IHT_TrimServerListByNC(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials,
    PULONG                              piServers
    );

PULONG
IHT_AndServerLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc1,
    IN      PULONG                      piSrc2
    );

PULONG
IHT_CopyServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_NotServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_OrderServerListByGuid(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\dscache.h ===
/*++

Copyright (c) 2001 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dscache.h

ABSTRACT:

    This is the header for the globally useful cache data structures for the entire
    dcdiag.exe utility.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

    8  Aug 2001 Brett Shirley (BrettSh)
        Added support for CR cache.

--*/

#ifndef _DSCACHE_H_
#define _DSCACHE_H_

#include <ntdsa.h>

typedef struct {
    LPWSTR                 pszNetUseServer;
    LPWSTR                 pszNetUseUser;
    NETRESOURCE            NetResource;
    LSA_OBJECT_ATTRIBUTES  ObjectAttributes;
    LSA_UNICODE_STRING     sLsaServerString;
    LSA_UNICODE_STRING     sLsaRightsString;
} NETUSEINFO;

typedef struct {
    LPWSTR      pszDn;
    LPWSTR      pszName;
    UUID        uuid;
    UUID        uuidInvocationId;
    LPWSTR      pszGuidDNSName;
    LPWSTR      pszDNSName;
    LPWSTR      pszComputerAccountDn;
    LPWSTR *    ppszMasterNCs; //8
    LPWSTR *    ppszPartialNCs;
    LPWSTR      pszCollectedDsServiceName; // May not be set ... set by initial tests.
    ULONG       iSite;
    INT         iOptions;  //11
    BOOL        bIsSynchronized;
    BOOL        bIsGlobalCatalogReady;
    BOOL        bDnsIpResponding;    // Set by UpCheckMain
    BOOL        bLdapResponding;     // Set by UpCheckMain
    BOOL        bDsResponding;       // Set by UpCheckMain ... as in the Rpc is responding by DsBind..()
    LDAP *      hLdapBinding;   // Access this through the DcDiagLdapOpenAndBind() function.
    LDAP *      hGcLdapBinding;   // Access this through the DcDiagLdapOpenAndBind() function.
    HANDLE      hDsBinding;   // Access this through the DcDiagDsBind() function.
    NETUSEINFO  sNetUseBinding;
    DWORD       dwLdapError;
    DWORD       dwGcLdapError;
    DWORD       dwDsError;
    DWORD       dwNetUseError;
    USN         usnHighestCommittedUSN;
    // BUGBUG these FILETIME fields must be right after this USN, because
    // the USN is forcing proper alignment of these fields for when they are
    // cast to LONGLONGs by some bad operations.
    FILETIME    ftRemoteConnectTime; // Remote time when connect occurred
    FILETIME    ftLocalAcquireTime; // Local time when timestamp taken
} DC_DIAG_SERVERINFO, * PDC_DIAG_SERVERINFO;

// These are possible sources for an instance of CRINFO, to be used 
// in DC_DIAG_CRINFO.dwFlags, and to be used when requesting a
// specific source for CRINFO via the primary access function
// DcDiagGetCrossRefInfo()
//
// These 4 constants describe where this CrInfo came from.
#define CRINFO_SOURCE_HOME              (0x00000001) // from dcdiag "home" server
#define CRINFO_SOURCE_FSMO              (0x00000002) // from Domain Naming FSMO
#define CRINFO_SOURCE_FIRST             (0x00000004) // from first replica of NC
#define CRINFO_SOURCE_OTHER             (0x00000008) // from any one (not used currently)
// These are not used in dwFlags in the DC_DIAG_CRINFO structure, these are used
// for access functions.
#define CRINFO_SOURCE_AUTHORITATIVE     (0x00000010) // gets the authoritative CR data
#define CRINFO_SOURCE_ANY               (0x00000020) // no preference

// The access functions will perform LDAP operations (i.e. go off machine) to
// retrieve the requested information
#define CRINFO_RETRIEVE_IF_NEC          (0x00000080)
// Normally only a subset of the fields are filled in for the CrInfo, if you 
// pass one of these flags we retrieve more fields for the CrInfo.
#define CRINFO_DATA_NO_CR               (0x00000100) // When there is no CR on this source
#define CRINFO_DATA_BASIC               (0x00000200) // The basic data see CRINFO data structure
#define CRINFO_DATA_EXTENDED            (0x00000400) // Currently just ftWhenCreated
#define CRINFO_DATA_REPLICAS            (0x00000800) // Gets Replica List



#define CRINFO_SOURCE_ALL_BASIC         (CRINFO_SOURCE_HOME | CRINFO_SOURCE_FSMO | CRINFO_SOURCE_FIRST | CRINFO_SOURCE_OTHER)
#define CRINFO_SOURCE_ALL               (CRINFO_SOURCE_ALL_BASIC | CRINFO_SOURCE_AUTHORITATIVE | CRINFO_SOURCE_ANY)
#define CRINFO_DATA_ALL                 (CRINFO_DATA_BASIC | CRINFO_DATA_EXTENDED | CRINFO_DATA_REPLICAS)


// Return values for access functions.  Used by DcDiagGetCrossRefInfo() and
// it's helper functions (DcDiagRetriveCrInfo() and DcDiagGetCrInfoBinding())
#define CRINFO_RETURN_SUCCESS          0
#define CRINFO_RETURN_OUT_OF_SCOPE     1
#define CRINFO_RETURN_LDAP_ERROR       2
#define CRINFO_RETURN_BAD_PROGRAMMER   3
#define CRINFO_RETURN_FIRST_UNDEFINED  4
#define CRINFO_RETURN_MIXED_INDEX      5
#define CRINFO_RETURN_NEED_TO_RETRIEVE 6
#define CRINFO_RETURN_NO_CROSS_REF     7

// -----------------------------------------------------------------
//   After the initial pull of data all of the CrInfo structures
//   will be in one of these two states.

//
// Blank CR (rare)
//     dwFlags = (CRINFO_SOURCE_HOME | CRINFO_DATA_NO_CR);

//
// Home CR
//     dwFlags = (CRINFO_SOURCE_HOME | CRINFO_DATA_BASIC);
//     // Basic data, like pszDn, ulSystemFlags, pszDnsRoot, bEnabled, etc

//
// Later calls to DcDiagGetCrInfo() can push other CRINFO
// structures into the aCrInfo array for an NC.
//

typedef struct _DC_DIAG_CRINFO{
    
    // dwFlags is always valid, and when no other data is set then dwFlags
    // should be set to CRINFO_DATA_NO_CR | CRINFO_SOURCE_HOME.  Otherwise the
    // fields can be requested to be filled in by specifying the constant above
    // the fields you desire.  A fully filled CrInfo struct would have all the
    // CRINFO_DATA_* bits set, i.e. they're not exclusive.
    //
    // If you want to add an attribute to the cross ref cache under any 
    // CRINFO_DATA_* flag.
    //  DcDiagPullLdapCrInfo() - Pull info out of LDAP entry and put in pCrInfo struct.
    //  DcDiagRetrieveCrInfo() - Add to the list of ppszBasicAttrs to pull from the CR.
    //  DcDiagMergeCrInfo() - Merge data into new pCrInfo.
    //  DcDiagPrintCrInfo() - For debugging only.
    //  DcDiagFreeDsInfo() - Free any added cross-ref fields.
    //  DcDiagGenerateNCsListCrossRefInfo() - Only for CRINFO_DATA_BASIC info ..
    //                     Add to the list ppszCrossRefSearch to pull from the CR.

    // ----------------------------------------
    // Record keeping information about where this CRINFO came from, what is
    // currently cached etc.
    DWORD       dwFlags;
    
    // ----------------------------------------
    // retrieved with CRINFO_DATA_BASIC
    // ----------------------------------------
    // The reason this data is considered basic, is because it's the minimum
    // set of information to determine some basic information like:
    //      A) this CR is the authoritative CR or not.
    //      B) whether this is an external or internal (to the AD) cross-reference.
    //      C) whether this NC is in use yet.
    //
    // Only _ONE_ of these next two variables will be defined on any given 
    // CrInfo structure. Note pszServerSource should only be defined, if the
    // server couldn't be found in pDsInfo->pServers array, otherwise we just
    // use the index into the server array to get at the good LDAP binding
    // handle cache.
    LONG        iSourceServer; // -1 not defined. otherwise index into pDsInfo->pServers
    LPWSTR      pszSourceServer; // NULL not defined, otherwise a pointer to a dns name.
    // DN of the cross-ref itself.
    LPWSTR      pszDn; // CR DN.

    // Basic CR information that is needed by several tests to distinguish
    // NDNCs from Domain NCs and which server this NC belongs to initially.
    ULONG       ulSystemFlags; // CR systemFlags attribute.
    LPWSTR      pszDnsRoot; // CR dNSRoot attribute
    BOOL        bEnabled; // CR enabled attribute, if enable attr is not on CR, CR is considered enabled.

    // ----------------------------------------
    // retrieved with CRINFO_DATA_EXTENTDED
    // ----------------------------------------
    FILETIME    ftWhenCreated;
    LPWSTR      pszSDReferenceDomain;
    LPWSTR      pszNetBiosName;
    DSNAME *    pdnNcName; // a true DSNAME!!!
    // May need these some day!
    //LONG        iFirstReplicaDelay; // maybe should use the optional values from ndnc.lib
    //LONG        iSubsequentReplicaDelay;

    // ----------------------------------------
    // retrieved with CRINFO_DATA_REPLICAS
    // ----------------------------------------
    // This is the list of replicas we will use.
    LONG        cReplicas; 
    LPWSTR *    aszReplicas;

    // Adding a field for this CR struct would require you update:
    // This DC_DIAG_CRINFO struct, DcDiagPullLdapCrInfo(), DcDiagRetrieveCrInfo(),
    //      DcDiagFreeDsInfo(), MergeCrInfo(). DcDiagFillBlankCrInfo(), and
    //      optionally DcDiagPrintDcInfo().
    //
} DC_DIAG_CRINFO, * PDC_DIAG_CRINFO;

typedef struct {
    LPWSTR      pszDn;
    LPWSTR      pszName;

    // So when dcdiag was first engendered, I was young and had a lack
    // of foresight, and didn't plan for the multiple views that we 
    // could acheive by talking to different servers.  For example we
    // could learn of a server (DC) or naming context (NC) that isn't
    // represented in our initial data collection of the enterprise info.
    //
    // Anyway, this is the first structure that needs/tries to be 
    // version aware.  This array of DC_DIAG_CRINFOs is an array of
    // the same data, taken from different server's perspectives.  When
    // updated, always update the array first, then the count.  The 
    // array should always have the same order that it had formerly,
    // so that people can save indexes into this array. i.e. new 
    // entries are effectively appended onto the end of the array.
    // Also the array should ALWAYS have at least one entry, though
    // that entry maybe blank (CRINFO_SOURCE_HOME | CRINFO_DATA_NO_CR)
    // set in it's dwFlags.
    LONG            cCrInfo;
    PDC_DIAG_CRINFO aCrInfo;
} DC_DIAG_NCINFO, * PDC_DIAG_NCINFO;

typedef struct {
    LPWSTR      pszSiteSettings;
    LPWSTR      pszName;
    INT         iSiteOptions;
    LPWSTR      pszISTG;
    DWORD       cServers;
} DC_DIAG_SITEINFO, * PDC_DIAG_SITEINFO;

typedef struct {
    LDAP *	                    hld; //1
    // Specified on command line
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds;
    ULONG                       ulFlags;
    LPWSTR                      pszNC;
    ULONG                       ulHomeServer;
    ULONG                       iHomeSite; //6
    
    // Target Servers
    ULONG                       ulNumTargets;
    ULONG *                     pulTargets;
    // Target NCs
    ULONG                       cNumNcTargets;
    ULONG *                     pulNcTargets;

    //         Enterprise Info ---------------
    // All the servers
    ULONG                       ulNumServers; //12
    PDC_DIAG_SERVERINFO         pServers;
    // All the sites
    ULONG                       cNumSites;
    PDC_DIAG_SITEINFO           pSites;
    // All the naming contexts
    ULONG                       cNumNCs; //16
    PDC_DIAG_NCINFO             pNCs;
    // Other Stuff
    INT                         iSiteOptions;
    LPWSTR                      pszRootDomain;
    LPWSTR                      pszRootDomainFQDN; //20
    LPWSTR                      pszConfigNc;
    DWORD                       dwTombstoneLifeTimeDays;
    LPWSTR                      pszSmtpTransportDN;
    
    // iDomainNamingFsmo will be valid if the Domain Naming FSMO server
    // is somewhere in pServers, otherwise we'll just leave the LDAP *
    // for the Domain Naming FSMO in hCachedDomainNamingFsmoLdap and the
    // server name in pszDomainNamingFsmo.
    LONG                        iDomainNamingFsmo;
    LPWSTR                      pszDomainNamingFsmo;
    LDAP *                      hCachedDomainNamingFsmoLdap;
    // Code.Improvement we've got alot of server references where the
    // server reference is either a string server name or a index into 
    // pServers, so at some point we may want to make a server reference
    // struct that contains both of these, and has good access clever
    // access functions.

    LONG                        iConfigNc; // index into pNCs
    LONG                        iSchemaNc; // index into pNCs

    // Contain information from the CommandLine that
    // will be parsed by tests that required information
    // specific to them.  Switches must be declared in
    // alltests.h
    LPWSTR                      *ppszCommandLine;  
    DWORD                       dwForestBehaviorVersion;
    LPWSTR                      pszPartitionsDn;
} DC_DIAG_DSINFO, * PDC_DIAG_DSINFO;

typedef struct {
    INT                         testId;
    DWORD (__stdcall *	fnTest) (DC_DIAG_HANDLE);
    ULONG                       ulTestFlags;
    LPWSTR                      pszTestName;
    LPWSTR                      pszTestDescription;
} DC_DIAG_TESTINFO, * PDC_DIAG_TESTINFO;

// Function prototypes

#define NO_SERVER               0xFFFFFFFF
#define NO_SITE                 0xFFFFFFFF
#define NO_NC                   0xFFFFFFFF

ULONG
DcDiagGetServerNum(
    PDC_DIAG_DSINFO            pDsInfo,
    LPWSTR                      pszName,
    LPWSTR                      pszGuidName,
    LPWSTR                      pszDsaDn,
    LPWSTR                      pszDNSName,
    LPGUID                      puuidInvocationId 
    );

VOID *
GrowArrayBy(
    VOID *            pArray, 
    ULONG             cGrowBy, 
    ULONG             cbElem
    );

ULONG
DcDiagGetMemberOfNCList(
    LPWSTR pszTargetNC,
    PDC_DIAG_NCINFO pNCs,
    INT iNumNCs
    );

DWORD
DcDiagGetCrossRefInfo(
    IN OUT PDC_DIAG_DSINFO                     pDsInfo,
    IN     DWORD                               iNC,
    IN     DWORD                               dwFlags,
    OUT    PLONG                               piCrVer,
    OUT    PDWORD                              pdwError
    );

ULONG
DcDiagGetCrSystemFlags(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iNc
    );

ULONG
DcDiagGetCrEnabled(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iNc
    );

BOOL
DcDiagIsNdnc(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iNc
    );

VOID
DcDiagPrintCrInfo(
    PDC_DIAG_CRINFO  pCrInfo,
    WCHAR *          pszVar
    );

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    );

DWORD
DcDiagGatherInfo (
    LPWSTR                           pszServerSpecifiedOnCommandLine,
    LPWSTR                           pszNCSpecifiedOnCommandLine,
    ULONG                            ulFlags,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds,
    PDC_DIAG_DSINFO                  pDsInfo
    );

VOID
DcDiagPrintDsInfo(
    PDC_DIAG_DSINFO pDsInfo
    );

VOID
DcDiagFreeDsInfo (
    PDC_DIAG_DSINFO        pDsInfo
    );

DWORD
DcDiagGenerateNCsList(
    PDC_DIAG_DSINFO                     pDsInfo,
    LDAP *                              hld
    );

BOOL
fIsOldCrossRef(
    PDC_DIAG_CRINFO   pCrInfo,
    LONGLONG          llThreshold
    );

// Need this to create the SMTP Transport DN in DcDiagGatherInfo()
#define WSTR_SMTP_TRANSPORT_CONFIG_DN  L"CN=SMTP,CN=Inter-Site Transports,CN=Sites,"

#endif  // _DSCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_EXAMPLE_STRING                 1000

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\repl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    repl.h

ABSTRACT:

    This function contains some foward decls for some useful functions scattered 
    through the dcdiag framework.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:

    Code.Improvement ... to put DcDiagHasNC in some more generic header file, 
    and to make sure that dcdiag is developing in a coherent fashion towards a
    nice clean structure.

--*/

INT 
ReplServerConnectFailureAnalysis(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
    );

BOOL
DcDiagHasNC(
    LPWSTR                          pszNC,
    PDC_DIAG_SERVERINFO             pServer,
    BOOL                            bMasters,
    BOOL                            bPartials
    );

BOOL
IsDomainNC(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\references.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    references.h

ABSTRACT:

    This is the API and data structures, used for the 
    ReferentialIntegerityChecker().

DETAILS:

CREATED:

    11/15/2001  Brett Shirley (BrettSh)

REVISION HISTORY:

    11/15/2001  BrettSh - Created

--*/

//
// The test flags, filled in LNK_ENTRY.dwFlags by client
//
#define REF_INT_TEST_SRC_BASE               0x0001
#define REF_INT_TEST_SRC_STRING             0x0002
#define REF_INT_TEST_SRC_INDEX              0x0004
#define REF_INT_TEST_FORWARD_LINK           0x0010
#define REF_INT_TEST_BACKWARD_LINK          0x0020
#define REF_INT_TEST_BOTH_LINKS             0x0040
#define REF_INT_TEST_GUID_AND_SID           0x0080

//
// The result flags, filled in LNK_ENTRY.dwResultFlags by Engine
//                                              
#define REF_INT_RES_DELETE_MANGLED          0x0001
#define REF_INT_RES_CONFLICT_MANGLED        0x0002
#define REF_INT_RES_ERROR_RETRIEVING        0x0004
#define REF_INT_RES_DEPENDENCY_FAILURE      0x0008
#define REF_INT_RES_BACK_LINK_NOT_MATCHED   0x0010



//
// Table entry
//
typedef struct {

    // -----------------------------------------------------------
    // How to run the test (IN PARAM, user fills)
    //
    // User must fill in these with the REF_INT_TEST_* flags, user must specify
    // one and only one REF_INT_TEST_SRC_* flag, and must specify one and only
    // one of (REF_INT_TEST_FORWARD_LINK or REF_INT_TEST_BACKWARD_LINK), and 
    // the last flag may specified if the users wishes.
    DWORD           dwFlags;
    
    // -----------------------------------------------------------
    // Source options (IN PARAM, user fills)
    //
    // User fills these in for how they wish to drive the engine forward.  The
    // *_BASE source flag can be used to pull and attribute off the rootDSE.
    LPWSTR          szSource; // A pure string source to use as the original 
                              // source, use this in conjunction with the 
                              // REF_INT_TEST_SRC_STRING flag.
    ULONG           iSource;  // Index into the table you passed to pull the 
                              // original source from, must be used
                              // with the REF_INT_TEST_SRC_INDEX flag
    ULONG           cTrimBy;  // Number of RDNs to trim off original source, 
    LPWSTR          szSrcAddl; // String to pre-pend to the original source,
                               // after the cTrimBy has been applied, Ex:
                               // L"CN=NTDS Settings,"

    // -----------------------------------------------------------
    // The Link or DN attributes we want to look at (IN PARAM, user fills)
    //
    // These are the attributes to actually follow to drive the engine, If the 
    // REF_INT_TEST_FORWARD_LINK is specified in the dwFlags than the  
    // szFwdDnAttr attribute must be secified, if REF_INT_TEST_BACKWARD_LINK is
    // specified the szBwdDnAttr attribute must be specified.  If 
    // REF_INT_TEST_BOTH_LINKS is specified, both of these fields must be 
    // specified (i.e. valid LDAP attribute)
    LPWSTR          szFwdDnAttr;
    LPWSTR          szBwdDnAttr;

    // -----------------------------------------------------------
    // Out Parameters (OUT, PARAM, Leave blank)
    //
    // Caller responsible for freeing these values by calling the function:
    // ReferentialIntegrityEngineCleanTable()
    DWORD           dwResultFlags; 
         // DELETE_MANGLED
         // CONFLICT_MANGLED
         // ERROR_RETRIEVING
         // GC_ERROR_RETRIEVING
         // DEPENDENCY_FAILURE
         // BACK_LINK_NOT_MATCHED

    LPWSTR *        pszValues;   // LDAP allocated
    LPWSTR          szExtra; 	  // LocalAlloc()'d
} REF_INT_LNK_ENTRY, * REF_INT_LNK_TABLE;


void
ReferentialIntegrityEngineCleanTable(
    ULONG                cLinks,
    REF_INT_LNK_TABLE    aLink
    );


DWORD
ReferentialIntegrityEngine(
    PDC_DIAG_SERVERINFO  pServer,
    LDAP *               hLdap,
    BOOL                 bIsGc,
    ULONG                cLinks,
    REF_INT_LNK_TABLE    aLink
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\intersite.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    intersite.c

ABSTRACT:

    Contains tests related to checking the health of intersite replication.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:


NOTES:

    The heart of this test lies in the following functions (organized by who 
    calls who), for each site and NC do this:

        ReplIntersiteDoOneSite(
            ReplIntersiteGetISTGInfo(
                IHT_GetOrCheckISTG(
                    IHT_GetNextISTG(
            ReplIntersiteCheckBridgeheads(
            ReplIntersiteSiteAnalysis(

    This is basically it, everything else is really a helper type function, that
    either checks for something, creates a list, modifies a list, or get some
    parameter from a server.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>
//#include <mdglobal.h>

//Want to #include "..\kcc\kcc.hxx", but couldn't get it to work, plus
//   it is in C++ and this will hissy fit over it. So the evil of all evils
//   a copy.
// Code.Improvement move these constants to dsconfig.h, so I can 
//   #include them from dsconfig
#define KCC_DEFAULT_SITEGEN_FAILOVER           (60) // Minutes.
#define KCC_DEFAULT_SITEGEN_RENEW              (30) // Minutes.

#define KCC_DEFAULT_INTERSITE_FAILOVER_TRIES   (1)
#define KCC_MIN_INTERSITE_FAILOVER_TRIES       (0)
#define KCC_MAX_INTERSITE_FAILOVER_TRIES       (ULONG_MAX)

#define KCC_DEFAULT_INTERSITE_FAILOVER_TIME    (2 * HOURS_IN_SECS) // Seconds
#define KCC_MIN_INTERSITE_FAILOVER_TIME        (0)                 // Seconds
#define KCC_MAX_INTERSITE_FAILOVER_TIME        (ULONG_MAX)         // Seconds

// Used in the ReplIntersiteGetBridgeheadsList().
#define LOCAL_BRIDGEHEADS       0x1
#define REMOTE_BRIDGEHEADS      0x2

#define FAILOVER_INFINITE                0x0FFFFFFF

#include "dcdiag.h"
#include "repl.h"
#include "list.h"
#include "utils.h"

typedef struct {
    ULONG        iNC;
    BOOL         bMaster;
} TARGET_NC, * PTARGET_NC;

typedef struct {
    ULONG                               iSrc;
    ULONG                               iDst;
} CONNECTION_PAIR, * PCONNECTION_PAIR;

typedef struct {
    BOOL           bFailures;
    BOOL           bDown;
    LONG           lConnTriesLeft; // connection failures til KCC declares down.
    LONG           lLinkTriesLeft; // link failures til KCC declares down.
    LONG           lConnTimeLeft; // time til KCC declares down from first connnection failure.
    LONG           lLinkTimeLeft; // time til KCC declares down from first link failure.
} KCCFAILINGSERVERS, *PKCCFAILINGSERVERS;


PDSNAME 
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    );

DWORD
IHT_PrintInconsistentDsCopOutError(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iServer,
    LPWSTR                              pszServer
    )
/*++

Description:

    This prints the generic error from having different DS information
    on different DCs.  This handles that error.

Parameters:
    pDsInfo
    iServer or pszServer are optional parameters that describe what DC the
        extra inconsistent info was found on.

Return Value:
    The Win32 error.

  --*/
{
    DWORD                               dwRet;
    
    if((pszServer == NULL && iServer == NO_SERVER)
       || (iServer == pDsInfo->ulHomeServer)){
        // Don't know any servers, so bail badly.
        

        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_INCONSISTENT_DS_COPOUT_UNHELPFUL);
        return(ERROR_DS_CODE_INCONSISTENCY); 
    }
    
    // Server is set in either pszServer, or iServer.
    if(iServer != NO_SERVER){
        // Server is set in iServer, so don't use pszServer
        pszServer = pDsInfo->pServers[iServer].pszName;
    }
    
    PrintMsg(SEV_ALWAYS, 
             DCDIAG_INTERSITE_INCONSISTENT_DS_COPOUT_HOME_SERVER_NOT_IN_SYNC,
             pDsInfo->pServers[pDsInfo->ulHomeServer].pszName,
             pszServer);
    
    return(ERROR_DS_CODE_INCONSISTENCY); 
}

DSTIME
IHT_GetSecondsSince1601()
/*++

Description:

    This function just gets the seconds since 1601, as easy as that.

Return Value:

    a DSTIME, that is the seconds since 1601.

  --*/
{
    SYSTEMTIME sysTime;
    FILETIME   fileTime;
    DSTIME  dsTime = 0, tempTime = 0;

    GetSystemTime( &sysTime );

    // Get FileTime
    SystemTimeToFileTime(&sysTime, &fileTime);

    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    return(dsTime/(10*1000*1000L));
}

VOID
IHT_FreeConnectionList(
    PCONNECTION_PAIR                    pConnections
    )
/*++

Description:

    This frees the pConnections array.  Note this is unnecessary right now, but
    just in case later we want to store more in a connection's list.

Parameters:

    pConnections - 

  --*/
{
    ULONG                               ii;

    if(pConnections == NULL){
        return;
    }
    for(ii = 0; pConnections[ii].iSrc != NO_SERVER; ii++){
        // free any per connection allocated items ...none yet, but maybe soon.
    }

    LocalFree(pConnections);
}

PCONNECTION_PAIR
IHT_GetConnectionList(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      LDAP *                      hld,
    IN      ULONG                       iSite
    )
/*++

Description:

    This returns a array of ULONG pairs with a iSrc, and iDst field, for
    the two sides of a connection object.  This returns all connection
    objects with destinations in iSite.

Parameters:

    pDsInfo ... this is how we get at the GUIDs.
    hld ... an LDAP handle to the appropriate server that you want to read
                 the connection objects off of
    iSite ... the site to read all the connection objects for.

Return Value:
  
    Not a pure list function, it returns NULL or an array of 
    CONNECTION_PAIRs.  If it returns NULL, SetLastError should
    have been called.

  --*/
{
    LPWSTR                              ppszConnectionSearch [] = {
        L"enabledConnection",
        L"objectGUID",
        L"fromServer",
        L"distinguishedName",
        NULL };
    LDAPMessage *                       pldmEntry = NULL;
    LDAPMessage *                       pldmConnResults = NULL;
    LPWSTR *                            ppszTemp = NULL;
    DWORD                               dwRet;
    ULONG                               ii, cNumConn, iTempServer;
    ULONG                               iTargetConn = 0;
    PDSNAME                             pdsnameSite = NULL;
    PDSNAME                             pdsnameSiteSettings = NULL;
    PDSNAME                             pdsnameConnection = NULL;
    PDSNAME                             pdsnameServer = NULL;
    PCONNECTION_PAIR                    pConnections = NULL;
    LDAPSearch *                        pSearch = NULL;
    ULONG                               ulTotalEstimate = 0;
    DWORD                               dwLdapErr;

    __try {
    

        SetLastError(ERROR_SUCCESS);

        pdsnameSiteSettings = 
            DcDiagAllocDSName (pDsInfo->pSites[iSite].pszSiteSettings);
        DcDiagChkNull( pdsnameSite = (PDSNAME) LocalAlloc (LMEM_FIXED, 
                                       pdsnameSiteSettings->structLen));
        TrimDSNameBy (pdsnameSiteSettings, 1, pdsnameSite);
        
        // Can connect to supposed ISTG.    

        pSearch = ldap_search_init_page(hld,
                                        pdsnameSite->StringName,
                                        LDAP_SCOPE_SUBTREE,
                                        L"(&(objectCategory=nTDSConnection)(enabledConnection=TRUE))",
                                        ppszConnectionSearch,
                                        FALSE, NULL, NULL, 0, 0, NULL);
        if(pSearch == NULL){
            dwLdapErr = LdapGetLastError();
            SetLastError(LdapMapErrorToWin32(dwLdapErr));
            pConnections = NULL;
            __leave;
        }
                  
        dwLdapErr = ldap_get_next_page_s(hld, 
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmConnResults);
        if(dwLdapErr == LDAP_NO_RESULTS_RETURNED){
            SetLastError(ERROR_DS_OBJ_NOT_FOUND);
            pConnections = NULL;
            __leave;
        }

        while(dwLdapErr == LDAP_SUCCESS){

            pConnections = (PCONNECTION_PAIR) GrowArrayBy(pConnections,
                       ldap_count_entries(hld, pldmConnResults) + (ULONG)1,
                                       sizeof(CONNECTION_PAIR));
            if(pConnections == NULL){
                // Error should have been set by LocalAlloc in GrowArrayBy().
                pConnections = NULL;
                __leave;
            }

            pldmEntry = ldap_first_entry(hld, pldmConnResults);
            for(; pldmEntry != NULL; iTargetConn++){
                // First get destination server.
                ppszTemp = ldap_get_valuesW(hld, pldmEntry, 
                                            L"distinguishedName");
                if(ppszTemp == NULL){
                    IHT_FreeConnectionList(pConnections);
                    pConnections = NULL;
                    __leave;
                }
                // DcDiagAllocDSName will throw an exception on allocation failure.
                pdsnameConnection = DcDiagAllocDSName (ppszTemp[0]);
                DcDiagChkNull( pdsnameServer = (PDSNAME) LocalAlloc 
                               (LMEM_FIXED, pdsnameConnection->structLen));
                TrimDSNameBy (pdsnameConnection, 1, pdsnameServer);       
                if((iTempServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                                     pdsnameServer->StringName,
                                                     NULL,NULL))
                   != NO_SERVER){
                    // Setting the connection's destination.
                    pConnections[iTargetConn].iDst = iTempServer;
                } else {
                    IHT_FreeConnectionList(pConnections);
                    SetLastError(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                                    NO_SERVER,
                                                                    NULL));
                    pConnections = NULL;
                    __leave;
                }
                ldap_value_freeW(ppszTemp);
                ppszTemp = NULL;

                // Now get source server.
                ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"fromServer");
                if(ppszTemp == NULL){
                    pConnections[iTargetConn].iDst = NO_SERVER;
                    IHT_FreeConnectionList(pConnections);
                    if(GetLastError() == ERROR_SUCCESS){
                        SetLastError(ERROR_DS_CANT_RETRIEVE_ATTS);
                    } 
                    pConnections = NULL;
                    __leave;
                }
                if((iTempServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                                     ppszTemp[0], NULL, NULL))
                   != NO_SERVER){
                    // Setting the connection's source.
                    pConnections[iTargetConn].iSrc = iTempServer; 
                } else {
                    pConnections[iTargetConn].iDst = NO_SERVER;
                    IHT_FreeConnectionList(pConnections);
                    SetLastError(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                                    NO_SERVER, 
                                                                    NULL));
                    pConnections = NULL;
                    __leave;
                }
                ldap_value_freeW(ppszTemp);
                ppszTemp = NULL;

                if(pdsnameConnection != NULL) { LocalFree(pdsnameConnection); }
                pdsnameConnection = NULL;
                if(pdsnameServer != NULL) { LocalFree(pdsnameServer); }
                pdsnameServer = NULL;

                pldmEntry = ldap_next_entry (hld, pldmEntry);
            } // End for each connection object loop
    
            ldap_msgfree(pldmConnResults);

            dwLdapErr = ldap_get_next_page_s(hld,
                                             pSearch,
                                             0,
                                             DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                             &ulTotalEstimate,
                                             &pldmConnResults);
        } // End of while loop for a page of searches
        if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
            SetLastError(LdapMapErrorToWin32(dwLdapErr));
            pConnections = NULL;
            __leave;
        }

        ldap_search_abandon_page(hld, pSearch);

        pConnections[iTargetConn].iSrc = NO_SERVER;
        pConnections[iTargetConn].iDst = NO_SERVER;
        
    } __finally {

        if(pdsnameSiteSettings != NULL) { LocalFree(pdsnameSiteSettings); }
        if(pdsnameSite != NULL) { LocalFree(pdsnameSite); }
        if(pdsnameConnection != NULL) { LocalFree(pdsnameConnection); }
        if(pdsnameServer != NULL) { LocalFree(pdsnameServer); }
        if(ppszTemp != NULL) { ldap_value_freeW(ppszTemp); }
        if(pldmConnResults != NULL) { ldap_msgfree(pldmConnResults); }

    }
    
    return(pConnections);
}

PCONNECTION_PAIR
IHT_TrimConnectionsForInterSite(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iSite,
    IN      PCONNECTION_PAIR            pConnections
    )
/*++

Description:

    This simply takes a Connections objects list, and kills the ones that
    don't have the requested NC or have a source server that is intrasite.
    i.e. it finds all intersite connections objects with the needed NC. This 
    was just done to make the code a little more broken up.

Parameters:

    pDsInfo
    iSite ... the site to read all the connection objects for.
    pConnections ... an existing list to trim.

Return Value:
  
    Should be a pure list function, except that it does return CONNECTION_PAIRS,
    and not a straight array of ULONGs.

  --*/
{
    ULONG                               iConn, iTargetConn, cConns;
    PCONNECTION_PAIR                    pTemp;

    if(pConnections == NULL){
        return NULL;
    }
    
    for(cConns = 0; pConnections[cConns].iSrc != NO_SERVER; cConns++){
        ; // Note the ";" this counts.
    }

    pTemp = LocalAlloc(LMEM_FIXED, sizeof(CONNECTION_PAIR) * (cConns+1));
    if(pTemp == NULL){
        return(NULL);
    }

    iTargetConn = 0;
    for(iConn = 0; pConnections[iConn].iSrc != NO_SERVER; iConn++){
        if(pDsInfo->pServers[pConnections[iConn].iSrc].iSite != iSite){
            // This connection pair is an intersite connection.
            pTemp[iTargetConn].iSrc = pConnections[iConn].iSrc;
            pTemp[iTargetConn].iDst = pConnections[iConn].iDst;
            // note may be more to copy someday.
            iTargetConn++;
        }
    }

    pTemp[iTargetConn].iSrc = NO_SERVER;
    pTemp[iTargetConn].iDst = NO_SERVER;
    memcpy(pConnections, pTemp, sizeof(CONNECTION_PAIR) * (iTargetConn+1));
    LocalFree(pTemp);

    return(pConnections);
}

PCONNECTION_PAIR
IHT_TrimConnectionsForInterSiteAndTargetNC(    
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iSite,
    IN      PCONNECTION_PAIR            pConnections
    )
/*++

Description:

    This simply takes a Connections objects list, and kills the ones that
    don't have the requested NC or have a source server that is intrasite.
    i.e. it finds all intersite connections objects with the needed NC. This 
    was just done to make the code a little more broken up.

Parameters:

    pDsInfo
    iSite ... the site to read all the connection objects for.
    pConnections ... an existing list to trim.

Return Value:
  
    Should be a pure list function, except that it does return CONNECTION_PAIRS,
    and not a straight array of ULONGs.

  --*/
{
    ULONG                               iConn, iTargetConn, cConns;
    PCONNECTION_PAIR                    pTemp;

    if(pConnections == NULL){
        return NULL;
    }
    
    for(cConns = 0; pConnections[cConns].iSrc != NO_SERVER; cConns++){
        ; // Note the ";" this counts.
    }

    pTemp = LocalAlloc(LMEM_FIXED, sizeof(CONNECTION_PAIR) * (cConns+1));
    if(pTemp == NULL){
        return(NULL);
    }

    iTargetConn = 0;
    for(iConn = 0; pConnections[iConn].iSrc != NO_SERVER; iConn++){
        if(pDsInfo->pServers[pConnections[iConn].iSrc].iSite != iSite 
           && (pDsInfo->pszNC != NULL 
               && (DcDiagHasNC(pDsInfo->pszNC, 
                          &(pDsInfo->pServers[pConnections[iConn].iDst]), 
                          TRUE, TRUE) 
                   && DcDiagHasNC(pDsInfo->pszNC, 
                                  &(pDsInfo->pServers[pConnections[iConn].iSrc]), 
                                  TRUE, TRUE)
                   )
               )
           ){
            // This connection pair is intersite and has the right NC.
            pTemp[iTargetConn].iSrc = pConnections[iConn].iSrc;
            pTemp[iTargetConn].iDst = pConnections[iConn].iDst;
            // note may be more to copy someday.
            iTargetConn++;
        }
    }

    pTemp[iTargetConn].iSrc = NO_SERVER;
    pTemp[iTargetConn].iDst = NO_SERVER;
    memcpy(pConnections, pTemp, sizeof(CONNECTION_PAIR) * (iTargetConn+1));
    LocalFree(pTemp);

    return(pConnections);
}

PULONG
IHT_GetSrcSitesListFromConnections(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      PCONNECTION_PAIR            pConnections
    )
/*++

Description
 
    This returns a list of all the src's from the pConnections, with no
    duplicates.

Parameters
  
    pDsInfo
    pConnections ... the connections list to strip the iSrc fields out of.

Return Value:
  
    pure list function, see IHT_GetServerList().

  --*/
{
    ULONG                               iConn, iiTargetSite, iiSite;
    PULONG                              piSites;

    piSites = (PULONG) LocalAlloc(LMEM_FIXED, 
                                  sizeof(ULONG) * (pDsInfo->cNumSites + 1));
    if(pConnections == NULL || piSites == NULL){
        return(NULL);
    }

    iiTargetSite = 0;
    for(iConn = 0; pConnections[iConn].iSrc != NO_SERVER; iConn++){
        // Check to make sure we don't have this site already.
        for(iiSite = 0; iiSite < iiTargetSite; iiSite++){
            if(piSites[iiSite] 
               == pDsInfo->pServers[pConnections[iConn].iSrc].iSite){
                // We already have this site targeted.
                break;
            }
        }
        if(iiSite == iiTargetSite){
            // This means that we didn't find the site in piSites.
            piSites[iiTargetSite] = pDsInfo->pServers[pConnections[iConn].iSrc].iSite;
            iiTargetSite++;
        }    
    }
    piSites[iiTargetSite] = NO_SITE;

    return(piSites);
}

VOID
IHT_GetISTGsBridgeheadFailoverParams(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iISTG,
    OUT     PULONG                      pulIntersiteFailoverTries,
    OUT     PULONG                      pulIntersiteFailoverTime
    )
/*++

Description:

    This function gets the bridgehead failover parameters from the registry
    of the server as indexed by iISTG, or uses the default values.

Parameters:

    pDsInfo
    iISTG ... the server to get the failover parameters of.
    pulIntersiteFailoverTries ... this is how many tries before a bridghead 
            is stale.
    pulIntersiteFailoverTime ... This is how long before a bridgehead is stale.
       ... note that both Tries & Time must be exceeded for a bridgehead to be 
       stale.

Return Value:
  
    No return value, always succeeds ... will use default if thier is an error.

  --*/
{
    HKEY                                hkMachine = NULL;
    HKEY                                hk= NULL;
    CHAR *                              cpszMachine = NULL;
    CHAR *                              cpszTemp = NULL;
    ULONG                               ulTemp = 0;
    DWORD                               dwRet = 0, dwErr = 0, dwType = 0;
    DWORD                               dwSize = 4;
    LPWSTR                              pszMachine = NULL;
    LPWSTR                              pszDsaConfigSection = NULL;
    LPWSTR                              pszKccIntersiteFailoverTries = NULL;
    LPWSTR                              pszKccIntersiteFailoverTime = NULL;

    // This function will either succeed at reading the parameters
    //   of the ISTG's registry OR it will print a warning and use 
    //   the default values below.

    __try{

                                      // 2 for "\\", 1 for null, and 1 extra
        ulTemp = wcslen(pDsInfo->pServers[iISTG].pszName) + 4;
        cpszMachine = LocalAlloc(LMEM_FIXED, sizeof(char) * ulTemp);
        cpszTemp = LocalAlloc(LMEM_FIXED, sizeof(char) * ulTemp);
        if(cpszMachine == NULL || cpszTemp == NULL){
            goto UseDefaultsAndBail;
        }
        
        WideCharToMultiByte(CP_UTF8, 0, pDsInfo->pServers[iISTG].pszName, -1, 
                            cpszTemp, ulTemp, NULL, NULL);
        
        strcpy(cpszMachine, "\\\\");
        strcat(cpszMachine, cpszTemp);
        LocalFree(cpszTemp);
        
        pszMachine = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        if(pszMachine == NULL){
            goto UseDefaultsAndBail;
        }
        wcscpy(pszMachine, L"\\\\");
        wcscat(pszMachine, pDsInfo->pServers[iISTG].pszName);
        
        dwRet = RegConnectRegistry(pszMachine, HKEY_LOCAL_MACHINE, &hkMachine);
        if(dwRet != ERROR_SUCCESS){
            goto UseDefaultsAndBail;
        }
        
        ulTemp = strlen(DSA_CONFIG_SECTION) + 1;
        pszDsaConfigSection = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        mbstowcs(pszDsaConfigSection, DSA_CONFIG_SECTION, ulTemp);

        ulTemp = strlen(KCC_INTERSITE_FAILOVER_TRIES) + 1;
        pszKccIntersiteFailoverTries = LocalAlloc(LMEM_FIXED,
                                                  sizeof(WCHAR) * ulTemp);
        mbstowcs(pszKccIntersiteFailoverTries, KCC_INTERSITE_FAILOVER_TRIES, 
                 ulTemp);
        
        ulTemp = strlen(KCC_INTERSITE_FAILOVER_TIME) + 1;
        pszKccIntersiteFailoverTime = LocalAlloc(LMEM_FIXED, 
                                                 sizeof(WCHAR) * ulTemp);
        mbstowcs(pszKccIntersiteFailoverTime, KCC_INTERSITE_FAILOVER_TIME, 
                 ulTemp);
        
        if ((dwRet = RegOpenKey(hkMachine, pszDsaConfigSection, &hk)) 
            == ERROR_SUCCESS){

            // Get Tries if exists;
            if((dwErr = RegQueryValueEx(hk, pszKccIntersiteFailoverTries, 
                                        NULL, &dwType, 
                                        (LPBYTE) pulIntersiteFailoverTries, 
                                        &dwSize))){

                // Parameter not found use the default.
                *pulIntersiteFailoverTries = KCC_DEFAULT_INTERSITE_FAILOVER_TRIES;
            } else if (dwType == REG_DWORD){
                // Do nothing, this means the value was found and set.
            } else {
                // This would mean that the dwType was other than REG_DWORD ...
                //    cause for concern?
                *pulIntersiteFailoverTries = KCC_DEFAULT_INTERSITE_FAILOVER_TRIES;
            }
            
            // Get Time if exists
            if (dwErr = RegQueryValueEx(hk, pszKccIntersiteFailoverTime, 
                                        NULL, &dwType, 
                                        (LPBYTE) pulIntersiteFailoverTime, 
                                        &dwSize)){
                // Paramter not found use the default.
                *pulIntersiteFailoverTime = KCC_DEFAULT_INTERSITE_FAILOVER_TIME;
            } else if (dwType == REG_DWORD){
                // Do nothing, this means the value was found and set.
            } else {
                // This would mean that the dwType was other than REG_DWORD ...
                //    cause for concern?
                *pulIntersiteFailoverTime = KCC_DEFAULT_INTERSITE_FAILOVER_TIME;
            }
            
        } else {
            RegCloseKey(hkMachine);
            goto UseDefaultsAndBail;
        }
        
        __leave;
    
    UseDefaultsAndBail:
        
        *pulIntersiteFailoverTries = KCC_DEFAULT_INTERSITE_FAILOVER_TRIES;
        *pulIntersiteFailoverTime = KCC_DEFAULT_INTERSITE_FAILOVER_TIME;
        
    } __finally {

        if (hk) RegCloseKey(hk);
        if (hkMachine) RegCloseKey(hkMachine);
        if(pszMachine != NULL) { LocalFree(pszMachine); }
        if(pszKccIntersiteFailoverTries != NULL) { 
            LocalFree(pszKccIntersiteFailoverTries); 
        }
        if(pszKccIntersiteFailoverTime != NULL) { 
            LocalFree(pszKccIntersiteFailoverTime); 
        }
        if(pszDsaConfigSection != NULL) { 
            LocalFree(pszDsaConfigSection); 
        }

    }
        
}

BOOL
IHT_BridgeheadIsUp(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iServerToCheck,
    IN      ULONG                       ulIntersiteFailoverTries,
    IN      ULONG                       ulIntersiteFailoverTime,
    IN      DS_REPL_KCC_DSA_FAILURESW * pConnectFailures,
    IN      DS_REPL_KCC_DSA_FAILURESW * pLinkFailures,
    IN      BOOL                        bPrintErrors
    )
/*++

Description:

    This function takes the ISTG's parameters of ulIntersiteFailoverTries & 
    ulIntersiteFailoverTime and a server to check, and the failure caches
    from the ISTG and determines if that DC/ISTG's KCC would consider this
    bridgehead to be stale or not.

Parameters:

    pDsInfo
    iServerToCheck ... server to check for staleness
    ulIntersiteFailoverTries ... number of failures not to be exceeded
    ulIntersiteFailoverTime ... length of time not to be exceeded
    pConnectFailures ... the connect failure cache from the ISTG.
    pLinkFailures ... the link failure cache from the ISTG.
    bPrintErrors ... print out the errors.

Return Value:
  
    returns FALSE if the KCC would consider the bridgehead stale/down,
    TRUE otherwise.

  --*/
{
    ULONG                               iFailure;
    DS_REPL_KCC_DSA_FAILUREW *          pFailure = NULL;
    DSTIME                              dstFirstFailure;
    DSTIME                              dstNow;
    DWORD                               dwRet;
    DSTIME                              dstTimeSinceFirstFailure = 0;
    ULONG                               ulTemp;

    dstNow = IHT_GetSecondsSince1601();

    if(pConnectFailures->cNumEntries == 0 && pLinkFailures->cNumEntries == 0){
        return(TRUE);
    }

    dwRet = TRUE;

    for(iFailure = 0; iFailure < pConnectFailures->cNumEntries; iFailure++){
        pFailure = &pConnectFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServerToCheck].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > ulIntersiteFailoverTries){
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                dstTimeSinceFirstFailure = ((ULONG) dstNow - dstFirstFailure);
                if((dstNow - dstFirstFailure) > ulIntersiteFailoverTime){
                    // We know this server is down in connect cache
                    dwRet = FALSE;
                } // end if too long since first failure
            } // end if too many consecutive failures
        } // end if right server by GUID
    }

    for(iFailure = 0; iFailure < pLinkFailures->cNumEntries; iFailure++){
        pFailure = &pLinkFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServerToCheck].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > ulIntersiteFailoverTries){
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                dstTimeSinceFirstFailure = ((ULONG) dstNow - dstFirstFailure);
                if((dstNow - dstFirstFailure) > ulIntersiteFailoverTime){
                    // We know this server is down in the link cache
                    dwRet = FALSE;
                } // end if too long since first failure
            } // end if too many consecutive failures
        } // end if right server by GUID
    }

    return(dwRet);                                

}

PULONG
IHT_GetExplicitBridgeheadList(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iISTG
    )
/*++

Description:

    Gets the list of all the explicit brdigeheads for an enterprise, for
    the IP transport.

Parameters:

    pDsInfo
    hld ... an LDAP binding to use to query a server for the explicit 
         bridgehead list.

Return Value:
  
    not quite a pure function, but pretty pure.  Will return NULL, or a 
    pointer to a bridgehead list.  IF NULL, then SetLastError() should have
    been called.

  --*/
{
    LPWSTR                              ppszTransportSearch [] = {
        L"bridgeheadServerListBL",
        NULL };
    // Code.Improvement BUGBUG We should be able to handle 
    //    multiple transports someday.
    LPWSTR                              pszIpContainerPrefix = 
        L"CN=IP,CN=Inter-Site Transports,";
    LPWSTR                              pszNtDsSettingsPrefix = 
        L"CN=NTDS Settings,";
    PULONG                              piExplicitBridgeheads = NULL;
    PDSNAME                             pdsnameSiteSettings = NULL;
    PDSNAME                             pdsnameSitesContainer = NULL;
    LDAPMessage *                       pldmBridgeheads = NULL;
    LDAPMessage *                       pldmBridgeheadResults = NULL;
    LPWSTR *                            ppszExplicitBridgeheads = NULL;
    LPWSTR                              pszTemp = NULL;
    ULONG                               iServer = NO_SERVER;
    ULONG                               ulTemp, i;
    LPWSTR                              pszIpTransport = NULL;
    LDAP *                              hld = NULL;
    DWORD                               dwRet;

    __try {

        dwRet = DcDiagGetLdapBinding(&(pDsInfo->pServers[iISTG]), 
                                     pDsInfo->gpCreds,
                                     FALSE, &hld);
        if(dwRet != ERROR_SUCCESS){
            SetLastError(dwRet);
            __leave;
        }

        piExplicitBridgeheads = IHT_GetEmptyServerList(pDsInfo);
        if(piExplicitBridgeheads == NULL){
            SetLastError(IHT_PrintListError(GetLastError()));
            __leave;
        }

        // presumes at least one site.
        pdsnameSiteSettings = DcDiagAllocDSName (
            pDsInfo->pSites[0].pszSiteSettings);
        DcDiagChkNull( pdsnameSitesContainer = (PDSNAME) LocalAlloc 
                       (LMEM_FIXED, pdsnameSiteSettings->structLen));
        TrimDSNameBy (pdsnameSiteSettings, 2, pdsnameSitesContainer);
        ulTemp = wcslen(pdsnameSitesContainer->StringName) + 
                 wcslen(pszIpContainerPrefix) + 2;
        pszIpTransport = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        if(pszIpTransport == NULL){
            SetLastError(IHT_PrintListError(GetLastError()));
            __leave;
        }
        wcscpy(pszIpTransport, pszIpContainerPrefix);
        wcscat(pszIpTransport, pdsnameSitesContainer->StringName);
        
        DcDiagChkLdap (ldap_search_sW ( hld,
                                        pszIpTransport,
                                        LDAP_SCOPE_BASE,
                                        L"(objectCategory=interSiteTransport)",
                                        ppszTransportSearch,
                                        0,
                                        &pldmBridgeheadResults));
        
        pldmBridgeheads = ldap_first_entry (hld, pldmBridgeheadResults);
        ppszExplicitBridgeheads = ldap_get_valuesW(hld, pldmBridgeheads, 
                                                   L"bridgeheadServerListBL");
        if(ppszExplicitBridgeheads == NULL){
            // we are done, and empty list is returned because thier 
            //    are no explicit bridgeheads
            __leave; 
        }
        
        for(i = 0; ppszExplicitBridgeheads[i] != NULL; i++){
            // walk through each explicit bridgehead.
            ulTemp = wcslen(ppszExplicitBridgeheads[i]) + 
                     wcslen(pszNtDsSettingsPrefix) + 2;
            pszTemp = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
            if(pszTemp == NULL){
                SetLastError(IHT_PrintListError(GetLastError()));
                __leave; 
            }
            wcscpy(pszTemp, pszNtDsSettingsPrefix);
            wcscat(pszTemp, ppszExplicitBridgeheads[i]);
            // should have NTDS Settings Dn of a server now.
            iServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, pszTemp, NULL, NULL);
            if(iServer == NO_SERVER){
                SetLastError(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                                NO_SERVER, 
                                                                pszTemp));
                __leave; 
            }
            IHT_AddToServerList(piExplicitBridgeheads, iServer);
            LocalFree(pszTemp);
            pszTemp = NULL;
        }

    } __finally {

        if(pdsnameSiteSettings != NULL) { LocalFree(pdsnameSiteSettings); }
        if(pdsnameSitesContainer != NULL) { LocalFree(pdsnameSitesContainer); }
        if(pszIpTransport != NULL) { LocalFree(pszIpTransport); }
        if(pszTemp != NULL) { LocalFree(pszTemp); }
        if(ppszExplicitBridgeheads != NULL) { 
            ldap_value_freeW(ppszExplicitBridgeheads); 
        }
        if(pldmBridgeheadResults != NULL) { 
            ldap_msgfree(pldmBridgeheadResults); 
        }
    }
    
    return(piExplicitBridgeheads);
}

DWORD
IHT_GetFailureCaches(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iServer, // The server num
    HANDLE                              hDS,
    DS_REPL_KCC_DSA_FAILURESW **        ppConnectionFailures,
    DS_REPL_KCC_DSA_FAILURESW **        ppLinkFailures
    )
/*++

Description:
 
    This function retireves the failure caches for the Ds binding handle hDS.

Parameters:

    pDsInfo
    iServer ... The server number, for printing purposes.
    hDS ... effectively server to retrieve failure cache from
    ppConnectionFailures ... pointer to a pointer of failure info to return
    ppLinkFailures ... same as connection failures but for link failures.

Return Value:
  
    not quite a pure function, but pretty pure.  Will return NULL, or a 
    pointer to a bridgehead list.  IF NULL, then SetLastError() should have 
    been called.

  --*/
{
    DWORD                               dwRet;
    DS_REPL_KCC_DSA_FAILURESW *         pFailures;

    dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                              NULL, NULL, &pFailures);
    if (dwRet != ERROR_SUCCESS) {
        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ERROR_GETTING_FAILURE_CACHE_ABORT,
                 pDsInfo->pServers[iServer].pszName,
                 Win32ErrToString(dwRet));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwRet);
        return(dwRet);
    } else {
        *ppConnectionFailures = pFailures;
        dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                  NULL, NULL, &pFailures);
        if (dwRet != ERROR_SUCCESS) {
            PrintMsg(SEV_ALWAYS, 
                     DCDIAG_INTERSITE_ERROR_GETTING_FAILURE_CACHE_ABORT,
                     pDsInfo->pServers[iServer].pszName, 
                     Win32ErrToString(dwRet));
            if(*ppConnectionFailures != NULL){
                DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, 
                                  *ppConnectionFailures);            
            }
            return(dwRet);
        } else {
            *ppLinkFailures = pFailures;
        }  // if/else can't get Link Failures
    } // end if/else can't get Connection Failures

    return(ERROR_SUCCESS);
}

VOID
ReplIntersiteSetBridgeheadFailingInfo(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iServer,
    IN      ULONG                       ulIntersiteFailoverTries,
    IN      ULONG                       ulIntersiteFailoverTime,
    IN      DS_REPL_KCC_DSA_FAILURESW * pConnectionFailures,
    IN      DS_REPL_KCC_DSA_FAILURESW * pLinkFailures,
    IN      PKCCFAILINGSERVERS          prgKCCFailingServer
    )
/*++

Description:

    This function takes the Failure caches and puts them into a nicer
    structured array that can be easily passed around and quickly
    referenced
    
Parameters:

    pDsInfo
    iServer - The server that we are setting up.
    ulIntersiteFailoverTries (IN) - The Failover retries the KCC will make
    ulIntersiteFailoverTime (IN) - The failover time the kcc will wait.
    pConnectionFailures (IN) - The connection failure cache from the ISTG.
    pLinkFailures (IN) - The link failures cache from the ISTG.
    prgKCCFailingServer (OUT) - This is the thing to setup with info
        from the two failure caches.       

--*/
{
    DSTIME                              dstNow;
    DSTIME                              dstFirstFailure;
    ULONG                               iFailure;
    DS_REPL_KCC_DSA_FAILUREW *          pFailure = NULL;


    Assert(pConnectionFailures);
    Assert(pLinkFailures);
    Assert(prgKCCFailingServer != NULL);

    prgKCCFailingServer->bFailures = FALSE;
    prgKCCFailingServer->bDown = FALSE;
    prgKCCFailingServer->lConnTriesLeft = FAILOVER_INFINITE;
    prgKCCFailingServer->lLinkTriesLeft = FAILOVER_INFINITE;
    prgKCCFailingServer->lConnTimeLeft = FAILOVER_INFINITE;
    prgKCCFailingServer->lLinkTimeLeft = FAILOVER_INFINITE;
    
    dstNow = IHT_GetSecondsSince1601();

    for(iFailure = 0; iFailure < pConnectionFailures->cNumEntries; iFailure++){
        pFailure = &pConnectionFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServer].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > 0){
                prgKCCFailingServer->bFailures = TRUE;
                prgKCCFailingServer->lConnTriesLeft = ulIntersiteFailoverTries - pFailure->cNumFailures;                
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                prgKCCFailingServer->lConnTimeLeft = ulIntersiteFailoverTime - (LONG) (dstNow - dstFirstFailure);
            }
        } // end if right server by GUID
    }

    for(iFailure = 0; iFailure < pLinkFailures->cNumEntries; iFailure++){
        pFailure = &pLinkFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServer].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > 0){
                prgKCCFailingServer->bFailures = TRUE;
                prgKCCFailingServer->lLinkTriesLeft = ulIntersiteFailoverTries - pFailure->cNumFailures;                
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                prgKCCFailingServer->lLinkTimeLeft = ulIntersiteFailoverTime - (LONG) (dstNow - dstFirstFailure);
            }
        } // end if right server by GUID
    }

}

PULONG
IHT_GetKCCFailingServersLists(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       ulIntersiteFailoverTries,
    IN      ULONG                       ulIntersiteFailoverTime,
    IN      DS_REPL_KCC_DSA_FAILURESW * pConnectionFailures,
    IN      DS_REPL_KCC_DSA_FAILURESW * pLinkFailures,
    OUT     PKCCFAILINGSERVERS *        pprgKCCFailingServers
    )
/*++

Description:

    This gives back a list of which servers in the enterprise are down 
    _according to the KCC_.  And also returns a list of servers that are
    failing, but aren't considered down by the KCC.

Parameters:

    pDsInfo
    ulIntersiteFailoverTries ... the number of tries that are acceptable
    ulIntersiteFailoverTime ... the length of time of failure that is 
         acceptable.
    pConnectionFailures ... connection failures
    pLinkFailures ... link failures
    pprgKCCFailingServers ... out param, for the servers that are failing,
        but not down yet.

Return Value:

    This is a pure list function, it can only fail because a memory alloc 
    failed, see IHT_GetServerList().

  --*/
{
    ULONG                               iServer;
    PULONG                              piKCCDownServers = NULL;

    piKCCDownServers = IHT_GetEmptyServerList(pDsInfo);
    if(piKCCDownServers == NULL){
        return(NULL);
    }
    *pprgKCCFailingServers = LocalAlloc(LMEM_FIXED,
                     pDsInfo->ulNumServers * sizeof(KCCFAILINGSERVERS));
    if(*pprgKCCFailingServers == NULL){
        LocalFree(piKCCDownServers);
        return(NULL);
    }

    // Walk through all servers.
    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){

        ReplIntersiteSetBridgeheadFailingInfo(pDsInfo,
                                     iServer,
                                     ulIntersiteFailoverTries,
                                     ulIntersiteFailoverTime,
                                     pConnectionFailures,
                                     pLinkFailures,
                                     &((*pprgKCCFailingServers)[iServer]));
        
        // Code.Improvement ... make a BridgeheadIsUp(), function
        //   that only takes iServer, and prgKCCFailingServers array.
        if(!IHT_BridgeheadIsUp(pDsInfo,
                               iServer,
                               ulIntersiteFailoverTries,
                               ulIntersiteFailoverTime,
                               pConnectionFailures,
                               pLinkFailures,
                               FALSE)){
            // if not up, add to the list
            IHT_AddToServerList(piKCCDownServers, iServer);

        }
        

    }

    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){
        if(IHT_ServerIsInServerList(piKCCDownServers, iServer)){
            (*pprgKCCFailingServers)[iServer].bDown = TRUE;
        }
    }

    return(piKCCDownServers);
}

PULONG
ReplIntersiteGetUnreacheableServers(
    PDC_DIAG_DSINFO                     pDsInfo
    )
/*++

Description:

    Using the info in pDsInfo, it constructs a list of servers that we
    couldn't contact.

Parameters:

    pDsInfo - mini - enterprise

Return Value:

    NULL if we can't allocate the list, a pointer to the list if we can.

--*/
{
    PULONG                              piUnreacheableServers = NULL;
    ULONG                               iServer;

    piUnreacheableServers = IHT_GetEmptyServerList(pDsInfo);
    if(piUnreacheableServers == NULL){
        return(NULL);
    }    
    
    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){
        if(!pDsInfo->pServers[iServer].bDnsIpResponding 
           || !pDsInfo->pServers[iServer].bDsResponding){
            IHT_AddToServerList(piUnreacheableServers, iServer);
        }    
    } // End for each server.

    return(piUnreacheableServers);
}

VOID
GetInterSiteAttributes(
    IN   LDAP *                         hld,
    IN   LPWSTR                         pszSiteSettings,
    OUT  LPWSTR *                       ppszInterSiteTopologyGenerator,
    OUT  PULONG                         pulInterSiteTopologyFailover,
    OUT  PULONG                         pulInterSiteTopologyRenew
    )
/*++

Description:

    This function gets the relevant attributes of a NTDS Site Settings 
    object, for purpose of locating the ISTG.

Parameters:

    hld ... Ldap binding handle of possible ISTG.
    pszSiteSettings ... string to the CN=NTDS Site Settings,DC=Site,DC=etc 
           string
    ppszInterSiteTopologyGenerator ... return the ISTG string found on this 
           object.
    pulInterSiteTopologyFailover ... the failover period
    pulInterSiteTopologyRenew ... frequency of writes to ISTG attribute.

Return Value:

    NULL in ppszInterSiteTopologyGenerator, that'd be closest to an actual 
    error.

--*/
{
    LPWSTR                              ppszNtdsSiteSearch [] = {
        L"objectGUID",
        L"distinguishedName",
        L"interSiteTopologyGenerator",
        L"interSiteTopologyFailover",
        L"interSiteTopologyRenew",
        NULL };
    LDAPMessage *                       pldmEntry = NULL;
    LDAPMessage *                       pldmNtdsSitesResults = NULL;
    LPWSTR *                            ppszTemp = NULL;
    ULONG                               ulTemp;

    // Can connect to supposed ISTG.
    DcDiagChkLdap (ldap_search_sW ( hld,
                                    pszSiteSettings,
                                    LDAP_SCOPE_BASE,
                                    L"(objectCategory=ntDSSiteSettings)",
                                    ppszNtdsSiteSearch,
                                    0,
                                    &pldmNtdsSitesResults));
    pldmEntry = ldap_first_entry (hld, pldmNtdsSitesResults);
    
    // interSiteTopologyGenerator                
    ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"interSiteTopologyGenerator");
    if(ppszTemp != NULL){
        ulTemp = wcslen(ppszTemp[0]) + 2;
        *ppszInterSiteTopologyGenerator = (LPWSTR) LocalAlloc(LMEM_FIXED, 
                                                 sizeof(WCHAR) * ulTemp);
        wcscpy(*ppszInterSiteTopologyGenerator, ppszTemp[0]);
        ldap_value_freeW(ppszTemp);
    } else {
        *ppszInterSiteTopologyGenerator = NULL;
    }
    
    // interSiteTopologyFailover
    ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"interSiteTopologyFailover");
    if(ppszTemp != NULL){
        *pulInterSiteTopologyFailover = wcstoul(ppszTemp[0], NULL, 10);
        ldap_value_freeW(ppszTemp);
    } else {
        *pulInterSiteTopologyFailover = KCC_DEFAULT_SITEGEN_FAILOVER;
    }
    
    // interSiteTopologyRenew
    ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"interSiteTopologyRenew");
    if(ppszTemp != NULL){
        *pulInterSiteTopologyRenew = wcstoul(ppszTemp[0], NULL, 10);
        ldap_value_freeW(ppszTemp);
    } else {
        *pulInterSiteTopologyRenew = KCC_DEFAULT_SITEGEN_RENEW;
    }

    if(pldmNtdsSitesResults != NULL) ldap_msgfree (pldmNtdsSitesResults);
}

DWORD
GetTimeSinceWriteStamp(
    HANDLE                              hDS,
    LPWSTR                              pszDn,
    LPWSTR                              pszAttr,
    PULONG                              pulTimeSinceLastWrite
    )
/*++

Description:

    This returns in seconds the time since the last write to the attribute
    pszAttr of the object pszDn.

Parameters:

    hDS ... the handle of the DC to get this info from.
    pszDn ... the DN of the object where the attribute resides that we want
         the last write meta data of.
    pszAttr ... the attribute to retrieve the last write of.
    pulTimeSinceLastWrite ... place to store the time since last write.

Return Value:

    Returns a Win 32 error.

--*/
{
    DSTIME                              dstWriteStamp; 
                                     // dst - Directory Standard Time :)
    DS_REPL_OBJ_META_DATA *             pObjMetaData;
    DWORD                               dwRet = ERROR_SUCCESS;
    ULONG                               iMetaEntry;

    dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_METADATA_FOR_OBJ, pszDn,
                              NULL, &pObjMetaData);
    if (dwRet != ERROR_SUCCESS) {
        return(dwRet);
    }

    for(iMetaEntry = 0; iMetaEntry < pObjMetaData->cNumEntries; iMetaEntry++){
        if(_wcsicmp(pszAttr, pObjMetaData->rgMetaData[iMetaEntry].pszAttributeName) == 0){
            FileTimeToDSTime(pObjMetaData->rgMetaData[iMetaEntry].ftimeLastOriginatingChange, &dstWriteStamp);
            // we have got our meta data!
            break;
        }
    }

    *pulTimeSinceLastWrite = (ULONG) ((IHT_GetSecondsSince1601() - dstWriteStamp)/60);

    DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, pObjMetaData);

    return(ERROR_SUCCESS);
}


DWORD
IHT_GetISTGInfo(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN      ULONG                       iSite,
    IN      ULONG                       iServer,
    OUT     LPWSTR *                    ppszLocalISTG,
    OUT     PULONG                      pulInterSiteFailover,
    OUT     PULONG                      pulInterSiteRenew,
    OUT     PULONG                      pulTimeSinceLastISTGWrite
    )
{
    DWORD                               dwRet;
    LDAP *                              hld;
    HANDLE                              hDS;
    
    dwRet = DcDiagGetLdapBinding(&(pDsInfo->pServers[iServer]),
                                     gpCreds, FALSE, &hld);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    dwRet = DcDiagGetDsBinding(&(pDsInfo->pServers[iServer]), gpCreds, &hDS);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    GetInterSiteAttributes(hld, pDsInfo->pSites[iSite].pszSiteSettings,
                           ppszLocalISTG, pulInterSiteFailover, 
                           pulInterSiteRenew);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    } 
    dwRet = GetTimeSinceWriteStamp(hDS, pDsInfo->pSites[iSite].pszSiteSettings, 
                                   L"interSiteTopologyGenerator", 
                                   pulTimeSinceLastISTGWrite);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    return(ERROR_SUCCESS);
}



DWORD
IHT_GetNextISTG(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iSite,
    IN      PULONG                      piServersSiteOrig,
    IN OUT  PULONG                      pulISTG,
    OUT     PULONG                      pulFailoverTotal
    )
/*++

Description:

    This function is one of the 5 meaty functions that make the intersite 
    test go.  This function will get the ISTG to come, and set the 
    pulFailoverTotal.

Parameters:

    pDsInfo
    iSite ... This is the site we are analyzing.
    piServersSiteOrig ... all the servers for the site, ie potential ISTGs
    pulISTG ... the last guess as an ISTG.
    pulFailoverTotal ... the failover to be set
    ulInterSiteFailover ... 
    ulTimeSinceLastISTGWrite ... the time since the ISTG attribute has been 
         written (in sec?)

Return Value:

    returns a Win 32 error.  If it does this is a fatal error to this test.

  --*/
{
    ULONG                               iiOldISTG, cNumServers, iiTarget;
    ULONG                               iDefunctISTG;
    ULONG                               ulInterSiteRenew;
    LPWSTR                              pszLocalISTG = NULL;
    DWORD                               dwRet = ERROR_SUCCESS;
    PULONG                              piOrderedServers = NULL;
    ULONG                               ulTimeSinceLastISTGWrite = 0;
    ULONG                               ulInterSiteFailover = 0;

    __try{

        iDefunctISTG = *pulISTG;
        for(cNumServers=0; piServersSiteOrig[cNumServers] != NO_SERVER; cNumServers++){
            ; // get number of servers ... note semicolon.
        }
        
        piOrderedServers = IHT_CopyServerList(pDsInfo, piServersSiteOrig);
        piOrderedServers = IHT_OrderServerListByGuid(pDsInfo, 
                                                     piOrderedServers);
        
        if(piOrderedServers == NULL){
            dwRet = IHT_PrintListError(GetLastError());
            __leave;
        } else if(piOrderedServers[0] == NO_SERVER){
            // No servers in this site
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_NO_SERVERS_IN_SITE_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            *pulISTG = NO_SERVER;
            *pulFailoverTotal = 0;
            __leave; // dwRet initialized to ERROR_SUCCESS above;
        }
        
        for(iiOldISTG=0; piOrderedServers[iiOldISTG] != NO_SERVER; iiOldISTG++){
            if(iDefunctISTG == piOrderedServers[iiOldISTG]){
                break;
            }
        }
        
        if(piOrderedServers[iiOldISTG] == NO_SERVER){
            // the old ISTG has been moved out of the site.
            *pulISTG = NO_SERVER;
            *pulFailoverTotal = 0;
            dwRet = IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                       NO_SERVER, 
                                                       NULL);
            __leave;
        }
        
        for(iiTarget = (iiOldISTG+1) % cNumServers; iiTarget != iiOldISTG; iiTarget = (iiTarget+1) % cNumServers){

            if(pDsInfo->pServers[piOrderedServers[iiTarget]].bDnsIpResponding 
               && pDsInfo->pServers[piOrderedServers[iiTarget]].bDsResponding 
               && pDsInfo->pServers[piOrderedServers[iiTarget]].bLdapResponding){
                // Server pServers[piOrderedServers[iiTarget]] is up and will 
                //   be the next ISTG.  Calculate failover ... off of time      
                Assert(iiTarget != iiOldISTG && 
                       "If this is the case, we should have dropped out to"
                       " the ii == iiTarget\n");
                
                dwRet = IHT_GetISTGInfo(pDsInfo, pDsInfo->gpCreds, iSite, 
                                        piOrderedServers[iiTarget],
                                        &pszLocalISTG, 
                                        &ulInterSiteFailover, 
                                        &ulInterSiteRenew, 
                                        &ulTimeSinceLastISTGWrite);
                if(dwRet != ERROR_SUCCESS){
                    PrintMsg(SEV_VERBOSE,
                             DCDIAG_INTERSITE_NO_METADATA_TIMESTAMP_ABORT,
                             pDsInfo->pServers[*pulISTG].pszName,
                             pDsInfo->pSites[iSite].pszName);
                    *pulISTG = NO_SERVER;
                    __leave;
                }
                if(_wcsicmp(pszLocalISTG, 
                            pDsInfo->pServers[piOrderedServers[iiTarget]].pszDn)
                   == 0){
                    // Note this server has already take over as the ISTG.
                    *pulFailoverTotal = 0;
                    *pulISTG = piOrderedServers[iiTarget];
                    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                    pszLocalISTG = NULL;
                    dwRet = ERROR_SUCCESS;
                    __leave;
                }
                if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                pszLocalISTG = NULL;
                
                // Code.Improvement: get max kcc lag, and put in here. Can't
                //    remember where kcc lag is, somewhere is how often the kcc runs.
                // pulFailoverTotal  = (# in between up server and failed ISTG)
                //                                   *   failover period   +    
                //             max kcc lag - Time elapsed since write of ISTG
                //                                                   attribue
                *pulISTG = piOrderedServers[iiTarget]; 
                if(iiTarget > iiOldISTG){
                    *pulFailoverTotal = (iiTarget - iiOldISTG) 
                                        * ulInterSiteFailover +    
                                        15 - ulTimeSinceLastISTGWrite;
                } else {
                    *pulFailoverTotal = (iiTarget + (cNumServers - iiOldISTG))
                                        * ulInterSiteFailover +    
                                        15 - ulTimeSinceLastISTGWrite;
                }
                if(*pulFailoverTotal > (cNumServers * ulInterSiteFailover)){
                    Assert(!"Hey what is up, did the TimeSinceLastWrite "
                           "exceed the down servers\n");
                    // Something's wrong, but it should be about one intersite
                    //   failover before some DC at least tries to take the 
                    //   ISTG role.
                    *pulFailoverTotal = *pulFailoverTotal %
                                         ulInterSiteFailover + 15;
                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_ISTG_CANT_AUTHORATIVELY_DETERMINE,                             
                             pDsInfo->pSites[iSite].pszName,
                             *pulFailoverTotal);
                }
                break;
            }
        }
        if(iiOldISTG == iiTarget){
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_ALL_DCS_DOWN_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            *pulISTG = NO_SERVER;
            *pulFailoverTotal = 0;
            dwRet = ERROR_SUCCESS;
            __leave;
        }
        
        Assert(piOrderedServers[iiOldISTG] != NO_SERVER);
     
    } __finally {
        if(piOrderedServers != NULL){ LocalFree(piOrderedServers); }
        if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
        pszLocalISTG = NULL;
    }   
    return(dwRet); 
}

DWORD
IHT_GetOrCheckISTG(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iSite,
    IN      PULONG                      piServersForSite,
    IN OUT  PULONG                      pulISTG,
    OUT     PULONG                      pulFailover,
    IN      INT                         iRecursionLevel
    )
/*++

Description:

    This function is one of the 5 meaty functions that make the intersite test 
    go.  This function basically checks if we have the ISTG or makes a guess at
    the ISTG if we don't have the 

Parameters:

    pDsInfo
    iSite ... This is the site we are analyzing.
    piServersForSite ... all the servers for the site, ie potential ISTGs
    pulISTG ... the last guess as an ISTG.
    pulFailover ... the failover to be set
    iRecursionLevel ... to ensure we don't recurse too far.

Return Value:

    returns a Win 32 error.  If it does this is a fatal error to this test.

  --*/
{
    LDAP *                              hld = NULL;
    DWORD                               dwRet = ERROR_SUCCESS;
    DWORD                               dwRetDS, dwRetLDAP;
    LPWSTR                              pszLocalISTG = NULL;
    ULONG                               ulInterSiteFailover;
    ULONG                               ulInterSiteRenew;
    HANDLE                              hDS;
    ULONG                               ulTimeSinceLastISTGWrite;
    ULONG                               ulFirstGuessISTG;

    Assert(piServersForSite);
    Assert(piServersForSite[0] != NO_SERVER);
    Assert(pulISTG);
    Assert(pulFailover);

    *pulISTG = NO_SERVER;
    *pulFailover = 0;

    __try {

        if(iRecursionLevel > 6){
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_CIRCULAR_LOOP_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            *pulISTG = NO_SERVER;
            *pulFailover = 0;
            __leave; // dwRet initialized to ERROR_SUCCESS
        }

        if(*pulISTG == NO_SERVER){
            // Get the home servers guess for teh ISTG for the site.
            *pulISTG = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                          pDsInfo->pSites[iSite].pszISTG, 
                                          NULL,NULL);
            if(*pulISTG == NO_SERVER){
                dwRet = IHT_PrintInconsistentDsCopOutError(pDsInfo, NO_SERVER, 
                                                           pDsInfo->pSites[iSite].pszISTG);
                __leave;
            }

        } else {
            // pulISTG is set with a DC the caller wants us to try ... 
            //   so lets check out that DC.
        }

        Assert(*pulISTG != NO_SERVER);
        ulFirstGuessISTG = *pulISTG;

        if(pDsInfo->pServers[*pulISTG].iSite == iSite){
            // At least the server is in this site ... go on.

            dwRetLDAP = DcDiagGetLdapBinding(&(pDsInfo->pServers[*pulISTG]),
                                         pDsInfo->gpCreds, FALSE, &hld);
            dwRetDS = DcDiagGetDsBinding(&(pDsInfo->pServers[*pulISTG]), 
                                         pDsInfo->gpCreds, &hDS);

            if((dwRetDS == ERROR_SUCCESS) && (dwRetLDAP == ERROR_SUCCESS)){

                GetInterSiteAttributes(hld,
                                       pDsInfo->pSites[iSite].pszSiteSettings,
                                       &pszLocalISTG, &ulInterSiteFailover, 
                                       &ulInterSiteRenew);
                
                if(_wcsicmp(pszLocalISTG, pDsInfo->pSites[iSite].pszISTG) == 0){
                    // the ISTG attribute is consistent on the home server 
                    //    and the ISTG itself.  clear? :)
                    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                    pszLocalISTG = NULL;

                    dwRet = GetTimeSinceWriteStamp(hDS, 
                                  pDsInfo->pSites[iSite].pszSiteSettings, 
                                  L"interSiteTopologyGenerator", 
                                  &ulTimeSinceLastISTGWrite);
                    if(dwRet == ERROR_SUCCESS){
                        // Note ulTimeSinceLastISTGWrite is returned in minutes.
                        
                        if( ulTimeSinceLastISTGWrite < ulInterSiteFailover ){
                            // We know this is the authorative ISTG.
                            //   This will be the exit point of this function 
                            //   90% of the time.
                            *pulFailover = 0;
                            __leave; // dwRet set to ERROR_SUCCESS above.
                        } else {
                            // Meta data is old, meaning ISTG is past due, 
                            //    a new DC will take ISTG control.
                            PrintMsg(SEV_VERBOSE,
                                     DCDIAG_INTERSITE_OLD_ISTG_TIME_STAMP,
                                     ulTimeSinceLastISTGWrite,
                                     pDsInfo->pServers[*pulISTG].pszName);

                            dwRet = IHT_GetNextISTG(pDsInfo, iSite, 
                                                    piServersForSite,
                                                    pulISTG, 
                                                    pulFailover);
                            if(dwRet != ERROR_SUCCESS) {
                                PrintMsg(SEV_ALWAYS,
                                         DCDIAG_INTERSITE_COULD_NOT_LOCATE_AN_ISTG_ABORT,
                                         pDsInfo->pSites[iSite].pszName);
                                __leave;
                            }
                            if(*pulISTG == NO_SERVER){
                                // Last known to be the ISTG roll.
                                *pulISTG = ulFirstGuessISTG; 
                                // This is indented, becuase of where we come
                                //   from in GetNextISTG kind of completes 
                                //   the error message.
                                PrintMsg(SEV_NORMAL,
                                         DCDIAG_INTERSITE_USING_LAST_KNOWN_ISTG,
                                         pDsInfo->pSites[iSite].pszName,
                                         pDsInfo->pServers[*pulISTG].pszName);
                            }
                        } // end if/else meta data was up to date.
                    } else {
                        // Couldn't get the meta data/time stamp on the 
                        //   ISTG attr.
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_INTERSITE_NO_METADATA_TIMESTAMP_ABORT,
                                 pDsInfo->pServers[*pulISTG].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 Win32ErrToString(dwRet));
                        PrintRpcExtendedInfo(SEV_VERBOSE, dwRet);
                        *pulFailover = 0;
                        *pulISTG = NO_SERVER;
                        dwRet = ERROR_SUCCESS;
                        __leave;
                    }
                } else {
                    // The ISTG attribute on the home server did not match the 
                    //   ISTG attribute on the ISTG (that was claimed by the 
                    //   home server).  So now goto this new ISTG attribute.
                    //   ... watch out for endless recursion.
                    // Get next guess, which is the local ISTG attribute.
                    *pulISTG = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                                  pszLocalISTG, NULL,NULL);
                    if(*pulISTG == NO_SERVER){
                        dwRet = IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                                 NO_SERVER, 
                                                                 pszLocalISTG);
                        if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                        pszLocalISTG = NULL;
                        __leave;
                    }
                    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                    pszLocalISTG = NULL;
                    // The iRecurisionLevel+1 ensures no endless recursion.
                    dwRet = IHT_GetOrCheckISTG(pDsInfo, iSite, 
                                               piServersForSite,
                                               pulISTG, 
                                               pulFailover, 
                                               iRecursionLevel+1);
                    __leave;
                } //end if/else ISTG attributes matched. 
            } else {
                // Can't connect to current ISTG is he down?  
                //   if so -> IHT_GetNextISTG().
                // Errors for this DC should have already been reported 
                //   by the inital connection tests.
                PrintMsg(SEV_VERBOSE,
                         DCDIAG_INTERSITE_ISTG_DOWN,
                         pDsInfo->pServers[*pulISTG].pszName);
                dwRet = IHT_GetNextISTG(pDsInfo, iSite, 
                                        piServersForSite, 
                                        pulISTG,
                                        pulFailover);
                __leave;
            } // end if/else couldn't connect.
        } else { 
            // ISTG server isn't actually in this site.
            //   Needs a special function.  Code.Imrovement ... be able to
            //   identify that the server was just moved out of the site, and
            //   then figure out the failover and new ISTG anyway.
            PrintMsg(SEV_NORMAL, DCDIAG_INTERSITE_ISTG_MOVED_OUT_OF_SITE,
                     pDsInfo->pServers[*pulISTG].pszName,
                     pDsInfo->pSites[iSite].pszName);
            dwRet = IHT_GetNextISTG(pDsInfo, iSite, 
                                    piServersForSite, 
                                    pulISTG,
                                    pulFailover);
            __leave;
        }
        
    }  __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                        &dwRet)){
    }

    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
    
    return dwRet;
}

PULONG
ReplIntersiteGetBridgeheadList(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iISTG,
    ULONG                               iSite,
    ULONG                               ulFlag
    )
{
    PULONG                              piBridgeheads = NULL;
    PCONNECTION_PAIR                    paConns = NULL;
    ULONG                               iConn;
    LDAP *                              hldISTG = NULL;
    DWORD                               dwErr;

    Assert(pDsInfo != NULL);
    Assert(iSite != NO_SITE);
    Assert((ulFlag & LOCAL_BRIDGEHEADS) || (ulFlag & REMOTE_BRIDGEHEADS));
    
    dwErr = DcDiagGetLdapBinding(&(pDsInfo->pServers[iISTG]), 
                                 pDsInfo->gpCreds,
                                 FALSE, 
                                 &hldISTG);
    if(dwErr != ERROR_SUCCESS){
        SetLastError(dwErr);
        return(NULL);
    }

    // Get all the connections for every server in the site.
    paConns = IHT_GetConnectionList(pDsInfo, hldISTG, iSite);
    if(paConns == NULL){
        return(NULL);
    }

    // Trims connections to only leave the ones that have this NC on both
    //   sides of the connection, and where the src is in another site.
    paConns = IHT_TrimConnectionsForInterSite(pDsInfo, 
                                              iSite,
                                              paConns);
    if(paConns == NULL){
        return(NULL);
    }

    // Make the list requested for.
    piBridgeheads = IHT_GetEmptyServerList(pDsInfo);
    for(iConn = 0; paConns[iConn].iSrc != NO_SERVER; iConn++){
        if(ulFlag & LOCAL_BRIDGEHEADS){
            IHT_AddToServerList(piBridgeheads, paConns[iConn].iSrc);
        }
        if(ulFlag & REMOTE_BRIDGEHEADS){
            IHT_AddToServerList(piBridgeheads, paConns[iConn].iDst);
        }
    }


    return(piBridgeheads);
}

BOOL
IHT_CheckServerListForNC(
    PDC_DIAG_DSINFO                     pDsInfo,
    PULONG                              piServers,
    LPWSTR                              pszNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials
    )
/*++

Description:

    This function checks all the target servers to see if this NC
    is contained amongst them.

Parameters:

    pDsInfo
    piServers ... The servers to find the naming context among
    pszNC ... The Naming Context to check the target servers
    bDoMasters ... whether to check it for master replicas of pszNC
    bDoPartials ... whether to check it for partial replicas of pszNC

Return Value:

    returns TRUE if one of the target servers has the NC, else FALSE

  --*/
{
    ULONG                               iiDC;

    if(piServers == NULL){
        return(FALSE);
    }

    for(iiDC = 0; piServers[iiDC] != NO_SERVER; iiDC++){
        if(DcDiagHasNC(pszNC, 
                          &(pDsInfo->pServers[pDsInfo->pulTargets[iiDC]]), 
                          bDoMasters, bDoPartials)){
            return(TRUE);
        }
    }
    return(FALSE);
}

PTARGET_NC
IHT_GenerateTargetNCsList(
    PDC_DIAG_DSINFO                     pDsInfo,
    PULONG                              piServers
    )
/*++

Description:

    This generates the targets NCs based on the scope of the run,
    /a or /e.

Parameters:

    pDsInfo

Return Value:

    returns an array of TARGET_NC's, or NULL if a fatal error occurs.

  --*/
{
    ULONG                               iNC, ulTemp, iiTarget;
    LPWSTR *                            ppszzNCs = NULL;
    LPWSTR *                            ppTemp = NULL;
    PDC_DIAG_SERVERINFO                 pServer = NULL;
    PTARGET_NC                          prgTargetNCs = NULL;

    Assert(piServers);

    prgTargetNCs = LocalAlloc(LMEM_FIXED, 
                              sizeof(TARGET_NC) * (pDsInfo->cNumNCs * 2 + 1));
    if(prgTargetNCs == NULL){
        return(NULL);
    }

    iiTarget = 0;
    if(pDsInfo->pszNC != NULL){
        if(IHT_CheckServerListForNC(pDsInfo, piServers, 
                                    pDsInfo->pszNC, TRUE, FALSE)){
            // Add this to the target NC set.
            //   but first must find the NC again, this is a hack.
            for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
                if(_wcsicmp(pDsInfo->pNCs[iNC].pszDn, pDsInfo->pszNC) == 0){
                    prgTargetNCs[iiTarget].iNC = iNC;
                    prgTargetNCs[iiTarget].bMaster = TRUE;
                    iiTarget++;
                }
            }
        } else {
            // check to see if we need to check this NCs read only, only
            //  if we aren't doing a writeable, because then the read only
            //  is piggybacked on the writeable.
            if(IHT_CheckServerListForNC(pDsInfo, piServers,
                                        pDsInfo->pszNC, FALSE, TRUE)){
                // Add this to the target NC set.
                //   but first must find the NC again, this is a hack.
                for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
                    if(_wcsicmp(pDsInfo->pNCs[iNC].pszDn, pDsInfo->pszNC) == 0){
                        prgTargetNCs[iiTarget].iNC = iNC;
                        prgTargetNCs[iiTarget].bMaster = FALSE;
                        iiTarget++;
                    }
                }
            }
        }
    } else {
        // Walk through each NC and see which NCs are on the target servers.
        // BUGBUG ... this code & later code too, will test a partial NC as 
        //   a partial NC on a site of servers that are all master replicas 
        //   for the NC.
        for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
            
            prgTargetNCs[iiTarget].iNC = NO_NC;
            // Check to see if we need to check this NC's read/write
            if(IHT_CheckServerListForNC(pDsInfo, piServers,
                                        pDsInfo->pNCs[iNC].pszDn, 
                                        TRUE, FALSE)){
                // Add this to the target NC set.
                prgTargetNCs[iiTarget].iNC = iNC;
                prgTargetNCs[iiTarget].bMaster = TRUE;
                iiTarget++;
            } else {
                // check to see if we need to check this NCs read only, only
                //  if we aren't doing a writeable, because then the read only
                //  is piggybacked on the writeable.
                if(IHT_CheckServerListForNC(pDsInfo, piServers,
                                            pDsInfo->pNCs[iNC].pszDn, 
                                            FALSE, TRUE)){
                    // Add this to the target NC set.
                    prgTargetNCs[iiTarget].iNC = iNC;
                    prgTargetNCs[iiTarget].bMaster = FALSE;
                    iiTarget++;
                }
            }
        }

    }

    prgTargetNCs[iiTarget].iNC = NO_NC;
    return(prgTargetNCs);
}

PULONG
ReplIntersiteGetRemoteSitesWithNC(
    PDC_DIAG_DSINFO                     pDsInfo, 
    PULONG                              piBridgeheads,
    LPWSTR                              pszNC
    )
/*++

Description:

    Thsi function Gets all the sites from the list of bridgeheads, if there
    is a NC it makes sure that the servers have the NC.

Parameters:

    pDsInfo
    piBridgeheads (IN) - The servers to extrapolate the sites from.
    pszNC (IN) - The optional NC

Return Value:


--*/
{
    ULONG                               iiBridgehead;
    PULONG                              piSites = NULL;

    piSites = LocalAlloc(LMEM_FIXED, sizeof(ULONG) * (pDsInfo->cNumSites + 1));
    if(piSites == NULL){
        return(NULL);
    }
    piSites[0] = NO_SITE;

    for(iiBridgehead = 0; piBridgeheads[iiBridgehead] != NO_SERVER; iiBridgehead++){
        if(pszNC){
            if(DcDiagHasNC(pszNC, &(pDsInfo->pServers[piBridgeheads[iiBridgehead]]),
                           TRUE, TRUE)){
                IHT_AddToServerList(piSites, 
                          pDsInfo->pServers[piBridgeheads[iiBridgehead]].iSite);
            }
        } else {
            IHT_AddToServerList(piSites, 
                         pDsInfo->pServers[piBridgeheads[iiBridgehead]].iSite);
        }
    }

    return(piSites);
}

PULONG
ReplIntersiteTrimServerListByKCCUpness(
    PDC_DIAG_DSINFO                     pDsInfo, 
    PKCCFAILINGSERVERS                  prgKCCFailingServers,
    PULONG                              piOriginalServers
    )
/*++

Description:

    This trims the list given to it by whether the KCC things they're up.

Parameters:

    pDsInfo
    prgKCCFailingServers (IN) - Holds which servers are failing.
    piOriginalServers (INOUI) - The server list to trim.
    
Return value

    NULL if it fails, otherwise teh address of the piOriginalServers.

--*/
{
    ULONG                               iPut, iCheck;
    
    if(piOriginalServers == NULL){
        return(NULL);
    }

    iPut = 0;
    iCheck = 0;
    while(piOriginalServers[iCheck] != NO_SERVER){
        if(!prgKCCFailingServers[piOriginalServers[iCheck]].bDown){\
            piOriginalServers[iPut] = piOriginalServers[iCheck];
            iPut++;
        }
        iCheck++;
    }

    return(piOriginalServers);
}

PULONG
ReplIntersiteTrimServerListByReacheability(
    PDC_DIAG_DSINFO                     pDsInfo, 
    PULONG                              piUnreacheableServers,
    PULONG                              piOriginalServers
    )
/*++

Description:

    This trims the list given to it by whether dcdiag could verify
    that the servers were up (ping) with and able to DsBind for 
    replication purposes.

Parameters:

    pDsInfo
    piUnreacheableServers (IN) - The state of server from dcdiag's perspective.
        Which is always right, BTW ;)
    piOriginalServers (INOUI) - The server list to trim.
    
Return value

    NULL if it fails, otherwise the address of the piOriginalServers.

--*/
{
    ULONG                               iPut, iCheck;
    
    if(piOriginalServers == NULL){
        return(NULL);
    }

    iPut = 0;
    iCheck = 0;
    while(piOriginalServers[iCheck] != NO_SERVER){
        if(pDsInfo->pServers[piOriginalServers[iCheck]].bDnsIpResponding
           && pDsInfo->pServers[piOriginalServers[iCheck]].bDsResponding){
            piOriginalServers[iPut] = piOriginalServers[iCheck];
            iPut++;
        }
        iCheck++;
    }

    return(piOriginalServers);
}

PULONG
ReplIntersiteTrimServerListByUpness(
    PDC_DIAG_DSINFO                     pDsInfo, 
    PKCCFAILINGSERVERS                  prgKCCFailingServers,
    PULONG                              piUnreacheableServers,
    PULONG                              piOriginalServers
    )
/*++

Description:

    This trims the list given to it by whether the KCC AND whether
    dcdiag thinks the servers are up.

Parameters:

    pDsInfo
    prgKCCFailingServers (IN) - Holds which servers are failing.
    piUnreacheableServers (IN) - Servers dcdiag couldn't reach.
    piOriginalServers (INOUI) - The server list to trim.
    
Return value

    NULL if it fails, otherwise the address of the piOriginalServers.

--*/
{
    ULONG                               iPut, iCheck;
    
    if(piOriginalServers == NULL){
        return(NULL);
    }

    iPut = 0;
    iCheck = 0;
    while(piOriginalServers[iCheck] != NO_SERVER){
        if(!prgKCCFailingServers[piOriginalServers[iCheck]].bDown
           && !prgKCCFailingServers[piOriginalServers[iCheck]].bFailures
           && pDsInfo->pServers[piOriginalServers[iCheck]].bDnsIpResponding
           && pDsInfo->pServers[piOriginalServers[iCheck]].bDsResponding){
            piOriginalServers[iPut] = piOriginalServers[iCheck];
            iPut++;
        }
        iCheck++;
    }

    return(piOriginalServers);
}

VOID
ReplIntersiteDbgPrintISTGFailureParams(
    PDC_DIAG_DSINFO                     pDsInfo, 
    ULONG                               iSite, 
    ULONG                               iISTG, 
    ULONG                               ulIntersiteFailoverTries, 
    ULONG                               ulIntersiteFailoverTime, 
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures
    )
/*++

Description:

    This prints out a little interesting information if the /d flag is
    specified.

Parameters:

    pDsInfo
    iSite - the site wer are doing
    iISTG - the ISTG of iSite.
    ulIntersiteFailoverTries - The failover param from teh KCC
    ulIntersiteFailoverTime - the failover param from the KCC
    pConnectionFailures - The connection failure cache
    pLinkFailures - The link failure cache
    
    
--*/
{
    if(!(gMainInfo.ulSevToPrint >= SEV_DEBUG)){
        return;
    }
    PrintIndentAdj(1);
    PrintMsg(SEV_DEBUG, DCDIAG_INTERSITE_DBG_ISTG_FAILURE_PARAMS,
             pDsInfo->pServers[iISTG].pszName,
             ulIntersiteFailoverTries,
             ulIntersiteFailoverTime/60);
    PrintIndentAdj(-1);
    // Code.Improvement: Print out failure caches, steal code from repadmin.
}

DWORD
ReplIntersiteGetISTGInfo(
    PDC_DIAG_DSINFO                     pDsInfo, 
    ULONG                               iSite, 
    PULONG                              piISTG, 
    PULONG                              pulIntersiteFailoverTries, 
    PULONG                              pulIntersiteFailoverTime, 
    DS_REPL_KCC_DSA_FAILURESW **        ppConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW **        ppLinkFailures
    )
/*++

Description:

    This function's purpose is to get all the ISTG info that is necessary for
    the rest of the intersite test to run.  Basically it finds the ISTG,
    using IHT_GetOrCheckISTG(), then gets the LDAP and DS bindings to make
    sure the ISTG can be connected, then gets the connection and link failure
    caches, and finally the failover parameters.

Parameters:

    pDsInfo .
    iSite (IN) - The site we are analyzing.
    piISTG (OUT) - This is an index into pDsInfo->pServers[iISTG] for which
        server is the ISTG.
    pulIntersiteFailoverTries (OUT) - This is how many retries the KCC will
        try before declaring a birdgehead stale, if the *pulIntersiteFailoverTime
        is already exceeded.
    pulIntersiteFailoverTime (OUT) - This is how long before a KCC will call a
        bridgehead stale, if the *pulIntersiteFailoverTries are exceeded.  Note
        that it takes both IntersiteFailover params to be exceeded before a
        bridgehead is declared stale or down for the KCC.
    ppConnectionFailures - The connection failure cache off the ISTG.
    ppLinkFailures - The link failures cache off the ISTG.    

Return Value:

    If there is a fatal error, and the ISTG, or failure caches are not 
    retrieveable, then this will not be ERROR_SUCCESS.

--*/
{
    PULONG                              piSiteServers = NULL;
    ULONG                               ul;
    DWORD                               dwRet, dwRetLdap, dwRetDs;
    ULONG                               ulFailoverTime = 0;
    LDAP *                              hldISTG = NULL;
    HANDLE                              hDSISTG = NULL;

    __try{

        *piISTG = NO_SERVER;
        *ppConnectionFailures = NULL;
        *ppLinkFailures = NULL;

        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BEGIN_GET_ISTG_INFO);

        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(1); 
        }
        
        piSiteServers = IHT_GetServerList(pDsInfo);
        piSiteServers = IHT_TrimServerListBySite(pDsInfo, iSite, piSiteServers);
        if(piSiteServers == NULL){
            dwRet = IHT_PrintListError(GetLastError());
            __leave;
        }

        // FIRST) Find the Intersite Topology Generator (ISTG).
        *piISTG = NO_SERVER;
        dwRet = IHT_GetOrCheckISTG(pDsInfo, iSite, 
                                   piSiteServers, 
                                   piISTG, 
                                   &ulFailoverTime, 
                                   0);
        if(dwRet == ERROR_SUCCESS){
            if(*piISTG == NO_SERVER){
                // For any error, GetOrCheckISTG has printed out
                //   an message.
                dwRet = ERROR_DS_SERVER_DOWN;
                __leave;
            } else {
                // Only need to print things if GetOrCheckISTG() has returned
                //   successful results, ie ERROR_SUCCESS, and valid server 
                //   index.
                if(ulFailoverTime == 0){
                    // The returned server is the authoratitive ISTG.
                    // Printing is our responsibility here.
                    PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_THE_SITES_ISTG_IS,
                             pDsInfo->pSites[iSite].pszName, 
                             pDsInfo->pServers[*piISTG].pszName);
                } else {
                    // The returned server is the next ISTG to come.
                    // Printing is our responsibility in this case.
                    if(ulFailoverTime < 60){
                        PrintMsg(SEV_NORMAL, 
                                 DCDIAG_INTERSITE_ISTG_FAILED_NEW_ISTG_IN_MIN,
                                 pDsInfo->pServers[*piISTG].pszName, 
                                 ulFailoverTime);
                    } else {
                        PrintMsg(SEV_NORMAL, 
                                 DCDIAG_INTERSITE_ISTG_FAILED_NEW_ISTG_IN_HRS,
                                 pDsInfo->pServers[*piISTG].pszName, 
                                 ulFailoverTime / 60, ulFailoverTime % 60);
                    }
                }
            }
        } else {
            // an error from IHT_GetOrCheckISTG() is a fatal error, but the
            //    a message should have been already printed out.
            __leave;
        }

        // SECOND) Get ISTG's Ldap and Ds bindings.
        dwRetLdap = DcDiagGetLdapBinding(&(pDsInfo->pServers[*piISTG]), 
                                         pDsInfo->gpCreds, FALSE, &hldISTG);
        dwRetDs = DcDiagGetDsBinding(&(pDsInfo->pServers[*piISTG]), 
                                     pDsInfo->gpCreds, &hDSISTG);
        if(dwRetLdap != ERROR_SUCCESS || dwRetDs != ERROR_SUCCESS){
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_CONNECT_FAILURE_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            if (ERROR_SUCCESS != dwRetDs)
            {
               PrintRpcExtendedInfo(SEV_VERBOSE, dwRetDs);
            }
            dwRet = (dwRetLdap != ERROR_SUCCESS)? dwRetLdap : dwRetDs;
            __leave;
        }
        
        // Get failure cache of ISTG.
        dwRet = IHT_GetFailureCaches(pDsInfo, *piISTG, hDSISTG, 
                                     ppConnectionFailures, 
                                     ppLinkFailures);
        if(dwRet != ERROR_SUCCESS){
            // IHT_GetFailureCaches took care of printing errors, just fail out.
            __leave;
        }
        
        // This function will use default values if it can't get these
        //   two values from the registry of the ISTG.
        IHT_GetISTGsBridgeheadFailoverParams(pDsInfo, *piISTG,
                                             pulIntersiteFailoverTries,
                                             pulIntersiteFailoverTime);
        
        // Got an ISTG, it's bindings, and the failure params

    } __finally { 
        
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(-1); 
        }
        
        if(piSiteServers) { LocalFree(piSiteServers); }
        if(dwRet != ERROR_SUCCESS){
            // free up return variables, because function failed.
            if(*ppConnectionFailures != NULL) {
                DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, 
                                  *ppConnectionFailures);
                *ppConnectionFailures = NULL;
            }
            if(*ppLinkFailures != NULL) {
                DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, 
                                  *ppLinkFailures);
                *ppLinkFailures = NULL;
            }
        } // end of if function failed, so clean upstuff.
    } // End of clean up memory.

    return(dwRet);
} // End of ReplIntersiteGetISTGInfo()


DWORD
ReplIntersiteCheckBridgeheads(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iSite,
    ULONG                               iISTG,
    ULONG                               ulIntersiteFailoverTries,
    ULONG                               ulIntersiteFailoverTime,
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures,
    PULONG *                            ppiBridgeheads,
    PULONG *                            ppiKCCDownServers,
    PKCCFAILINGSERVERS *                pprgKCCFailingServers,
    PULONG *                            ppiUnreacheableServers
    )
/*++

Description:
   
    This function is simply to print the down bridgeheads, and return a list of
    Bridgeheads, Servers considered down in the KCC, and servers that are 
    unreacheable.
        
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to consider.
    iISTG - The index into pDsInfo->pServers[iISTG] of the ISTG
    ulIntersiteFailoverTries - Intersite failover tries from the ISTG.
    ulIntersiteFailoverTime - Intersite failover time from the ISTG.
    pConnectionFailures - Connection Failures from the ISTG.
    pLinkFailures - Link Failures from the ISTG.
    ppiBridgeheads (OUT) - The list of bridgeheads to return for site iSite.
    ppiKCCDownServers (OUT) - Down servers as calculated from the above params.
    pprgKCCFailingServers (OUT) - The failures, and the time left til the server
        is down.
    ppiUnreacheableServers - The servers that we haven't contacted.    

Return Value:

    Returns a Win32 Error code for success or not.  Should only return a value
    other than ERROR_SUCCESS, if it couldn't possibly go on.
    
--*/
{
    DWORD                               dwRet = ERROR_SUCCESS;
    ULONG                               iiServer;
    LONG                                lTriesLeft;
    LONG                                lTimeLeft;
    
    __try {
        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BEGIN_CHECK_BRIDGEHEADS);
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(1); 
        }

        // Get List of bridgeheads.
        *ppiBridgeheads = ReplIntersiteGetBridgeheadList(pDsInfo, iISTG, iSite, 
                                    LOCAL_BRIDGEHEADS | REMOTE_BRIDGEHEADS);
        if(*ppiBridgeheads == NULL){
            dwRet = GetLastError();
            __leave;
        }

        // Get KCC's down & failing servers.
        *ppiKCCDownServers = IHT_GetKCCFailingServersLists(pDsInfo,
                                                      ulIntersiteFailoverTries, 
                                                      ulIntersiteFailoverTime,
                                                      pConnectionFailures, 
                                                      pLinkFailures,
                                                      pprgKCCFailingServers);
        if(*ppiKCCDownServers == NULL){
            dwRet = GetLastError();
            __leave;
        }
        Assert(*pprgKCCFailingServers && "Should have been set by "
               "IHT_GetKCCFailingServers() if we got this far"); 

        // Get servers that we couldn't contact.
        *ppiUnreacheableServers = ReplIntersiteGetUnreacheableServers(pDsInfo);

        // Do local site ...


        // for each bridgehead
        for(iiServer = 0; (*ppiBridgeheads)[iiServer] != NO_SERVER; iiServer++){
            if(pDsInfo->pszNC){
                if(!DcDiagHasNC(pDsInfo->pszNC, 
                                &(pDsInfo->pServers[(*ppiBridgeheads)[iiServer]]),
                                TRUE, TRUE)){
                    // This bridgehead doesn't actually have the specified NC,
                    //   so skip it.
                    continue;
                }
            }

            if(((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]]).bDown){
                Assert(IHT_ServerIsInServerList(*ppiKCCDownServers, 
                                                (*ppiBridgeheads)[iiServer]));
                // KCC is showing enough failures to declare server down.

                PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_KCC_DOWN_REMOTE,
                         pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                         pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                         pDsInfo->pSites[iSite].pszName);

                if(!pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDnsIpResponding 
                   || !pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDsResponding){
                    // Also we couldn't contact the server

                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_BRIDGEHEAD_UNREACHEABLE_REMOTE,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);
                }
            } else if ((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].bFailures) {
                Assert(!IHT_ServerIsInServerList(*ppiKCCDownServers, (*ppiBridgeheads)[iiServer]));
                // KCC is showing some failures.

                lTriesLeft = min((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lConnTriesLeft,
                                 (*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lLinkTriesLeft);
                lTimeLeft = min((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lConnTimeLeft,
                                (*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lLinkTimeLeft);
                Assert(lTriesLeft > 0 || lTimeLeft > 0);
                Assert(lTriesLeft != FAILOVER_INFINITE 
                       || lTimeLeft != FAILOVER_INFINITE);

                if(lTriesLeft == FAILOVER_INFINITE && lTimeLeft == FAILOVER_INFINITE){
                    Assert(!"Don't we have to have a PrintMsg() here. Why doesn't this fall under"
                           " the else clause at the end?\n");
                } else if(lTriesLeft < 0){
                    PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_TIME_LEFT,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                             lTimeLeft/60/60, lTimeLeft/60%60);

                } else if (lTimeLeft < 0) {
                    PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_TRIES_LEFT,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                             lTriesLeft);
                } else {
                    PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_BOTH_LEFT,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                             lTimeLeft/60/60, lTimeLeft/60%60, lTriesLeft);
                }

                if(!pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDnsIpResponding 
                   || !pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDsResponding){
                    // Also we couldn't contact the server

                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_BRIDGEHEAD_UNREACHEABLE_REMOTE,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);
                }
            } else {
                // The bridgehead appears to be up and replicating fine.
                Assert(!IHT_ServerIsInServerList(*ppiKCCDownServers, (*ppiBridgeheads)[iiServer]));

                PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BRIDGEHEAD_UP,
                         pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                         pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);

                if(!pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDnsIpResponding 
                   || !pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDsResponding){
                    // Also we couldn't contact the server

                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_BRIDGEHEAD_UNREACHEABLE_REMOTE,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);
                }
            } // end if/elseif/else state of bridgehead upness.

        } // End of for each bridgehead

    } __finally {
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(-1); 
        }
        if(dwRet != ERROR_SUCCESS){
            // Function failed clean up return parameters, but ONLY ON ERROR.
            if(*ppiBridgeheads){
                LocalFree(*ppiBridgeheads);
                *ppiBridgeheads = NULL;
            }
            if(*ppiKCCDownServers) { 
                LocalFree(*ppiKCCDownServers); 
                *ppiKCCDownServers = NULL;
            }
            if(*pprgKCCFailingServers){
                LocalFree(*pprgKCCFailingServers);
                *pprgKCCFailingServers = NULL;
            }
            if(*ppiUnreacheableServers){
                LocalFree(*ppiUnreacheableServers);
                *ppiUnreacheableServers = NULL;
            }
        }
    }
    
    return(dwRet);
} // End of ReplIntersiteCheckBridgeheads()

BOOL
ReplIntersiteDoThisNCP(
    PTARGET_NC                         prgLocalNC,
    PTARGET_NC                         paRemoteNCs
    )
/*++

Description:
   
    A predicate function (that the P at the end), determines whether
    the NC in prgLocalNC is in the array of NCs in paRemoteNCs.
        
Parameters:

    prgLocalNC - The NC to find
    paRemoteNCs - The NCs to search.

Return Value:

    TRUE if it finds the NC in the NCs, FALSE otherwise.
        
--*/
{
    ULONG                             iiNC;
    
    Assert(paRemoteNCs != NULL && prgLocalNC != NULL);

    for(iiNC = 0; paRemoteNCs[iiNC].iNC != NO_NC; iiNC++){
        if(prgLocalNC->iNC == paRemoteNCs[iiNC].iNC
           && (paRemoteNCs[iiNC].bMaster || (prgLocalNC->bMaster 
                                             && paRemoteNCs[iiNC].bMaster))){
            return(TRUE);
        }
    }
    return(FALSE);
}

BOOL
ReplIntersiteServerListHasNC(
    PDC_DIAG_DSINFO                    pDsInfo,
    PULONG                             piServers,
    ULONG                              iNC,
    BOOL                               bMaster,
    BOOL                               bPartial
    )
/*++

Description:
   
    This is just like DcDiagHaNC, except it operates on a list of servers,
    instead of on a single server.
        
Parameters:

    pDsInfo
    piServers - The list of servers to search for the NC
    iNC - The NC to search for.
    bMaster - To search for it as a master NC
    bPartial - To search for it as a partial NC

Return Value:

    TRUE if it finds the NC in the list of servers, FALSE otherwise.
        
--*/
{
    ULONG                              iiSer;

    if(piServers == NULL){
        return(FALSE);
    }

    for(iiSer = 0; piServers[iiSer] != NO_SERVER; iiSer++){
        if(DcDiagHasNC(pDsInfo->pNCs[iNC].pszDn,
                       &(pDsInfo->pServers[piServers[iiSer]]),
                       bMaster, bPartial)){
            return(TRUE);
        }
    }
    return(FALSE);
}

DWORD
ReplIntersiteSiteAnalysis(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iSite,
    ULONG                               iISTG,
    ULONG                               ulIntersiteFailoverTries,
    ULONG                               ulIntersiteFailoverTime,
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures,
    PULONG                              piBridgeheads,
    PULONG                              piKCCDownServers,
    PKCCFAILINGSERVERS                  prgKCCFailingServers,
    PULONG                              piUnreacheableServers
    )
/*++
Description:
   
    This function does the site analysis to determine which NCs can't
    replicate in.
        
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to consider.
    iISTG - The index into pDsInfo->pServers[iISTG] of the ISTG
    ulIntersiteFailoverTries - Intersite failover tries from the ISTG.
    ulIntersiteFailoverTime - Intersite failover time from the ISTG.
    pConnectionFailures - Connection Failures from the ISTG.
    pLinkFailures - Link Failures from the ISTG.
    piKCCDownServers - Down servers as calculated from the above params.

Return Value:

    Returns a Win32 Error code for success or not.  If all NCs can progress in
    replication then ERROR_SUCCESS is returned.

--*/
{
    DWORD                               dwRet = ERROR_SUCCESS;
    PTARGET_NC                          prgLocalNCs = NULL;
    PTARGET_NC                          prgRemoteNCs = NULL;
    PULONG                              piRSites = NULL;
    ULONG                               iiBridgehead;
    ULONG                               iiNC;
    ULONG                               iRSite;
    // These server lists will be trimmed by thier level of "upness".  See below.
    PULONG                              piLocalBridgeheads = NULL;
    PULONG                              piExplicitBridgeheads = NULL;
    PULONG                              piKCCUpBridgeheads = NULL;
    PULONG                              piReacheableBridgeheads = NULL;
    PULONG                              piUpBridgeheads = NULL;
    // These correspong to the 3 lists above, but trimmed by Site.
    PULONG                              piRemoteBridgeheads = NULL;
    PULONG                              piExpGotSiteBrdhds = NULL;
    PULONG                              piKUpGotSiteBrdhds = NULL;
    PULONG                              piReachGotSiteBrdhds = NULL;
    PULONG                              piUpGotSiteBrdhds = NULL;
    // These will be trimed by NC as well
    PULONG                              piExpGotNCGotSiteBrdhds = NULL;
    PULONG                              piKUpGotNCGotSiteBrdhds = NULL;
    PULONG                              piReachGotNCGotSiteBrdhds = NULL;
    PULONG                              piUpGotNCGotSiteBrdhds = NULL;

    BOOL                                bFailures;

    Assert(piBridgeheads);
    Assert(piKCCDownServers);
    Assert(prgKCCFailingServers);
    Assert(piUnreacheableServers);
    
    __try {
        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BEGIN_SITE_ANALYSIS);
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(1); 
        }

        // ---------------------------------------------------------------------  
        // if (there are no failures in the bridgeheads, then we need not
        // go on ... this site is OK.  This is sort of an opt out early thing.
        bFailures = FALSE;
        for(iiBridgehead = 0; piBridgeheads[iiBridgehead] != NO_SERVER; iiBridgehead++){

            if(prgKCCFailingServers[piBridgeheads[iiBridgehead]].bDown){
                bFailures = TRUE;
            }
            if(prgKCCFailingServers[piBridgeheads[iiBridgehead]].bFailures){
                bFailures = TRUE;
            }
            if(IHT_ServerIsInServerList(piUnreacheableServers, piBridgeheads[iiBridgehead])){
                bFailures = TRUE;
            }
        }
        if(!bFailures){
            // No brigeheads failed or even are failing or even are
            //    just  unreacheable, so print all is fine and leave;
            PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_ALL_SITES_UP,
                     pDsInfo->pSites[iSite].pszName);
            __leave;
        }

        // ---------------------------------------------------------------------
        // Get all the target remote sites.
        piRSites = ReplIntersiteGetRemoteSitesWithNC(pDsInfo, 
                                                     piBridgeheads, 
                                                     pDsInfo->pszNC);
        if(piRSites == NULL){
            dwRet = IHT_PrintListError(GetLastError());
            __leave;
        }

        // ---------------------------------------------------------------------
        // Detemine various arrays of bridgeheads with different kinds of 
        //   "upness".  Each version of upness is explained when set.
        
        // This is a list of the local bridgeheads.
        piLocalBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piLocalBridgeheads = IHT_TrimServerListBySite(pDsInfo, iSite, piLocalBridgeheads);

        // piExplicitBridgeheads or ipExpBrdhdsXXXX, are lists that will 
        //   be used to determine if we need only pay attention to bridgeheads.
        piExplicitBridgeheads = IHT_GetExplicitBridgeheadList(pDsInfo, iISTG);

        // piKCCUpBridgeheads, or piKUpBrdhdsXXXX, are lists with only
        //   bridgeheads that qualify in the kCC of the ISTG as being up.
        piKCCUpBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piKCCUpBridgeheads = 
            ReplIntersiteTrimServerListByKCCUpness(pDsInfo,
                                                   prgKCCFailingServers,
                                                   piKCCUpBridgeheads);

        // piReacheableBridgeheads, or piReachBrdhdsXXXX, are lists with only
        //   bridgeheads that dcdiag personally contacted.
        piReacheableBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piReacheableBridgeheads = 
            ReplIntersiteTrimServerListByReacheability(pDsInfo,
                                                       piUnreacheableServers,
                                                       piReacheableBridgeheads);

        // piUpBridgeheads, or piUpBrdhdsXXXX, are lists with only bridgeheads
        //   that are up, by the contrived definition described in the 
        //   ReplIntersiteTrimByUpness() function.
        piUpBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piUpBridgeheads = 
            ReplIntersiteTrimServerListByUpness(pDsInfo,
                                                prgKCCFailingServers,
                                                piUnreacheableServers,
                                                piUpBridgeheads);

        // Check to make sure all these lists were setup correctly.
        if(!piExplicitBridgeheads || !piKCCUpBridgeheads 
           || !piReacheableBridgeheads || !piUpBridgeheads){
            dwRet = IHT_PrintListError(GetLastError()); 
            __leave;
        }

        // ---------------------------------------------------------------------
        // Setup our target NC's array, so we can walk through it in a moment.
        if(pDsInfo->pszNC != NULL){
            prgLocalNCs = LocalAlloc(LMEM_FIXED, sizeof(TARGET_NC) * 3);
            if(prgLocalNCs == NULL){
                dwRet = IHT_PrintListError(GetLastError());
                __leave;
            }
            prgLocalNCs[0].iNC = DcDiagGetNCNum(pDsInfo, pDsInfo->pszNC, NULL);
            if(prgLocalNCs[0].iNC == NO_NC){
                dwRet = IHT_PrintInconsistentDsCopOutError(pDsInfo, iISTG, NULL);
                __leave;
            }
            prgLocalNCs[0].bMaster = ReplIntersiteServerListHasNC(pDsInfo, 
                                                            piLocalBridgeheads,
                                                            prgLocalNCs[0].iNC, 
                                                            TRUE, FALSE);
            if(!ReplIntersiteServerListHasNC(pDsInfo, piLocalBridgeheads, prgLocalNCs[0].iNC, FALSE, TRUE)){
                PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_MISTAKE);
                dwRet = ERROR_SUCCESS;
                __leave;
            }
            prgLocalNCs[1].iNC = NO_NC;
        } else {
            // Get all the target NCs for this site.
            if((prgLocalNCs = IHT_GenerateTargetNCsList(pDsInfo, piLocalBridgeheads)) 
               == NULL){
                dwRet = IHT_PrintListError(GetLastError());
                __leave;
            }

            if(prgLocalNCs[0].iNC == NO_NC){
                PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_MISTAKE);
                Assert(!"This is an invalid code path now ... I think.  -BrettSh");
                dwRet = ERROR_SUCCESS;
                __leave;
            }
        }

        // -------------------------------------------------------------------
        // Start walking through the sites.
        for(iRSite = 0; iRSite < pDsInfo->cNumSites; iRSite++){

            if(iRSite == iSite){
                // Skip the local site.
                continue;
            }

            // Get site stuff.
            piRemoteBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
            piExpGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piExplicitBridgeheads);
            piKUpGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piKCCUpBridgeheads);
            piReachGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piReacheableBridgeheads);
            piUpGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piUpBridgeheads);
            piRemoteBridgeheads = IHT_TrimServerListBySite(pDsInfo, 
                                                           iRSite, 
                                                           piRemoteBridgeheads);
            piExpGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                          piExpGotSiteBrdhds);
            piKUpGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                        piKUpGotSiteBrdhds);
            piReachGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                          piReachGotSiteBrdhds);
            piUpGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                       piUpGotSiteBrdhds);
            if(!piExpGotSiteBrdhds || !piKUpGotSiteBrdhds 
               || !piReachGotSiteBrdhds || ! piUpGotSiteBrdhds){
                dwRet = IHT_PrintListError(GetLastError()); 
                __leave;
            }
            
            prgRemoteNCs = IHT_GenerateTargetNCsList(pDsInfo, piRemoteBridgeheads);

            // Start walking through each of the target NCs.
            for(iiNC = 0; prgLocalNCs[iiNC].iNC != NO_NC; iiNC++){

                // Deterimine if the Bridgeheads of the remote site support this NC.
                if(!ReplIntersiteDoThisNCP(&(prgLocalNCs[iiNC]), prgRemoteNCs)){
                    // This paticular NC isn't on the remote site.
                    continue;
                }
                
                if(prgLocalNCs[iiNC].bMaster){
                    PrintMsg(SEV_DEBUG, DCDIAG_INTERSITE_ANALYSIS_GOT_TO_ANALYSIS_RW,
                             pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName,
                             pDsInfo->pSites[iRSite].pszName);
                } else {
                    PrintMsg(SEV_DEBUG, DCDIAG_INTERSITE_ANALYSIS_GOT_TO_ANALYSIS_RO,
                        pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName,
                        pDsInfo->pSites[iRSite].pszName);
                }

                piExpGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piExpGotSiteBrdhds);
                piKUpGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piKUpGotSiteBrdhds);
                piReachGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piReachGotSiteBrdhds);
                piUpGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piUpGotSiteBrdhds);
                
                piExpGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                 prgLocalNCs[iiNC].iNC,
                                                                 TRUE, 
                                                                 !prgLocalNCs[iiNC].bMaster,
                                                                 piExpGotNCGotSiteBrdhds);
                piKUpGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                 prgLocalNCs[iiNC].iNC,
                                                                 TRUE,
                                                                 !prgLocalNCs[iiNC].bMaster,
                                                                 piKUpGotNCGotSiteBrdhds);
                piReachGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                   prgLocalNCs[iiNC].iNC,
                                                                   TRUE,
                                                                   !prgLocalNCs[iiNC].bMaster,
                                                                   piReachGotNCGotSiteBrdhds);
                piUpGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                prgLocalNCs[iiNC].iNC,
                                                                TRUE,
                                                                !prgLocalNCs[iiNC].bMaster,
                                                                piUpGotNCGotSiteBrdhds);
                if(!piExpGotNCGotSiteBrdhds || !piKUpGotNCGotSiteBrdhds 
                   || !piReachGotNCGotSiteBrdhds || !piUpGotNCGotSiteBrdhds){
                    dwRet = IHT_PrintListError(GetLastError());
                    __leave;
                }
            
                if(piExpGotNCGotSiteBrdhds[0] != NO_SERVER){
                    // We've got explicit bridgeheads.
                    // readjust the upness lists.
                    piKUpGotNCGotSiteBrdhds = IHT_AndServerLists(pDsInfo,
                                                                 piKUpGotNCGotSiteBrdhds,
                                                                 piExpGotNCGotSiteBrdhds);
                    piReachGotNCGotSiteBrdhds = IHT_AndServerLists(pDsInfo,
                                                                   piReachGotNCGotSiteBrdhds,
                                                                   piExpGotNCGotSiteBrdhds);
                    piUpGotNCGotSiteBrdhds = IHT_AndServerLists(pDsInfo,
                                                                piUpGotNCGotSiteBrdhds,
                                                                piExpGotNCGotSiteBrdhds);
                    if(!piKUpGotNCGotSiteBrdhds 
                       || !piReachGotNCGotSiteBrdhds 
                       || !piUpGotNCGotSiteBrdhds){
                        dwRet = IHT_PrintListError(GetLastError());
                        __leave;
                    }
                }

                // FINALLY DO FAILURE ANALYSIS ==============================
                // Note: this is the mean this is wh)at it all is for. :)
                // for prgTargetNCs[iiNC], iRSite.

                if(piKUpGotNCGotSiteBrdhds[0] == NO_SERVER){
                    if(prgLocalNCs[iiNC].bMaster){
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_SERVERS_AVAIL_RW,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    } else {
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_SERVERS_AVAIL_RO,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    }
                } else if(piUpGotNCGotSiteBrdhds[0] == NO_SERVER){
                    if(prgLocalNCs[iiNC].bMaster){
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_GOOD_SERVERS_AVAIL_RW,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    } else {
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_GOOD_SERVERS_AVAIL_RO,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    }
                } else {
                    if(prgLocalNCs[iiNC].bMaster){
                        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_SITE_IS_GOOD_RW,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    } else {
                        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_SITE_IS_GOOD_RO,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    }
                }

                // END FAILURE ANALYSIS =====================================

                // Clean up the server lists for this NC
                if(piExpGotNCGotSiteBrdhds){ 
                    LocalFree(piExpGotNCGotSiteBrdhds);
                    piExpGotNCGotSiteBrdhds = NULL;
                }
                if(piKUpGotNCGotSiteBrdhds){ 
                    LocalFree(piKUpGotNCGotSiteBrdhds);
                    piKUpGotNCGotSiteBrdhds = NULL;
                }
                if(piReachGotNCGotSiteBrdhds){ 
                    LocalFree(piReachGotNCGotSiteBrdhds); 
                    piReachGotNCGotSiteBrdhds = NULL;
                }
                if(piUpGotNCGotSiteBrdhds){ 
                    LocalFree(piUpGotNCGotSiteBrdhds);
                    piUpGotNCGotSiteBrdhds = NULL;
                }


            }  // end for each NC
        
        
            // Clean up the server lists for this Site.
            if(piRemoteBridgeheads){
                LocalFree(piRemoteBridgeheads);
                piRemoteBridgeheads = NULL;
            }
            if(piExpGotSiteBrdhds){
                LocalFree(piExpGotSiteBrdhds);
                piExpGotSiteBrdhds = NULL;
            }
            if(piKUpGotSiteBrdhds){
                LocalFree(piKUpGotSiteBrdhds);
                piKUpGotSiteBrdhds = NULL;
            }
            if(piReachGotSiteBrdhds){
                LocalFree(piReachGotSiteBrdhds);
                piReachGotSiteBrdhds = NULL;
            }
            if(piUpGotSiteBrdhds){
                LocalFree(piUpGotSiteBrdhds);
                piUpGotSiteBrdhds = NULL;
            }
            if(prgRemoteNCs){
                LocalFree(prgRemoteNCs);
                prgRemoteNCs = NULL;
            }

        } // end for each site.

    } __finally {
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(-1); 
        }
        if(prgLocalNCs){ LocalFree(prgLocalNCs); }
        if(prgRemoteNCs){ LocalFree(prgRemoteNCs); }
        
        if(piRSites) { LocalFree(piRSites); }

        // Clean up all those darn server lists I used to do analysis.
        if(piExplicitBridgeheads){ LocalFree(piExplicitBridgeheads); }
        if(piKCCUpBridgeheads){ LocalFree(piKCCUpBridgeheads); }
        if(piReacheableBridgeheads){ LocalFree(piReacheableBridgeheads); }
        if(piUpBridgeheads){ LocalFree(piUpBridgeheads); }
        if(piRemoteBridgeheads) { LocalFree(piRemoteBridgeheads); }
        if(piExpGotSiteBrdhds){ LocalFree(piExpGotSiteBrdhds); }
        if(piKUpGotSiteBrdhds){ LocalFree(piKUpGotSiteBrdhds); }
        if(piReachGotSiteBrdhds){ LocalFree(piReachGotSiteBrdhds); }
        if(piUpGotSiteBrdhds){ LocalFree(piUpGotSiteBrdhds); }
        if(piExpGotNCGotSiteBrdhds){ LocalFree(piExpGotNCGotSiteBrdhds); }
        if(piKUpGotNCGotSiteBrdhds){ LocalFree(piKUpGotNCGotSiteBrdhds); }
        if(piReachGotNCGotSiteBrdhds){ LocalFree(piReachGotNCGotSiteBrdhds); }
        if(piUpGotNCGotSiteBrdhds){ LocalFree(piUpGotNCGotSiteBrdhds); }
        if(piLocalBridgeheads) { LocalFree(piLocalBridgeheads); }
    }

    return(dwRet);
}

DWORD
ReplIntersiteDoOneSite(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iSite
    )
/*++
Description:
   
    This is the heart of the Inbound Intersite Replication test.  This function,
    does inbound intersite replication test on one site (iSite).  It basically
    holds together the 3 most important functions of intersite:
        ReplIntersiteGetISTGInfo()
        ReplIntersiteCheckBridgeheads()
        ReplIntersiteSiteAnalysis()
       
    
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to test.

Return Value:

    Returns a Win32 Error on whether it could proceed or whether inbound
    intersite replication seems A-OK.
    
Notes:

    The function has 3 parts,
        1) Get and establish bindings to the ISTG or furture ISTG, and get
            various ISTG info, failure caches, failover params, etc
        2) Print out down bridgeheads wrt to the KCC, and bridgeheads that
            look like they are not responding and starting to fail in the KCC.
        3) Do site analysis based on the down bridgeheads, and print out an
            NCs and remote sites that seem to be not replicating in.

--*/
{
    DWORD                               dwRet;
    
    // Things returned by ReplIntersiteGetISTG()
    ULONG                               iISTG = NO_SERVER;
    ULONG                               ulIntersiteFailoverTries = 0;
    ULONG                               ulIntersiteFailoverTime = 0;
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures = NULL;
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures = NULL;    
    PULONG                              piBridgeheads = NULL;
    PULONG                              piKCCDownServers = NULL;
    PKCCFAILINGSERVERS                  prgKCCFailingServers = NULL;
    PULONG                              piUnreacheableServers = NULL;

    __try{
    
        // Get ISTG and related info ...
        // --------------------------------------------------------------------
        dwRet = ReplIntersiteGetISTGInfo(pDsInfo, iSite, 
                                         &iISTG, 
                                         &ulIntersiteFailoverTries,
                                         &ulIntersiteFailoverTime,
                                         &pConnectionFailures,
                                         &pLinkFailures);
        if(dwRet != ERROR_SUCCESS){
            // There was an error trying to find/contact an ISTG.
            // The function should have taken care of printing the error.
            __leave;
        }
        Assert(iISTG != NO_SERVER);
        Assert(pConnectionFailures != NULL);
        Assert(pLinkFailures != NULL);

        // This function only prints things if the /d flag is specified.
        ReplIntersiteDbgPrintISTGFailureParams(pDsInfo, iSite,
                                               iISTG,
                                               ulIntersiteFailoverTries,
                                               ulIntersiteFailoverTime,
                                               pConnectionFailures,
                                               pLinkFailures);


        // Get down bridgehead lists ...
        // --------------------------------------------------------------------
        dwRet = ReplIntersiteCheckBridgeheads(pDsInfo, iSite,
                                              iISTG,
                                              ulIntersiteFailoverTries,
                                              ulIntersiteFailoverTime,
                                              pConnectionFailures,
                                              pLinkFailures,
                                              &piBridgeheads,
                                              &piKCCDownServers,
                                              &prgKCCFailingServers,
                                              &piUnreacheableServers);
        if(dwRet != ERROR_SUCCESS){
            // There was an error printing/creating the bridgehead and
            // bridgehead's failing lists.
            __leave;
        }
        Assert(piBridgeheads != NULL);
        Assert(piKCCDownServers != NULL);
        Assert(prgKCCFailingServers != NULL);
        Assert(piUnreacheableServers != NULL);


        // Do site analysis ...
        // --------------------------------------------------------------------
        dwRet = ReplIntersiteSiteAnalysis(pDsInfo, iSite,
                                          iISTG,
                                          ulIntersiteFailoverTries,
                                          ulIntersiteFailoverTime,
                                          pConnectionFailures,
                                          pLinkFailures,
                                          piBridgeheads,
                                          piKCCDownServers,
                                          prgKCCFailingServers,
                                          piUnreacheableServers);
        if(dwRet != ERROR_SUCCESS){
            // There was an error in doing the site analysis.  This is 
            // probably a fatal error, like out of mem.
            Assert(dwRet != -1);
            __leave;
        }


    } __finally {
        if(pConnectionFailures != NULL) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, 
                              pConnectionFailures);
        }
        if(pLinkFailures != NULL) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, 
                              pLinkFailures);
        }
        if(piBridgeheads) { LocalFree(piBridgeheads); }
        if(piKCCDownServers) { LocalFree(piKCCDownServers); }
        if(prgKCCFailingServers) { LocalFree(prgKCCFailingServers); }
        if(piUnreacheableServers) { LocalFree(piUnreacheableServers); }
    } // End clean up memory section.
    
    return(dwRet);
}

DWORD
ReplIntersiteDoThisSiteP(
    IN  PDC_DIAG_DSINFO                     pDsInfo,
    IN  ULONG                               iSite,
    OUT PBOOL                               pbDoSite
    )
/*++

Description:
   
    This takes the DsInfo struct (containing the target NC if there is one),
    and the Site to do.  This function sets pbDoSite to TRUE if the scoping of
    dcdiag (via, SITE, ENTERPRISE, and NC scope) if this is a site that 
    should be examined by the inbound intersite replication engine.  If there
    is an error it returns an win 32 error.
    
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to consider.
    pbDoSite - Whether this site should be done or not.
        
Return Value:

    Returns a win 32 error.  ERROR_SUCCESS if one should use pbDoSite
    
--*/
{
    PULONG                            piRelevantServers = NULL;
    PULONG                            piSites = NULL;
    PCONNECTION_PAIR                  pConnections = NULL;
    LDAP *                            hldHomeServer = NULL;
    ULONG                             iNC;
    DWORD                             dwErr = ERROR_SUCCESS;

    *pbDoSite = TRUE;

    __try{

        if(pDsInfo->cNumSites == 1){
            // Can't do intersite anything with only one site.
            *pbDoSite = FALSE;
            __leave;
        }

        if(!(gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE || 
           gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_SITE)){
            // Why analyze intersite repl. without at least site or enterprise scope.
            *pbDoSite = FALSE;
            __leave;
        }

        if(gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_SITE && iSite != pDsInfo->iHomeSite){
            // Doing only one site, and this one is not it.
            *pbDoSite = FALSE;
            __leave;
        }

        piRelevantServers = IHT_GetServerList(pDsInfo);
        piRelevantServers = IHT_TrimServerListBySite(pDsInfo,
                                                     iSite,
                                                     piRelevantServers);
        if(piRelevantServers == NULL){
            *pbDoSite = FALSE;
            dwErr = IHT_PrintListError(GetLastError());
            Assert(dwErr != ERROR_SUCCESS);
            __leave;
        }
        if(piRelevantServers[0] == NO_SERVER){
            // This means it is a site that has no servers in it.
            *pbDoSite = FALSE;
            __leave;
        }

        if(pDsInfo->pszNC != NULL){
            
            // There is a target NC
            iNC = DcDiagGetNCNum(pDsInfo, pDsInfo->pszNC, NULL);
            Assert(iNC != NO_NC && "I don't think this should ever fire -BrettSh");
            
            piRelevantServers = IHT_TrimServerListByNC(pDsInfo, 
                                                       iNC, TRUE, TRUE, 
                                                       piRelevantServers);
            if(piRelevantServers == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }
            if(piRelevantServers[0] == NO_SERVER){
                // This site contains no servers with the specified NC.
                *pbDoSite = FALSE;
                __leave;
            }

            // Check whether any sites that we are attached to have the target NC.
            if((dwErr = DcDiagGetLdapBinding( &(pDsInfo->pServers[pDsInfo->ulHomeServer]), 
                                              pDsInfo->gpCreds, 
                                              FALSE, 
                                              &hldHomeServer)) != ERROR_SUCCESS){
                PrintMsg(SEV_ALWAYS,
                         DCDIAG_INTERSITE_FAILURE_CONNECTING_TO_HOME_SERVER,
                         pDsInfo->pServers[pDsInfo->ulHomeServer].pszName,
                         Win32ErrToString(dwErr));
                *pbDoSite = FALSE;
                __leave;
            }

            pConnections = IHT_GetConnectionList(pDsInfo, hldHomeServer, iSite);
            if(pConnections == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }

            // Trims connections to only leave the ones that have this NC on both
            //   sides of the connection, and where the src is in another site.
            pConnections = IHT_TrimConnectionsForInterSiteAndTargetNC(pDsInfo, 
                                                                      iSite,
                                                                      pConnections);
            if(pConnections == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }

            // Get list of sites for the src's of the connection objects.
            piSites = IHT_GetSrcSitesListFromConnections(pDsInfo, pConnections);
            if(piSites == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }
            if(piSites[0] == NO_SITE){
                // There are no sites outside this one that have this NC
                // This is a rare case that there are no GCs outside this site.
                *pbDoSite = FALSE;
                __leave;
            }

        } else {
            // Every site should be valid in this case, because at least Config/Schema
            //   are replicated to every DC.

        }

    } __finally {
        if(piRelevantServers) { LocalFree(piRelevantServers); }
        if(piSites) { LocalFree(piSites); }
        if(pConnections) { IHT_FreeConnectionList(pConnections); }
    }
    
    // Looks like a good site to do.  "Houston, We are go fly for launch!"
    return(dwErr);
}

DWORD
ReplIntersiteHealthTestMain(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iTargetSite,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Description:

    This is the basic stub function ... it bails on certain preliminary
    conditions, like only one site, scope not set to /a or /e, etc ... 
    otherwise the function calls ReplIntersiteDoOneSite().

Parameters:

    pDsInfo ... the pDsInfo structure, basically the mini-enterprise variable.
    iCurrTargetServer ... the targeted serve ... which means nothing to this 
             test, because this is an enterprise test.
    gpCreds ... the users credentials

Return Value:

    returns a Win 32 error.

  --*/
{
    DWORD                              dwRet;
    DWORD                              dwWorst = ERROR_SUCCESS;
    ULONG                              iSite;
    BOOL                               bDoSite;

    for(iSite = 0; iSite < pDsInfo->cNumSites; iSite++){
        if((dwRet = ReplIntersiteDoThisSiteP(pDsInfo, iSite, &bDoSite)) 
           != ERROR_SUCCESS){
            // This means trouble talking to home server or out of memory, 
            //   either way a completely fatal condition.
            return(dwRet);
        }

        if(!bDoSite){ //!bDoSite){
            // This site doesn't quailify,
            PrintMsg(SEV_VERBOSE,
                     DCDIAG_INTERSITE_SKIP_SITE,
                     pDsInfo->pSites[iSite].pszName);
            continue;
        }

        // Do a site.
        PrintMsg(SEV_NORMAL, 
                 DCDIAG_INTERSITE_BEGIN_DO_ONE_SITE,
                 pDsInfo->pSites[iSite].pszName);
        PrintIndentAdj(1);
        dwRet = ReplIntersiteDoOneSite(pDsInfo, iSite);
        if(dwWorst == ERROR_SUCCESS){
            dwWorst = dwRet;
        }
        PrintIndentAdj(-1);
    }

    return(dwWorst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\objects.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    objects.c

Abstract:

This module contains the test and the support routines to check that
critical objects are fully replicated to all holders of the domain.
There are two aspects to this: enumerating what the critical objects are,
and finding all the replicas of that object and verifying that they are
at the latest version.    

Author:

    Will Lees (wlees) 31-Aug-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>
#include <ntdsa.h>    // options
#include <mdglobal.h>
#include <dsutil.h>
#include <drs.h>  // need DS_REPL_INFO_REPSTO

#include "dcdiag.h"
#include "repl.h"
#include "ldaputil.h"

// Data structure to represent one candidate server holding an object in a domain

typedef struct _SERVER_OBJECT {
    PDC_DIAG_SERVERINFO pServer;
    HANDLE *hDS;
    BOOL fMaster;
    DS_REPL_OBJ_META_DATA * pObjMetaData;
} SERVER_OBJECT, *PSERVER_OBJECT;

// Data structure to represent one attribute on one object on one
// candidate server

typedef struct _SERVER_ATTRIBUTE {
    PSERVER_OBJECT pServerObject;
    DS_REPL_ATTR_META_DATA *pAttrMetaData;
} SERVER_ATTRIBUTE, *PSERVER_ATTRIBUTE;

/* External */

/* Static */

/* Forward */
/* End Forward */


void
PrintAttrMetaData(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN LPWSTR pszDescription,
    IN LPWSTR pszServerName,
    IN BOOL fMaster,
    IN DS_REPL_ATTR_META_DATA *pAttrMetaData
    )

/*++

Routine Description:

Print the contents of server attribute record.  This is user-visable
attribute print routine

Arguments:

    pDsInfo - 
    pszDescription - Call's string description of this attribute
    pszServerName - Server where this attribute came from
    pAttrMetaData - Metadata to be printed

Return Value:

    None

--*/

{
    CHAR szBuf[SZDSTIME_LEN];
    WCHAR wszTime[SZDSTIME_LEN];
    DSTIME dstime;
    DWORD i;
    LPWSTR pszLastOriginatingDsa, pszUuid = NULL;

    PrintMessage( SEV_ALWAYS, L"%ws attribute %ws on %ws (%ws)\n",
                  pszDescription,
                  pAttrMetaData->pszAttributeName,
                  pszServerName,
                  fMaster ? L"writeable" : L"readonly" );

    FileTimeToDSTime(pAttrMetaData->ftimeLastOriginatingChange,
                     &dstime);
    DSTimeToDisplayString(dstime, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                         wszTime, SZDSTIME_LEN);

    if (UuidToString( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                      &pszUuid) != RPC_S_OK) return;

    // Reverse translate invocation id to server name
    pszLastOriginatingDsa = pszUuid;
    for( i=0; i < pDsInfo->ulNumServers; i++ ) {
        if (memcmp( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                    &(pDsInfo->pServers[i].uuidInvocationId),
                    sizeof( UUID ) ) == 0 ) {
            pszLastOriginatingDsa = pDsInfo->pServers[i].pszName;
            break;
        }
    }

    PrintIndentAdj(1);
    PrintMessage( SEV_ALWAYS, L"usnLocalChange = %I64d\n",
                  pAttrMetaData->usnLocalChange );
    PrintMessage( SEV_ALWAYS, L"LastOriginatingDsa = %ws\n",
                  pszLastOriginatingDsa );
    PrintMessage( SEV_ALWAYS, L"usnOriginatingChange = %I64d\n",
                  pAttrMetaData->usnOriginatingChange );
    PrintMessage( SEV_ALWAYS, L"timeLastOriginatingChange = %ws\n",
                  wszTime );
    PrintMessage( SEV_ALWAYS, L"VersionLastOriginatingChange = %d\n",
                  pAttrMetaData->dwVersion );
    PrintIndentAdj(-1);

// cleanup

    if (pszUuid) {
        RpcStringFree( &pszUuid );
    }
} /* PrintAttrMetaData */


void
printServerAttributeSingleLine(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerAttributes,
    IN PSERVER_ATTRIBUTE pServerAttr,
    IN BOOL fPrintHeader
    )

/*++

Routine Description:

Helper routine that dumps a single line of the attribute
instance array.

Note, uses fwprintf

Arguments:

    pDsInfo - 
    pServerAttr - 
    fPrintHeader - 

Return Value:

    None

--*/

{
    CHAR szBuf[SZDSTIME_LEN];
    WCHAR wszTime[SZDSTIME_LEN];
    DSTIME dstime;
    DWORD i;
    LPWSTR pszLastOriginatingDsa, pszUuid = NULL;
    DS_REPL_ATTR_META_DATA *pAttrMetaData =
        pServerAttr->pAttrMetaData;
    
    if (fPrintHeader) {
        fwprintf( gMainInfo.streamOut,
                  L"\nDumping %d Server Attributes.\n", cServerAttributes );

        fwprintf( gMainInfo.streamOut,
                  L"\n%15s%3s%10s%37s%10s%20s%5s %s\n",
                  L"Local DSA",
                  L"W",
                  L"Loc.USN",
                  L"Originating DSA",
                  L"Org.USN",
                  L"Org.Time/Date",
                  L"Ver",
                  L"Attribute"
            );

        fwprintf( gMainInfo.streamOut,
            L"%15s%3s%10s%37s%10s%20s%5s %s\n",
                  L"===",
                  L"=========",
                  L"=======",
                  L"===============",
                  L"=======",
                  L"=============",
                  L"===",
                  L"========="
            );
    }

    FileTimeToDSTime(pAttrMetaData->ftimeLastOriginatingChange,
                     &dstime);
    DSTimeToDisplayString(dstime, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                         wszTime, SZDSTIME_LEN);

    if (UuidToString( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                      &pszUuid) != RPC_S_OK) return;

    // Reverse translate invocation id to server name
    pszLastOriginatingDsa = pszUuid;
    for( i=0; i < pDsInfo->ulNumServers; i++ ) {
        if (memcmp( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                    &(pDsInfo->pServers[i].uuidInvocationId),
                    sizeof( UUID ) ) == 0 ) {
            pszLastOriginatingDsa = pDsInfo->pServers[i].pszName;
            break;
        }
    }

    fwprintf( gMainInfo.streamOut,
              L"%15ls%3d%10I64d%37ls%10I64d%20s%5d %ls\n",
              pServerAttr->pServerObject->pServer->pszName,
              pServerAttr->pServerObject->fMaster,
              pAttrMetaData->usnLocalChange,
              pszLastOriginatingDsa,
              pAttrMetaData->usnOriginatingChange,
              wszTime,
              pAttrMetaData->dwVersion,
              pAttrMetaData->pszAttributeName
        );

// cleanup

    if (pszUuid) {
        RpcStringFree( &pszUuid );
    }
} /* printServerAttributeSingleLine */


void
printServerAttributes(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerAttributes,
    IN PSERVER_ATTRIBUTE pServerAttributes
    )

/*++

Routine Description:

Dump routine that prints the array of attribute instances

Arguments:

    pDsInfo - 
    cServerAttributes - 
    pServerAttributes - 

Return Value:

    None

--*/

{
    DWORD i;

    for( i = 0; i < cServerAttributes; i++ ) {
        PSERVER_ATTRIBUTE pServerAttr = &(pServerAttributes[i]);
        printServerAttributeSingleLine(
            pDsInfo,
            cServerAttributes,
            pServerAttr,
            (i == 0) // First line or not?
            );
    };
} /* printServerAttributes */


int __cdecl
compareServerAttrVersion(
    const void *pArg1,
    const void *pArg2
    )

/*++

Routine Description:

Helper comparison function.

1. sort by version, DESCENDING
2. sort by change time, DESCENDING

Arguments:

    pArg1 - 
    pArg2 - 

Return Value:

    int __cdecl - 

--*/

{
    PSERVER_ATTRIBUTE pServerAttribute1 = (PSERVER_ATTRIBUTE) pArg1;
    PSERVER_ATTRIBUTE pServerAttribute2 = (PSERVER_ATTRIBUTE) pArg2;
    int result;
    LONGLONG llTime1, llTime2;

    // Attribute names are equal, sort by version, DESCENDING

    if (pServerAttribute1->pAttrMetaData->dwVersion >
        pServerAttribute2->pAttrMetaData->dwVersion ) {
        return -1;
    } else if (pServerAttribute1->pAttrMetaData->dwVersion <
        pServerAttribute2->pAttrMetaData->dwVersion ) {
        return 1;
    }

    // Version numbers are equal, sort by change time, DESCENDING

    llTime1 = *((UNALIGNED64 LONGLONG *) &(pServerAttribute1->pAttrMetaData->ftimeLastOriginatingChange));
    llTime2 = *((UNALIGNED64 LONGLONG *) &(pServerAttribute2->pAttrMetaData->ftimeLastOriginatingChange));
    if (llTime1 > llTime2) {
        return -1;
    } else if (llTime1 < llTime2) {
        return 1;
    }

    // The two records are equal as far as we are concerned

    return 0;
} /* sortByVersion */


int __cdecl
compareServerAttrNameWriteVersion(
    const void *pArg1,
    const void *pArg2
    )

/*++

Routine Description:

qsort comparison function
1. Sort by attribute name, ASCENDING
2. Sort by writeability, DESCENDING
3. Attribute names are equal, sort by version, DESCENDING
4. Version numbers are equal, sort by change time, DESCENDING

Arguments:

    pArg1 - 
    pArg2 - 

Return Value:

    int __cdecl - 

--*/

{
    PSERVER_ATTRIBUTE pServerAttribute1 = (PSERVER_ATTRIBUTE) pArg1;
    PSERVER_ATTRIBUTE pServerAttribute2 = (PSERVER_ATTRIBUTE) pArg2;
    int result;
    LONGLONG llTime1, llTime2;

    // Sort by attribute name, ASCENDING

    result = _wcsicmp( pServerAttribute1->pAttrMetaData->pszAttributeName,
                       pServerAttribute2->pAttrMetaData->pszAttributeName );
    if (result != 0) {
        return result;
    }

    // Sort by writability, DESCENDING
    if (pServerAttribute1->pServerObject->fMaster >
        pServerAttribute2->pServerObject->fMaster ) {
        return -1;
    } else if (pServerAttribute1->pServerObject->fMaster <
               pServerAttribute2->pServerObject->fMaster ) {
        return 1;
    }

    return
        compareServerAttrVersion( pServerAttribute1, pServerAttribute2 );
} /* sortByNameVersion */


BOOL
walkSortedServerAttributes(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerAttributes,
    IN PSERVER_ATTRIBUTE pServerAttributes
    )

/*++

Routine Description:

All the attributes from all the replicas have been correllated in one array.
Walk through the attributes and report any that are not current.

We know that the array is sorted first by attribute name, then by most recent change.
So the first occurance of an attribute name in the list must be the most
recent, so call that the "authoritative" instance of the attribute.  Any that
deviate from this are called "out of date".

CODE.IMPROVEMENT: detect if an attribute is missing on some of the servers. Note
that GC's only hold a subset of the attributes.

Arguments:

    cServerAttributes - 
    pServerAttributes - 

Return Value:

    BOOL - Difference found

--*/

{
    DWORD status = ERROR_SUCCESS, i;
    PSERVER_ATTRIBUTE pAuthAttr;
    BOOL fAuthAttrPrinted = FALSE;
    BOOL fDifferenceFound = FALSE;

    // Start out with the 0th element being authoritative, and go through
    // the rest of the array starting at element 1.  If the name changes,
    // declare a new authoritative element.

    pAuthAttr = &(pServerAttributes[0]);
    for( i = 1; i < cServerAttributes; i++ ) {
        PSERVER_ATTRIBUTE pServerAttr = &(pServerAttributes[i]);

        // See if it is time to start a new attribute name
        if (_wcsicmp( pAuthAttr->pAttrMetaData->pszAttributeName,
                      pServerAttr->pAttrMetaData->pszAttributeName ) != 0) {
            pAuthAttr = &(pServerAttributes[i]);
            fAuthAttrPrinted = FALSE;
            continue;
        }

        // See if current attribute change is the same as the authoritative
        if (compareServerAttrVersion( pAuthAttr, pServerAttr ) == 0) {
            continue;
        }

        // WORKAROUND problem that whenCreated was added to partial attribute set
        // If readonly copy of whenCreated is more recent, skip
        if ( (pAuthAttr->pServerObject->fMaster) &&
             (!(pServerAttr->pServerObject->fMaster)) &&
             (_wcsicmp( pAuthAttr->pAttrMetaData->pszAttributeName,
                        L"whenCreated" ) == 0) &&
             (compareServerAttrVersion( pAuthAttr, pServerAttr ) > 0) ) {
            continue;
        }
        // operatingSystemServicePack was another one that changed from being set
        // to not being set around 2/99
        if (_wcsicmp( pAuthAttr->pAttrMetaData->pszAttributeName,
                      L"operatingSystemServicePack" ) == 0) {
            continue;
        }
        // WORKAROUND

        // Current attribute is out of date

        // Print the authoritative attribute out once
        if (!fAuthAttrPrinted) {
            PrintAttrMetaData( pDsInfo,
                               L"Authoritative",
                               pAuthAttr->pServerObject->pServer->pszName,
                               pAuthAttr->pServerObject->fMaster,
                               pAuthAttr->pAttrMetaData);
            fAuthAttrPrinted = TRUE;
        }

        // Print the out of date attribute
        PrintAttrMetaData( pDsInfo,
                           L"Out-of-date",
                           pServerAttr->pServerObject->pServer->pszName,
                           pServerAttr->pServerObject->fMaster,
                           pServerAttr->pAttrMetaData);
        fDifferenceFound = TRUE;
    }

    return fDifferenceFound;
} /* walkSortedServerAttributes */


BOOL
mergeAttributesOnServers(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerObjects,
    IN PSERVER_OBJECT pServerObjects
    )

/*++

Routine Description:

At this point, we have an array of records, one for each server.  In the record
is a pointer to metadata for the object.

What we want to do is check that across all servers, all hold the same metadata
for the same attribute.

What we do here is allocate another array, an array of attribute instances.
Each occurance of an attribute metadata on a particular server gets its own
record.  These records are then sorted, first by attribute, then by most
recent change.  Then we can easily go through them.

Arguments:

    pDsInfo - Global information
    cServerObjects - Number of replicas
    pServerObjects - Array of server object context records

Return Value:

    BOOL - 

--*/

{
    DWORD status = ERROR_SUCCESS, cServerAttributes = 0;
    DWORD i, j, dwCurrentAttribute;
    PSERVER_ATTRIBUTE pServerAttributes = NULL;
    BOOL fDifferenceFound = FALSE;

    // Make two passes: count the attribute instances, then allocate and init

    // Count the number of server attributes we have

    for( i = 0; i < cServerObjects; i++ ) {
        PSERVER_OBJECT pServerObject = &(pServerObjects[i]);
        // If no metadata, do not include this server
        if (pServerObject->pObjMetaData == NULL) {
            continue;
        }
        for( j = 0; j < pServerObject->pObjMetaData->cNumEntries; j++ ) {
            // Skip non-replicated attributes
            if (_wcsicmp( pServerObject->pObjMetaData->rgMetaData[j].pszAttributeName,
                          L"cn" ) == 0) {
                continue;
            }
            cServerAttributes++;
        }
    }

    // Allocate array
    // Zero all fields to start out
    pServerAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                    cServerAttributes *
                                    sizeof( SERVER_ATTRIBUTE ) );
    if (pServerAttributes == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        return TRUE;  // Indicate an error occurred
    }

    // Initialize array

    dwCurrentAttribute = 0;
    for( i = 0; i < cServerObjects; i++ ) {
        PSERVER_OBJECT pServerObject = &(pServerObjects[i]);

        // If no metadata, do not include this server
        if (pServerObject->pObjMetaData == NULL) {
            continue;
        }
        for( j = 0; j < pServerObject->pObjMetaData->cNumEntries; j++ ) {
            // Skip non-replicated attributes
            if (_wcsicmp( pServerObject->pObjMetaData->rgMetaData[j].pszAttributeName,
                          L"cn" ) == 0) {
                continue;
            }
            pServerAttributes[dwCurrentAttribute].pServerObject = pServerObject;
            pServerAttributes[dwCurrentAttribute].pAttrMetaData =
                &(pServerObject->pObjMetaData->rgMetaData[j]);
            dwCurrentAttribute++;
        }
    }

    // Sort the array

    qsort( pServerAttributes,
           cServerAttributes,
           sizeof( SERVER_ATTRIBUTE ),
           compareServerAttrNameWriteVersion );

#ifdef EXTENDED_DEBUGGING
    // Dump server attributes table if desired
    IF_DEBUG(printServerAttributes(pDsInfo, cServerAttributes, pServerAttributes););
#endif

    // Walk through the sorted attributes

    fDifferenceFound =
        walkSortedServerAttributes( pDsInfo,
                                    cServerAttributes,
                                    pServerAttributes );
    if (!fDifferenceFound) {
        PrintMessage( SEV_VERBOSE, L"Object is up-to-date on all servers.\n" );
    }

// cleanup
    if (pServerAttributes) {
        LocalFree( pServerAttributes );
    }
    return fDifferenceFound;
} /* mergeAttributesOnServers */


DWORD
checkObjectOnServers(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN LPWSTR pszDomainDn,
    IN LPWSTR pszObjectDn,
    IN DWORD cServerObjects,
    IN PSERVER_OBJECT pServerObjects
    )

/*++

Routine Description:

Check whether the given object in the domain is at the latest version on
all of its replicas.

Arguments:

    pszDomainDn - DN of domain to be searched
    pszObjectDn - DN of object in domain to be checked
    cServerObjects - Number of replicas to be searched
    pServerObjects - Array of server object context records

Return Value:

    DWORD - Error if object not fully replicated

--*/

{
    BOOL fDifferenceFound = FALSE;
    DWORD status, i;

    PrintMessage( SEV_VERBOSE, L"Checking for %ws in domain %ws on %d servers\n",
                  pszObjectDn, pszDomainDn, cServerObjects );

    // Fill the server object array with metadata 
    // One metadata query for each server

    for( i = 0; i < cServerObjects; i++ ) {
        PSERVER_OBJECT pServerObject = &(pServerObjects[i]);

        status = DsReplicaGetInfoW( pServerObject->hDS,
                                    DS_REPL_INFO_METADATA_FOR_OBJ,
                                    pszObjectDn,
                                    NULL,
                                    &(pServerObject->pObjMetaData));
        if (ERROR_SUCCESS != status) {
            PrintMessage( SEV_ALWAYS,
                          L"Failed to read object metadata on %ws, error %ws\n",
                          pServerObject->pServer->pszName,
                          Win32ErrToString(status) );
            PrintRpcExtendedInfo(SEV_VERBOSE, status);
            // keep going, leave pObjMetaData as null
        }
    }

    // Compare all the attributes for differences

    PrintIndentAdj(1);

    fDifferenceFound =
        mergeAttributesOnServers( pDsInfo,
                                  cServerObjects,
                                  pServerObjects );

    PrintIndentAdj(-1);

// cleanup

    for( i = 0; i < cServerObjects; i++ ) {
        if (pServerObjects[i].pObjMetaData) {
            DsReplicaFreeInfo( DS_REPL_INFO_METADATA_FOR_OBJ,
                               pServerObjects[i].pObjMetaData );
            pServerObjects[i].pObjMetaData = NULL;
        }
    }

    return fDifferenceFound ? ERROR_DS_GENERIC_ERROR : ERROR_SUCCESS;
} /* checkObjectOnServers */


DWORD
checkObjectsOnDomain(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN SEC_WINNT_AUTH_IDENTITY_W * pCreds,
    LPWSTR pszDomainDn,
    LPWSTR pszObjectDn
    )

/*++

Routine Description:

This routine generates a data structure that is an array of server-object records.
There is one such record for each server that holds a copy of the domain
we are interested in.  We enumerate the replicas by going through the known
server list looking for writable or readable copies.

This test requires N x N queries.  There are as many computer accounts as there are
DC's.  Each computer account is replicated to all the holders of that domain.
I had a choice of defining what the target server means for this test.  Is it the
account to be checked for, or each server on which the check occurs.  I have chosen to
use the test target server for the account to be checked for.  The systems that will be
checked are hard coded to all the domain holders.

Arguments:

    pDsInfo - 
    pTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD i, status, cServerObjects = 0;
    BOOL fHoldsDomainWriteable = FALSE, fHoldsDomainReadOnly = FALSE;
    PSERVER_OBJECT pServerObjects = NULL;

    // Allocate a maximal size array
    // Note that fields are all zero'd to start with
    pServerObjects = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                 pDsInfo->ulNumServers * sizeof( SERVER_OBJECT ) );
    if (pServerObjects == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Walk the known server list, and find replicas

    for( i = 0; i < pDsInfo->ulNumTargets; i++ ) {
        PDC_DIAG_SERVERINFO pCandidateServer =
            &(pDsInfo->pServers[pDsInfo->pulTargets[i]]);
        HANDLE hDS = NULL;

        // Check for writable copy
        fHoldsDomainWriteable =
            DcDiagHasNC( pszDomainDn, pCandidateServer, TRUE, FALSE );
        if (!fHoldsDomainWriteable) {
            // Check for readonly copy
            fHoldsDomainReadOnly =
                DcDiagHasNC( pszDomainDn, pCandidateServer, FALSE, TRUE );
            if (!fHoldsDomainReadOnly) {
                continue;
            }
        }

        // If we already know candidate is down, don't bother
        if ( (!pCandidateServer->bDnsIpResponding) ||
             (!pCandidateServer->bLdapResponding) ||
             (!pCandidateServer->bDsResponding) ) {
            continue;
        }
        // If candidate not reachable via ldap, don't bother
        status = DcDiagGetDsBinding(pCandidateServer,
                                    pCreds,
                                    &hDS);
    	if (ERROR_SUCCESS != status) {
            continue;
    	}

        pServerObjects[cServerObjects].pServer = pCandidateServer;
        pServerObjects[cServerObjects].hDS = hDS;
        pServerObjects[cServerObjects].fMaster = fHoldsDomainWriteable;
        cServerObjects++;
    }

    // Check given object

    status = checkObjectOnServers( pDsInfo,
                                   pszDomainDn,
                                   pszObjectDn,
                                   cServerObjects,
                                   pServerObjects );

// Cleanup

    if (pServerObjects) {
        LocalFree( pServerObjects );
    }

    return status;
} /* checkObjectsOnDomain */


DWORD
ReplCheckObjectsMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This test verifies that the most recent copies of important
objects and attributes have replicated through the domain.

The objects that are checked are:
1. The machine account object of the target server. The search scope is all
the copies of the machine's primary domain.
2. The NTDS-DSA object of the target server. The search scope is all the
replicas of the CN=Configuration naming context.

Arguments:

    pDsInfo - 
    ulCurrTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD status = ERROR_SUCCESS, worst = ERROR_SUCCESS;
    DWORD i, j;
    PDC_DIAG_SERVERINFO pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);
    LPWSTR pszDomainDn = NULL;
    LPWSTR pszObjectDn = NULL;

    // See if user-specified object present
    for( i = 0; pDsInfo->ppszCommandLine[i] != NULL; i++ ) {
        if (_wcsnicmp( pDsInfo->ppszCommandLine[i],
                       L"/objectdn:", wcslen( L"/objectdn:" ) ) == 0 )
        {
            pszObjectDn = &pDsInfo->ppszCommandLine[i][wcslen(L"/objectdn:")];
            break;
        }
    }

    // Find the primary domain of the target server
    for( j = 0; pTargetServer->ppszMasterNCs[j] != NULL; j++ ) {
        if ( IsDomainNC( pDsInfo, pTargetServer->ppszMasterNCs[j]) ) {
            pszDomainDn = pTargetServer->ppszMasterNCs[j];
            break;
        }
    }
    Assert( pszDomainDn );

    PrintMessage( SEV_VERBOSE, L"%ws is in domain %ws\n",
                  pTargetServer->pszName,
                  pszDomainDn );

    //
    // Check replication for the machine account of the target server,
    // which is in the domain of the target server
    //

    status = checkObjectsOnDomain( pDsInfo,
                                   pCreds,
                                   pszDomainDn,
                                   pTargetServer->pszComputerAccountDn );
    if (status != ERROR_SUCCESS) {
        worst = status;
    }

    //
    // Check replication of the server object, which is in
    // the configuration naming context
    //

    status = checkObjectsOnDomain( pDsInfo,
                                   pCreds,
                                   pDsInfo->pszConfigNc,
                                   pTargetServer->pszDn );
    if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
        worst = status;
    }

    //
    // Check user supplied object
    //

    if ( (pszObjectDn) && (pDsInfo->pszNC) ) {
        status = checkObjectsOnDomain( pDsInfo,
                                       pCreds,
                                       pDsInfo->pszNC,
                                       pszObjectDn );
        if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
            worst = status;
        }
    }

    return worst;
} /* CheckObjectsMain */

/* end objects.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\initial.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    servers.c

ABSTRACT:

    Contains tests related to the replication topology.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

        Did alot, added a DNS/server failure analysis.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>

// added to make IsIcmpRespose() or Ping() function
#include <winsock2.h>
#include <lmcons.h>
#include <ipexport.h>  // has type IPaddr for icmpapi.h
#include <icmpapi.h>   // for IcmpCreateFile, IcmpSendEcho, IcmpCloseHandle

#include <dnsresl.h>
#include <svcguid.h>

#include "dcdiag.h"
#include "repl.h"

// Some pound defines imported from xportst.h
#define DEFAULT_SEND_SIZE      32
#define MAX_ICMP_BUF_SIZE      ( sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE )
#define DEFAULT_TIMEOUT        1000L
#define PING_RETRY_CNT         4


// Some constants for DNSRegistration/Up Check
// There is a better place to get this var ... but it is a pain
const LPWSTR                    pszTestNameUpCheck = L"DNS Registration & Server Up Check";

//-------------------------------------------------------------------------//
//######  I s I c m p R e s p o n s e ()  #################################//
// NOTE: This is actually IsIcmpRespose from 
//   /nt/private/net/sockets/tcpcmd/nettest/xportst.c modified instead to take
//   a ULONG as an IP address, compared to before where it took an IP string.
//-------------------------------------------------------------------------//
DWORD
Ping( 
    ULONG ipAddr
    ) 
//++
//
//  Routine Description:
//
//      Sends ICMP echo request frames to the IP address specified.
//    
//  Arguments:
//
//      ipAddrStr - address to ping
//
//  Return Value:
//
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
//--
{

    CHAR   *SendBuffer, *RcvBuffer;
    INT     i, nReplyCnt;
    INT     nReplySum = 0;
    INT     iTempRet;
    HANDLE  hIcmp;
    PICMP_ECHO_REPLY reply;

    //
    //  contact ICMP driver
    //
    hIcmp = IcmpCreateFile();
    if ( hIcmp == INVALID_HANDLE_VALUE ) {
        return ERROR_NOT_ENOUGH_MEMORY; // Should be corrected
    }

    //
    //  prepare buffers
    //
    SendBuffer = LocalAlloc( LMEM_FIXED, DEFAULT_SEND_SIZE );
    if ( SendBuffer == NULL ) {
	IcmpCloseHandle( hIcmp );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( SendBuffer, DEFAULT_SEND_SIZE );

    RcvBuffer = LocalAlloc( LMEM_FIXED, MAX_ICMP_BUF_SIZE );
    if ( RcvBuffer == NULL ) {
        LocalFree( SendBuffer );
	IcmpCloseHandle( hIcmp );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( RcvBuffer, DEFAULT_SEND_SIZE );

    //
    //  send ICMP echo request
    //
    for ( i = 0; i < PING_RETRY_CNT; i++ ) {
        nReplyCnt = IcmpSendEcho( hIcmp,
                                  ipAddr,
                                  SendBuffer,
                                  (unsigned short )DEFAULT_SEND_SIZE,
                                  NULL,
                                  RcvBuffer,
                                  MAX_ICMP_BUF_SIZE,
                                  DEFAULT_TIMEOUT
                                );

        //
        //  test for destination unreachables
        //
        if ( nReplyCnt != 0 ) {
            reply = (PICMP_ECHO_REPLY )RcvBuffer;
            if ( reply->Status == IP_SUCCESS ) {
                nReplySum += nReplyCnt;
            }
        }

    } /* for loop */

    //
    //  cleanup
    //
    LocalFree( SendBuffer );
    LocalFree( RcvBuffer );
    IcmpCloseHandle( hIcmp );
    if ( nReplySum == 0 ) { 
        return GetLastError(); 
    } else { 
        return ERROR_SUCCESS;
    }

} /* END OF IsIcmpRespose() */

DWORD
FaCheckIdentityHelperF1(
    IN   PDC_DIAG_SERVERINFO          pServer,
    IN   LPWSTR                       pszTargetNameToCheck
)
/*++

Description:

    This function will look up the official DNS name and aliases for pszHostNameToLookup and compare them to
    pszTargetNameToCheck.

Arguments:

    pServer (IN) - Host Name to resolve into official names, use ->pszGuidDNSName or ->pszName.

    pszTargetNameToCheck (IN) - Name to be checked.


Return value:

    dwRet - is undetermined at this time.

Notes:

    This function was created instead of using gethostbyname(), because gethostbyname does not support
    non-ANSI names, as part of a recent (as of 5.17.1999) RFC -- i.e., that gethostbyname() supports 
    only ANSI names, and we need to be able to resolve Unicode names.

--*/
{
    LPWSTR                             pszOfficialDnsName = NULL;
    VOID *                             pPD = NULL;
    DWORD                              dwRet;
    LPWSTR                             pszHostNameToLookup = NULL;

    if(pServer->pszGuidDNSName != NULL){
        pszHostNameToLookup = pServer->pszGuidDNSName;
    } else {
        pszHostNameToLookup = pServer->pszName;
    }

    __try {
        dwRet = GetDnsHostNameW(&pPD, pszHostNameToLookup, &pszOfficialDnsName);
        if(dwRet == NO_ERROR){
            if(CompareString(LOCALE_INVARIANT,
                             NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                             pszOfficialDnsName,
                             -1,
                             pszTargetNameToCheck,
                             -1
                             ) == CSTR_EQUAL){
                dwRet = NO_ERROR;
                __leave;
            } // else they don't match try the next alias.
        } else {
            // An unknown error from winsock.
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"***Warning: could not confirm the identity of this server in\n");
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"the directory versus the names returned by DNS servers.\n");
            PrintMessage(SEV_NORMAL, L"There was an error in Windows Sockets during hostname resolution.\n");
            PrintMessage(SEV_NORMAL, L"Winsock retured the following error (%D):\n", dwRet);
            PrintMessage(SEV_NORMAL, L"%s", Win32ErrToString(dwRet));
            __leave;
        }
        
        while((dwRet = GetDnsAliasNamesW(&pPD, &pszOfficialDnsName)) == NO_ERROR){
            if(_wcsicmp(pszOfficialDnsName, pszTargetNameToCheck) == 0){
                dwRet = NO_ERROR;
                __leave;
            } // else they don't match try the next alias.
        }

        if(dwRet == WSA_E_NO_MORE){
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"*** Warning: could not confirm the identity of this server in\n");
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"the directory versus the names returned by DNS servers.\n");
            PrintMessage(SEV_NORMAL, L"If there are problems accessing this directory server then\n");
            PrintMessage(SEV_NORMAL, L"you may need to check that this server is correctly registered\n");
            PrintMessage(SEV_NORMAL, L"with DNS\n");
            PrintIndentAdj(-2);
            dwRet = NO_ERROR;
            __leave;
        } else if (dwRet != NO_ERROR){
            // An unknonwn error from winsock.
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"***Warning: could not confirm the identity of this server in\n");
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"the directory versus the names returned by DNS servers.\n");
            PrintMessage(SEV_NORMAL, L"There was an error in Windows Sockets during hostname resolution.\n");
            PrintMessage(SEV_NORMAL, L"Winsock retured the following error (%D):\n", dwRet);
            PrintMessage(SEV_NORMAL, L"%s", Win32ErrToString(dwRet));
            __leave;
        }
    } __finally {
        GetDnsFreeW(&pPD);
    }

    return(dwRet);
} // End of FaCheckIdentityHelperF1()

INT
FaCheckIdentity(
               PDC_DIAG_SERVERINFO              pServer,
               LDAP *                           hld,
               ULONG                            ulIPofDNSName,
               SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
               )

/*++

Routine Description

    This function uses an open and bound ldap handle.  This function checks the various Domain Names of a machine against the official.

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server we are trying to identify.
    hld - IMPORTANT this is assumed to be an open and bound ldap connection that can just be used, and 
        not unbound, because the caller will do that.
    ulIPofDNSName - Assumed to be the IP address of the machine.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
#define FA_PRINT_LDAP_ERROR(e)      if (e == ERROR_NOT_ENOUGH_MEMORY) { \
                                        PrintMessage(SEV_ALWAYS, L"Fatal Error: Not enough memory to complete operation\n"); \
                                    } else if (e == ERROR_SUCCESS) { \
                                        PrintMessage(SEV_ALWAYS, L"LDAP couldn't retrieve the root object from the server %s.\n",  \
                                            pServer->pszName); \
                                    } else { \
                                        PrintMessage(SEV_ALWAYS, L"LDAP couldn't retrieve the root object from the server %s with\n", \
                                            pServer->pszName); \
                                        PrintMessage(SEV_ALWAYS, L"this error %s\n", Win32ErrToString(e)); \
                                    }
    ULONG                       ulRet;
    INT                         iTemp, iTempSize;
    INT                         iTempRet = 1;
    LPWSTR                      ppszServerAttr [3];
    LDAPMessage *               pldmMachineCheck = NULL;
    LDAPMessage *               pldmMCEntry = NULL;
    LPWSTR *                    ppszMachineName = NULL;
    LPWSTR *                    ppszDsServiceName = NULL;
    LPWSTR                      pszTempDNSName = NULL;
    UUID                        uuidTemp;

    ppszServerAttr[0] = L"dnsHostName";
    if (pServer->pszGuidDNSName) {
        ppszServerAttr[1] = L"dsServiceName";
        ppszServerAttr[2] = NULL;
    } else {
        ppszServerAttr[1] = NULL;
    }

    // Time to do some ldapping!
    ulRet = LdapMapErrorToWin32( ldap_search_sW(hld,
                                                NULL, // Want the root object
                                                LDAP_SCOPE_BASE,
                                                L"(objectClass=*)",
                                                ppszServerAttr,
                                                0,
                                                &pldmMachineCheck) );

    if (ulRet != ERROR_SUCCESS) {
        if (ulRet == ERROR_NOT_ENOUGH_MEMORY) {
            PrintMessage(SEV_ALWAYS, L"Fatal Error: Not enough memory to complete operation\n");
        } else {
            PrintMessage(SEV_ALWAYS, L"LDAP There was an error searching, %s\n",
                         Win32ErrToString(ulRet));
        }
        goto CleanExitPoint;
    }

    pldmMCEntry = ldap_first_entry(hld, pldmMachineCheck);
    ulRet = LdapMapErrorToWin32(LdapGetLastError());
    if (pldmMCEntry == NULL || ulRet != ERROR_SUCCESS) {
        FA_PRINT_LDAP_ERROR(ulRet);
        goto CleanExitPoint;
    }
    ppszMachineName = ldap_get_valuesW(hld, pldmMCEntry, L"dnsHostName");
    ulRet = LdapMapErrorToWin32(LdapGetLastError());
    if (ulRet != ERROR_SUCCESS || ppszMachineName == NULL || ppszMachineName[0] == NULL) {
        FA_PRINT_LDAP_ERROR(ulRet);
        goto CleanExitPoint;
    }

    if (pServer->pszGuidDNSName) {
        // This attribute should always be present.
        ppszDsServiceName = ldap_get_valuesW(hld, pldmMCEntry, L"dsServiceName");
        ulRet = LdapMapErrorToWin32(LdapGetLastError());
        if (ulRet != ERROR_SUCCESS || ppszDsServiceName == NULL || ppszDsServiceName[0] == NULL) {
            FA_PRINT_LDAP_ERROR(ulRet);
            goto CleanExitPoint;
        }

        // Code.Improvement - Might consider adding a extra check to 
        // FaCheckIdentity() or FaCheckIdentityHelperF1().  Basically,
        // add the ability to check that the pServer->pszDn is the
        // same object as pServer->pszCollectedDsServiceName.  If these
        // are different it means an old DNS record for pszGuidDNSName
        // is pointing us to the wrong server.  Currently, we only check
        // this in RepCheckHelpFailure() in repl\servers.c in the case
        // we hit a suspecious error like ERROR_WRONG_TARGET_NAME.
        pServer->pszCollectedDsServiceName = CopyAndAllocWStr(ppszDsServiceName[0]);
    }

    ulRet = FaCheckIdentityHelperF1(pServer, ppszMachineName[0]);

    CleanExitPoint:
    if (pldmMachineCheck != NULL){
        ldap_msgfree(pldmMachineCheck);
        pldmMachineCheck = NULL;
    }
    if (ppszMachineName != NULL){
        ldap_value_freeW(ppszMachineName);
        ppszMachineName = NULL;
    }
    if (ppszDsServiceName) {
        ldap_value_freeW(ppszDsServiceName);
        ppszDsServiceName = NULL;
    }

    return(ulRet);
}

INT
FaLdapCheck(
    PDC_DIAG_SERVERINFO              pServer,
    ULONG                            ulIPofDNSName,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
    )
/*++

Routine Description

    This function will try to make a successful ldap_init() and ldap_bind() and
    then call CheckIdentity().  Otherwise print out a pleasant/helpful error
    message and return a Win32Err

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server
        we are trying to identify.
    ulIPofDNSName - Assumed to be the IP address of the machine.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
    LDAP *                     hld = NULL;
    ULONG                      ulRet;

    ulRet = DcDiagGetLdapBinding(pServer, gpCreds, FALSE, &hld);
    if(ulRet == NO_ERROR){
        if (!pServer->bIsSynchronized) {
            PrintMsg( SEV_ALWAYS, DCDIAG_INITIAL_DS_NOT_SYNCED, pServer->pszName );
        }
        ulRet = FaCheckIdentity(pServer, hld, ulIPofDNSName, gpCreds);
    } else {
        if(ulRet == ERROR_BAD_NET_RESP){
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_BAD_NET_RESP,
                     pServer->pszName);
        } else if (ulRet == ERROR_WRONG_PASSWORD) {
            PrintMsg(SEV_ALWAYS, DCDIAG_NEED_GOOD_CREDS);
        } else {
            // Do nothing.
        }
    }

    return(ulRet);
}

BOOL
FaCheckNormalName(
    PDC_DIAG_SERVERINFO              pServer,
    LPWSTR                           pszGuidIp,
    ULONG                            ulIPofGuidDNSName
    )
/*++

Routine Description:

    This function checks the Normal DNS Name if the GUID based
    DNS Name failed either to resolve in DNS or ping.
    
Arguments:

    pServer - The server to check.
    pszGuidIp - This is the string version of ulIPofGuidDNSName.  It is
        NULL if ulIPofGuidDNSName equals INADDR_NONE.
    ulIPofGuidDNSName - If the GUID DNS Name resolved, then this is a 
        valid IP, if the GUID DNS Name didn't even resolve this is 
        INADDR_NONE.

Returns: TRUE if it prints an advanced and more informative error, FALSE if
    it did not.


    BUGBUG It might just be a better less confusing output synario to 
    have a 3 step print thing.  Ie just the facts.
    1) Is the guid based name registered/resolving?
    2) Are the guid based name and normal name resolving to the same IP.
        Indicated DNS server inconsistencies or DHCP problems.
    3) Is the IP respondings.  Often indicates is the system up.   

--*/
{
    WCHAR                            pszNormalIp[IPADDRSTR_SIZE];
    CHAR                             paszNormalIp[IPADDRSTR_SIZE];
    ULONG                            ulNormalIp = INADDR_NONE;
    ULONG                            dwRet, dwRetPing;

    Assert(pServer->pszGuidDNSName != NULL && "This function is only"
           " relevant if we have both a GUID and normal DNS name.");
    Assert((ulIPofGuidDNSName == INADDR_NONE && pszGuidIp == NULL) ||
           (ulIPofGuidDNSName != INADDR_NONE && pszGuidIp != NULL));

    // We either failed in the DNS lookup or the ping of the IP of the Guid
    //   based DNS Name.  Either way lookup the normal name.
    dwRet = GetIpAddrByDnsNameW(pServer->pszDNSName, pszNormalIp);
    if(dwRet == NO_ERROR){
        wcstombs(paszNormalIp, pszNormalIp, IPADDRSTR_SIZE);
        ulNormalIp = inet_addr(paszNormalIp);
        if(ulNormalIp == INADDR_NONE){
            if(ulIPofGuidDNSName == INADDR_NONE){
                // Nothing weird here, neither name resolved, nothing printed out.
                return(FALSE); 
            }
            // How odd, the Guid DNS Name resolved, but the Normal Name
            //   could not be resolved.

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_CONNECTIVITY_DNS_NO_NORMAL_NAME,
                     pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName);
            return(FALSE);
        }
    } else {
        if(ulIPofGuidDNSName == INADDR_NONE){
            // Nothing weird here, neither name resolved, nothing printed out.
            return(FALSE);
        } 
        // How odd, the Guid DNS Name resolved, but the Normal Name
        //   could not be resolved.

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_CONNECTIVITY_DNS_NO_NORMAL_NAME,
                 pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName);
        return(FALSE);
    }

    if(ulIPofGuidDNSName == ulNormalIp){
        // The GUID based DNS Name and Normal DNS Name resolved to the same
        //   IP, so no need to try to reping it or print out an error. Just
        //   bail out.
        Assert(ulIPofGuidDNSName != INADDR_NONE && "What?? This should"
               " never happen, because ulNormalIp should be a valid IP.");
        return(FALSE);
    }
    
    // Interesting case, the resolved IP of the Normal name was different
    //    than that of the resolved Guid based IP.  So lets run a ping off
    //    the Normal DNS Name.

    if((dwRet = Ping(ulNormalIp)) == ERROR_SUCCESS){

        if(ulIPofGuidDNSName == INADDR_NONE){
            // The Guid based name couldn't  be resolved, but the normal name
            //    could be resolved and pinged.
            
            PrintMsg(SEV_ALWAYS,
                     DCDIAG_CONNECTIVITY_DNS_GUID_NAME_NOT_RESOLVEABLE,
                     pServer->pszGuidDNSName, pServer->pszDNSName, pszNormalIp);
            return(TRUE);
        } else {
            // The Guid based DNS name was resolved, but could not be pinged,
            //   the normal name resolved to a different IP, and was pingeable.
            
            PrintMsg(SEV_ALWAYS, 
                     DCDIAG_CONNECTIVITY_DNS_INCONSISTENCY_NO_GUID_NAME_PINGABLE,
                     pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName,
                     pszNormalIp);
            return(TRUE);
        }
    } else {
        if(ulIPofGuidDNSName == INADDR_NONE){
            // The Guid based DNS name couldn't be resolved, but the Normal
            //    DNS name was resolved but couldn't be pinged.

            PrintMsg(SEV_ALWAYS, 
                     DCDIAG_CONNECTIVITY_DNS_NO_GUID_NAME_NORMAL_NAME_PINGABLE,
                     pServer->pszGuidDNSName, pServer->pszDNSName, pszNormalIp);
            return(FALSE);
        } else {
            // Both Guid And Normal DNS names resolved, but to different IPs,
            //   and neither could be pinged.  Most odd case.

            PrintMsg(SEV_ALWAYS,
                         DCDIAG_CONNECTIVITY_DNS_INCONSISTENCY_NO_PING,
                         pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName,
                         pszNormalIp);
            return(FALSE);
        }
    }
    Assert(!"Bad programmer!  The conditional above should have taken care of it.");
    return(FALSE);
}
INT
FaPing(
    PDC_DIAG_SERVERINFO              pServer,
    LPWSTR                           pszGuidIp,
    ULONG                            ulIPofGuidDNSName,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
    )

/*++

Routine Description

    This function tries to ping the IP address provided, if successful it calls ...FaLdapCheck(), else it prints a friendly error message and returns a win32Err

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server we are trying to identify.
    pszGuidIp - String version of IP address like: L"172.98.233.13"
    ulIPofGuidDNSName - Assumed to be the IP address of the machine, this may not actually be the 
        Guid IP, if this is the first call of this function on the original machine.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
  
    ULONG                        dwRet, dwRet2;

    if((dwRet = Ping(ulIPofGuidDNSName)) == ERROR_SUCCESS){
        dwRet = FaLdapCheck(pServer, ulIPofGuidDNSName, gpCreds);
    } else {
        if(dwRet == ERROR_NOT_ENOUGH_MEMORY){
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
        } else {
            if(pServer->pszGuidDNSName == NULL
               || !FaCheckNormalName(pServer, pszGuidIp, ulIPofGuidDNSName)){
                PrintMessage(SEV_ALWAYS, L"Server %s resolved to this IP address %s, \n", 
                             pServer->pszName, pszGuidIp);
                PrintMessage(SEV_ALWAYS, L"but the address couldn't be reached(pinged), so check the network.  \n");
                PrintMessage(SEV_ALWAYS, L"The error returned was: %s  \n", Win32ErrToString(dwRet));

                switch(dwRet){
                case WSA_QOS_NO_RECEIVERS:
                    PrintMessage(SEV_ALWAYS, L"This error more often than not means the local machine is \n");
                    PrintMessage(SEV_ALWAYS, L"disconnected from the network.\n");
                    break;
                case WSA_QOS_ADMISSION_FAILURE:
                    PrintMessage(SEV_ALWAYS, L"This error more often means that the targeted server is \n");
                    PrintMessage(SEV_ALWAYS, L"shutdown or disconnected from the network\n");
                    break;
                default:
                    // Note the default message is printed above.
                    ;
                }
            } // end if there is a Guid Name, ie not a call of this function.
            //  on home server.
            
        } // if/else no memory
    }
    return(dwRet);
}


INT
RUC_FaDNSResolve(
    PDC_DIAG_SERVERINFO              pServer,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
		      )
/*++

Routine Description

    This resolves the pServer->pszGuidDNSName or pServer->pszName provided to a IP address and then 
    calles ...FaPing(), else prints off a friendly descriptive error message and returns a Win32Err.

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server we are trying to identify.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
    ULONG                       ulIPofDNSName;
    ULONG                       dwErr;
    INT                         iTempSize, iTemp;
    CHAR                        cTemp;
    WCHAR                       pszIp[IPADDRSTR_SIZE];
    CHAR                        paszIp[IPADDRSTR_SIZE];
    DWORD                       dwRet;
    LPWSTR                      pszHostName;

    // Guid-based name may not always be set
    pszHostName = (pServer->pszGuidDNSName ? pServer->pszGuidDNSName : pServer->pszName );

    dwErr = GetIpAddrByDnsNameW(pszHostName, pszIp);

    if(dwErr == NO_ERROR){

        wcstombs(paszIp, pszIp, IPADDRSTR_SIZE);
	
        ulIPofDNSName = inet_addr(paszIp);
        if(ulIPofDNSName == INADDR_NONE){
            PrintMessage(SEV_ALWAYS, L"The host %s could not be resolved to a valid IP address.\n",
                         pszHostName );
            PrintMessage(SEV_ALWAYS, L"Check the DNS server, DHCP, server name, etc\n");
            return(ERROR_INVALID_PARAMETER);
        }

        dwRet = FaPing(pServer, pszIp, ulIPofDNSName, gpCreds);
	goto CleanExitPoint;
    } else {
        // There was an error in GetIpAddrByDnsNameW()
        dwRet = dwErr;

	switch(dwRet){
	case WSAHOST_NOT_FOUND:
	case WSANO_DATA:
	  PrintMessage(SEV_ALWAYS, L"The host %s could not be resolved to an\n", pszHostName);
          PrintMessage(SEV_ALWAYS, L"IP address.  Check the DNS server, DHCP, server name, etc\n");
	  break;
	case WSATRY_AGAIN:
	case WSAEINPROGRESS:
	case WSAEINTR:
	  PrintMessage(SEV_ALWAYS, L"An error that is usually temporary occured during DNS host lookup,\n");
          PrintMessage(SEV_ALWAYS, L"Please try again later.\n");
	  break;
	case WSANO_RECOVERY:
	  PrintMessage(SEV_ALWAYS, L"An error occured during DNS host lookup, that the program could not\n");
          PrintMessage(SEV_ALWAYS, L"recover from\n");
	  break;
	case WSANOTINITIALISED:
	case WSAENETDOWN:
	  PrintMessage(SEV_ALWAYS, L"There is a problem with the network.  Check to see the sockets\n");
          PrintMessage(SEV_ALWAYS, L"services are up, the computer is connected to the network, etc.\n");
	  break;
	default:
          PrintMessage(SEV_ALWAYS, L"An error cocured during DNS host lookup\n");
        }

        if(pServer->pszGuidDNSName != NULL){
            FaCheckNormalName(pServer, NULL, INADDR_NONE);
        }

	goto CleanExitPoint;
    }

 CleanExitPoint:
    
    return(dwRet);
}

INT 
ReplServerConnectFailureAnalysis(
                             PDC_DIAG_SERVERINFO             pServer,
			     SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
			       )
 /*++

Routine Description:

    Use this to print a message that users would not normally want to
    see but that might be useful in localizing an error.  It will only
    be displayed in verbose mode.  It will return a Win 32 Error, either
    a ERROR_SUCCESS, or the first error it ran into during the process,
    from ldap open() or bind() or DNS lookup, or Ping(), etc.

Arguments:

    pDsInfo (IN) - This is the dcdiag struct of info about the whole enterprise
    ulCurrTargetServer (IN) - This is the server we are targeting for this test
    gpCreds (IN) - Credentials for ldap and 

Return Value:

    Win 32 Error Value;

--*/
{
    DWORD                       dwWin32Err = ERROR_SUCCESS;
    LPWSTR                      pszRet = NULL;
        
    WSASetLastError(0);

    if(pServer == NULL){
        Assert("This shouldn't happen, bad programmer error, someone is calling ReplServerConnectFailureAnalysis() with a NULL for pServer field\n");
        return(ERROR_INVALID_PARAMETER);
    }

    dwWin32Err = RUC_FaDNSResolve(pServer, gpCreds);

    if(dwWin32Err == ERROR_SUCCESS){
        IF_DEBUG( PrintMessage(SEV_ALWAYS, L"Failure Analysis: %s ... OK.\n", 
                                    pServer->pszName) );
    } else {
        pServer->bDnsIpResponding = FALSE;
    }

    return(dwWin32Err);
}


VOID DNSRegistrationHelp (
    DWORD			dwWin32Err
    )
{
    switch (dwWin32Err) {

	case RPC_S_SERVER_TOO_BUSY:
	case EPT_S_NOT_REGISTERED:
	    PrintMessage(SEV_ALWAYS, L"This may be a transient error.  Try running dcdiag again in a\n");
	    PrintMessage(SEV_ALWAYS, L"few minutes.  If the error persists, there might be a problem with\n");
	    PrintMessage(SEV_ALWAYS, L"the target server.  Try running nettest and dcdiag on the target\n");
	    PrintMessage(SEV_ALWAYS, L"server.\n");
	    break;

	case RPC_S_SERVER_UNAVAILABLE:
	    PrintMessage(SEV_ALWAYS, L"This server could not be located on the network.  This might\n");
	    PrintMessage(SEV_ALWAYS, L"be due to one or several of these reasons:\n");
	    PrintMessage(SEV_ALWAYS, L"(a) The target server is temporarily down.\n");
	    PrintMessage(SEV_ALWAYS, L"(b) There is a problem with the target server.  Try running\n");
	    PrintMessage(SEV_ALWAYS, L"    nettest and dcdiag on the target server.\n");
	    PrintMessage(SEV_ALWAYS, L"(c) The target server's DNS name is registered incorrectly\n");
	    PrintMessage(SEV_ALWAYS, L"    in the directory service.\n");
	    break;

	default:
	    break;

    }

}

DWORD 
RPCServiceCheck (
    PDC_DIAG_SERVERINFO            pServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This function checks that the RPC or DsBind services are up and running.

Arguments:
    pServer (IN) - This is the server to check for DsBind service.
    gpCreds (IN) - Credentials for DsBindWithCredW() if needed.

Return Value:
    Win 32 Error Value;

--*/
{
    HANDLE			hDS = NULL;
    DWORD                       ulRet;

    PrintMessage(SEV_VERBOSE, L"* Active Directory RPC Services Check\n");

    ulRet = DcDiagGetDsBinding(pServer, gpCreds, &hDS);
    pServer->bDsResponding = (ulRet == ERROR_SUCCESS);

    return ulRet;
}

DWORD 
LDAPServiceCheck (
    PDC_DIAG_SERVERINFO            pServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This function checks that the ldap services are up and running.

Arguments:
    pServer (IN) - This is the server to check for ldap services.
    gpCreds (IN) - Credentials for ldap_bind_sW() if needed.

Return Value:
    Win 32 Error Value;

--*/
{
    DWORD			dwWin32Err;

    PrintMessage(SEV_VERBOSE, L"* Active Directory LDAP Services Check\n");

    dwWin32Err = ReplServerConnectFailureAnalysis(pServer, gpCreds);

    pServer->bLdapResponding = (dwWin32Err == ERROR_SUCCESS); // Not responding
    return dwWin32Err;        
}

DWORD
ReplUpCheckMainEx (
    PDC_DIAG_SERVERINFO            pServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This is the guts/top level function of the UpCheck test, it basically first 
    checks that first DNS is registered, then that it's IP address is pingeable,
    then that ldap services are up and finally that RPC/DsBind services are up.  
    If it fails at any point it prints out suiteable error message an returns an
    error code.

Arguments:
    pServer (IN) - This is the server to check for DsBind service.
    gpCreds (IN) - Credentials for ldap_bind_sW() and DsBindWithCredW() calls if needed.

Return Value:
    Win 32 Error Value;

--*/
{
    DWORD			dwWin32Err = ERROR_SUCCESS;

    if(pServer == NULL){
        Assert("This shouldn't happen, bad programmer error, someone is calling ReplUpCheckMainEx() with a NULL for pServer field\n");
        return(ERROR_INVALID_PARAMETER);
    }

    dwWin32Err = LDAPServiceCheck(pServer, gpCreds);
    if(dwWin32Err != ERROR_SUCCESS){
        pServer->bLdapResponding = FALSE;
        return dwWin32Err;
    } else {
        dwWin32Err = RPCServiceCheck(pServer, gpCreds);
        if(dwWin32Err != ERROR_SUCCESS){
            pServer->bDsResponding = FALSE;
            return dwWin32Err;
        }
    }

    return ERROR_SUCCESS;
}


VOID
checkClockDifference(
    PDC_DIAG_SERVERINFO pHomeServer,
    PDC_DIAG_SERVERINFO pTargetServer
    )

/*++

Routine Description:

Check if the time at the target server is too far apart from the time at the
home server.

We are comparing the time of ldap connect on these servers, accounting for the
local time delay between collecting the timestamps. We are assuming that time
passes at the same rate on this system as it does on the dc's being measured.

It is assumed that the connect time of the home server is initialized when
dcdiag first starts. See main.c

The timestamp for a particular target is collected before the bind attempt is
made. Thus this routine can be called even if the bind attempt fails.

Arguments:

    pHomeServer - 
    pTargetServer - 

Return Value:

    None

--*/

{
    LONGLONG time1, time2, localSkew, remoteSkew;
#define ONE_SECOND (10 * 1000 * 1000L)
#define ONE_MINUTE (60 * ONE_SECOND)

    // Calculate the local delay in acquiring the two stamps
    time1 = *(LONGLONG*)&(pTargetServer->ftLocalAcquireTime);
    time2 = *(LONGLONG*)&(pHomeServer->ftLocalAcquireTime);
    if (time1 == 0) {
        // If stamp not collected, don't bother
        return;
    }
    Assert( time2 != 0 );
    Assert( time1 >= time2 );

    localSkew = time1 - time2;
    // Round down to nearest second
    // Remote times are only to second accuracy anyway
    localSkew = (localSkew / ONE_SECOND) * ONE_SECOND;

    // Calculate the time clock difference
    time1 = *(LONGLONG*)&(pTargetServer->ftRemoteConnectTime);
    time2 = *(LONGLONG*)&(pHomeServer->ftRemoteConnectTime);
    Assert( time1 != 0 );
    Assert( time2 != 0 );

    time1 -= localSkew;// Account for local collection delay

    // Either computer could be running a little fast
    if (time1 > time2) {
        remoteSkew = time1 - time2;
    } else {
        remoteSkew = time2 - time1;
    }

    if (remoteSkew > ONE_MINUTE) {
        PrintMsg( SEV_ALWAYS, DCDIAG_CLOCK_SKEW_TOO_BIG,
                  pHomeServer->pszName, pTargetServer->pszName );
    }

#undef ONE_MINUTE
#undef ONE_SECOND
} /* checkClockDifference */

DWORD
ReplUpCheckMain (
    PDC_DIAG_DSINFO		   pDsInfo,
    ULONG                          ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This is merely a wrapper routine of ReplUpCheckMainEx(), except this function
    takes a pDsInfo structure and a target server and calls ReplUpCheckMainEx()
    with the appropriate pServer structure.  This is so that this test can be called
    from the array of tests in include\alltests.h, which forces a test to take
    a pDsInfo structure and a target server.

Arguments:

    pDsInfo (IN) - This is the dcdiag struct of info about the whole enterprise
    ulCurrTargetServer (IN) - This is the server we are targeting for this test
    gpCreds (IN) - Credentials for ldap and 

Return Value:
    Win 32 Error Value;

--*/
{
    DWORD status;
    PDC_DIAG_SERVERINFO pHomeServer, pTargetServer;

    if(ulCurrTargetServer == NO_SERVER){
        Assert("The programmer shouldn't call ReplUpCheckMain() with NO_SERVER value");
        return(ERROR_INVALID_PARAMETER);
    }

    pHomeServer = &(pDsInfo->pServers[pDsInfo->ulHomeServer]);
    pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);

    status = ReplUpCheckMainEx( pTargetServer, gpCreds);

    // Check this regardless of status
    checkClockDifference( pHomeServer, pTargetServer );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\roles.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    roles.c

ABSTRACT:

    Advertisement and role holding test

DETAILS:

CREATED:

    21 Jul 1999  William Lees

--*/

#include <ntdspch.h>

#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h> // NetApiBufferFree
#include <ntdsa.h>    // options

#include "dcdiag.h"
#include "ldaputil.h"

// Other Forward Function Decls
PDSNAME
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    );
BOOL
RH_CARVerifyGC(
    IN  PDC_DIAG_DSINFO                pDsInfo,
    IN  PDOMAIN_CONTROLLER_INFO        pDcInfo,
    OUT PDWORD                         pdwErr
    );

static LPWSTR wzRoleNames[] = {
    L"Schema Owner",
    L"Domain Owner",
    L"PDC Owner",
    L"Rid Owner",
    L"Infrastructure Update Owner",
};

static LPWSTR wzNameErrors[] = {
    L"No Error",
    L"Can't Resolve",
    L"Not Found",
    L"Not Unique",
    L"No Mapping",
    L"Domain Only",
    L"No Syntactical Mapping",
};


DWORD
CheckFsmoRoles(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This is a helper function for the CheckRoles test.

This test checks whether Fsmo roles can be returned, and that the
returned role holders are responding.

Fsmo roles are stored as dn-valued attributes in the DS.  Each role is stored
on a different attribute on a different object.  By writing the name of a 
server on a Fsmo attribute, we are causing the election of that server to that
role.  Replication will resolve any conflicts so that eventually all dc's will
agree who holds that role.  Note that Fsmo's must be manually moved, and that
the do not float automatically like the site generator role (which is not,
strictly speaking, a Fsmo).

The DsListRoles api will return the Fsmo holders for us.

We are assuming that all Fsmo's returned are global to the enterprise, and are
not domain specific.

Note that this test assumes that the home server's view of the Fsmo role 
holders is sufficient.  This test does not verify that all dc's share the same
view of the Fsmo's. Replication should assure that all dc's see the same 
Fsmo's, unless part of the problem being debugged is that replication is 
partitioned.  Since Fsmo's should not change verify frequently, differing 
views of the Fsmo's is not our top priority.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/

{
    DWORD status, dwRoleIndex, dwServerIndex;
    BOOL fWarning = FALSE;
    PDS_NAME_RESULTW pRoles = NULL;
    PDC_DIAG_SERVERINFO psiTarget = &(pDsInfo->pServers[ulCurrTargetServer]);
    PDC_DIAG_SERVERINFO psiRoleHolder;
    HANDLE hDs;
    LDAP *hLdap;

    // Don't check servers that are not responding
    if ( (!psiTarget->bLdapResponding) || (!psiTarget->bDsResponding) ) {
        return ERROR_SUCCESS;
    }

    // Bind to target server
    status = DcDiagGetDsBinding( psiTarget, pCreds, &hDs );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Get the roles as known to the home server...

    status = DsListRoles( hDs, &pRoles );
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS, L"Fatal Error: DsListRoles (%ws) call failed, error %d\n", psiTarget->pszName, status );
        PrintMessage( SEV_ALWAYS, L"Could not reach DS at home server.\n" );
        PrintRpcExtendedInfo(SEV_VERBOSE, status);
        goto cleanup;
    }

    Assert( pRoles->cItems > DS_ROLE_INFRASTRUCTURE_OWNER );

    //
    // Iterate through the role holders.  Verify that the role holder could
    // be determined, and that the server is valid and responding.
    //

    for( dwRoleIndex = 0; dwRoleIndex < pRoles->cItems; dwRoleIndex++ ) {
        PDS_NAME_RESULT_ITEM pnsiRole = pRoles->rItems + dwRoleIndex;

        if (!pnsiRole->status) {
            PrintMessage( SEV_VERBOSE, L"Role %ws = %ws\n",
                      wzRoleNames[dwRoleIndex], pnsiRole->pName );
        }

        // Was the name resolved?
        if ( (pnsiRole->status != DS_NAME_NO_ERROR) ||
             (!pnsiRole->pName) ) {
            PrintMessage(SEV_ALWAYS,
                        L"Warning: %ws could not resolve the name for role\n",
                         psiTarget->pszName );
            PrintMessage( SEV_ALWAYS, L"%ws.\n", wzRoleNames[dwRoleIndex] );
            PrintMessage( SEV_ALWAYS, L"The name error was %ws.\n",
                          wzNameErrors[pnsiRole->status] );
            fWarning = TRUE;
            continue;
        }

        // Is the server deleted?
        if (IsDeletedRDNW( pnsiRole->pName )) {
            PrintMessage(SEV_ALWAYS, L"Warning: %ws is the %ws, but is deleted.\n", pnsiRole->pName, wzRoleNames[dwRoleIndex] );
            fWarning = TRUE;
            continue;
        }

        // The name returned by ListRoles is a dn of the NTDS-DSA object
        // Convert Role holder Dn to server info

        dwServerIndex = DcDiagGetServerNum( pDsInfo, NULL, NULL, 
                                            pnsiRole->pName, NULL,NULL );
        if (dwServerIndex == NO_SERVER) {
            // Lookup failed
            PrintMessage(SEV_ALWAYS,
                         L"Warning: %ws returned role-holder name\n",
                         psiTarget->pszName );
            PrintMessage(SEV_ALWAYS,
                         L"%ws that is unknown to this Enterprise.\n",
                         pnsiRole->pName );
            fWarning = TRUE;
            continue;
        }
        psiRoleHolder = &(pDsInfo->pServers[dwServerIndex]);   

        status = DcDiagGetDsBinding( psiRoleHolder, pCreds, &hDs );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS, L"Warning: %ws is the %ws, but is not responding to DS RPC Bind.\n", psiRoleHolder->pszName, wzRoleNames[dwRoleIndex] );
            PrintRpcExtendedInfo(SEV_VERBOSE, status);
            fWarning = TRUE;
        }

        status = DcDiagGetLdapBinding( psiRoleHolder, pCreds, FALSE, &hLdap );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS, L"Warning: %ws is the %ws, but is not responding to LDAP Bind.\n", psiRoleHolder->pszName, wzRoleNames[dwRoleIndex] );
            fWarning = TRUE;
        }

    } // for role index ...

    status = ERROR_SUCCESS;
cleanup:

    if (pRoles != NULL) {
        DsFreeNameResult( pRoles );
    }

    // If warning flag set, and no more serious error, return indicator...
    if ( (status == ERROR_SUCCESS) && (fWarning) ) {
        status = ERROR_NOT_FOUND;
    }

    return status;
} /* CheckFsmoRoles */


DWORD 
ReplLocatorGetDcMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This test performs locator related checks.  This test determines if a server
is advertising when it should.

This is a per-server test.

DsGetDcName is the API to the "locator". The locator is the service location
mechanism for Domain Controllers.  It may use Netbios, DNS or the DS itself to
locate other domain controllers.  The locator can find DC's by capability, such
as a Global Catalog or a Primary Domain Controller.

When DsGetDcName is directed at a particular server, it will return whether that
server is up, and what capabilities that server has.  We want to verify that the
server is reporting all the capabilities, or roles, that it should.

In this test, we should only be called if the server is responding.  There is a
possibility that DsGetDcName might refer us to another DC if the server we
requested is not suitable.  We check for this case.

Arguments:

    pDsInfo - Information structure
    ulCurrTargetServer - Index of target server
    pCreds - 

Return Value:

    DWORD  - 

--*/

{
    DWORD status, cItems;
    BOOL fWarning = FALSE;
    PDC_DIAG_SERVERINFO psiTarget = &(pDsInfo->pServers[ulCurrTargetServer]);
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    DWORD dwTempErr = ERROR_SUCCESS;
    BOOL fNotFound = FALSE, fConnected = FALSE;
    size_t cch = 0;
    WCHAR wzUncName[MAX_PATH+3] = L"\\\\";
    NETRESOURCE NetRes = {0};


    if (!psiTarget->bIsSynchronized) {
        PrintMessage( SEV_ALWAYS, L"Warning: the directory service on %ws has not completed initial synchronization.\n", psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Other services will be delayed.\n" );
        PrintMessage( SEV_ALWAYS, L"Verify that the server can replicate.\n" );
        fWarning = TRUE;
    }

    // Get active domain controller information
    if (pCreds && pCreds->User)
    {
       wcscat(wzUncName, psiTarget->pszName);
       NetRes.dwType = RESOURCETYPE_ANY;
       NetRes.lpRemoteName = wzUncName;

       // No need to fail this ReplLocatorGetDcMain call with an error here, the error
       // check on DsGetDcName is sufficient.
       fConnected = WNetAddConnection2(&NetRes,
                                       (pCreds->Password) ? pCreds->Password : L"",
                                       pCreds->User,
                                       0) == ERROR_SUCCESS;
    }
    status = DsGetDcName(
        psiTarget->pszName,
        NULL, // domain name
        NULL, // domain guid,
        NULL, // site name,
        DS_DIRECTORY_SERVICE_REQUIRED |
        DS_IP_REQUIRED |
        DS_IS_DNS_NAME |
        DS_RETURN_DNS_NAME,
        &pDcInfo );
    if (fConnected)
    {
       WNetCancelConnection2(wzUncName, 0, TRUE);
    }
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS, L"Fatal Error:DsGetDcName (%ws) call failed, error %d\n",
                     psiTarget->pszName, status ); 
        PrintMessage(SEV_ALWAYS, L"The Locator could not find the server.\n" );
        PrintRpcExtendedInfo(SEV_VERBOSE, status);
        goto cleanup;
    }

    // Verify that DsGetDcName returned info for the server we asked for
    cch = wcslen(psiTarget->pszName);
    if (wcslen(pDcInfo->DomainControllerName + 2) < cch)
    {
       fNotFound = TRUE;
    }
    else
    {
       fNotFound = CompareString(LOCALE_INVARIANT,
                                 NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                                 pDcInfo->DomainControllerName + 2,
                                 cch,
                                 psiTarget->pszName,
                                 -1
                                 ) != CSTR_EQUAL;
    }
    if (fNotFound) {
        PrintMessage( SEV_ALWAYS, L"Warning: DsGetDcName returned information for %ws, when we were trying to reach %ws.\n", pDcInfo->DomainControllerName, psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Server is not responding or is not considered suitable.\n" );
        fWarning = TRUE;
    }

    // DS Role Flag
    if ( !(pDcInfo->Flags & DS_DS_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a directory server Domain Controller.\n", psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Check that the database on this machine has sufficient free space.\n" );
        fWarning = TRUE;
    } else {
        // Code.Improvement would be to condense all these lines into 
        PrintMessage( SEV_VERBOSE, L"The DC %s is advertising itself as a DC and having a DS.\n", psiTarget->pszName );
    }

    // LDAP Role Flag
    if ( !(pDcInfo->Flags & DS_LDAP_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a LDAP server.\n", psiTarget->pszName );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as an LDAP server\n", psiTarget->pszName );
    }

    // DS WRITABLE Role Flag
    if ( !(pDcInfo->Flags & DS_WRITABLE_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a writable directory server.\n", psiTarget->pszName );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as having a writeable directory\n", psiTarget->pszName );
    }

    // KDC Role Flag
    if ( !(pDcInfo->Flags & DS_KDC_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a Key Distribution Center.\n", psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Check that the Directory has started.\n" );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as a Key Distribution Center\n", psiTarget->pszName );
    }

    // TIMESERV Role Flag
    if ( !(pDcInfo->Flags & DS_TIMESERV_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a time server.\n", psiTarget->pszName );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as a time server\n", psiTarget->pszName );
    }

    // GC Role Flag, if it is supposed to be a GC
    if (psiTarget->iOptions & NTDSDSA_OPT_IS_GC) {
        if (!psiTarget->bIsGlobalCatalogReady) {
            PrintMessage( SEV_ALWAYS, L"Warning: %ws has not finished promoting to be a GC.\n", psiTarget->pszName );
            PrintMessage( SEV_ALWAYS, L"Check the event log for domains that cannot be replicated.\n" );
        }
        if (pDcInfo->Flags & DS_GC_FLAG) {
            if(!RH_CARVerifyGC(pDsInfo, pDcInfo, &dwTempErr)){
                PrintMessage(SEV_ALWAYS, L"Server %s is advertising as a global catalog, but\n",
                             psiTarget->pszName);
                PrintMessage(SEV_ALWAYS, L"it could not be verified that the server thought it was a GC.\n");
                fWarning = TRUE;
            } else {
                PrintMessage(SEV_VERBOSE, L"The DS %s is advertising as a GC.\n", psiTarget->pszName );
            }
        } else {
            PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a global catalog.\n", psiTarget->pszName );
            PrintMessage( SEV_ALWAYS, L"Check that server finished GC promotion.\n" );
            PrintMessage( SEV_ALWAYS, L"Check the event log on server that enough source replicas for the GC are available.\n" );
            fWarning = TRUE;
        } 
    }

    // Check whether DsListRoles returns Fsmo's, and that they are responding

    status = ERROR_SUCCESS;

cleanup:

    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }

    // If warning flag set, and no more serious error, return indicator...
    if ( (status == ERROR_SUCCESS) && (fWarning) ) {
        status = ERROR_NOT_FOUND;
    }

    return status;
} /* LocatorGetDcMain */

BOOL
RH_CARVerifyGC(
    IN  PDC_DIAG_DSINFO                pDsInfo,
    IN  PDOMAIN_CONTROLLER_INFO        pDcInfo,
    OUT PDWORD                         pdwErr
    )
/*++

Routine Description

    This code verifys that the DC passed back in pDcInfo is in fact a GC.

Arguments:

    pDsInfo - the mini enterprise.
    pDcInfo - the struct gotten from DsGetDcName()
    pdwErr - a return value of an error if it occured.

Return Values
  
    returns TRUE if it could verify the machine as a GC, returns FALSE if ther
    was an error or it verifies the machine as NOT a GC.  If the function
    verifies the machine as not a GC, then pdwErr will be ERROR_SUCCESS.

--*/
{
    LPWSTR                             pszTemp = NULL;
    LPWSTR                             pszOptions = NULL;
    INT                                i;
    ULONG                              iServer;
    LONG                               lOptions;
    WCHAR *                            pwcStopString;
    BOOL                               bRet;

    Assert(pDsInfo);
    Assert(pDcInfo);
    Assert(pdwErr);
    
    *pdwErr = ERROR_SUCCESS;

    __try {
        // Get a copy of the first part of the DNS name.
        pszTemp = pDcInfo->DomainControllerName;
        for(;pszTemp[0] == L'\\'; pszTemp++);

        // Find the server associated with this DNS name.
        iServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, NULL, pszTemp, NULL);
        if(iServer == NO_SERVER){
            *pdwErr = ERROR_INVALID_SERVER_STATE;
            bRet = FALSE;
            __leave;
        }
        // Get the options attribute of this servere NTDSA object.
        *pdwErr = DcDiagGetStringDsAttribute(&(pDsInfo->pServers[iServer]), 
                                             pDsInfo->gpCreds,
                                             pDsInfo->pServers[iServer].pszDn,
                                             L"options",
                                             &pszOptions);
        if(*pdwErr != ERROR_SUCCESS){
            // Most likely NTDSA object didn't exist.
            bRet = FALSE;
            __leave;
        }
        if(pszOptions == NULL){
            // Attribute did not exist, meaning not a GC
            *pdwErr = ERROR_SUCCESS;
            bRet = FALSE;
            __leave;
        }

        lOptions = wcstol(pszOptions, &pwcStopString, 10);
        Assert(*pwcStopString == L'\0');
        
        if(lOptions & NTDSDSA_OPT_IS_GC){
            // Hooray, machine thinks it's a GC.
            *pdwErr = ERROR_SUCCESS;
            bRet = TRUE;
            __leave;
        } else {
            // Uh-oh, doesn't think it is a GC.
            *pdwErr = ERROR_SUCCESS;
            bRet = FALSE;
            __leave;
        }
    } __finally {
        if(pszOptions){ LocalFree(pszOptions); }
    }
    return(bRet);
}

BOOL
RH_CARVerifyPDC(
    IN  PDC_DIAG_DSINFO                pDsInfo,
    IN  PDOMAIN_CONTROLLER_INFO        pDcInfo,
    OUT PDWORD                         pdwErr
    )
/*++

Routine Description

    This function verifies that the server in the pDcInfo struct is a PDC.

Arguments:

    pDsInfo - the mini-enterprise.
    pDcInfo - the server struct from DsGetDcName()
    pdwErr - the error code if there is an error.

Return Values
  
    Returns TRUE if we are able to verify from DsListRoles() that this machine
    is a PDC.  If the machine is not listed in DsListRoles(), or there is an
    error then FALSE is returned.  If it is confirmed the server is NOT
    the PDC then the error code in pdwErr will be ERROR_SUCCESS

--*/
{
    HANDLE                             hDS = NULL;
    LPWSTR                             pszTemp = NULL;
    LPWSTR                             pszTargetName = NULL;
    PDS_NAME_RESULTW                   prgRoles = NULL;
    PDSNAME                            pdsnameNTDSSettings = NULL;
    PDSNAME                            pdsnameServer = NULL;
    ULONG                              iServer;
    ULONG                              iTemp;
    LPWSTR                             pszDnsName = NULL;
    BOOL                               fRet = FALSE;

    Assert(pDsInfo);
    Assert(pDcInfo);
    Assert(pdwErr);

    *pdwErr = ERROR_SUCCESS;

    __try{
        // --------------------------------------------------- 
        // Setup server string from pDcInfo
        pszTemp = pDcInfo->DomainControllerName;
        for(;pszTemp[0] == L'\\'; pszTemp++);

        // ---------------------------------------------------
        // Setup Server string from DsListRoles.
        *pdwErr = DcDiagGetDsBinding(&(pDsInfo->pServers[pDsInfo->ulHomeServer]),
                                     pDsInfo->gpCreds,
                                     &hDS);
        if(*pdwErr != ERROR_SUCCESS){
            fRet = FALSE;
            __leave;
        }
        *pdwErr = DsListRoles(hDS, &prgRoles);
        if(*pdwErr != NO_ERROR){
            fRet = FALSE;
            __leave;
        }
        if(prgRoles->cItems < DS_ROLE_PDC_OWNER){
            *pdwErr = ERROR_INVALID_DATA;
            fRet = FALSE;
            __leave;
        }
        // Now we have the NTDSA object, but trim it off and get the 
        //   dNSHostName, from the Computer object.
        pdsnameNTDSSettings = DcDiagAllocDSName(prgRoles->rItems[DS_ROLE_PDC_OWNER].pName);
        if(pdsnameNTDSSettings == NULL){
            *pdwErr = GetLastError();
            fRet = FALSE;
            __leave;
        }
        pdsnameServer = (PDSNAME) LocalAlloc(LMEM_FIXED, 
                                             pdsnameNTDSSettings->structLen);
        if(pdsnameServer == NULL){
            *pdwErr = GetLastError();
            fRet = FALSE;
            __leave;
        }
        TrimDSNameBy(pdsnameNTDSSettings, 1, pdsnameServer);
        *pdwErr = DcDiagGetStringDsAttribute(&(pDsInfo->pServers[pDsInfo->ulHomeServer]), pDsInfo->gpCreds, 
                                             pdsnameServer->StringName, L"dNSHostName",
                                             &pszDnsName);
        
        if(*pdwErr != ERROR_SUCCESS){
            fRet = FALSE;
            __leave;
        }
        if(pszDnsName == NULL){
            // Simply means the attribute didn't exist.
            *pdwErr = ERROR_NOT_FOUND;
            fRet = FALSE;
            __leave;
        }

        // ---------------------------------------------------
        // Compare the two strings and make sure they are the same server.
        if(_wcsicmp(pszTemp, pszDnsName) == 0){
        // Successfully verified PDC with DsListRoles.
            *pdwErr = ERROR_SUCCESS;
            fRet = TRUE;
            __leave;
        } else {
            // Successfully concluded that they are advertising different PDCs.
            *pdwErr = ERROR_SUCCESS;
            fRet = FALSE;
            __leave;
        }
    } __finally {
        if(prgRoles){ DsFreeNameResult(prgRoles); }
        if(pdsnameNTDSSettings){ LocalFree(pdsnameNTDSSettings); }
        if(pdsnameServer){ LocalFree(pdsnameServer); }
        if(pszDnsName){ LocalFree(pszDnsName); }
    }
    return fRet;
}

DWORD
RH_CARDsGetDcName(
    PDC_DIAG_SERVERINFO                psiTarget,
    ULONG                              ulRoleFlags,
    PDOMAIN_CONTROLLER_INFO *          ppDcInfo
    )
/*++

Routine Description

This is a helper routine to CheckAdvertiesedRoles(), and it basically reduces
this 12 line function call down to a 3 line function call.  Just for clarity
of code.

Arguments:

    psiTarget - the server to test.
    ulRoleFlags - the flags to OR (|) into the 5th parameter
    pDcInfo - the return structure

Return Values
  
    DWORD - the error code from DsGetDcName()

--*/
{
    return(DsGetDcName(psiTarget->pszName,
                       NULL, // domain name
                       NULL, // domain guid
                       NULL, // site name
                       DS_FORCE_REDISCOVERY |
                       DS_IP_REQUIRED |
                       DS_IS_DNS_NAME |
                       DS_RETURN_DNS_NAME |
                       (ulRoleFlags),
                       ppDcInfo ));
}


DWORD
CheckAdvertisedRoles(
    IN  PDC_DIAG_DSINFO             pDsInfo
    )
/*++

Routine Description:

This is a helper function for the CheckRoles test.

Check global roles known to the locator.  If the locator returns the name, the
server is up.

The locator can return a server according to a required criteria.  We point
DsGetDcName at a server to start, so it knows which enterprise it is in.
If we ask for a capability that is not on the starting server, it refers us to
another server with the capability.

The four capabilities, or roles, we ask it to locate are:
o Global Catalog Server (GC)
o Primary Domain Controller (PDC)
o Time Server
o Preferred Time Server
o Kerberos Key Distribution Center (KDC)

Arguments:

    pDsInfo - 

Return Value:

    DWORD - 

--*/
{
    DWORD status;
    BOOL fWarning = FALSE;
    PDC_DIAG_SERVERINFO psiTarget =
        &(pDsInfo->pServers[pDsInfo->ulHomeServer]);
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    DWORD dwError = ERROR_SUCCESS;

    // -----------------------------------------------------------------------
    //
    // Search for an advertised GC somewhere in the enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget, 
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_GC_SERVER_REQUIRED, 
                                     &pDcInfo)) 
        == ERROR_SUCCESS) {
        if(!RH_CARVerifyGC(pDsInfo, pDcInfo, &dwError) != ERROR_SUCCESS){
            if(dwError == ERROR_SUCCESS){
                PrintMessage(SEV_NORMAL,
                             L"Error: A GC returned by DsGetDcName() was not a GC in it's directory\n");
            } else {
                PrintMessage( SEV_VERBOSE,
                              L"Warning: Couldn't verify this server as a GC in this servers AD.\n");
            }
        }
        PrintMessage(SEV_VERBOSE, L"GC Name: %ws\n",
                     pDcInfo->DomainControllerName );
        PrintMessage(SEV_VERBOSE, L"Locator Flags: 0x%x\n", 
                     pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS, 
                     L"Warning: DcGetDcName(GC_SERVER_REQUIRED) call failed, error %d\n", 
                     status ); 
        PrintMessage( SEV_ALWAYS,
                      L"A Global Catalog Server could not be located - All GC's are down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised PDC somewhere in the enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget,
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_PDC_REQUIRED,
                                     &pDcInfo)) 
        == ERROR_SUCCESS) {
        if(!RH_CARVerifyPDC(pDsInfo, pDcInfo, &dwError) != ERROR_SUCCESS){
            if(dwError == ERROR_SUCCESS){
                PrintMessage( SEV_ALWAYS,
                              L"Error: The server returned by DsGetDcName() did not match DsListRoles() for the PDC\n");
            } else {
                PrintMessage( SEV_VERBOSE, L"Warning: Couldn't verify this server as a PDC using DsListRoles()\n");
            }
        }
        PrintMessage( SEV_VERBOSE, L"PDC Name: %ws\n", 
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n", 
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS, 
                     L"Warning: DcGetDcName(PDC_REQUIRED) call failed, error %d\n", 
                     status ); 
        PrintMessage( SEV_ALWAYS, 
                      L"A Primary Domain Controller could not be located.\n" );
        PrintMessage( SEV_ALWAYS, 
                      L"The server holding the PDC role is down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised Time Server somewhere in the enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget, 
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_TIMESERV_REQUIRED,
                                     &pDcInfo))
        == ERROR_SUCCESS){
        PrintMessage( SEV_VERBOSE, L"Time Server Name: %ws\n", 
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n", 
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"Warning: DcGetDcName(TIME_SERVER) call failed, error %d\n", 
                     status );
        PrintMessage( SEV_ALWAYS,
                      L"A Time Server could not be located.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"The server holding the PDC role is down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised Preferred Time Server somewhere in the 
    //    enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget, DS_GOOD_TIMESERV_PREFERRED, &pDcInfo))
        == ERROR_SUCCESS){
        PrintMessage( SEV_VERBOSE, L"Preferred Time Server Name: %ws\n",
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n",
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"Warning: DcGetDcName(GOOD_TIME_SERVER_PREFERRED) call failed, error %d\n", 
                     status ); 
        PrintMessage( SEV_ALWAYS, 
                      L"A Good Time Server could not be located.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised Key Distribution Center somewhere in the 
    //    enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget,
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_KDC_REQUIRED,
                                     &pDcInfo))
        == ERROR_SUCCESS){
        PrintMessage( SEV_VERBOSE, L"KDC Name: %ws\n",
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n",
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"Warning: DcGetDcName(KDC_REQUIRED) call failed, error %d\n", 
                     status );
        PrintMessage( SEV_ALWAYS,
                      L"A KDC could not be located - All the KDCs are down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    if(fWarning){
        return ERROR_NOT_FOUND;
    }
    return(ERROR_SUCCESS);

} /* CheckAdvertisedRoles */


DWORD
ReplCheckRolesMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This is a per-enterprise test.  It verifies that the owners of global roles can
be returened, at the owners are responding.

We check the two ways that Roles are made known to clients: through the locator
and through the Fsmo role apis.

Arguments:

    pDsInfo - 
    ulCurrTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;

    status = CheckAdvertisedRoles( pDsInfo );

    return status;
} /* CheckRolesMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\security.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    security.c

ABSTRACT:

    Contains tests related to replication and whether the appropriate 
    permissions on some security objects are set to allow replication.

DETAILS:

CREATED:

    22 May 1999  Brett Shirley (brettsh)

REVISION HISTORY:
        

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <permit.h>

#include "dcdiag.h"
#include "utils.h"
#include "repl.h"
#include <sddl.h>

#define PERMS ULONG

typedef enum _REPL_PERMS {
    RIGHT_GET_CHANGES,
    RIGHT_GET_CHANGES_ALL,
    RIGHT_SYNC,
    RIGHT_MANAGE_TOPO,
    RIGHT_MAX
} REPL_PERMS;

typedef struct _REPL_RIGHT {
    GUID guidRight;
    PERMS maskRight;
    LPWSTR pszExtStringRight;
} REPL_RIGHT;

#define NUM_REPL_RIGHTS (4)

REPL_RIGHT rgReplRights[RIGHT_MAX] = {
    {{0x1131f6aa,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 0x1, L"Replicating Directory Changes"},
    {{0x1131f6ad,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 0x2, L"Replicating Directory Changes All"},
    {{0x1131f6ab,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 0x4, L"Replication Synchronization"},
    {{0x1131f6ac,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 0x8, L"Manage Replication Topology"},
};

#define RIGHT_ALL_WIN2K (rgReplRights[RIGHT_GET_CHANGES].maskRight | rgReplRights[RIGHT_SYNC].maskRight | rgReplRights[RIGHT_MANAGE_TOPO].maskRight)
#define RIGHT_ALL_WHISTLER (rgReplRights[RIGHT_GET_CHANGES].maskRight | rgReplRights[RIGHT_SYNC].maskRight | rgReplRights[RIGHT_MANAGE_TOPO].maskRight | rgReplRights[RIGHT_GET_CHANGES_ALL].maskRight)
#define RIGHT_DOMAIN_WHISTLER (rgReplRights[RIGHT_GET_CHANGES_ALL].maskRight)
#define RIGHT_ENTERPRISE_WHISTLER (RIGHT_ALL_WIN2K)
#define RIGHT_NONE (0)
#define RIGHT_ALL (RIGHT_ALL_WHISTLER)

// security.c helper data structure
typedef struct _TARGET_ACCOUNT_STRUCT {
    PSID        pSid;
    GUID        Guid;
    ACCESS_MASK access;
    BOOL        bFound;
    
} TARGET_ACCOUNT_STRUCT;

#define ACCT_STRING_SZ 80L

// stolen from ntdsa/src/secadmin.c
VOID
SampBuildNT4FullSid(
    IN NT4SID * DomainSid,
    IN ULONG    Rid,
    IN NT4SID * AccountSid
    )
{
    RtlCopyMemory(AccountSid,DomainSid,RtlLengthSid((PSID) DomainSid));
    (*(RtlSubAuthorityCountSid((PSID) AccountSid)))++;
     *(RtlSubAuthoritySid(
            (PSID) AccountSid,
            *RtlSubAuthorityCountSid((PSID)AccountSid)-1
             )) = Rid;
}

typedef enum _ACCOUNT_TYPE {
    ACCOUNT_EDC,
    ACCOUNT_DDC,
    ACCOUNT_ADMIN,
    ACCOUNT_MAX_TYPE
} ACCOUNT_TYPE ;

LPWSTR ACCOUNT_TYPE_EXT_NAMES[ACCOUNT_MAX_TYPE+1] = {
    L"Enterprise Domain Controllers",
    L"Domain Domain Controllers",
    L"Administrators",
    L"Unknown Account"
};

typedef enum _NC_TYPE {
    NC_CONFIG,
    NC_SCHEMA,
    NC_DOMAIN,
    NC_NDNC,
    NC_MAX_TYPE
} NC_TYPE ;

LPWSTR NC_TYPE_EXT_NAMES[NC_MAX_TYPE+1] = {
    L"Configuration",
    L"Schema",
    L"Domain",
    L"NDNC",
    L"Unknown NC Type"
};

typedef enum _NC_VERSION {
    NC_VERSION_WIN2K,
    NC_VERSION_WHISTLER,
    NC_VERSION_UNKNOWN
} NC_VERSION ;

LPWSTR NC_VERSION_EXT_NAMES[NC_VERSION_UNKNOWN+1] = {
    L"Version 1",
    L"Version 2",
    // This unknown version should always be last
    L"Unknown Version"
};


ULONG
ldapError(
    LDAP * hld,
    ULONG ldapErrIn,
    LPWSTR pszServer, 
    BOOL fVerbose)
/*++

Routine Description

    If there's an ldap error, get the extended error and return it.

Arguments:

    hld -
    ldapErrIn - ldap error
    pszServer - server connected to with hld
    fVerbose - optionally output error text

Return Value:
    
    WINERROR

--*/
{
    ULONG ldapErr = LDAP_SUCCESS;
    ULONG err = ERROR_SUCCESS;
    ULONG ulOptions;

    if (ldapErrIn==LDAP_SUCCESS) {
        return ERROR_SUCCESS;
    }

    ldapErr = ldap_get_option(hld, LDAP_OPT_SERVER_EXT_ERROR, &ulOptions);
    if (ldapErr == LDAP_SUCCESS) {
        err = ulOptions;
    } else {
        err = ERROR_GEN_FAILURE;
    }

    if (fVerbose) {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] An LDAP operation failed with error %d\n",
                     pszServer,
                     err);
        PrintMessage(SEV_ALWAYS, L"%s.\n",
                     Win32ErrToString(err));
    }
    
    return err;
}

BOOL
IsDomainNC(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC)
/*++

Routine Description

    Test whether the NC is a domain NC

Arguments:

    pDsInfo -
    pszNC - nc to test for

Return Value:
    
    Boolean

--*/
{
    LONG i = -1;
    
    i = DcDiagGetMemberOfNCList(pszNC,
                                pDsInfo->pNCs, 
                                pDsInfo->cNumNCs);
    if (i>=0) {
        return ((DcDiagGetCrSystemFlags(pDsInfo, i) & FLAG_CR_NTDS_DOMAIN) != 0);
    }

    return FALSE;
}

BOOL
IsNDNC(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC)
/*++

Routine Description

    Test whether the NC is an NDNC

Arguments:

    pDsInfo -
    pszNC - nc to test for

Return Value:
    
    Boolean

--*/
{
    LONG i = -1;
    
    i = DcDiagGetMemberOfNCList(pszNC,
                                pDsInfo->pNCs, 
                                pDsInfo->cNumNCs);
    if (i>=0) {
        return (DcDiagIsNdnc(pDsInfo, i));
    }

    return FALSE;
}

BOOL
IsConfig(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC)
/*++

Routine Description

    Test whether the NC is a config NC

Arguments:

    pDsInfo -
    pszNC - nc to test for

Return Value:
    
    Boolean

--*/
{
    LONG i = -1;

    i = DcDiagGetMemberOfNCList(pszNC,
                                pDsInfo->pNCs, 
                                pDsInfo->cNumNCs);
    if (i>=0) {
        return (i == pDsInfo->iConfigNc);
    }

    return FALSE;
}

BOOL
IsSchema(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC)
/*++

Routine Description

    Test whether the NC is a schema NC

Arguments:

    pDsInfo -
    pszNC - nc to test for

Return Value:
    
    Boolean

--*/
{
    LONG i = -1;

    i = DcDiagGetMemberOfNCList(pszNC,
                                pDsInfo->pNCs, 
                                pDsInfo->cNumNCs);
    if (i>=0) {
        return (i == pDsInfo->iSchemaNc);
    }

    return FALSE;
}

DWORD 
CheckExistence(
    LDAP *                                   hld,
    LPWSTR                                   pszDN,
    LPWSTR                                   pszServer,
    BOOL *                                   pfExist
    )
/*++

Routine Description

    Test whether the inputted DN exists

Arguments:

    pDsInfo -
    pszNC - nc to test for
    pfExist - OUT

Return Value:
    
    WINERROR

--*/
{

    ULONG err = ERROR_SUCCESS;
    ULONG ldapErr = LDAP_SUCCESS;

    // we should ask for something to check for existence
    LPWSTR  ppszAttr [2] = {
        L"objectGUID",
        NULL 
    };

    LDAPMessage *               pldmResults = NULL;

    ldapErr = ldap_search_ext_sW (hld,
                                  pszDN, 
                                  LDAP_SCOPE_BASE,
                                  L"(objectCategory=*)",
                                  ppszAttr,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0, // return all entries
                                  &pldmResults);

    err = ldapError(hld, ldapErr, pszServer, FALSE);
    
    if (err==ERROR_SUCCESS) {
        // found it.

        *pfExist = TRUE; 
    } else if (err == ERROR_DS_OBJ_NOT_FOUND) {
        // not there.
        *pfExist = FALSE; 
        err=ERROR_SUCCESS;
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] An LDAP operation failed with error %d\n",
                     pszServer,
                     err);
    }

    return err;

}

DWORD
GetDomainNCVersion(
    LDAP *                                   hld,
    LPWSTR                                   pszNC,
    LPWSTR                                   pszServer,
    NC_VERSION *                             pncVer)
/*++

Routine Description

    Get the forest version of the NC: Win2k, or Whistler
        Win2k means that the permissions should be win2k format
        Whistler means the permsissions should be whistler format

Arguments:

    hld - ldap to use to query
    pszConfig - string dn of the NC
    pszServer - server connected to with hld
    pncVer - OUT

Return Value:
    
    WINERROR

--*/
{
    DWORD err = ERROR_SUCCESS;
    BOOL fExist = FALSE;

    LPCWSTR pszDomainUpdates = L"CN=DomainUpdates,CN=System,";
    LPWSTR pszDomainUpdatesCN = malloc(sizeof(WCHAR)*(wcslen(pszDomainUpdates) + wcslen(pszNC) + 1));
    if (pszDomainUpdatesCN==NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    wcscpy(pszDomainUpdatesCN, pszDomainUpdates);
    wcscat(pszDomainUpdatesCN, pszNC);

    err = CheckExistence(hld, pszDomainUpdatesCN, pszServer, &fExist);

    if (err==ERROR_SUCCESS) {
        if (fExist) {
            *pncVer = NC_VERSION_WHISTLER;
        } else {
            *pncVer = NC_VERSION_WIN2K;
        }
    }

    if (pszDomainUpdatesCN) {
        free(pszDomainUpdatesCN);
    }

    return err;
}

DWORD
GetForestNCVersion(
    LDAP *                                   hld,
    LPWSTR                                   pszConfig,
    LPWSTR                                   pszServer,
    NC_VERSION *                             pncVer)
/*++

Routine Description

    Get the forest version of the NC: Win2k, or Whistler
        Win2k means that the permissions should be win2k format
        Whistler means the permsissions should be whistler format

Arguments:

    hld - ldap to use to query
    pszConfig - string dn of the config container
    pszServer - server connected to with hld
    pncVer - OUT

Return Value:
    
    WINERROR

--*/
{
    DWORD err = ERROR_SUCCESS;
    BOOL fExist = FALSE;

    LPCWSTR pszForestUpdates = L"CN=ForestUpdates,";
    LPWSTR pszForestUpdatesCN = malloc(sizeof(WCHAR)*(wcslen(pszForestUpdates) + wcslen(pszConfig) + 1));
    if (pszForestUpdatesCN==NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    wcscpy(pszForestUpdatesCN, pszForestUpdates);
    wcscat(pszForestUpdatesCN, pszConfig);

    err = CheckExistence(hld, pszForestUpdatesCN, pszServer, &fExist);

    if (err==ERROR_SUCCESS) {
        if (fExist) {
            *pncVer = NC_VERSION_WHISTLER;
        } else {
            *pncVer = NC_VERSION_WIN2K;
        }
    }

    if (pszForestUpdatesCN) {
        free(pszForestUpdatesCN);
    }

    return err;
}

DWORD
GetNCVersion(
    PDC_DIAG_DSINFO                          pDsInfo, 
    LDAP *                                   hld, 
    LPWSTR                                   pszNC, 
    NC_TYPE                                  ncType, 
    LPWSTR                                   pszServer,
    NC_VERSION *                             pncVer)
/*++

Routine Description

    Get the version of the NC: Win2k, or Whistler
        Win2k means that the permissions should be win2k format
        Whistler means the permsissions should be whistler format

Arguments:

    pDsInfo -
    hld - ldap to use to query
    pszNC - nc to query for version of
    ncType - version depends on the type of NC
    pszServer - server connected to with hld
    pncVer - OUT

Return Value:
    
    WINERROR

--*/
{

    Assert(pncVer);
    *pncVer = NC_VERSION_UNKNOWN;
    // the nc version is equivalent to what machines are able
    // to hold the nc.  (not to be confused with forest version)
    // a win2k nc is one that only win2k DC's can hold.
    // a whistler nc is one that whistler nc's may hold. (ie adprep has run)

    // for config, schema, and ndnc's - every dc in the forest
    // can replicate these nc's, so the version we're looking for
    // is of the forest.  For domain nc's, we need to look at the nc itself.
    if (ncType==NC_DOMAIN) {
        return GetDomainNCVersion(hld, pszNC, pszServer, pncVer);
    } else if ((ncType==NC_SCHEMA) || (ncType==NC_CONFIG) || (ncType==NC_NDNC)) {
        return GetForestNCVersion(hld, pDsInfo->pszConfigNc, pszServer, pncVer); 
    }

    Assert(!"A new nc type has been added!  Update GetNCVersion!");

    return ERROR_GEN_FAILURE;

}

DWORD
GetNCType(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC,
    NC_TYPE *                                pncType)
/*++

Routine Description

    Return the type of the nc (ie domain, config, schema, ndnc)

Arguments:

    pDsInfo -
    pszNC - nc to get type of
    pncType OUT

Return Value:
    
    WINERROR

--*/
{
    if (IsDomainNC(pDsInfo, pszNC)) {
        *pncType = NC_DOMAIN;
    } else if (IsNDNC(pDsInfo, pszNC)) {
        *pncType = NC_NDNC;
    } else if (IsConfig(pDsInfo, pszNC)) {
        *pncType = NC_CONFIG;
    } else if (IsSchema(pDsInfo, pszNC)) {
        *pncType = NC_SCHEMA;
    } else {
        Assert(!"Another NCType has been added!  GetNCType must be updated!\n");
        return ERROR_INVALID_PARAMETER;
    }

    return ERROR_SUCCESS;
}

DWORD
GetEDCSid(
    PSID * ppSid)
/*++

Routine Description

    Create and return the EDC Sid

Arguments:

    OUT ppSid

Return Value:
    
    WINERROR, ppSid has been allocated and must be freed with FreeSid

--*/
{
    DWORD err = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&siaNtAuthority,
                                  1,
                                  SECURITY_ENTERPRISE_CONTROLLERS_RID, 
                                  0, 0, 0, 0, 0, 0, 0,
                                  ppSid)){
        err = ERROR_INVALID_SID;
    }

    return err;
}

DWORD
GetAdminSid(
    PSID * ppSid)
/*++

Routine Description

    Create and return the Admin Sid

Arguments:

    OUT ppSid

Return Value:
    
    WINERROR, ppSid has been allocated and must be freed with FreeSid

--*/
{
    DWORD err = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&siaNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID, 
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0,
                                  ppSid)){
        err = ERROR_INVALID_SID;
    }

    return err;
}

DWORD
GetDDCSid(
    SID * pNCSid,
    PSID * ppSid
    )
/*++

Routine Description

    Create and return the DDC Sid

Arguments:

    pNCSid - sid of the domain
    OUT ppSid

Return Value:
    
    WINERROR, ppSid has been allocated and must be freed with FreeSid

--*/
{
    // kind of a weird way to do this, but is more continuous with the rest
    // of the Get*Sid functions and enables all to be freed with FreeSid
    DWORD err = ERROR_SUCCESS;
    DWORD cbSid = SECURITY_MAX_SID_SIZE;

    ULONG i = 0;

    BOOL fDomainRid = FALSE;

    ULONG subAuthority[8];

    if (pNCSid->SubAuthorityCount>7) {
        return ERROR_INVALID_SID;
    }

    for (i=0; i < 8; i++) {
        if (pNCSid->SubAuthorityCount>i) {
            subAuthority[i] = pNCSid->SubAuthority[i];
        } else {
            subAuthority[i] = !fDomainRid ? DOMAIN_GROUP_RID_CONTROLLERS : 0;
            fDomainRid = TRUE;
        }
    }

    if (!AllocateAndInitializeSid(&(pNCSid->IdentifierAuthority), 
                                  pNCSid->SubAuthorityCount+1,
                                  subAuthority[0],
                                  subAuthority[1],
                                  subAuthority[2],
                                  subAuthority[3],
                                  subAuthority[4],
                                  subAuthority[5],
                                  subAuthority[6],
                                  subAuthority[7],
                                  ppSid)) {
        err = GetLastError();
    }

    return err;
}

DWORD
GetAccountSid(
    ACCOUNT_TYPE    accountType, 
    PSID            pNCSid, 
    NC_TYPE         ncType,
    PSID *          ppSid)
/*++

Routine Description

    Create and return the Sid requested

Arguments:

    accountType - type of sid to get
    pNCSid - sid of the ignored if ncType!=DOMAIN
    ncType - type of NC
    OUT ppSid

Return Value:
    
    WINERROR, ppSid has been allocated and must be freed with FreeSid

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (accountType==ACCOUNT_EDC) {
        err = GetEDCSid(ppSid);
    } else if (accountType==ACCOUNT_DDC) {
        if (ncType==NC_DOMAIN) {
            err = GetDDCSid(pNCSid, ppSid);
        } else {
            //can't get a ddc sid if we're not in a domain nc
            *ppSid = NULL;
            err = ERROR_SUCCESS;
        }
    } else if (accountType==ACCOUNT_ADMIN) {
        err = GetAdminSid(ppSid);
    } else {
        Assert(!"A new account type has been added!  Please update GetAccountSid!");
        err = ERROR_INVALID_SID;
    }
    if (err!=ERROR_SUCCESS) {
        PrintIndentAdj(1);
        PrintMessage(SEV_ALWAYS,
                     L"%s:  Unable to lookup account SID with error %d\n",
                     ACCOUNT_TYPE_EXT_NAMES[accountType],
                     err);
        PrintMessage(SEV_ALWAYS, L"%s.\n",
                     Win32ErrToString(err));
        PrintIndentAdj(-1);
    }

    return err;
}

LPWSTR
GetAccountString(
    PSID pSid
    )
/*++

Routine Description

    Get a printable account string for the Sid

Arguments:

    pSid - sid of account to return

Return Value:
    
    string or NULL and GetLastError(), returned value must be freed with free()

--*/
{
    ULONG                       ulAccountSize = ACCT_STRING_SZ;
    ULONG                       ulDomainSize = ACCT_STRING_SZ;
    WCHAR                       pszAccount[ACCT_STRING_SZ];
    WCHAR                       pszDomain[ACCT_STRING_SZ];
    SID_NAME_USE                SidType = SidTypeWellKnownGroup;
    LPWSTR                      pszGuidType = NULL;
    LPWSTR                      pszAccountString = NULL;

    if (LookupAccountSidW(NULL,
                          pSid,
                          pszAccount,
                          &ulAccountSize,
                          pszDomain,
                          &ulDomainSize,
                          &SidType)) {
        pszAccountString = malloc((wcslen(pszDomain) + wcslen(pszAccount) + 2) * sizeof(WCHAR));
        if (pszAccountString!=NULL) { 
            wcscpy(pszAccountString, pszDomain);
            wcscat(pszAccountString, L"\\");
            wcscat(pszAccountString, pszAccount);
        }
    }
    
    return pszAccountString;
}

PERMS
GetHasPerms(
    PACL         pNCDacl,
    PSID         pSid
    )
/*++

Routine Description

    Get the permissions set on the dacl for the sid

Arguments:

    pNCDacl - aces for the nc head
    pSid - account sid to look for

Return Value:
    
    PERMS

--*/
{
    ACE_HEADER *                   pTempAce = NULL;
    PSID                           pTempSid = NULL;
    ACCESS_ALLOWED_OBJECT_ACE *    pToCurrAce = NULL;
    INT                            iAce = 0;
    INT                            i=0;

    PERMS permsReturn = RIGHT_NONE;

    if (pSid==NULL) {
        return permsReturn;
    }

    Assert(pNCDacl != NULL);
        
    for(; iAce < pNCDacl->AceCount; iAce++){
        if(GetAce(pNCDacl, iAce, &pTempAce)){

            if(pTempAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE){ 
                ACCESS_ALLOWED_ACE * pAce = (ACCESS_ALLOWED_ACE *) pTempAce;
                if((pAce->Mask & RIGHT_DS_CONTROL_ACCESS) && 
                   IsValidSid(&(pAce->SidStart)) && 
                   EqualSid(pSid, &(pAce->SidStart))) {
                    // we found the account we are looking for, and it has all access
                    permsReturn |= RIGHT_ALL_WHISTLER;
                }
            } else {
                ACCESS_ALLOWED_OBJECT_ACE * pAce = (ACCESS_ALLOWED_OBJECT_ACE *) pTempAce;
                if(pAce->Mask & RIGHT_DS_CONTROL_ACCESS){
                    if(pAce->Flags & ACE_OBJECT_TYPE_PRESENT){
                        GUID * pGuid = (GUID *) &(pAce->ObjectType);

                        if(pAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT){
                            pTempSid = ((PBYTE) pGuid) + sizeof(GUID) + sizeof(GUID);
                        } else {
                            pTempSid = ((PBYTE) pGuid) + sizeof(GUID);
                        }
                        
                        if (IsValidSid(pTempSid) && EqualSid(pSid, pTempSid)) {
                            for (i=0; i<RIGHT_MAX; i++) {
                                if(memcmp(pGuid, &(rgReplRights[i].guidRight), sizeof(GUID)) == 0){      
                                    permsReturn |= rgReplRights[i].maskRight;   
                                }
                            }
                        }
                    }
                }
            }
        } else {
           Assert(!"Malformed ACE?\n"); 
        }
    }

    return permsReturn;
}

PERMS 
GetShouldHavePerms(
    ACCOUNT_TYPE accountType,
    NC_TYPE      ncType,
    NC_VERSION   ncVer
    )
/*++

Routine Description

    Get the repl perms that the account needs to have for the nc type and version

Arguments:

    accountType - what account
    ncType - type of nc
    ncVersion - version of nc

Return Value:
    
    PERMS

--*/
{
    PERMS permRet = -1;
    // for each type and version and account
    // a set of perms must be defined.
    if (ncVer==NC_VERSION_WHISTLER) {
        if ((ncType==NC_CONFIG) || (ncType==NC_SCHEMA) || (ncType==NC_NDNC)) {
            if ((accountType==ACCOUNT_EDC) || (accountType==ACCOUNT_ADMIN)) {
                permRet = RIGHT_ALL_WHISTLER;
            } else {
                permRet = RIGHT_NONE;
            }
        } else if (ncType==NC_DOMAIN) {
            if ((accountType==ACCOUNT_EDC) || (accountType==ACCOUNT_ADMIN)) {
                permRet = RIGHT_ENTERPRISE_WHISTLER;
            } else if (accountType==ACCOUNT_DDC) {
                permRet = RIGHT_DOMAIN_WHISTLER;
            }
        }
    } else if (ncVer==NC_VERSION_WIN2K) {
        // make sure to keep this in a format so that new accounts or nc types don't have to touch this section
        if (ncType==NC_NDNC) {
            Assert(!"Win2K forests shouldn't have NDNCs!\n");
            permRet = -1;
        } else if ((accountType==ACCOUNT_ADMIN) || (accountType==ACCOUNT_EDC)) {
            permRet = RIGHT_ALL_WIN2K;
        } else {
            permRet = RIGHT_NONE;
        }
    } else {
        Assert(!"Another NC_VERION was added - please update GetShouldHavePerms!\n"); 
        permRet = -1;
    }

    return permRet;
}

PERMS
GetPermsMissing(
    ACCOUNT_TYPE accountType,
    PACL         pNCDacl, 
    PSID         pSid, 
    NC_TYPE      ncType, 
    NC_VERSION   ncVer)
/*++

Routine Description

    Get the permissions that the account type is missing

Arguments:

    accountType -
    pNCDacl - dacl of nc head
    pSid - the sid of the account to search for
    nctype - type of nc
    ncver - version of nc

Return Value:
    
    PERMS (those which the account should have, but doesn't)

--*/
{

    // missing perms are what we don't have and should have.
    return ((~GetHasPerms(pNCDacl, pSid) & RIGHT_ALL) & GetShouldHavePerms(accountType, ncType, ncVer));
}

DWORD
GetNCSecInfo(
    LDAP * hld, 
    LPWSTR pszNC, 
    NC_TYPE ncType,
    LPWSTR pszServer,
    PACL * ppNCDacl, 
    PSID * ppNCSid)
/*++

Routine Description

    Get the security info (via ldap) for the NC:  the DACL of the NC head, and the Sid of the domain (if applicable)

Arguments:

    hld - ldap
    pszNC - nc to get info for
    ncType - if it's a domain nc, then get the sid, otherwise ignore
    pszServer - server connected to with hld
    ppNCDacl - out
    ppNCSid - out -domain sid (if nctype==DOMAIN)

Return Value:
    
    WINERROR, ppNCDacl and ppNCSid were alloced with malloc and must be freed

--*/
{
    DWORD err = 0;
    ULONG ldapErr = LDAP_SUCCESS;

    LPWSTR  ppszSecurityAttr [3] = {
        L"nTSecurityDescriptor",
        L"objectSid",
        NULL 
    };

    SECURITY_INFORMATION        seInfo =   DACL_SECURITY_INFORMATION
                                         | GROUP_SECURITY_INFORMATION
                                         | OWNER_SECURITY_INFORMATION;
                          // Don't need  | SACL_SECURITY_INFORMATION;
    BYTE                        berValue[2*sizeof(ULONG)];
    LDAPControlW                seInfoControl = { 
        LDAP_SERVER_SD_FLAGS_OID_W,
        { 5, (PCHAR) berValue }, 
        TRUE 
    };

    PLDAPControlW               serverControls[2] = { &seInfoControl, NULL };
    
    LDAPMessage *               pldmRootResults = NULL;
    LDAPMessage *               pldmEntry;
    PLDAP_BERVAL *              pSDValue = NULL;
    PLDAP_BERVAL *              pSidDomainValue = NULL; 

    SECURITY_DESCRIPTOR *       pSecDesc = NULL;
    BOOLEAN                     DaclPresent = FALSE;
    BOOLEAN                     Defaulted;

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE) (seInfo & 0xF);

    ldapErr = ldap_search_ext_sW (hld,
                                  pszNC, 
                                  LDAP_SCOPE_BASE,
                                  L"(objectCategory=*)",
                                  ppszSecurityAttr,
                                  0,
                                  (PLDAPControlW *)serverControls,
                                  NULL,
                                  NULL,
                                  0, // return all entries
                                  &pldmRootResults);
    err = ldapError(hld, ldapErr, pszServer, TRUE);

    // get the dacl
    if (err == ERROR_SUCCESS) {
        pldmEntry = ldap_first_entry (hld, pldmRootResults);
        Assert(pldmEntry != NULL);

        pSDValue = ldap_get_values_lenW (hld, 
                                         pldmEntry, 
                                         ppszSecurityAttr[0]);
        Assert(pSDValue != NULL);
    }
        
    if((err==ERROR_SUCCESS) && ((pldmEntry == NULL) || (pSDValue == NULL))){ 
        err = ERROR_INVALID_SECURITY_DESCR;
    }

    if (err == ERROR_SUCCESS) {
        pSecDesc = (SECURITY_DESCRIPTOR *) (*pSDValue)->bv_val ;
        Assert( pSecDesc != NULL );
    }
    
    if((err==ERROR_SUCCESS) && (pSecDesc == NULL)){ 
        err = ERROR_INVALID_SECURITY_DESCR;
    } 

    if (err==ERROR_SUCCESS) {
        PACL pTempAcl = NULL;
        err = RtlGetDaclSecurityDescriptor( pSecDesc, 
                                            &DaclPresent, 
                                            &pTempAcl, 
                                            &Defaulted );
        if(err != ERROR_SUCCESS || !DaclPresent || !pTempAcl) { 
            PrintMessage(SEV_ALWAYS, 
                      L"Fatal Error: Cannot retrieve Security Descriptor Dacl\n");  
        }
        else {
            *ppNCDacl = malloc(pTempAcl->AclSize);
            memcpy(*ppNCDacl, pTempAcl, pTempAcl->AclSize);
        }
    }


    // get the sid

    if (ncType==NC_DOMAIN) {
        if (err==ERROR_SUCCESS) {

            pSidDomainValue = ldap_get_values_lenW (hld, pldmEntry, 
                                                    ppszSecurityAttr[1]);
            Assert(pSidDomainValue != NULL);
        }

        if((err==ERROR_SUCCESS) && (pSidDomainValue == NULL)){
            err = ERROR_INVALID_SID;
        }

        if (err==ERROR_SUCCESS) {
            *ppNCSid = malloc((*pSidDomainValue)->bv_len); 
            memcpy(*ppNCSid, (*pSidDomainValue)->bv_val,(*pSidDomainValue)->bv_len);
            Assert( *ppNCSid != NULL );
        }

        if((err==ERROR_SUCCESS) && ((*ppNCSid == NULL) || !IsValidSid(*ppNCSid))) {
            err = ERROR_INVALID_SID;
        } 

        if (err!=ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS, 
                         L"Fatal Error: Cannot retrieve SID\n"); 
        }
    }

    if (pldmRootResults != NULL)  ldap_msgfree (pldmRootResults);
    if (pSDValue != NULL)         ldap_value_free_len(pSDValue);
    if (pSidDomainValue !=NULL)   ldap_value_free_len(pSidDomainValue);

    return err;
}

DWORD
PrintPermsMissing(
    ACCOUNT_TYPE accountType, 
    PSID pSid, 
    LPWSTR pszNC,
    PERMS permsMissing
    )
/*++

Routine Description:

    Print the perms that the account is missing

Arguments:

   accountType - type of account
   pSid - account which is missing perms
   pszNC - nc we're looking at
   permsMissing - PERMS that the account should have and doesn't

Return Value:

    WINERROR - ERROR_SUCCESS if has all perms it should have, and ERROR_DS_DRA_ACCESS_DENIED otherwise

--*/
{
    // for each perm set in perms Missing, output the missing stuff
    LPWSTR pszAccountString = NULL;
    ULONG i = 0;

    if (permsMissing!=0) { 
        pszAccountString = GetAccountString(pSid);
        PrintMessage(SEV_ALWAYS, L"Error %s doesn't have \n",
                     pszAccountString ? pszAccountString : ACCOUNT_TYPE_EXT_NAMES[accountType]);

        PrintIndentAdj(1);

        for (i=0; i<RIGHT_MAX; i++) {
            if (permsMissing & (rgReplRights[i].maskRight)) {
                PrintMessage(SEV_ALWAYS, L"%s\n", rgReplRights[i].pszExtStringRight);
            }
        }

        PrintIndentAdj(-1);
        PrintMessage(SEV_ALWAYS, 
                     L"access rights for the naming context:\n");
        PrintMessage(SEV_ALWAYS, L"%s\n", pszNC); 
        if (pszAccountString) {
            free(pszAccountString);
            pszAccountString=NULL;
        }
        return ERROR_DS_DRA_ACCESS_DENIED;
    }
    return ERROR_SUCCESS;
}

DWORD 
CNHSD_CheckOneNc(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   ULONG                               ulCurrTargetServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   LPWSTR                              pszNC,
    IN   BOOL                                bIsMasterNc
    )
/*++

Routine Description:

    This helper function of CheckNcHeadSecurityDescriptors takes a single 
    Naming Context (pszNC) to check for the appropriate security access.

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying 
        everything about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server
        is being tested.
    gpCreds - The command line credentials if any that were passed in.
    pszNC - The Naming Context to test.

Return Value:

    NO_ERROR, if the NC checked out OK, with the appropriate rights for the 
    appropriate people a Win32 error of some kind otherwise, indicating that
    someone doesn't have rights.

--*/
{
    DWORD err = ERROR_SUCCESS;
    DWORD retErr = ERROR_SUCCESS;
    LDAP * hld = NULL;

    PACL pNCDacl = NULL;
    PSID pNCSid = NULL;

    NC_TYPE ncType;
    NC_VERSION ncVer;
    
    ULONG i = 0;
    PSID pSid = NULL;
    PERMS permsMissing;

    PrintMessage(SEV_VERBOSE, L"* Security Permissions Check for\n");
    PrintMessage(SEV_VERBOSE, L"  %s\n", pszNC);

    // get an ldap binding
    err = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                               gpCreds, 
                               !bIsMasterNc, 
                               &hld);


    if (err==ERROR_SUCCESS) {
        err = GetNCType(pDsInfo, pszNC, &ncType); 
    }

    if (err==ERROR_SUCCESS) {
        err = GetNCVersion(pDsInfo, hld, pszNC, ncType, pDsInfo->pServers[ulCurrTargetServer].pszName, &ncVer);
    }

    if (err==ERROR_SUCCESS) {
        PrintIndentAdj(1);
        PrintMessage(SEV_VERBOSE, L"(%s,%s)\n", NC_TYPE_EXT_NAMES[ncType], NC_VERSION_EXT_NAMES[ncVer]);
        PrintIndentAdj(-1);
    }

    if (err==ERROR_SUCCESS) {
        err = GetNCSecInfo(hld, pszNC, ncType, pDsInfo->pServers[ulCurrTargetServer].pszName, &pNCDacl, &pNCSid);
    }

    if (err==ERROR_SUCCESS) {
        for (i=0; i < ACCOUNT_MAX_TYPE; i++) {
            pSid = NULL;
            permsMissing = RIGHT_NONE;

            err = GetAccountSid(i, pNCSid, ncType, &pSid);

            if (err==ERROR_SUCCESS) {
                permsMissing = GetPermsMissing(i, pNCDacl, pSid, ncType, ncVer);
            }

            if (err==ERROR_SUCCESS) {
                err = PrintPermsMissing(i, pSid, pszNC, permsMissing);
            }

            retErr = err ? err : retErr;
            err = ERROR_SUCCESS;

            if (pSid) {
                FreeSid(pSid);
                pSid = NULL;
            }

        }
    }

    if (pNCSid) {
        free(pNCSid);
    }

    retErr = retErr ? retErr : err;

    return retErr;
}

DWORD
ReplCheckNcHeadSecurityDescriptorsMain (
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test will 
    determine if the Security Descriptors associated with all the Naming 
    Context heads for that server have the right accounts with the right 
    access permissions to make sure replication happens.  Helper functions 
    of this function all begin with "CNHSD_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying
        everything about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server
        is being tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all NCs checked out.
    A Win32 Error if any NC failed to check out.

--*/
{
    DWORD                     dwRet = ERROR_SUCCESS, dwErr = ERROR_SUCCESS;
    ULONG                     i;
    BOOL                      bIsMasterNC;

    if(pDsInfo->pszNC != NULL){
        bIsMasterNC = DcDiagHasNC(pDsInfo->pszNC,
                                  &(pDsInfo->pServers[ulCurrTargetServer]), 
                                  TRUE, FALSE);
        dwRet = CNHSD_CheckOneNc(pDsInfo, ulCurrTargetServer, gpCreds, 
                                 pDsInfo->pszNC, 
                                 bIsMasterNC);
        return(dwRet);
    }
        
    // First Check Master NCs
    if(pDsInfo->pServers[ulCurrTargetServer].ppszMasterNCs != NULL){
        for(i = 0; pDsInfo->pServers[ulCurrTargetServer].ppszMasterNCs[i] != NULL; i++){
            dwRet = CNHSD_CheckOneNc(
                pDsInfo, 
                ulCurrTargetServer, 
                gpCreds, 
                pDsInfo->pServers[ulCurrTargetServer].ppszMasterNCs[i],
                TRUE);
            if(dwRet != ERROR_SUCCESS){
                dwErr = dwRet;
            }
        }
    }

    // Then Check Partial NCs
    if(pDsInfo->pServers[ulCurrTargetServer].ppszPartialNCs != NULL){
        for(i = 0; pDsInfo->pServers[ulCurrTargetServer].ppszPartialNCs[i] != NULL; i++){
            dwRet = CNHSD_CheckOneNc(
                pDsInfo, 
                ulCurrTargetServer, 
                gpCreds,
                pDsInfo->pServers[ulCurrTargetServer].ppszPartialNCs[i],
                FALSE);
            if(dwRet != ERROR_SUCCESS){
                dwErr = dwRet;
            }
        }
    }

    return dwErr;
}





// ===========================================================================
//
// CheckLogonPriviledges() function & helpers.
// 
// This test will basically query the DC as to whether the appropriate 
//    accounts have the Network Logon Right.
//
// ===========================================================================
// 

DWORD
CLP_GetTargetAccounts(
    TARGET_ACCOUNT_STRUCT **            ppTargetAccounts,
    ULONG *                             pulTargetAccounts
    )
/*++

Routine Description:

    This helper function of CheckLogonPriviledges() gets the accounts and then 
    returns them.

Arguments:

    ppTargetAccounts - ptr to array of TARGET_ACCOUNT_STRUCTS ... filled in 
        by function.  
    pulTargetAccounts - ptr to int for the number of TARGET_ACCOUNT_STRUCTS
        filled in.

Return Value:

    returns a GetLastError() Win32 error if the function failes, NO_ERROR 
    otherwise.

--*/
{
    SID_IDENTIFIER_AUTHORITY        siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY        siaWorldSidAuthority = 
                                              SECURITY_WORLD_SID_AUTHORITY;
    TARGET_ACCOUNT_STRUCT *         pTargetAccounts = NULL;
    ULONG                           ulTarget = 0;
    ULONG                           ulTargetAccounts = 3;

    *pulTargetAccounts = 0;
    *ppTargetAccounts = NULL;

    pTargetAccounts = LocalAlloc(LMEM_FIXED, 
                       sizeof(TARGET_ACCOUNT_STRUCT) * ulTargetAccounts);
    if(pTargetAccounts == NULL){
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset(pTargetAccounts, 0, 
           sizeof(TARGET_ACCOUNT_STRUCT) * ulTargetAccounts);
    
    if (!AllocateAndInitializeSid(&siaNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0, 
                                  &pTargetAccounts[0].pSid)){
        return(GetLastError());
    }
    
    // This I believe is the important one that allows replication
    if (!AllocateAndInitializeSid(&siaNtAuthority, 
                                  1,
                                  SECURITY_AUTHENTICATED_USER_RID,
                                  0, 0, 0, 0, 0, 0, 0, 
                                  &pTargetAccounts[1].pSid)){
        return(GetLastError());
    }
    if (!AllocateAndInitializeSid(&siaWorldSidAuthority,
                                  1,
                                  SECURITY_WORLD_RID, 
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pTargetAccounts[2].pSid)){
        return(GetLastError());
    }

    *pulTargetAccounts = ulTargetAccounts;
    *ppTargetAccounts = pTargetAccounts;
    return(ERROR_SUCCESS);
}

// security.c helper functions
VOID
FreeTargetAccounts(
    IN   TARGET_ACCOUNT_STRUCT *             pTargetAccounts,
    IN   ULONG                               ulTargetAccounts
    )
/*++

Routine Description:

    This is the parallel to XXX_GetTargetAccounts().  Goes through and frees 
    all the pSids, and then frees the array.

Arguments:

    pTargetAccounts - Array of TARGET_ACCOUNT_STRUCTs to free.
    ulTargetAccounts - number of structs in array.

--*/
{
    ULONG                                  ulTarget = 0;

    if(pTargetAccounts != NULL){
        for(ulTarget = 0; ulTarget < ulTargetAccounts; ulTarget++){
            if(pTargetAccounts[ulTarget].pSid != NULL){
                FreeSid(pTargetAccounts[ulTarget].pSid);
            }
        }
        LocalFree(pTargetAccounts);
    }
}

VOID
InitLsaString(
    OUT  PLSA_UNICODE_STRING pLsaString,
    IN   LPWSTR              pszString
    )
/*++

Routine Description:

    InitLsaString, is something that takes a normal unicode string null 
    terminated string, and inits a special unicode structured string.  This 
    function is basically reporduced all over the NT source.

Arguments:

    pLsaString - Struct version of unicode strings to be initialized
    pszString - String to use to init pLsaString.

--*/
{
    DWORD dwStringLength;

    if (pszString == NULL) 
    {
        pLsaString->Buffer = NULL;
        pLsaString->Length = 0;
        pLsaString->MaximumLength = 0;
        return;
    }

    dwStringLength = wcslen(pszString);
    pLsaString->Buffer = pszString;
    pLsaString->Length = (USHORT) dwStringLength * sizeof(WCHAR);
    pLsaString->MaximumLength=(USHORT)(dwStringLength+1) * sizeof(WCHAR);
}

DWORD 
ReplCheckLogonPrivilegesMain (
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test will determine
    whether certain important user accounts have Net Logon privileges.  If 
    they don't replication may be hampered or stopped.  Helper functions of 
    this function all begin with "CLP_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying 
        everything about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server
        is being tested.
    gpCreds - The command line credentials if any that were passed in.

Return Value:

    NO_ERROR, if all expected accounts had net logon privileges.
    A Win32 Error if any expected account didn't have net logon privileges.

--*/
{
    DWORD                               dwRet = ERROR_SUCCESS; 
    NETRESOURCE                         NetResource;
    LSA_HANDLE                          hPolicyHandle = NULL;
    DWORD                               DesiredAccess = 
                                           POLICY_VIEW_LOCAL_INFORMATION;
    LSA_OBJECT_ATTRIBUTES               ObjectAttributes;
    LSA_UNICODE_STRING                  sLsaServerString;
    LSA_UNICODE_STRING                  sLsaRightsString;
    LSA_ENUMERATION_INFORMATION *       pAccountsWithLogonRight = NULL;
    ULONG                               ulNumAccounts = 0; 
    ULONG                               ulTargetAccounts = 0;
    ULONG                               ulTarget, ulCurr;
    TARGET_ACCOUNT_STRUCT *             pTargetAccounts = NULL;
    LPWSTR                              pszNetUseServer = NULL;
    LPWSTR                              pszNetUseUser = NULL;
    LPWSTR                              pszNetUsePassword = NULL;
    ULONG                               iTemp, i;
    UNICODE_STRING                      TempUnicodeString;
    ULONG                               ulAccountSize = ACCT_STRING_SZ;
    ULONG                               ulDomainSize = ACCT_STRING_SZ;
    WCHAR                               pszAccount[ACCT_STRING_SZ];
    WCHAR                               pszDomain[ACCT_STRING_SZ];
    SID_NAME_USE                        SidType = SidTypeWellKnownGroup;
    BOOL                                bConnected = FALSE;
    DWORD                               dwErr = ERROR_SUCCESS;
    BOOL                                bFound = FALSE;

    __try{

        PrintMessage(SEV_VERBOSE, L"* Network Logons Privileges Check\n");
            
        // INIT ---------------------------------------------------------------
        // Always initialize the object attributes to all zeroes.
        InitializeObjectAttributes(&ObjectAttributes,NULL,0,NULL,NULL);

        // Initialize various strings for the Lsa Services and for 
        //     WNetAddConnection2()
        InitLsaString( &sLsaServerString, 
                       pDsInfo->pServers[ulCurrTargetServer].pszName );
        InitLsaString( &sLsaRightsString, SE_NETWORK_LOGON_NAME );

        if(gpCreds != NULL 
           && gpCreds->User != NULL 
           && gpCreds->Password != NULL 
           && gpCreds->Domain != NULL){ 
            // only need 2 for NULL, and an extra just in case. 
            iTemp = wcslen(gpCreds->Domain) + wcslen(gpCreds->User) + 4;
            pszNetUseUser = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
            if(pszNetUseUser == NULL){
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            wcscpy(pszNetUseUser, gpCreds->Domain);
            wcscat(pszNetUseUser, L"\\");
            wcscat(pszNetUseUser, gpCreds->User);
            pszNetUsePassword = gpCreds->Password;
        } // end if creds, else assume default creds ... 
        //      pszNetUseUser = NULL; pszNetUsePassword = NULL;

        // "\\\\" + "\\ipc$"
        iTemp = wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName) + 10; 
        pszNetUseServer = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
        if(pszNetUseServer == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        wcscpy(pszNetUseServer, L"\\\\");
        wcscat(pszNetUseServer, pDsInfo->pServers[ulCurrTargetServer].pszName);
        wcscat(pszNetUseServer, L"\\ipc$");

        // Initialize NetResource structure for WNetAddConnection2()
        NetResource.dwType = RESOURCETYPE_ANY;
        NetResource.lpLocalName = NULL;
        NetResource.lpRemoteName = pszNetUseServer;
        NetResource.lpProvider = NULL;


        // CONNECT & QUERY ---------------------------------------------------
        //net use \\brettsh-posh\ipc$ /u:brettsh-fsmo\administrator ""
        dwRet = WNetAddConnection2(&NetResource, // connection details
                                   pszNetUsePassword, // points to password
                                   pszNetUseUser, // points to user name string
                                   0); // set of bit flags that specify 
        if(dwRet != NO_ERROR){
            if(dwRet == ERROR_SESSION_CREDENTIAL_CONFLICT){
                PrintMessage(SEV_ALWAYS, 
                   L"* You must make sure there are no existing net use connections,\n");
                PrintMessage(SEV_ALWAYS, 
                        L"  you can use \"net use /d %s\" or \"net use /d\n", 
                             pszNetUseServer);
                PrintMessage(SEV_ALWAYS, 
                             L"  \\\\<machine-name>\\<share-name>\"\n");
            }
            __leave;
        } else bConnected = TRUE;


        // Attempt to open the policy.
        dwRet = LsaOpenPolicy(&sLsaServerString,
                              &ObjectAttributes,
                              DesiredAccess,
                              &hPolicyHandle); 
        if(dwRet != NO_ERROR) __leave;
        Assert(hPolicyHandle != NULL);

        dwRet = LsaEnumerateAccountsWithUserRight( hPolicyHandle,
                                                   &sLsaRightsString,
                                                   &pAccountsWithLogonRight,
                                                   &ulNumAccounts);
        if(dwRet != NO_ERROR) __leave;
        Assert(pAccountsWithLogonRight != NULL);

        dwRet = CLP_GetTargetAccounts(&pTargetAccounts, &ulTargetAccounts);
        if(dwRet != ERROR_SUCCESS) __leave;
     
        // CHECKING FOR LOGON RIGHTS -----------------------------------------
        for(ulTarget = 0; ulTarget < ulTargetAccounts; ulTarget++){

            for(ulCurr = 0; ulCurr < ulNumAccounts && !pTargetAccounts[ulTarget].bFound; ulCurr++){
                if( IsValidSid(pTargetAccounts[ulTarget].pSid) &&
                    IsValidSid(pAccountsWithLogonRight[ulCurr].Sid) &&
                    EqualSid(pTargetAccounts[ulTarget].pSid, 
                             pAccountsWithLogonRight[ulCurr].Sid) ){
                    // Sids are equal
                    bFound = TRUE;
                    break;
                }
            }
        }
        if(!bFound){
            dwRet = LookupAccountSid(NULL,
                                     pTargetAccounts[0].pSid,
                                     pszAccount,
                                     &ulAccountSize,
                                     pszDomain,
                                     &ulDomainSize,
                                     &SidType);
            PrintMessage(SEV_NORMAL, 
                L"* Warning %s\\%s did not have the \"Access this computer\n",
                         pszDomain, pszAccount);
            PrintMessage(SEV_NORMAL, L"*   from network\" right.\n");
            dwErr = ERROR_INVALID_ACCESS;
        }
        

    } __finally {
        // CLEAN UP ----------------------------------------------------------
        if(hPolicyHandle != NULL)           LsaClose(hPolicyHandle);
        if(bConnected)                      WNetCancelConnection2(pszNetUseServer, 0, FALSE);
        if (pszNetUseServer != NULL)        LocalFree(pszNetUseServer);
        if(pszNetUseUser != NULL)           LocalFree(pszNetUseUser);
        if(pAccountsWithLogonRight != NULL) LsaFreeMemory(pAccountsWithLogonRight);
        FreeTargetAccounts(pTargetAccounts, ulTargetAccounts);

    }

    // ERROR HANDLING --------------------------------------------------------

    switch(dwRet){
    case ERROR_SUCCESS:
    case ERROR_SESSION_CREDENTIAL_CONFLICT: 
        // Took care of it earlier, no need to print out.
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        PrintMessage(SEV_ALWAYS, 
                 L"Fatal Error: Not enough memory to complete operation.\n");
        break;
    case ERROR_ALREADY_ASSIGNED:
        PrintMessage(SEV_ALWAYS, 
                     L"Fatal Error: The network resource is already in use\n");
        break;
    case STATUS_ACCESS_DENIED:
    case ERROR_INVALID_PASSWORD:
    case ERROR_LOGON_FAILURE:
        // This comes from the LsaOpenPolicy or 
        //    LsaEnumerateAccountsWithUserRight or 
        //    from WNetAddConnection2
        PrintMessage(SEV_ALWAYS, 
                     L"User credentials does not have permission to perform this operation.\n");
        PrintMessage(SEV_ALWAYS, 
                     L"The account used for this test must have network logon privileges\n");
        PrintMessage(SEV_ALWAYS, 
                     L"for the target machine's domain.\n");
        break;
    case STATUS_NO_MORE_ENTRIES:
        // This comes from LsaEnumerateAccountsWithUserRight
    default:
        PrintMessage(SEV_ALWAYS,                                               
                     L"[%s] An net use or LsaPolicy operation failed with error %d, %s.\n", 
                     pDsInfo->pServers[ulCurrTargetServer].pszName,            
                     dwRet,                                              
                     Win32ErrToString(dwRet));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwRet);
        break;
    }

    if(dwErr == ERROR_SUCCESS)
        return(dwRet);
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\partitions.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    intersite.c

ABSTRACT:

    Contains test to check the health of partitions (internally more commonly
    referred to as Naming Contexts or NCs).

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:


NOTES:

    This primarily checks the health of Application Directory Partitions
    (internally: Non-Domain Naming Contexts or NDNCs) as opposed to the other
    partitions such as Config/Schema or Domain Directory Partitions.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>
#include <attids.h>
#include <windns.h>
//#include <mdglobal.h>

#include "dcdiag.h"
#include "repl.h"
#include "list.h"
#include "utils.h"
#include "ldaputil.h"
#include "ndnc.h"

VOID
DcDiagPrintCrError(
    DWORD                   dwCrInfoRet,
    DWORD                   dwLdapError,
    LPWSTR                  pszNc,
    LPWSTR                  pszCr
    )
/*++

Description:

    This will hopefully print out a user friendly comment about why
    this paticular call to DcDiagGetCrossRefInfo() failed.

Parameters:

    dwCrInfoRet - one of the CRINFO_RETURN_* constants specified in cache.h
    dwLdapError - LDAP error if applicable.

--*/
{
    PrintIndentAdj(1);

    if(pszCr){
        PrintMsg(SEV_NORMAL, DCDIAG_NC_CR_HEADER, pszNc, pszCr);
    } else {
        PrintMsg(SEV_NORMAL, DCDIAG_NC_CR_HEADER_NO_CR, pszNc);
    }

    PrintIndentAdj(1);
    
    switch (dwCrInfoRet) {
    case CRINFO_RETURN_OUT_OF_SCOPE:
        PrintMsg(SEV_NORMAL, DCDIAG_ERR_CRINFO_RETURN_OUT_OF_SCOPE);
        break;
    case CRINFO_RETURN_LDAP_ERROR:
        PrintMsg(SEV_NORMAL, DCDIAG_ERR_CRINFO_RETURN_LDAP_ERROR, dwLdapError);
        break;
    case CRINFO_RETURN_FIRST_UNDEFINED:
        // Actually this is fine. Don't print.
        break;
    case CRINFO_RETURN_NO_CROSS_REF:
        // Actually this is fine. Don't print.
        break;

        // Not really errors.
    case CRINFO_RETURN_NEED_TO_RETRIEVE:
    case CRINFO_RETURN_BAD_PROGRAMMER:
    case CRINFO_RETURN_SUCCESS:
    default:
        PrintMsg(SEV_NORMAL, DCDIAG_ERR_INTERNAL_ERROR);
        Assert(!"Programmer should've handled these!");
        break;
    }

    PrintIndentAdj(-2);
}

BOOL
IsReplicaInCrList(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iServer,
    PDC_DIAG_CRINFO                     pCrInfo
    )
{
    LONG             iReplica;

    if (pCrInfo->cReplicas == -1) {
        Assert(!"Why are we getting this section wasn't initialized!");
        return(FALSE);
    }

    // Check the replica list in the CR
    for (iReplica = 0; iReplica < pCrInfo->cReplicas; iReplica++) {
        if ( DcDiagEqualDNs(pDsInfo->pServers[iServer].pszDn,
                            pCrInfo->aszReplicas[iReplica]) ) {
            // This server is indeed in the replica set.
            return(TRUE);
        }
    }

    // Not found.
    return(FALSE);
}

                                                         
DWORD
VerifyInstantiatedReplicas(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Description:

    This test checks that all the replicas of NCs this server should have
    are present.
    
Parameters:

    pDsInfo - the pDsInfo structure, basically the mini-enterprise variable.
    iServer - the targeted server index in pDsInfo->pServers[]
    gpCreds - the users credentials

Return Value:

    returns a Win 32 error.

--*/
{
    ULONG         iNc, iCr, iServerNc;
    DWORD         dwRet, dwErr, dwFlags;
    DWORD         dwRetErr = ERROR_SUCCESS;
    BOOL          bSingleServer;

    //
    // Setup flags for retrieving replica set
    //
    bSingleServer = !((pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE)
                      || (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE));
    dwFlags = CRINFO_RETRIEVE_IF_NEC;
    if (bSingleServer){
        dwFlags |= CRINFO_SOURCE_HOME;
    } else {
        dwFlags |= CRINFO_SOURCE_FSMO;
    }
    dwFlags |= CRINFO_DATA_BASIC | CRINFO_DATA_REPLICAS;

    //
    // Get the namingContexts this server hosts locally
    //

    //
    // Try each NC
    //
    for (iNc = 0; iNc < pDsInfo->cNumNCs; iNc++) {
        
        if (!DcDiagIsNdnc(pDsInfo, iNc)) {
            // This is not an NDNC, just skip it.
            continue;
        }

        //
        // Retrieve the replicas from the cross-ref
        //
        dwRet = DcDiagGetCrossRefInfo(pDsInfo, iNc, dwFlags, &iCr, &dwErr);
        if(dwRet == CRINFO_RETURN_NO_CROSS_REF){       
            // Success everything is fine here.
            continue;
        } else if (dwRet) {
            DcDiagPrintCrError(dwRet, dwErr, pDsInfo->pNCs[iNc].pszDn,
                               pDsInfo->pNCs[iNc].aCrInfo[0].pszDn);
            dwRetErr = dwErr ? dwErr : ERROR_NOT_ENOUGH_MEMORY;
            continue;
        }

        //
        // OK, we're going to kind of do the check backwards for efficiency, but
        // basically what we're trying to obtain, is if this is an NC that is 
        // not instantiated on this DC, and this server is listed in the replica
        // set (msDS-NC-Replica-Locations) on the cross-ref.
        //
        for (iServerNc = 0; pDsInfo->pServers[iServer].ppszMasterNCs[iServerNc]; iServerNc++) {
            if ( DcDiagEqualDNs(pDsInfo->pNCs[iNc].pszDn,
                                pDsInfo->pServers[iServer].ppszMasterNCs[iServerNc]) ) {
                // Since this NC is locally instantiated, we don't need to check if
                // it's in the replica set.

                if (pDsInfo->pNCs[iNc].aCrInfo[iCr].cReplicas == 0) {
                    // Code.Improvement this may also some day check if we've got an NC 
                    // present in our namingContexts attribute on the rootDSE, that is not
                    // represented on the cross-refs msDS-NC-Replica-Locations attribute.
                    // This could be the case where we've orphaned the NDNC on
                    // this server.  This may be more appropriate for it's own test though,
                    // because this is a more critical error, and this test is not run
                    // by default. 
                }
                break;
            }
        }
        if (pDsInfo->pServers[iServer].ppszMasterNCs[iServerNc] != NULL) {
            continue;
        }
        
        if ( IsReplicaInCrList(pDsInfo, iServer, &(pDsInfo->pNCs[iNc].aCrInfo[iCr])) ) {

            PrintMsg(SEV_NORMAL, DCDIAG_REPLICA_NOT_VERIFIED, pDsInfo->pNCs[iNc].pszDn);
            dwRetErr = ERROR_DS_DRA_GENERIC;

        }
    }

    return(dwRetErr);
}
    

// Function and list of characters taken from util\rendom\renutil.cxx
WCHAR InvalidDownLevelChars[] = TEXT("\"/\\[]:|<>+=;?,*")
                                TEXT("\001\002\003\004\005\006\007")
                                TEXT("\010\011\012\013\014\015\016\017")
                                TEXT("\020\021\022\023\024\025\026\027")
                                TEXT("\030\031\032\033\034\035\036\037");
ValidateNetbiosName(
    IN  PWSTR Name,
    IN  ULONG Length
    )

/*++

Routine Description:

    Taken from util\rendom\renutil.cxx

Arguments:

    Name    - pointer to zero terminated wide-character netbios name
    Length  - of Name in characters, excluding zero-terminator

Return Value:

    BOOLEAN
        TRUE    Name is valid netbios name
        FALSE   Name is not valid netbios name

--*/

{

    if (1==DnsValidateName_W(Name,DnsNameHostnameFull))
    {
        return(FALSE);
    }

    //
    // Fall down to netbios name validation
    //

    if (Length > MAX_COMPUTERNAME_LENGTH || Length < 1) {
        return FALSE;
    }

    //
    // Don't allow leading or trailing blanks in the computername.
    //

    if ( Name[0] == ' ' || Name[Length-1] == ' ' ) {
        return(FALSE);
    }

    return (BOOLEAN)((ULONG)wcscspn(Name, InvalidDownLevelChars) == Length);
}


DWORD
ValidateCrossRefTest(
    PDC_DIAG_DSINFO		                pDsInfo,
    ULONG                               iNc, // Target NC
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Description:

    This test validates a cross-ref's various attributes. 
    
    Used to be the Dead Cross Ref Test ---
    This tests looks for NDNCs that have failed to be created, but
    did manage to get thier cross-ref created.  These dead cross-refs
    can be cleaned out.

Parameters:

    pDsInfo - the pDsInfo structure, basically the mini-enterprise variable.
    iNc - the targeted NC index in pDsInfo->pNCs[]
    gpCreds - the users credentials

Return Value:

    returns a Win 32 error.

--*/
{
#define ONE_SECOND ((LONGLONG) (10 * 1000 * 1000L))
#define ONE_MINUTE (60 * ONE_SECOND)
#define ONE_HOUR   (60 * ONE_MINUTE)
#define ONE_DAY    (24 * ONE_HOUR)
    PDC_DIAG_CRINFO pCrInfo;
    WCHAR *     pszDnsDn = NULL;
    BOOL        bSingleServer;
    BOOL        bMangled;
    MANGLE_FOR  eMangle;
    DWORD       dwRet = ERROR_SUCCESS;
    DWORD       dwError;
    DWORD       dwFlags;
    PDSNAME     pdnNcName = NULL;
    WCHAR       pszRdnValue[MAX_RDN_SIZE+1];
    ULONG       cbRdnLen;
    DWORD       dwRdnType = 0;
    LONG        iCr;

    //
    // First, retrieve all cross-ref information.
    //
    bSingleServer = !((pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE)
                      || (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE));

    dwFlags = CRINFO_RETRIEVE_IF_NEC;
    if (bSingleServer){
        dwFlags |= CRINFO_SOURCE_HOME;
    } else {
        dwFlags |= CRINFO_SOURCE_AUTHORITATIVE;
    }
    dwFlags |= CRINFO_DATA_BASIC | CRINFO_DATA_EXTENDED | CRINFO_DATA_REPLICAS;

    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNc,
                                  dwFlags,
                                  &iCr,
                                  &dwError);

    if(dwRet == CRINFO_RETURN_FIRST_UNDEFINED
       || dwRet == CRINFO_RETURN_NO_CROSS_REF){       
        // Success everything is fine here.
        return(0);
    } else if (dwRet) {
        DcDiagPrintCrError(dwRet, dwError, pDsInfo->pNCs[iNc].pszDn,
                           pDsInfo->pNCs[iNc].aCrInfo[0].pszDn);
        return(dwRet);
    }

    // for ease of coding.
    pCrInfo = &(pDsInfo->pNCs[iNc].aCrInfo[iCr]);

    //
    // Second, run some common cross-ref validation tests.
    //

    // Make sure the pdnNcName
    if (pCrInfo->pdnNcName == NULL) {
        Assert(!"Unexpected condition.");
        return(ERROR_INTERNAL_ERROR);
    }

    // Check for mangledness.
    bMangled = DcDiagIsStringDnMangled(pCrInfo->pdnNcName->StringName, &eMangle);
    if (bMangled) {
        // Uh-oh!
        if (eMangle == MANGLE_OBJECT_RDN_FOR_DELETION ||
            eMangle == MANGLE_PHANTOM_RDN_FOR_DELETION) {

            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_DEL_MANGLED_NC_NAME,
                     pCrInfo->pdnNcName->StringName, pCrInfo->pszDn);
        
        } else if (eMangle == MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT ||
                   eMangle == MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT) {

            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_CNF_MANGLED_NC_NAME,
                     pCrInfo->pdnNcName->StringName, pCrInfo->pszDn);

        }
    }

    // Check if it's has a top RDN component type of DC= that
    // it's a good convertible DNS name type DN.
    dwRet = GetRDNInfoExternal(pCrInfo->pdnNcName, pszRdnValue, &cbRdnLen, &dwRdnType);
    if (dwRdnType == ATT_DOMAIN_COMPONENT) {

        dwRet = GetDnsFromDn(pCrInfo->pdnNcName->StringName, &pszDnsDn);
        if (dwRet || pszDnsDn == NULL) {
            Assert(dwRet && pszDnsDn == NULL);
            return(dwRet);
        }

        if (_wcsicmp(pszDnsDn, pCrInfo->pszDnsRoot)) {

            PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_BAD_DNS_ROOT_ATTR,
                     pCrInfo->pdnNcName->StringName, pCrInfo->pszDn, 
                     pCrInfo->pszDnsRoot, pszDnsDn);

        }

        LocalFree(pszDnsDn);

    }

    if (fNullUuid(&(pCrInfo->pdnNcName->Guid)) &&
        fIsOldCrossRef(pCrInfo, (2 * ONE_DAY))) {

        PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_NULL_GUID,
                 pCrInfo->pdnNcName->StringName, pCrInfo->pszDn);

    }

    //
    // Third, run domain/NDNC specific cross-ref validation tests.
    //
    if(!DcDiagIsNdnc(pDsInfo, iNc)
       && DcDiagGetCrSystemFlags(pDsInfo, iNc) != 0
       && DcDiagGetCrEnabled(pDsInfo, iNc)){
        
        // If we've got a Domain or Config/Schema cross-refs.

        if (!(DcDiagGetCrSystemFlags(pDsInfo, iNc) & FLAG_CR_NTDS_DOMAIN)) {
            // Config/Schema ...
            ; // we're fine

        } else {

            if (pCrInfo->pszNetBiosName == NULL ||
                ValidateNetbiosName(pCrInfo->pszNetBiosName, 
                                    wcslen(pCrInfo->pszNetBiosName)+1) ){

                PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_BAD_NETBIOSNAME_ATTR,
                         pCrInfo->pdnNcName->StringName, pCrInfo->pszDn, 
                         pCrInfo->pszNetBiosName);

            }

            if (pCrInfo->pdnNcName->SidLen == 0 &&
                fIsOldCrossRef(pCrInfo, (2 * ONE_DAY))) {

                PrintMsg(SEV_NORMAL, DCDIAG_CROSS_REF_VALIDATION_MISSING_SID,
                         pCrInfo->pdnNcName->StringName, pCrInfo->pszDn);

                // Code.Improvement See the comment in frsref.c:VerifySystemObjs()
                // about using RtlValidSid() for increased validation.

            }

        }


    } else {

        // If we've got an NDNC or a potentially pre-created CR

        dwRet = 0;
        PrintIndentAdj(1);

        if( ! (pCrInfo->bEnabled) &&
            (pCrInfo->ulSystemFlags == 0) ){
            PrintMsg(SEV_VERBOSE, DCDIAG_DISABLED_CROSS_REF,
                     pCrInfo->pszDn);
        }

        if( ! (pCrInfo->bEnabled) 
            && (pCrInfo->ulSystemFlags & FLAG_CR_NTDS_NC) ){

            Assert(!(pCrInfo->ulSystemFlags & FLAG_CR_NTDS_DOMAIN));

            //
            // What we have here is a suspect cross-ref.  It is likely that this
            // cross-ref is left over from a failed NDNC creation, and needs to 
            // be cleaned up.
            //

            if ( fIsOldCrossRef(pCrInfo, (10 * ONE_MINUTE)) ) {

                // If this CR is longer than an hour old, we're definately going 
                // to guess that this CR is from a failed NDNC creation.
                PrintMsg(SEV_NORMAL, DCDIAG_ERR_DEAD_CROSS_REF,
                         pDsInfo->pNCs[iNc].pszDn, pCrInfo->pszDn);
                dwRet = 1;
            }
        }

        if ( pCrInfo->bEnabled 
             && (pCrInfo->cReplicas == 0) ) {

            // NDNC Test 2 
            PrintMsg(SEV_NORMAL, DCDIAG_ERR_EMPTY_REPLICA_SET,
                     pDsInfo->pNCs[iNc].pszDn);

        }

        PrintIndentAdj(-1);

    }

    if (pdnNcName != NULL) { LocalFree(pdnNcName); }

    return(dwRet);
}

DWORD
CheckSDRefDom(
    PDC_DIAG_DSINFO		                pDsInfo,
    ULONG                               iNc, // Target NC
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Description:

    This function simply ensures that there is an SD reference domain if this
    is an Application Directory Parition.

Parameters:

    pDsInfo - the pDsInfo structure, basically the mini-enterprise variable.
    iNc - the targeted NC index in pDsInfo->pNCs[]
    gpCreds - the users credentials

Return Value:

    returns a Win 32 error.

--*/
{
    PDC_DIAG_CRINFO pCrInfo;
    BOOL  bSingleServer;
    DWORD dwRet, dwError;
    LONG iCr;
    DWORD dwFlags;

    // Only NDNCs need security descriptor reference domains
    if(!DcDiagIsNdnc(pDsInfo, iNc)){
        return(0);
    }
    
    bSingleServer = !((pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE)
                      || (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE));

    dwFlags = CRINFO_RETRIEVE_IF_NEC;
    if (bSingleServer){
        dwFlags |= CRINFO_SOURCE_HOME;
    } else {
        dwFlags |= CRINFO_SOURCE_AUTHORITATIVE;
    }
    dwFlags |= CRINFO_DATA_BASIC | CRINFO_DATA_EXTENDED;

    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNc,
                                  dwFlags,
                                  &iCr,
                                  &dwError);

    Assert(dwRet != CRINFO_RETURN_FIRST_UNDEFINED);
    if(dwRet == CRINFO_RETURN_FIRST_UNDEFINED
       || dwRet == CRINFO_RETURN_NO_CROSS_REF){       
        // Success everything is fine here.
        return(0);
    } else if (dwRet) {
        DcDiagPrintCrError(dwRet, dwError, pDsInfo->pNCs[iNc].pszDn,
                           pDsInfo->pNCs[iNc].aCrInfo[0].pszDn);
        return(dwRet);
    }
    
    // for ease of coding.
    pCrInfo = &(pDsInfo->pNCs[iNc].aCrInfo[iCr]);
           
    PrintIndentAdj(1);

    dwRet = 0;
    if (pCrInfo->pszSDReferenceDomain == NULL) {
        PrintMsg(SEV_NORMAL, DCDIAG_ERR_MISSING_SD_REF_DOM, 
                 pDsInfo->pNCs[iNc].pszDn, pCrInfo->pszDn);
        dwRet = 1;
    } 

    PrintIndentAdj(-1);

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\include\utils.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    include\utils.h

ABSTRACT:

    This is the file that contains most of the function headers for the dcdiag
    set of utilities.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

// from common\main.c --------------------------------------------------------
// Code.Improvement: move these functions to common\dsinfo.c
ULONG
DcDiagGetNCNum(
    PDC_DIAG_DSINFO                     pDsInfo,
    LPWSTR                              pszNCDN,
    LPWSTR                              pszDomain
    );

// from common\ldaputil.c ----------------------------------------------------
DWORD
DcDiagGetStringDsAttributeEx(
    LDAP *                          hld,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

LPWSTR
DcDiagTrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    );

DWORD
DcDiagGetStringDsAttribute(
    IN  PDC_DIAG_SERVERINFO         prgServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

// from common\bindings.c ----------------------------------------------------
DWORD
DcDiagGetLdapBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   BOOL                                bUseGcPort,
    OUT  LDAP * *                            phLdapBinding
    );

DWORD
DcDiagGetDsBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  HANDLE *                            phDsBinding
    );

DWORD
DcDiagGetNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
    );

VOID
DcDiagTearDownNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer
    );

DWORD
DcDiagGetDomainNamingFsmoLdapBinding(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  PULONG                              piFsmoServer,
    OUT  LPWSTR *                            ppszFsmoServer,
    OUT  LDAP **                             phLdapBinding
    );

// from common\list.c --------------------------------------------------------
/*
NOTES:

    This is a "pure" list function, in that it returns NULL, or a memory address.  If
    it returns NULL, then GetLastError() should have the error, even if another pure
    list function was called in the mean time.  If not it is almost certainly a memory
    error, as this is the only thing that can go wrong in pure list functions.  The pure
    list functions return a NO_SERVER terminated list.  The function always returns the
    pointer to the list.  Note most of the list functions modify one of the lists they
    are passed and passes back that pointer, so if you want the original contents, make
    a copy with IHT_CopyServerList().
*/

DWORD
IHT_PrintListError(
    DWORD                               dwErr
    );

VOID
IHT_PrintServerList(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );

PULONG
IHT_GetServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

PULONG
IHT_GetEmptyServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

BOOL
IHT_ServerIsInServerList(
    PULONG                              piServers,
    ULONG                               iTarget
    );

PULONG
IHT_AddToServerList(
    PULONG                             piServers,
    ULONG                              iTarget
    );

PULONG
IHT_TrimServerListBySite(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iSite,
    PULONG                              piServers
    );

PULONG
IHT_TrimServerListByNC(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials,
    PULONG                              piServers
    );

PULONG
IHT_AndServerLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc1,
    IN      PULONG                      piSrc2
    );

PULONG
IHT_CopyServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_NotServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_OrderServerListByGuid(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );


// from common\registry.c ----------------------------------------------------

DWORD
GetRegistryDword(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pszRegLocation,
    LPWSTR                          pszRegParameter,
    PDWORD                          pdwResult
    );

// from common\events.c ------------------------------------------------------

DWORD
GetEventString(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    LPWSTR *                        ppszMsg
    );

BOOL
EventIsInList(
    DWORD                           dwTarget,
    PDWORD                          paEventsList
    );

VOID 
PrintTimeGenerated(
    PEVENTLOGRECORD              pEvent
    );

VOID
GenericPrintEvent(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    BOOL                            fVerbose
    );

DWORD
PrintSelectEvents(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pwszEventLog,
    DWORD                           dwPrintAllEventsOfType,
    PDWORD                          paSelectEvents,
    PDWORD                          paBeginningEvents,
    DWORD                           dwBeginTime,
    VOID (__stdcall *               pfnPrintEventHandler) (PVOID, PEVENTLOGRECORD),
    VOID (__stdcall *               pfnBeginEventHandler) (PVOID, PEVENTLOGRECORD),
    PVOID                           pvContext
    );

BOOL
IsDomainNC(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC);

BOOL
IsSchema(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC);

BOOL
IsConfig(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC);

BOOL
IsNDNC(
    PDC_DIAG_DSINFO                          pDsInfo,
    LPWSTR                                   pszNC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\servers.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    servers.c

ABSTRACT:

    Contains tests related to the replication topology.

DETAILS:

CREATED:

    09 Jul 98   Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

        Did alot, added a DNS/server failure analysis.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <drs.h>  // need DS_REPL_INFO_REPSTO
#include <attids.h>

#include "dcdiag.h"
#include "ldaputil.h"
#include "repl.h"

// Some constants for ReplicationsCheck
// There is a better place to get this var ... but it is a pain
const LPWSTR                    pszTestNameRepCheck = L"Replications Check";

// Extern
// BUGBUG - move this routine to common
DSTIME
IHT_GetSecondsSince1601();

BOOL DcDiagIsMasterForNC (
    PDC_DIAG_SERVERINFO          pServer,
    LPWSTR                       pszNC
    );


DWORD
GetRemoteSystemsTimeAsFileTime(
    PDC_DIAG_SERVERINFO         pServer,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    FILETIME *                  pTimeNow
    )
/*++

Routine Description:

    This takes a Server (pServer) and gets the "currentTime" stored in the 
    RootDSE from that server.

Parameters:

    pServer - [Supplies] The server to fetch the current time from.
    gpCreds - [Supplies] The credentials to use when fetching the time.
    pTimeNow - [Returns] The current time retrieved.

Return Value:
  
    Win 32 Error.

  --*/
{
    LDAPMessage *               pldmTimeResults = NULL;
    LPWSTR                      ppszCurrentTime [] = {
        L"currentTime",
        NULL };
    struct berval **            ppsbvTime = NULL;
    SYSTEMTIME                  aTime;
    DWORD                       dwRet;
    LDAP *                      hld = NULL;
    LDAPMessage *               pldmEntry;
    LPWSTR *                    ppszTime = NULL;

    if((dwRet = DcDiagGetLdapBinding(pServer,
                                     gpCreds,
                                     FALSE,
                                     &hld)) != NO_ERROR){
        return(dwRet);
    }    
    dwRet = LdapMapErrorToWin32(ldap_search_sW (hld,
                                                NULL,
                                                LDAP_SCOPE_BASE,
                                                L"(objectCategory=*)",
                                                ppszCurrentTime,
                                                0,
                                                &pldmTimeResults));
    if(dwRet != ERROR_SUCCESS){
        ldap_msgfree(pldmTimeResults);
        return(dwRet);
    }
    pldmEntry = ldap_first_entry (hld, pldmTimeResults);
    ppszTime = ldap_get_valuesW (hld, pldmEntry, L"currentTime");
    if(ppszTime == NULL){
        ldap_msgfree(pldmTimeResults);
        return(-1); // Error isn't used anyway.
    }
    dwRet = DcDiagGeneralizedTimeToSystemTime((LPWSTR) ppszTime[0], &aTime);
    ldap_value_freeW(ppszTime);
    ldap_msgfree(pldmTimeResults);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    SystemTimeToFileTime(&aTime, pTimeNow);
        
    return(ERROR_SUCCESS); 
}


BOOL
GetCachedHighestCommittedUSN(
    PDC_DIAG_SERVERINFO pServer,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    USN *pUsn
    )

/*++

Routine Description:

Retrieve the "highestCommittedUSN" attribute from the ROOTDSE of the named
server.  If it is returned, it is cached in the server object, and reused
on the next call.

Arguments:

    pServer - 
    gpCreds - 
    pUsn - 

Return Value:

    BOOL - 

--*/

{
    DWORD status;
    BOOL fReturnResult = FALSE;
    LDAP *hLdap = NULL;
    LDAPMessage *pldmResults = NULL;
    LPWSTR ppszRootAttrs [] = {
        L"highestCommittedUSN",
        NULL };
    LDAPMessage *pldmEntry;
    LPWSTR *ppszUsnValues = NULL;

    // Return cached value if present
    if (pServer->usnHighestCommittedUSN) {
        *pUsn = pServer->usnHighestCommittedUSN;
        return TRUE;
    }

    // See if server is reachable. May not be if using MBR
    status = DcDiagGetLdapBinding( pServer, gpCreds, FALSE, &hLdap);
    if (status) {
        // If not reachable, just return quietly
        return FALSE;
    }

    // Get the value using LDAP
    status = LdapMapErrorToWin32(ldap_search_sW (hLdap,
                                                 NULL,
                                                 LDAP_SCOPE_BASE,
                                                 L"(objectCategory=*)",
                                                 ppszRootAttrs,
                                                 0,
                                                 &pldmResults));
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS, L"An LDAP search of the RootDSE failed.\n" );
        PrintMessage(SEV_ALWAYS, L"The error is %s\n", Win32ErrToString(status) );
        goto cleanup;
    }

    // Only one object returned
    pldmEntry = ldap_first_entry (hLdap, pldmResults);
    if (pldmEntry == NULL) {
        Assert( FALSE );
        goto cleanup;
    }

    ppszUsnValues = ldap_get_valuesW (hLdap, pldmEntry, L"highestCommittedUSN");
    if (ppszUsnValues == NULL) {
        Assert( FALSE );
        goto cleanup;
    }

    // store the usn
    *pUsn = pServer->usnHighestCommittedUSN = _wtoi64( *ppszUsnValues );
    
    fReturnResult = TRUE;
cleanup:

    if (ppszUsnValues) {
        ldap_value_freeW(ppszUsnValues);
    }
    if (pldmResults != NULL) {
        ldap_msgfree(pldmResults);
    }

    return fReturnResult;
} /* GetCachedHighestCommittedUSN */


BOOL
checkRepsTo(
    PDC_DIAG_DSINFO             pDsInfo,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    const LPWSTR                pszNC,
    PDC_DIAG_SERVERINFO         pSourceServer,
    PDC_DIAG_SERVERINFO         pDestServer
    )

/*++

Routine Description:

Look for the reps-to on the source server

Arguments:

    pDsInfo - 
    gpCreds - 
    pszNC - 
    pSourceServer - 
    pDestServer - 

Return Value:

    BOOL - was found or not

--*/

{
    DWORD ret;
    BOOL fResult = FALSE;
    HANDLE hDS = NULL;
    DS_REPL_NEIGHBORSW *pNeighbors = NULL;
    DS_REPL_NEIGHBORW * pNeighbor;

    if ( (!pSourceServer->bDnsIpResponding) ||
         (!pSourceServer->bLdapResponding) ||
         (!pSourceServer->bDsResponding) ) {
        // If we know source is down, don't bother
        return TRUE;
    }

    // Bind to the source server if it is up
    ret = DcDiagGetDsBinding(pSourceServer,
                             gpCreds,
                             &hDS);
    if (ERROR_SUCCESS != ret) {
        return TRUE; // claim success if can't reach
    }

    // Look up the reps-to we need
    ret = DsReplicaGetInfoW(hDS,
                            DS_REPL_INFO_REPSTO,
                            pszNC,
                            &(pDestServer->uuid),
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintMessage(SEV_VERBOSE,
                     L"[%s,%s] DsReplicaGetInfo(REPSTO) failed with error %d,\n",
                     REPLICATIONS_CHECK_STRING,
                     pSourceServer->pszName,
                     ret);
        PrintMessage(SEV_VERBOSE, L"%s.\n",
                     Win32ErrToString(ret));
        return TRUE; // claim success if can't reach
    }

    // Resources acquired - must goto cleanup after this point

    // No reps-to looks like zero neighbors
    if (pNeighbors->cNumNeighbors == 0) {
        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage(SEV_ALWAYS, L"ERROR: Expected notification link is missing.\n" );
        PrintMessage(SEV_ALWAYS, L"Source %s\n", pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"This problem should self-correct on the next periodic sync.\n" );
        goto cleanup;
    } else if (pNeighbors->cNumNeighbors != 1) {
        // Verify that it looks right
        PrintMessage( SEV_ALWAYS,
                      L"ERROR: Unexpected number of reps-to neighbors returned from %ws.\n",
                      pSourceServer->pszName );
        goto cleanup;
    }

    pNeighbor = &(pNeighbors->rgNeighbor[0]);
    if ( (_wcsicmp( pNeighbor->pszNamingContext, pszNC ) != 0) ||
         (memcmp( &(pNeighbor->uuidSourceDsaObjGuid),
                  &(pDestServer->uuid), sizeof( UUID ) ) != 0 ) ) {
        PrintMessage( SEV_ALWAYS,
                      L"ERROR: Reps-to has unexpected contents.\n" );
        goto cleanup;
    }

    fResult = TRUE;
cleanup:
    if (pNeighbors != NULL) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    return fResult;
} /* checkRepsTo */


VOID
RepCheckHelpSuccess(
    DWORD dwSuccessStatus
    )

/*++

Routine Description:

Given the user recommendations for success errors.  These errors are not counted
as failures (see drarfmod.c) must indicate a replication delay.

Arguments:

    dwSuccessStatus - 

Return Value:

    None

--*/

{
//Columns for message length
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    switch (dwSuccessStatus) {
    case ERROR_SUCCESS:
    case ERROR_DS_DRA_REPL_PENDING:
        PrintMessage( SEV_ALWAYS,
        L"Progress is occurring normally on this path.\n" );
        break;
    case ERROR_DS_DRA_PREEMPTED:
        PrintMessage( SEV_ALWAYS,
        L"A large number of replication updates need to be carried on this\n" );
        PrintMessage( SEV_ALWAYS,
        L"path. Higher priority replication work has temporarily interrupted\n" );
        PrintMessage( SEV_ALWAYS,
        L"progress on this link.\n" );
        break;
    case ERROR_DS_DRA_ABANDON_SYNC:
        PrintMessage( SEV_ALWAYS,
        L"Boot-time synchronization of this link was skipped because the source\n" );
        PrintMessage( SEV_ALWAYS,
        L"was taking too long returning updates.  Another sync will be tried\n" );
        PrintMessage( SEV_ALWAYS,
        L"at the next periodic replication interval.\n" );
        break;
    case ERROR_DS_DRA_SHUTDOWN:
        PrintMessage( SEV_ALWAYS,
        L"Either the source or destination was shutdown during the replication cycle.\n" );
        break;
    }

} /* RepCheckHelpSuccess */


VOID
RepCheckHelpFailure(
    DWORD dwFailureStatus,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    PDC_DIAG_SERVERINFO pSourceServer,
    PDC_DIAG_SERVERINFO pDestServer
    )

/*++

Routine Description:

Given the user recommendations for replication failures.

Arguments:

    dwFailureStatus - 
    pSourceServer - Source server for link. May be null if we haven't heard of this
    server yet.

Return Value:

    None

--*/

{
    DWORD status;
    HANDLE hDS = NULL;

    // If we couldn't resolve the source server, don't bother
    if (!pSourceServer) {
        return;
    }

//Columns for message length
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    switch (dwFailureStatus) {
// Retriable (transient) errors
    case ERROR_DS_DRA_SHUTDOWN:
    case ERROR_DS_DRA_SCHEMA_MISMATCH:
    case ERROR_DS_DRA_BUSY:
    case ERROR_DS_DRA_PREEMPTED:
    case ERROR_DS_DRA_ABANDON_SYNC:
        break;
    case ERROR_DS_DRA_OBJ_NC_MISMATCH:
        PrintMessage( SEV_ALWAYS,
        L"The parent of the object we tried to add is in the wrong\n" );
        PrintMessage( SEV_ALWAYS,
        L"partition.\n" );
        PrintMessage( SEV_ALWAYS,
        L"A modification and a cross-domain move occurred at the same time.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Replication will correct itself later once the writeable\n" );
        PrintMessage( SEV_ALWAYS,
        L"copies synchronize and sort out the inconsistency.\n" );
        break;
    case ERROR_OBJECT_NOT_FOUND:
    case ERROR_DS_DRA_MISSING_PARENT:
        PrintMessage( SEV_ALWAYS,
        L"The parent of the object we tried to add is missing\n" );
        PrintMessage( SEV_ALWAYS,
        L"because it is deleted.\n" );
        PrintMessage( SEV_ALWAYS,
        L"A modification and a parent delete occurred at the same time.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Replication will correct itself later once the writeable\n" );
        PrintMessage( SEV_ALWAYS,
        L"copies synchronize and  sort out the inconsistency.\n" );
        break;
    case RPC_S_SERVER_UNAVAILABLE:
        if ( (!pSourceServer->bDnsIpResponding) ||
             (!pSourceServer->bLdapResponding) ||
             (!pSourceServer->bDsResponding) ) {
            // Server is down
            PrintMessage( SEV_ALWAYS,
                          L"The source remains down. Please check the machine.\n" );
        } else {
            // Bind to the source server if it is up
            status = DcDiagGetDsBinding(pSourceServer,
                                        gpCreds,
                                        &hDS);
            if (ERROR_SUCCESS == status) {
                // Server is up now
                PrintMessage( SEV_ALWAYS,
                              L"The source %s is responding now.\n",
                              pSourceServer->pszName );
            } else {
                // Server is down
                PrintMessage( SEV_ALWAYS,
                              L"The source remains down. Please check the machine.\n" );
            }
        }
        break;

// Call failures
    case ERROR_DS_DNS_LOOKUP_FAILURE:
        PrintMessage( SEV_ALWAYS,
        L"The guid-based DNS name %s\n", pSourceServer->pszGuidDNSName );
        PrintMessage( SEV_ALWAYS,
        L"is not registered on one or more DNS servers.\n" );
        break;
    case ERROR_DS_DRA_OUT_OF_MEM:
    case ERROR_NOT_ENOUGH_MEMORY:
        PrintMessage( SEV_ALWAYS,
                      L"Check load and resouce usage on %s.\n",
                      pSourceServer->pszName );
        break;
    case RPC_S_SERVER_TOO_BUSY:
        PrintMessage( SEV_ALWAYS,
                      L"Check load and resouce usage on %s.\n",
                      pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"Security provider may have returned an unexpected error code.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"Check the clock difference between the two machines.\n" );

        break;
    case RPC_S_CALL_FAILED:
    case ERROR_DS_DRA_RPC_CANCELLED:
        PrintMessage( SEV_ALWAYS,
        L"The replication RPC call executed for too long at the server and\n" );
        PrintMessage( SEV_ALWAYS,
        L"was cancelled.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"Check load and resouce usage on %s.\n",
                      pSourceServer->pszName );
        break;
    case EPT_S_NOT_REGISTERED:
        PrintMessage( SEV_ALWAYS,
        L"The directory on %s is in the process.\n",
                      pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"of starting up or shutting down, and is not available.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Verify machine is not hung during boot.\n" );
        break;

// Kerberos security errors
    case ERROR_TIME_SKEW:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Check that the system time between the two servers is sufficiently.\n" );
        PrintMessage( SEV_ALWAYS,
        L"close. Also check that the time service is functioning correctly\n" );
        break;
    case ERROR_DS_DRA_ACCESS_DENIED:
        PrintMessage( SEV_ALWAYS,
        L"The machine account for the destination %s.\n",
                      pDestServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"is not configured properly.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Check the userAccountControl field.\n" );
        // fall through
    case ERROR_LOGON_FAILURE:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"The machine account is not present, or does not match on the.\n" );
        PrintMessage( SEV_ALWAYS,
        L"destination, source or KDC servers.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Verify domain partition of KDC is in sync with rest of enterprise.\n" );
        PrintMessage( SEV_ALWAYS,
        L"The tool repadmin/syncall can be used for this purpose.\n" );
        break;
    case ERROR_WRONG_TARGET_NAME:
        if (pSourceServer->pszGuidDNSName &&
            pSourceServer->pszDn &&
            pSourceServer->pszCollectedDsServiceName &&
            _wcsicmp(pSourceServer->pszDn, pSourceServer->pszCollectedDsServiceName)) {
            // These two objects are different, meaning the server we bound to in the
            // pSourceServer->pszGuidDNSName wasn't the server we thought it was,
            // meaning that we've got an old DNS record that needs cleaning up.
            PrintMsg( SEV_ALWAYS, 
                      DCDIAG_ERR_REPL_STALE_DNS_CAUSING_ERRORS,
                      pSourceServer->pszName,
                      pDestServer->pszName,
                      pSourceServer->pszGuidDNSName);
        } else {
            PrintMsg( SEV_ALWAYS,
                      DCDIAG_ERR_REPL_KERB_ERROR_WRONG_TARGET_NAME,
                      pSourceServer->pszName,
                      pDestServer->pszName);
            PrintIndentAdj(1);
            PrintMsg( SEV_ALWAYS,
                      DCDIAG_ERR_REPL_KERB_ERROR_WRONG_TARGET_NAME_REASONS,
                      pSourceServer->pszName,
                      pDestServer->pszName);
            PrintIndentAdj(-1);
        }
        break;
    case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"A KDC was not found to authenticate the call.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Check that sufficient domain controllers are available.\n" );
        break;
        
// Replication Errors

    case ERROR_ENCRYPTION_FAILED:
        PrintMessage( SEV_ALWAYS,
        L"Check that the servers have the proper certificates.\n" );
        break;
    case ERROR_DS_DRA_SOURCE_DISABLED:
    case ERROR_DS_DRA_SINK_DISABLED:
        PrintMessage( SEV_ALWAYS,
        L"Replication has been explicitly disabled through the server options.\n" );
        break;
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
    case ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT:
        PrintMessage( SEV_ALWAYS,
        L"Try upgrading all domain controllers to the lastest software version.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Try synchronizing the Schema partition on all servers in the forest.\n" );
        break;
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
    case ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA:
        PrintMessage( SEV_ALWAYS,
        L"Try synchronizing the Schema partition on all servers in the forest.\n" );
        break;

//Serious error

    case ERROR_DISK_FULL:
        PrintMessage( SEV_ALWAYS,
        L"The disk containing the database or log files on %s\n",
                      pDestServer->pszName );
        PrintMessage( SEV_ALWAYS,
        L"does not have enough space to replicate in the latest changes.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Try moving the database files to a larger volume using ntdsutil.\n" );
        break;
    case ERROR_DS_OBJ_TOO_LARGE:
        PrintMessage( SEV_ALWAYS,
        L"The size of the last replication update was too large or complex\n" );
        PrintMessage( SEV_ALWAYS,
        L"to be held in memory.  Consult the error log. The change\n" );
        PrintMessage( SEV_ALWAYS,
        L"must be simplified at the server where it originated.\n" );
        break;
    case ERROR_DS_DRA_INTERNAL_ERROR:
    case ERROR_DS_DRA_DB_ERROR:
        PrintMessage( SEV_ALWAYS,
        L"A serious error is preventing replication from continuing.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Consult the error log for further information.\n" );
        PrintMessage( SEV_ALWAYS,
        L"If a particular object is named, it may be necessary to manually\n" );
        PrintMessage( SEV_ALWAYS,
        L"modify or delete the object.\n" );
        PrintMessage( SEV_ALWAYS,
        L"If the condition persists, contact Microsoft Support.\n" );
        break;

    // Core internal errors, should not be returned
    case ERROR_DS_DRA_NAME_COLLISION:
    case ERROR_DS_DRA_SOURCE_REINSTALLED:
        Assert( !"Unexpected error status returned" );
        break;

    default:
        break;
    }

} /* RepCheckHelpFailure */

VOID 
ReplicationsCheckRep (
    PDC_DIAG_DSINFO             pDsInfo,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    const ULONG                 ulServer,
    const LPWSTR                pszNC,
    BOOL                        bNCHasCursors,
    const DS_REPL_NEIGHBORW *   pNeighbor
    )
/*++

Routine Description:

    This function takes the pNeighbor structure associated with the server 
    ulServer and checks the replications for the specified NC.

Parameters:
    pDsInfo - [Supplies] The main directiory info.
    ulServer - [Supplies] The server to target.
    pszNC - [Supplies] The NC to specify.
    pNeighbor - [Supplies] The neighbor info from the repsFrom that is used
        to detemine if there are any errors on this servers replications.
    bNCHasCursors - The NC already has an UP TO DATE VECTOR, ie it has sunk
                    once successfully already

  --*/
{
    // The number of 100 nsec intervals in one minute.
    const LONGLONG              llIntervalsPerMinute = (60 * 1000 * 1000 * 10);
    const LONGLONG              llUnusualRepDelay = 180 * llIntervalsPerMinute;
                                                     //  3 hours
    CHAR                        szBuf [SZDSTIME_LEN];
    WCHAR                       szTimeLastAttempt [SZDSTIME_LEN];
    WCHAR                       szTimeLastSuccess [SZDSTIME_LEN];
    FILETIME                    timeNow;
    //    FILETIME                      timeLastAttempt;
    DSTIME                      dstimeLastSyncSuccess;
    DSTIME                      dstimeLastSyncAttempt;
    LONGLONG                    llTimeSinceLastAttempt;
    LONGLONG                    llTimeSinceLastSuccess;

    LPWSTR                      pszSourceName = NULL;
    ULONG                       ulServerTemp;
    DWORD                       dwRet;
    PDC_DIAG_SERVERINFO         pSourceServer = NULL;

    if (IsDeletedRDNW(pNeighbor->pszSourceDsaDN)) { 
        //  Since this is actually a deleted server/neighbor we will skip it
        return;
    }
                       
    ulServerTemp = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                      pNeighbor->pszSourceDsaDN, NULL, NULL);
    if(ulServerTemp != NO_SERVER) {
        pSourceServer = &(pDsInfo->pServers[ulServerTemp]);
        pszSourceName = pSourceServer->pszName;

        // Should we skip this source?
        if ( (pDsInfo->ulFlags & DC_DIAG_IGNORE) &&
             ( (!pSourceServer->bDnsIpResponding) ||
               (!pSourceServer->bLdapResponding) ||
               (!pSourceServer->bDsResponding) ) &&
             (pNeighbor->cNumConsecutiveSyncFailures) &&
             (pNeighbor->dwLastSyncResult == RPC_S_SERVER_UNAVAILABLE) ) {
            IF_DEBUG(
                PrintMessage(SEV_VERBOSE, 
                             L"Skipping neighbor %s, because it was down\n",
                             pDsInfo->pServers[ulServerTemp].pszName) );
            return;
        }

        // Is this source server prohibiting outbound replications?
        if (pSourceServer->iOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL) {
            PrintMessage(SEV_NORMAL, 
                         L"Skipping server %s, because it has outbound "
                         L"replication disabled\n", 
                         pSourceServer->pszName);
            return;
            // If it is, there's no point in printing a zillion 
            //   warning messages.
        }
    } else {
        pszSourceName = pNeighbor->pszSourceDsaAddress;
        if (pszSourceName == NULL) {
            Assert(!"I'd expect pNeighbor->pszSourceDsaAddress to be filled in?!?");
            pszSourceName = L"(unknown)";
        }
    }
    Assert(pszSourceName);

    // Gather all the time information.
    // pNeighbor ->ftimeLastSyncSuccess  ->ftimeLastSyncAttempt  timeNow

    FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dstimeLastSyncAttempt);
    DSTimeToDisplayString (dstimeLastSyncAttempt, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                         szTimeLastAttempt, SZDSTIME_LEN);

    FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dstimeLastSyncSuccess);
    DSTimeToDisplayString (dstimeLastSyncSuccess, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                         szTimeLastSuccess, SZDSTIME_LEN);

    dwRet = GetRemoteSystemsTimeAsFileTime (&(pDsInfo->pServers[ulServer]),
                                            pDsInfo->gpCreds,
                                            &timeNow);
    if(dwRet != ERROR_SUCCESS){
        PrintMessage(SEV_VERBOSE, 
                     L"Warning: Could not get current time from remote\n");
        PrintMessage(SEV_VERBOSE,
                     L"directory on %s, using the local time instead\n",
                     pDsInfo->pServers[ulServer].pszName);
        GetSystemTimeAsFileTime(&timeNow);
    }

    // instead of timeLastAttempt .. use pNeighbor->ftimeLastSyncAttempt
    llTimeSinceLastSuccess = ((LARGE_INTEGER *) &timeNow)->QuadPart
        - ((LARGE_INTEGER *) &pNeighbor->ftimeLastSyncSuccess)->QuadPart;
    llTimeSinceLastAttempt = ((LARGE_INTEGER *) &timeNow)->QuadPart 
        - ((LARGE_INTEGER *) &pNeighbor->ftimeLastSyncAttempt)->QuadPart;

    Assert(llTimeSinceLastAttempt >= 0);
    Assert(llTimeSinceLastSuccess >= 0);
    
    // Check for failures.
    if (pNeighbor->cNumConsecutiveSyncFailures) {
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] A recent replication attempt failed:\n",
                     REPLICATIONS_CHECK_STRING,
                     pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
        PrintMessage(SEV_ALWAYS, L"From %s to %s\n", pszSourceName, 
                     pDsInfo->pServers[ulServer].pszName);
        PrintMessage(SEV_ALWAYS, L"Naming Context: %s\n", pszNC);
        PrintMessage(SEV_ALWAYS, 
                     L"The replication generated an error (%ld):\n", 
                     pNeighbor->dwLastSyncResult);
        PrintMessage(SEV_ALWAYS, L"%s\n", 
                     Win32ErrToString (pNeighbor->dwLastSyncResult));
        PrintMessage(SEV_ALWAYS, L"The failure occurred at %s.\n", 
                     szTimeLastAttempt);
        PrintMessage(SEV_ALWAYS, L"The last success occurred at %s.\n", 
                     szTimeLastSuccess);
        PrintMessage(SEV_ALWAYS, 
                     L"%d failures have occurred since the last success.\n",
                     pNeighbor->cNumConsecutiveSyncFailures);
        RepCheckHelpFailure( pNeighbor->dwLastSyncResult,
                             gpCreds,
                             pSourceServer,
                             &(pDsInfo->pServers[ulServer]) );
        PrintIndentAdj(-1);

    // Check if this replication has never been attempted.
    } else if (((LARGE_INTEGER *) &pNeighbor->ftimeLastSyncAttempt)->QuadPart == 0) {
        // This is okay -- e.g., a newly added source.  This means a
        //    replication has never been attempted.

        NOTHING;

    // Check if it's gone unattempted || for an unusually long time.
    } else if (llTimeSinceLastAttempt >= llUnusualRepDelay){
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] No replication recently attempted:\n",
                     REPLICATIONS_CHECK_STRING,
                     pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
        PrintMessage(SEV_ALWAYS, L"From %s to %s\n", 
                     pszSourceName, pDsInfo->pServers[ulServer].pszName);
        PrintMessage(SEV_ALWAYS, L"Naming Context: %s\n", pszNC);
        PrintMessage(SEV_ALWAYS, 
                L"The last attempt occurred at %s (about %I64d hours ago).\n", 
                     szTimeLastAttempt, 
                     llTimeSinceLastAttempt / llIntervalsPerMinute / 60);
        PrintIndentAdj(-1);

        // Check for delays when the last status was success
    } else if ( (llTimeSinceLastSuccess >= llUnusualRepDelay) ||
                ( (pNeighbor->dwLastSyncResult != ERROR_SUCCESS) &&
                  (pNeighbor->dwLastSyncResult != ERROR_DS_DRA_REPL_PENDING) )) {
        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS,
                   L"%s: This replication path was preempted by higher priority work.\n",
                      pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
        PrintMessage(SEV_ALWAYS, L"from %s to %s\n", pszSourceName, 
                     pDsInfo->pServers[ulServer].pszName);
        PrintMessage(SEV_ALWAYS, L"Reason: %s\n", 
                     Win32ErrToString (pNeighbor->dwLastSyncResult));
        PrintMessage(SEV_ALWAYS, L"The last success occurred at %s.\n", 
                     szTimeLastSuccess);
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        RepCheckHelpSuccess( pNeighbor->dwLastSyncResult) ;
        PrintIndentAdj(-1);
    } // end big if/elseif/elseif check for failures statement

    // Report on full sync in progress

    // Can't use DS_REPL_NBR_NEVER_SYNCED because not set for mail
    if ( (pNeighbor->usnAttributeFilter == 0) && (!bNCHasCursors) ) {
        USN usnHighestCommittedUSN = 0;

        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS, L"%s: A full synchronization is in progress\n",
                      pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
        PrintMessage(SEV_ALWAYS, L"from %s to %s\n", pszSourceName, 
                     pDsInfo->pServers[ulServer].pszName);
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        // If we can reach the source, find out his highest USN
        if ( pSourceServer &&
             (!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT)) &&
             (GetCachedHighestCommittedUSN(
                 pSourceServer, pDsInfo->gpCreds, &usnHighestCommittedUSN ))) {
            double percentComplete =
                ((double)pNeighbor->usnLastObjChangeSynced /
                 (double)usnHighestCommittedUSN) * 100.0;
            PrintMessage( SEV_ALWAYS,
                          L"The full sync is %.2f%% complete.\n", percentComplete );

        }
        PrintIndentAdj(-1);
    }

    // If expecting notification, check reps-to on source
    if ( (!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS)) &&
         (!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT)) &&
         (pSourceServer) ) {
        checkRepsTo( pDsInfo, gpCreds, pszNC, pSourceServer,
                     &(pDsInfo->pServers[ulServer]) );
    }
}


VOID
ReplicationsCheckQueue(
    PDC_DIAG_DSINFO             pDsInfo,
    const ULONG                 ulServer,
    DS_REPL_PENDING_OPSW *      pPendingOps
    )

/*++

Routine Description:

Check that the current item in the replication work queue has not gone on too long.

Arguments:

    pDsInfo - 
    ulServer - 
    pPendingOps - 

Return Value:

    None

--*/

{
#define NON_BLOCKING_TIMELIMIT (5 * 60)
#define BLOCKING_TIMELIMIT (2 * 60)
#define EXCESSIVE_ITEM_LIMIT (50)
    CHAR szBuf[SZDSTIME_LEN];
    WCHAR wszTime[SZDSTIME_LEN];
    DWORD status;
    PDC_DIAG_SERVERINFO pServer = &(pDsInfo->pServers[ulServer]);
    DSTIME dsTime, dsTimeNow;
    int dsElapsed, limit;
    BOOL fBlocking;
    DS_REPL_OPW *pOp;
    LPWSTR pszOpType;

    // Check for no work in progress
    if ( (pPendingOps->cNumPendingOps == 0) ||
         (memcmp( &pPendingOps->ftimeCurrentOpStarted, &gftimeZero,
                  sizeof( FILETIME ) ) == 0) ) {
        return;
    }

    PrintMessage( SEV_VERBOSE,
                  L"%s: There are %d replication work items in the queue.\n",
                  pDsInfo->pServers[ulServer].pszName,
                  pPendingOps->cNumPendingOps );

    FileTimeToDSTime(pPendingOps->ftimeCurrentOpStarted, &dsTime);
    dsTimeNow = IHT_GetSecondsSince1601();

    dsElapsed = (int) (dsTimeNow - dsTime);

    // See if anyone is waiting

    if ( (pPendingOps->cNumPendingOps == 1) ||
         (pPendingOps->rgPendingOp[0].ulPriority >=
          pPendingOps->rgPendingOp[1].ulPriority ) ) {
        // Nobody more important is waiting
        limit = NON_BLOCKING_TIMELIMIT;
        fBlocking = FALSE;
    } else {
        // Somebody important is blocked
        limit = BLOCKING_TIMELIMIT;
        fBlocking = TRUE;
    }

    // This has gone on long enough!

    if (dsElapsed > limit) {
        pOp = &pPendingOps->rgPendingOp[0];

        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS, L"%s: A long-running replication operation is in progress\n",
                      pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
        PrintMessage( SEV_ALWAYS, L"The job has been executing for %d minutes and %d seconds.\n",
                      dsElapsed / 60, dsElapsed % 60);
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        if (fBlocking) {
            PrintMessage( SEV_ALWAYS, L"Error: Higher priority replications are being blocked\n" );
        } else {
            PrintMessage( SEV_ALWAYS,
                          L"This is normal for a new connection, or for a system\n" );
            PrintMessage( SEV_ALWAYS,
                          L"that has been down a long time.\n" );
        }
        
        FileTimeToDSTime(pOp->ftimeEnqueued, &dsTime);
        DSTimeToDisplayString(dsTime, szBuf);
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                             wszTime, SZDSTIME_LEN);
        
        PrintMessage( SEV_ALWAYS, L"Enqueued %s at priority %d\n",
                      wszTime,
                      pOp->ulPriority );
            
        switch (pOp->OpType) {
        case DS_REPL_OP_TYPE_SYNC:
            pszOpType = L"SYNC FROM SOURCE";
            break;
        case DS_REPL_OP_TYPE_ADD:
            pszOpType = L"ADD NEW SOURCE";
            break;
        case DS_REPL_OP_TYPE_DELETE:
            pszOpType = L"DELETE SOURCE";
            break;
        case DS_REPL_OP_TYPE_MODIFY:
            pszOpType = L"MODIFY SOURCE";
            break;
        case DS_REPL_OP_TYPE_UPDATE_REFS:
            pszOpType = L"UPDATE CHANGE NOTIFICATION";
            break;
        default:
            pszOpType = L"UNKNOWN";
            break;
        }

        PrintMessage( SEV_ALWAYS, L"Op: %s\n", pszOpType);
        PrintMessage( SEV_ALWAYS, L"NC %ls\n", pOp->pszNamingContext);
        PrintMessage( SEV_ALWAYS, L"DSADN %ls\n", 
                      pOp->pszDsaDN ? pOp->pszDsaDN : L"(null)");
        PrintMessage( SEV_ALWAYS, L"DSA transport addr %ls\n",
                      pOp->pszDsaAddress ? pOp->pszDsaAddress : L"(null)");
        PrintIndentAdj(-1);
    } else {
        // Job still has time left
        PrintMessage( SEV_VERBOSE,
                      L"The first job has been executing for %d:%d.\n",
                      dsElapsed / 60, dsElapsed % 60);
    }

    if (pPendingOps->cNumPendingOps > EXCESSIVE_ITEM_LIMIT) {
        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS, L"%s: %d replication work items are backed up.\n",
                      pDsInfo->pServers[ulServer].pszName,
                      pPendingOps->cNumPendingOps );
    }

} /* ReplicationsCheckQueue */


BOOL
getNativePropertyMetaDataVector(
    PVOID pvData,
    DWORD cbLength,
    PROPERTY_META_DATA_VECTOR_V1 **ppNativeMetaDataVec,
    BOOL *pfMustFreeMetaDataVec
    )

/*++

Routine Description:

    Convert a replPropertyMetaData blob into the native meta data vector.

    Silently returns false if version not recognized.

Arguments:

    pvData - blob pointer
    cbLength - blob length
    ppNativeMetaDataVec (OUT) - pointer to native vector
    pfMustFreeMetaDataVec (OUT) - Whether vector was allocated and must be freed

    Note that the out parameters are only initialized if return TRUE.

Return Value:

    BOOL - True if the blob format is recognized, False otherwise

--*/

{
    PROPERTY_META_DATA_VECTOR *pVec =
        (PROPERTY_META_DATA_VECTOR *) pvData;

    if (!pVec) {
        return FALSE;
    }

    // To add support for new versions, add a switch statement here. Return the highest
    // version supported in place, and add code to convert downlevel structures into
    // the native version.
    if ( (pVec->dwVersion != 1) ||
         (MetaDataVecV1Size(pVec) != cbLength) ) {
        return FALSE;
    }

    *ppNativeMetaDataVec = &(pVec->V1);
    *pfMustFreeMetaDataVec = FALSE;

    return TRUE;
} /* getNativePropertyMetaDataVector */


DWORD
ReplicationsCheckSiteLatency(
    LDAP *                      hld,
    PDC_DIAG_DSINFO             pDsInfo,
    const ULONG                 ulServer
    )

/*++

Routine Description:

Check that the latency of replication from all other sites.
Display if over EXCESSIVE_LATENCY_LIMIT

Ignore a site if:
o There are no servers in the site (check pSite[].cServers)
o The site has disabled the istg (check pSite[].options)
o If a site has enabled Whistler mode through an option on a per-site basis

Enumerate the site settings objects for the given target dc.

Read the replication property metadata. We do this by reading the attribute
blob so that we can get all the information in one call. We will crack the
blob locally.  This tool will have to be updated if the blob format ever changes.
This tool will silently ignore blobs it doesn't recognize.

Skip sites according to rules above.

Compare the last originating update time of the ISTG attribute with the
current time. If more time has passed than the limit, an error is reported.

Arguments:

    hld - ldap handle
    pDsInfo - info block
    ulServer - index of server in pDsInfo->pServers

Return Value:

    0 on success or Win32 error code on failure.

--*/

{
    LPWSTR                     ppszNtdsSiteSearch [] = {
        L"replPropertyMetaData",
        NULL };
    LDAPMessage *              pldmEntry = NULL;
    LDAPMessage *              pldmNtdsSitesResults = NULL;
    LPWSTR                     pszDn = NULL;
    DWORD                      dwWin32Err = NO_ERROR;
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    ULONG                      ulCount = 0;
    DWORD                      dwLdapErr;
    struct berval **           ppbvMetaData = NULL;
    DSTIME                     dsTimeNow;
    int                        dsElapsed, limit;
    CHAR                       szTimeNow[SZDSTIME_LEN], szTimeChanged[SZDSTIME_LEN];
    PROPERTY_META_DATA_VECTOR_V1 *pNativeMetaDataVec = NULL;
    PROPERTY_META_DATA         *pMetaData = NULL;
    BOOL                       fMustFreeMetaDataVec = FALSE;
    DWORD                      i;
    CHAR                       szUuid[SZUUID_LEN];

#define SITE_LATENCY_LIMIT_SECS (24 * 60 * 60)

    Assert( pDsInfo->dwForestBehaviorVersion < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS );

    PrintMsg( SEV_VERBOSE, DCDIAG_SITE_LATENCY_TEST_BANNER );

    dsTimeNow = IHT_GetSecondsSince1601();
    DSTimeToDisplayString(dsTimeNow, szTimeNow);

    __try {

        pSearch = ldap_search_init_page(hld,
                                        pDsInfo->pszConfigNc,
                                        LDAP_SCOPE_SUBTREE,
                                        L"(objectCategory=ntDSSiteSettings)",
                                        ppszNtdsSiteSearch,
                                        FALSE, NULL, NULL, 0, 0, NULL);
        if(pSearch == NULL){
            dwLdapErr = LdapGetLastError();
            DcDiagException(LdapMapErrorToWin32(dwLdapErr));
        }

        dwLdapErr = ldap_get_next_page_s(hld,
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmNtdsSitesResults);
        if(dwLdapErr == LDAP_NO_RESULTS_RETURNED){      
            PrintMsg( SEV_ALWAYS, DCDIAG_ERR_NO_SITES );
            DcDiagException(ERROR_DS_OBJ_NOT_FOUND);
        }
        while(dwLdapErr == LDAP_SUCCESS){

            // Walk through all the sites ...
            pldmEntry = ldap_first_entry (hld, pldmNtdsSitesResults);
            for (; pldmEntry != NULL; ulCount++) {
                // Get the site common/printable name
                if ((pszDn = ldap_get_dnW (hld, pldmEntry)) == NULL){
                    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
                }

                PrintMessage( SEV_DEBUG, L"Site Settings = %s\n", pszDn );

                if ((ppbvMetaData = ldap_get_values_lenW (hld, pldmEntry, L"replPropertyMetaData")) == NULL) {
                    DcDiagException (ERROR_NOT_ENOUGH_MEMORY); // missing attribute?
                }

                if (!getNativePropertyMetaDataVector(
                        ppbvMetaData[0]->bv_val, ppbvMetaData[0]->bv_len,
                        &pNativeMetaDataVec, &fMustFreeMetaDataVec )) {
                    // Unrecognized format? Fail silently
                    PrintMsg( SEV_VERBOSE,
                              DCDIAG_SITE_SKIP_BAD_META,
                              pszDn );
                    goto leave_loop;
                }

                pMetaData = NULL;
                for( i = 0; i < pNativeMetaDataVec->cNumProps; i++ ) {
                    if (pNativeMetaDataVec->rgMetaData[i].attrType ==
                        ATT_INTER_SITE_TOPOLOGY_GENERATOR) {
                        pMetaData = &( pNativeMetaDataVec->rgMetaData[i] );
                        break;
                    }
                }
                if (!pMetaData) {
                    // Attribute never written - site emptry
                    PrintMsg( SEV_VERBOSE,
                              DCDIAG_SITE_SKIP_NO_ISTG,
                              pszDn );
                    goto leave_loop;
                }

                DSTimeToDisplayString(pMetaData->timeChanged, szTimeChanged);
                PrintMessage( SEV_DEBUG, L"[0x%x,v=%d,t=%S,g=%S,orig=%I64d,local=%I64d]\n",
                              pMetaData->attrType,
                              pMetaData->dwVersion,
                              szTimeChanged,
                              DsUuidToStructuredStringCch((const UUID *)&(pMetaData->uuidDsaOriginating),szUuid,SZUUID_LEN),
                              pMetaData->usnOriginating,
                              pMetaData->usnProperty );


                dsElapsed = (int) (dsTimeNow - pMetaData->timeChanged);
                if (dsElapsed < SITE_LATENCY_LIMIT_SECS) {
                    PrintMessage( SEV_DEBUG, L"Elapsed time (sec) = %d\n", dsElapsed );
                    goto leave_loop;
                }

                // See if site should be excluded because of site properties.
                // Find the site.
                for(i = 0; i < pDsInfo->cNumSites; i++){
                    if(_wcsicmp(pDsInfo->pSites[i].pszSiteSettings, pszDn) == 0){
                        break;
                    }
                }
                // If the home server and the target agree there is such a site...
                if (i < pDsInfo->cNumSites) {

                    if (pDsInfo->pSites[i].cServers == 0) {
                        // This is the case that a site used to have servers, had an istg written,
                        // and then all servers moved out of site.
                        // Suppress this warning
                        PrintMsg( SEV_VERBOSE,
                                  DCDIAG_SITE_SKIP_NO_SERVERS,
                                  pszDn );
                        goto leave_loop;
                    }

                    if (pDsInfo->pSites[i].iSiteOptions &
                        NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED) {
                        // ISTG is turned off in this site, ignore warnings
                        PrintMsg( SEV_VERBOSE,
                                  DCDIAG_SITE_SKIP_ISTG_OFF,
                                  pszDn );
                        goto leave_loop;
                    }
                }

                PrintMsg( SEV_ALWAYS, DCDIAG_SITE_REPLICATION_LATENCY,
                          pszDn, szTimeNow, szTimeChanged );

            leave_loop:
                ldap_value_free_len (ppbvMetaData);
                ppbvMetaData = NULL;

                ldap_memfreeW (pszDn);
                pszDn = NULL;

                pldmEntry = ldap_next_entry (hld, pldmEntry);
            } // end for each site

            ldap_msgfree(pldmNtdsSitesResults);
            pldmNtdsSitesResults = NULL;

            dwLdapErr = ldap_get_next_page_s(hld,
                                             pSearch,
                                             0,
                                             DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                             &ulTotalEstimate,
                                             &pldmNtdsSitesResults);
        } // end of while loop for each page

        if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
            DcDiagException(LdapMapErrorToWin32(dwLdapErr));
        }

        ldap_search_abandon_page(hld, pSearch);
        pSearch = NULL;

    } __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                       &dwWin32Err)){
    }

    // Note we do not unbind the Ds or Ldap connections, because they have been saved for later use.
    Assert( !fMustFreeMetaDataVec );
    if (pszDn != NULL) { ldap_memfreeW (pszDn); }
    if (ppbvMetaData != NULL) { ldap_value_free_len (ppbvMetaData); }
    if (pldmNtdsSitesResults != NULL) { ldap_msgfree (pldmNtdsSitesResults); }
    if (pSearch != NULL) { ldap_search_abandon_page(hld, pSearch); }

    return dwWin32Err;
}


DWORD
ReplicationsCheckLatency(
    HANDLE                      hDs,
    PDC_DIAG_DSINFO             pDsInfo,
    const ULONG                 ulServer
    )

/*++

Routine Description:

Check that the latency of replication from all other servers for all NC's
Display if over EXCESSIVE_LATENCY_LIMIT

Arguments:

    hDs - handle
    pDsInfo - info block
    ulServer - index of server in pDsInfo->pServers

Return Value:

    0 on success or Win32 error code on failure.

--*/

{

    DWORD               iCursor;
    DSTIME              dsTime;
    CHAR                szTime[SZDSTIME_LEN];
    BOOL                fWarning = FALSE;
    BOOL                fNCWarning = FALSE;
    FILETIME            ftCurrentTime;
    FILETIME            ftLastSyncSuccess;
    DS_REPL_CURSORS_2 *         pCursors2 = NULL;
    ULARGE_INTEGER      uliSyncTime;
    ULONG               ulOtherServerIndex;
    ULONG               ulNC;
    INT                 ret;
    ULONG               cRetiredInvocationId = 0;
    ULONG               cTimeStamp = 0;
    ULONG               cIgnoreReadOnlyReplicas = 0;
    
    //define times in nanoseconds for latency limit
    #define _SECOND ((LONGLONG)10000000)
    #define _MINUTE (60 * _SECOND)
    #define _HOUR   (60 * _MINUTE)
    #define _DAY    (24 * _HOUR) 
    #define EXCESSIVE_LATENCY_LIMIT (12*_HOUR)
    

    PrintMessage(SEV_VERBOSE, 
                         L"* Replication Latency Check\n"   );
    //check latency for each NC we have info on
    for (ulNC=0;ulNC<pDsInfo->cNumNCs;ulNC++) { 
        if (  !((pDsInfo->pszNC != NULL) && _wcsicmp(pDsInfo->pNCs[ulNC].pszDn,pDsInfo->pszNC)) 
              &&
              (DcDiagHasNC(pDsInfo->pNCs[ulNC].pszDn, &(pDsInfo->pServers[ulServer]), TRUE, TRUE))
               ) 
           //do not perform the test for this NC if:

           //the NC is specified on the command line and this NC is not the one specified
           //or
           //this NC doesn't exist on this server 
            
        { 
        //init counters to track info on vector entries we cannot compute a latency for
        cRetiredInvocationId = 0;
        cTimeStamp = 0;
        cIgnoreReadOnlyReplicas = 0;

        //init for warning info
        fNCWarning = FALSE;

        //get UTD cursor
        ret = DsReplicaGetInfoW(hDs, DS_REPL_INFO_CURSORS_2_FOR_NC, pDsInfo->pNCs[ulNC].pszDn, NULL, &pCursors2);
        
        if (ERROR_NOT_SUPPORTED == ret) {
            PrintMessage(SEV_VERBOSE,
                         L"The replications latency check is not available on this DC.\n");
            return ERROR_SUCCESS;
        }
        else if (ERROR_SUCCESS != ret) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] DsReplicaGetInfoW(CURSORS_2_FOR_NC) failed with error %d,\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulServer].pszName,
                         ret);
            PrintMessage(SEV_ALWAYS, L"%s\n",
                         Win32ErrToString(ret));
       PrintRpcExtendedInfo(SEV_VERBOSE, ret);
            if (pCursors2 != NULL)   {DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_2_FOR_NC, pCursors2);}
            return ret;
        } 


        //get the current time on the homeserver (or at least current with respect to vector)
        ftCurrentTime = pDsInfo->pServers[ulServer].ftRemoteConnectTime;

        //for each row/invocationID in the cursor, check the repl latency to the corresponding server
        for (iCursor = 0; iCursor < pCursors2->cNumCursors; iCursor++) {
            
            ulOtherServerIndex = DcDiagGetServerNum(pDsInfo, 
                                                    NULL, 
                                                    NULL, 
                                                    NULL, 
                                                    NULL, 
                                                    &(pCursors2->rgCursor[iCursor].uuidSourceDsaInvocationID));
            if (ulOtherServerIndex==ulServer) {
                // this is us, we don't need to do anything for our own row in the vector
            }
            else if (ulOtherServerIndex==NO_SERVER) {    
                //no server found in the pDsInfo to match the GUID from the Cursor
                //this machine has been restored/etc and the invocationId is retired
                //no need to check latency for this. track how many for verbose print
                cRetiredInvocationId += 1; 
            }
            else if (!DcDiagIsMasterForNC(&(pDsInfo->pServers[ulOtherServerIndex]),pDsInfo->pNCs[ulNC].pszDn)) {
                // don't check latency for read only copies in the cursor, they are not
                // guaranteed to be viable in our repliation path (there can exist entires in the UTD which
                // we no longer replicate with, so those latencies will appear stale)
                cIgnoreReadOnlyReplicas +=1;
            }
            else { 
                //translate filetime to ularge_integer for comparison   
                uliSyncTime.LowPart = pCursors2->rgCursor[iCursor].ftimeLastSyncSuccess.dwLowDateTime;
                uliSyncTime.HighPart = pCursors2->rgCursor[iCursor].ftimeLastSyncSuccess.dwHighDateTime;

                if (uliSyncTime.QuadPart==0) {
                    //the timestamp is not there, version < V2
                    //verbose print count below
                    cTimeStamp += 1;  
                }
                else { //uliSyncTime is non zero

                    // Add EXCESSIVE_LATENCY_LIMIT
                    uliSyncTime.QuadPart = uliSyncTime.QuadPart + EXCESSIVE_LATENCY_LIMIT;

                    // Copy the result back into a FILETIME structure to make comparisons.
                    ftLastSyncSuccess.dwLowDateTime  = uliSyncTime.LowPart;
                    ftLastSyncSuccess.dwHighDateTime = uliSyncTime.HighPart; 

                    if ( CompareFileTime(&ftCurrentTime,&ftLastSyncSuccess) > 0) {
                        
                        if (!fWarning) {
                            FileTimeToDSTime(ftCurrentTime,
                                             &dsTime); 
                            DSTimeToDisplayString(dsTime, szTime);
                            PrintMessage( SEV_ALWAYS, L"REPLICATION-RECEIVED LATENCY WARNING\n");   
                            PrintMessage( SEV_ALWAYS, L"%s:  Current time is %S.\n", 
                                          pDsInfo->pServers[ulServer].pszName, 
                                          szTime );


                        }
                        //for any nc outside the latency limits, only display the above message once
                        fWarning = TRUE;
                        if (!fNCWarning) {
                            PrintMessage( SEV_ALWAYS, L"   %s\n", pDsInfo->pNCs[ulNC].pszDn);
                        }
                        fNCWarning = TRUE;
                        //for each nc outside the latency limits, display the above message once

                        FileTimeToDSTime(pCursors2->rgCursor[iCursor].ftimeLastSyncSuccess,
                                         &dsTime); 
                        DSTimeToDisplayString(dsTime, szTime);
                        PrintMessage( SEV_ALWAYS, L"      Last replication recieved from %s at %S.\n",
                                      pDsInfo->pServers[ulOtherServerIndex].pszName,
                                      szTime ? szTime : "(unknown)" ); 
                        //if beyond the tombstonelifetime, print another warning
                        uliSyncTime.QuadPart = uliSyncTime.QuadPart - EXCESSIVE_LATENCY_LIMIT + pDsInfo->dwTombstoneLifeTimeDays*_DAY;
                        
                        ftLastSyncSuccess.dwLowDateTime  = uliSyncTime.LowPart;
                        ftLastSyncSuccess.dwHighDateTime = uliSyncTime.HighPart;
                        if (CompareFileTime(&ftCurrentTime,&ftLastSyncSuccess) > 0) {
                            PrintMessage (SEV_ALWAYS, 
                                          L"      WARNING:  This latency is over the Tombstone Lifetime of %d days!\n",
                                          pDsInfo->dwTombstoneLifeTimeDays);
                        }

                    }// if comparefiletime
                }//else { //uliSyncTime is non zero
            }//else ulOtherServer not found
        }//for (iCursor = 0; iCursor <  pCurors2->cNumCursors; iCursor++) {
 
        if (cRetiredInvocationId!=0 || cTimeStamp!=0 || cIgnoreReadOnlyReplicas!=0) {
            if (!fNCWarning) {
                PrintMessage( SEV_VERBOSE, L"   %s\n", pDsInfo->pNCs[ulNC].pszDn);
            }
            PrintMessage(SEV_VERBOSE, 
                         L"      Latency information for %d entries in the vector were ignored.\n", 
                         cRetiredInvocationId + cTimeStamp + cIgnoreReadOnlyReplicas);
            PrintMessage(SEV_VERBOSE,
                         L"         %d were retired Invocations.  %d were either: read-only replicas and are not verifiably latent, or dc's no longer replicating this nc.  %d had no latency information (Win2K DC).  \n",
                         cRetiredInvocationId,
                         cIgnoreReadOnlyReplicas,
                         cTimeStamp);
        }

        if (pCursors2 != NULL)  { DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_2_FOR_NC, pCursors2); }
        } //else
    } //for(ulNC=0;ulNC<pDsInfo->cNumNCs;ulNC++) {

    return ERROR_SUCCESS;
} //ReplicationsCheckLatency

BOOL
DcDiagHasNC(
    LPWSTR                           pszNC,
    PDC_DIAG_SERVERINFO              pServer,
    BOOL                             bMasters,
    BOOL                             bPartials
    )
/*++

Routine Description:

    Checks if the DC specified by pServer has the NC specified by pszNC.  The
    routine can check for read only, writeable or both, by bMasters & bPartials

Parameters:
    pszNC - IN is the NC to check for
    pServer - IN is the server to check
    bMasters - IN is true if you want to check for writeable copies of NCs
    bPartials - IN is true if you want to check for read only copies of NCs

Return Value:
  
    True if it found the NC in the right form (read only/writeable).
    Fales otherwise.

  --*/
{
    INT iTemp;

    if(pszNC == NULL){
        return TRUE;
    }

    // Make sure this is a server that has this NC.
    if(bMasters){
        if(pServer->ppszMasterNCs != NULL){
            for(iTemp = 0; pServer->ppszMasterNCs[iTemp] != NULL; iTemp++){
                if(_wcsicmp(pServer->ppszMasterNCs[iTemp], pszNC) == 0){
                    return TRUE;
                }

            } // end for loop cycling through MasterNCs for pServer
        }
    }

    if(bPartials){
        if(pServer->ppszPartialNCs != NULL){
            for(iTemp = 0; pServer->ppszPartialNCs[iTemp] != NULL; iTemp++){
                if(_wcsicmp(pServer->ppszPartialNCs[iTemp], pszNC) == 0){
                    return TRUE;
                }

            } // end for loop cycling through MasterNCs for pServer
        }
    }

    return FALSE;
}

BOOL DcDiagIsMasterForNC (
    PDC_DIAG_SERVERINFO          pServer,
    LPWSTR                       pszNC
    )
/*++

Routine Description:

Check that pServer is a master for the NC pszNC

Arguments:

    pServer - Server info block
    pszNC - String representation of NC

Return Value:

    TRUE or FALSE

--*/
{
    ULONG                        ulTemp;

    if (!pServer) {
        return FALSE;
    }

    if(pServer->ppszMasterNCs){
        for(ulTemp = 0; pServer->ppszMasterNCs[ulTemp] != NULL; ulTemp++) {  
            if (!_wcsicmp(pServer->ppszMasterNCs[ulTemp],pszNC)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

DWORD 
ReplReplicationsCheckMain (
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
{
    #define DsRRCMChkLdap(s,e)                                                      \
    {                                                                               \
        if ((dwWin32Err = LdapMapErrorToWin32 (e)) != NO_ERROR) {                  \
            PrintMessage(SEV_ALWAYS,                                                \
                         L"[%s,%s] An LDAP operation failed with error %d, %s.\n",  \
                         REPLICATIONS_CHECK_STRING,                                 \
                         pDsInfo->pServers[ulCurrTargetServer].pszName,             \
                         dwWin32Err,                                               \
                         Win32ErrToString(dwWin32Err));                   \
            PrintMessage(SEV_ALWAYS,                                                \
                         L"%s.\n",  \
                         Win32ErrToString(dwWin32Err));                   \
            __leave;                                                     \
        }                                                                           \
    }

    LPWSTR  ppszServerSearch [] = {
                                L"options",
                                NULL };
    LPWSTR  ppszDsServiceName [] = {
                L"dsServiceName",
                                NULL };

    LDAP *                      hld = NULL;
    HANDLE                      hDS = NULL;
    LDAPMessage *               pldmEntry;

    LDAPMessage *               pldmRootResults = NULL;
    LPWSTR *                    ppszServiceName = NULL;

    LDAPMessage *               pldmServerResults = NULL;
    LPWSTR *                    ppszOptions = NULL;
    LPWSTR *                    ppszMasterNCs = NULL;
    LPWSTR *                    ppszPartialReplicaNCs = NULL;
    //    LPWSTR *                      ppszNCs = NULL;

    LDAPMessage *               pldmNCResults = NULL;
    DS_REPL_NEIGHBORSW *        pNeighbors = NULL;
    DS_REPL_NEIGHBORW *         pNeighbor = NULL;
    DS_REPL_PENDING_OPSW *      pPendingOps = NULL;
    DS_REPL_CURSORS *           pCursors = NULL;
    

    DWORD                       dwWin32Err = NO_ERROR;
    BOOL                        bSkip;
    ULONG                       ulRepFrom;

    INT                         iNCType;
    BOOL                        bNCHasCursors;
    ULONG                       ulNC;
 
    // Check all connections in all NCs on all servers to see when the last
    // replication was and whether or not it was successful.
    // Also make sure LDAP is responding on all machines.

    //pDsInfo->pszNC may be NULL
    if(!DcDiagHasNC(pDsInfo->pszNC, &(pDsInfo->pServers[ulCurrTargetServer]), TRUE, TRUE)){
        // Skipping this server, because it doesn't contain the NC.
        IF_DEBUG( PrintMessage(SEV_VERBOSE, L"ReplicationsCheck: Skipping %s, because it doesn't hold NC %s\n",
                                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                                     pDsInfo->pszNC) );
        return ERROR_SUCCESS;
    }

    PrintMessage(SEV_VERBOSE, L"* Replications Check\n");
    
    __try {

        if((dwWin32Err = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                              gpCreds,
                                              FALSE,
                                              &hld)) != NO_ERROR){
            __leave;
        }
    
        DsRRCMChkLdap (pDsInfo->pServers[ulCurrTargetServer].pszName, ldap_search_sW (
                                      hld,
                                      NULL,
                                      LDAP_SCOPE_BASE,
                                      L"(objectCategory=*)",
                                      ppszDsServiceName,
                                      0,
                                      &pldmRootResults));
    
        pldmEntry = ldap_first_entry (hld, pldmRootResults);
        ppszServiceName = ldap_get_valuesW (hld, pldmEntry, L"dsServiceName");
    
        DsRRCMChkLdap (pDsInfo->pServers[ulCurrTargetServer].pszName, ldap_search_sW (
                                      hld,
                                      ppszServiceName[0],
                                      LDAP_SCOPE_BASE,
                                      L"(objectCategory=*)",
                                      ppszServerSearch,
                                      0,
                                      &pldmServerResults));
    
        pldmEntry = ldap_first_entry (hld, pldmServerResults);
        // Grab a fresh copy of the options to make sure they reflect
        // what this server actually believes.
        ppszOptions = ldap_get_valuesW (hld, pldmEntry, L"options");
        if (ppszOptions == NULL) pDsInfo->pServers[ulCurrTargetServer].iOptions = 0;
        else pDsInfo->pServers[ulCurrTargetServer].iOptions = atoi ((LPSTR) ppszOptions[0]);
    
        // Check if this server is disabling replications.
        bSkip = FALSE;
        if (pDsInfo->pServers[ulCurrTargetServer].iOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] Inbound replication is disabled.\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
            PrintMessage(SEV_ALWAYS,
                         L"To correct, run \"repadmin /options %s -DISABLE_INBOUND_REPL\"\n",
                                     pDsInfo->pServers[ulCurrTargetServer].pszName);
            bSkip = TRUE;
        }
        if (pDsInfo->pServers[ulCurrTargetServer].iOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] Outbound replication is disabled.\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
            PrintMessage(SEV_ALWAYS,
                         L"To correct, run \"repadmin /options %s -DISABLE_OUTBOUND_REPL\"\n",
                                     pDsInfo->pServers[ulCurrTargetServer].pszName);
            bSkip = TRUE;
        }
        if (pDsInfo->pServers[ulCurrTargetServer].iOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] Connection object translation is disabled.\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
            PrintMessage(SEV_ALWAYS,
                         L"To correct, run \"repadmin /options %s -DISABLE_NTDSCONN_XLATE\"\n",
                                     pDsInfo->pServers[ulCurrTargetServer].pszName);
            bSkip = TRUE;
        }
        if (bSkip) {
            dwWin32Err = ERROR_DS_NOT_SUPPORTED;
            __leave;
        }
    
        dwWin32Err = DcDiagGetDsBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                        gpCreds,
                                        &hDS);
        if (ERROR_SUCCESS != dwWin32Err) {
            __leave;
        }

        for (ulNC=0;ulNC<pDsInfo->cNumNCs;ulNC++) { 
            if (  !((pDsInfo->pszNC != NULL) && _wcsicmp(pDsInfo->pNCs[ulNC].pszDn,pDsInfo->pszNC)) 
                  &&
                  (DcDiagHasNC(pDsInfo->pNCs[ulNC].pszDn, &(pDsInfo->pServers[ulCurrTargetServer]), TRUE, TRUE))
                ) 
                //do not perform the test for this NC if:

                //the NC is specified on the command line and this NC is not the one specified
                //or
                //this NC doesn't exist on this server 
            
            { 
                dwWin32Err = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS,
                                               pDsInfo->pNCs[ulNC].pszDn, NULL, &pNeighbors);
                if (ERROR_SUCCESS != dwWin32Err) {
                    PrintMessage(SEV_ALWAYS,
                                 L"[%s,%s] DsReplicaGetInfo(NEIGHBORS,%s) failed with error %d,\n",
                                 REPLICATIONS_CHECK_STRING,
                                 pDsInfo->pServers[ulCurrTargetServer].pszName,
                                 pDsInfo->pNCs[ulNC].pszDn,
                                 dwWin32Err);
                    PrintMessage(SEV_ALWAYS, L"%s.\n",
                                 Win32ErrToString(dwWin32Err));
                    PrintRpcExtendedInfo(SEV_VERBOSE, dwWin32Err);
                    __leave;
                }
    
                // Check if NC has an up to date vector, since this will influence how efficient
                // its replication can be
                dwWin32Err = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC,
                                               pDsInfo->pNCs[ulNC].pszDn, NULL, &pCursors);
                if (ERROR_SUCCESS != dwWin32Err) {
                    PrintMessage(SEV_ALWAYS,
                                 L"[%s,%s] DsReplicaGetInfo(CURSORS,%s) failed with error %d,\n",
                                 REPLICATIONS_CHECK_STRING,
                                 pDsInfo->pServers[ulCurrTargetServer].pszName,
                                 pDsInfo->pNCs[ulNC].pszDn,
                                 dwWin32Err);
                    PrintMessage(SEV_ALWAYS, L"%s.\n",
                                 Win32ErrToString(dwWin32Err));
                    PrintRpcExtendedInfo(SEV_VERBOSE, dwWin32Err);
                    // Not fatal, keep going
                    bNCHasCursors = FALSE;
                } else {
                    // We always have atleast one for ourselves
                    PrintMessage( SEV_DEBUG, L"%s has %d cursors.\n",
                                  pDsInfo->pNCs[ulNC].pszDn, pCursors->cNumCursors );
                    bNCHasCursors = (pCursors->cNumCursors > 1);
                }

                // Walk through all the repsFrom neighbors ... then done.
                for (ulRepFrom = 0; ulRepFrom < pNeighbors->cNumNeighbors; ulRepFrom++) {
                    ReplicationsCheckRep (pDsInfo,
                                          gpCreds,
                                          ulCurrTargetServer,
                                          pNeighbors->rgNeighbor[ulRepFrom].pszNamingContext,
                                          bNCHasCursors,
                                          &pNeighbors->rgNeighbor[ulRepFrom] );
                } // Move on to the next neighbor

                if (pNeighbors != NULL) {
                    DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
                    pNeighbors = NULL;
                }
                if (pCursors != NULL) {
                    DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
                    pCursors = NULL;
                }
            }
        }

        // Check the replication queue on this guy as well
        dwWin32Err = DsReplicaGetInfoW(hDS, DS_REPL_INFO_PENDING_OPS, NULL, NULL,
                                       &pPendingOps);
        if (ERROR_SUCCESS != dwWin32Err) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] DsReplicaGetInfoW(PENDING_OPS) failed with error %d,\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName,
                         dwWin32Err);
            PrintMessage(SEV_ALWAYS, L"%s.\n",
                         Win32ErrToString(dwWin32Err));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwWin32Err);
            __leave;
        }

        ReplicationsCheckQueue( pDsInfo,
                                ulCurrTargetServer,
                                pPendingOps );

        //check the replication times for outstanding latencies on all nc's
        //do this for all nc's inside the following function
        dwWin32Err = ReplicationsCheckLatency( hDS, pDsInfo,    
                                               ulCurrTargetServer ); 
        if (ERROR_SUCCESS != dwWin32Err) {
            __leave;
        }

        // Check site latency.
        // We only check this in w2k mode since this is the only mode where the ISTG
        // keep alive is written.
        if (pDsInfo->dwForestBehaviorVersion < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS) {
            dwWin32Err = ReplicationsCheckSiteLatency( hld, pDsInfo,    
                                                ulCurrTargetServer ); 
            if (ERROR_SUCCESS != dwWin32Err) {
                __leave;
            }
        }
        
    } __finally {

        if (pldmNCResults != NULL)          ldap_msgfree (pldmNCResults);
        if (ppszPartialReplicaNCs != NULL)  ldap_value_freeW (ppszPartialReplicaNCs);
        if (ppszMasterNCs != NULL)          ldap_value_freeW (ppszMasterNCs);
        if (ppszOptions != NULL)            ldap_value_freeW (ppszOptions);
        if (pldmServerResults != NULL)      ldap_msgfree (pldmServerResults);
        if (ppszServiceName != NULL)        ldap_value_freeW (ppszServiceName);
        if (pldmRootResults != NULL)        ldap_msgfree (pldmRootResults);
        if (pNeighbors != NULL)             DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
        if (pPendingOps != NULL)            DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        if (pCursors != NULL)               DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        

    } // end exception handler
    return dwWin32Err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dscntl\dscntl.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    dscntl.c

Abstract:

Author:

    Colin Brace (ColinBr) 21-Jan-98

Environment:

    User Mode - Win32

Revision History:

    21-Jan-1997 ColinBr
        Created initial file.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>

#include <ntdsapi.h>    

//
// Forward decl's
//
VOID
GetWinErrorMessage(
    IN  DWORD WinError,
    OUT LPSTR *WinMsg
    );

//
// Small helper routines
//
void
Usage(
    VOID
    )
{
    printf("dscntl is a command line utility used to perform control operations\n");
    printf("on a directory service.\n" );
    printf("\nOptions\n\n");
    printf("-s      the target server on which to perform the operation(s).\n");
    printf("-rs     specifies the server to remove.\n");
    printf("-rd     specifies the domain to remove.\n");
    printf("-commit indicates whether to commit the changes.\n");

    exit( ERROR_INVALID_PARAMETER );
}

//
// Executable entry point
//
int _cdecl 
main(
    int   argc, 
    char  *argv[]
    )
{

    int   Index;
    int   WinError = ERROR_SUCCESS;
    char  *Option;

    HANDLE hDs = 0;

    LPSTR Server           = NULL;
    LPSTR RemoveServerDN   = NULL;
    LPSTR RemoveDomainDN   = NULL;
    BOOL  fCommit          = FALSE;

    for ( Index = 1; Index < argc; Index++ )
    {
        Option = argv[Index];

        if ( *Option == '/' || *Option == '-' )
        {
            Option++;
        }

        if ( !_strnicmp( Option, "s", 1 ) )
        {
            Option++;
            if ( *Option == ':' ) {
                Option++;
            }
            if ( *Option == '\0' ) {
                Index++;
                Server = argv[Index];
            } else {
                Server = Option;
            }
        }
        else if ( !_strnicmp( Option, "rs", 2 )  )
        {
            Option += 2;
            while ( *Option == ':' ) {
                Option++;
            }
            if ( *Option == '\0' ) {
                Index++;
                RemoveServerDN = argv[Index];
            } else {
                RemoveServerDN = Option;
            }
        }
        else if ( !_strnicmp( Option, "rd", 2 )  )
        {
            Option += 2;
            while ( *Option == ':' ) {
                Option++;
            }
            if ( *Option == '\0' ) {
                Index++;
                RemoveDomainDN = argv[Index];
            } else {
                RemoveDomainDN = Option;
            }
        }
        else if ( !_stricmp( Option, "commit" )  )
        {
            fCommit = TRUE;
        }
        else
        {
            Usage();
        }
        
    }

    if ( !Server )
    {
        Usage();
    }

    //
    // Get a server handle
    //
    WinError = DsBindA( Server,
                        NULL,   // domain name
                        &hDs );

    if ( ERROR_SUCCESS != WinError )
    {
        printf( "Unable to establish a connection with %s because error %d occurred.\n",
                 Server, WinError );
        goto ErrorCase;
    }


    if ( RemoveServerDN )
    {

        BOOL fLastDcInDomain = FALSE;

        WinError = DsRemoveDsServerA( hDs,
                                      RemoveServerDN,
                                      RemoveDomainDN,
                                      &fLastDcInDomain,
                                      fCommit );

        if ( ERROR_SUCCESS != WinError )
        {
            printf( "The remove server operation failed with %d.\n", WinError );
            goto ErrorCase;
        }
        else
        {
            if ( RemoveDomainDN )
            {
                if ( fLastDcInDomain )
                {
                    printf( "The dsa %s is the last dc in domain %s\n", 
                            RemoveServerDN, RemoveDomainDN );
                }
                else
                {
                    printf( "The dsa %s is not the last dc in domain %s\n", 
                             RemoveServerDN, RemoveDomainDN );
                }
            }
    
            printf( "The dsa %s has been removed successfully.\n", RemoveServerDN );
        }
    }

    if ( !RemoveServerDN && RemoveDomainDN )
    {

        WinError = DsRemoveDsDomainA( hDs,
                                      RemoveDomainDN );
        
        if ( ERROR_SUCCESS != WinError )
        {
            printf( "The remove server operation failed with %d.\n", WinError );
            goto ErrorCase;
        }
        else
        {
            printf( "The domain %s has been removed successfully.\n", RemoveDomainDN );
        }

        goto ErrorCase;
    }


ErrorCase:

    if ( hDs )
    {
        DsUnBind( hDs );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        printf( "\nThe command completely successfully.\n" );
    }
    else
    {
        LPSTR Tmp;

        GetWinErrorMessage( WinError, &Tmp );

        printf( "\nError %d: %s\n", WinError, Tmp );
        LocalFree( Tmp );

    }

    return WinError;

}

VOID
GetWinErrorMessage(
    IN  DWORD WinError,
    OUT LPSTR *WinMsg
    )
{
    LPSTR   DefaultMessageString = "Unknown failure";
    ULONG   Size = sizeof( DefaultMessageString ) + sizeof(char);
    LPSTR   MessageString = NULL;
    ULONG   Length;

    Length = (USHORT) FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_FROM_SYSTEM ,
                                      NULL, // ResourceDll,
                                      WinError,
                                      0,       // Use caller's language
                                      (LPSTR)&MessageString,
                                      0,       // routine should allocate
                                      NULL );
    if ( MessageString )
    {
        // Messages from a message file have a cr and lf appended
        // to the end
        MessageString[Length-2] = L'\0';
        Size = ( Length + 1) * sizeof(char);
    }

    if ( !MessageString )
    {
        MessageString = DefaultMessageString;
    }

    if ( WinMsg )
    {
        *WinMsg = ( LPSTR ) LocalAlloc( 0, Size );
        if ( *WinMsg )
        {
            strcpy( (*WinMsg), MessageString );
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\repl\topology.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    topology.c

ABSTRACT:

    Contains tests related to the replication topology.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)
    08 Sep 1999 Completely re-written to use tool framework services

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include "dcdiag.h"
#include "repl.h"


void
printUnreachableServers(
    IN PDC_DIAG_DSINFO pDsInfo,
    PDS_REPSYNCALL_ERRINFOW *apErrInfo
    )

/*++

Routine Description:

Helper routine to print the unreachable servers

Arguments:

    pDsInfo - 
    apErrInfo - 

Return Value:

    None

--*/

{
    DWORD i, dwServer;
    LPWSTR pszName, pszSite;

    PrintIndentAdj(1);
    for (i = 0; apErrInfo[i] != NULL; i++){
        dwServer = DcDiagGetServerNum(
            pDsInfo, NULL, NULL, apErrInfo[i]->pszSvrId, NULL, NULL );
        if (dwServer == NO_SERVER) {
            pszSite = L"unknown";
            pszName = apErrInfo[i]->pszSvrId;
        } else {
            pszSite = pDsInfo->pSites[pDsInfo->pServers[dwServer].iSite].pszName;
            pszName = pDsInfo->pServers[dwServer].pszName;
        }
        switch (apErrInfo[i]->error) {
        case DS_REPSYNCALL_SERVER_UNREACHABLE:
            PrintMessage(SEV_ALWAYS, L"%s/%s\n", pszSite, pszName );
            break;
        }
    }
    PrintIndentAdj( -1 );
} /* printUnreachableServers */


BOOL
errorIndicatesDisconnected(
    PDS_REPSYNCALL_ERRINFOW *apErrInfo
    )

/*++

Routine Description:

Helper routine to determine if there are any unreachable server errors
in the error array

Arguments:

    apErrInfo - 

Return Value:

    BOOL - 

--*/

{
    DWORD i;
    BOOL bDisconnected = FALSE;

    // Are any nodes unreachable?
    if (apErrInfo) {
        for( i = 0; apErrInfo[i] != NULL; i++ ) {
            if (apErrInfo[i]->error == DS_REPSYNCALL_SERVER_UNREACHABLE) {
                bDisconnected = TRUE;
                break;
            }
        }
    }
    return bDisconnected;
} /* errorIndicatesDisconnected */


DWORD
checkTopologyOneNc(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN HANDLE hDS,
    IN PDC_DIAG_SERVERINFO pTargetServer,
    IN BOOL fAlivenessCheck,
    IN LPWSTR pszNc
    )

/*++

Routine Description:

Check the topology of one naming context.  The DsReplicaSyncAll api is used
to check for unreachable servers.

There are two modes to this check, depending on whether aliveness should
be considered when calculating servers that cannot be reached by the
replication topology.

Without the aliveness check, this test becomes purely a question of whether
the KCC build a connected set of connections, regardless of the current
state of the systems.

Arguments:

    pDsInfo - Global tool data
    hDS - Handle to current server
    pTargetServer - Current server info structure
    fCheckAliveness - Whether aliveness should be taken into account
    pszNc - NC being checked

Return Value:

    DWORD - 

--*/

{
    DWORD status, dwFlags, worst = ERROR_SUCCESS;
    PDS_REPSYNCALL_ERRINFOW *apErrInfo = NULL;

    // Standard flags for all cases
    dwFlags =
        DS_REPSYNCALL_ID_SERVERS_BY_DN;

    // Search intersite if requested
    if (gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE) {
        dwFlags |=
            DS_REPSYNCALL_CROSS_SITE_BOUNDARIES;
    }

    if (fAlivenessCheck) {
        PrintMessage(SEV_VERBOSE,
                     L"* Analyzing the alive system replication topology for %s.\n",
                     pszNc);
    } else {
        PrintMessage(SEV_VERBOSE, L"* Analyzing the connection topology for %s.\n",
                     pszNc);
        dwFlags |= DS_REPSYNCALL_SKIP_INITIAL_CHECK;
    }

//
// Upstream analysis: Whose changes can't I receive?
//

    PrintMessage(SEV_VERBOSE, L"* Performing upstream (of target) analysis.\n" );
    status = DsReplicaSyncAllW (
        hDS,
        pszNc,
        dwFlags,
        NULL,		// No callback function
        NULL,		// No parameter to callback function
        &apErrInfo
        );
    if (ERROR_SUCCESS != status) {
        PrintMessage( SEV_ALWAYS,
                      L"DsReplicaSyncAllW failed with error %ws.\n",
                      Win32ErrToString(status) );
        PrintRpcExtendedInfo(SEV_VERBOSE, status);
    }

    if (errorIndicatesDisconnected( apErrInfo )) {
        PrintMessage(SEV_ALWAYS,
                     L"Upstream topology is disconnected for %ws.\n",
                     pszNc);
        PrintMessage(SEV_ALWAYS,
                     L"Home server %ws can't get changes from these servers:\n",
                     pTargetServer->pszName );
        printUnreachableServers( pDsInfo, apErrInfo );
        worst = ERROR_DS_GENERIC_ERROR;
    } // if disconneced

    if (apErrInfo != NULL) {
        LocalFree (apErrInfo);
        apErrInfo = NULL;
    }

    //
    // Downstream analysis: who can't receive my changes?
    //

    dwFlags |= DS_REPSYNCALL_PUSH_CHANGES_OUTWARD;

    PrintMessage(SEV_VERBOSE, L"* Performing downstream (of target) analysis.\n" );

    status = DsReplicaSyncAllW (
        hDS,
        pszNc,
        dwFlags,
        NULL,		// No callback function
        NULL,		// No parameter to callback function
        &apErrInfo
        );
    if (ERROR_SUCCESS != status) {
        PrintMessage( SEV_ALWAYS,
                      L"DsReplicaSyncAllW failed with error %ws.\n",
                      Win32ErrToString(status) );
        PrintRpcExtendedInfo(SEV_VERBOSE, status);
    }

    if (errorIndicatesDisconnected( apErrInfo )) {
        PrintMessage(SEV_ALWAYS,
                     L"Downstream topology is disconnected for %ws.\n",
                     pszNc);
        PrintMessage(SEV_ALWAYS,
                     L"These servers can't get changes from home server %ws:\n",
                     pTargetServer->pszName );
        printUnreachableServers( pDsInfo, apErrInfo );
        worst = ERROR_DS_GENERIC_ERROR;
    } // if disconneced

// cleanup      
    if (apErrInfo != NULL) {
        LocalFree (apErrInfo);
        apErrInfo = NULL;
    }

    return worst;
} /* checkTopologyOneNc */


DWORD
checkTopologyHelp(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN PDC_DIAG_SERVERINFO pTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * pCreds,
    IN BOOL fAlivenessCheck
    )

/*++

Routine Description:

Helper routine with common code for both tests: the pure topology test, and the
cutoff server test.

Arguments:

    pDsInfo - common tool state
    pTargetServer - server information for target server
    pCreds - credentials
    fAlivenessCheck - Whether aliveness should be taken into account

Return Value:

    DWORD - 

--*/

{
    DWORD status, i, worst = ERROR_SUCCESS;
    HANDLE hDS = NULL;

    // Bind to the source server if it is up
    status = DcDiagGetDsBinding(pTargetServer,
                                pCreds,
                                &hDS);
    if (ERROR_SUCCESS != status) {
        PrintMessage( SEV_ALWAYS,
                      L"Failed to bind to %ws: %ws.\n",
                      pTargetServer->pszName,
                      Win32ErrToString(status) );
        PrintRpcExtendedInfo(SEV_VERBOSE, status);
        return status;
    }

    if (pDsInfo->pszNC) {
        // Explicit NC specified: use it
        worst = checkTopologyOneNc( pDsInfo,
                                    hDS,
                                    pTargetServer,
                                    fAlivenessCheck,
                                    pDsInfo->pszNC );
    } else {
        // No NC specified, check all of them

        // Check writable connection topology
        if(pTargetServer->ppszMasterNCs){
            for(i = 0; pTargetServer->ppszMasterNCs[i] != NULL; i++){
                status = checkTopologyOneNc( pDsInfo,
                                             hDS,
                                             pTargetServer,
                                             fAlivenessCheck,
                                             pTargetServer->ppszMasterNCs[i]);
                if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
                    worst = status;
                }
            }
        }

        // Check partial connection topology
        if(pTargetServer->ppszPartialNCs){
            for(i = 0; pTargetServer->ppszPartialNCs[i] != NULL; i++){
                status = checkTopologyOneNc( pDsInfo,
                                             hDS,
                                             pTargetServer,
                                             fAlivenessCheck,
                                             pTargetServer->ppszPartialNCs[i]);
                if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
                    worst = status;
                }
            }
        }
    }

    return worst;
} /* checkTopologyHelp */


DWORD
ReplToplIntegrityMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

Top level routine for "topology integrity" test.

This test verifies whether the topology is connected if we assume all
systems are up.  It is a KCC verification.

Arguments:

    pDsInfo - Common state
    ulCurrTargetServer - index of target
    pCreds - Credentials

Return Value:

    DWORD - 

--*/

{
    DWORD status, i, worst = ERROR_SUCCESS;
    PDC_DIAG_SERVERINFO pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);

    PrintMessage(SEV_VERBOSE, L"* Configuration Topology Integrity Check\n");

    // Is inter/intrasite topology generation off?
    if(pDsInfo->pSites[pTargetServer->iSite].iSiteOptions
       & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED){
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] Intra-site topology generation is disabled in this site.\n",
                     TOPOLOGY_INTEGRITY_CHECK_STRING,
                     pTargetServer->pszName);
    }
    if(pDsInfo->pSites[pTargetServer->iSite].iSiteOptions
       & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED){
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] Inter-site topology generation is disabled in this site.\n",
                     TOPOLOGY_INTEGRITY_CHECK_STRING,
                     pTargetServer->pszName);
    }

    // Check topology

    worst = checkTopologyHelp(
        pDsInfo,
        pTargetServer,
        pCreds,
        FALSE // connectivity check only
        );

    return worst;
} /* ReplToplIntegrityMain */


DWORD
ReplToplCutoffMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

Top-level routine for "Cutoff server topology" test.

This test identifies those servers that cannot receive changes because servers
are down in the topology.

Arguments:

    pDsInfo - 
    ulCurrTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, i, worst = ERROR_SUCCESS;
    HANDLE hDS = NULL;
    PDC_DIAG_SERVERINFO pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);

    PrintMessage(SEV_VERBOSE, L"* Configuration Topology Aliveness Check\n");

    worst = checkTopologyHelp(
        pDsInfo,
        pTargetServer,
        pCreds,
        TRUE // aliveness check
        );

    return worst;
} /* ReplToplCutoffMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\atq.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    atq.cxx

Abstract:

    Dump functions for types used by private\security\kerberos\atqnew.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    13-July-99   RRandall     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop

extern "C" {

#include "dsexts.h"
}
#include <isatq.hxx>

#define DPRINT4(_x,_a,_b,_c,_d,_e)
#define Assert(_x)  
#undef new
#undef delete


BOOL
Dump_ATQ_CONTEXT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ATQCONTEXT dump routine.  

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ATQ_ENDPOINT in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    ATQ_CONTEXT     *pAtqContextd, *pAtqCon;

    Printf("%sATQ_CONTEXT:\n", Indent(nIndents));
    nIndents++;

    if (NULL != (pAtqContextd = (ATQ_CONTEXT *)ReadMemory(pvProcess, sizeof(ATQ_CONTEXT)))) {
        pAtqCon = (ATQ_CONTEXT *)pvProcess;

        Printf("%shAsyncIO       = 0x%x\n", Indent(nIndents), pAtqContextd->hAsyncIO);

        Printf("%sOverlapped      @ %p\n", Indent(nIndents), &pAtqCon->Overlapped);
        Printf("%sOverlapped->Internal = 0x%x\n", Indent(nIndents), pAtqContextd->Overlapped.Internal);
        Printf("%sSignature      = %x\n", Indent(nIndents), pAtqContextd->Signature);
        Printf("\n");
        Printf("%sm_acState      = %x\n", Indent(nIndents), pAtqContextd->m_acState);
        Printf("%sm_acFlags      = %x\n", Indent(nIndents), pAtqContextd->m_acFlags);
        Printf("\n");
        Printf("%spEndpoint       @ %p\n", Indent(nIndents), pAtqContextd->pEndpoint);
        Printf("%sContextList     @ %p\n", Indent(nIndents), pAtqContextd->ContextList);
        Printf("%sClientContext   @ %p\n", Indent(nIndents), pAtqContextd->ClientContext);
        Printf("%spfnCompletion   @ %p\n", Indent(nIndents), pAtqContextd->pfnCompletion);
        Printf("\n");
        Printf("%slSyncTimeout   = %x\n", Indent(nIndents), pAtqContextd->lSyncTimeout);
        Printf("%sTimeOut        = %x\n", Indent(nIndents), pAtqContextd->TimeOut);
        Printf("%sNextTimeout    = %x\n", Indent(nIndents), pAtqContextd->NextTimeout);
        Printf("%sTimeOutScanID  = %x\n", Indent(nIndents), pAtqContextd->TimeOutScanID);
        Printf("\n");
        Printf("%sBytesSent      = %x\n", Indent(nIndents), pAtqContextd->BytesSent);
        Printf("%spvBuff          @ %p\n", Indent(nIndents), pAtqContextd->pvBuff);
        Printf("%sm_nIO          = %x\n", Indent(nIndents), pAtqContextd->m_nIO);
        Printf("\n");
        Printf("%sfDatagramContext = %s\n", Indent(nIndents), pAtqContextd->fDatagramContext ? "TRUE" : "FALSE");
        Printf("%sAddressInformation @ %p\n", Indent(nIndents), pAtqContextd->AddressInformation);
        Printf("%sAddressLength  = %x\n", Indent(nIndents), pAtqContextd->AddressLength);
        
        FreeMemory(pAtqContextd);
        fSuccess = TRUE;
    }

    return fSuccess;
}


BOOL
Dump_ATQ_ENDPOINT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ATQ_ENDPOINT dump routine.  

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ATQ_ENDPOINT in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    PATQ_ENDPOINT   pEndpointd;

    Printf("%sATQ_ENDPOINT:\n", Indent(nIndents));
    nIndents++;

    if (NULL != (pEndpointd = (PATQ_ENDPOINT)ReadMemory(pvProcess, sizeof(ATQ_ENDPOINT)))) {

        Printf("%sSignature       = 0x%x\n", Indent(nIndents), pEndpointd->Signature);
        Printf("\n");
        Printf("%sm_refCount      = 0x%x\n", Indent(nIndents), pEndpointd->m_refCount);
        Printf("%sState           = 0x%x\n", Indent(nIndents), pEndpointd->State);
        Printf("\n");
        Printf("%sUseAcceptEx     = %s\n", Indent(nIndents), pEndpointd->UseAcceptEx ? "TRUE" : "FALSE");
        Printf("%sfDatagram       = %s\n", Indent(nIndents), pEndpointd->fDatagram ? "TRUE" : "FALSE");
        Printf("%sfExclusive      = %s\n", Indent(nIndents), pEndpointd->fExclusive ? "TRUE" : "FALSE");
        Printf("\n");
        Printf("%snSocketsAvail   = 0x%x\n", Indent(nIndents), pEndpointd->nSocketsAvail);
        Printf("%sInitialRecvSize = 0x%x\n", Indent(nIndents), pEndpointd->InitialRecvSize);
        Printf("%sListenSocket        @ %p\n", Indent(nIndents), &pEndpointd->ListenSocket);
        Printf("\n");
        Printf("%sConnectCompletion   @ %p\n", Indent(nIndents), pEndpointd->ConnectCompletion);
        Printf("%sConnectExCompletion @ %p\n", Indent(nIndents), pEndpointd->ConnectExCompletion);
        Printf("%sIoCompletion        @ %p\n", Indent(nIndents), pEndpointd->IoCompletion);
        Printf("\n");
        Printf("%sContext             @ %p\n", Indent(nIndents), pEndpointd->Context);
        Printf("%sShutdownCallback    @ %p\n", Indent(nIndents), pEndpointd->ShutdownCallback);
        Printf("%sShutdownCallbackContext @ %p\n", Indent(nIndents), pEndpointd->ShutdownCallbackContext);
        Printf("%spListenAtqContext   @ %p\n", Indent(nIndents), pEndpointd->pListenAtqContext);
        Printf("\n");
        Printf("%shListenThread   = 0x%x\n", Indent(nIndents), pEndpointd->hListenThread);
        Printf("%sPort            = %d\n", Indent(nIndents), pEndpointd->Port);
        Printf("%sIpAddress       = 0x%x\n", Indent(nIndents), pEndpointd->IpAddress);
        Printf("%sAcceptExTimeout = 0x%x\n", Indent(nIndents), pEndpointd->AcceptExTimeout);
        Printf("%snAcceptExOutstanding = 0x%x\n", Indent(nIndents), pEndpointd->nAcceptExOutstanding);
        Printf("%sfAddingSockets  = %s\n", Indent(nIndents), pEndpointd->fAddingSockets ? "TRUE" : "FALSE");
        Printf("%snAvailDuringTimeOut  = 0x%x\n", Indent(nIndents), pEndpointd->nAvailDuringTimeOut);
        Printf("%sConsumerType    = 0x%x\n", Indent(nIndents), pEndpointd->ConsumerType);

        FreeMemory(pEndpointd);
        fSuccess = TRUE;
    }

    return fSuccess;
}



BOOL
Dump_ATQC_ACTIVE_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Give a pointer to the global list of ATQ_CONTEXT's dumps the active portion of the list.  
    This is made difficult by the fact that there are really multiple lists.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of AtqActiveContextList in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                   fSuccess = FALSE;
    DWORD                  i, j = 0;
    PATQ_ENDPOINT          pEndpoint;
    PATQ_CONT              pAtqContext, pAtqCon;
    PATQ_CONTEXT_LISTHEAD  pContListHead;
    PVOID                  pTmp;
    LIST_ENTRY             *pListHead, pListEntry;

    if (NULL != (pContListHead = (PATQ_CONTEXT_LISTHEAD)ReadMemory(pvProcess, (ATQ_NUM_CONTEXT_LIST * sizeof(ATQ_CONTEXT_LISTHEAD))))) {
        for (i = 0; i < ATQ_NUM_CONTEXT_LIST; i++) {
            pListHead = &(pContListHead[i].ActiveListHead); 
            pTmp = pListHead->Flink;
            pListHead = &(((PATQ_CONTEXT_LISTHEAD)pvProcess)[i].ActiveListHead);
            while (pTmp != pListHead) {
                // Get the address of the ATQ_CONTEXT in the process space.
                pAtqCon = CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout);
                Printf("%sATQ_CONTEXT @ %p\n", Indent(nIndents), pAtqCon);
                nIndents++; j++;

                // Convert to this memory space.
                pAtqContext = (PATQ_CONT)ReadMemory(pAtqCon, sizeof(ATQ_CONTEXT));
                if (pAtqContext && 
                    pAtqContext->pEndpoint && 
                    (pEndpoint = (PATQ_ENDPOINT)ReadMemory(pAtqContext->pEndpoint, sizeof(ATQ_ENDPOINT)))) {

                    Printf("%sfDatagramContext = %s\n", Indent(nIndents), pAtqContext->fDatagramContext ? "TRUE" : "FALSE");
                    Printf("%sSignature     = 0x%x\n", pAtqContext->Signature);
                    Printf("%shAsyncIO      = %x\n", Indent(nIndents), pAtqContext->hAsyncIO);
                    Printf("%sOverlapped      @ %p\n", Indent(nIndents), &pAtqCon->Overlapped);
                    Printf("%sOverlapped->Internal = 0x%x\n", Indent(nIndents), pAtqContext->Overlapped.Internal);
                    Printf("%spEndpoint     @ %p\n", Indent(nIndents), pAtqContext->pEndpoint);
                    Printf("%spfnCompletion @ %p\n", Indent(nIndents), pAtqContext->pfnCompletion);

                    // Get the some info from the associated ATQ_ENDPOINT so that we have a better
                    // idea what this context is for.
                    pEndpoint = (PATQ_ENDPOINT)ReadMemory(pAtqContext->pEndpoint, sizeof(ATQ_ENDPOINT));
                    if (pEndpoint) {
                        Printf("%sEndpoint info:\n", Indent(nIndents));
                        nIndents++;
                        Printf("%sPort            = %d\n", Indent(nIndents), pEndpoint->Port);
                        Printf("%sListenSocket    = 0x%x\n", Indent(nIndents), &pEndpoint->ListenSocket);
                        Printf("%sfDatagram       = %s\n", Indent(nIndents), pEndpoint->fDatagram ? "TRUE" : "FALSE");
                        nIndents--;
                        FreeMemory(pEndpoint);
                        pEndpoint = NULL;
                    } else {
                        Printf("%sEndpoint info NOT AVAILABLE.\n", Indent(nIndents));
                    }

                    nIndents--;                  
                } else {
                    nIndents--;
                    Printf("%sFAILED TO READ ATQ_CONTEXT @ %p\n", Indent(nIndents), CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout));
                    break;
                }
                Printf("\n");
                pTmp = pAtqContext->m_leTimeout.Flink;
                FreeMemory(pAtqContext);
                if (1000 < j) {
                    Printf("%sASSUMING LOOP:Since 1000 ATQ_CONTEXTS were printed, assuming this is a loop and quiting.\n",
                        Indent(nIndents));
                    break;
                }
            }

        }

        FreeMemory(pContListHead);
        fSuccess = TRUE;
    }

    return fSuccess;

}



BOOL
Dump_ATQC_PENDING_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Give a pointer to the global list of ATQ_CONTEXT's dumps the pending AcceptEx portion of the list.  
    This is made difficult by the fact that there are really multiple lists.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of AtqActiveContextList in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                   fSuccess = FALSE;
    DWORD                  i, j = 0;
    PATQ_ENDPOINT          pEndpoint;
    PATQ_CONT              pAtqContext, pAtqCon;
    PATQ_CONTEXT_LISTHEAD  pContListHead;
    PVOID                  pTmp;
    LIST_ENTRY             *pListHead, pListEntry;

    if (NULL != (pContListHead = (PATQ_CONTEXT_LISTHEAD)ReadMemory(pvProcess, (ATQ_NUM_CONTEXT_LIST * sizeof(ATQ_CONTEXT_LISTHEAD))))) {
        for (i = 0; i < ATQ_NUM_CONTEXT_LIST; i++) {
            pListHead = &(pContListHead[i].PendingAcceptExListHead); 
            pTmp = pListHead->Flink;
            pListHead = &(((PATQ_CONTEXT_LISTHEAD)pvProcess)[i].PendingAcceptExListHead);
            while (pTmp != pListHead) {
                // Get the address of the ATQ_CONTEXT in the process space.
                pAtqCon = CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout);
                Printf("%sATQ_CONTEXT @ %p\n", Indent(nIndents), pAtqCon);
                nIndents++;
                j++;

                // Convert to this memory space.
                pAtqContext = (PATQ_CONT)ReadMemory(pAtqCon, sizeof(ATQ_CONTEXT));
                if (pAtqContext) {
                    Printf("%sfDatagramContext = %s\n", Indent(nIndents), pAtqContext->fDatagramContext ? "TRUE" : "FALSE");
                    Printf("%sSignature     = 0x%x\n", Indent(nIndents), pAtqContext->Signature);
                    Printf("%shAsyncIO      = %x\n", Indent(nIndents), pAtqContext->hAsyncIO);
                    Printf("%sOverlapped      @ %p\n", Indent(nIndents), &pAtqCon->Overlapped);
                    Printf("%sOverlapped->Internal = 0x%x\n", Indent(nIndents), pAtqContext->Overlapped.Internal);
                    Printf("%spEndpoint     @ %p\n", Indent(nIndents), pAtqContext->pEndpoint);
                    Printf("%spfnCompletion @ %p\n", Indent(nIndents), pAtqContext->pfnCompletion);

                    // Get the some info from the associated ATQ_ENDPOINT so that we have a better
                    // idea what this context is for.
                    if (pAtqContext->pEndpoint && (pEndpoint = (PATQ_ENDPOINT)ReadMemory(pAtqContext->pEndpoint, sizeof(ATQ_ENDPOINT)))) {
                        Printf("%sEndpoint info:\n", Indent(nIndents));
                        nIndents++;
                        Printf("%sPort            = %d\n", Indent(nIndents), pEndpoint->Port);
                        Printf("%sListenSocket    = 0x%x\n", Indent(nIndents), &pEndpoint->ListenSocket);
                        Printf("%sfDatagram       = %s\n", Indent(nIndents), pEndpoint->fDatagram ? "TRUE" : "FALSE");
                        nIndents--;
                        FreeMemory(pEndpoint);
                        pEndpoint = NULL;
                    } else {
                        Printf("%sEndpoint info NOT AVAILABLE.\n", Indent(nIndents));
                    }

                    nIndents--;                  
                } else {
                    nIndents--;
                    Printf("%sFAILED TO READ ATQ_CONTEXT @ %p\n", Indent(nIndents), CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout));
                    break;
                }
                Printf("\n");
                pTmp = pAtqContext->m_leTimeout.Flink;
                FreeMemory(pAtqContext);
                if (1000 < j) {
                    Printf("%sASSUMING LOOP:Since 1000 ATQ_CONTEXTS were printed, assuming this is a loop and quiting.\n",
                        Indent(nIndents));
                    break;
                }
            }

        }

        FreeMemory(pContListHead);
        fSuccess = TRUE;
    }

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dnsresl\dns.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    dnsresl - DNS Resolution Library

Abstract:

    This is a library to do DNS hostresolution and return a stringized IP using winsock2 functions
    instead of gethostbyname().

Author:

    BrettSh   14-May-1999

Environment:

    any environment, it does need Assert()s though

Revision History:

--*/

#include <ntdspch.h>
#include <winsock2.h>
#include <svcguid.h>
#include <dnsresl.h>

#include <debug.h>
#include <dsexcept.h>

#include <fileno.h>
#define FILENO FILENO_UTIL_DNSRESL_DNS		

DWORD
GetIpAddrByDnsNameHelper(
    IN     LPWSTR             pszHostName,
    OUT    LPWSTR             pszIP,
    IN OUT INT *              piQueryBufferSize,
    OUT    WSAQUERYSETW *     pQuery)
/*++

Description:

    This is a helper function for GetIpAddrByDnsNameW, solely for the purpose of avoiding code dupication.  This
    function is basically wrapped by the real function which takes care of memory allocations of pQuery.

Arguments:

    pszHostName (IN) - Host Name to resolve.

    pszIP (OUT) - The pszIP string to ... it should be a WCHAR array of at least IPADDRSTR_SIZE size.

    piQueryBufferSize (IN/OUT) - This is the size of the pQuery buffer that was passed in.  If the pQuery
          buffer isn't big enough, then this var will be set to a buffer of the requisite size.

    pQuery (IN) - This is just a empty buffer that is guaranteed to be piQueryBufferSize

Return value:

    dwRet - If there is no error then NO_ERROR will be returned, and pszIP will have a wchar 
    stringized IP in it.  If WSAEFAULT is returned, then piQueryBufferSize will have the needed
    size in it.  All other cases are just various errors winsock, MultiByteToWideChar, or 
    inet_ntoa might cause us to have.

    Note there are actually pQuery->dwNumberOfCsAddrs IP addresses in pQuery->lpcsaBuffer[]:
    I am just using the first one, because I do not know better.  Everything I tested this on
    only returned one IP address though.
    pTemp = (struct sockaddr_in *) pQuery->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

--*/
{
    HANDLE                      handle = NULL;
    GUID                        ServiceClass = SVCID_HOSTNAME;
    DWORD                       dwRet = NO_ERROR;
    CHAR *                      pszTemp;
    struct sockaddr_in *        pTemp;

    // Initialize things.
    pszIP[0] = L'\0'; // Just in case no IP.
    memset(pQuery, 0, *piQueryBufferSize);
    pQuery->lpszServiceInstanceName =  pszHostName;
    pQuery->dwNameSpace = NS_ALL;
    pQuery->dwSize = sizeof(WSAQUERYSETW);
    pQuery->lpServiceClassId = &ServiceClass;

    __try{

        // Begin the name lookup process
        if(WSALookupServiceBeginW(pQuery, LUP_RETURN_ADDR, &handle) == SOCKET_ERROR){
            dwRet = WSAGetLastError();
            Assert(dwRet != WSAEFAULT);
            __leave;
        }

        if(WSALookupServiceNextW(handle, 0, piQueryBufferSize, pQuery) != SOCKET_ERROR){
            // take care of the ip address.
            if(pQuery->dwNumberOfCsAddrs >= 1){

                Assert(pQuery->lpcsaBuffer != NULL);
                pTemp = (struct sockaddr_in *) pQuery->lpcsaBuffer->RemoteAddr.lpSockaddr;
                Assert(pTemp);
                Assert(sizeof(pTemp->sin_addr)==4); // If this fails, then no longer IPv4?
                
                // Code.Improvement could check to make sure the IP address isn't 0.

                pszTemp = inet_ntoa(pTemp->sin_addr);
                if(pszTemp == NULL || '\0' == pszTemp[0]){
                    dwRet = ERROR_INVALID_PARAMETER;
                    __leave;
                }
                if(MultiByteToWideChar(CP_UTF8, 0, pszTemp, -1, pszIP, IPADDRSTR_SIZE) != 0){
                    // SUCCESS  HOORAY.  RAH RAH GO TEAM!
                    dwRet = NO_ERROR;
                    // we could use __leave or just fall out ... wonder which is more efficient?
                } else {
                    dwRet = GetLastError();
                    __leave;
                }
            } else {
                Assert(!"There are no IP addresses returned from a successful WSALookupServiceNextW() call? Why?");
                dwRet = ERROR_DS_DNS_LOOKUP_FAILURE;
                __leave;
            } // if/else has IP address in the returned Query Set

        } else {
            // There was some kind of error on lookup.
            dwRet = WSAGetLastError();
            __leave;
        }

    } __finally {
        if(handle != NULL) {
            if(WSALookupServiceEnd(handle) == SOCKET_ERROR) Assert(!"Badness\n");
        }
    }

    return(dwRet);
} // end GetIpAddrByDnsNameHelper()

DWORD
GetIpAddrByDnsNameW(
    IN   LPWSTR             pszHostName,
    OUT  LPWSTR             pszIP)
/*++

Description:

    Generate a string IP address from the pszHostName

Arguments:

    pszHostName (IN) - Host Name to resolve.

    pszIP (OUT) - The pszIP string to ... it should be a WCHAR array of at least IPADDRSTR_SIZE size.

Return value:

    dwRet - Will be either NO_ERROR or a Windows Sockets 2 error. 10108 is if the host is unresolveable.

Notes:

    This function was created instead of using gethostbyname(), because gethostbyname does not support
    non-ANSI names, as part of a recent (as of 5.17.1999) RFC -- i.e., that gethostbyname() supports 
    only ANSI names, and we need to be able to resolve Unicode names.

--*/
{
    WSAQUERYSETW *              pQuery = NULL;
    BOOL                        bLocalAllocd = FALSE;
    INT                         dwRet = NO_ERROR;
    INT                         iQueryBufferSize = 148; 
                                                 // Found you need at least 116 through experimentation.  
                                                 //  Probably should increase with IPv6.  Added a little
                                                 //  (32 B) extra for extra IP addresses to be returned.
                                                 //  sizeof(WSAQUERYSETW) is about 64 bytes, so that is
                                                 //  an absolute minimum


    // Allocate and clear the WSA Query Set struct
    __try{
        pQuery = (WSAQUERYSETW *) alloca(iQueryBufferSize);
    } __except(EXCEPTION_EXECUTE_HANDLER){
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
    if(dwRet == ERROR_NOT_ENOUGH_MEMORY || pQuery == NULL){
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Do the lookup
    dwRet = GetIpAddrByDnsNameHelper(pszHostName, pszIP, &iQueryBufferSize, pQuery);
    if(dwRet == WSAEFAULT){
        // Need more memory to do this lookup.
        // Allocate and clear a bigger WSA Query Set struct off the heap
        bLocalAllocd = TRUE;
        pQuery = (WSAQUERYSETW *) LocalAlloc(LMEM_FIXED, iQueryBufferSize); // allocate and init buffer to 0
        if(pQuery == NULL){
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
            
        dwRet = GetIpAddrByDnsNameHelper(pszHostName, pszIP, &iQueryBufferSize, pQuery);
        Assert(dwRet != WSAEFAULT && "This makes no sense, we just inceased the buffer size for the 2nd call.\n");
    } // end if need more memory (dwRet == WSAEFAULT)

    if(bLocalAllocd && pQuery != NULL) LocalFree(pQuery);
    return(dwRet);

} // End of GetIpAddrByDnsNameW()

#define  DEFAULT_HOSTLOOKUP_QUERY_SIZE  300

DWORD 
GetDnsHostNameW(
    IN OUT  VOID **                    ppPrivData,
    IN      LPWSTR                     pszNameToLookup,
    OUT     LPWSTR *                   ppszDnsHostName)
/*++

Routine Description:

    This routine will return the next alias name it finds for a given hostname

Arguments:

    ppPrivData (IN/OUT) - handle returned by GetDnsHostNameW().
    pszNameToLookup - The name, common, or netbios to lookup.
    ppszDnsHostName (OUT) - returned pointer to the string of the alias name.  This
        string name will need to be copied out before the next call to a GetDnsXXX()
        function, using this handle.

Return Value:

    NO_ERROR if the host lookup is returned.
    A WSA error on an unsuccessful lookup.
        WSASERVICE_NOT_FOUND:  Will be returned if there is not such hostname.
        any other WSA error from WSALookupServiceBegin() or WSALookupServiceNext().

Notes:

    Don't forget 2 things:
    A) Must copy out the string for the DNS host name if you wish to use it later
    B) Must call GetDnsFreeW() to clean up the ppPrivData handle only if this function
        did not return an error.

--*/
{
    PDNSRESL_GET_DNS_PD                pPD = NULL;
    PWSAQUERYSETW                      pQuery = NULL;
    GUID                               ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
    DWORD                              dwRet;

    if(ppPrivData == NULL){
        return(ERROR_INVALID_PARAMETER);
    }
    // Setting up the Private Data structure to keep state between function calls
    pPD = (PDNSRESL_GET_DNS_PD) malloc(sizeof(DNSRESL_GET_DNS_PD));
    if(pPD == NULL){
        *ppPrivData = NULL;
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    *ppPrivData = pPD;
    pPD->iQueryBufferSize = DEFAULT_HOSTLOOKUP_QUERY_SIZE;
    pPD->pQuery = NULL;
    pPD->hWsaLookup = NULL;

    // adding to the Private Data the pQuery (WSAQUERYSET) structure.
    pQuery = (PWSAQUERYSETW) malloc(pPD->iQueryBufferSize);
    if(pQuery == NULL){
        GetDnsFreeW(ppPrivData);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset(pQuery, 0, pPD->iQueryBufferSize);
    pPD->pQuery = pQuery;

    // Initializing the pQuery (WSAQUERYSET) structure.
    pQuery->lpszServiceInstanceName = pszNameToLookup;
    pQuery->dwSize = sizeof(WSAQUERYSETW);
    pQuery->dwNameSpace = NS_ALL;
    pQuery->lpServiceClassId = &ServiceGuid;

    // Begin the query.
    if(WSALookupServiceBeginW(pQuery,
                              LUP_RETURN_ALIASES | LUP_RETURN_NAME,
                              &pPD->hWsaLookup ) == SOCKET_ERROR ){
        dwRet = GetLastError();
        Assert(dwRet != WSAEFAULT && "Need to increase the size of DEFAULT_HOSTLOOKUP_QUERY_SIZE");
        GetDnsFreeW(ppPrivData);
        return(dwRet);
    }

 retryWithBiggerBuffer:
    // Do the actual query.
    if(WSALookupServiceNextW(pPD->hWsaLookup, LUP_RETURN_NAME, &(pPD->iQueryBufferSize), pQuery) == NO_ERROR){
        if(ppszDnsHostName != NULL){
            *ppszDnsHostName = pQuery->lpszServiceInstanceName;
        }
        return(NO_ERROR);
    } else {
        dwRet = GetLastError();
        if(dwRet == WSAEFAULT){
            // This means the pQuery buffer was too small, make a bigger buffer and retry.
#pragma prefast(suppress:308, "Pointer aliased above, GetDnsFreeW() free's ppPriveData->pQuery (PREfast bug 506)")
            pQuery = realloc(pQuery, pPD->iQueryBufferSize);
            if(pQuery == NULL){
                GetDnsFreeW(ppPrivData);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            pPD->pQuery = pQuery;
            goto retryWithBiggerBuffer;
        }
        GetDnsFreeW(ppPrivData);
        return(dwRet);
    }
}

DWORD 
GetDnsAliasNamesW(
    IN OUT  VOID **                    ppPrivData,
    OUT     LPWSTR *                   ppszDnsHostName)
/*++

Routine Description:

    This routine will return the next alias name it finds for a given hostname

Arguments:

    ppPrivData (IN/OUT) - handle returned by GetDnsHostNameW().
    ppszDnsHostName (OUT) - returned pointer to the string of the alias name.  This
        string name will need to be copied out before the next call to a GetDnsXXX()
        function, using this handle.

Return Value:

    NO_ERROR if the host lookup is returned.
    A WSA error on an unsuccessful lookup.
        WSASERVICE_NOT_FOUND:  Will be returned if there are no aliases.
        WSA_E_NO_MORE:  Will be returned if there is no more aliases.
        any other WSA error from WSALookupServiceNext().

Notes:

    Don't forget 2 things:
    A) Must copy out the string for the DNS alias name if you wish to use it later
    B) Must call GetDnsFreeW() to clean up the ppPrivData handle.

--*/
{
    PDNSRESL_GET_DNS_PD                pPD = NULL;
    PWSAQUERYSETW                      pQuery = NULL;
    DWORD                              dwRet;

    if(ppPrivData == NULL || *ppPrivData == NULL || 
       ((PDNSRESL_GET_DNS_PD)*ppPrivData)->pQuery == NULL){
        return(ERROR_INVALID_PARAMETER);
    }
    pPD = *ppPrivData;
    pQuery = pPD->pQuery;

 retryWithBiggerBuffer:
    // Query for the next alias.
    if(WSALookupServiceNextW(pPD->hWsaLookup, LUP_RETURN_NAME | LUP_RETURN_ALIASES, 
                             &(pPD->iQueryBufferSize), pQuery ) == NO_ERROR ){
        *ppszDnsHostName = pQuery->lpszServiceInstanceName;
        return(NO_ERROR);
    } else {
        dwRet = GetLastError();
        if(dwRet == WSAEFAULT){
            // This means the pQuery buffer was too small, make a bigger buffer and retry.
#pragma prefast(suppress:308, "Original pointer in ppPrivData->pQuery, caller's responsibility to free w/ GetDnsFreeW() (PREfast bug 506)")
            pQuery = realloc(pQuery, pPD->iQueryBufferSize);
            if(pQuery == NULL){
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            pPD->pQuery = pQuery;
            goto retryWithBiggerBuffer;
        }
        return(dwRet);
    }
    Assert(!"We should not hit here ever");
    return (2);
}

VOID 
GetDnsFreeW(
    IN      VOID **                     ppPrivData)
/*++

Routine Description:

    This routine will clean up the handle passed back by GetDnsHostNameW() or by
    GetDnsAliasNamesW()

Arguments:

    ppPrivData (IN/OUT) - handle returned by GetDnsHostNameW() or by GetDnsAliasNamesW()

Notes:

    The only time this function needs to not be called is if, GetDnsHostNameW() returns
    an error (ie not NO_ERROR).

--*/

{
    if(ppPrivData == NULL || *ppPrivData == NULL){
        return;
    }
    if(((PDNSRESL_GET_DNS_PD)*ppPrivData)->hWsaLookup != NULL){
        WSALookupServiceEnd(((PDNSRESL_GET_DNS_PD)*ppPrivData)->hWsaLookup);
    }
    if(((PDNSRESL_GET_DNS_PD)*ppPrivData)->pQuery != NULL){
        free(((PDNSRESL_GET_DNS_PD)*ppPrivData)->pQuery);
    }
    free(*ppPrivData);
    *ppPrivData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\backrest.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    backrest.c

ABSTRACT:

    Routines to dump backup/restore structures.

DETAILS:

CREATED:

    99/08/05    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
#include <ntdsbcli.h>
#include "util.h"
#include "jetbp.h"

BOOL
Dump_JETBACK_SHARED_HEADER(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                    fSuccess = FALSE;
    JETBACK_SHARED_HEADER * pHdr = NULL;
    const DWORD             cchFieldWidth = 24;

    Printf("%sJETBACK_SHARED_HEADER @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pHdr = (JETBACK_SHARED_HEADER *)
                ReadMemory(pvProcess, sizeof(JETBACK_SHARED_HEADER));

    if (NULL != pHdr) {
        fSuccess = TRUE;

        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "cbSharedBuffer", pHdr->cbSharedBuffer);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "cbPage", pHdr->cbPage);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "dwReadPointer", pHdr->dwReadPointer);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "dwWritePointer", pHdr->dwWritePointer);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "cbReadDataAvailable", pHdr->cbReadDataAvailable);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hrApi", pHdr->hrApi);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fReadBlocked", pHdr->fReadBlocked ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fWriteBlocked", pHdr->fWriteBlocked ? "TRUE" : "FALSE");

        FreeMemory((VOID *) pHdr);
    }

    return fSuccess;
}

BOOL
Dump_JETBACK_SHARED_CONTROL(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                      fSuccess = FALSE;
    JETBACK_SHARED_CONTROL *  pCtrl = NULL;
    const DWORD               cchFieldWidth = 24;

    Printf("%sJETBACK_SHARED_CONTROL @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCtrl = (JETBACK_SHARED_CONTROL *)
                ReadMemory(pvProcess, sizeof(JETBACK_SHARED_CONTROL));

    if (NULL != pCtrl) {
        fSuccess = TRUE;

        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hSharedMemoryMapping", pCtrl->hSharedMemoryMapping);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "heventRead", pCtrl->heventRead);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "heventWrite", pCtrl->heventWrite);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hmutexSection", pCtrl->hmutexSection);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "pjshSection", pCtrl->pjshSection);
        
        fSuccess
            = Dump_JETBACK_SHARED_HEADER(
                nIndents+1,
                (VOID *) pCtrl->pjshSection);
        
        FreeMemory(pCtrl);
    }

    return fSuccess;
}

BOOL
Dump_BackupContext(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    BackupContext * pCtx = NULL;
    const DWORD     cchFieldWidth = 24;

    Printf("%sBackupContext @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCtx = (BackupContext *)
                ReadMemory(pvProcess, sizeof(BackupContext));

    if (NULL != pCtx) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "hBinding", pCtx->hBinding);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "cxh", pCtx->cxh);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fLoopbacked", pCtx->fLoopbacked ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fUseSockets", pCtx->fUseSockets ? "TRUE" : "FALSE");
        Printf("%s%-*s: @ %p\n",
               Indent(nIndents), cchFieldWidth,
               "rgsockSocketHandles",
               (BYTE *) pvProcess + offsetof(BackupContext, rgsockSocketHandles));
        Printf("%s%-*s: @ %p\n",
               Indent(nIndents), cchFieldWidth,
               "rgprotvalProtocolsUsed",
               (BYTE *) pvProcess + offsetof(BackupContext, rgprotvalProtocolsUsed));
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "cSockets", pCtx->cSockets);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "sock",
               (BYTE *) pvProcess + offsetof(BackupContext, sock));
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hReadThread", pCtx->hReadThread);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "tidThreadId", pCtx->tidThreadId);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hPingThread", pCtx->hPingThread);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "tidThreadIdPing", pCtx->tidThreadIdPing);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hrApiStatus", pCtx->hrApiStatus);

        FreeMemory(pCtx);
    }

    return fSuccess;
}

BOOL
Dump_JETBACK_SERVER_CONTEXT(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                      fSuccess = FALSE;
    JETBACK_SERVER_CONTEXT *  pCtx = NULL;
    const DWORD               cchFieldWidth = 34;

    Printf("%sJETBACK_SERVER_CONTEXT @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCtx = (JETBACK_SERVER_CONTEXT *)
                ReadMemory(pvProcess, sizeof(JETBACK_SERVER_CONTEXT));

    if (NULL != pCtx) {
        fSuccess = TRUE;

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fRestoreOperation", pCtx->fRestoreOperation ? "TRUE" : "FALSE");
        if (pCtx->fRestoreOperation) {
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Restore.fJetCompleted",
                   pCtx->u.Restore.fJetCompleted ? "TRUE" : "FALSE");
            Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
                   "u.Restore.cUnitDone",
                   pCtx->u.Restore.cUnitDone);
            Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
                   "u.Restore.cUnitTotal",
                   pCtx->u.Restore.cUnitTotal);
        }
        else {
            Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.hFile", pCtx->u.Backup.hFile);
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fHandleIsValid",
                   pCtx->u.Backup.fHandleIsValid ? "TRUE" : "FALSE");
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.cbReadHint", pCtx->u.Backup.cbReadHint);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.sockClient",
                   (BYTE *) pvProcess
                        + offsetof(JETBACK_SERVER_CONTEXT, u.Backup.sockClient));
            Printf("%s%-*s: %I64u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.liFileSize", pCtx->u.Backup.liFileSize);
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.dwHighestLogNumber", pCtx->u.Backup.dwHighestLogNumber);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.wszBackupAnnotation", pCtx->u.Backup.wszBackupAnnotation);
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.dwFileSystemGranularity", pCtx->u.Backup.dwFileSystemGranularity);
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fUseSockets",
                   pCtx->u.Backup.fUseSockets ? "TRUE" : "FALSE");
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fUseSharedMemory",
                   pCtx->u.Backup.fUseSharedMemory ? "TRUE" : "FALSE");
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fBackupIsRegistered", pCtx->u.Backup.fBackupIsRegistered ? "TRUE" : "FALSE");
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.dwClientIdentifier", pCtx->u.Backup.dwClientIdentifier);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.jsc",
                   (BYTE *) pvProcess + offsetof(JETBACK_SERVER_CONTEXT, u.Backup.jsc));

            fSuccess
                = Dump_JETBACK_SHARED_CONTROL(
                    nIndents+1,
                    (BYTE *) pvProcess + offsetof(JETBACK_SERVER_CONTEXT, u.Backup.jsc));
        }

        FreeMemory(pCtx);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsconlib\localization.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   dsconlib - DS Console Library

Abstract:

   This file has some utility functions for internationalization
   and localization.

Author:

    Brett Shirley (BrettSh)

Environment:

    tapicfg.exe, repadmin.exe, dcdiag.exe, ntdsutil.exe 

Notes:

Revision History:

    Brett Shirley   BrettSh     Aug 4th, 2002
        Created file.

--*/

#include <ntdspch.h>

#include <locale.h>     // for setlocale()
#include <winnlsp.h>    // for SetThreadUILanguage()

#define DS_CON_LIB_CRT_VERSION 1
#include "dsconlib.h"   // Our own library header. :)
                    
enum {
    eNotInited = 0,
    eCrtVersion,
    eWin32Version
} geConsoleType =  eNotInited;

DS_CONSOLE_INFO  gConsoleInfo;


// FUTURE-2002/08/04-BrettSh - We should move the PrintMsg() routines from
//      the various console apps (dcdiag/repadmin/ntdsutil/tapicfg) to this
//      library so common code is not repeated so many times.  Much info on
//      how to properly localize console apps, can be garnered from these 
//      internal resources:
//  http://globalsys/wr/references/globalizatiofoconsolapplications.htm
//  http://globalsys/pseudoloc/Localizability/Best_Practices.htm
//

void
DsConLibInitCRT(
   void
   )
{
    UINT               Codepage; // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";
    
    HANDLE                          hConsole = NULL;
    CONSOLE_SCREEN_BUFFER_INFO      ConInfo;
    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
        setlocale(LC_ALL, achCodepage);
    } else {
        // We do this because LC_ALL sets the LC_CTYPE as well, and we're
        // not supposed to do that, say the experts if we're setting the
        // locale to ".OCP".
        setlocale (LC_COLLATE, achCodepage );    // sets the sort order 
        setlocale (LC_MONETARY, achCodepage ); // sets the currency formatting rules
        setlocale (LC_NUMERIC, achCodepage );  // sets the formatting of numerals
        setlocale (LC_TIME, achCodepage );     // defines the date/time formatting
    }

    SetThreadUILanguage(0);

    // Initialize output package
    gConsoleInfo.sStdOut = stdout;
    gConsoleInfo.sStdErr = stderr;

    if(hConsole = GetStdHandle(STD_OUTPUT_HANDLE)){
        if(GetConsoleScreenBufferInfo(hConsole, &ConInfo)){
            gConsoleInfo.wScreenWidth = ConInfo.dwSize.X;
        } else {
            // This probably means we're printing to a file ...
            // FUTURE-2002/08/13-BrettSh Check this more explicitly.
            gConsoleInfo.bStdOutIsFile = TRUE;
            gConsoleInfo.wScreenWidth = 0xFFFF;
        }
    } else {
        gConsoleInfo.wScreenWidth = 80;
    }

    geConsoleType = eCrtVersion;
}

void
DsConLibInitWin32(
    void
    )
{

    geConsoleType = eWin32Version;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\dra.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dra.c

ABSTRACT:

    Routines to dump replication structures.

DETAILS:

CREATED:

    97/11/24    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include "ntdsa.h"
#include "drs.h"
#include "dsexts.h"
#include "objids.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"
#include "draasync.h"
#include <debug.h>
#include "dsatools.h"
#include "dsutil.h"
#include "mdlocal.h"
#include "drautil.h"
#include "drsuapi.h"

struct {
    USHORT  usOp;
    LPSTR   pszOp;
} gAsyncOpCode[] =  {
                        { AO_OP_REP_ADD,    "REP_ADD"    },
                        { AO_OP_REP_DEL,    "REP_DEL"    },
                        { AO_OP_REP_MOD,    "REP_MOD"    },
                        { AO_OP_REP_SYNC,   "REP_SYNC"   },
                        { AO_OP_UPD_REFS,   "UPD_REFS"   }
                    };
#define gcNumAsyncOpCodes (sizeof(gAsyncOpCode)/sizeof(gAsyncOpCode[0]))

LPSTR
DraUuidToStr(
    IN  UUID *  puuid,
    OUT LPSTR   pszUuid     OPTIONAL,
    IN  ULONG   cchUuid
    )
/*++

Routine Description:

    Stringize a UUID.

Arguments:

    puuid (IN) - UUID to stringize.
    pszUuid (OUT, OPTIONAL) - Buffer to hold stringized UUID.  If NULL, uses
        static internal buffer.

Return Values:

--*/
{
    LPSTR pszUuidBuffer;
    static CHAR szUuid[1 + 2*sizeof(GUID)];

    if (NULL == pszUuid) {
        pszUuid = szUuid;
        cchUuid = 1 + 2*sizeof(GUID);
    }

    pszUuidBuffer = DsUuidToStructuredStringCch(puuid, pszUuid, cchUuid);
    if (pszUuidBuffer == NULL) {
        strcpy(pszUuid, "bad uuid format");
    }

    return pszUuid;
}


LPSTR
UsnVecToStr(
    IN  USN_VECTOR *    pusnvec,
    OUT LPSTR           pszUsnVec   OPTIONAL
    )
/*++

Routine Description:

    Stringize a USN_VECTOR.

Arguments:

    pusnvec (IN) - USN_VECTOR to stringize.
    pszUsnVec (OUT, OPTIONAL) - Buffer to hold stringized USN_VECTOR.  If NULL,
        uses static internal buffer.

Return Values:

--*/
{
    static CHAR szUsnVec[128];

    if (NULL == pszUsnVec) {
        pszUsnVec = szUsnVec;
    }

    sprintf(pszUsnVec, "%I64d/Obj, %I64d/Prop",
            pusnvec->usnHighObjUpdate, pusnvec->usnHighPropUpdate);

    return pszUsnVec;
}



LPSTR
DrsExtendedOpToStr(
    IN  ULONG   ulExtendedOp,
    OUT LPSTR   pszExtendedOp
    )
{
    static CHAR szExtendedOp[80];

    if (NULL == pszExtendedOp) {
        pszExtendedOp = szExtendedOp;
    }

    switch ( ulExtendedOp ) {
    case 0:
        strcpy(pszExtendedOp, "none");
        break;
    case EXOP_FSMO_REQ_ROLE:
        strcpy(pszExtendedOp, "EXOP_FSMO_REQ_ROLE");
        break;
    case EXOP_FSMO_REQ_RID_ALLOC:
        strcpy(pszExtendedOp, "EXOP_FSMO_REQ_RID_ALLOC");
        break;
    case EXOP_FSMO_RID_REQ_ROLE:
        strcpy(pszExtendedOp, "EXOP_FSMO_RID_REQ_ROLE");
        break;
    case EXOP_FSMO_REQ_PDC:
        strcpy(pszExtendedOp, "EXOP_FSMO_REQ_PDC");
        break;
    case EXOP_FSMO_ABANDON_ROLE:
        strcpy(pszExtendedOp, "EXOP_FSMO_ABANDON_ROLE");
        break;
    case EXOP_REPL_OBJ:
	strcpy(pszExtendedOp, "EXOP_REPL_OBJ");
	break;
    default:
        // Bad parameter or dsexts out of date.
        sprintf(pszExtendedOp, "0x%x", ulExtendedOp);
        break;
    }

    return pszExtendedOp;
}


LPSTR
DrsExtendedRetToStr(
    IN  ULONG   ulExtendedRet,
    OUT LPSTR   pszExtendedRet
    )
{
    static CHAR szExtendedRet[80];

    if (NULL == pszExtendedRet) {
        pszExtendedRet = szExtendedRet;
    }

    switch (ulExtendedRet) {
    case 0:
        strcpy(pszExtendedRet, "none");
        break;
    case EXOP_ERR_SUCCESS:
        strcpy(pszExtendedRet, "EXOP_ERR_SUCCESS");
        break;
    case EXOP_ERR_UNKNOWN_OP:
        strcpy(pszExtendedRet, "EXOP_ERR_UNKNOWN_OP");
        break;
    case EXOP_ERR_FSMO_NOT_OWNER:
        strcpy(pszExtendedRet, "EXOP_ERR_FSMO_NOT_OWNER");
        break;
    case EXOP_ERR_UPDATE_ERR:
        strcpy(pszExtendedRet, "EXOP_ERR_UPDATE_ERR");
        break;
    case EXOP_ERR_EXCEPTION:
        strcpy(pszExtendedRet, "EXOP_ERR_EXCEPTION");
        break;
    case EXOP_ERR_UNKNOWN_CALLER:
        strcpy(pszExtendedRet, "EXOP_ERR_UNKNOWN_CALLER");
        break;
    case EXOP_ERR_RID_ALLOC:
        strcpy(pszExtendedRet, "EXOP_ERR_RID_ALLOC");
        break;
    case EXOP_ERR_FSMO_OWNER_DELETED:
        strcpy(pszExtendedRet, "EXOP_ERR_FSMO_OWNER_DELETED");
        break;
    case EXOP_ERR_FSMO_PENDING_OP:
        strcpy(pszExtendedRet, "EXOP_ERR_FSMO_PENDING_OP");
        break;
    case EXOP_ERR_COULDNT_CONTACT:
        strcpy(pszExtendedRet, "EXOP_ERR_COULDNT_CONTACT");
        break;
    case EXOP_ERR_FSMO_REFUSING_ROLES:
        strcpy(pszExtendedRet, "EXOP_ERR_FSMO_REFUSING_ROLES");
        break;
    case EXOP_ERR_DIR_ERROR:
        strcpy(pszExtendedRet, "EXOP_ERR_DIR_ERROR");
        break;
    case EXOP_ERR_FSMO_MISSING_SETTINGS:
        strcpy(pszExtendedRet, "EXOP_ERR_FSMO_MISSING_SETTINGS");
        break;
    case EXOP_ERR_ACCESS_DENIED:
        strcpy(pszExtendedRet, "EXOP_ERR_ACCESS_DENIED");
        break;
    case EXOP_ERR_PARAM_ERR:
	strcpy(pszExtendedRet, "EXOP_ERR_PARAM_ERR");
	break;
    default:
        // Bad parameter or dsexts out of date.
        sprintf(pszExtendedRet, "0x%x", ulExtendedRet);
        break;
    }

    return pszExtendedRet;
}


BOOL
Dump_REPLTIMES_local(
    IN DWORD        nIndents,
    IN REPLTIMES *  prt
    )
/*++

Routine Description:

    REPLTIMES dump routine.

Arguments:

    nIndents - Indentation level desired.

    puuid - address of REPLTIMES in *local* address space (i.e., address space
        of the debugger, not that of the process being debugged).

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    static LPCSTR rgpszDays[] =
    {"SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};

    DWORD   iDay, ib;

    printf("%sREPLTIMES\n", Indent(nIndents));
    for (iDay = 0; iDay < 7; iDay++) {
        Printf("%s%s ", Indent(nIndents + 2), rgpszDays[iDay]);

        for (ib = 0; ib < 12; ib++) {
            Printf(" %02x", prt->rgTimes[iDay*12 + ib]);
        }

        Printf("\n");
    }

    return TRUE;
}


BOOL
Dump_REPLTIMES(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    REPLTIMES (replication schedule) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLTIMES in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            ok = FALSE;
    REPLTIMES *     prt;

    prt = (REPLTIMES *) ReadMemory(pvProcess, sizeof(REPLTIMES));

    if (NULL != prt) {
        ok = Dump_REPLTIMES_local(nIndents, prt);
    }

    return ok;
}


BOOL
Dump_UUID_local(
    IN DWORD    nIndents,
    IN UUID *   puuid
    )
/*++

Routine Description:

    UUID dump routine.

Arguments:

    nIndents - Indentation level desired.

    puuid - address of UUID in *local* address space (i.e., address space of the
        debugger, not that of the process being debugged).

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    Printf("%sUUID %s\n", Indent(nIndents), DraUuidToStr(puuid, NULL, 0));

    return TRUE;
}


BOOL
Dump_UUID(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    UUID dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of UUID in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL    ok = FALSE;
    UUID *  puuid;

    puuid = (UUID *) ReadMemory(pvProcess, sizeof(UUID));

    if (NULL != puuid) {
        ok = Dump_UUID_local(nIndents, puuid);
    }

    return ok;
}


BOOL
Dump_MTX_ADDR(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    MTX_ADDR (replication network address) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of MTX_ADDR in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL        ok = FALSE;
    MTX_ADDR *  pmtx;
    DWORD       cb;

    pmtx = (MTX_ADDR *) ReadMemory(pvProcess, sizeof(MTX_ADDR));

    if (NULL != pmtx) {
        cb = MTX_TSIZE(pmtx);
        Printf("%sMTX_ADDR (struct size %d, name length %d)\n",
               Indent(nIndents), cb, pmtx->mtx_namelen);

        FreeMemory(pmtx);
        pmtx = (MTX_ADDR *) ReadMemory(pvProcess, cb);
        if (NULL != pmtx) {
            ok = TRUE;

            if (1 + lstrlenA(pmtx->mtx_name) != (int) pmtx->mtx_namelen) {
                Printf("%s!! mtx_namelen (%d) != 1 + lstrlenA(pmtx->mtx_name) (%d) !!\n",
                       Indent(nIndents+2), pmtx->mtx_namelen, 1 + lstrlenA(pmtx->mtx_name));
                ok = FALSE;
            }

            Printf("%s%s\n", Indent(nIndents+2), pmtx->mtx_name);
        }
    }

    return ok;
}


BOOL
Dump_AO_local(
    IN DWORD nIndents,
    IN AO *  pao
    )
/*++

Routine Description:

    AO (async replication op structure) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pao - address of PAO in *local* address space (i.e., address space of the
        debugger, not that of the process being debugged).

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL ok = FALSE;
    CHAR szTime[SZDSTIME_LEN];

    Printf("%sNext AO               @ 0x%p\n", Indent(nIndents), pao->paoNext);
    Printf("%sTime enqueued           %s\n", Indent(nIndents),
           DSTimeToDisplayString(pao->timeEnqueued, szTime));
    Printf("%sSerial number           0x%x\n", Indent(nIndents), pao->ulSerialNumber);
    Printf("%sPriority                0x%x\n", Indent(nIndents), pao->ulPriority);
    Printf("%sOptions                 0x%x\n", Indent(nIndents), pao->ulOptions);
    Printf("%sResult                  0x%x\n", Indent(nIndents), pao->ulResult);
    Printf("%shDone                   0x%I64x\n", Indent(nIndents), pao->hDone);

    switch (pao->ulOperation) {
      case AO_OP_REP_ADD:
        Printf("%sREP_ADD\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_add.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_add.pNC);

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.rep_add.pDSASMtx_addr);
            ok = Dump_MTX_ADDR(nIndents+3, pao->args.rep_add.pDSASMtx_addr);
        }

        if (ok) {
            Printf("%sSource Dom DNS Name   @ 0x%p\n", Indent(nIndents+2),
                   pao->args.rep_add.pszSourceDsaDnsDomainName);

            Printf("%sSchedule              @ 0x%p\n", Indent(nIndents+2), pao->args.rep_add.preptimesSync);
            if (NULL != pao->args.rep_add.preptimesSync) {
                ok = Dump_REPLTIMES(nIndents+3, pao->args.rep_add.preptimesSync);
            }
        }
        break;

      case AO_OP_REP_DEL:
        Printf("%sREP_DEL\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_del.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_del.pNC);

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.rep_del.pSDSAMtx_addr);
            if (NULL != pao->args.rep_del.pSDSAMtx_addr) {
                ok = Dump_MTX_ADDR(nIndents+3, pao->args.rep_del.pSDSAMtx_addr);
            }
        }
        break;

      case AO_OP_REP_MOD:
        Printf("%sREP_MOD\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_mod.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_mod.pNC);

        if (ok) {
            Printf("%sSource DSA UUID       @ 0x%p\n", Indent(nIndents+2), pao->args.rep_mod.puuidSourceDRA);
            if (NULL != pao->args.rep_mod.puuidSourceDRA) {
                ok = Dump_UUID(nIndents+3, pao->args.rep_mod.puuidSourceDRA);
            }
        }

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.rep_mod.pmtxSourceDRA);
            if (NULL != pao->args.rep_mod.pmtxSourceDRA) {
                ok = Dump_MTX_ADDR(nIndents+3, pao->args.rep_mod.pmtxSourceDRA);
            }
        }

        if (ok) {
            Printf("%sSchedule              @ 0x%p\n", Indent(nIndents+2), &pao->args.rep_mod.rtSchedule);
            ok = Dump_REPLTIMES_local(nIndents+3, &pao->args.rep_mod.rtSchedule);
        }

        if (ok) {
            Printf("%sReplica flags           0x%x\n", Indent(nIndents+2), pao->args.rep_mod.ulReplicaFlags);
            Printf("%sModify fields           0x%x\n", Indent(nIndents+2), pao->args.rep_mod.ulModifyFields);
        }
        break;

      case AO_OP_REP_SYNC:
        Printf("%sREP_SYNC\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_sync.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_sync.pNC);

        if (ok) {
            Printf("%sSource DSA UUID       @ 0x%p\n", Indent(nIndents+2), &pao->args.rep_sync.invocationid);
            ok = Dump_UUID_local(nIndents+3, &pao->args.rep_sync.invocationid);
        }

        if (ok) {
            Printf("%sSource DSA Name       @ 0x%p\n", Indent(nIndents+2), pao->args.rep_sync.pszDSA);
        }
        break;

      case AO_OP_UPD_REFS:
        Printf("%sUPD_REFS\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.upd_refs.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.upd_refs.pNC);

        if (ok) {
            Printf("%sSource DSA UUID       @ 0x%p\n", Indent(nIndents+2), &pao->args.upd_refs.invocationid);
            ok = Dump_UUID_local(nIndents+3, &pao->args.upd_refs.invocationid);
        }

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.upd_refs.pDSAMtx_addr);
            if (NULL != pao->args.upd_refs.pDSAMtx_addr) {
                ok = Dump_MTX_ADDR(nIndents+3, pao->args.upd_refs.pDSAMtx_addr);
            }
        }
        break;

      default:
        Printf("%sUnknown op 0x%x!\n", Indent(nIndents), pao->ulOperation);
        break;
    }

    return ok;
}


BOOL
Dump_AO(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    AO (async replication op structure) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PAO in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL    ok = FALSE;
    AO *    pao;

    Printf("%sAO @ 0x%p\n", Indent(nIndents), pvProcess);

    pao = (AO *) ReadMemory(pvProcess, sizeof(AO));

    if (NULL != pao) {
        ok = Dump_AO_local(nIndents+2, pao);

        FreeMemory(pao);
    }

    return ok;
}


BOOL
Dump_AOLIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    AO (async replication op structure) list dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of first PAO in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL    ok;
    AO *    pao;

    do {
        Printf("%sAO @ 0x%p\n", Indent(nIndents), pvProcess);

        pao = (AO *) ReadMemory(pvProcess, sizeof(AO));

        if (NULL != pao) {
            ok = Dump_AO_local(nIndents+2, pao);

            pvProcess = pao->paoNext;

            FreeMemory(pao);
        }
        else {
            ok = FALSE;
        }
    } while (ok && (NULL != pvProcess));

    return ok;
}


BOOL
Dump_DRS_MSG_GETCHGREQ_V4(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREQ_V2 dump routine.  DRS_MSG_GETCHGREQ_V2 is the
    message sent from replication sink to replication source to request changes
    from a given NC.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V2 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                    fSuccess = FALSE;
    DRS_MSG_GETCHGREQ_V4 *  pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREQ_V4 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREQ_V4 *) ReadMemory(pvProcess,
                                               sizeof(DRS_MSG_GETCHGREQ_V4));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sDestination DSA:          %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->V3.uuidDsaObjDest, NULL, 0));

        Printf("%sSource DSA Invocation ID: %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->V3.uuidInvocIdSrc, NULL, 0));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->V3.pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->V3.usnvecFrom, NULL));

        Printf("%sDestination UTD vector: @ %p\n", Indent(nIndents),
               pmsg->V3.pUpToDateVecDestV1);

        Printf("%sFlags:                    0x%x\n", Indent(nIndents),
               pmsg->V3.ulFlags);

        Printf("%sMax objects to return:    %d\n", Indent(nIndents),
               pmsg->V3.cMaxObjects);

        Printf("%sMax bytes to return:      %d\n", Indent(nIndents),
               pmsg->V3.cMaxBytes);

        Printf("%sExtended operation:       %s\n", Indent(nIndents),
               DrsExtendedOpToStr(pmsg->V3.ulExtendedOp, NULL));

        Printf("%sReply via transport:      %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidTransportObj, NULL, 0));

        Printf("%sReturn address:         @ %p\n", Indent(nIndents),
               pmsg->pmtxReturnAddress);
        if (!Dump_MTX_ADDR(nIndents+3, pmsg->pmtxReturnAddress)) {
            fSuccess = FALSE;
        }

        FreeMemory(pmsg);
    }

    return fSuccess;
}


BOOL
Dump_DRS_MSG_GETCHGREQ_V5(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREQ_V5 dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V5 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                    fSuccess = FALSE;
    DRS_MSG_GETCHGREQ_V5 *  pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREQ_V5 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREQ_V5 *) ReadMemory(pvProcess,
                                               sizeof(DRS_MSG_GETCHGREQ_V5));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sDestination DSA objGuid:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjDest, NULL, 0));

        Printf("%sSource DSA Invocation ID: %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL, 0));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sDestination UTD vector: @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecDestV1);

        Printf("%sFlags:                    0x%x\n", Indent(nIndents),
               pmsg->ulFlags);

        Printf("%sMax objects to return:    %d\n", Indent(nIndents),
               pmsg->cMaxObjects);

        Printf("%sMax bytes to return:      %d\n", Indent(nIndents),
               pmsg->cMaxBytes);

        Printf("%sExtended operation:       %s\n", Indent(nIndents),
               DrsExtendedOpToStr(pmsg->ulExtendedOp, NULL));

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREQ_V8(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREQ_V8 dump routine.
Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V8 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                    fSuccess = FALSE;
    DRS_MSG_GETCHGREQ_V8 *  pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREQ_V8 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREQ_V8 *) ReadMemory(pvProcess,
                                               sizeof(DRS_MSG_GETCHGREQ_V8));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sDestination DSA objGuid:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjDest, NULL, 0));

        Printf("%sSource DSA Invocation ID: %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL, 0));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sDestination UTD vector: @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecDest);

        Printf("%sFlags:                    0x%x\n", Indent(nIndents),
               pmsg->ulFlags);

        Printf("%sMax objects to return:    %d\n", Indent(nIndents),
               pmsg->cMaxObjects);

        Printf("%sMax bytes to return:      %d\n", Indent(nIndents),
               pmsg->cMaxBytes);

        Printf("%sExtended operation:       %s\n", Indent(nIndents),
               DrsExtendedOpToStr(pmsg->ulExtendedOp, NULL));

        Printf("%sFsmo Info:                %I64d\n", Indent(nIndents),
              pmsg->liFsmoInfo);

        Printf("%spPartialAttrSet:        @ %p\n", Indent(nIndents),
               pmsg->pPartialAttrSet);

        Printf("%spPartialAttrSetEx:      @ %p\n", Indent(nIndents),
               pmsg->pPartialAttrSetEx);

        Printf("%sPrefixTableDest.PrefixCount:     %d\n", Indent(nIndents),
               pmsg->PrefixTableDest.PrefixCount);

        Printf("%sPrefixTableDest.pPrefixEntry:  @ %p\n", Indent(nIndents),
               pmsg->PrefixTableDest.pPrefixEntry);

        FreeMemory(pmsg);
    }

    return fSuccess;
}



BOOL
Dump_DRS_MSG_GETCHGREPLY_V1(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREPLY_V1 dump routine.  DRS_MSG_GETCHGREQ_V1 is the
    message sent from replication sink to replication source to request changes
    from a given NC.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V1 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V1 * pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREPLY_V1 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V1 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V1));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sSource DSA objectGuid:    %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjSrc, NULL, 0));

        Printf("%sSource DSA invocationId:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL, 0));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sTo USN vector:            %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecTo, NULL));

        Printf("%sSource UTD vector:      @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecSrcV1);

        Printf("%sNum bytes returned:       %d\n", Indent(nIndents),
               pmsg->cNumBytes);

        Printf("%sNum objects returned:     %d\n", Indent(nIndents),
               pmsg->cNumObjects);

        Printf("%sObjects:                @ %p\n", Indent(nIndents),
               pmsg->pObjects);

        Printf("%sExtended return code:     %s\n", Indent(nIndents),
               DrsExtendedRetToStr(pmsg->ulExtendedRet, NULL));

        Printf("%sMore Data:                %s\n", Indent(nIndents),
               pmsg->fMoreData ? "yes" : "no");

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREPLY_V6(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREPLY_V6 dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREPLY_V6 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V6 * pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREPLY_V6 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V6 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V6));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sSource DSA objectGuid:    %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjSrc, NULL, 0));

        Printf("%sSource DSA invocationId:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL, 0));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sTo USN vector:            %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecTo, NULL));

        Printf("%sSource UTD vector:      @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecSrc);

        Printf("%sNum bytes returned:       %d\n", Indent(nIndents),
               pmsg->cNumBytes);

        Printf("%sNum objects returned:     %d\n", Indent(nIndents),
               pmsg->cNumObjects);

        Printf("%sObjects:                @ %p\n", Indent(nIndents),
               pmsg->pObjects);

        Printf("%sExtended return code:     %s\n", Indent(nIndents),
               DrsExtendedRetToStr(pmsg->ulExtendedRet, NULL));

        Printf("%sMore Data:                %s\n", Indent(nIndents),
               pmsg->fMoreData ? "yes" : "no");

        Printf("%sNum values returned:      %d\n", Indent(nIndents),
               pmsg->cNumValues);

        Printf("%sValues:                 @ %p\n", Indent(nIndents),
               pmsg->rgValues);
        
        Printf("%sdwDRSError:               %d\n", Indent(nIndents),
               pmsg->dwDRSError);

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREPLY_VALUES(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Dump the values array out of a GETCHGREPLY structure. It doesn't matter which
    version of the reply structure you pass in here, as long as the rgValues
    field hasn't changed position.

    Note also that you do not pass the address of rgValues.  You pass the address of the
    GETCHGREPLY structure. This is because we need to dig out the count of values in
    the array, which is kept in this containing structure.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREPLY_V6 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V6 * pmsg = NULL;
    DWORD                    i;

    Printf("%sDRS_MSG_GETCHGREPLY_Vx @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V6 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V6));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sNum values returned:      %d\n", Indent(nIndents),
               pmsg->cNumValues);

        Printf("%sValues:                 @ %p\n", Indent(nIndents),
               pmsg->rgValues);
        
        for( i = 0; i < pmsg->cNumValues; i++ ) {
            REPLVALINF *pReplValInf = pmsg->rgValues + i;
            Dump_REPLVALINF( nIndents + 1, pReplValInf );
        }

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_NCSYNCSOURCE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL fSuccess = TRUE;
    NCSYNCSOURCE *pncss = NULL;
    DWORD size, length;
    BOOL fFollowLinks = TRUE;

    nIndents++;
    do {
        if (!pvProcess) {
            break;
        }
        Printf("%sNCSYNCSOURCE @ %p\n", Indent(nIndents - 1), pvProcess);

        // Deal with variable length structure. Read base structure to get length
        size = sizeof( NCSYNCSOURCE );
        pncss = (NCSYNCSOURCE *) ReadMemory(pvProcess, size );
        if (pncss == NULL) {
            fSuccess = FALSE;
            break;
        }
        if (pncss->cchDSA < 256) {
            size += (pncss->cchDSA + 1) * sizeof(WCHAR);
            pncss = (NCSYNCSOURCE *) ReadMemory(pvProcess, size );
            if (pncss == NULL) {
                fSuccess = FALSE;
                break;
            }
        } else {
            *(pncss->szDSA) = L'\0';
        }

        Printf("%sDSA:           %ws\n", Indent(nIndents),
               pncss->szDSA);
        Printf("%sfCompletedSrc: %d\n", Indent(nIndents),
               pncss->fCompletedSrc);
        Printf("%sulResult:      %d\n", Indent(nIndents),
               pncss->ulResult);

        pvProcess = pncss->pNextSource;
        FreeMemory(pncss);

    } while (fFollowLinks && fSuccess);

    return fSuccess;
}

BOOL
Dump_NCSYNCDATA(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL fSuccess = TRUE;
    NCSYNCDATA *pncsd = NULL;
    BOOL fFollowLinks = TRUE;

    nIndents++;
    do {
        if (!pvProcess) {
            break;
        }
        Printf("%sNCSYNCDATA @ %p\n", Indent(nIndents - 1), pvProcess);

        Printf("%sNC:\n", Indent(nIndents));
        // Re-reads same memory as below
        if (!Dump_DSNAME(2 + nIndents, ((BYTE *)pvProcess) +
                         offsetof( NCSYNCDATA, NC ) )) {
            fSuccess = FALSE;
            break;
        }

        pncsd = (NCSYNCDATA *) ReadMemory(pvProcess, sizeof(NCSYNCDATA));
        if (pncsd == NULL) {
            fSuccess = FALSE;
            break;
        }

        Printf("%sulUntriedSrcs:       %d\n", Indent(nIndents),
               pncsd->ulUntriedSrcs);
        Printf("%sulTriedSrcs:         %d\n", Indent(nIndents),
               pncsd->ulTriedSrcs);
        Printf("%sulLastTriedSrcs:     %d\n", Indent(nIndents),
               pncsd->ulLastTriedSrcs);
        Printf("%sulReplicaFlags:      0x%x\n", Indent(nIndents),
               pncsd->ulReplicaFlags);
        Printf("%sfSyncedFromOneSrc:   %d\n", Indent(nIndents),
               pncsd->fSyncedFromOneSrc);
        Printf("%sfNCComplete:         %d\n", Indent(nIndents),
               pncsd->fNCComplete);
        Printf("%spFirstSource:\n", Indent(nIndents));
        fSuccess = Dump_NCSYNCSOURCE( nIndents, pncsd->pFirstSource );

        pvProcess = pncsd->pNCSDNext;

        FreeMemory(pncsd);

    } while (fFollowLinks && fSuccess);

    return fSuccess;
}

BOOL
Dump_INITSYNC(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL fSuccess = TRUE;
    PVOID pAddress;
    LPDWORD pdwValue;

#define DUMPSYMD( sym ) \
    pAddress = (VOID *) GetExpr("ntdsa!" #sym); \
    if (NULL == pAddress) { \
        Printf("Can't Locate the Address of %s - Sorry\n", #sym); \
        return FALSE; \
    } else { \
        pdwValue = (LPDWORD) ReadMemory(pAddress, sizeof(DWORD)); \
        if (pdwValue == NULL) { \
            Printf("Can't read address 0x%x - Sorry\n", pAddress); \
            return FALSE; \
        } else { \
            Printf("%s(0x%x) = %d (0x%x)\n", #sym, pAddress, *pdwValue, *pdwValue ); \
        } \
    }

    DUMPSYMD( gfIsSynchronized );
    DUMPSYMD( gfInitSyncsFinished );
    DUMPSYMD( gfDsaWritable );
    DUMPSYMD( gpNCSDFirst );
    if (*pdwValue != 0) {
        Printf( "!dsexts.dump NCSYNCDATA %x\n", *pdwValue );
    }
    DUMPSYMD( gulNCUnsynced );
    DUMPSYMD( gulNCUnsyncedWrite );
    DUMPSYMD( gulNCUnsyncedReadOnly );
    DUMPSYMD( gfWasPreviouslyPromotedGC );
    DUMPSYMD( gulGCPartitionOccupancy );

    DUMPSYMD( gAnchor );
    if (pAddress != 0) {
        Printf( "!dsexts.dump DSA_ANCHOR %x\n", pAddress );
    }


    return fSuccess;
}


BOOL
Dump_DRS_ASYNC_RPC_STATE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_ASYNC_RPC_STATE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_ASYNC_RPC_STATE in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    static struct {
        DRS_CALL_TYPE   CallType;
        LPSTR           pszCallType;
    } rgCallTypeTable[] = {
        {DRS_ASYNC_CALL_GET_CHANGES, "GetChanges"},
    };
    const DWORD cchFieldWidth = 29;

    BOOL                  fSuccess = FALSE;
    DRS_ASYNC_RPC_STATE * pAsyncState = NULL;
    CHAR                  szTime[SZDSTIME_LEN];
    DWORD                 i;
    LPSTR                 pszCallType;

    Printf("%sDRS_ASYNC_RPC_STATE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pAsyncState = (DRS_ASYNC_RPC_STATE *) ReadMemory(pvProcess,
                                                     sizeof(DRS_ASYNC_RPC_STATE));

    if (NULL != pAsyncState) {
        fSuccess = TRUE;

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "ListEntry.Flink", pAsyncState->ListEntry.Flink);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "ListEntry.Blink", pAsyncState->ListEntry.Blink);

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "timeInitialized",
               DSTimeToDisplayString(pAsyncState->timeInitialized, szTime));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "RpcState.u.hEvent", pAsyncState->RpcState.u.hEvent);

        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "dwCallerTID", pAsyncState->dwCallerTID);

        pszCallType = "Unknown!";
        for (i = 0; i < ARRAY_SIZE(rgCallTypeTable); i++) {
            if (pAsyncState->CallType == rgCallTypeTable[i].CallType) {
                pszCallType = rgCallTypeTable[i].pszCallType;
                break;
            }
        }
        Printf("%s%-*s: %d (%s)\n", Indent(nIndents), cchFieldWidth,
               "CallType", pAsyncState->CallType, pszCallType);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "CallArgs.pszServerName", pAsyncState->CallArgs.pszServerName);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "CallArgs.pszDomainName", pAsyncState->CallArgs.pszDomainName);

        switch (pAsyncState->CallType) {
        case DRS_ASYNC_CALL_GET_CHANGES:
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.pmsgIn",
                   pAsyncState->CallArgs.GetChg.pmsgIn);
            Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.dwOutVersion",
                   pAsyncState->CallArgs.GetChg.dwOutVersion);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.pmsgOut",
                   pAsyncState->CallArgs.GetChg.pmsgOut);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.pSchemaInfo",
                   pAsyncState->CallArgs.GetChg.pSchemaInfo);
            break;

        default:
            break;
        }

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "SessionKey.SessionKey", pAsyncState->SessionKey.SessionKey);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "SessionKey.SessionKeyLength",
               pAsyncState->SessionKey.SessionKeyLength);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "pContextInfo", pAsyncState->pContextInfo);

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "fIsCallInProgress", pAsyncState->fIsCallInProgress);

        FreeMemory(pAsyncState);
    }

    return fSuccess;
}

// Stolen from mdnotify.c, since the datastructure is not published.

// Notify element.
// This list is shared between the ReplicaNotify API and the ReplNotifyThread.
// The elements on this list are fixed size.
// NC's to be notified are identified by NCDNT

typedef struct _ne {
    struct _ne *pneNext;
    ULONG ulNcdnt;          // NCDNT to notify
    DWORD dwNotifyTime;     // Time to send notification
    BOOL fUrgent;           // Notification was queued urgently
} NE;

BOOL Dump_ReplNotifyElement(
        IN DWORD nIndents,
        IN OPTIONAL PVOID pvProcess)
/*++

Routine Description:

    Public NE (replication notification element) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of NE in address space of process being debugged.
               If left NULL, we automatically try to look up the one known
               global NE root pointer and use that.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    NE * pneLocal;
    DWORD cTickNow = GetTickCount();
    BOOL bSucceeded = TRUE;

    if (pvProcess == NULL) {
        // Nothing specified, so find the global list head
        pvProcess = (VOID*)GetExpr("ntdsa!pneHead");
        if (pvProcess) {
            // and read the address of the first entry
            NE ** ppAddr;
            ppAddr = ReadMemory(pvProcess, sizeof(PVOID));
            if (ppAddr) {
                pvProcess = *ppAddr;
                FreeMemory(ppAddr);
            }
            else {
                bSucceeded = FALSE;
                pvProcess = NULL;
            }
        }
    }

    while (pvProcess) {
        pneLocal = ReadMemory(pvProcess, sizeof(NE));
        if (pneLocal) {
            pvProcess = pneLocal->pneNext;
            Printf("%sNC DNT        %u\n",
                   Indent(nIndents),
                   pneLocal->ulNcdnt);
            Printf("%sNotify Time   %u ticks (%us from now)\n",
                   Indent(nIndents),
                   pneLocal->dwNotifyTime,
                   (pneLocal->dwNotifyTime > cTickNow)
                   ? (pneLocal->dwNotifyTime - cTickNow)/1000
                   : 0);
            Printf("%sUrgent        %s\n",
                   Indent(nIndents),
                   pneLocal->fUrgent
                   ? "True"
                   : "False");
            Printf("%spNext        @ %p\n\n",
                   Indent(nIndents),
                   pvProcess);
            FreeMemory(pneLocal);
        }
        else {
            pvProcess = NULL;
            bSucceeded = FALSE;
        }
    }
    return bSucceeded;
}

BOOL
Dump_UPTODATE_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public UPTODATE_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of UPTODATE_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = FALSE;
    UPTODATE_VECTOR *putodvec = NULL;
    DWORD           cNumCursors = 0;
    DWORD           iCursor;
    DWORD           cb;
    CHAR            szTime[SZDSTIME_LEN];

    Printf("%sUPTODATE_VECTOR @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    putodvec = (UPTODATE_VECTOR *) ReadMemory(pvProcess,
                                              UpToDateVecV1SizeFromLen(0));
    if (NULL != putodvec) {
        if (1 == putodvec->dwVersion) {
            cNumCursors = putodvec->V1.cNumCursors;
            cb = UpToDateVecV1Size(putodvec);
        } else if (2 == putodvec->dwVersion) {
            cNumCursors = putodvec->V2.cNumCursors;
            cb = UpToDateVecV2Size(putodvec);
        } else {
            Printf("%sInvalid UPTODATE_VECTOR version (%d).\n", Indent(nIndents), putodvec->dwVersion);
        }

        FreeMemory(putodvec);

        if (0 != cNumCursors) {
            putodvec = (UPTODATE_VECTOR *) ReadMemory(pvProcess, cb);

            if (NULL != putodvec) {
                for (iCursor = 0; iCursor < cNumCursors; iCursor++) {
                    if (1 == putodvec->dwVersion) {
                        Printf("%sDSA Invoc ID: %s  USN: %I64d\n",
                               Indent(nIndents),
                               DraUuidToStr(&putodvec->V1.rgCursors[iCursor].uuidDsa, NULL, 0),
                               putodvec->V1.rgCursors[iCursor].usnHighPropUpdate);
                    } else {
                        Printf("%sDSA Invoc ID: %s | USN: %I64d | Timestamp: %s\n",
                               Indent(nIndents),
                               DraUuidToStr(&putodvec->V2.rgCursors[iCursor].uuidDsa, NULL, 0),
                               putodvec->V2.rgCursors[iCursor].usnHighPropUpdate,
                               DSTimeToDisplayString(putodvec->V2.rgCursors[iCursor].timeLastSyncSuccess,
                                                     szTime));
                    }
                }

                FreeMemory(putodvec);
                fSuccess = TRUE;
            }
        }
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\kcc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcc.cxx

ABSTRACT:

    Routines to dump KCC structures.

DETAILS:

CREATED:

    99/01/19    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include "kcc.hxx"
#include "kccsite.hxx"
#include "kccdsa.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"

extern "C" {
#include "dsutil.h"
#include "dsexts.h"
#include "schedman.h"
#include "stalg.h"
#include "stda.h"
}

BOOL
Dump_KCC_SITE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL        fSuccess = FALSE;
    KCC_SITE *  pSite = NULL;
    const DWORD cchFieldWidth = 24;
    CHAR        szTime[SZDSTIME_LEN];

    Printf("%sKCC_SITE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSite = (KCC_SITE *) ReadMemory(pvProcess, sizeof(KCC_SITE));

    if (NULL != pSite) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSite->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pSite->m_dwOptions);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSiteObject", pSite->m_pdnSiteObject);
        if (pSite->m_pdnSiteObject
            && !Dump_DSNAME(1 + nIndents, pSite->m_pdnSiteObject)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnNtdsSiteSettings", pSite->m_pdnNtdsSiteSettings);
        if (pSite->m_pdnNtdsSiteSettings
            && !Dump_DSNAME(1 + nIndents, pSite->m_pdnNtdsSiteSettings)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSiteGenerator", pSite->m_pdnSiteGenerator);
        if (pSite->m_pdnSiteGenerator
            && !Dump_DSNAME(1 + nIndents, pSite->m_pdnSiteGenerator)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pSiteGeneratorDSA", pSite->m_pSiteGeneratorDSA);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_timeSiteGenSet",
               DSTimeToDisplayString(pSite->m_timeSiteGenSet, szTime));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pDsaList", pSite->m_pDsaList);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cNumTransportDsaLists", pSite->m_cNumTransportDsaLists);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pTransportDsaLists", pSite->m_pTransportDsaLists);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_destSiteConnMapSize", pSite->m_destSiteConnMapSize);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pDestSiteConnMap", pSite->m_pDestSiteConnMap);

        FreeMemory(pSite);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_SITE_LIST *   pSiteList = NULL;
    const DWORD       cchFieldWidth = 20;

    Printf("%sKCC_SITE_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteList = (KCC_SITE_LIST *) ReadMemory(pvProcess,
                                            sizeof(KCC_SITE_LIST));

    if (NULL != pSiteList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteList->m_fIsInitialized);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteArray));
        fSuccess = Dump_KCC_SITE_ARRAY( nIndents + 1,
               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteArray));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteNameArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteNameArray));

//        fSuccess = Dump_KCC_DSNAME_SITE_ARRAY( nIndents + 1,
//               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteNameArray));

        FreeMemory(pSiteList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_SITE_ARRAY *  pSiteArray = NULL;
    const DWORD       cchFieldWidth = 20;
    KCC_SITE **       ppSites;
    DWORD             iSite;

    Printf("%sKCC_SITE_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteArray = (KCC_SITE_ARRAY *) ReadMemory(pvProcess,
                                               sizeof(KCC_SITE_ARRAY));

    if (NULL != pSiteArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pSiteArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pSiteArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pSiteArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pSiteArray->m_Array);

        ppSites = (KCC_SITE **) ReadMemory(pSiteArray->m_Array,
                                           sizeof(KCC_SITE *) * pSiteArray->m_Count);
        if (NULL == ppSites) {
            fSuccess = FALSE;
        }
        else {
            for (iSite = 0; iSite < pSiteArray->m_Count; iSite++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iSite);
                if (!Dump_KCC_SITE(nIndents+1, ppSites[iSite])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppSites);
        }

        FreeMemory(pSiteArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSNAME_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_DSNAME_ARRAY *  pArray = NULL;
    const DWORD         cchFieldWidth = 20;
    KCC_DSNAME_SORT_ELEMENT *pElements;
    DWORD               iElem;

    Printf("%sKCC_DSNAME_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pArray = (KCC_DSNAME_ARRAY *) ReadMemory(pvProcess,
                                             sizeof(KCC_DSNAME_ARRAY));

    if (NULL != pArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pArray->m_Array);

        pElements = (KCC_DSNAME_SORT_ELEMENT *) ReadMemory(pArray->m_Array,
                                           sizeof(KCC_DSNAME_SORT_ELEMENT) * pArray->m_Count);
        if (NULL == pElements) {
            fSuccess = FALSE;
        } else {
            for (iElem = 0; iElem < pArray->m_Count; iElem++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iElem);
                Printf("%spszStringKey: %p\n",Indent(nIndents+1), pElements[iElem].pszStringKey );
                if (!Dump_DSNAME(nIndents+1, pElements[iElem].pDn)) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(pElements);
        }

        FreeMemory(pArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSNAME_SITE_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_DSNAME_SITE_ARRAY *  pArray = NULL;
    const DWORD         cchFieldWidth = 20;
    KCC_DSNAME_SITE_ELEMENT *pElements;
    DWORD               iElem;

    Printf("%sKCC_DSNAME_SITE_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pArray = (KCC_DSNAME_SITE_ARRAY *) ReadMemory(pvProcess,
                                             sizeof(KCC_DSNAME_SITE_ARRAY));

    if (NULL != pArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pArray->m_Array);

        pElements = (KCC_DSNAME_SITE_ELEMENT *) ReadMemory(pArray->m_Array,
                             sizeof(KCC_DSNAME_SITE_ELEMENT) * pArray->m_Count);
        if (NULL == pElements) {
            fSuccess = FALSE;
        } else {
            for (iElem = 0; iElem < pArray->m_Count; iElem++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iElem);
                Printf("%spszStringKey: %p\n",Indent(nIndents+1), pElements[iElem].pszStringKey );
                if (!Dump_KCC_SITE(nIndents+1, pElements[iElem].pSite)) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(pElements);
        }

        FreeMemory(pArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LINK_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                   fSuccess = FALSE;
    KCC_SITE_LINK_ARRAY *  pSiteLinkArray = NULL;
    const DWORD            cchFieldWidth = 20;
    KCC_SITE_LINK **       ppSiteLinks;
    DWORD                  iSiteLink;

    Printf("%sKCC_SITE_LINK_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteLinkArray = (KCC_SITE_LINK_ARRAY *) ReadMemory(pvProcess,
                                                        sizeof(KCC_SITE_LINK_ARRAY));

    if (NULL != pSiteLinkArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteLinkArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pSiteLinkArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pSiteLinkArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pSiteLinkArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pSiteLinkArray->m_Array);

        ppSiteLinks = (KCC_SITE_LINK **) ReadMemory(pSiteLinkArray->m_Array,
                                           sizeof(KCC_SITE_LINK *) * pSiteLinkArray->m_Count);
        if (NULL == ppSiteLinks) {
            fSuccess = FALSE;
        }
        else {
            for (iSiteLink = 0; iSiteLink < pSiteLinkArray->m_Count; iSiteLink++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iSiteLink);
                if (!Dump_KCC_SITE_LINK(nIndents+1, ppSiteLinks[iSiteLink])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppSiteLinks);
        }

        FreeMemory(pSiteLinkArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_BRIDGE_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                   fSuccess = FALSE;
    KCC_BRIDGE_ARRAY *     pBridgeArray = NULL;
    const DWORD            cchFieldWidth = 20;
    KCC_BRIDGE **          ppBridges;
    DWORD                  iBridge;

    Printf("%sKCC_BRIDGE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pBridgeArray = (KCC_BRIDGE_ARRAY *) ReadMemory(pvProcess,
                                                      sizeof(KCC_BRIDGE_ARRAY));

    if (NULL != pBridgeArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pBridgeArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pBridgeArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pBridgeArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pBridgeArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pBridgeArray->m_Array);

        ppBridges = (KCC_BRIDGE **) ReadMemory(pBridgeArray->m_Array,
                                           sizeof(KCC_BRIDGE *) * pBridgeArray->m_Count);
        if (NULL == ppBridges) {
            fSuccess = FALSE;
        }
        else {
            for (iBridge = 0; iBridge < pBridgeArray->m_Count; iBridge++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iBridge);
                if (!Dump_KCC_BRIDGE(nIndents+1, ppBridges[iBridge])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppBridges);
        }

        FreeMemory(pBridgeArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSA(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    KCC_DSA *       pDsa = NULL;
    const DWORD     cchFieldWidth = 22;
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           idn;
    DSNAME **       ppdn;
    KCC_DSA_ADDR *  pAddrs;
    DWORD           iAddr;

    Printf("%sKCC_DSA @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pDsa = (KCC_DSA *) ReadMemory(pvProcess, sizeof(KCC_DSA));

    if (NULL != pDsa) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pDsa->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnDSA", pDsa->m_pdnDSA);
        if (pDsa->m_pdnDSA
            && !Dump_DSNAME(1 + nIndents, pDsa->m_pdnDSA)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cMasterNCs", pDsa->m_cMasterNCs);
        ppdn = (DSNAME **) ReadMemory(pDsa->m_ppdnMasterNCs,
                                  sizeof(DSNAME *) * pDsa->m_cMasterNCs);
        if (NULL == ppdn) {
            fSuccess = FALSE;
        }
        else {
            for( idn = 0; idn < pDsa->m_cMasterNCs; idn++ ) {
                Printf("%sm_ppdnMasterNCs[%d]:\n",  Indent(nIndents), idn);
                if (ppdn[idn]
                    && !Dump_DSNAME(1 + nIndents, ppdn[idn])) {
                    fSuccess = FALSE;
                }
            }
            FreeMemory( ppdn );
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cFullReplicaNCs", pDsa->m_cFullReplicaNCs);
        ppdn = (DSNAME **) ReadMemory(pDsa->m_ppdnFullReplicaNCs,
                                  sizeof(DSNAME *) * pDsa->m_cFullReplicaNCs);
        if (NULL == ppdn) {
            fSuccess = FALSE;
        }
        else {
            for( idn = 0; idn < pDsa->m_cFullReplicaNCs; idn++ ) {
                Printf("%sm_ppdnFullReplicaNCs[%d]:\n",Indent(nIndents), idn);
                if (ppdn[idn]
                    && !Dump_DSNAME(1 + nIndents, ppdn[idn])) {
                    fSuccess = FALSE;
                }
            }
            FreeMemory( ppdn );
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fAddrsRead", pDsa->m_fAddrsRead);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cNumAddrs", pDsa->m_cNumAddrs);
        pAddrs = (KCC_DSA_ADDR *)
                    ReadMemory(pDsa->m_pAddrs,
                               sizeof(KCC_DSA_ADDR) * pDsa->m_cNumAddrs);
        if (NULL == pAddrs) {
            fSuccess = FALSE;
        }
        else {
            for (iAddr = 0; iAddr < pDsa->m_cNumAddrs; iAddr++) {
                Printf("%spDsa->m_pAddrs[%d]:\n",Indent(nIndents), iAddr);
                if (ATT_SMTP_MAIL_ADDRESS == pAddrs[iAddr].attrType) {
                    Printf("%sATT_SMTP_MAIL_ADDRESS (psz @ %p, pmtx @ %p):\n",
                           Indent(1 + nIndents),
                           pAddrs[iAddr].pszAddr,
                           pAddrs[iAddr].pmtxAddr);
                }
                else {
                    Printf("%sAttr 0x%x (psz @ %p, pmtx @ %p):\n",
                           Indent(1 + nIndents),
                           pAddrs[iAddr].attrType,
                           pAddrs[iAddr].pszAddr,
                           pAddrs[iAddr].pmtxAddr);
                }

                if (!Dump_MTX_ADDR(2 + nIndents, pAddrs[iAddr].pmtxAddr)) {
                    fSuccess = FALSE;
                }
            }
            
            FreeMemory(pAddrs);
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pDsa->m_dwOptions);
 
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSite", pDsa->m_pdnSite);
        if (pDsa->m_pdnSite
            && !Dump_DSNAME(1 + nIndents, pDsa->m_pdnSite)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwBehaviorVersion", pDsa->m_dwBehaviorVersion);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pIntraSiteCnList", pDsa->m_pIntraSiteCnList);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pInterSiteCnList", pDsa->m_pInterSiteCnList);

        FreeMemory(pDsa);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSA_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_DSA_LIST *    pDsaList = NULL;
    const DWORD       cchFieldWidth = 20;
    KCC_DSA **        ppDsas;
    DWORD             iDsa;

    Printf("%sKCC_DSA_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pDsaList = (KCC_DSA_LIST *) ReadMemory(pvProcess,
                                             sizeof(KCC_DSA_LIST));

    if (NULL != pDsaList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pDsaList->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pfnSortedBy", pDsaList->m_pfnSortedBy);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cdsa", pDsaList->m_cdsa);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppdsa", pDsaList->m_ppdsa);

        ppDsas = (KCC_DSA **) ReadMemory(pDsaList->m_ppdsa,
                                           sizeof(KCC_DSA *) * pDsaList->m_cdsa);
        if (NULL == ppDsas) {
            fSuccess = FALSE;
        }
        else {
            for (iDsa = 0; iDsa < pDsaList->m_cdsa; iDsa++) {
                Printf("%sm_ppdsa[%d]:\n",  Indent(nIndents), iDsa);
                if (!Dump_KCC_DSA(nIndents+1, ppDsas[iDsa])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppDsas);
        }

        FreeMemory(pDsaList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_CONNECTION(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_CONNECTION *  pConn = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sKCC_CONNECTION @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pConn = (KCC_CONNECTION *) ReadMemory(pvProcess, sizeof(KCC_CONNECTION));

    if (NULL != pConn) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnConnection", pConn->m_pdnConnection);
        if (pConn->m_pdnConnection
            && !Dump_DSNAME(1 + nIndents, pConn->m_pdnConnection)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsEnabled", pConn->m_fIsEnabled);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pSourceDSA", pConn->m_pSourceDSA);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pDestDSA", pConn->m_pDestDSA);
        if (pConn->m_pDestDSA
            && !Dump_KCC_DSA(1 + nIndents, pConn->m_pDestDSA)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnTransport", pConn->m_pdnTransport);
        if (pConn->m_pdnTransport
            && !Dump_DSNAME(1 + nIndents, pConn->m_pdnTransport)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pConn->m_dwOptions);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_toplSchedule",
               (BYTE *) pvProcess + offsetof(KCC_CONNECTION, m_toplSchedule));
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_timeCreated",
               DSTimeToDisplayString(pConn->m_timeCreated, szTime));
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ReasonForConnection", pConn->m_ReasonForConnection);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ReplicatedNCArray",
               (BYTE *) pvProcess + offsetof(KCC_CONNECTION, m_ReplicatedNCArray));
        if (!Dump_KCC_REPLICATED_NC_ARRAY(1 + nIndents,
                                          (BYTE *) pvProcess
                                          + offsetof(KCC_CONNECTION,
                                                     m_ReplicatedNCArray))) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fUpdatedOptions", pConn->m_fUpdatedOptions);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fUpdatedSchedule", pConn->m_fUpdatedSchedule);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fUpdatedTransport", pConn->m_fUpdatedTransport);

        FreeMemory(pConn);
    }

    return fSuccess;
}

BOOL
Dump_KCC_REPLICATED_NC_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                      fSuccess = FALSE;
    KCC_REPLICATED_NC_ARRAY * pArray = NULL;
    KCC_REPLICATED_NC **      ppReplNCs = NULL;
    const DWORD               cchFieldWidth = 24;
    DWORD                     iReplNC;

    Printf("%sKCC_REPLICATED_NC_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pArray = (KCC_REPLICATED_NC_ARRAY *)
                ReadMemory(pvProcess, sizeof(KCC_REPLICATED_NC_ARRAY));

    if (NULL != pArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pArray->m_Count);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pArray->m_Array);

        ppReplNCs = (KCC_REPLICATED_NC **)
                        ReadMemory(pArray->m_Array,
                                   sizeof(KCC_REPLICATED_NC *) * pArray->m_Count);
        if (NULL == ppReplNCs) {
            fSuccess = FALSE;
        }
        else {
            for (iReplNC = 0; iReplNC < pArray->m_Count; iReplNC++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iReplNC);
                if (!Dump_KCC_REPLICATED_NC(nIndents+1, ppReplNCs[iReplNC])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppReplNCs);
        }

        FreeMemory(pArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_REPLICATED_NC(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_REPLICATED_NC * pReplNC = NULL;
    const DWORD         cchFieldWidth = 24;

    Printf("%sKCC_REPLICATED_NC @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pReplNC = (KCC_REPLICATED_NC *) ReadMemory(pvProcess,
                                               sizeof(KCC_REPLICATED_NC));
    if (NULL != pReplNC) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "pNC", pReplNC->pNC);
        if (pReplNC->pNC
            && !Dump_DSNAME(1 + nIndents, pReplNC->pNC)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fReadOnly",
               pReplNC->fReadOnly ? "yes" : "no");

        FreeMemory(pReplNC);
    }

    return fSuccess;
}

BOOL
Dump_KCC_INTRASITE_CONNECTION_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                            fSuccess = FALSE;
    KCC_INTRASITE_CONNECTION_LIST * pList = NULL;
    const DWORD                     cchFieldWidth = 20;
    KCC_CONNECTION **               ppConns;
    DWORD                           iConn;

    Printf("%sKCC_INTRASITE_CONNECTION_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_INTRASITE_CONNECTION_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_INTRASITE_CONNECTION_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ccn", pList->m_ccn);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppcn", pList->m_ppcn);

        ppConns = (KCC_CONNECTION **)
                        ReadMemory(pList->m_ppcn,
                                   sizeof(KCC_CONNECTION *) * pList->m_ccn);
        if (NULL == ppConns) {
            fSuccess = FALSE;
        }
        else {
            for (iConn = 0; iConn < pList->m_ccn; iConn++) {
                Printf("%sm_ppcn[%d]:\n",  Indent(nIndents), iConn);
                if (!Dump_KCC_CONNECTION(nIndents+1, ppConns[iConn])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppConns);
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_INTERSITE_CONNECTION_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                            fSuccess = FALSE;
    KCC_INTERSITE_CONNECTION_LIST * pList = NULL;
    const DWORD                     cchFieldWidth = 20;
    KCC_CONNECTION **               ppConns;
    DWORD                           iConn;

    Printf("%sKCC_INTERSITE_CONNECTION_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_INTERSITE_CONNECTION_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_INTERSITE_CONNECTION_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ccn", pList->m_ccn);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppcn", pList->m_ppcn);

        ppConns = (KCC_CONNECTION **)
                        ReadMemory(pList->m_ppcn,
                                   sizeof(KCC_CONNECTION *) * pList->m_ccn);
        if (NULL == ppConns) {
            fSuccess = FALSE;
        }
        else {
            for (iConn = 0; iConn < pList->m_ccn; iConn++) {
                Printf("%sm_ppcn[%d]:\n",  Indent(nIndents), iConn);
                if (!Dump_KCC_CONNECTION(nIndents+1, ppConns[iConn])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppConns);
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_TRANSPORT(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_TRANSPORT *   pTransport = NULL;
    const DWORD       cchFieldWidth = 24;

    Printf("%sKCC_TRANSPORT @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pTransport = (KCC_TRANSPORT *) ReadMemory(pvProcess, sizeof(KCC_TRANSPORT));

    if (NULL != pTransport) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pTransport->m_fIsInitialized);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdn", pTransport->m_pdn);
        if (pTransport->m_pdn
            && !Dump_DSNAME(1 + nIndents, pTransport->m_pdn)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "m_attAddressType", pTransport->m_attAddressType);

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pTransport->m_dwOptions);

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSiteLinkListInitialized",
               pTransport->m_fIsSiteLinkListInitialized);

        if (pTransport->m_fIsSiteLinkListInitialized) {
            Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
                   "m_SiteLinkList",
                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_SiteLinkList));
//            fSuccess = Dump_KCC_SITE_LINK_LIST( nIndents + 1,
//                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_SiteLinkList));
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsBridgeListInitialized",
               pTransport->m_fIsBridgeListInitialized);

        if (pTransport->m_fIsBridgeListInitialized) {
            Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
                   "m_BridgeList",
                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_BridgeList));
//            fSuccess = Dump_KCC_BRIDGE_LIST( nIndents + 1,
//                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_BridgeList));
        }

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_AllExplicitBridgeheadArray",
               (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_AllExplicitBridgeheadArray));

//        fSuccess = Dump_KCC_DSNAME_ARRAY( nIndents + 1,
//               (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_AllExplicitBridgeheadArray));

        FreeMemory(pTransport);
    }

    return fSuccess;
}

BOOL
Dump_KCC_TRANSPORT_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    KCC_TRANSPORT_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 20;
    BYTE *                pTransport;
    DWORD                 iTransport;

    Printf("%sKCC_TRANSPORT_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_TRANSPORT_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_TRANSPORT_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cTransports", pList->m_cTransports);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pTransports", pList->m_pTransports);


        // This is a pointer to an array of the objects themselves.
        pTransport = (BYTE *) pList->m_pTransports;
        if (pTransport) {
            for (iTransport = 0; iTransport < pList->m_cTransports; iTransport++) {
                printf("%sm_pTransports[%d]:\n",  Indent(nIndents), iTransport);
                if (!Dump_KCC_TRANSPORT(nIndents+1, pTransport)) {
                    fSuccess = FALSE;
                    break;
                }
                pTransport += sizeof( KCC_TRANSPORT );
            }
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DS_CACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    KCC_DS_CACHE *  pCache = NULL;
    const DWORD     cchFieldWidth = 20;

    Printf("%sKCC_DS_CACHE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCache = (KCC_DS_CACHE *) ReadMemory(pvProcess,
                                         sizeof(KCC_DS_CACHE));

    if (NULL != pCache) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_initializationStage", pCache->m_initializationStage);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fRunningUnderAltID", pCache->m_fRunningUnderAltID);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnLocalDSA", pCache->m_pdnLocalDSA);
        if (pCache->m_pdnLocalDSA
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnLocalDSA)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnConfiguration", pCache->m_pdnConfiguration);
        if (pCache->m_pdnConfiguration
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnConfiguration)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSchema", pCache->m_pdnSchema);
        if (pCache->m_pdnSchema
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnSchema)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnIpTransport", pCache->m_pdnIpTransport);
        if (pCache->m_pdnIpTransport
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnIpTransport)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszForestDnsName", pCache->m_pszForestDnsName);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_CrossRefList",
               (BYTE *) pvProcess + offsetof(KCC_DS_CACHE, m_CrossRefList));
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_TransportList",
               (BYTE *) pvProcess + offsetof(KCC_DS_CACHE, m_TransportList));
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteList",
               (BYTE *) pvProcess + offsetof(KCC_DS_CACHE, m_SiteList));
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_pLocalSite", (BYTE *) pCache->m_pLocalSite);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pLocalDSA", pCache->m_pLocalDSA);

        FreeMemory(pCache);
    }

    return fSuccess;
}

BOOL
Dump_KCC_CROSSREF(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    KCC_CROSSREF *  pCR = NULL;
    const DWORD     cchFieldWidth = 30;
    CHAR            szTime[SZDSTIME_LEN];
    LPSTR           pszType;
    BYTE *          pb;

    Printf("%sKCC_CROSSREF @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCR = (KCC_CROSSREF *) ReadMemory(pvProcess, sizeof(KCC_CROSSREF));

    if (NULL != pCR) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnNC", pCR->m_pdnNC);
        if (pCR->m_pdnNC
            && !Dump_DSNAME(1 + nIndents, pCR->m_pdnNC)) {
            fSuccess = FALSE;
        }

        switch (pCR->m_NCType) {
        case KCC_NC_TYPE_INVALID:   pszType = "KCC_NC_TYPE_INVALID";   break;
        case KCC_NC_TYPE_CONFIG:    pszType = "KCC_NC_TYPE_CONFIG";    break;
        case KCC_NC_TYPE_SCHEMA:    pszType = "KCC_NC_TYPE_SCHEMA";    break;
        case KCC_NC_TYPE_DOMAIN:    pszType = "KCC_NC_TYPE_DOMAIN";    break;
        case KCC_NC_TYPE_NONDOMAIN: pszType = "KCC_NC_TYPE_NONDOMAIN"; break;
        default:                    pszType = "!!UNKNOWN!!";           break;
        }

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_NCType", pszType);
        
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsReplicatedToGCs",
               pCR->m_fIsReplicatedToGCs ? "TRUE" : "FALSE");
        
        pb = (BYTE *) pvProcess + offsetof(KCC_CROSSREF, m_NCReplicaLocationsArray);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_NCReplicaLocationsArray", pb);
        if (!Dump_KCC_DSNAME_ARRAY(nIndents + 1, pb)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pLinkList", pCR->m_pLinkList);

        
        FreeMemory(pCR);
    }

    return fSuccess;
}

BOOL
Dump_KCC_CROSSREF_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_CROSSREF_LIST * pCRList = NULL;
    const DWORD         cchFieldWidth = 20;
    DWORD               iCR;

    Printf("%sKCC_CROSSREF_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCRList = (KCC_CROSSREF_LIST *) ReadMemory(pvProcess,
                                               sizeof(KCC_CROSSREF_LIST));

    if (NULL != pCRList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pCRList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwForestVersion", pCRList->m_dwForestVersion);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ccref", pCRList->m_ccref);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pcref", pCRList->m_pcref);

        for (iCR = 0; iCR < pCRList->m_ccref; iCR++) {
            Printf("%sm_pcref[%d]:\n",  Indent(nIndents), iCR);
            if (!Dump_KCC_CROSSREF(nIndents+1,
                                   &pCRList->m_pcref[iCR])) {
                fSuccess = FALSE;
                break;
            }
        }

        FreeMemory(pCRList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LINK(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_SITE_LINK *   pSiteLink = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sKCC_SITE_LINK @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteLink = (KCC_SITE_LINK *) ReadMemory(pvProcess, sizeof(KCC_SITE_LINK));

    if (NULL != pSiteLink) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteLink->m_fIsInitialized);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdn", pSiteLink->m_pdnSiteLinkObject);
        if (pSiteLink->m_pdnSiteLinkObject
            && !Dump_DSNAME(1 + nIndents, pSiteLink->m_pdnSiteLinkObject)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pSiteLink->m_dwOptions);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwCost", pSiteLink->m_dwCost);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwReplInterval", pSiteLink->m_dwReplInterval);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hSchedule", pSiteLink->m_hSchedule);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LINK, m_SiteArray));

        fSuccess = Dump_KCC_SITE_ARRAY( nIndents + 1,
               (BYTE *) pvProcess + offsetof(KCC_SITE_LINK, m_SiteArray));

        FreeMemory(pSiteLink);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LINK_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    KCC_SITE_LINK_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 20;

    Printf("%sKCC_SITE_LINK_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_SITE_LINK_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_SITE_LINK_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteLinkArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LINK_LIST, m_SiteLinkArray));

        Dump_KCC_SITE_LINK_ARRAY( nIndents + 1,
                 (BYTE *) pvProcess + offsetof(KCC_SITE_LINK_LIST, m_SiteLinkArray));

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_BRIDGE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_BRIDGE *      pBridge = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sKCC_BRIDGE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pBridge = (KCC_BRIDGE *) ReadMemory(pvProcess, sizeof(KCC_BRIDGE));

    if (NULL != pBridge) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pBridge->m_fIsInitialized);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdn", pBridge->m_pdnBridgeObject);
        if (pBridge->m_pdnBridgeObject
            && !Dump_DSNAME(1 + nIndents, pBridge->m_pdnBridgeObject)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteLinkArray",
               (BYTE *) pvProcess + offsetof(KCC_BRIDGE, m_SiteLinkArray));

        fSuccess = Dump_KCC_SITE_LINK_ARRAY( nIndents + 1,
               (BYTE *) pvProcess + offsetof(KCC_BRIDGE, m_SiteLinkArray));

        FreeMemory(pBridge);
    }

    return fSuccess;
}

BOOL
Dump_KCC_BRIDGE_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    KCC_BRIDGE_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 20;

    Printf("%sKCC_BRIDGE_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_BRIDGE_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_BRIDGE_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_BridgeArray",
               (BYTE *) pvProcess + offsetof(KCC_BRIDGE_LIST, m_BridgeArray));

        Dump_KCC_BRIDGE_ARRAY( nIndents + 1,
                 (BYTE *) pvProcess + offsetof(KCC_BRIDGE_LIST, m_BridgeArray));

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_TOPL_REPL_INFO(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PTOPL_REPL_INFO   pRI = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sTOPL_REPL_INFO @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pRI = (PTOPL_REPL_INFO) ReadMemory(pvProcess, sizeof(TOPL_REPL_INFO));

    if (NULL != pRI) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "cost", pRI->cost);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "repIntvl", pRI->repIntvl);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "options", pRI->options);
        fSuccess &= Dump_TOPL_SCHEDULE( nIndents + 1, (BYTE*) pRI->schedule );

        FreeMemory(pRI);
    }

    return fSuccess;
}

BOOL
Dump_ToplVertex(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PToplVertex       v = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sToplVertex @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    v = (PToplVertex) ReadMemory(pvProcess, sizeof(ToplVertex));

    if (NULL != v) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "vtxId", v->vtxId);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vertexName", v->vertexName);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "edgeList", v->edgeList);
        
        fSuccess &= Dump_DynArray( nIndents + 1,
               (BYTE*) pvProcess + offsetof(ToplVertex, edgeList));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "color", v->color);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "acceptRedRed", v->acceptRedRed);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "acceptBlack", v->acceptBlack);

        fSuccess &= Dump_TOPL_REPL_INFO( nIndents + 1,
               (BYTE *) pvProcess + offsetof(ToplVertex, ri));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "heapLocn", v->heapLocn);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "root", v->root);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "demoted", v->demoted);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "componentId", v->componentId);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "componentIndex", v->componentIndex);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "distToRed", v->distToRed);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "parent", v->parent);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "nextChild", v->nextChild);
    }

    return fSuccess;
}


BOOL
Dump_ToplGraphState(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PToplGraphState   g = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sToplGraphState @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    g = (PToplGraphState) ReadMemory(pvProcess, sizeof(ToplGraphState));

    if (NULL != g) {
        fSuccess = TRUE;

        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicStart", g->magicStart);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vertexNames", g->vertexNames);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vertices", g->vertices);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "numVertices", g->numVertices);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "melSorted", g->melSorted);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "masterEdgeList", g->masterEdgeList);
        fSuccess &= Dump_DynArray( nIndents + 1,
               (BYTE*) pvProcess + offsetof(ToplGraphState, masterEdgeList));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "edgeSets", g->edgeSets);
        fSuccess &= Dump_DynArray( nIndents + 1,
               (BYTE*) pvProcess + offsetof(ToplGraphState, edgeSets));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vnCompFunc", g->vnCompFunc);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "schedCache", g->schedCache);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicEnd", g->magicEnd);
    }

    return fSuccess;
}


BOOL
Dump_ToplInternalEdge(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PToplInternalEdge e = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sToplInternalEdge @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    e = (PToplInternalEdge) ReadMemory(pvProcess, sizeof(ToplInternalEdge));

    if (NULL != e) {
        fSuccess = TRUE;

        fSuccess &= Dump_ToplVertex( nIndents + 1, e->v1 );
        fSuccess &= Dump_ToplVertex( nIndents + 1, e->v2 );

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "redRed", e->redRed);

        fSuccess &= Dump_TOPL_REPL_INFO( nIndents + 1,
               (BYTE *) pvProcess + offsetof(ToplInternalEdge, ri));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "edgeType", e->edgeType);
    }

    return fSuccess;
}


BOOL
Dump_TOPL_SCHEDULE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    ToplSched        *s = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    if( pvProcess==NULL ) {
        Printf("%sToplSchedule: NULL (Always Schedule)\n", Indent(nIndents), pvProcess);
        return TRUE;
    } 

    Printf("%sToplSchedule @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    s = (ToplSched*) ReadMemory(pvProcess, sizeof(ToplSched));

    if (NULL != s) {
        fSuccess = TRUE;

        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicStart", s->magicStart);

        fSuccess &= Dump_PSCHEDULE( nIndents + 1, (BYTE *) s->s );

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "duration", s->duration);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicEnd", s->magicEnd);
    }

    return fSuccess;
}


BOOL
Dump_PSCHEDULE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PSCHEDULE         s;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sSCHEDULE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    s = (PSCHEDULE) ReadMemory(pvProcess, sizeof(SCHEDULE));

    if (NULL != s) {
        fSuccess = TRUE;

        if( s->Size!=sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES
         || s->NumberOfSchedules!=1
         || s->Schedules[0].Type!=SCHEDULE_INTERVAL
         || s->Schedules[0].Offset!=sizeof(SCHEDULE) )
        {
            Printf("%s%-*s: \n", Indent(nIndents), cchFieldWidth,
                   "Unsupported Schedule Type!");
            return FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "Size", s->Size);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "Bandwidth", s->Bandwidth);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "NumberOfSchedules", s->NumberOfSchedules);

        Printf("%s%-*s: \n", Indent(nIndents), cchFieldWidth,
               "Data" );
        data = (PBYTE) ReadMemory( ((PBYTE)pvProcess)+sizeof(SCHEDULE),
            SCHEDULE_DATA_ENTRIES );
        if( NULL != data ) {
            for( i=0; i<SCHEDULE_DATA_ENTRIES; i++ ) {
                Printf("%02x ",data[i]);
            }
        }
        Printf("\n");
    }

    return fSuccess;
}


BOOL
Dump_DynArray(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PDynArray         da;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sDynArray @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    da = (PDynArray) ReadMemory(pvProcess, sizeof(DynArray));

    if (NULL != da) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "elementSize", da->elementSize);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "logicalElements", da->logicalElements);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "physicalElements", da->physicalElements);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "data", da->data );
    }

    return fSuccess;
}


BOOL
Dump_TOPL_MULTI_EDGE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PTOPL_MULTI_EDGE  e;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sPTOPL_MULTI_EDGE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    e = (PTOPL_MULTI_EDGE) ReadMemory(pvProcess, sizeof(TOPL_MULTI_EDGE));
    if (NULL != e) {
        e = (PTOPL_MULTI_EDGE) ReadMemory(pvProcess, sizeof(TOPL_MULTI_EDGE)
            + sizeof(TOPL_NAME_STRUCT)*(e->numVertices-1) );
    }

    if (NULL != e) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "numVertices", e->numVertices);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "edgeType", e->edgeType);

        fSuccess &= Dump_TOPL_REPL_INFO( nIndents + 1,
               (BYTE *) pvProcess + offsetof(TOPL_MULTI_EDGE, ri));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "fDirectedEdge", e->fDirectedEdge);

        if( e->numVertices <= 8 ) {
            for( i=0; i<e->numVertices; i++ ) {
                Printf("%s%-*s[%d].name: %p\n", Indent(nIndents), cchFieldWidth,
                       "vertexNames", i, e->vertexNames[i].name );
                Printf("%s%-*s[%d].reserved: %d\n", Indent(nIndents), cchFieldWidth,
                       "vertexNames", i, e->vertexNames[i].reserved );
            }
        }
    }

    return fSuccess;
}


BOOL
Dump_TOPL_MULTI_EDGE_SET(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PTOPL_MULTI_EDGE_SET  eSet;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sPTOPL_MULTI_EDGE_SET @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    eSet = (PTOPL_MULTI_EDGE_SET) ReadMemory(pvProcess, sizeof(TOPL_MULTI_EDGE_SET));

    if (NULL != eSet) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "numMultiEdges", eSet->numMultiEdges );
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "multiEdgeList", eSet->multiEdgeList );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\ism.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcc.cxx

ABSTRACT:

    Routines to dump KCC structures.

DETAILS:

CREATED:

    99/01/19    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

extern "C" {
#include "ntdsa.h"
#include "debug.h"
#include "dsutil.h"
#include "dsexts.h"
}

#include "ismapi.h"
#include "ismserv.hxx"


BOOL
Dump_ISM_PENDING_ENTRY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    ISM_PENDING_ENTRY * pEntry = NULL;
    const DWORD         cchFieldWidth = 24;

    Printf("%sISM_PENDING_ENTRY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pEntry = (ISM_PENDING_ENTRY *) ReadMemory(pvProcess,
                                              sizeof(ISM_PENDING_ENTRY));

    if (NULL != pEntry) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "hEvent", pEntry->hEvent);
        
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "szServiceName",
               (BYTE *) pvProcess + offsetof(ISM_PENDING_ENTRY, szServiceName));

        FreeMemory(pEntry);
    }

    return fSuccess;
}

BOOL
Dump_ISM_PENDING_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    ISM_PENDING_LIST *  pList = NULL;
    const DWORD         cchFieldWidth = 24;
    DWORD               iEntry;
    ISM_PENDING_ENTRY * pEntry;

    Printf("%sISM_PENDING_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (ISM_PENDING_LIST *) ReadMemory(pvProcess,
                                            sizeof(ISM_PENDING_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_Lock",
               (BYTE *) pvProcess + offsetof(ISM_PENDING_LIST, m_Lock));

        for (iEntry = 0, pEntry = pList->m_pPending;
             NULL != pEntry;
             iEntry++, pEntry = pEntry->pNext) {
            if (!Dump_ISM_PENDING_ENTRY(nIndents+1, pEntry)) {
                fSuccess = FALSE;
                break;
            }
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_ISM_TRANSPORT(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    ISM_TRANSPORT * pTransport = NULL;
    const DWORD     cchFieldWidth = 26;

    Printf("%sISM_TRANSPORT @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pTransport = (ISM_TRANSPORT *) ReadMemory(pvProcess,
                                              sizeof(ISM_TRANSPORT));

    if (NULL != pTransport) {
        fSuccess = TRUE;

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized",
               pTransport->m_fIsInitialized ? "TRUE" : "FALSE");
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszTransportDN", pTransport->m_pszTransportDN);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszTransportDll", pTransport->m_pszTransportDll);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_TransportGuid",
               DraUuidToStr(&pTransport->m_TransportGuid, NULL, 0));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hIsm", pTransport->m_hIsm);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_PendingList",
               (BYTE *) pvProcess + offsetof(ISM_TRANSPORT, m_PendingList));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hDll", pTransport->m_hDll);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pStartup", pTransport->m_pStartup);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pRefresh", pTransport->m_pRefresh);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pSend", pTransport->m_pSend);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pReceive", pTransport->m_pReceive);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeMsg", pTransport->m_pFreeMsg);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pGetConnectivity", pTransport->m_pGetConnectivity);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeConnectivity", pTransport->m_pFreeConnectivity);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pGetTransportServers", pTransport->m_pGetTransportServers);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeTransportServers", pTransport->m_pFreeTransportServers);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pGetConnectionSchedule", pTransport->m_pGetConnectionSchedule);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeConnectionSchedule", pTransport->m_pFreeConnectionSchedule);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pShutdown", pTransport->m_pShutdown);

        FreeMemory(pTransport);
    }

    return fSuccess;
}

BOOL
Dump_ISM_TRANSPORT_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    ISM_TRANSPORT_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 26;
    ISM_TRANSPORT **      ppTransports;
    DWORD                 iTransport;

    Printf("%sISM_TRANSPORT_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (ISM_TRANSPORT_LIST *) ReadMemory(pvProcess,
                                              sizeof(ISM_TRANSPORT_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_Lock",
               (BYTE *) pvProcess + offsetof(ISM_TRANSPORT_LIST, m_Lock));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hLdap", pList->m_hLdap);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hTransportMonitorThread", pList->m_hTransportMonitorThread);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hSiteMonitorThread", pList->m_hSiteMonitorThread);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "m_ulTransportNotifyMsgNum", pList->m_ulTransportNotifyMsgNum);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "m_ulSiteNotifyMsgNum", pList->m_ulSiteNotifyMsgNum);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszTransportContainerDN", pList->m_pszTransportContainerDN);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszSiteContainerDN", pList->m_pszSiteContainerDN);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hChangeEvent", pList->m_hChangeEvent);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cNumTransports", pList->m_cNumTransports);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppTransport", pList->m_ppTransport);

        ppTransports = (ISM_TRANSPORT **)
                            ReadMemory(pList->m_ppTransport,
                                       sizeof(ISM_TRANSPORT *)
                                            * pList->m_cNumTransports);
        if (NULL == ppTransports) {
            fSuccess = FALSE;
        }
        else {
            for (iTransport = 0;
                 iTransport < pList->m_cNumTransports;
                 iTransport++) {
                Printf("%sm_ppTransport[%d]:\n",  Indent(nIndents), iTransport);
                if (!Dump_ISM_TRANSPORT(nIndents+1,
                                        ppTransports[iTransport])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppTransports);
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_ISM_SERVICE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    ISM_SERVICE *   pService = NULL;
    const DWORD     cchFieldWidth = 24;

    Printf("%sISM_SERVICE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pService = (ISM_SERVICE *) ReadMemory(pvProcess,
                                              sizeof(ISM_SERVICE));

    if (NULL != pService) {
        fSuccess = TRUE;

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized",
               pService->m_fIsInitialized ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsRunningAsService",
               pService->m_fIsRunningAsService ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsStopPending",
               pService->m_fIsStopPending ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsRpcServerListening",
               pService->m_fIsRpcServerListening ? "TRUE" : "FALSE");
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_TransportList",
               (BYTE *) pvProcess + offsetof(ISM_SERVICE, m_TransportList));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hShutdown", pService->m_hShutdown);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hLogLevelChange", pService->m_hLogLevelChange);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "m_Status", pService->m_Status);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hStatus", pService->m_hStatus);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pServiceCtrlHandler", pService->m_pServiceCtrlHandler);

        FreeMemory(pService);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\dsexts.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsexts.c

Abstract:

    Implements public entry points for the DS ntsd/windbg extensions DLL.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Jan-00   XinHe       Added Dump_TQEntry() into rDumpItems

    24-Apr-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop
#include "dsexts.h"
#include <ntverp.h>
#include <debug.h>

//
// Globals
//

PNTSD_EXTENSION_APIS    gpExtApis;
HANDLE                  ghDbgThread;
HANDLE                  ghDbgProcess;
LPSTR                   gpszCommand;
BOOL                    gfVerbose = FALSE;

//
// Dump declarations.  A new element should be added to rDumpItems[] for each
// new type which the extension knows how to dump.  The help entry point
// automatically generates help based on ?DumpItems as well.
//
// Individual dump functions return a BOOL success code so that dump functions
// can call each other and break out on error.  I.e. as soon as the first
// nested dump function encounters a bogus pointer, for example.  First
// argument (DWORD) indicates indentation level, second argument (PVOID) is
// address of struct in address space of process being debugged.  This way
// Dump_* routines can easily construct an indented output by incrementing the
// indentation level and calling one another.
//
// Dump functions should dump all values in hex for consistency - i.e. "%x".
//

typedef struct _DumpItem {
    CHAR    *pszType;
    BOOL    (*pFunc)(DWORD nIndents, PVOID pvProcess);
} DumpItem;

DumpItem rDumpItems[] = {
    { "AddArg",                         Dump_AddArg},
    { "AddRes",                         Dump_AddRes},
    { "AO",                             Dump_AO},
    { "AOLIST",                         Dump_AOLIST},
    { "ATQ_CONTEXT",                    Dump_ATQ_CONTEXT},
    { "ATQ_ENDPOINT",                   Dump_ATQ_ENDPOINT},
    { "ATQC_ACTIVE_list",               Dump_ATQC_ACTIVE_list},
    { "ATQC_PENDING_list",              Dump_ATQC_PENDING_list},
    { "ATTCACHE",                       Dump_ATTCACHE},
    { "ATTR",                           Dump_Attr},
    { "ATTRBLOCK",                      Dump_AttrBlock},
    { "ATTRVALBLOCK",                   Dump_AttrValBlock},
    { "BackupContext",                  Dump_BackupContext},
    { "BHCache",                        Dump_BHCache},
    { "Binary",                         Dump_Binary},
    { "BINDARG",                        Dump_BINDARG},
    { "BINDRES",                        Dump_BINDRES},
    { "CLASSCACHE",                     Dump_CLASSCACHE},
    { "COMMARG",                        Dump_CommArg},
    { "CONTEXT",                        Dump_Context},
    { "CONTEXTLIST",                    Dump_ContextList},
    { "d_memname",                      Dump_d_memname},
    { "d_tagname",                      Dump_d_tagname},
    { "DBPOS",                          Dump_DBPOS},
    { "DirWaitItem",                    Dump_DirWaitItem},
    { "DirWaitList",                    Dump_DirWaitList},
    { "GLOBALDNREADCACHE",              Dump_GLOBALDNREADCACHE},
    { "LOCALDNREADCACHE",               Dump_LOCALDNREADCACHE},
    { "DefinedDomain",                  Dump_DefinedDomain},
    { "DefinedDomains",                 Dump_DefinedDomains},
    { "DRS_ASYNC_RPC_STATE",            Dump_DRS_ASYNC_RPC_STATE},
    { "DRS_MSG_GETCHGREQ_V4",           Dump_DRS_MSG_GETCHGREQ_V4},
    { "DRS_MSG_GETCHGREQ_V5",           Dump_DRS_MSG_GETCHGREQ_V5},
    { "DRS_MSG_GETCHGREQ_V8",           Dump_DRS_MSG_GETCHGREQ_V8},
    { "DRS_MSG_GETCHGREPLY_V1",         Dump_DRS_MSG_GETCHGREPLY_V1},
    { "DRS_MSG_GETCHGREPLY_V6",         Dump_DRS_MSG_GETCHGREPLY_V6},
    { "DRS_MSG_GETCHGREPLY_VALUES",     Dump_DRS_MSG_GETCHGREPLY_VALUES},
    { "DSA_ANCHOR",                     Dump_DSA_ANCHOR},
    { "DSNAME",                         Dump_DSNAME},
    { "DynArray",                       Dump_DynArray},
    { "ENTINF",                         Dump_ENTINF},
    { "ENTINFSEL",                      Dump_ENTINFSEL},
    { "EscrowInfo",                     Dump_EscrowInfo},
    { "FILTER",                         Dump_FILTER},
    { "GCDeletionList",                 Dump_GCDeletionList},
    { "GCDeletionListProcessed",        Dump_GCDeletionListProcessed},
    { "GUID",                           Dump_UUID},
    { "INDEXSIZE",                      Dump_INDEXSIZE},
    { "INITSYNC",                       Dump_INITSYNC},
    { "INVALIDATED_DC_LIST",            Dump_INVALIDATED_DC_LIST},
    { "ISM_PENDING_ENTRY",              Dump_ISM_PENDING_ENTRY},
    { "ISM_PENDING_LIST",               Dump_ISM_PENDING_LIST},
    { "ISM_SERVICE",                    Dump_ISM_SERVICE},
    { "ISM_TRANSPORT",                  Dump_ISM_TRANSPORT},
    { "ISM_TRANSPORT_LIST",             Dump_ISM_TRANSPORT_LIST},
    { "JETBACK_SERVER_CONTEXT",         Dump_JETBACK_SERVER_CONTEXT},
    { "JETBACK_SHARED_CONTROL",         Dump_JETBACK_SHARED_CONTROL},
    { "JETBACK_SHARED_HEADER",          Dump_JETBACK_SHARED_HEADER},
    { "KCC_BRIDGE",                     Dump_KCC_BRIDGE},
    { "KCC_BRIDGE_LIST",                Dump_KCC_BRIDGE_LIST},
    { "KCC_DS_CACHE",                   Dump_KCC_DS_CACHE},
    { "KCC_CONNECTION",                 Dump_KCC_CONNECTION},
    { "KCC_CROSSREF",                   Dump_KCC_CROSSREF},
    { "KCC_CROSSREF_LIST",              Dump_KCC_CROSSREF_LIST},
    { "KCC_DSA",                        Dump_KCC_DSA},
    { "KCC_DSA_LIST",                   Dump_KCC_DSA_LIST},
    { "KCC_DSNAME_ARRAY",               Dump_KCC_DSNAME_ARRAY},
    { "KCC_DSNAME_SITE_ARRAY",          Dump_KCC_DSNAME_SITE_ARRAY},
    { "KCC_INTERSITE_CONNECTION_LIST",  Dump_KCC_INTERSITE_CONNECTION_LIST},
    { "KCC_INTRASITE_CONNECTION_LIST",  Dump_KCC_INTRASITE_CONNECTION_LIST},
    { "KCC_REPLICATED_NC",              Dump_KCC_REPLICATED_NC},
    { "KCC_REPLICATED_NC_ARRAY",        Dump_KCC_REPLICATED_NC_ARRAY},
    { "KCC_SITE",                       Dump_KCC_SITE},
    { "KCC_SITE_ARRAY",                 Dump_KCC_SITE_ARRAY},
    { "KCC_SITE_LINK",                  Dump_KCC_SITE_LINK},
    { "KCC_SITE_LINK_LIST",             Dump_KCC_SITE_LINK_LIST},
    { "KCC_SITE_LIST",                  Dump_KCC_SITE_LIST},
    { "KCC_TRANSPORT",                  Dump_KCC_TRANSPORT},
    { "KCC_TRANSPORT_LIST",             Dump_KCC_TRANSPORT_LIST},
    { "KEY",                            Dump_KEY},
    { "KEY_INDEX",                      Dump_KEY_INDEX},
    { "LDAP_CONN",                      Dump_USERDATA},
    { "LDAP_CONN_list",                 Dump_USERDATA_list},
    { "LIMITS",                         Dump_LIMITS},
    { "MODIFYARG",                      Dump_MODIFYARG},
    { "MODIFYDNARG",                    Dump_MODIFYDNARG},
    { "MTX_ADDR",                       Dump_MTX_ADDR},
    { "NCSYNCDATA",                     Dump_NCSYNCDATA},
    { "NCSYNCSOURCE",                   Dump_NCSYNCSOURCE},
    { "PAGED",                          Dump_PAGED},
    { "PARTIAL_ATTR_VECTOR",            Dump_PARTIAL_ATTR_VECTOR},
    { "PROPERTY_META_DATA_EXT_VECTOR",  Dump_PROPERTY_META_DATA_EXT_VECTOR},
    { "PROPERTY_META_DATA_VECTOR",      Dump_PROPERTY_META_DATA_VECTOR},
    { "ProxyVal",                       Dump_ProxyVal},
    { "PSCHEDULE",                      Dump_PSCHEDULE},
    { "ReadArg",                        Dump_ReadArg},
    { "ReadRes",                        Dump_ReadRes},
    { "RemoveArg",                      Dump_RemoveArg},
    { "RemoveRes",                      Dump_RemoveRes},
    { "REPLENTINFLIST",                 Dump_REPLENTINFLIST},
    { "REPLICA_LINK",                   Dump_REPLICA_LINK},
    { "ReplNotifyElement",              Dump_ReplNotifyElement},
    { "REPLTIMES",                      Dump_REPLTIMES},
    { "REPLVALINF",                     Dump_REPLVALINF},
    { "REQUEST",                        Dump_REQUEST},
    { "REQUEST_list",                   Dump_REQUEST_list},
    { "SAMP_LOOPBACK_ARG",              Dump_SAMP_LOOPBACK_ARG},
    { "SearchArg",                      Dump_SearchArg},
    { "SearchRes",                      Dump_SearchRes},
    { "SCHEMAPTR",                      Dump_SCHEMAPTR},
    { "SCHEMA_PREFIX_TABLE",            Dump_SCHEMA_PREFIX_TABLE},
    { "SD",                             Dump_SD},
    { "SID",                            Dump_Sid},
    { "SPROPTAG",                       Dump_SPropTag},
    { "SROWSET",                        Dump_SRowSet},
    { "STAT",                           Dump_STAT},
    { "SUBSTRING",                      Dump_SUBSTRING},
    { "THSTATE",                        Dump_THSTATE},
    { "TOPL_MULTI_EDGE",                Dump_TOPL_MULTI_EDGE},
    { "TOPL_MULTI_EDGE_SET",            Dump_TOPL_MULTI_EDGE_SET},
    { "TOPL_REPL_INFO",                 Dump_TOPL_REPL_INFO},
    { "TOPL_SCHEDULE",                  Dump_TOPL_SCHEDULE},
    { "ToplGraphState",                 Dump_ToplGraphState},
    { "ToplInternalEdge",               Dump_ToplInternalEdge},
    { "ToplVertex",                     Dump_ToplVertex},
    { "TransactionalData",              Dump_TransactionalData},
    { "UPTODATE_VECTOR",                Dump_UPTODATE_VECTOR},
    { "USN_VECTOR",                     Dump_USN_VECTOR},
    { "USER_DATA",                      Dump_USERDATA},
    { "USER_DATA_list",                 Dump_USERDATA_list},
    { "UUID",                           Dump_UUID},
    { "VALUE_META_DATA",                Dump_VALUE_META_DATA},
    { "VALUE_META_DATA_EXT",            Dump_VALUE_META_DATA_EXT},
};

DWORD cDumpItems = sizeof(rDumpItems) / sizeof(DumpItem);

DEBUG_EXT(help)

/*++

Routine Description:

    Extensions DLL "help" entry point.  Dumps a synopsis of permissible
    commands.

Arguments:

    See DEBUG_EXT macro in dbexts.h.

Return Value:

    None.

--*/

{
    DWORD i = VER_PRODUCTBUILD;

    INIT_DEBUG_EXT;

    Printf("\n\t*** NT DS Debugger Extensions - v%u ***\n\n", i);
    Printf("\thelp            - prints this help\n");
    Printf("\tdprint cmd arg  - controls DS DPRINT behavior\n");
    Printf("\t\twhere cmd is one of: help, show,level, add, remove, thread\n");
    Printf("\tdump type addr  - dumps object of 'type' at 'addr'\n");
    Printf("\t\tuse 'dump help' for list of types\n");
    Printf("\tassert [cmd]    - controls disabled asserts\n" );
}

void
Dump_Help(void)
{
    DWORD i;

    Printf("\tdump type addr  - dumps object of 'type' at 'addr'\n");
    Printf("\t\twhere type is one of:\n");

    for ( i = 0; i < cDumpItems; i++ )
    {
        Printf("\t\t\t%s\n", rDumpItems[i].pszType);
    }
}

DWORD ExceptionHandler(DWORD dwException, LPEXCEPTION_POINTERS pInfo){

   Printf("Exception 0x%x: dsexts exception failure.\n", dwException);
   if ( pInfo ) {
       Printf("\tContextRecord   :    0x%p\n"       \
              "\tExceptionRecord :    0x%p\n",
              pInfo->ContextRecord,
              pInfo->ExceptionRecord );
   }

   return EXCEPTION_EXECUTE_HANDLER;
}

DEBUG_EXT(dump)

/*++

Routine Description:

    Extensions DLL "dump" entry point.  Dumps a struct or object in
    human readable form.

Arguments:

    See DEBUG_EXT macro in dbexts.h.

Return Value:

    None.

--*/

{
    CHAR    *pszType;
    VOID    *pvProcess;
    CHAR    *pszToken;
    CHAR    *pszDelimiters = " \t";
    DWORD   i;
    CHAR    *p;
    STRING  str1, str2;
    BOOL    fGoodSyntax = FALSE;

    INIT_DEBUG_EXT;

    __try {
        //
        // Derive object type and dump address from command line.
        // First token in gpszCommand is the type of object/struct to dump.
        //

        if ( NULL != (pszType = strtok(gpszCommand, pszDelimiters)) )
        {
            //
            // Second token is the address to dump.
            //

            if ( NULL != (pszToken = strtok(NULL, pszDelimiters)) )
            {
                //
                // Convert token to address.
                //

                if ( NULL != (pvProcess = (VOID *) GetExpr(pszToken)) )
                {
                    //
                    // Verify there is no third token.
                    //

                    if ( NULL == strtok(NULL, pszDelimiters) )
                    {
                        fGoodSyntax = TRUE;
                    }
                }
            }
            else {
                // No address, see if type was "help"
                if (0 == _strcmpi(pszType, "help")) {
                    Dump_Help();
                    return;
                }
            }
        }

        if ( !fGoodSyntax )
        {
            Printf("Dump command parse error!\n");
            return;
        }

        //
        // Find pszType in rDumpItems[] and call corresponding dump routine.
        //

        for ( i = 0; i < cDumpItems; i++ )
        {
            //
            // Suspect we shouldn't call CRTs in a debugger extension so
            // just use RtlCompareString instead.
            //

            for ( str1.Length = 0, p = pszType; '\0' != *p; p++ )
            {
                str1.Length++;
            }

            str1.MaximumLength = str1.Length;
            str1.Buffer = pszType;

            for ( str2.Length = 0, p = rDumpItems[i].pszType; '\0' != *p; p++ )
            {
                str2.Length++;
            }

            str2.MaximumLength = str2.Length;
            str2.Buffer = rDumpItems[i].pszType;

            if ( !RtlCompareString(&str1, &str2, TRUE) )
            {
                (rDumpItems[i].pFunc)(0, pvProcess);
                break;
            }
        }

        if ( i >= cDumpItems )
        {
            Printf("Dump routine for '%s' not found!\n", pszType);
        }

    }
    __except(ExceptionHandler(GetExceptionCode(), GetExceptionInformation())) {
        //
        // Handle all dump exceptions so that we don't stall in the debugger.
        // we assume that can at least printf in the debugger (prety safe
        // for the most part)
        //
        Printf("Aborting dump function\n");

    }
}


void
AssertHelp(void)
{
    Printf( "\tassert help - this message\n" );
    Printf( "\tassert show - list disabled assertions\n" );
    Printf( "\tassert enable <index|*> - enable disabled assertions by index from the show list\n" );
    Printf( "\tassert disable <DSID> - disabled assertion at the DSID\n" );
    Printf( "\t\tUse /m:<module> to specify the dlls use the appropriate master dll:\n"
            "\t\t\tntdskcc,ntdsbsrv,ntdsetup: use ntdsa\n"
            "\t\t\tismip,ismsmtp: use ismserv\n" );
}

typedef enum _ASSERTOP {
    eInvalid = 0,
    eHelp,
    eShow,
    eEnable,
    eDisable
} ASSERTOP;

typedef struct _ASSERTCMD {
    char      * pszCmd;
    ASSERTOP    op;
} ASSERTCMD;

ASSERTCMD aACmd[] = {
    {"help", eHelp},
    {"show", eShow},
    {"enable", eEnable},
    {"disable", eDisable}
};

#define countACmd (sizeof(aACmd)/sizeof(ASSERTCMD))


DEBUG_EXT(assert)

/*++

Routine Description:

Debugger extension entrypoint for the assert command. Handles disabled
assertions.

Arguments:

Standard debugger extension entry signature

Return Value:

    None

--*/

{
    CHAR *pszModule = "ntdsa", *argv[10];
    CHAR *pszDelimiters = " \t";
    DWORD argc, i, j;
    ASSERTOP op;
    DEBUGARG *pvProcessDebugInfo = NULL;
    ASSERT_TABLE pvProcessAssertTable = NULL;
    ASSERT_TABLE pvLocalAssertTable = NULL;
    CHAR szSymbol[50];
    BOOL fUpdateNeeded = FALSE;        
    ULONG iWrite = 0;
    ULONG cDisabledAsserts;
    BOOL fSuccess;

    INIT_DEBUG_EXT;

    // Construct arg vector. Also parse out options.
    argc = 0;
    argv[argc] = strtok(gpszCommand, pszDelimiters);
    while (argv[argc] != NULL) {
        argc++;
        argv[argc] = strtok(NULL, pszDelimiters);

        if ( (NULL != argv[argc]) &&
             (_strnicmp( argv[argc], "/m:", 3 ) == 0) ) {
            pszModule = argv[argc] + 3;
            argv[argc] = strtok(NULL, pszDelimiters);
        }
    }

    // Command is mandatory
    if (argv[0] == NULL) {
        Printf( "subcommand must be specified.\n" );
        AssertHelp();
        return;
    }

    // See which command it is
    op = eInvalid;
    for (i=0; i<countACmd; i++) {
        if (0 == _stricmp(argv[0], aACmd[i].pszCmd)) {
            op = aACmd[i].op;
            break;
        }
    }
    if ( (op == eHelp) || (op == eInvalid) ) {
        AssertHelp();
        return;
    }

    // Construct the symbol name of the assertion info structure
    strcpy( szSymbol, pszModule );
    strcat( szSymbol, "!DebugInfo" );
    pvProcessDebugInfo = (DEBUGARG *) GetExpr( szSymbol );
    if (pvProcessDebugInfo == NULL) {
        Printf("Can't locate address of '%s' - sorry\n", szSymbol);
        return;
    }
    pvProcessAssertTable = pvProcessDebugInfo->aAssertTable;
    if (pvProcessAssertTable == NULL) {
        Printf("HUH!!!  Check you're using the right dsexts with the right"
               "ntdsa, then Contact DSDev, pvProcessAssertTable is NULL.");
        return;
    }

    pvLocalAssertTable = (ASSERT_TABLE)ReadMemory(pvProcessAssertTable,
                             sizeof(ASSERT_TABLE_ENTRY[ASSERT_TABLE_SIZE+2]));
    if (pvLocalAssertTable == NULL) {
        Printf("Can't read assert arg - sorry\n");
        return;
    }

    // First, lets count the number of disabled asserts.
    cDisabledAsserts = 0;
    for (i = 0; pvLocalAssertTable[i].dwDSID; i++) {
        if(pvLocalAssertTable[i].dwFlags & ASSERT_DISABLED){
            cDisabledAsserts++;
        }
    }

    // Handle commands
    switch (op) {
    case eShow:

        if(cDisabledAsserts == 0){
            Printf( "\tNo assertions are disabled in %s.%s.\n", szSymbol, 
                    "aAssertTable");
        } else {
            Printf( "\t%d assertions are disabled in %s.%s.\n",
                    cDisabledAsserts, szSymbol, "aAssertTable");
            for (i = 0; pvLocalAssertTable[i].dwDSID; i++){
                if(pvLocalAssertTable[i].dwFlags & ASSERT_DISABLED){
                    Printf( "\t%d = 0x%x (Dir %d, File %d, Line %d) dwFlags = %d\n", 
                            i,
                            pvLocalAssertTable[i].dwDSID, 
                            ((pvLocalAssertTable[i].dwDSID & DSID_MASK_DIRNO) / 0x01000000),
                            ((pvLocalAssertTable[i].dwDSID & DSID_MASK_FILENO) / 0x00010000),
                            (pvLocalAssertTable[i].dwDSID & DSID_MASK_LINE),
                            pvLocalAssertTable[i].dwFlags);
                }
            }
        }
        break;

    case eEnable:

        if (argv[1] == NULL) {
            Printf( "enable command requires index\n" );
            AssertHelp();
            goto cleanup;
        }

        if( (_strnicmp( argv[1], "*", 1 ) == 0) ){

            for(i = 0; i < ASSERT_TABLE_SIZE; i++){
                pvLocalAssertTable[i].dwDSID = 0;
                pvLocalAssertTable[i].dwFlags = 0;
            }
            iWrite = ASSERT_TABLE_SIZE;
            fUpdateNeeded = TRUE;

            Printf("\tRe-enabling all asserts.\n");

        } else {
            i = strtoul( argv[1], NULL, 10 );
            if (i >= cDisabledAsserts) {
                Printf( "Error: index out of range\n" );
                goto cleanup;
            }
            pvLocalAssertTable[i].dwFlags = 0;
            iWrite = i;
            fUpdateNeeded = TRUE;
            
            Printf( "\t%d - 0x%x (Dir %d, File %d, Line %d) dwFlags = %d - re-enabled assert.\n",
                    i,
                    pvLocalAssertTable[i].dwDSID, 
                    ((pvLocalAssertTable[i].dwDSID & DSID_MASK_DIRNO) / 0x01000000),
                    ((pvLocalAssertTable[i].dwDSID & DSID_MASK_FILENO) / 0x00010000),
                    (pvLocalAssertTable[i].dwDSID & DSID_MASK_LINE),
                    pvLocalAssertTable[i].dwFlags);
        }
        
        // Re-enabling assert.

        // Re-enable the DSID for the picked DSID.
        break;

    case eDisable:

        if (argv[1] == NULL) {
            Printf( "missing command arguments\n" );
            AssertHelp();
            goto cleanup;
        }
        
        // Use base 16, we're reading a DSID.
        j = strtoul( argv[1], NULL, 16 );
        if(j == 0){
            Printf( "Invalid DSID of 0\n" );
            break;
        }

        i = GetBlankAssertEntry(pvLocalAssertTable, j);
        if(i == ASSERT_TABLE_SIZE){
            Printf( "Maximum number of %d disabled assertions has been reached!\n",
                    ASSERT_TABLE_SIZE );
            break;
        }

        pvLocalAssertTable[i].dwDSID = j;
        pvLocalAssertTable[i].dwFlags = (ASSERT_DISABLED | ASSERT_PRINT);
        iWrite = i;
        fUpdateNeeded = TRUE;

        Printf( "\t%d - 0x%x (Dir %d, File %d, Line %d) dwFlags = %d - disabled assert.\n",
                i,
                pvLocalAssertTable[i].dwDSID, 
                ((pvLocalAssertTable[i].dwDSID & DSID_MASK_DIRNO) / 0x01000000),
                ((pvLocalAssertTable[i].dwDSID & DSID_MASK_FILENO) / 0x00010000),
                (pvLocalAssertTable[i].dwDSID & DSID_MASK_LINE),
                pvLocalAssertTable[i].dwFlags);

        break;

    default:
        Printf("Invalid command\n");
            AssertHelp();
    }

cleanup:

    if (fUpdateNeeded) {
        if (iWrite == ASSERT_TABLE_SIZE){
            // Write whole table
            fSuccess = WriteMemory(pvProcessAssertTable,
                                   pvLocalAssertTable,
                                   sizeof(ASSERT_TABLE_ENTRY[ASSERT_TABLE_SIZE]));
        } else {
            // Write one entry from iWrite.
            fSuccess = WriteMemory(&pvProcessAssertTable[iWrite],
                                   &pvLocalAssertTable[iWrite],
                                   sizeof(ASSERT_TABLE_ENTRY));
        }
        if (fSuccess) {
            Printf("Updated!\n");
        } else {
            Printf("Failed to update\n");
        }
    }
    if (pvLocalAssertTable) {
        FreeMemory( pvLocalAssertTable );
    }
}


DEBUG_EXT(unmask)

/*++

Routine Description:

    Extensions DLL "unmask" entry point. XORs a range of memory with 0xFF 

Arguments:

    See DEBUG_EXT macro in dbexts.h.

Return Value:

    None.

--*/
{
    CHAR    *pszStart;
    VOID    *pvStart;
    CHAR    *pszLen;
    DWORD   dwLen;
    CHAR    *pszDelimiters = " \t";
    BOOL    fGoodSyntax = FALSE;
    CHAR    *pData;
    DWORD   i;

    INIT_DEBUG_EXT;

    __try {

        //
        // Derive object type and dump address from command line.
        // First token in gpszCommand is the start address
        //

        if ( NULL != (pszStart = strtok(gpszCommand, pszDelimiters)) )
        {
            //
            // Convert token to address.
            //

            if ( NULL != (pvStart = (VOID *) GetExpr(pszStart)) )
            {
                //
                // Second token is the length.
                //

                if ( NULL != (pszLen = strtok(NULL, pszDelimiters)) )
                {
                    //
                    // Convert token to address.
                    //

                    dwLen = (DWORD) GetExpr(pszLen);
                    
                    //
                    // Verify there is no third token.
                    //

                    if ( NULL == strtok(NULL, pszDelimiters) )
                    {
                        fGoodSyntax = TRUE;
                    }
                }
            }
        }

        if ( !fGoodSyntax )
        {
            Printf("Unmask command parse error!\n");
            return;
        }

        Printf("Unmasking data: Start=%p, Length=%d\n", pvStart, dwLen);

        pData = ReadMemory( pvStart, dwLen );
	if (NULL == pData) {
	    Printf("Unable to read memory!\n");
	    return;
	}

        for( i=0; i<dwLen; i++ ) {
            pData[i] ^= 0xFF;
        }

        if( !WriteMemory( pvStart, pData, dwLen ) ) {
            Printf("Unmask command write error!\n");
        }

    }
    __except(ExceptionHandler(GetExceptionCode(), GetExceptionInformation())) {
        //
        // Handle all dump exceptions so that we don't stall in the debugger.
        // we assume that can at least printf in the debugger (pretty safe
        // for the most part)
        //
        Printf("Aborting unmask function\n");
    }
}

VOID NtsdExtensionDllInit(VOID) {
    // This function does nothing. It is exported from the dll.
    // It is a hack to make both kd and ntsd recognize us as an 
    // "old-style" extension.
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\dsexts.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsexts.h

Abstract:

    Declares helpers and globals for the DS ntsd/windbg debugger extensions
    DLL.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Jan-00   XinHe       Added Dump_TQEntry()

    24-Apr-96   DaveStr     Created

--*/

#include <ntsdexts.h>       // debugger extension helpers

//
// Globals
//

extern PNTSD_EXTENSION_APIS     gpExtApis;
extern HANDLE                   ghDbgThread;
extern HANDLE                   ghDbgProcess;
extern LPSTR                    gpszCommand;

//
// Global flag to control verbosity of misc. routines.  Should be
// used to debug the DLL itself, not to report operation progress
// to DLL users.
//

extern BOOL                     gfVerbose;

//
// Macros to easily access extensions helper routines for printing, etc.
// In particular, Printf() takes the same arguments as the CRT printf().
//

#define Printf          (gpExtApis->lpOutputRoutine)
#define GetSymbol       (gpExtApis->lpGetSymbolRoutine)
#define GetExpr         (gpExtApis->lpGetExpressionRoutine)
#define CheckC          (gpExtApis->lpCheckControlCRoutine)

//
// Macros to simplify declaration and globals setup of debugger extension DLL
// entry points.  See DEBUG_EXT(help) in dsexts.c for usage example.
//

#define DEBUG_EXT(cmd)                                  \
                                                        \
VOID                                                    \
cmd(                                                    \
    HANDLE                  hProcess,                   \
    HANDLE                  hThread,                    \
    DWORD                   dwCurrentPc,                \
    PNTSD_EXTENSION_APIS    lpExt,                      \
    LPSTR                   pszCommand)

#define INIT_DEBUG_EXT                                  \
    ghDbgProcess = hProcess;                            \
    ghDbgThread = hThread;                              \
    gpExtApis = lpExt;                                  \
    gpszCommand = pszCommand;

//
// Macro for getting the byte offset of an object/struct member.
// s == struct, m == member
//

#define OFFSET(s,m) ((size_t)((BYTE*)&(((s*)0)->m)-(BYTE*)0))

//
// Typedef of all functions that dump a type
//

typedef
BOOL
(*PFN_DUMP_TYPE) (
    IN      DWORD   nIndents,
    IN      PVOID   pvProcess
    );

//
// Helper function prototypes
//

extern PVOID                // address of debugger local memory
ReadMemory(
    IN PVOID  pvAddr,       // address to read in process being debugged
    IN DWORD  dwSize);      // byte count to read

PVOID                       // address of debugger local memory
ReadStringMemory(
    IN PVOID  pvAddr,       // address to read in process being debugged
    IN DWORD  dwSize);      // maximum byte count to read

PVOID                       // address of debugger local memory
ReadUnicodeMemory(
    IN PVOID  pvAddr,       // address to read in process being debugged
    IN DWORD  dwSize);      // maximum character count to read


extern BOOL
WriteMemory(
    IN PVOID  pvProcess,    // address to write in process being debugged
    IN PVOID  pvLocal,      // address of debugger local memory
    IN DWORD  dwSize) ;     // byte count to write

extern VOID
FreeMemory(
    IN PVOID p);            // address returned by ReadMemory

extern VOID
ShowBinaryData(             // pretty prints binary data to debugger output
    IN DWORD   nIndents,    // number of indent levels desired
    IN PVOID   pvData,      // debugger local memory address
    IN DWORD   dwSize);     // count of bytes to dump

extern PCHAR
Indent(
    IN DWORD nIndents);     // number of indent levels desired

extern PCHAR                // '_' prefix so as not to conflict with oidconv.c
_DecodeOID(                 // produces a printable decoded OID
    IN PVOID   pvOID,       // pointer to buffer holding encoded OID
    IN DWORD   cbOID);      // count of bytes in encoded OID

// defined in md.c
extern LPSTR
DraUuidToStr(
    IN  UUID *  puuid,
    OUT LPSTR   pszUuid     OPTIONAL,
    IN  ULONG   cchUuid     
    );

// defined in md.c
extern BOOL
Dump_LHT(
    IN      DWORD           nIndents,
    IN      PVOID           pvProcess,
    IN      PFN_DUMP_TYPE   pfnDumpType );

//
// Externs for all dump routines.  These are made global so dump routines
// can call one another.  They should all have the same signature.
//
// BOOL
// Dump_TYPENAME(
//      IN DWORD nIndents
//      IN PVOID pvProcess);
//
extern BOOL Dump_Binary(DWORD, PVOID);
extern BOOL Dump_BinaryCount(DWORD, PVOID, DWORD);
extern BOOL Dump_DSNAME(DWORD, PVOID);
extern BOOL Dump_DSNAME_local( DWORD, PVOID pName);
extern BOOL Dump_BINDARG(DWORD, PVOID);
extern BOOL Dump_BINDRES(DWORD, PVOID);
extern BOOL Dump_THSTATE(DWORD, PVOID);
extern BOOL Dump_SAMP_LOOPBACK_ARG(DWORD, PVOID);
extern BOOL Dump_Context(DWORD, PVOID);
extern BOOL Dump_ContextList(DWORD, PVOID);
extern BOOL Dump_ATQ_CONTEXT(DWORD, PVOID);
extern BOOL Dump_ATQ_ENDPOINT(DWORD, PVOID);
extern BOOL Dump_ATQC_ACTIVE_list(DWORD, PVOID);
extern BOOL Dump_ATQC_PENDING_list(DWORD, PVOID);
extern BOOL Dump_AttrBlock(DWORD, PVOID);
extern BOOL Dump_AttrBlock_local(DWORD, PVOID, BOOL);
extern BOOL Dump_AttrValBlock(DWORD, PVOID);
extern BOOL Dump_AttrVal(DWORD, PVOID);
extern BOOL Dump_Attr(DWORD, PVOID);
extern BOOL Dump_Attr_local(DWORD, PVOID, BOOL);
extern BOOL Dump_UPTODATE_VECTOR(DWORD, PVOID);
extern BOOL Dump_DSA_ANCHOR(DWORD, PVOID);
extern BOOL Dump_DBPOS(DWORD, PVOID);
extern BOOL Dump_DirWaitItem(DWORD, PVOID);
extern BOOL Dump_DirWaitList(DWORD, PVOID);
extern BOOL Dump_EscrowInfo(DWORD, PVOID);
extern BOOL Dump_TransactionalData(DWORD, PVOID);
extern BOOL Dump_KEY(DWORD, PVOID);
extern BOOL Dump_KEY_INDEX(DWORD, PVOID);
extern BOOL Dump_CommArg(DWORD, PVOID);
extern BOOL Dump_USN_VECTOR(DWORD, PVOID);
extern BOOL Dump_PROPERTY_META_DATA_VECTOR(DWORD, PVOID);
extern BOOL Dump_PROPERTY_META_DATA_EXT_VECTOR(DWORD, PVOID);
extern BOOL Dump_ENTINF(DWORD, PVOID);
extern BOOL Dump_ENTINFSEL(DWORD, PVOID);
extern BOOL Dump_REPLENTINFLIST(DWORD, PVOID);
extern BOOL Dump_ReplNotifyElement(DWORD, PVOID);
extern BOOL Dump_REPLVALINF(DWORD, PVOID);
extern BOOL Dump_REPLICA_LINK(DWORD, PVOID);
extern BOOL Dump_AddArg(DWORD,PVOID);
extern BOOL Dump_AddRes(DWORD,PVOID);
extern BOOL Dump_ReadArg(DWORD,PVOID);
extern BOOL Dump_ReadRes(DWORD,PVOID);
extern BOOL Dump_SCHEMAPTR(DWORD,PVOID);
extern BOOL Dump_RemoveArg(DWORD,PVOID);
extern BOOL Dump_RemoveRes(DWORD,PVOID);
extern BOOL Dump_SearchArg(DWORD,PVOID);
extern BOOL Dump_SearchRes(DWORD,PVOID);
extern BOOL Dump_CLASSCACHE(DWORD,PVOID);
extern BOOL Dump_ATTCACHE(DWORD,PVOID);
extern BOOL Dump_FILTER(DWORD,PVOID);
extern BOOL Dump_SUBSTRING(DWORD,PVOID);
extern BOOL Dump_GLOBALDNREADCACHE(DWORD, PVOID);
extern BOOL Dump_LOCALDNREADCACHE(DWORD, PVOID);
extern BOOL Dump_BHCache(DWORD, PVOID);
extern BOOL Dump_MODIFYARG(DWORD, PVOID);
extern BOOL Dump_REQUEST(DWORD, PVOID);
extern BOOL Dump_REQUEST_list(DWORD, PVOID);
extern BOOL Dump_LIMITS(DWORD, PVOID);
extern BOOL Dump_PAGED(DWORD, PVOID);
extern BOOL Dump_USERDATA(DWORD, PVOID);
extern BOOL Dump_USERDATA_list(DWORD, PVOID);
extern BOOL Dump_PARTIAL_ATTR_VECTOR(DWORD, PVOID);
extern BOOL Dump_GCDeletionList(DWORD, PVOID);
extern BOOL Dump_GCDeletionListProcessed(DWORD, PVOID);
extern BOOL Dump_UUID(DWORD, PVOID);
extern BOOL Dump_REPLTIMES(DWORD, PVOID);
extern BOOL Dump_AO(DWORD, PVOID);
extern BOOL Dump_AOLIST(DWORD, PVOID);
extern BOOL Dump_MTX_ADDR(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREQ_V4(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREQ_V5(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREQ_V8(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_V1(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_V6(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_VALUES(DWORD, PVOID);
extern BOOL Dump_MODIFYDNARG(DWORD, PVOID);
extern BOOL Dump_d_tagname(DWORD, PVOID);
extern BOOL Dump_d_memname(DWORD, PVOID);
extern BOOL Dump_ProxyVal(DWORD, PVOID);
extern BOOL Dump_Sid(DWORD, PVOID);
extern BOOL Dump_DefinedDomain(DWORD, PVOID);
extern BOOL Dump_DefinedDomains(DWORD, PVOID);
extern BOOL Dump_FixedLengthDomain_local(DWORD, PVOID);
extern BOOL Dump_KCC_SITE(DWORD, PVOID);
extern BOOL Dump_KCC_SITE_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_SITE_ARRAY(DWORD, PVOID);
extern BOOL Dump_KCC_DSA(DWORD, PVOID);
extern BOOL Dump_KCC_DSA_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_CONNECTION(DWORD, PVOID);
extern BOOL Dump_KCC_INTRASITE_CONNECTION_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_INTERSITE_CONNECTION_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_REPLICATED_NC(DWORD, PVOID);
extern BOOL Dump_KCC_REPLICATED_NC_ARRAY(DWORD, PVOID);
extern BOOL Dump_KCC_DS_CACHE(DWORD, PVOID);
extern BOOL Dump_KCC_CROSSREF(DWORD, PVOID);
extern BOOL Dump_KCC_CROSSREF_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_DSNAME_ARRAY(DWORD, PVOID);
extern BOOL Dump_KCC_TRANSPORT(DWORD, PVOID);
extern BOOL Dump_KCC_TRANSPORT_LIST(DWORD, PVOID);
extern BOOL Dump_SCHEMA_PREFIX_TABLE(DWORD, PVOID);
extern BOOL Dump_SD(DWORD, PVOID);
extern BOOL Dump_STAT(DWORD, PVOID);
extern BOOL Dump_INDEXSIZE(DWORD, PVOID);
extern BOOL Dump_SPropTag(DWORD, PVOID);
extern BOOL Dump_SRowSet(DWORD, PVOID);
extern BOOL Dump_NCSYNCSOURCE(DWORD, PVOID);
extern BOOL Dump_NCSYNCDATA(DWORD, PVOID);
extern BOOL Dump_INITSYNC(DWORD, PVOID);
extern BOOL Dump_JETBACK_SHARED_HEADER(DWORD, PVOID);
extern BOOL Dump_JETBACK_SHARED_CONTROL(DWORD, PVOID);
extern BOOL Dump_BackupContext(DWORD, PVOID);
extern BOOL Dump_JETBACK_SERVER_CONTEXT(DWORD, PVOID);
extern BOOL Dump_DRS_ASYNC_RPC_STATE(DWORD, PVOID);
extern BOOL Dump_ISM_PENDING_ENTRY(DWORD, PVOID);
extern BOOL Dump_ISM_PENDING_LIST(DWORD, PVOID);
extern BOOL Dump_ISM_TRANSPORT(DWORD, PVOID);
extern BOOL Dump_ISM_TRANSPORT_LIST(DWORD, PVOID);
extern BOOL Dump_ISM_SERVICE(DWORD, PVOID);
extern BOOL Dump_VALUE_META_DATA(DWORD, PVOID);
extern BOOL Dump_VALUE_META_DATA_EXT(DWORD, PVOID);
extern BOOL Dump_KCC_SITE_LINK(DWORD,PVOID);
extern BOOL Dump_KCC_SITE_LINK_LIST(DWORD,PVOID);
extern BOOL Dump_KCC_BRIDGE(DWORD,PVOID);
extern BOOL Dump_KCC_BRIDGE_LIST(DWORD,PVOID);
extern BOOL Dump_TOPL_REPL_INFO(DWORD,PVOID);
extern BOOL Dump_ToplGraphState(DWORD,PVOID);
extern BOOL Dump_ToplInternalEdge(DWORD,PVOID);
extern BOOL Dump_ToplVertex(DWORD,PVOID);
extern BOOL Dump_TOPL_SCHEDULE(DWORD,PVOID);
extern BOOL Dump_PSCHEDULE(DWORD,PVOID);
extern BOOL Dump_DynArray(DWORD,PVOID);
extern BOOL Dump_TOPL_MULTI_EDGE(DWORD,PVOID);
extern BOOL Dump_TOPL_MULTI_EDGE_SET(DWORD,PVOID);
extern BOOL Dump_KCC_DSNAME_SITE_ARRAY(DWORD, PVOID);
extern BOOL Dump_INVALIDATED_DC_LIST(DWORD, PVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\mapi.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    Dump functions for MAPI related types

Environment:

Revision History:

    22-Mar-99   MariosZ     Created

--*/


#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
// Core headers.
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <dsatools.h>                   // Memory, etc.


// Assorted MAPI headers.
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <_entryid.h>                   // Defines format of an entryid
#include "abdefs.h"


BOOL
Dump_STAT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public STAT dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PSTAT pstat = 0;

    pstat = (PSTAT) ReadMemory(pvProcess, sizeof(STAT));
        
    if ( pstat ) {

        Printf("%s hIndex:       0x%x\n", Indent(nIndents), pstat->hIndex);
        Printf("%s ContainerID:  0x%x\n", Indent(nIndents), pstat->ContainerID);
        Printf("%s CurrentRec:   %lu\n", Indent(nIndents), pstat->CurrentRec);
        Printf("%s Delta:        %ld\n", Indent(nIndents), pstat->Delta);
        Printf("%s NumPos:       %lu\n", Indent(nIndents), pstat->NumPos);
        Printf("%s TotalRecs:    %lu\n", Indent(nIndents), pstat->TotalRecs);
        Printf("%s CodePage:     %lu\n", Indent(nIndents), pstat->CodePage);
        Printf("%s TemplateLoc:  %lu\n", Indent(nIndents), pstat->TemplateLocale );
        Printf("%s SortLocale:   %lu\n", Indent(nIndents), pstat->SortLocale );

        FreeMemory(pstat);
    }

    return(TRUE);
}

BOOL
Dump_INDEXSIZE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public INDEXSIZE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PINDEXSIZE pIndexSize = 0;


    pIndexSize = (PINDEXSIZE) ReadMemory(pvProcess, sizeof(INDEXSIZE));
        
    if ( pIndexSize ) {
        Printf("%s TotalCount:     %ld\n", Indent(nIndents), pIndexSize->TotalCount);
        Printf("%s ContainerID:     0x%x\n",Indent(nIndents), pIndexSize->ContainerID);
        Printf("%s ContainerCount: %ld\n", Indent(nIndents), pIndexSize->ContainerCount);
        
        FreeMemory(pIndexSize);
    }

    return(TRUE);
}



BOOL
Dump_SPropTag(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SPropTag dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    LPSPropTagArray_r     pPropTagArr_tmp = 0;
    LPSPropTagArray_r     pPropTagArr = 0;
    ULONG i;


    do {
        pPropTagArr_tmp = (LPSPropTagArray_r) ReadMemory(pvProcess, sizeof(SPropTagArray_r));
        
        if ( NULL == pPropTagArr_tmp )
            break;

        pPropTagArr = (LPSPropTagArray_r) ReadMemory(pvProcess, sizeof(SPropTagArray_r) + 
                                                                     sizeof (ULONG) * pPropTagArr_tmp->cValues);
        
        if ( NULL == pPropTagArr )
            break;

        
        Printf("%s SPropTagArr[%d]:\n", Indent(nIndents), pPropTagArr->cValues);
        
        for (i=0; i<pPropTagArr->cValues; i++) {
            Printf("%s aulPropTag[%d]: 0x%x\n", Indent(nIndents+1), i, pPropTagArr->aulPropTag[i]);
        }
    }
    while ( FALSE );


    if (pPropTagArr_tmp)
        FreeMemory(pPropTagArr_tmp);
    if (pPropTagArr)
        FreeMemory(pPropTagArr);

    return(TRUE);
}

BOOL
Dump_SRowSet(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SRowSet dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    LPLPSRowSet_r ppRows = 0;
    LPSRowSet_r   pRows_tmp = 0;
    LPSRowSet_r   pRows = 0;

    LPSPropValue_r lpProps = 0, lpProps_tmp = 0;

    DWORD tempSyntax;
    ULONG i, j;
    
    Printf("Reading Memory: %x\n", pvProcess);

    do {

        ppRows = (LPLPSRowSet_r) ReadMemory(pvProcess, sizeof (LPSRowSet_r));
        
        if ( NULL == ppRows )
            break;
        
        Printf("Reading Memory: %x\n", *ppRows);
        
        pRows_tmp = (LPSRowSet_r) ReadMemory(*ppRows, sizeof(SRowSet_r));
        
        if ( NULL == pRows_tmp )
            break;

        pRows = (LPSRowSet_r) ReadMemory(*ppRows, sizeof(SRowSet_r) + 
                                                  sizeof (SRow_r) * pRows_tmp->cRows);
        
        if ( NULL == pRows )
            break;

        
        Printf("%s SRowSet[%d]:\n", Indent(nIndents), pRows->cRows);
        
        for (i=0; i<pRows->cRows; i++) {
            Printf("%s aRow[%d]:\n", Indent(nIndents+1), i);
            Printf("%s ulAdrEntryPad:  0x%x\n", Indent(nIndents+2), pRows->aRow[i].ulAdrEntryPad);
            Printf("%s cValues:       %d\n",   Indent(nIndents+2), pRows->aRow[i].cValues);

            lpProps_tmp = lpProps = (LPSPropValue_r) ReadMemory(pRows->aRow[i].lpProps, sizeof (LPSPropValue_r) * pRows->aRow[i].cValues);
            if ( NULL == lpProps )
                break;

            Printf("%s PropValue[%d]:\n", Indent(nIndents+2), pRows->aRow[i].cValues);
            for (j=0; j<pRows->aRow[i].cValues; j++) {

                Printf("%s ulPropTag[%d]:  0x%x\n", Indent(nIndents+3), j, lpProps->ulPropTag);
                //Printf("%s dwAlignPad[%d]: %d\n",   Indent(nIndents+3), j, lpProps->dwAlignPad);
                
                tempSyntax = PROP_TYPE(lpProps->ulPropTag);
                if (tempSyntax == PT_STRING8 ) {
                    LPWSTR lpszW;

                    lpszW = (LPWSTR) ReadStringMemory (lpProps->Value.lpszW, 40);

                    Printf("%s value[%d]:      %s\n",   Indent(nIndents+3), j, lpszW);

                    if (lpszW)
                        FreeMemory(lpszW);

                } else {
                    Printf("%s value[%d]:      0x%x\n",   Indent(nIndents+3), j, lpProps->Value.l);
                }

                lpProps++;
            }

            if (lpProps_tmp) 
                FreeMemory(lpProps_tmp);
        }
    }
    while ( FALSE );


    if (ppRows)
        FreeMemory(ppRows);
    if (pRows_tmp)
        FreeMemory(pRows_tmp);
    if (pRows)
        FreeMemory(pRows);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\ldap.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    md.c

Abstract:

    Dump functions for types used by dsamain\src - i.e. the mini-directory.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    08-May-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#include "dsexts.h"
#include "objids.h"
#include "drs.h"
#include "ntdsa.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"
#include "mappings.h"
#include "mdlocal.h"
#include "anchor.h"
#include "direrr.h"
#include "filtypes.h"
#include <dsjet.h>
#include "dbintrnl.h"
#include "dsatools.h"
#include "bhcache.h"
#include <winsock2.h>
#include <winldap.h>
#include <atq.h>
#include <ldap.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <ntdsctr.h>
#ifdef __cplusplus
}
#endif //__cplusplus

#define DPRINT4(_x,_a,_b,_c,_d,_e)
#define Assert(_x)  
#undef new
#undef delete
#include <const.hxx>
#include <limits.hxx>
#include <cache.hxx>
#include <connect.hxx>
#include <request.hxx>
#include <secure.hxx>
#include <userdata.hxx>
#include <ldaptype.hxx>
#include <globals.hxx>

#define TF(exp) ( exp ? "TRUE" : "FALSE" )


BOOL
Dump_USERDATA(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA dump routine.  Dumps an LDAP_CONN object.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of LDAP_CONN in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    PLDAP_CONN      pUDd = NULL;
    PLDAP_CONN      pLdapConnUserSpace;
    DWORD           i;
    char            *c;
    SOCKADDR_IN     *pSockAddr;
    IN_ADDR         InetAddr;
    
    Printf("%sUSER_DATA\n", Indent(nIndents));
    nIndents++;

    pLdapConnUserSpace = (PLDAP_CONN)pvProcess;
    if (NULL != (pUDd = (PLDAP_CONN)ReadMemory(pvProcess,
                                               sizeof(LDAP_CONN))))
    {
        c = (char *)&pUDd->m_signature;
        Printf("%sSignature = %c%c%c%c\n", Indent(nIndents), c[0], c[1], c[2], c[3]);
        Printf("%sIs UDP connection %s\n",Indent(nIndents),TF(pUDd->m_fUDP));
        Printf("%sIs SSL connection %s\n",Indent(nIndents),TF(pUDd->m_fSSL));
        Printf("%sIs TLS connection %s\n",Indent(nIndents),TF(pUDd->m_fTLS));
        Printf("%sIs GC connection  %s\n",Indent(nIndents),TF(pUDd->m_fGC));

        Printf("%sSealing Enabled   %s\n",Indent(nIndents),TF(pUDd->m_fSeal));
        Printf("%sSigning Enabled   %s\n",Indent(nIndents),TF(pUDd->m_fSign));

        Printf("\n");
        Printf("%sDigest Bind       %s\n",Indent(nIndents),TF(pUDd->m_fDigest));

        Printf("%sSimple Bind       %s\n",Indent(nIndents),TF(pUDd->m_fSimple));
        Printf("%sGSSAPI Bind       %s\n",Indent(nIndents),TF(pUDd->m_fGssApi));
        Printf("%sSPNEGO Bind       %s\n",Indent(nIndents),TF(pUDd->m_fSpNego));

        Printf("\n");
        Printf("%sCanScatterGather  %s\n",Indent(nIndents),TF(pUDd->m_fCanScatterGather));
        Printf("%sNeedsHeader       %s\n",Indent(nIndents),TF(pUDd->m_fNeedsHeader));
        Printf("%sNeedsTrailer      %s\n",Indent(nIndents),TF(pUDd->m_fNeedsTrailer));

        Printf("%sVersion                       %d\n",
               Indent(nIndents),pUDd->m_Version);
        Printf("%sClientID                      %d\n",
               Indent(nIndents),pUDd->m_dwClientID);
        Printf("%sm_listEntry                 @ %p\n", Indent(nIndents), &pUDd->m_listEntry);
        Printf("%sm_cipherStrength =            %d\n", Indent(nIndents), pUDd->m_cipherStrength);

        switch(pUDd->m_CodePage) {
        case CP_UTF8:
            Printf("%sUTF-8 code page\n",Indent(nIndents));
            break;

        case CP_ACP:
            Printf("%sACP code page\n",Indent(nIndents));
            break;

        default:
            Printf("%sUnknown code page (0x%X)\n",
                   Indent(nIndents),pUDd->m_CodePage);
            break;
        }
        
        Printf("%sReferences                    %d\n",
               Indent(nIndents),pUDd->m_RefCount);
        
        Printf("%sCurrently servicing %d calls ",
               Indent(nIndents), pUDd->m_nRequests);
        
        switch(pUDd->m_CallState) {
        case inactive:
            Printf("(no binds)\n");
            break;
        case activeNonBind:
            Printf("(Odd, active-non-bind is set)\n");
            break;
        case activeBind:
            Printf("(1 bind)\n");
            break;
        default:
            Printf("(Unknown Call State-%d)\n",pUDd->m_CallState);
            break;
        }
        
        Printf("%sm_nTotalRequests        =     %d\n",
               Indent(nIndents), pUDd->m_nTotalRequests);
        Printf("%sState  =           ", Indent(nIndents));
        switch(pUDd->m_State) {
        case BlockStateInvalid:
            Printf("BlockStateInvalid");
            break;
        case BlockStateCached:
            Printf("BlockStateCached");
            break;
        case BlockStateActive:
            Printf("BlockStateActive");
            break;
        case BlockStateClosed:
            Printf("BlockStateClosed");
            break;
        default:
            Printf("Unknown Block State");
        }
        Printf("\n");

        Printf("%sm_requestObject              @ %p\n",
               Indent(nIndents),&pLdapConnUserSpace->m_requestObject);
        Printf("%sRequest                     @ %p\n",
               Indent(nIndents),pUDd->m_request);
        Printf("%sRequest List                @ %p\n",
               Indent(nIndents),&pLdapConnUserSpace->m_requestList);
        Printf("%sRequest List Critical Section %p\n",
               Indent(nIndents),&pLdapConnUserSpace->m_csLock);
        Printf("%spAtqContext                 @ %p\n",
               Indent(nIndents),pUDd->m_atqContext);
        
        Printf("%sNotifications               @ %p\n",
               Indent(nIndents),pUDd->m_Notifications);
        Printf("%sNotify Count                  %d\n",
               Indent(nIndents),pUDd->m_countNotifies);

        Printf("%sCookie count                  %d\n",
               Indent(nIndents),pUDd->m_CookieCount);
        Printf("%sCooke list head             @ %p\n",
               Indent(nIndents), &pLdapConnUserSpace->m_CookieList);

        Printf("%sSecurity Context            @ %X\n",
               Indent(nIndents), pUDd->m_pSecurityContext);
        Printf("%sSSL State                     %X\n",
               Indent(nIndents),pUDd->m_SslState);
        Printf("%sSSL Security Context          %X\n",
               Indent(nIndents),pUDd->m_hSslSecurityContext);
        Printf("%sUserName Buffer               %X\n",
               Indent(nIndents),pUDd->m_userName);
        Printf("%sm_bIsAdmin              =     %s\n",
               Indent(nIndents), TF(pUDd->m_bIsAdmin));
        Printf("%sm_csLock                    @ %p\n",
               Indent(nIndents), &pUDd->m_csLock);
        
        pSockAddr = (SOCKADDR_IN *)&(pUDd->m_RemoteSocket);
        InetAddr.S_un.S_addr = ntohl(pSockAddr->sin_addr.S_un.S_addr);

        Printf("%sRemote Socket = ip %d.%d.%d.%d port - %d\n",
            Indent(nIndents), InetAddr.S_un.S_un_b.s_b4,InetAddr.S_un.S_un_b.s_b3,
            InetAddr.S_un.S_un_b.s_b2,InetAddr.S_un.S_un_b.s_b1,ntohs(pSockAddr->sin_port));

        Printf("%sm_MsgIdsPos                 = %d\n",
               Indent(nIndents), pUDd->m_MsgIdsPos);

        if (!pUDd->m_fUDP) {
        
            Printf("%sMsgIds:\n", Indent(nIndents));
            i = 0;
            while (i < MSGIDS_BUFFER_SIZE) {
                Printf("%s", Indent(nIndents));

                while ( (((i+1) % 10) != 0) && (i < MSGIDS_BUFFER_SIZE)) {

                    if ( (i + 1) == pUDd->m_MsgIdsPos ) {
                        // We are positioned right before the current position pointer.
                        Printf("(");
                    } else if (i == pUDd->m_MsgIdsPos && (i % 10) != 0) {
                        // We are positioned right after the current position pointer, 
                        // but not at the begginning of a new line.
                        Printf(")");
                    } else {
                        Printf(" ");
                    }
                    
                    Printf("%.4x", pUDd->m_MsgIds[i]);

                    i++;
                }
                // Take care of the last entry on the line.
                if (i < MSGIDS_BUFFER_SIZE) {
                    if ( (i + 1) == pUDd->m_MsgIdsPos ) {
                        Printf("(");
                    } else if (i == pUDd->m_MsgIdsPos) {
                        Printf(")");
                    } else {
                        Printf(" ");
                    }
                    
                    Printf("%.4x", pUDd->m_MsgIds[i]);

                    if ( (i + 1) == pUDd->m_MsgIdsPos) {
                        // We are at the end of a line, so if this is the current
                        // positon, print the close paren now.
                        Printf(")");
                    }
                    i++;
                }
                Printf("\n");
            }
        }

        FreeMemory(pUDd);
        fSuccess = TRUE;
    }

    return(fSuccess);
}



BOOL
Dump_USERDATA_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA_list dump routine.  Dumps a list of LDAP_CONN's.  The most useful of which
    is the ntdsa!ActiveConnectionsList

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of LDAP_CONN list head in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = TRUE;
    PLDAP_CONN pUDd = NULL;                  // Debugger pointer to LDAP_CONN.
    PVOID           pUD;                     // Process pointer to LDAP_CONN.
    DWORD           count=0;
    LIST_ENTRY      *pActiveConnectionsList; // Debugger pointer.
    LIST_ENTRY      *pFlink;                 // Should always contain process pointers.
    SOCKADDR_IN     *pSockAddr;
    IN_ADDR         InetAddr;

    
    Printf("%sUSER_DATA list\n", Indent(nIndents));
    nIndents++;

    if (NULL != 
        (pActiveConnectionsList = (LIST_ENTRY*)ReadMemory(pvProcess, sizeof(LIST_ENTRY))))
    {
        pFlink = pActiveConnectionsList->Flink;
        Printf("\n%spvProcess = %p, ActiveConnectionsList = %p, Blink = %p\n",
            Indent(nIndents), pvProcess, pActiveConnectionsList, pActiveConnectionsList->Blink);

        while (pFlink != pvProcess) {

            if (NULL !=
                (pUDd = (PLDAP_CONN)ReadMemory(pUD = CONTAINING_RECORD(pFlink, LDAP_CONN, m_listEntry), sizeof(LDAP_CONN))))
            {

                Printf("\n%s%d) @ %X\n",Indent(nIndents),++count,pUD);

                Printf("%sFlink = %p\n",Indent(nIndents), pFlink);

                Printf("%sIs UDP connection = %s\n",Indent(nIndents),TF(pUDd->m_fUDP));
                Printf("%sIs SSL connection = %s\n",Indent(nIndents),TF(pUDd->m_fSSL));
                Printf("%sIs GC connection  = %s\n",Indent(nIndents),TF(pUDd->m_fGC));
                Printf("%sIs TLS connection = %s\n",Indent(nIndents),TF(pUDd->m_fTLS));
                Printf("%sDigest Bind       = %s\n",Indent(nIndents),TF(pUDd->m_fDigest));

                Printf("%sClientID                      %d\n",
                       Indent(nIndents),pUDd->m_dwClientID);

                Printf("%sReferences                    %d\n",
                       Indent(nIndents),pUDd->m_RefCount);

                Printf("%sCurrently servicing %d calls\n",
                       Indent(nIndents), pUDd->m_nRequests);
                Printf("%sm_nTotalRequests        =     %d\n",
                       Indent(nIndents), pUDd->m_nTotalRequests);

                pSockAddr = (SOCKADDR_IN *)&(pUDd->m_RemoteSocket);
                InetAddr.S_un.S_addr = ntohl(pSockAddr->sin_addr.S_un.S_addr);

                Printf("%sRemote Socket = ip %d.%d.%d.%d port - %d\n",
                    Indent(nIndents), InetAddr.S_un.S_un_b.s_b4,InetAddr.S_un.S_un_b.s_b3,
                    InetAddr.S_un.S_un_b.s_b2,InetAddr.S_un.S_un_b.s_b1,ntohs(pSockAddr->sin_port));
 
                pFlink = pUDd->m_listEntry.Flink;
                FreeMemory(pUDd);
            } else {
                Printf("%sThe list is corrupt, aborting!\n",Indent(nIndents));
                fSuccess = FALSE;
                break;
            }
            if (5000 < count) {
                Printf("%sASSUMING LOOP: Too many LDAP_CONN's, must be in a loop, exiting.", Indent(nIndents));
                fSuccess = FALSE;
                break;
            }
        }
        FreeMemory(pActiveConnectionsList);
    } else {
        Printf("%sBad pointer for ActiveConnectionsList!\n",Indent(nIndents));
        fSuccess = FALSE;
    }

    return(fSuccess);
}



BOOL
Dump_REQUEST(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dump routine for an LDAP_REQUEST structure.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of an LDAP_REQUEST in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    
    BOOL            fSuccess = FALSE;
    PLDAP_REQUEST   pReq = NULL;
    char            *c;
    
    Printf("%sREQUEST\n", Indent(nIndents));
    nIndents++;
    
    if (NULL != (pReq = (PLDAP_REQUEST)ReadMemory(pvProcess,
                                                  sizeof(LDAP_REQUEST))))
        {
            c = (char *)&pReq->m_signature;
            Printf("%sSignature = %c%c%c%c\n", Indent(nIndents), c[0], c[1], c[2], c[3]);

            Printf("%sMessageID                     %d\n",
               Indent(nIndents),pReq->m_MessageId);            

            if(pReq->m_fAbandoned) {
                Printf("%sMarked as abandonded\n",Indent(nIndents));
            }
            else {
                Printf("%sNot marked as abandonded\n",Indent(nIndents));
            }
            Printf("\n");
            Printf("%sIs SSL Connection       = %s\n",Indent(nIndents),TF(pReq->m_fSSL));
            Printf("%sIs TLS Connection       = %s\n",Indent(nIndents),TF(pReq->m_fTLS));
            Printf("%sIs Sign/Seal Connection = %s\n",Indent(nIndents),TF(pReq->m_fSignSeal));
            Printf("%sCanScatterGather        = %s\n",Indent(nIndents),TF(pReq->m_fCanScatterGather));
            Printf("%sNeedsHeader             = %s\n",Indent(nIndents),TF(pReq->m_fNeedsHeader));
            Printf("%sHeader Size             = %d bytes\n",Indent(nIndents),TF(pReq->m_HeaderSize));
            Printf("%sNeedsTrailer            = %s\n",Indent(nIndents),TF(pReq->m_fNeedsTrailer));
            Printf("%sTrailer Size            = %d bytes\n",Indent(nIndents),TF(pReq->m_TrailerSize));

            if(pReq->m_fDeleteBuffer) {
                Printf("%sReceive buffer will be deleted.\n",Indent(nIndents));
            }
            else {
                Printf("%sReceive buffer won't be deleted.\n",Indent(nIndents));
            }
            
            Printf("%scchReceiveBufferUsed          %d\n",
                   Indent(nIndents),pReq->m_cchReceiveBufferUsed);
            Printf("%scchReceiveBuffer              %d\n",
                   Indent(nIndents),pReq->m_cchReceiveBuffer);            
            Printf("%spReceiveBuffer              @ %X\n",
                   Indent(nIndents),pReq->m_pReceiveBuffer);            
            Printf("%sEmbedded Receive Buffer     @ %X\n",
                   Indent(nIndents),
                   ((DWORD_PTR)pvProcess + OFFSET(LDAP_REQUEST,m_ReceiveBuffer)));

            Printf("%sWsaBufferCount                %d\n",
                   Indent(nIndents),pReq->m_wsaBufCount);            
            Printf("%sWsaBuf                        %x\n",
                   Indent(nIndents),pReq->m_wsaBuf);            
            Printf("%sCurrentBufferPtr               %x\n",
                   Indent(nIndents),pReq->m_nextBufferPtr);            
            
            Printf("%spAtqContext                   %X\n",
                   Indent(nIndents),pReq->m_patqContext);
            Printf("%spLdapConn                   @ %p\n",
                   Indent(nIndents),pReq->m_LdapConnection);
            
            FreeMemory(pReq);
            fSuccess = TRUE;
        }
    
    return(fSuccess);
} // DUMP request


BOOL
Dump_REQUEST_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Prints a summary of all the requests in a list.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of the head of a list of LDAP_REQUESTs.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = TRUE;
    PLDAP_REQUEST   pReqProc = NULL;        // Request in process memory.
    LIST_ENTRY      *pListEntryDeb = NULL;  // List entry in debugger memory.
    LIST_ENTRY      *pListEntryProc = NULL; // List entry in process memory.
    LIST_ENTRY      *pListHeadDeb = NULL;   // List head in debugger memory.
    DWORD           dwReqCount = 1;

    Printf("%sREQUEST list\n", Indent(nIndents));
    nIndents++;
    
    pListHeadDeb = (LIST_ENTRY *) ReadMemory(pvProcess, sizeof(LIST_ENTRY));
    if (!pListHeadDeb) {
        Printf("%sUnable to read list head @ %p\n", Indent(nIndents), pvProcess);
        return FALSE;
    }

    pListEntryProc = pListHeadDeb->Flink;
    FreeMemory(pListHeadDeb);
    if (pListEntryProc == pvProcess) {
        Printf("%sThe list is empty.\n", Indent(nIndents));
        return TRUE;
    }

    while (pListEntryProc != pvProcess) {
        pReqProc = CONTAINING_RECORD(pListEntryProc, LDAP_REQUEST, m_listEntry);
        Printf("%s%d) @ %p\n", Indent(nIndents), dwReqCount, pReqProc);
        nIndents++;

        if (!Dump_REQUEST(nIndents, pReqProc)) {
            nIndents--;
            fSuccess = FALSE;
            Printf("%sFailed to print Request @ %p\n", Indent(nIndents), pReqProc);
            break;
        } 
        
        nIndents--;
        pListEntryDeb = (LIST_ENTRY *) ReadMemory(pListEntryProc, sizeof(LIST_ENTRY));

        if (!pListEntryDeb) {
            fSuccess = FALSE;
            Printf("%sFailed to read next Request list entry @ %p\n", Indent(nIndents), pListEntryProc);
            break;
        }

        pListEntryProc = pListEntryDeb->Flink;
        FreeMemory(pListEntryDeb);
        dwReqCount++;
    }

    return fSuccess;
}



BOOL
Dump_LIMITS(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA dump routine.  Extremely hacky.  Assumes way too much about
    the internals of a USERDATA object because it's a c++ thing, and I don't
    know how to deal with that cleanly here.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSNAME in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    
    BOOL            fSuccess = FALSE;
    PLIMIT_BLOCK    pBlock = NULL;
    BOOL            ok = TRUE;
    CHAR            name[MAX_PATH+1];        
    Printf("%sLIMITS\n", Indent(nIndents));
    nIndents++;
    
    do {

        if (NULL != (pBlock = (PLIMIT_BLOCK)ReadMemory(pvProcess,
                                                   sizeof(LIMIT_BLOCK)))) {
            
            PCHAR   pName;
            PDWORD  pLimit;
            DWORD   MinLimit;
            DWORD   MaxLimit;

            if ( pBlock->Limit != NULL ) {

                if (NULL != (pName = (PCHAR)ReadMemory(
                                                pBlock->Name.value,
                                                pBlock->Name.length))) {


                    if (NULL != (pLimit = (PDWORD)ReadMemory(
                                                    pBlock->Limit,
                                                    sizeof(DWORD)))) {

                        CopyMemory(name, pName, pBlock->Name.length);
                        name[pBlock->Name.length] = '\0';
                        Printf("%s%-23s  %8d\t(min: %d, max: %d)\n",
                               Indent(nIndents),
                               name,
                               *pLimit,
                               pBlock->MinLimit,
                               pBlock->MaxLimit);
                        FreeMemory(pLimit);
                    }
                    FreeMemory(pName);
                }
                pvProcess = (PCHAR)pvProcess + sizeof(LIMIT_BLOCK);
            } else {
                ok = FALSE;
            }
            FreeMemory(pBlock);
            fSuccess = TRUE;
        }
    
    } while ( ok && (pBlock != NULL) );
    return(fSuccess);

} // Dump LIMITS



BOOL
Dump_PAGED(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA dump routine.  Extremely hacky.  Assumes way too much about
    the internals of a USERDATA object because it's a c++ thing, and I don't
    know how to deal with that cleanly here.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSNAME in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    
    BOOL            fSuccess = FALSE;
    PLIST_ENTRY     ListEntry;
    PLIST_ENTRY     headList, ulo;
    BOOL            ok = TRUE;
    CHAR            name[MAX_PATH+1];        
    PLDAP_PAGED_BLOB    pPaged;
    PCHAR pTmp;

    Printf("%sPaged Cookies\n", Indent(nIndents));
    nIndents++;
    
    headList = (PLIST_ENTRY)pvProcess;

    do {

        if (NULL != (ListEntry = (PLIST_ENTRY)ReadMemory(pvProcess,
                                                       sizeof(LIST_ENTRY)))) {
                
            if ( ListEntry->Flink != headList ) {


                pTmp = (PCHAR)CONTAINING_RECORD(ListEntry->Flink,
                                        LDAP_PAGED_BLOB,
                                        ListEntry
                                        );

                pPaged = (PLDAP_PAGED_BLOB)ReadMemory(pTmp,
                                    sizeof(LDAP_PAGED_BLOB));

                if ( pPaged != NULL ) {
                    
                    Printf("%sCookie   %x\n",Indent(nIndents),pTmp);
                    Printf("%sBlobId   %d\n",Indent(nIndents),pPaged->BlobId);
                    Printf("%sBlobSize %d\n",Indent(nIndents),pPaged->BlobSize);
                    Printf("%sLdapConn %x\n",Indent(nIndents),pPaged->LdapConn);
                    Printf("%sBlob     %x\n\n",Indent(nIndents),
                           ((PLDAP_PAGED_BLOB)pTmp)->Blob);

                    pvProcess = ListEntry->Flink;
                    FreeMemory(pPaged);
                } else {
                    ok = FALSE;
                }

            } else {
                ok = FALSE;
            }

            FreeMemory(ListEntry);
            fSuccess = TRUE;
        } else {
            ok = FALSE;
        }
    } while ( ok );

    return(fSuccess);

} // Dump PAGED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\sam.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sam.c

Abstract:

    Helper functions for dsexts.dll ntsd/windbg debugger extensions.
    This contains routines to dump out SAM structures

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    24-Aug-96   MURLIS     Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
#include <samsrvp.h>
#include <winsock2.h>


BOOL
Dump_Sid(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

  Routine Description:

    Dumps a SID

  Arguments:

    nIndents    Desired Indentation Level
    pvProcess   Address of SID


  Return Values:

    TRUE on Success
    FALSE Otherwise

  --*/
{
    PSID            PSid = NULL;
    BOOL            fSuccess = FALSE;

    if (NULL != (PSid = (PSID) ReadMemory(pvProcess, sizeof(NT4SID))))
    {
        WCHAR   SidText[128];
        UNICODE_STRING  us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        RtlConvertSidToUnicodeString(&us, PSid, FALSE);
        Printf("%sSID = %S\n", Indent(nIndents), SidText);

        FreeMemory(PSid);

        fSuccess = TRUE;
    }

    return fSuccess;

}


BOOL
Dump_Context(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

  Routine Description:

    Dumps a SAM context Block

  Arguments:

    nIndents    Desired Indentation Level
    pvProcess   Address of Context Block


  Return Values:

    TRUE on Success
    FALSE Otherwise

  --*/
{
    PSAMP_OBJECT    Context = NULL;
    BOOL                fSuccess = FALSE; 
    IN_ADDR             inetAddr;


    Printf("%sContext Block\n", Indent(nIndents));
    nIndents++;

    if (NULL!=(Context=(PSAMP_OBJECT) ReadMemory(
                                        pvProcess,
                                        sizeof(SAMP_OBJECT))))
    {


        Printf("%sLIST_ENTRY Flink = %p\n",
            Indent(nIndents),Context->ContextListEntry.Flink);
        Printf("%sLIST_ENTRY Blink = %p\n",
            Indent(nIndents),Context->ContextListEntry.Blink);
        Printf("%sObjectType = %x\n",
            Indent(nIndents),(ULONG) (Context->ObjectType));
        Printf("%sFixedValid = %x\n",
            Indent(nIndents),(ULONG) (Context->FixedValid));
        Printf("%sVariableValid = %x\n",
            Indent(nIndents),(ULONG) (Context->VariableValid));
        Printf("%sFixedDirty = %x\n",
            Indent(nIndents),(ULONG) (Context->FixedDirty));
        Printf("%sVariableDirty = %x\n",
            Indent(nIndents),(ULONG) (Context->VariableDirty));
        Printf("%sOnDisk = %p\n",
            Indent(nIndents),Context->OnDisk);
        Printf("%sOnDiskAllocated = %x\n",
            Indent(nIndents),(ULONG) (Context->OnDiskAllocated));
        Printf("%sOnDiskUsed = %x\n",
            Indent(nIndents),(ULONG) (Context->OnDiskUsed));
        Printf("%sOnDiskFree = %x\n",
            Indent(nIndents),(ULONG) (Context->OnDiskFree));
        Printf("%sReferenceCount = %x\n",
            Indent(nIndents),(ULONG) (Context->ReferenceCount));
        Printf("%sGrantedAccess = %x\n",
            Indent(nIndents),(ULONG) (Context->GrantedAccess));
        Printf("%sRootKey = %p\n",
            Indent(nIndents),Context->RootKey);

        //
        // Print Root Key Name
        //

        Printf("%sRootName = \n", Indent(nIndents));
        Printf("%sMaximum Length = %x\n",
                Indent(nIndents+4), (ULONG)(Context->RootName.MaximumLength));
        Printf("%sLength = %x\n",
                Indent(nIndents+4), (ULONG) (Context->RootName.Length));

        Printf("%sBuffer = %p\n",
                Indent(nIndents+4), Context->RootName.Buffer);


        //
        // Print Out DS Name
        //

        Printf("%sObjectNameInDs = %p \n", Indent(nIndents),
                 Context->ObjectNameInDs);
        if (NULL!=Context->ObjectNameInDs)
        {
            if (!Dump_DSNAME(nIndents+4,Context->ObjectNameInDs))
                Printf("%sError Could Not Evaluate Expression",Indent(nIndents));
        }

        Printf("%sObjectFlags = %x\n",
                Indent(nIndents), (ULONG) Context->ObjectFlags);

        Printf("%sDomainIndex = %x\n",
                Indent(nIndents), (ULONG) Context->DomainIndex);

        Printf("%sClientRevision = %x\n",
                Indent(nIndents), (ULONG) Context->ClientRevision);

        if (Context->MarkedForDelete)
            Printf("%sMarkedForDelete = TRUE\n",Indent(nIndents));
        else
            Printf("%sMarkedForDelete = FALSE\n",Indent(nIndents));

        if (Context->TrustedClient)
            Printf("%sTrustedClient = TRUE\n",Indent(nIndents));
        else
            Printf("%sTrustedClient = FALSE\n",Indent(nIndents));

        if (Context->AuditOnClose)
            Printf("%sAuditOnClose = TRUE\n",Indent(nIndents));
        else
            Printf("%sAuditOnClose = FALSE\n",Indent(nIndents));

        if (Context->LoopbackClient)
            Printf("%sLoopbackClient = TRUE\n",Indent(nIndents));
        else
            Printf("%sLoopbackClient = FALSE\n",Indent(nIndents));


        if (Context->Valid)
            Printf("%sValid = TRUE\n",Indent(nIndents));
        else
            Printf("%sValid = FALSE\n",Indent(nIndents));

        Printf("%sSignature = %x\n", Indent(nIndents), Context->Signature);

        if (Context->NotSharedByMultiThreads)
            Printf("%sNotSharedByMultiThreads = TRUE\n",Indent(nIndents));
        else
            Printf("%sNotSharedByMultiThreads = FALSE\n",Indent(nIndents));

        if (Context->OpenedByDCPromo)
            Printf("%sOpenedByDCPromo = TRUE\n", Indent(nIndents));
        else
            Printf("%sOpenedByDCPromo = FALSE\n", Indent(nIndents));

        Printf("%sTYPE BODY IS",Indent(nIndents));

        switch(Context->ObjectType)
        {
        case SampDomainObjectType:
                Printf(" DOMAIN\n");
                break;

        case SampUserObjectType:
                Printf(" USER\n");
                Printf("%sRid = %x\n",
                    Indent(nIndents+4),
                    Context->TypeBody.User.Rid
                    );

                Printf("%sLockoutTime %x %x\n", 
                       Indent(nIndents+4),
                       Context->TypeBody.User.LockoutTime.HighPart,
                       Context->TypeBody.User.LockoutTime.LowPart
                       );

                Printf("%sLastLogonTimeStamp %x %x\n", 
                       Indent(nIndents+4),
                       Context->TypeBody.User.LastLogonTimeStamp.HighPart,
                       Context->TypeBody.User.LastLogonTimeStamp.LowPart
                       );

                if (Context->TypeBody.User.CachedSupplementalCredentialsValid)
                {
                    Printf("%sCachedSupplementalCredentialsValid= TRUE\n",
                           Indent(nIndents+4) );
                    Printf("%sCachedSupplementalCredentialsLength= %ld\n",
                           Indent(nIndents+4),
                           Context->TypeBody.User.CachedSupplementalCredentialLength);
                    Printf("%sCachedSupplementalCredentials= %p\n",
                        Indent(nIndents+4),
                        Context->TypeBody.User.CachedSupplementalCredentials);
                }
                else
                {
                    Printf("%sCachedSupplementalCredentialsValid= FALSE\n",
                        Indent(nIndents+4));
                }


                Printf("%sSupplementalCredentialsToWrite= %p\n",
                       Indent(nIndents+4),
                       Context->TypeBody.User.SupplementalCredentialsToWrite
                       );




                if (Context->TypeBody.User.CachedOrigUserParmsIsValid)
                {
                    Printf("%sCachedOrigUserParmsIsValid = TRUE\n",
                           Indent(nIndents+4));
                    Printf("%sCachedOrigUserParmsLength = %ld\n",
                           Indent(nIndents+4),
                           Context->TypeBody.User.CachedOrigUserParmsLength);
                    Printf("%sCachedOrigUserParms = %p\n",
                           Indent(nIndents+4),
                           Context->TypeBody.User.CachedOrigUserParms);
                }
                else
                {
                    Printf("%sCachedOrigUserParmsIsValid = FALSE\n",
                           Indent(nIndents+4));
                }

                if (Context->TypeBody.User.DomainPasswordInformationAccessible)
                    Printf("%sDomainPasswordInformationAccessible = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sDomainPasswordInformationAccessible = FALSE\n",
                           Indent(nIndents+4));

                if (Context->TypeBody.User.PrivilegedMachineAccountCreate)
                    Printf("%sPrivilegedMachineAccountCreate = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sPrivilegedMachineAccountCreate = FALSE\n",
                           Indent(nIndents+4));

                if (Context->TypeBody.User.UparmsInformationAccessible)
                    Printf("%sUparmsInformationAccessible = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sUparmsInformationAccessible = FALSE\n",
                           Indent(nIndents+4));

                Printf("%sDomainSidForNt4SdConversion = %p\n", 
                       Indent(nIndents+4), 
                       Context->TypeBody.User.DomainSidForNt4SdConversion);

                Printf("%sUPN \n", Indent(nIndents+4));
                Printf("%sMaximum Length = %x\n", Indent(nIndents+8),
                       (ULONG) (Context->TypeBody.User.UPN.MaximumLength));
                Printf("%sLength = %x\n", Indent(nIndents+8),
                       (ULONG) (Context->TypeBody.User.UPN.Length));
                Printf("%sBuffer = %p\n", Indent(nIndents+8),
                       Context->TypeBody.User.UPN.Buffer);

                if (Context->TypeBody.User.UpnDefaulted)
                    Printf("%sUpnDefaulted = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sUpnDefaulted = FALSE\n",
                           Indent(nIndents+4));

                Printf("%sSiteAffinity \n", Indent(nIndents+4));
                Printf("%sGuid = %s\n", 
                    Indent(nIndents+8), 
                    DraUuidToStr(&(Context->TypeBody.User.SiteAffinity.SiteGuid), NULL, 0));

                Printf("%sTimeStamp = %x %x\n", 
                    Indent(nIndents+8),
                    Context->TypeBody.User.SiteAffinity.TimeStamp.HighPart,
                    Context->TypeBody.User.SiteAffinity.TimeStamp.LowPart );

                if (Context->TypeBody.User.fCheckForSiteAffinityUpdate) 
                    Printf("%sfCheckForSiteAffinityUpdate = TRUE\n", 
                        Indent(nIndents+4));
                else
                    Printf("%sfCheckForSiteAffinityUpdate = FALSE\n", 
                        Indent(nIndents+4));       

                if (Context->TypeBody.User.fNoGcAvailable) 
                    Printf("%sfNoGcAvailable = TRUE\n", 
                        Indent(nIndents+4));
                else
                    Printf("%sfNoGcAvailable = FALSE\n", 
                        Indent(nIndents+4)); 

                Printf("%sClientInfo \n", Indent(nIndents+4));
                                
                switch (Context->TypeBody.User.ClientInfo.Type) {

                case SamClientNoInformation:
                    Printf("%sType = %x (SamClientNoInformation)\n", 
                        Indent(nIndents+8),
                        Context->TypeBody.User.ClientInfo.Type);
                    break;

                case SamClientIpAddr:
                    Printf("%sType = %x (SamClientIpAddr)\n", 
                        Indent(nIndents+8),
                        Context->TypeBody.User.ClientInfo.Type);
                    
                    inetAddr.s_addr = (ULONG)(Context->TypeBody.User.ClientInfo.Data.IpAddr);

                    Printf("%sIpAddr = %x (%s)\n", 
                        Indent(nIndents+8),
                        Context->TypeBody.User.ClientInfo.Data.IpAddr,
                        inet_ntoa(inetAddr));                    
                    break;
                        
                default:
                    Printf("%sType = %x (UNKNOWN)\n", 
                        Indent(nIndents+8),
                        Context->TypeBody.User.ClientInfo.Type);
                    break;
                    
                }                                    

                break;

        case SampGroupObjectType:
                Printf(" GROUP\n");
                Printf("%sRid = %x\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.Rid
                    );
                Printf("%sNT4GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.NT4GroupType
                    );
                Printf("%sNT5GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.NT5GroupType
                    );
                Printf("%sSecurityEnabled = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.SecurityEnabled
                    );
                Printf("%sCachedMembershipOperationsListMaxLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.CachedMembershipOperationsListMaxLength
                    );
                Printf("%sCachedMembershipOperationsListLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.CachedMembershipOperationsListLength
                    );
                Printf("%sCachedMembershipOperationsList = %p\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.CachedMembershipOperationsList
                    );

                break;

         case SampAliasObjectType:
                Printf(" ALIAS\n");
                Printf("%sRid = %x\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.Rid
                    );
                Printf("%sNT4GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.NT4GroupType
                    );
                Printf("%sNT5GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.NT5GroupType
                    );
                Printf("%sSecurityEnabled = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.SecurityEnabled
                    );
                Printf("%sCachedMembershipOperationsListMaxLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength
                    );
                Printf("%sCachedMembershipOperationsListLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.CachedMembershipOperationsListLength
                    );
                Printf("%sCachedMembershipOperationsList = %p\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.CachedMembershipOperationsList
                    );

                break;

         case SampServerObjectType:
                Printf(" SERVER\n");
                break;

         default:
                Printf(" UNKNOWN\n");
                break;
        }

        FreeMemory(Context);

        fSuccess = TRUE;
    }
    return fSuccess;
}


ULONG   MAX_CONTEXTS_COUNT = 500;


BOOL
Dump_ContextList(
    IN DWORD    nIndents,
    IN PVOID    pvProcess
    )
{
    PLIST_ENTRY     Head, NextEntry;
    PSAMP_OBJECT    Context = NULL;
    BOOL            fSuccess = FALSE;
    ULONG           ContextListCount = 0;

    Printf("%sSAM Context List\n", Indent(nIndents));
    nIndents++;

    if (NULL != (Head=(PLIST_ENTRY) ReadMemory(pvProcess, sizeof(LIST_ENTRY))))
    {
        fSuccess = TRUE;
        NextEntry = Head->Flink;

        while ((NextEntry != Head) && (ContextListCount < MAX_CONTEXTS_COUNT))
        {
            ContextListCount++;
            if (NULL != (Context = (PSAMP_OBJECT) ReadMemory((PVOID)NextEntry, 
                                                             sizeof(SAMP_OBJECT))))
            {
                Printf("%sLIST_ENTRY Flink = %p\n",
                       Indent(nIndents),Context->ContextListEntry.Flink);
                Printf("%sLIST_ENTRY Blink = %p\n",
                       Indent(nIndents),Context->ContextListEntry.Blink);
                Printf("%sReferenceCount = %x\n",
                    Indent(nIndents),(ULONG) (Context->ReferenceCount));
                if (Context->MarkedForDelete)
                    Printf("%sMarkedForDelete = TRUE\n",Indent(nIndents));
                else
                    Printf("%sMarkedForDelete = FALSE\n",Indent(nIndents));

                if (Context->NotSharedByMultiThreads)
                    Printf("%sNotSharedByMultiThreads = TRUE\n",Indent(nIndents));
                else
                    Printf("%sNotSharedByMultiThreads = FALSE\n",Indent(nIndents));

                switch (Context->ObjectType)
                {
                case SampServerObjectType:
                    Printf("%sObjectType = SERVER\n", Indent(nIndents));
                    break;
                case SampDomainObjectType:
                    Printf("%sObjectType = DOMAIN\n", Indent(nIndents));
                    break;
                case SampUserObjectType:
                    Printf("%sObjectType = USER\n", Indent(nIndents));
                    Printf("%sRid = %x\n", Indent(nIndents+4), 
                           Context->TypeBody.User.Rid);
                    break;
                case SampGroupObjectType:
                    Printf("%sObjectType = GROUP\n", Indent(nIndents));
                    Printf("%sRid = %x\n", Indent(nIndents+4), 
                           Context->TypeBody.Group.Rid);
                    break;
                case SampAliasObjectType:
                    Printf("%sObjectType = ALIAS\n", Indent(nIndents));
                    Printf("%sRid = %x\n", Indent(nIndents+4), 
                           Context->TypeBody.Alias.Rid);
                    break;
                default:
                    Printf("%sUNKNOWN Object Type\n", Indent(nIndents));
                    break;
                }

                NextEntry = Context->ContextListEntry.Flink;
                FreeMemory(Context);
            }
            else
            {
                fSuccess = FALSE;
                break;
            }
        }

        FreeMemory(Head);
    }

    return fSuccess;
}




BOOL
Dump_DefinedDomain(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

  Routine Description:

    Dumps a SAM Defined Domain

  Arguments:

    nIndents    Desired Indentation Level
    pvProcess   Address of Defined Domain


  Return Values:

    TRUE on Success
    FALSE Otherwise

--*/

{

    PSAMP_DEFINED_DOMAINS    DefinedDomain = NULL;
    BOOL            fSuccess = FALSE;
    CHAR            szNetLogonChangeLogSerialNumber[20];


    Printf("%sDefined Domain\n", Indent(nIndents));
    nIndents++;

    if (NULL!=(DefinedDomain=(PSAMP_DEFINED_DOMAINS) ReadMemory(
                                                        pvProcess,
                                                        sizeof(SAMP_DEFINED_DOMAINS))))
    {
        if (!Dump_Context(nIndents+4,DefinedDomain->Context))
            Printf("%sError Could Not Evaluate Expression\n",Indent(nIndents));

        Printf("%sSID Address = %p\n", Indent(nIndents), DefinedDomain->Sid);
        if (DefinedDomain->Sid)
        {
            Dump_Sid(nIndents+4, DefinedDomain->Sid);
        }
        else
        {
            Printf("%sSID = NULL\n", Indent(nIndents+4));
        }

        Printf("%sExternalName \n", Indent(nIndents));
        Printf("%sMaximum Length = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->ExternalName.MaximumLength));
        Printf("%sLength = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->ExternalName.Length));
        Printf("%sBuffer = %p\n", Indent(nIndents+4),
               DefinedDomain->ExternalName.Buffer);

        Printf("%sInternalName \n", Indent(nIndents));
        Printf("%sMaximum Length = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->InternalName.MaximumLength));
        Printf("%sLength = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->InternalName.Length));
        Printf("%sBuffer = %p\n", Indent(nIndents+4),
               DefinedDomain->InternalName.Buffer);

        Printf("%sAdminUserSD = %p\n", Indent(nIndents), DefinedDomain->AdminUserSD);
        Printf("%sAdminGroupSD = %p\n", Indent(nIndents), DefinedDomain->AdminGroupSD);
        Printf("%sNormalUserSD = %p\n", Indent(nIndents), DefinedDomain->NormalUserSD);
        Printf("%sNormalGroupSD = %p\n", Indent(nIndents), DefinedDomain->NormalGroupSD);
        Printf("%sNormalAliasSD = %p\n", Indent(nIndents), DefinedDomain->NormalAliasSD);

        Printf("%sAdminUserRidPointer = %p\n", Indent(nIndents), DefinedDomain->AdminUserRidPointer);
        Printf("%sNormalUserRidPointer = %p\n", Indent(nIndents), DefinedDomain->NormalUserRidPointer);

        Printf("%sAdminUserSDLength = %x\n", Indent(nIndents), DefinedDomain->AdminUserSDLength);
        Printf("%sAdminGroupSDLength = %x\n", Indent(nIndents), DefinedDomain->AdminGroupSDLength);
        Printf("%sNormalUserSDLength = %x\n", Indent(nIndents), DefinedDomain->NormalUserSDLength);
        Printf("%sNormalGroupSDLength = %x\n", Indent(nIndents), DefinedDomain->NormalGroupSDLength);
        Printf("%sNormalAliasSDLength = %x\n", Indent(nIndents), DefinedDomain->NormalAliasSDLength);

        Printf("%sCurrentFixed\n", Indent(nIndents));
        Dump_FixedLengthDomain_local(nIndents+4, &(DefinedDomain->CurrentFixed));

        Printf("%sUnmodifiedFixed\n", Indent(nIndents));
        Dump_FixedLengthDomain_local(nIndents+4, &(DefinedDomain->UnmodifiedFixed));


        if (DefinedDomain->FixedValid)
            Printf("%sFixedValid = TRUE\n", Indent(nIndents));
        else
            Printf("%sFixedValid = FALSE\n", Indent(nIndents));



        RtlLargeIntegerToChar((LARGE_INTEGER *) &(DefinedDomain->NetLogonChangeLogSerialNumber),
                              16,
                              sizeof(szNetLogonChangeLogSerialNumber),
                              szNetLogonChangeLogSerialNumber
                              );

        Printf("%sNetLogonChangeLogSerialNumber = %16s\n", Indent(nIndents),
               szNetLogonChangeLogSerialNumber);


        if (DefinedDomain->IsBuiltinDomain)
            Printf("%sIsBuiltinDomain = TRUE\n", Indent(nIndents));
        else
            Printf("%sIsBuiltinDomain = FALSE\n", Indent(nIndents));


        if (DefinedDomain->IsMixedDomain)
            Printf("%sIsMixedDomain = TRUE\n", Indent(nIndents));
        else
            Printf("%sIsMixedDomain = FALSE\n", Indent(nIndents));

        Printf("%sBehaviorVersion = %x\n", Indent(nIndents), DefinedDomain->BehaviorVersion);

        Printf("%sLastLogonTimeStampSyncInterval = %x\n", Indent(nIndents), DefinedDomain->LastLogonTimeStampSyncInterval);


        switch (DefinedDomain->ServerRole)
        {
        case DomainServerRoleBackup:
            Printf("%sServerRole = DomainServerRoleBackup\n", Indent(nIndents));
            break;

        case DomainServerRolePrimary:
            Printf("%sServerRole = DomainServerRolePrimary\n", Indent(nIndents));
            break;

        default:
            Printf("%sServerRole = UNKNOWN\n", Indent(nIndents));
            break;
        }


        Printf("%sDsDomainHandle = %p\n", Indent(nIndents), DefinedDomain->DsDomainHandle);

        FreeMemory(DefinedDomain);

        fSuccess = TRUE;
    }

    return fSuccess;

}

BOOL
Dump_DefinedDomains(
    IN DWORD    nIndents,
    IN PVOID    pvProcess
    )
/*++

    Routine Description:

        Dumps out all Defined Domains in the SampDefinedDomains Array

    Arguments:
        nIndents    Desired Indentation Level
        pvProcess   Address of Defined Domains

    Return Values:

        TRUE on success
        FALSE on Failure

--*/

{
    BOOL    fSuccess = TRUE;
    PULONG  pDefinedDomainsCount = NULL;
    PVOID   pAddress = NULL;
    ULONG   Count = 0;
    ULONG_PTR DefinedDomainAddress;

    pAddress = (VOID *) GetExpr("samsrv!SampDefinedDomainsCount");

    if (NULL == pAddress) {
        Printf("Can't Locate the Address of samsrv!SampDefinedDomainsCount - Sorry\n");
        return FALSE;
    }

    pDefinedDomainsCount = (ULONG *) ReadMemory(pAddress, sizeof(ULONG));

    if (NULL == pDefinedDomainsCount)
    {
        Printf("Can't Read Memory - Sorry\n");
        return FALSE;
    }

    for (Count = 0; Count < *pDefinedDomainsCount; Count ++)
    {
        DefinedDomainAddress = (ULONG_PTR)pvProcess + Count*sizeof(SAMP_DEFINED_DOMAINS);

        Printf("\n%sDefined Domain %d: Address Starts From %p\n",
               Indent(nIndents),
               Count,
               DefinedDomainAddress
              );

        if (!Dump_DefinedDomain(nIndents+2, (PVOID) DefinedDomainAddress) )
        {
            Printf("%sError Could Not Evaluate Defined Domain %d\n", Indent(nIndents), Count+1);
            fSuccess = FALSE;
        }
    }

    FreeMemory(pDefinedDomainsCount);

    return fSuccess;

}


BOOL
Dump_FixedLengthDomain_local(
    IN DWORD    nIndents,
    IN PVOID    pvProcess
    )
/*++

    Routine Description:

        Dumps out SAMP_V1_0A_FIXED_LENGTH_DOMAIN

    Arguments:

        seee Dump_Context

    Return Values:

        TRUE on success
        FALSE on failure
--*/
{
    BOOL    fSuccess = FALSE;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN Fixed = pvProcess;
    CHAR    szCreationTime[20];
    CHAR    szModifiedCount[20];
    CHAR    szMaxPasswordAge[20];
    CHAR    szMinPasswordAge[20];
    CHAR    szForceLogoff[20];
    CHAR    szLockoutDuration[20];
    CHAR    szLockoutObservationWindow[20];
    CHAR    szModifiedCountAtLastPromotion[20];

    Printf("%sRevision = %x\n", Indent(nIndents), Fixed->Revision);
    Printf("%sUnused1 = %x\n", Indent(nIndents), Fixed->Unused1);

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->CreationTime,
            16,
            sizeof( szCreationTime ),
            szCreationTime
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->ModifiedCount,
            16,
            sizeof( szModifiedCount ),
            szModifiedCount
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->MaxPasswordAge,
            16,
            sizeof( szMaxPasswordAge ),
            szMaxPasswordAge
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->MinPasswordAge,
            16,
            sizeof( szMinPasswordAge ),
            szMinPasswordAge
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->ForceLogoff,
            16,
            sizeof( szForceLogoff ),
            szForceLogoff
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->LockoutDuration,
            16,
            sizeof( szLockoutDuration ),
            szLockoutDuration
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->LockoutObservationWindow,
            16,
            sizeof( szLockoutObservationWindow ),
            szLockoutObservationWindow
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->ModifiedCountAtLastPromotion,
            16,
            sizeof( szModifiedCountAtLastPromotion ),
            szModifiedCountAtLastPromotion
            );

    Printf("%sCreationTime = %16s\n", Indent(nIndents), szCreationTime);
    Printf("%sModifiedCount = %16s\n", Indent(nIndents), szModifiedCount);
    Printf("%sMaxPasswordAge = %16s\n", Indent(nIndents), szMaxPasswordAge);
    Printf("%sMinPasswordAge = %16s\n", Indent(nIndents), szMinPasswordAge);
    Printf("%sForceLogoff = %16s\n", Indent(nIndents), szForceLogoff);
    Printf("%sLockoutDuration = %16s\n", Indent(nIndents), szLockoutDuration);
    Printf("%sLockoutObservationWindow = %16s\n", Indent(nIndents), szLockoutObservationWindow);
    Printf("%sModifiedCountAtLastPromotion = %16s\n", Indent(nIndents), szModifiedCountAtLastPromotion);

    Printf("%sNextRid = %x\n", Indent(nIndents), Fixed->NextRid);
    Printf("%sPasswordProperties = %x\n", Indent(nIndents), Fixed->PasswordProperties);
    Printf("%sMinPasswordLength = %x\n", Indent(nIndents), Fixed->MinPasswordLength);
    Printf("%sPasswordHistoryLength = %x\n", Indent(nIndents), Fixed->PasswordHistoryLength);
    Printf("%sLockoutThreshold = %x\n", Indent(nIndents), Fixed->LockoutThreshold);

    switch (Fixed->ServerState)
    {
    case DomainServerEnabled:
        Printf("%sServerState = DomainServerEnabled\n", Indent(nIndents));
        break;

    case DomainServerDisabled:
        Printf("%sServerState = DomainServerDisabled\n", Indent(nIndents));
        break;

    default:
        Printf("%sServerState = UNKNOWN\n", Indent(nIndents));
        break;
    }

    switch (Fixed->ServerRole)
    {
    case DomainServerRoleBackup:
        Printf("%sServerRole = DomainServerRoleBackup\n", Indent(nIndents));
        break;

    case DomainServerRolePrimary:
        Printf("%sServerRole = DomainServerRolePrimary\n", Indent(nIndents));
        break;

    default:
        Printf("%sServerRole = UNKNOWN\n", Indent(nIndents));
        break;
    }

    if (Fixed->UasCompatibilityRequired)
        Printf("%sUasCompatibilityRequired = TRUE\n", Indent(nIndents));
    else
        Printf("%sUasCompatibilityRequired = FALSE\n", Indent(nIndents));

    Printf("%sUnused2 = %3c\n", Indent(nIndents), Fixed->Unused2);

    Printf("%sDomainKeyAuthType = %x\n", Indent(nIndents), Fixed->DomainKeyAuthType);

    Printf("%sDomainKeyFlags = %x\n", Indent(nIndents), Fixed->DomainKeyFlags);

    Printf("%sAddress of DomainKeyInformation = %x\n",
           Indent(nIndents),
           &(Fixed->DomainKeyInformation)
           );

    return fSuccess;

}


BOOL
Dump_AttrBlock(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

      Routine Description:

            Dumps out a DS Attr Block.

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ATTRBLOCK   *pAttrBlock=NULL;
    DWORD       iCursor = 0;
    BOOL        fSuccess = FALSE;


    pAttrBlock = (ATTRBLOCK *)ReadMemory(pvProcess,sizeof(ATTRBLOCK));
    fSuccess = Dump_AttrBlock_local(nIndents, pAttrBlock, TRUE);
    if (NULL!=pAttrBlock)
        {
        FreeMemory(pAttrBlock);
    }

    return fSuccess;
}

BOOL
Dump_AttrBlock_local(
        IN  DWORD   nIndents,
        IN  ATTRBLOCK *pAttrBlock,
        BOOL fHasValues
    )
/*++

      Routine Description:

            Dumps out a DS Attr Block.

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    DWORD       iCursor = 0;
    BOOL        fSuccess = FALSE;
    ATTR        *pAttr = NULL;


    Printf("%sATTRBLOCK\n",Indent(nIndents));

    if (NULL!=pAttrBlock)
    {
        Printf("%sattrCount: %u\n",Indent(nIndents+1), pAttrBlock->attrCount);

        fSuccess = TRUE;

        // pAttrBlock->pAttr's value is an address space of the debugee.
        // So, we can add appropriate offsets to it to dump subsequent ATTR
        // structures
        for (iCursor = 0;
             fSuccess && (iCursor < pAttrBlock->attrCount);
             iCursor++)  {

            Printf("%spAttr[%u]: (@ 0x%x)\n", Indent(nIndents+1), iCursor,
                   pAttrBlock->pAttr + iCursor);

            pAttr = (ATTR *) ReadMemory(pAttrBlock->pAttr + iCursor,
                                        sizeof(ATTR));
            fSuccess = (NULL != pAttr);

            if (fSuccess) {
                fSuccess = Dump_Attr_local(nIndents+1, pAttr, fHasValues);
                FreeMemory(pAttr);
            }
        }
    }

    return fSuccess;
}

BOOL
Local_Dump_AttrValBlock(
    IN  DWORD   nIndents,
    IN  ATTRVALBLOCK *pAttrValBlock
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ATTRVAL      *pAVal = NULL;
    ULONG        i,j;
    BOOL         fSuccess = FALSE;

    Printf("%svalCount = %u\n",Indent(nIndents+1),pAttrValBlock->valCount);

    if (0 == pAttrValBlock->valCount) {
        return TRUE;
    }

    pAVal =(ATTRVAL *) ReadMemory(pAttrValBlock->pAVal,
                                  (sizeof(ATTRVAL) *
                                   pAttrValBlock->valCount));
    if (NULL!=pAVal) {
        for (i=0;i<pAttrValBlock->valCount;i++) {

            Printf("%spAVal[%u]: @ %p, len 0x%x\n", Indent(nIndents+1), i,
                   pAVal[i].pVal, pAVal[i].valLen);
        }

        FreeMemory(pAVal);

        fSuccess = TRUE;
    }

    return fSuccess;
}



Dump_AttrValBlock(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    BOOL        fSuccess = FALSE;
    ATTRVALBLOCK *pAttrValBlock = NULL;

    pAttrValBlock = (ATTRVALBLOCK *) ReadMemory(pvProcess,sizeof(ATTRVALBLOCK));

    if (NULL!=pAttrValBlock) {
        fSuccess = Local_Dump_AttrValBlock(nIndents, pAttrValBlock);
    }

    return fSuccess;
}



BOOL
Dump_Attr_local(
        IN  DWORD   nIndents,
        IN  ATTR    *pAttr,
        IN  BOOL    fHasValues
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ULONG       i;
    BOOL        fSuccess = FALSE;

    if (NULL!=pAttr)
    {
        Printf("%sattrType: 0x%x\n",Indent(nIndents+1),pAttr->attrTyp);
        if(fHasValues) {
            fSuccess = Local_Dump_AttrValBlock(nIndents+1,&(pAttr->AttrVal));
        }
        else {
            // This isn't supposed to have values.
            if(pAttr->AttrVal.valCount) {
                // But it does
                Printf("%sINCORRECTLY HAS VALUES!\n");
                fSuccess =
                    Local_Dump_AttrValBlock(nIndents+1,&(pAttr->AttrVal));
            }
            else {
                fSuccess = TRUE;
            }
        }
    }

    return fSuccess;
}




BOOL
Dump_Attr(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ATTR        *pAttr = NULL;
    ATTRVAL     *pAVal = NULL;
    ULONG       i;
    BOOL        fSuccess = FALSE;

    pAttr = (ATTR *) ReadMemory(pvProcess,sizeof(ATTR));

    if (NULL!=pAttr)
    {
        fSuccess = Dump_Attr_local(nIndents, pAttr, TRUE);
        FreeMemory(pAttr);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\md.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    md.c

Abstract:

    Dump functions for types used by dsamain\src - i.e. the mini-directory.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Jan-00   XinHe       Added Dump_TQEntry()

    08-May-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop
#include "winsock.h"            // htonl and ntohl
#include "dsexts.h"
#include "objids.h"
#include <ntdsa.h>
#include "drs.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"
#include "mappings.h"
#include "mdlocal.h"
#include "anchor.h"
#include "direrr.h"
#include "filtypes.h"
#include <dsjet.h>
#include "dbintrnl.h"
#include "dsatools.h"
#include "bhcache.h"
#include "gcverify.h"
#include <debug.h>
#include <dsutil.h>
#include <xdommove.h>
#include <lmcons.h>
#include <checkacl.h>
#include <seopaque.h>
#include <taskq.h>
#include <lht.h>
#include <lhtp.h>

typedef struct _AttrSelectionCode {
    UCHAR chCode;
    CHAR  *pszCode;
} AttrSelectionCode;

AttrSelectionCode rAttrSelectionCode[] = {
    {'A',   "EN_ATTSEL_ALL"},
    {'B',   "EN_ATTSEL_ALL_WITH_LIST"},
    {'L',   "EN_ATTSET_LIST"},
    {'E',   "EN_ATTSET_LIST_DRA"},
    {'D',   "EN_ATTSET_ALL_DRA"},
    {'F',   "EN_ATTSET_LIST_DRA_EXT"},
    {'G',   "EN_ATTSET_ALL_DRA_EXT"},
    {'H',   "EN_ATTSET_LIST_DRA_PUBLIC"},
    {'I',   "EN_ATTSET_ALL_DRA_PUBLIC"},
    {'T',   "EN_INFOTYPES_TYPES_ONLY"},
    {'V',   "EN_INFOTYPES_TYPES_VALS"},
    {'S',   "EN_INFOTYPES_SHORTNAMES"},
    {'M',   "EN_INFOTYPES_MAPINAMES"},
};


DWORD cAttrSelectionCode = sizeof(rAttrSelectionCode) / sizeof(AttrSelectionCode);

#define UNKNOWN_SELECTION_CODE "Unknown Selection Code"

char *PszSelCodeToString(UCHAR ch);


typedef struct GuidCache
{
    CHAR                *name;
    GUID                guid;
    int                 type;
} GuidCache;


GuidCache guidCache[] = {
    #include "..\aclguids\guidcache.h"
};

#define NUM_KNOWN_GUIDS  (sizeof (guidCache) / sizeof (GuidCache) -1 )



BOOL
Dump_DSNAME(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DSNAME dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSNAME in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    DSNAME          *pName = NULL;
    ULONG           structLen;
    int             cDelta;

    Printf("%sDSNAME", Indent(nIndents));
    nIndents++;

    if ( NULL != (pName = (DSNAME *) ReadMemory(pvProcess,
                                                sizeof(DSNAME))))
    {
        structLen = pName->structLen;

        Printf("\n%s", Indent(nIndents));
        Printf("total size: %u, name len: %u",
               pName->structLen, pName->NameLen);
        cDelta = pName->structLen - DSNameSizeFromLen(pName->NameLen);
        if (cDelta) {
            Printf(" Sizes are inconsistent, %d bytes %sallocated",
                   cDelta, (cDelta > 0) ? "over" : "UNDER");
        }
        Printf("\n%sGuid: %s",
               Indent(nIndents), DraUuidToStr(&(pName->Guid), NULL, 0));

        FreeMemory(pName);

        if (pName->SidLen) {
            WCHAR SidText[128];
            UNICODE_STRING us;

            SidText[0] = L'\0';
            us.MaximumLength = sizeof(SidText);
            us.Length = 0;
            us.Buffer = SidText;

            RtlConvertSidToUnicodeString(&us, &pName->Sid, FALSE);
            Printf("\n%sSID: %S", Indent(nIndents), SidText);
        }

        if ( NULL != (pName = (DSNAME *) ReadMemory(
                                                    pvProcess,
                                                    structLen)) )
        {
            Printf("\n%s", Indent(nIndents));
            Printf("Name: ");
            Printf("%S\n", pName->StringName);

            FreeMemory(pName);
            fSuccess = TRUE;
        }
    }

    return(fSuccess);
}


BOOL
Dump_DSNAME_local(
    IN DWORD nIndents,
    IN PVOID pvLocal)

/*++

Routine Description:

    Public DSNAME dump routine.
    Assumes the whole DNSAME (pDN->structLen worth) is already in memory

Arguments:

    nIndents - Indentation level desired.

    pLocal - the DSNAME in local memory

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    DSNAME          *pName = (DSNAME *) pvLocal;
    ULONG           structLen;
    int             cDelta;

    Printf("%sDSNAME", Indent(nIndents));
    nIndents++;

    structLen = pName->structLen;

    Printf("\n%s", Indent(nIndents));
    Printf("total size: %u, name len: %u",
           pName->structLen, pName->NameLen);
    cDelta = pName->structLen - DSNameSizeFromLen(pName->NameLen);
    if (cDelta) {
        Printf(" Sizes are inconsistent, %d bytes %sallocated",
               cDelta, (cDelta > 0) ? "over" : "UNDER");
    }
    Printf("\n%sGuid: %s",
           Indent(nIndents), DraUuidToStr(&(pName->Guid), NULL, 0));

    if (pName->SidLen) {
        WCHAR SidText[128];
        UNICODE_STRING us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        RtlConvertSidToUnicodeString(&us, &pName->Sid, FALSE);
        Printf("\n%sSID: %S", Indent(nIndents), SidText);
    }

    Printf("\n%s", Indent(nIndents));
    Printf("Name: ");
    Printf("%S\n", pName->StringName);

    fSuccess = TRUE;

    return(fSuccess);
}

BOOL
Dump_NC_Entry(
    IN DWORD nIndents,
    IN PVOID pNCL,
    OUT PVOID *pNextNC)
/*++

Routine Description:

    Public NAMING_CONTEXT_LIST entry dump routine.

Arguments:

    nIndents - Indentation level desired.

    pNCL - address of NAMING_CONTEXT_LIST entry in debugee address space

    pNextNC - address of next NAMING_CONTEXT_LIST entry in debugee address space

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    NAMING_CONTEXT_LIST *pNCListTmp;

    if(pNextNC == NULL){
        Printf("ASSERT: pNextNC was NULL in Dump_NC_Entry in dsexts\\md.c, line %d\n", __LINE__);
    return(FALSE);
    }
    pNCListTmp = ReadMemory(pNCL, sizeof(NAMING_CONTEXT_LIST));

    if ( NULL == pNCListTmp )
        return(FALSE);

    Printf("%sNC Entry @%p\n",
           Indent(nIndents),
           pNCL);
    nIndents++;
    Dump_DSNAME(nIndents, pNCListTmp->pNC);
    Printf("%sNCDNT          0x%x\n",
           Indent(nIndents),
           pNCListTmp->NCDNT);
    Printf("%sDelContDNT     0x%x\n",
           Indent(nIndents),
           pNCListTmp->DelContDNT);
    Printf("%sLost&FoundDNT  0x%x\n",
           Indent(nIndents),
           pNCListTmp->LostAndFoundDNT);
    Printf("%sfReplNotify    %s\n",
           Indent(nIndents),
           pNCListTmp->fReplNotify ? "True": "False");
    Dump_DSNAME(nIndents, pNCListTmp->pNtdsQuotasDN);
    Printf("%sulDefaultQuota 0x%x\n",
           Indent(nIndents),
           pNCListTmp->ulDefaultQuota);
    Printf("%sulTombstoneQuotaWeight 0x%x\n",
           Indent(nIndents),
           pNCListTmp->ulTombstonedQuotaWeight);
    Printf("%sNextNC is    @ %p\n", Indent(nIndents), pNCListTmp->pNextNC);

    *pNextNC = pNCListTmp->pNextNC;
    FreeMemory(pNCListTmp);

    return TRUE;
}


BOOL
Dump_NAMING_CONTEXT_LIST(
    IN DWORD nIndents,
    IN PCHAR pNCname,
    IN PVOID pNCL)

/*++

Routine Description:

    Public NAMING_CONTEXT_RC dump routine.

Arguments:

    nIndents - Indentation level desired.

    pNCname -- name of the list

    pNCL - address of NAMING_CONTEXT_LIST in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    DWORD   nTmp;

    Printf("%s%s @ %p\n", Indent(nIndents), pNCname, pNCL);

    nTmp = nIndents + 1;
    while ( NULL != pNCL )
    {
        if (!Dump_NC_Entry(nTmp, pNCL, &pNCL)) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
Dump_RESOBJ (
    IN DWORD nIndents,
    IN PVOID pvProcess)
{
    RESOBJ * pResObj;

    if (NULL == pvProcess) {
        Printf("%sNo resolved object\n", Indent(nIndents));
        return FALSE;
    }

    pResObj = (RESOBJ*) ReadMemory(pvProcess, sizeof(READARG));
    if (pResObj) {
        Dump_DSNAME(nIndents, pResObj->pObj);
        Printf("%sDNT = 0x%x, PDNT = 0x%x, NCDNT = 0x%x\n",
               Indent(nIndents),
               pResObj->DNT,
               pResObj->PDNT,
               pResObj->NCDNT);
        Printf("%sInstance Type = 0x%x\n",
               Indent(nIndents),
               pResObj->InstanceType);
        Printf("%sObjectClass   = 0x%x\n",
               Indent(nIndents),
               pResObj->MostSpecificObjClass);
        Printf("%sIs Deleted    = %s\n",
               Indent(nIndents),
               pResObj->IsDeleted ? "True" : "False" );
        FreeMemory(pResObj);
    }
    return TRUE;
}

BOOL
Dump_BINDARG(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public BINDARG dump routine.  BINDARG is one of the parameters to
    DSA_DirBind().

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of BINDARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL    fSuccess = FALSE;
    BINDARG *pBind = NULL;
    BYTE    *pVal = NULL;

    Printf("%sBINDARG:\n", Indent(nIndents));
    nIndents++;

    if ( NULL != (pBind = (BINDARG *) ReadMemory(
                                            pvProcess,
                                            sizeof(BINDARG))) )
    {
        if ( NULL != (pVal = (BYTE *) ReadMemory(
                                            pBind->Versions.pVal,
                                            pBind->Versions.len)) )
        {
            Printf("%sVersions - length(0x%x)\n",
                   Indent(nIndents),
                   pBind->Versions.len);
            ShowBinaryData(nIndents + 1, pVal, pBind->Versions.len);

            Printf("%sCredentials @ %p\n",
                   Indent(nIndents),
                   pBind->pCredents);

            if ( NULL == pBind->pCredents )
            {
                fSuccess = TRUE;
            }
            else
            {
                fSuccess = Dump_DSNAME(nIndents + 1, pBind->pCredents);
            }

            FreeMemory(pVal);
        }

        FreeMemory(pBind);
    }

    return(fSuccess);
}

BOOL
Dump_BINDRES(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public BINDRES dump routine.  BINDRES is the return parameter from
    DSA_DirBind().

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of BINDRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    //
    // BINDRES is the same as a BINDARG.
    //

    Printf("%sBINDRES: (same as BINDARG)\n", Indent(nIndents));
    return(Dump_BINDARG(nIndents, pvProcess));
}

// aux data structures for error dumping (below)

//
// We want the following Table both in Free and Checked Build
//
typedef struct
{
    char* ErrStr;
    ULONG ErrNo;
}ERRINFOSTRUCT;


static ERRINFOSTRUCT ProblemTable[]=
{
{"NO_ATTRIBUTE_OR_VAL", PR_PROBLEM_NO_ATTRIBUTE_OR_VAL},
{"INVALID_ATT_SYNTAX", PR_PROBLEM_INVALID_ATT_SYNTAX },
{"UNDEFINED_ATT_TYPE", PR_PROBLEM_UNDEFINED_ATT_TYPE },
{"WRONG_MATCH_OPER", PR_PROBLEM_WRONG_MATCH_OPER},
{"CONSTRAINT_ATT_TYPE", PR_PROBLEM_CONSTRAINT_ATT_TYPE},
{"ATT_OR_VALUE_EXISTS", PR_PROBLEM_ATT_OR_VALUE_EXISTS},
{"NO_OBJECT", NA_PROBLEM_NO_OBJECT},
{"NO_OBJ_FOR_ALIAS", NA_PROBLEM_NO_OBJ_FOR_ALIAS },
{"BAD_ATT_SYNTAX", NA_PROBLEM_BAD_ATT_SYNTAX},
{"ALIAS_NOT_ALLOWED", NA_PROBLEM_ALIAS_NOT_ALLOWED},
{"NAMING_VIOLATION", NA_PROBLEM_NAMING_VIOLATION},
{"BAD_NAME", NA_PROBLEM_BAD_NAME},
{"INAPPROPRIATE_AUTH", SE_PROBLEM_INAPPROPRIATE_AUTH},
{"INVALID_CREDENTS", SE_PROBLEM_INVALID_CREDENTS},
{"INSUFF_ACCESS_RIGHTS", SE_PROBLEM_INSUFF_ACCESS_RIGHTS},
{"INVALID_SIGNATURE", SE_PROBLEM_INVALID_SIGNATURE},
{"PROTECTION_REQUIRED", SE_PROBLEM_PROTECTION_REQUIRED},
{"NO_INFORMATION", SE_PROBLEM_NO_INFORMATION},
{"BUSY", SV_PROBLEM_BUSY},
{"UNAVAILABLE", SV_PROBLEM_UNAVAILABLE},
{"WILL_NOT_PERFORM", SV_PROBLEM_WILL_NOT_PERFORM},
{"CHAINING_REQUIRED", SV_PROBLEM_CHAINING_REQUIRED},
{"UNABLE_TO_PROCEED", SV_PROBLEM_UNABLE_TO_PROCEED},
{"INVALID_REFERENCE", SV_PROBLEM_INVALID_REFERENCE},
{"TIME_EXCEEDED", SV_PROBLEM_TIME_EXCEEDED},
{"ADMIN_LIMIT_EXCEEDED", SV_PROBLEM_ADMIN_LIMIT_EXCEEDED},
{"LOOP_DETECTED", SV_PROBLEM_LOOP_DETECTED},
{"UNAVAIL_EXTENSION", SV_PROBLEM_UNAVAIL_EXTENSION},
{"OUT_OF_SCOPE", SV_PROBLEM_OUT_OF_SCOPE},
{"DIR_ERROR", SV_PROBLEM_DIR_ERROR},
{"NAME_VIOLATION", UP_PROBLEM_NAME_VIOLATION},
{"OBJ_CLASS_VIOLATION", UP_PROBLEM_OBJ_CLASS_VIOLATION},
{"CANT_ON_NON_LEAF", UP_PROBLEM_CANT_ON_NON_LEAF},
{"CANT_ON_RDN", UP_PROBLEM_CANT_ON_RDN},
{"ENTRY_EXISTS", UP_PROBLEM_ENTRY_EXISTS},
{"AFFECTS_MULT_DSAS", UP_PROBLEM_AFFECTS_MULT_DSAS},
{"CANT_MOD_OBJ_CLASS", UP_PROBLEM_CANT_MOD_OBJ_CLASS},
{"Huh?", 0}};


// Codes should be win32 error codes, defined in winerror.h
static ERRINFOSTRUCT CodeTable[]=
{
{"ADD_REPLICA_INHIBITED", ERROR_DS_ADD_REPLICA_INHIBITED},
{"ALIASED_OBJ_MISSING", ERROR_DS_ALIASED_OBJ_MISSING},
{"ALIAS_POINTS_TO_ALIAS", ERROR_DS_ALIAS_POINTS_TO_ALIAS},
{"ATTRIBUTE_OWNED_BY_SAM", ERROR_DS_ATTRIBUTE_OWNED_BY_SAM},
{"ATT_ALREADY_EXISTS", ERROR_DS_ATT_ALREADY_EXISTS},
{"ATT_IS_NOT_ON_OBJ", ERROR_DS_ATT_IS_NOT_ON_OBJ},
{"ATT_NOT_DEF_FOR_CLASS", ERROR_DS_ATT_NOT_DEF_FOR_CLASS},
{"ATT_NOT_DEF_IN_SCHEMA", ERROR_DS_ATT_NOT_DEF_IN_SCHEMA},
{"ATT_SCHEMA_REQ_ID", ERROR_DS_ATT_SCHEMA_REQ_ID},
{"ATT_SCHEMA_REQ_SYNTAX", ERROR_DS_ATT_SCHEMA_REQ_SYNTAX},
{"ATT_VAL_ALREADY_EXISTS", ERROR_DS_ATT_VAL_ALREADY_EXISTS},
{"AUX_CLS_TEST_FAIL", ERROR_DS_AUX_CLS_TEST_FAIL},
{"BAD_ATT_SCHEMA_SYNTAX", ERROR_DS_BAD_ATT_SCHEMA_SYNTAX},
{"BAD_ATT_SYNTAX", ERROR_DS_INVALID_ATTRIBUTE_SYNTAX},
{"BAD_HIERARCHY_FILE", ERROR_DS_BAD_HIERARCHY_FILE},
{"BAD_INSTANCE_TYPE", ERROR_DS_BAD_INSTANCE_TYPE},
{"BAD_NAME_SYNTAX", ERROR_DS_BAD_NAME_SYNTAX},
{"BAD_RDN_ATT_ID_SYNTAX", ERROR_DS_BAD_RDN_ATT_ID_SYNTAX},
{"BUILD_HIERARCHY_TABLE_FAILED", ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED},
{"CANT_ADD_ATT_VALUES", ERROR_DS_CANT_ADD_ATT_VALUES},
{"CANT_ADD_SYSTEM_ONLY", ERROR_DS_CANT_ADD_SYSTEM_ONLY},
{"CANT_CACHE_ATT", ERROR_DS_CANT_CACHE_ATT},
{"CANT_CACHE_CLASS", ERROR_DS_CANT_CACHE_CLASS},
{"CANT_DELETE", ERROR_DS_CANT_DELETE},
{"CANT_DELETE_DSA_OBJ", ERROR_DS_CANT_DELETE_DSA_OBJ},
{"CANT_DEL_MASTER_CROSSREF", ERROR_DS_CANT_DEL_MASTER_CROSSREF},
{"CANT_DEREF_ALIAS", ERROR_DS_CANT_DEREF_ALIAS},
{"CANT_FIND_DSA_OBJ", ERROR_DS_CANT_FIND_DSA_OBJ},
{"CANT_FIND_EXPECTED_NC", ERROR_DS_CANT_FIND_EXPECTED_NC},
{"CANT_FIND_NC_IN_CACHE", ERROR_DS_CANT_FIND_NC_IN_CACHE},
{"CANT_MIX_MASTER_AND_REPS", ERROR_DS_CANT_MIX_MASTER_AND_REPS},
{"CANT_MOD_SYSTEM_ONLY", ERROR_DS_CANT_MOD_SYSTEM_ONLY},
{"CANT_REMOVE_ATT_CACHE", ERROR_DS_CANT_REMOVE_ATT_CACHE},
{"CANT_REMOVE_CLASS_CACHE", ERROR_DS_CANT_REMOVE_CLASS_CACHE},
{"CANT_REM_MISSING_ATT", ERROR_DS_CANT_REM_MISSING_ATT},
{"CANT_REM_MISSING_ATT_VAL", ERROR_DS_CANT_REM_MISSING_ATT_VAL},
{"CANT_REPLACE_HIDDEN_REC", ERROR_DS_CANT_REPLACE_HIDDEN_REC},
{"CANT_RETRIEVE_CHILD", ERROR_DS_CANT_RETRIEVE_CHILD},
{"CANT_RETRIEVE_DN", ERROR_DS_CANT_RETRIEVE_DN},
{"CANT_RETRIEVE_INSTANCE", ERROR_DS_CANT_RETRIEVE_INSTANCE},
{"CHILDREN_EXIST", ERROR_DS_CHILDREN_EXIST},
{"CLASS_MUST_BE_CONCRETE", ERROR_DS_CLASS_MUST_BE_CONCRETE},
{"CLASS_NOT_DSA", ERROR_DS_CLASS_NOT_DSA},
{"CODE_INCONSISTENCY", ERROR_DS_CODE_INCONSISTENCY},
{"CONFIG_PARAM_MISSING", ERROR_DS_CONFIG_PARAM_MISSING},
{"COULDNT_CONTACT_FSMO", ERROR_DS_COULDNT_CONTACT_FSMO},
{"COUNTING_AB_INDICES_FAILED", ERROR_DS_COUNTING_AB_INDICES_FAILED},
{"CROSS_NC_DN_RENAME", ERROR_DS_CROSS_NC_DN_RENAME},
{"CROSS_REF_EXISTS", ERROR_DS_CROSS_REF_EXISTS},
{"DATABASE_ERROR", ERROR_DS_DATABASE_ERROR},
{"DRA_SCHEMA_MISMATCH", ERROR_DS_DRA_SCHEMA_MISMATCH},
{"DSA_MUST_BE_INT_MASTER", ERROR_DS_DSA_MUST_BE_INT_MASTER},
{"DUP_LDAP_DISPLAY_NAME", ERROR_DS_DUP_LDAP_DISPLAY_NAME},
{"DUP_MAPI_ID", ERROR_DS_DUP_MAPI_ID},
{"DUP_OID", ERROR_DS_DUP_OID},
{"DUP_RDN", ERROR_DS_DUP_RDN},
{"DUP_SCHEMA_ID_GUID", ERROR_DS_DUP_SCHEMA_ID_GUID},
{"EXISTS_IN_AUX_CLS", ERROR_DS_EXISTS_IN_AUX_CLS},
{"EXISTS_IN_MAY_HAVE", ERROR_DS_EXISTS_IN_MAY_HAVE},
{"EXISTS_IN_MUST_HAVE", ERROR_DS_EXISTS_IN_MUST_HAVE},
{"EXISTS_IN_POSS_SUP", ERROR_DS_EXISTS_IN_POSS_SUP},
{"EXISTS_IN_SUB_CLS", ERROR_DS_EXISTS_IN_SUB_CLS},
{"GCVERIFY_ERROR", ERROR_DS_GCVERIFY_ERROR},
{"GENERIC_ERROR", ERROR_DS_GENERIC_ERROR},
{"GOVERNSID_MISSING", ERROR_DS_GOVERNSID_MISSING},
{"HIERARCHY_TABLE_MALLOC_FAILED", ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED},
{"ILLEGAL_MOD_OPERATION", ERROR_DS_ILLEGAL_MOD_OPERATION},
{"ILLEGAL_SUPERIOR", ERROR_DS_ILLEGAL_SUPERIOR},
{"INSUFF_ACCESS_RIGHTS", ERROR_DS_INSUFF_ACCESS_RIGHTS},
{"INTERNAL_FAILURE", ERROR_DS_INTERNAL_FAILURE},
{"INVALID_DMD", ERROR_DS_INVALID_DMD},
{"INVALID_ROLE_OWNER", ERROR_DS_INVALID_ROLE_OWNER},
{"MASTERDSA_REQUIRED", ERROR_DS_MASTERDSA_REQUIRED},
{"MAX_OBJ_SIZE_EXCEEDED", ERROR_DS_MAX_OBJ_SIZE_EXCEEDED},
{"MISSING_EXPECTED_ATT", ERROR_DS_MISSING_EXPECTED_ATT},
{"MISSING_REQUIRED_ATT", ERROR_DS_MISSING_REQUIRED_ATT},
{"MISSING_SUPREF", ERROR_DS_MISSING_SUPREF},
{"NAME_REFERENCE_INVALID", ERROR_DS_NAME_REFERENCE_INVALID},
{"NAME_TOO_LONG", ERROR_DS_NAME_TOO_LONG},
{"NAME_TOO_MANY_PARTS", ERROR_DS_NAME_TOO_MANY_PARTS},
{"NAME_TYPE_UNKNOWN", ERROR_DS_NAME_TYPE_UNKNOWN},
{"NAME_UNPARSEABLE", ERROR_DS_NAME_UNPARSEABLE},
{"NAME_VALUE_TOO_LONG", ERROR_DS_NAME_VALUE_TOO_LONG},
{"NCNAME_MISSING_CR_REF", ERROR_DS_NCNAME_MISSING_CR_REF},
{"NCNAME_MUST_BE_NC", ERROR_DS_NCNAME_MUST_BE_NC},
{"NONEXISTENT_MAY_HAVE", ERROR_DS_NONEXISTENT_MAY_HAVE},
{"NONEXISTENT_MUST_HAVE", ERROR_DS_NONEXISTENT_MUST_HAVE},
{"NONEXISTENT_POSS_SUP", ERROR_DS_NONEXISTENT_POSS_SUP},
{"NOTIFY_FILTER_TOO_COMPLEX", ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX},
{"NOT_AN_OBJECT", ERROR_DS_NOT_AN_OBJECT},
{"NOT_ON_BACKLINK", ERROR_DS_NOT_ON_BACKLINK},
{"NO_CHAINED_EVAL", ERROR_DS_NO_CHAINED_EVAL},
{"NO_CHAINING", ERROR_DS_NO_CHAINING},
{"NO_CROSSREF_FOR_NC", ERROR_DS_NO_CROSSREF_FOR_NC},
{"NO_DELETED_NAME", ERROR_DS_NO_DELETED_NAME},
{"NO_PARENT_OBJECT", ERROR_DS_NO_PARENT_OBJECT},
{"NO_RDN_DEFINED_IN_SCHEMA", ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA},
{"NO_REQUESTED_ATTS_FOUND", ERROR_DS_NO_REQUESTED_ATTS_FOUND},
{"OBJECT_CLASS_REQUIRED", ERROR_DS_OBJECT_CLASS_REQUIRED},
{"OBJ_CLASS_NOT_DEFINED", ERROR_DS_OBJ_CLASS_NOT_DEFINED},
{"OBJ_CLASS_NOT_SUBCLASS", ERROR_DS_OBJ_CLASS_NOT_SUBCLASS},
{"OBJ_GUID_EXISTS", ERROR_DS_OBJ_GUID_EXISTS},
{"OBJ_NOT_FOUND", ERROR_DS_OBJ_NOT_FOUND},
{"OBJ_STRING_NAME_EXISTS", ERROR_DS_OBJ_STRING_NAME_EXISTS},
{"OBJ_TOO_LARGE", ERROR_DS_OBJ_TOO_LARGE},
{"OUT_OF_SCOPE", ERROR_DS_OUT_OF_SCOPE},
{"PARENT_IS_AN_ALIAS", ERROR_DS_PARENT_IS_AN_ALIAS},
{"RANGE_CONSTRAINT", ERROR_DS_RANGE_CONSTRAINT},
{"RDN_DOESNT_MATCH_SCHEMA", ERROR_DS_RDN_DOESNT_MATCH_SCHEMA},
{"RECALCSCHEMA_FAILED", ERROR_DS_RECALCSCHEMA_FAILED},
{"REFERRAL", ERROR_DS_REFERRAL},
{"REPLICATOR_ONLY", ERROR_DS_REPLICATOR_ONLY},
{"ROOT_CANT_BE_SUBREF", ERROR_DS_ROOT_CANT_BE_SUBREF},
{"ROOT_MUST_BE_NC", ERROR_DS_ROOT_MUST_BE_NC},
{"ROOT_REQUIRES_CLASS_TOP", ERROR_DS_ROOT_REQUIRES_CLASS_TOP},
{"SCHEMA_ALLOC_FAILED", ERROR_DS_SCHEMA_ALLOC_FAILED},
{"SCHEMA_NOT_LOADED", ERROR_DS_SCHEMA_NOT_LOADED},
{"SECURITY_CHECKING_ERROR", ERROR_DS_SECURITY_CHECKING_ERROR},
{"SECURITY_ILLEGAL_MODIFY", ERROR_DS_SECURITY_ILLEGAL_MODIFY},
{"SEC_DESC_INVALID", ERROR_DS_SEC_DESC_INVALID},
{"SEC_DESC_TOO_SHORT", ERROR_DS_SEC_DESC_TOO_SHORT},
{"SEMANTIC_ATT_TEST", ERROR_DS_SEMANTIC_ATT_TEST},
{"SHUTTING_DOWN", ERROR_DS_SHUTTING_DOWN},
{"SINGLE_VALUE_CONSTRAINT", ERROR_DS_SINGLE_VALUE_CONSTRAINT},
{"SUBREF_MUST_HAVE_PARENT", ERROR_DS_SUBREF_MUST_HAVE_PARENT},
{"SUBTREE_NOTIFY_NOT_NC_HEAD", ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD},
{"SUB_CLS_TEST_FAIL", ERROR_DS_SUB_CLS_TEST_FAIL},
{"SYNTAX_MISMATCH", ERROR_DS_SYNTAX_MISMATCH},
{"TREE_DELETE_NOT_FINISHED", ERROR_DS_TREE_DELETE_NOT_FINISHED},
{"UNKNOWN_ERROR", ERROR_DS_UNKNOWN_ERROR},
{"UNKNOWN_OPERATION", ERROR_DS_UNKNOWN_OPERATION},
{"USER_BUFFER_TO_SMALL", ERROR_DS_USER_BUFFER_TO_SMALL},
{"Undefined error (look in winerror.h)", 0}};


char * GetProblemString(USHORT problem)
{
    ERRINFOSTRUCT * pEI = ProblemTable;

    while (pEI->ErrNo != problem && pEI->ErrNo)
      ++pEI;

    return pEI->ErrStr;
}

char * GetCodeString(ULONG code)
{
    ERRINFOSTRUCT * pEI = CodeTable;

    while (pEI->ErrNo != code && pEI->ErrNo)
      ++pEI;

    return pEI->ErrStr;
}


void
Dump_Error(IN DWORD nIndents,
           IN DWORD errCode,
           IN PVOID pErrInfoProcess)
/*++
 *
 * Routine description: helper for Dump_THSTATE
 *
 */
{
    DIRERR * pErrInfo;
    PROBLEMLIST *pplProcess, *ppl;
    DSA_ADDRESS_LIST *pdal, *pdalProcess;
    WCHAR *pw;
    unsigned long u, size;

    if (NULL == (pErrInfo = ReadMemory(pErrInfoProcess, sizeof(DIRERR)))) {
        return;
    }

    Printf("%spErrInfo    @ %p\n", Indent(nIndents), pErrInfoProcess);
    nIndents++;
    switch (errCode) {
      case 0:
        /* no error */
        break;

      case attributeError:
        Printf("%sAttribute error with %u attribute problems, DSID-%08X:\n",
               Indent(nIndents),
               pErrInfo->AtrErr.count,
               pErrInfo->AtrErr.FirstProblem.intprob.dsid);
        Printf("%s%u: att %x problem %u (%s) code %d (%s)\n",
               Indent(nIndents+1),
               0,
               pErrInfo->AtrErr.FirstProblem.intprob.type,
               pErrInfo->AtrErr.FirstProblem.intprob.problem,
               GetProblemString(pErrInfo->AtrErr.FirstProblem.intprob.problem),
               pErrInfo->AtrErr.FirstProblem.intprob.extendedErr,
               GetCodeString(pErrInfo->AtrErr.FirstProblem.intprob.extendedErr));
        ppl =  &pErrInfo->AtrErr.FirstProblem;
        pplProcess = ppl->pNextProblem;
        for (u=1; u<pErrInfo->AtrErr.count; u++) {
            ppl = ReadMemory(pplProcess, sizeof(PROBLEMLIST));
            if (ppl) {
                Printf("%s%u: att %x problem %u (%s) code %d (%s)\n",
                       Indent(nIndents+1),
                       u,
                       ppl->intprob.type,
                       ppl->intprob.problem,
                       GetProblemString(ppl->intprob.problem),
                       ppl->intprob.extendedErr,
                       GetCodeString(ppl->intprob.extendedErr));
                FreeMemory(ppl);
            }
        }
        break;

      case nameError:
        Printf("%sName Error with problem %u (%s), code %d (%s), DSID %08X\n",
               Indent(nIndents),
               pErrInfo->NamErr.problem,
               GetProblemString(pErrInfo->NamErr.problem),
               pErrInfo->NamErr.extendedErr,
               GetCodeString(pErrInfo->NamErr.extendedErr),
               pErrInfo->NamErr.dsid);
        break;

      case updError:
        Printf("%sUpdate Error with problem %u (%s), code %d (%s), and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->UpdErr.problem,
               GetProblemString(pErrInfo->UpdErr.problem),
               pErrInfo->UpdErr.extendedErr,
               GetCodeString(pErrInfo->UpdErr.extendedErr),
               pErrInfo->UpdErr.dsid);
        break;

      case systemError:
        // Note that problems are from a different space
        Printf("%sSystem Error with problem %u (%s), code %d (%s), and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->UpdErr.problem,
               strerror(pErrInfo->UpdErr.problem),
               pErrInfo->UpdErr.extendedErr,
               GetCodeString(pErrInfo->UpdErr.extendedErr),
               pErrInfo->UpdErr.dsid);
        break;

      case referralError:
        Printf("%sReferral with code %d (%s) and %u access points, DSID %08X\n",
               Indent(nIndents),
               pErrInfo->RefErr.extendedErr,
               GetCodeString(pErrInfo->RefErr.extendedErr),
               pErrInfo->RefErr.Refer.count,
               pErrInfo->RefErr.dsid);

        pdalProcess = pErrInfo->RefErr.Refer.pDAL;
        while (pdalProcess) {
            pdal = ReadMemory(pdalProcess, sizeof(DSA_ADDRESS_LIST));
            if (!pdal) {
                pdalProcess = NULL;
                break;
            }
            pw = ReadMemory(pdal->Address.Buffer, pdal->Address.Length + 2);
            if (pw) {
                // Our string isn't null terminated, so we
                // over-fetch by two bytes and then blast the extra
                // to null.  This is in the debugger (not debuggee)
                // space, so it's ok.  What if the page ended less
                // than two bytes after the end of the string? Well,
                // then the ReadMemory should have failed.
                pw[pdal->Address.Length/2] = L'\0';
                Printf("%sAP: %S\n",
                       Indent(nIndents+1),
                       pw);
                FreeMemory(pw);
            }
            pdalProcess = pdal->pNextAddress;
            FreeMemory(pdal);
        }
        break;

      case securityError:
        Printf("%sSecurity Error with problem %u (%s), code %d (%s) and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->SecErr.problem,
               GetProblemString(pErrInfo->SecErr.problem),
               pErrInfo->SecErr.extendedErr,
               GetCodeString(pErrInfo->SecErr.extendedErr),
               pErrInfo->SecErr.dsid);
        break;

      case serviceError:
        Printf("%sService Error with problem %u (%s), code %d (%s) and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->SvcErr.problem,
               GetProblemString(pErrInfo->SvcErr.problem),
               pErrInfo->SvcErr.extendedErr,
               GetCodeString(pErrInfo->SvcErr.extendedErr),
               pErrInfo->SvcErr.dsid);
        break;

      default:
        Printf("%sUnknown error code of %u\n",
               Indent(nIndents),
               errCode);
        break;
    }
    nIndents--;

    FreeMemory(pErrInfo);
}

void
Dump_CommRes(IN DWORD nIndents,
             IN PVOID pCommResProcess)
/*++
 *
 * Routine description: helper for Dump_XxxRes routines
 *
 */
{
    COMMRES * pCommRes;

    Printf( "%sCOMMRES:\n", Indent(nIndents) );
    nIndents++;

    if (NULL == (pCommRes = ReadMemory(pCommResProcess, sizeof(COMMRES)))) {
        return;
    }

    Printf("%sAlias dereferenced: %s\n",
           Indent(nIndents),
           pCommRes->aliasDeref ? "yes": "no");

    Dump_Error(nIndents,
               pCommRes->errCode,
               (BYTE *) pCommResProcess + offsetof( COMMRES, pErrInfo )
        );

    FreeMemory(pCommRes);
}

void
DumpZone(IN MEMZONE *pZone,
         IN DWORD nIndents)
{
    if (pZone->Base) {
        Printf("%sZone Base        @ %p  (zone end at @ %p)\n",
               Indent(nIndents),
               pZone->Base,
               pZone->Base + ZONETOTALSIZE);
        Printf("%sZone Current     @ %p\n",
               Indent(nIndents),
               pZone->Cur);
        if (pZone->Full) {
            Printf("%sZone is full (all %d blocks used)\n",
                   Indent(nIndents),
                   ZONETOTALSIZE / ZONEBLOCKSIZE);
        }
        else {
            Printf("%sZone has used %d of %d available blocks \n",
                   Indent(nIndents),
                   (pZone->Cur - pZone->Base) / ZONEBLOCKSIZE,
                   ZONETOTALSIZE / ZONEBLOCKSIZE);
        }
    }
    else {
        Printf("%sNo zone present\n",
               Indent(nIndents));
    }
}

BOOL
Dump_THSTATE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public THSTATE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of THSTATE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    THSTATE *pState = NULL;
    DWORD   cBytes;
    CHAR    szTime[ SZDSTIME_LEN ];
    CHAR    szUuid[ 40 ];
    DWORD   cTickNow = GetTickCount();
    DSTIME  dsTimeNow = GetSecondsSince1601();
    DSTIME  dsTimeTransStarted;
    char *pStrTmp;
    PAUTHZ_CLIENT_CONTEXT pAuthzCC;
    PAUTHZ_CLIENT_CONTEXT_INFO pAuthzContextInfo;

    Printf("%sTHSTATE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    //
    // THSTATE has some DBG-only fields at the end.  Always read the
    // non-DBG amount of memory since the process being debugged may
    // not be a DBG version although the extensions DLL is.  Although
    // we tried doing that by taking the offset of the last non-DBG-only
    // field, that didn't work because people added new fields and forgot
    // to update this count.  We can't just use the offset of the first
    // DBG only field, because that would break in a non-DBG build!
    // Hence, the revolting solution below:

#if DBG
    cBytes = OFFSET(THSTATE, Size) + sizeof(DWORD);
#else
    cBytes = sizeof(THSTATE);
#endif

    if ( NULL == (pState = ReadMemory(pvProcess, cBytes)) )

    {
        return(FALSE);
    }

    Printf("%shThread              0x%x\n",
           Indent(nIndents),
           pState->hThread);
    Printf("%shHeap                0x%x\n",
           Indent(nIndents),
           pState->hHeap);
    Printf("%scAllocs              0x%x\n",
           Indent(nIndents),
           pState->cAllocs);
    DumpZone(&pState->Zone,
             nIndents + 1);
    Printf("%sdwClientID           0x%x\n",
           Indent(nIndents),
           pState->dwClientID);
    Printf("%serrCode              0x%x\n",
           Indent(nIndents),
           pState->errCode);
    if (pState->errCode) {
        Dump_Error(nIndents,
                   pState->errCode,
                   pState->pErrInfo);
    }
    Printf("%spDB                @ %p\n",
           Indent(nIndents),
           pState->pDB);

    Printf("%sJetCache:\n", Indent(nIndents));
    ++nIndents;
    Printf("%stransLevel            %d\n",
           Indent(nIndents),
           pState->JetCache.transLevel);

    dsTimeTransStarted
        = dsTimeNow
          - (cTickNow - pState->JetCache.cTickTransLevel1Started) / 1000;
    Printf("%scTickTransLevel1Started %u (== %s)\n",
           Indent(nIndents),
           pState->JetCache.cTickTransLevel1Started,
           DSTimeToDisplayString(dsTimeTransStarted, szTime));

    Printf("%sSessionID            0x%x\n",
           Indent(nIndents),
           pState->JetCache.sesid);
    Printf("%sDataBaseID           0x%x\n",
           Indent(nIndents),
           pState->JetCache.dbid);
    Printf("%sObjTable             0x%x\n",
           Indent(nIndents),
           pState->JetCache.objtbl);
    Printf("%sSearchTbl            0x%x\n",
           Indent(nIndents),
           pState->JetCache.searchtbl);
    Printf("%sLinkTbl              0x%x\n",
           Indent(nIndents),
           pState->JetCache.linktbl);
    Printf("%sSDPropTbl            0x%x\n",
           Indent(nIndents),
           pState->JetCache.sdproptbl);
    Printf("%sSDTbl                0x%x\n",
           Indent(nIndents),
           pState->JetCache.sdtbl);
    Printf("%sTablesInUse?         %s\n",
           Indent(nIndents),
           pState->JetCache.tablesInUse ? "true": "false");
    Printf("%stransactionalDataPtr @%p\n",
           Indent(nIndents),
           pState->JetCache.dataPtr);
    --nIndents;

    // The goofy dump value is because the local DN read cache is an array
    // embedded inside the thstate, and we need to dump its base address
    // in the process space, not in debugger space.
    Printf("%sLocalDNReadCache        @ %p\n",
           Indent(nIndents),
           ((PBYTE)(&pState->LocalDNReadCache) - (PBYTE)pState)
           + (PBYTE)pvProcess);

    Printf("%sGlobalDNReadCache        @ %p\n",
           Indent(nIndents),
           pState->Global_DNReadCache);

    //BITFIELD BLOCK

    Printf("%stransType                 %s\n",
           Indent(nIndents),
           (pState->transType == SYNC_READ_ONLY)
               ? "SYNC_READ_ONLY"
               : (pState->transType == SYNC_WRITE)
                   ? "SYNC_WRITE"
                   : "!!! Unknown !!!");
    Printf("%stransControl              %s\n",
           Indent(nIndents),
           (pState->transControl == TRANSACT_BEGIN_END)
               ? "TRANSACT_BEGIN_END"
               : (pState->transControl == TRANSACT_DONT_BEGIN_END)
                   ? "TRANSACT_DONT_BEGIN_END"
                   : (pState->transControl == TRANSACT_BEGIN_DONT_END)
                       ? "TRANSACT_BEGIN_DONT_END"
                       : (pState->transControl == TRANSACT_DONT_BEGIN_DONT_END)
                           ? "TRANSACT_DONT_BEGIN_DONT_END"
                           : "!!! Unknown !!!");

    // Start dumping the thstate bit field:
    Printf("%sDumping the THSTATE bitfield bits (only printed bit if TRUE):\n", Indent(nIndents));
    nIndents++;
    { // Just for indentational clarity of printing
#define DUMP_THSTATE_BITFIELD_BIT(fStr, fBit)   if (pState->fBit) { Printf("%s" fStr "\n", Indent(nIndents), 1 & pState->fBit); }

        DUMP_THSTATE_BITFIELD_BIT("fSyncSet", fSyncSet);

        DUMP_THSTATE_BITFIELD_BIT("fCatalogCacheTouched", fCatalogCacheTouched);

        DUMP_THSTATE_BITFIELD_BIT("fRebuildCatalogOnCommit", fRebuildCatalogOnCommit);

        DUMP_THSTATE_BITFIELD_BIT("fSDP", fSDP);

        DUMP_THSTATE_BITFIELD_BIT("fDRA", fDRA);

        DUMP_THSTATE_BITFIELD_BIT("fEOF", fEOF);

        DUMP_THSTATE_BITFIELD_BIT("fLazyCommit", fLazyCommit);

        DUMP_THSTATE_BITFIELD_BIT("fDSA", fDSA);

        DUMP_THSTATE_BITFIELD_BIT("fSAM", fSAM);

        DUMP_THSTATE_BITFIELD_BIT("fSamDoCommit", fSamDoCommit);

        DUMP_THSTATE_BITFIELD_BIT("fSamWriteLockHeld", fSamWriteLockHeld);

        DUMP_THSTATE_BITFIELD_BIT("UpdateDITStructure", UpdateDITStructure);

        DUMP_THSTATE_BITFIELD_BIT("RecalcSchemaNow", RecalcSchemaNow);

        DUMP_THSTATE_BITFIELD_BIT("fLsa", fLsa);

        DUMP_THSTATE_BITFIELD_BIT("fAccessChecksCompleted", fAccessChecksCompleted);

        DUMP_THSTATE_BITFIELD_BIT("fGCLocalCleanup", fGCLocalCleanup);

        DUMP_THSTATE_BITFIELD_BIT("fDidInvalidate", fDidInvalidate);

        DUMP_THSTATE_BITFIELD_BIT("fBeginDontEndHoldsSamLock", fBeginDontEndHoldsSamLock);

        DUMP_THSTATE_BITFIELD_BIT("fCrossDomainMove", fCrossDomainMove);

        DUMP_THSTATE_BITFIELD_BIT("fNlSubnetNotify", fNlSubnetNotify);

        DUMP_THSTATE_BITFIELD_BIT("fNlSiteObjNotify", fNlSiteObjNotify);

        DUMP_THSTATE_BITFIELD_BIT("fNlSiteNotify", fNlSiteNotify);

        DUMP_THSTATE_BITFIELD_BIT("fDefaultLcid", fDefaultLcid);

        DUMP_THSTATE_BITFIELD_BIT("fPhantomDaemon", fPhantomDaemon);

        DUMP_THSTATE_BITFIELD_BIT("fAnchorInvalidated", fAnchorInvalidated);

        DUMP_THSTATE_BITFIELD_BIT("fSchemaConflict", fSchemaConflict);

        DUMP_THSTATE_BITFIELD_BIT("fExecuteKccOnCommit", fExecuteKccOnCommit);

        DUMP_THSTATE_BITFIELD_BIT("fLinkedValueReplication", fLinkedValueReplication);

        DUMP_THSTATE_BITFIELD_BIT("fNlDnsRootAliasNotify", fNlDnsRootAliasNotify);
        
        DUMP_THSTATE_BITFIELD_BIT("fSingleUserModeThread", fSingleUserModeThread);
          
        DUMP_THSTATE_BITFIELD_BIT("fDeletingTree", fDeletingTree);

        DUMP_THSTATE_BITFIELD_BIT("fBehaviorVersionUpdate", fBehaviorVersionUpdate);

        DUMP_THSTATE_BITFIELD_BIT("fIsValidLongRunningTask", fIsValidLongRunningTask);

    }
    nIndents--;       
    //END BITFIELD BLOCK

    Printf("%spSamNotificationTail @ %p\n",
           Indent(nIndents),
           pState->pSamNotificationTail);
    Printf("%spSamNotificationHead @ %p\n",
           Indent(nIndents),
           pState->pSamNotificationHead);
    Printf("%spSamAuditNotificationTail @ %p\n",
           Indent(nIndents),
           pState->pSamAuditNotificationTail);
    Printf("%spSamAuditNotificationHead @ %p\n",
           Indent(nIndents),
           pState->pSamAuditNotificationHead);
    Printf("%sUnCommUsn            %I64d\n",
           Indent(nIndents),
           pState->UnCommUsn);
    Printf("%shHeapOrg             0x%x\n",
           Indent(nIndents),
           pState->hHeapOrg);
    Printf("%scAllocsOrg           0x%x\n",
           Indent(nIndents),
           pState->cAllocsOrg);
    DumpZone(&pState->ZoneOrg,
             nIndents + 1);
    Printf("%spSpareTHS          @ %p\n",
           Indent(nIndents),
           pState->pSpareTHS);
    Printf("%sdwLcid               0x%x\n",
           Indent(nIndents),
           pState->dwLcid);
    Printf("%sCipherStrength       %d bits\n",
           Indent(nIndents),
           pState->CipherStrength);
    Printf("%spSamLoopbak        @ %p\n",
           Indent(nIndents),
           pState->pSamLoopback);
    Printf("%sSessionKeyLength     0x%x\n",
           Indent(nIndents),
           pState->SessionKey.SessionKeyLength);
    Printf("%sSessionKey         @ %p\n",
           Indent(nIndents),
           pState->SessionKey.SessionKey);

    Printf("%spAuthzCC           @ %p\n",
           Indent(nIndents),
           pState->pAuthzCC);
    if (pState->pAuthzCC != NULL) {
        if ( NULL == (pAuthzCC = ReadMemory(pState->pAuthzCC, sizeof(AUTHZ_CLIENT_CONTEXT))) ) {
            Printf("%sError reading pAuthzCC data\n", Indent(nIndents));
            return(FALSE);
        }
        Printf("%sAuthzContextInfo   @ %p\n",
               Indent(nIndents+1),
               pAuthzCC->pAuthzContextInfo);
        if ( NULL != pAuthzCC->pAuthzContextInfo ) {
            if ( NULL == (pAuthzContextInfo = ReadMemory(pAuthzCC->pAuthzContextInfo, sizeof(AUTHZ_CLIENT_CONTEXT_INFO))) ) {
                Printf("%sError reading pAuthzContextInfo data\n", Indent(nIndents+1));
                return(FALSE);
            }
            Printf("%sAuthzContextHandle @ %p\n",
                   Indent(nIndents+2),
                   pAuthzContextInfo->hAuthzContext);
            Printf("%sEffectiveQuotaList @ %p\n",
                   Indent(nIndents+2),
                   pAuthzContextInfo->pEffectiveQuota);
        }
        Printf("%srefCount             %d\n",
               Indent(nIndents+1),
               pAuthzCC->lRefCount);
    }
    Printf("%shAuthzAuditInfo          %p\n",
           Indent(nIndents),
           pState->hAuthzAuditInfo);

    Printf("%sSearchEntriesReturned      %d\n",
           Indent(nIndents),
           pState->searchLogging.SearchEntriesReturned);

    Printf("%sSearchEntriesVisited       %d\n",
           Indent(nIndents),
           pState->searchLogging.SearchEntriesVisited);

    Printf("%sFilter Used               @ %p\n",
       Indent(nIndents),
       pState->searchLogging.pszFilter);

    Printf("%sIndexes Used             @ %p\n",
           Indent(nIndents),
           pState->searchLogging.pszIndexes);

    if ( NULL != pState->pSamLoopback)
    {
        Dump_SAMP_LOOPBACK_ARG(nIndents, pState->pSamLoopback);
    }

    Printf("%spSamSearchInformation @ %p\n",
           Indent(nIndents),
           pState->pSamSearchInformation);
    Printf("%sNTDSErrorFlag        0x%1.1x\n",
           Indent(nIndents),
           1 & pState->NTDSErrorFlag);
    Printf("%sphSecurityContext  @ %p\n",
           Indent(nIndents),
           pState->phSecurityContext);
    Printf("%simpState             0x%x\n",
       Indent(nIndents),
       pState->impState);
    Printf("%spCtxtHandle        @ %p\n",
           Indent(nIndents),
           pState->pCtxtHandle);
    Printf("%simpState             %s\n",
           Indent(nIndents),
           ((ImpersonateNone == pState->impState)
            ? "ImpersonateNone"
            : ((ImpersonateRpcClient == pState->impState)
                ? "ImpersonateRpcClient"
                : ((ImpersonateNullSession == pState->impState)
                    ? "ImpersonateNullSession"
                    : ((ImpersonateSspClient == pState->impState)
                        ? "ImpersonateSspClient"
                        : ((ImpersonateDelegatedClient == pState->impState)
                            ? "ImpersonateDelegatedClient"
                            : "*** bad impState ***"))))) );
    Printf("%sulTickCreated        0x%x\n",
           Indent(nIndents),
           pState->ulTickCreated);

    {
        FILETIME localft;
        SYSTEMTIME st;

        FileTimeToLocalFileTime(&pState->TimeCreated,
                                &localft);

        FileTimeToSystemTime(&localft,&st);

        Printf("%sTimeCreated          (Hi 0x%08x Lo 0x%08x) %04d-%02d-%02d %02d:%02d.%02d\n",
               Indent(nIndents),
               pState->TimeCreated.dwHighDateTime,
               pState->TimeCreated.dwLowDateTime,
               st.wYear % 10000,
               st.wMonth,
               st.wDay,
               st.wHour,
               st.wMinute,
               st.wSecond);
    }

    Printf("%sCurrSchemaPtr      @ %p\n",
           Indent(nIndents),
           pState->CurrSchemaPtr);
    Printf("%sNewPrefix          @ %p\n",
           Indent(nIndents),
           pState->NewPrefix);
    Printf("%scNewPrefix           0x%x\n",
       Indent(nIndents),
       pState->cNewPrefix);
    Printf("%sGCVerifyCache      @ %p\n",
           Indent(nIndents),
           pState->GCVerifyCache);
    Printf("%spextRemote         @ %p\n",
           Indent(nIndents),
           pState->pextRemote);
    Printf("%sopendbcount          0x%x\n",
           Indent(nIndents),
           pState->opendbcount);
    Printf("%spNotifyNCs         @ %p\n",
           Indent(nIndents),
           pState->pNotifyNCs);
    // This switch should match the CALLERTYPE enum in ntdsa.h
    switch (pState->CallerType) {
      case CALLERTYPE_NONE:  pStrTmp = "NONE"; break;
      case CALLERTYPE_SAM:   pStrTmp = "SAM";  break;
      case CALLERTYPE_DRA:   pStrTmp = "DRA";  break;
      case CALLERTYPE_LDAP:  pStrTmp = "LDAP"; break;
      case CALLERTYPE_LSA:   pStrTmp = "LSA";  break;
      case CALLERTYPE_KCC:   pStrTmp = "KCC";  break;
      case CALLERTYPE_NSPI:  pStrTmp = "NSPI"; break;
      case CALLERTYPE_INTERNAL:  pStrTmp = "Internal"; break;
      case CALLERTYPE_NTDSAPI:  pStrTmp = "NTDSAPI"; break;
      default:  pStrTmp = "unknown"; break;
    }
    Printf("%sCallerType           %d (%s)\n",
           Indent(nIndents),
           pState->CallerType,
           pStrTmp);
    Printf("%sClient IP address    0x%x\n",
           Indent(nIndents),
           pState->ClientIP);
    Printf("%sdsidOrigin           0x%x\n",
           Indent(nIndents),
           pState->dsidOrigin);

    Printf("%sInvocationID         %s\n",
           Indent(nIndents),
           DsUuidToStructuredString(&pState->InvocationID, szUuid));

#if DBG
    Printf("%sSize                 %d\n",
           Indent(nIndents),
           pState->Size);
    Printf("%sSizeOrg              0x%x\n",
           Indent(nIndents),
           pState->SizeOrg);
    Printf("%sTotaldbpos           %d\n",
           Indent(nIndents),
           pState->Totaldbpos);
    Printf("%spDBList[]            @ %p\n",
           Indent(nIndents),
           pState->pDBList);
#endif

    FreeMemory(pState);
    return(TRUE);
}

BOOL
Dump_SAMP_LOOPBACK_ARG(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SAMP_LOOPBACK_ARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SAMP_LOOPBACK_ARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    SAMP_LOOPBACK_ARG   *pArg = NULL;
    SAMP_CALL_MAPPING   *rMap = NULL;
    ULONG               i;

    Printf("%sSAM_LOOPBACK_ARG @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pArg = ReadMemory(pvProcess, sizeof(SAMP_LOOPBACK_ARG))) )
    {
        Printf("Error reading memory at %p\n", pvProcess);
        return(FALSE);
    }

    Printf("%stype:             ", Indent(nIndents));

    switch ( pArg->type )
    {
    case LoopbackAdd:

        Printf("LoopbackAdd\n");
        break;

    case LoopbackModify:

        Printf("LoopbackModify\n");
        break;

    case LoopbackRemove:

        Printf("LoopbackRemove\n");
        break;

    default:

        Printf("Unknown - 0x%x\n", pArg->type);
        break;
    }

    if ( NULL != pArg->pObject )
    {
        Dump_DSNAME(nIndents, pArg->pObject);
    }

    Printf("%scCallMap:         0x%d\n", Indent(nIndents), pArg->cCallMap);
    Printf("%srCallMap:       @ %p\n", Indent(nIndents), pArg->cCallMap);

    if ( NULL != pArg->rCallMap )
    {
        if ( NULL == (rMap = ReadMemory(
                                pArg->rCallMap,
                                pArg->cCallMap * sizeof(SAMP_CALL_MAPPING))) )
        {
            Printf("Error reading memory at %p\n", pArg->rCallMap);
        }
        else
        {
            for ( i = 0; i < pArg->cCallMap; i++ )
            {
                Printf("%sfSamWriteRequired:    %x\n",
                       Indent(nIndents+1),
                       rMap[i].fSamWriteRequired);
                Printf("%sfIgnore:  %x\n",
                       Indent(nIndents+1),
                       rMap[i].fIgnore);
                Printf("%siAttr:    %x\n",
                       Indent(nIndents+1),
                       rMap[i].iAttr);
                Printf("%schoice:               %s\n",
                       Indent(nIndents+1),
                       rMap[i].choice == 'A'
                         ? "AT_CHOICE_ADD_ATT"
                         : rMap[i].choice == 'R'
                           ? "AT_CHOICE_REMOVE_ATT"
                           : rMap[i].choice == 'a'
                             ? "AT_CHOICE_ADD_VALUES"
                             : rMap[i].choice == 'r'
                               ? "AT_CHOICE_REMOVE_VALUES"
                               : rMap[i].choice == 'C'
                                 ? "AT_CHOICE_REPLACE_ATT"
                                 : "Unknown choice");
                Printf("%sAttr type:            0x%x\n",
                       Indent(nIndents),
                       rMap[i].attr.attrTyp);
                Printf("%sAttr value len:       0x%x\n",
                       Indent(nIndents),
                       rMap[i].attr.AttrVal.valCount);
                Printf("%sAttr value at:       %p\n",
                       Indent(nIndents),
                       rMap[i].attr.AttrVal.pAVal);
                Printf("%sAttCache:    %x\n",
                       Indent(nIndents),
                       rMap[i].pAC);
            }

            FreeMemory(rMap);
        }
    }

    FreeMemory(pArg);
    return(TRUE);
}

BOOL
Dump_DSA_ANCHOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DSA_ANCHOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSA_ANCHOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    DSA_ANCHOR          *pAnchor = NULL;
    CROSS_REF_LIST      *pCRList, *pCRListTmp;
    SUBREF_LIST         *pSRList, *pSRListTmp;
    DWORD               nTmp;
    DWORD               *pDNTs;
    ULONG               i;
    ULONG               cDomainSubrefList;
    ULONG *             pcbSidSize = NULL;
    PSID                pSidTmp = NULL;
    COUNTED_LIST *      pNoGCSearchList = NULL;
    DWORD *             paNonGCNcsDNTs = NULL;
    DWORD               dwPrevDNT = 0;

    Printf("%sDSA_ANCHOR @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pAnchor = ReadMemory(pvProcess, sizeof(DSA_ANCHOR))) )
    {
        return(FALSE);
    }

    Printf("%sCSUpdate           @ %p\n",
           Indent(nIndents),
           pvProcess);

    Dump_NAMING_CONTEXT_LIST(nIndents, "pMasterNC", pAnchor->pMasterNC);
    Dump_NAMING_CONTEXT_LIST(nIndents, "pReplicaNC", pAnchor->pReplicaNC);

    Printf("%spCRL               @ %p\n",
           Indent(nIndents),
           pAnchor->pCRL);

    pCRList = pAnchor->pCRL;
    nTmp = nIndents + 1;
    while ( NULL != pCRList )
    {
        pCRListTmp = ReadMemory(pCRList, sizeof(CROSS_REF_LIST));

        if ( NULL == pCRListTmp )
            return(FALSE);

        Printf("%sCross ref NC name\n", Indent(nTmp));
        Dump_DSNAME(nTmp, pCRListTmp->CR.pNC);
        Printf("%sObject holding info for this cross ref\n", Indent(nTmp));
        Dump_DSNAME(nTmp, pCRListTmp->CR.pObj);

        if ( pCRListTmp->CR.NetbiosName ) {
            WCHAR* pnbname = ReadMemory(pCRListTmp->CR.NetbiosName,
                                        (DNLEN+1)*sizeof(WCHAR) );
            if ( pnbname ) {
                Printf("%sNetbios name of domain: %ls\n",
                       Indent(nTmp), pnbname);
                FreeMemory( pnbname );

            } else {
                Printf("%sNetbios name of domain is unreadable\n",
                       Indent(nTmp) );
            }
        }

        if ( pCRListTmp->CR.DnsName ) {
            WCHAR* dnsname = ReadMemory(pCRListTmp->CR.DnsName,
                                        (255+1)*sizeof(WCHAR) );
            if ( dnsname ) {
                Printf("%sDns name of NC: %ls\n", Indent(nTmp), dnsname);
                FreeMemory( dnsname );
            } else {
                Printf("%sDns name of NC is unreadable\n", Indent(nTmp) );
            }
        }
        if (pCRListTmp->CR.DnsReferral.valCount) {
            DWORD nVal;
            ATTRVAL *pAVal = ReadMemory(pCRListTmp->CR.DnsReferral.pAVal,
                                        pCRListTmp->CR.DnsReferral.valCount
                                        * sizeof (ATTRVAL));
            if (pAVal) {
                for (nVal = 0; 
                     nVal < pCRListTmp->CR.DnsReferral.valCount;
                     ++nVal) {
                    UCHAR *pVal = ReadMemory(pAVal[nVal].pVal,
                                             pAVal[nVal].valLen + sizeof(WCHAR));
                    if (pVal) {
                        pVal[pAVal[nVal].valLen / sizeof(WCHAR)] = L'\0';
                        Printf("%sDns referral: %ls\n", Indent(nTmp), pVal);
                        FreeMemory(pVal);
                    } else {
                        Printf("%sDns referral @ %p is unreadable\n", Indent(nTmp), pAVal[nVal].pVal);
                    }
                }
                FreeMemory(pAVal);
            } else {
                Printf("%sDns referrals @ %p are unreadable\n", Indent(nTmp),
                       pCRListTmp->CR.DnsReferral.pAVal );
            }

        }
        if ( pCRListTmp->CR.DnsAliasName ) {
            WCHAR* dnsname = ReadMemory(pCRListTmp->CR.DnsAliasName,
                                        (255+1)*sizeof(WCHAR) );
            if ( dnsname ) {
                Printf("%sDns Alias name of NC: %ls\n", Indent(nTmp), dnsname);
                FreeMemory( dnsname );
            } else {
                Printf("%sDns Alias name of NC is unreadable\n", Indent(nTmp) );
            }
        }

        Printf("%sCrossRef Flags are 0x%x\n",
               Indent(nTmp), pCRListTmp->CR.flags);

        Printf("%sFirst DSA Replication Delay is %d seconds\n", Indent(nTmp),
            pCRListTmp->CR.dwFirstNotifyDelay);

        Printf("%sFirst DSA Replication Delay is %d seconds\n", Indent(nTmp),
            pCRListTmp->CR.dwSubsequentNotifyDelay);

        Printf("%sbEnabled is %d\n", Indent(nTmp), pCRListTmp->CR.bEnabled);

        if(pCRListTmp->CR.pdnSDRefDom){

            Printf("%sThe Security Descriptor Reference Domain:\n", Indent(nTmp));
            Dump_DSNAME(nIndents+1, pCRListTmp->CR.pdnSDRefDom);

            if(pCRListTmp->CR.pSDRefDomSid){
                WCHAR SidText[128];
                UNICODE_STRING us;

                SidText[0] = L'\0';
                us.MaximumLength = sizeof(SidText);
                us.Length = 0;
                us.Buffer = SidText;

                Printf("%sSecurity Descriptor Reference Domain SID Cache:", Indent(nTmp));

                // First 4 bytes of the Sid is the SID Length.
                pcbSidSize = (ULONG *) ReadMemory(pCRListTmp->CR.pSDRefDomSid, 4);
                if(pcbSidSize == NULL){
                    Printf(" unreadeable\n");
                } else {
                    pSidTmp = ReadMemory(pCRListTmp->CR.pSDRefDomSid, *pcbSidSize);
                    if(pSidTmp == NULL){
                        Printf(" unreadeable, but size is supposed to be %d\n", *((ULONG *) pSidTmp));
                    } else {
                        RtlConvertSidToUnicodeString(&us, pSidTmp, FALSE);
                        Printf("%S\n", SidText);
                        FreeMemory(pSidTmp);
                    }
                    FreeMemory(pcbSidSize);
                }
            } else {
                Printf("%sNo SID is cached\n", Indent(nTmp+1));
            }
        }


        Printf("%sNextCR is @ %p\n\n", Indent(nTmp), pCRListTmp->pNextCR);
        pCRList = pCRListTmp->pNextCR;
        FreeMemory(pCRListTmp);


    }

    Printf("%spRootDomain        @ %p\n",
           Indent(nIndents),
           pAnchor->pRootDomainDN);

    if ( NULL != pAnchor->pRootDomainDN )
        Dump_DSNAME(nIndents+1, pAnchor->pRootDomainDN);

    Printf("%spDMD               @ %p\n",
           Indent(nIndents),
           pAnchor->pDMD);

    if ( NULL != pAnchor->pDMD )
        Dump_DSNAME(nIndents+1, pAnchor->pDMD);

    Printf("%spLDAPDMD           @ %p\n",
           Indent(nIndents),
           pAnchor->pLDAPDMD);

    if ( NULL != pAnchor->pLDAPDMD )
        Dump_DSNAME(nIndents+1, pAnchor->pLDAPDMD);

    Printf("%sulDntLdapDmd          0x%x\n",
           Indent(nIndents),
           pAnchor->ulDntLdapDmd);

    Printf("%spDSA               @ %p\n",
           Indent(nIndents),
           pAnchor->pDSA);

    Printf("%spDSADN             @ %p\n",
           Indent(nIndents),
           pAnchor->pDSADN);

    if ( NULL != pAnchor->pDSADN )
        Dump_DSNAME(nIndents+1, pAnchor->pDSADN);

    Printf("%spDomainDN          @ %p\n",
           Indent(nIndents),
           pAnchor->pDomainDN);

    if ( NULL != pAnchor->pDomainDN )
        Dump_DSNAME(nIndents+1, pAnchor->pDomainDN);

    Printf("%spConfigDN          @ %p\n",
           Indent(nIndents),
           pAnchor->pConfigDN);

    if ( NULL != pAnchor->pConfigDN )
        Dump_DSNAME(nIndents+1, pAnchor->pConfigDN);

    Printf("%spPartitionsDN      @ %p\n",
           Indent(nIndents),
           pAnchor->pPartitionsDN);

    if ( NULL != pAnchor->pPartitionsDN )
        Dump_DSNAME(nIndents+1, pAnchor->pPartitionsDN);

    Printf("%spDsSvcConfigDN     @ %p\n",
           Indent(nIndents),
           pAnchor->pDsSvcConfigDN);

    if ( NULL != pAnchor->pDsSvcConfigDN )
        Dump_DSNAME(nIndents+1, pAnchor->pDsSvcConfigDN);

    Printf("%spExchangeDN        @ %p\n",
           Indent(nIndents),
           pAnchor->pExchangeDN);

    if ( NULL != pAnchor->pExchangeDN )
        Dump_DSNAME(nIndents+1, pAnchor->pExchangeDN);

    Printf("%spmtxDSA            @ %p\n",
           Indent(nIndents),
           pAnchor->pmtxDSA);

    Printf("%spwszRootDomainDnsName @ %p\n",
           Indent(nIndents),
           pAnchor->pwszRootDomainDnsName);

    Printf("%spwszHostDnsName @ %p\n",
           Indent(nIndents),
           pAnchor->pwszHostDnsName);

    Printf("%sfAmGC                0x%x\n",
           Indent(nIndents),
           pAnchor->fAmGC );

    Printf("%sfAmVirtualGC         0x%x\n",
           Indent(nIndents),
           pAnchor->fAmVirtualGC );

    Printf("%suDomainsInForest     0x%x\n",
           Indent(nIndents),
           pAnchor->uDomainsInForest );

    Printf("%sfDisableInboundRepl  0x%x\n",
           Indent(nIndents),
           pAnchor->fDisableInboundRepl );

    Printf("%sfDisableOutboundRepl 0x%x\n",
           Indent(nIndents),
           pAnchor->fDisableOutboundRepl );

    if (pAnchor->AncestorsNum) {
        Printf("%s%u Ancestors:",
               Indent(nIndents),
               pAnchor->AncestorsNum);
        pDNTs = ReadMemory(pAnchor->pAncestors,
                           pAnchor->AncestorsNum * sizeof(DWORD));
        if (pDNTs) {
            for (i=0; i<pAnchor->AncestorsNum; i++) {
                Printf(" 0x%x", pDNTs[i]);
            }
            FreeMemory(pDNTs);
        }
        Printf("\n");
    }
    else {
        Printf("%sNo Ancestors\n",
               Indent(nIndents));
    }

    if (pAnchor->UnDelAncNum) {
        Printf("%s%u Protected Ancestor DNTs:",
               Indent(nIndents),
               pAnchor->UnDelAncNum);
        pDNTs = ReadMemory(pAnchor->pUnDelAncDNTs,
                           pAnchor->UnDelAncNum * sizeof(DWORD));
        if (pDNTs) {
            for (i=0; i<pAnchor->UnDelAncNum; i++) {
                Printf(" 0x%x", pDNTs[i]);
            }
            FreeMemory(pDNTs);
        }
        Printf("\n");
    }
    else {
        Printf("%sNo Protected Ancestor DNTs\n",
               Indent(nIndents));
    }

    if (pAnchor->UnDeletableNum) {
        Printf("%s%u Protected DNTs:",
               Indent(nIndents),
               pAnchor->UnDeletableNum);
        pDNTs = ReadMemory(pAnchor->pUnDeletableDNTs,
                           pAnchor->UnDeletableNum * sizeof(DWORD));
        if (pDNTs) {
            for (i=0; i<pAnchor->UnDeletableNum; i++) {
                Printf(" 0x%x", pDNTs[i]);
            }
            FreeMemory(pDNTs);
        }
        Printf("\n");
    }
    else {
        Printf("%sNo Protected DNTs\n",
               Indent(nIndents));
    }

    Printf("%sGlobal DNread cache @ %p\n",
           Indent(nIndents),
           pAnchor->MainGlobal_DNReadCache);

    Printf("%spDomainSD:         @ %p\n",
           Indent(nIndents),
           pAnchor->pDomainSD);

    //
    // Dump cache of ATT_SUB_REFS
    //
    Printf("%spDomainSubrefList %p\n",
           Indent(nIndents),
           pAnchor->pDomainSubrefList);
    Printf("%sfDomainSubrefList %s\n",
           Indent(nIndents + 1),
           pAnchor->fDomainSubrefList ? "True": "False");
    Printf("%scDomainSubrefList %u\n",
           Indent(nIndents + 1),
           pAnchor->cDomainSubrefList);
    cDomainSubrefList = 0;
    pSRList = pAnchor->pDomainSubrefList;
    while ( NULL != pSRList )
    {
        ++cDomainSubrefList;
        pSRListTmp = ReadMemory(pSRList, sizeof(SUBREF_LIST));
        if (NULL == pSRListTmp)
        {
            Printf("%sCannot read memory @ %p; giving up\n",
                   Indent(nIndents + 1),
                   pSRList);
            break;
        }
        Dump_DSNAME(nIndents + 1, pSRListTmp->pDSName);
        if (pSRListTmp->cAncestors) {
            Printf("%s%u Ancestors (obj -> root):",
                   Indent(nIndents + 1),
                   pSRListTmp->cAncestors);
            pDNTs = ReadMemory(pSRListTmp->pAncestors,
                               pSRListTmp->cAncestors * sizeof(DWORD));
            if (pDNTs) {
                for (i=0; i<pSRListTmp->cAncestors; i++) {
                    Printf(" 0x%x", pDNTs[i]);
                }
                FreeMemory(pDNTs);
            }
            Printf("\n");
        }
        else {
            Printf("%sNo Ancestors\n",
                   Indent(nIndents + 1));
        }

        /* print a spacer between SRs */
        Printf("\n");

        pSRList = pSRListTmp->pNextSubref;
        FreeMemory(pSRListTmp);
    }
    if (cDomainSubrefList == pAnchor->cDomainSubrefList) {
        Printf("%scDomainSubrefList is okay (%u == %u)\n",
               Indent(nIndents + 1),
               cDomainSubrefList,
               pAnchor->cDomainSubrefList);
    } else {
        Printf("%sPOSSIBLE BUG: cDomainSubrefList is off (%u != %u)\n",
               Indent(nIndents + 1),
               cDomainSubrefList,
               pAnchor->cDomainSubrefList);
    }

    Printf("%sfAmRootDomainDC      0x%x\n",
           Indent(nIndents),
           pAnchor->fAmRootDomainDC );


    Printf("%spInfraStructureDN        @ %p\n",
           Indent(nIndents),
           pAnchor->pInfraStructureDN);

    if ( NULL != pAnchor->pInfraStructureDN )
        Dump_DSNAME(nIndents+1, pAnchor->pInfraStructureDN);


    Printf("%sMaxPasswordAge        0x%x 0x%x\n",
           Indent(nIndents),
           pAnchor->MaxPasswordAge.LowPart, pAnchor->MaxPasswordAge.HighPart);


    Printf("%sLockoutDuration        0x%x 0x%x\n",
           Indent(nIndents),
           pAnchor->LockoutDuration.LowPart, pAnchor->LockoutDuration.HighPart);

    Printf("%sForestBehaviorVersion %d\n",
           Indent(nIndents),
           pAnchor->ForestBehaviorVersion);

    Printf("%sDomainBehaviorVersion %d\n",
           Indent(nIndents),
           pAnchor->DomainBehaviorVersion);

    Printf("%spCurrInvocationID     %p\n",
           Indent(nIndents),
           pAnchor->pCurrInvocationID);

    Printf("%sfSchemaUpgradeInProgress %d\n",
           Indent(nIndents),
           pAnchor->fSchemaUpgradeInProgress);

    if(pAnchor->pNoGCSearchList){
        Printf("%spNoGCSearchList = %p\n", Indent(nIndents), pAnchor->pNoGCSearchList);
        if ( NULL == (pNoGCSearchList = ReadMemory(pAnchor->pNoGCSearchList,
                                                   sizeof(COUNTED_LIST))) ){
            Printf("%sCannot read memory @ %p; giving up\n.",
                   pAnchor->pNoGCSearchList);
            return(FALSE);
        }
        if(pNoGCSearchList->pList){
            Printf("%s->cNCs = %ul\n", Indent(nIndents+2), pNoGCSearchList->cNCs);
            Printf("%s->p = %p\n", Indent(nIndents+2), pNoGCSearchList->pList);
            if( NULL == (paNonGCNcsDNTs = ReadMemory(pNoGCSearchList->pList,
                                        (pNoGCSearchList->cNCs * sizeof(DWORD))))){
                Printf("%sCannot read memory @ %p; giving up.\n",
                       pNoGCSearchList->pList);
                FreeMemory(pNoGCSearchList);
                return(FALSE);
            }

            // This is the normal case.
            // Walk and print out the list of
            Printf("%s ", Indent(nIndents+4));
            for(i = 0; i < pNoGCSearchList->cNCs; i++){
                if(dwPrevDNT < paNonGCNcsDNTs[i]){
                    Printf("0x%X ", paNonGCNcsDNTs[i]);
                    dwPrevDNT = paNonGCNcsDNTs[i];
                } else {
                    Printf("%s\n\nCONSISTENCY ERROR dsexts\\md.c Line: %ul !?!, Contact the AD/DS group.\n\n",
                                       Indent(nIndents), __LINE__);
                    break;
                }
            }
            Printf("\n");

            FreeMemory(paNonGCNcsDNTs);
        } else {
            Printf("%s\n\nCONSISTENCY ERROR dsexts\\md.c Line: %ul !?!, Contact the AD/DS group.\n\n",
                   Indent(nIndents), __LINE__);
        }
        FreeMemory(pNoGCSearchList);
    } else {
        // This is the other normal case.
        Printf("%spNoGCSearchList = (NULL)\n", Indent(nIndents));
    }

    Printf("%spSigVec        @ %p\n",
           Indent(nIndents),
           pAnchor->pSigVec);

    Printf("%spComputerDN          @ %p\n",
           Indent(nIndents),
           pAnchor->pComputerDN);

    if ( NULL != pAnchor->pComputerDN )
        Dump_DSNAME(nIndents+1, pAnchor->pComputerDN);

    Printf("%sulDNTSystem          0x%x\n",
          Indent(nIndents),
          pAnchor->ulDNTSystem);

    Printf("%sfQuotaTableReady     %s\n",
          Indent(nIndents),
          pAnchor->fQuotaTableReady ? "True": "False");

    Printf("%sulQuotaRebldDNTLast  0x%x\n",
          Indent(nIndents),
          pAnchor->ulQuotaRebuildDNTLast);

    Printf("%sulQuotaRebldDNTMax   0x%x\n",
          Indent(nIndents),
          pAnchor->ulQuotaRebuildDNTMax);

    FreeMemory(pAnchor);
    return(TRUE);
}

BOOL
Dump_KEY(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public KEY dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of KEY in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    KEY   *pKey = NULL;
    VLV_SEARCH  *pVLVsearch = NULL;
    VLV_REQUEST *pVLVrequest = NULL;

    Printf("%sKEY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pKey = ReadMemory(pvProcess, sizeof(KEY)))) {
        return(FALSE);
    }

    Printf("%sSearch in progress:      %s\n",
           Indent(nIndents),
           (pKey->fSearchInProgress ? "TRUE": "FALSE"));


    Printf("%spIndex:                @ %p\n",
           Indent(nIndents),
           pKey->pIndex);


    Printf("%sSearch Root DNT:         %x\n",
           Indent(nIndents),
           pKey->ulSearchRootDnt);

    Printf("%sSearch Root PDNT:        %x\n",
           Indent(nIndents),
           pKey->ulSearchRootPDNT);

    Printf("%sSearch Root NCDNT:       %x\n",
           Indent(nIndents),
           pKey->ulSearchRootNcdnt);

    Printf("%sSearch Type:             ",Indent(nIndents));
    switch(pKey->ulSearchType) {
    case SE_CHOICE_BASE_ONLY:
        Printf("Base object\n");
        break;

    case SE_CHOICE_IMMED_CHLDRN:
        Printf("One level\n");
        break;

    case SE_CHOICE_WHOLE_SUBTREE:
        Printf("Whole subtree\n");
        break;

    default:
        Printf("Invalid choice\n");
        break;
    }

    Dump_FILTER(nIndents+1,pKey->pFilter);

    Printf("%spFilterSecurity:       @ %p\n",
           Indent(nIndents),
           pKey->pFilterSecurity);

    Printf("%spFilterResults:        @ %p\n",
           Indent(nIndents),
           pKey->pFilterResults);

    Printf("%spFilterSecuritySize:     %d\n",
           Indent(nIndents),
           pKey->FilterSecuritySize);


    Printf("%sIndex Type:             ",Indent(nIndents));
    switch(pKey->indexType) {
    case INVALID_INDEX_TYPE:
        Printf("Invalid index type\n");
        break;

    case UNSET_INDEX_TYPE:
        Printf("Unset index type\n");
        break;

    case GENERIC_INDEX_TYPE:
        Printf("Generic index type\n");
        break;

    case TEMP_TABLE_INDEX_TYPE:
        Printf("Temp table index type\n");
        break;

    case ANCESTORS_INDEX_TYPE:
        Printf("Ancestors index type\n");
        break;

    case INTERSECT_INDEX_TYPE:
        Printf("Intersect index type\n");
        break;

    case TEMP_TABLE_MEMORY_ARRAY_TYPE:
        Printf("InMemory array type\n");
        break;

    default:
        Printf("Invalid choice (%d)\n", pKey->indexType);
        break;
    }

    Printf("%sSort Type:               ",Indent(nIndents));
    switch(pKey->ulSorted) {
    case SORT_NEVER:
        Printf("NEVER\n");
        break;
    case SORT_OPTIONAL:
        Printf("OPTIONAL\n");
        break;
    case SORT_MANDATORY:
        Printf("MANDATORY\n");
        break;
    default:
        Printf("Invalid choice %d\n", pKey->ulSorted);
        break;
    }

    if ((pKey->indexType == TEMP_TABLE_INDEX_TYPE) ||
        (pKey->indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) ) {
        Printf("%sEntriesInTempTable:      %d\n",
                   Indent(nIndents),
                   pKey->ulEntriesInTempTable);
    }

    if (pKey->pVLV) {
        if ( NULL == (pVLVsearch = ReadMemory(pKey->pVLV, sizeof(VLV_SEARCH)))) {
            Printf("%sError Reading pVLV:@ %p\n",
                   Indent(nIndents),
                   pKey->pVLV);
        }
    }

    if (pVLVsearch) {
        Printf("%sVLV Present\n", Indent(nIndents));

        if ( NULL == (pVLVrequest = ReadMemory(pVLVsearch->pVLVRequest, sizeof(VLV_REQUEST)))) {
            Printf("%sError Reading pVLVRequest:@ %p\n",
                   Indent(nIndents),
                   pVLVsearch->pVLVRequest);
        }

        if (pVLVrequest) {
            Printf("%sOriginal VLV Request\n",
                   Indent(nIndents + 1));

            Printf("%sfseekToValue:            %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->fseekToValue);
            Printf("%sbeforeCount:             %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->beforeCount);
            Printf("%safterCount:              %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->afterCount);
            Printf("%stargetPosition:          %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->targetPosition);
            Printf("%scontentCount:            %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->contentCount);
            Printf("%sseekValue:             @ %p\n",
                   Indent(nIndents),
                   pVLVrequest->seekValue.pVal);
            Printf("%spVLVRestart:           @ %p\n",
                   Indent(nIndents),
                   pVLVrequest->pVLVRestart);
        }


        Printf("%spositionOp:              %d\n",
               Indent(nIndents + 1),
               pVLVsearch->positionOp);
        Printf("%sclnCurrPos:              %d\n",
               Indent(nIndents + 1),
               pVLVsearch->clnCurrPos);
        Printf("%sclnContentCount:         %d\n",
               Indent(nIndents + 1),
               pVLVsearch->clnContentCount);
        Printf("%scurrPosition:            %d\n",
               Indent(nIndents + 1),
               pVLVsearch->currPosition);
        Printf("%scontentCount:            %d\n",
               Indent(nIndents + 1),
               pVLVsearch->contentCount);
        Printf("%srequestedEntries:        %d\n",
               Indent(nIndents + 1),
               pVLVsearch->requestedEntries);
        Printf("%sAttrType:                %d\n",
               Indent(nIndents + 1),
               pVLVsearch->SortAttr);
        if (pVLVsearch->bUsingMAPIContainer) {
            Printf("%sMAPIContainerDNT:        %d\n",
                   Indent(nIndents + 1),
                   pVLVsearch->MAPIContainerDNT);
        }
        Printf("%sErr:                     %d\n",
               Indent(nIndents + 1),
               pVLVsearch->Err);
    }

    if (pKey->asqRequest.fPresent) {
        Printf("%sASQ Present\n", Indent(nIndents));
        Printf("%sASQ Attr from GC:        %d\n",
                   Indent(nIndents+1),
                   pKey->asqRequest.fMissingAttributesOnGC);
        Printf("%sASQ AttrType:            %d\n",
                   Indent(nIndents + 1),
                   pKey->asqRequest.attrType);

        Printf("%sASQ Err:                 %d\n",
                   Indent(nIndents + 1),
                   pKey->asqRequest.Err);

        Printf("%sASQ Mode:                 ", Indent(nIndents+1));

        if (pKey->asqMode) {

            if (pKey->asqMode & ASQ_SORTED) {
                Printf("SORTED ");
            }
            if (pKey->asqMode & ASQ_PAGED) {
                Printf("PAGED ");
            }
            if (pKey->asqMode & ASQ_VLV) {
                Printf("VLV ");
            }
            Printf("\n");
        }
        else {
            Printf("SIMPLE\n");
        }
        Printf("%sulASQLastUpperBound:     %d\n",
                   Indent(nIndents + 1),
                   pKey->ulASQLastUpperBound);

        Printf("%sulASQSizeLimit:          %d\n",
                   Indent(nIndents + 1),
                   pKey->ulASQSizeLimit);
    }

    if (pKey->cdwCountDNTs) {
        Printf("%scdwCountDNTs:            %d\n",
                   Indent(nIndents),
                   pKey->cdwCountDNTs);
        Printf("%spDNTs:                 @ %p\n",
                   Indent(nIndents),
                   pKey->pDNTs);
        Printf("%scurrRecPos:              %d\n",
                   Indent(nIndents),
                   pKey->currRecPos);
    }

    FreeMemory(pKey);
    return(TRUE);
}

BOOL
Dump_KEY_INDEX(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public KEY dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of KEY in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    KEY_INDEX   *pIndex = NULL;

    Printf("%sKEY_INDEX @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pIndex = ReadMemory(pvProcess, sizeof(KEY_INDEX)))) {
        return(FALSE);
    }

    if(pIndex->szIndexName) {
        char * pszIndex;
        DWORD cb;
        cb = min(64, (DWORD)(4095 - (((DWORD_PTR)pIndex->szIndexName) & 4095)));
        pszIndex = ReadMemory(pIndex->szIndexName, cb);
        if (NULL == pszIndex) {
            FreeMemory(pIndex);
            return FALSE;
        }
        // Null terminate, just in case
        pszIndex[cb-1]= 0;
        Printf("%sIndex Name:              %s\n",
               Indent(nIndents),
               pszIndex);
        FreeMemory(pszIndex);
    }
    else {
        Printf("%sIndex Name:              No Index\n", Indent(nIndents) );
    }

    Printf("%sEstimated Recs In Range: %d\n",
           Indent(nIndents),
           pIndex->ulEstimatedRecsInRange);

    Printf("%sbFlags:                  0x%x\n",
           Indent(nIndents),
           pIndex->bFlags);

    Printf("%sIndex is single-valued:  %s\n",
           Indent(nIndents),
           (pIndex->bIsSingleValued ? "TRUE" : "FALSE"));

    Printf("%sIndex is equality-based: %s\n",
           Indent(nIndents),
           (pIndex->bIsEqualityBased ? "TRUE" : "FALSE"));

    Printf("%sIndex is for sort:       %s\n",
           Indent(nIndents),
           (pIndex->bIsForSort ? "TRUE" : "FALSE"));

    Printf("%sIndex is PDNT-based:     %s\n",
           Indent(nIndents),
           (pIndex->bIsPDNTBased ? "TRUE" : "FALSE"));

    Printf("%sIndex is a tuple index:  %s\n",
           Indent(nIndents),
           (pIndex->bIsTupleIndex ? "TRUE" : "FALSE"));

    Printf("%sIndex is intersection:   %s\n",
           Indent(nIndents),
           (pIndex->bIsIntersection ? "TRUE" : "FALSE"));

    Printf("%sIndex Range has 1 record: %s\n",
           Indent(nIndents),
           (pIndex->bIsUniqueRecord ? "TRUE" : "FALSE"));

    Printf("%spindexid:              @ %p\n",
           Indent(nIndents),
           pIndex->pindexid);

    Printf("%scbKeyLower:              %d\n",
           Indent(nIndents),
           pIndex->cbDBKeyLower);

    Printf("%srgbKeyLower:           @ %p\n",
           Indent(nIndents),
           pIndex->rgbDBKeyLower);

    Printf("%scbKeyUpper:              %d\n",
           Indent(nIndents),
           pIndex->cbDBKeyUpper);

    Printf("%srgbKeyUpper:           @ %p\n",
           Indent(nIndents),
           pIndex->rgbDBKeyUpper);

    Printf("%spAC  :                 @ %p\n",
           Indent(nIndents),
           pIndex->pAC);

    Printf("%stblIntersection          0x%x\n",
           Indent(nIndents),
           pIndex->tblIntersection);

    Printf("%scolumnidBookmark:        0x%x\n",
           Indent(nIndents),
           pIndex->columnidBookmark);

    Printf("%spNext:                 @ %p\n",
           Indent(nIndents),
           pIndex->pNext);

    FreeMemory(pIndex);
    return(TRUE);
}

BOOL
Dump_DBPOS(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DBPOS dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DBPOS in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    DBPOS   *pDBPOS = NULL;
    DWORD   cBytes;


    Printf("%sDBPOS @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    //
    // DBPOS has some DBG-only fields at the end.  Always read the
    // non-DBG amount of memory since the process being debugged may
    // not be a DBG version although the extensions DLL is.
    //

    cBytes = OFFSET(DBPOS, NewlyCreatedDNT) + sizeof(ULONG);

    if ( NULL == (pDBPOS = ReadMemory(pvProcess, cBytes)) )
    {
        return(FALSE);
    }

    Printf("%spTHS               @ %p\n",
           Indent(nIndents),
           pDBPOS->pTHS);
    Printf("%svalBufSize           0x%x\n",
           Indent(nIndents),
           pDBPOS->valBufSize);
    Printf("%spValBuf            @ %p\n",
           Indent(nIndents),
           pDBPOS->pValBuf);
    Printf("%sDNT                  0x%x\n",
           Indent(nIndents),
           pDBPOS->DNT);
    Printf("%sPDNT                 0x%x\n",
           Indent(nIndents),
           pDBPOS->PDNT);
    Printf("%sSDNT                 0x%x\n",
           Indent(nIndents),
           pDBPOS->SDNT);
    Printf("%sNCDNT                0x%x\n",
           Indent(nIndents),
           pDBPOS->NCDNT);
    Printf("%sJetDBID              0x%x\n",
           Indent(nIndents),
           pDBPOS->JetDBID);
    Printf("%sJetSessID            0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSessID);
    Printf("%sJetObjTbl            0x%x\n",
           Indent(nIndents),
           pDBPOS->JetObjTbl);
    Printf("%sJetSearchTbl         0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSearchTbl);
    Printf("%sJetLinkTbl           0x%x\n",
           Indent(nIndents),
           pDBPOS->JetLinkTbl);
    Printf("%sJetSDPropTbl         0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSDPropTbl);
    Printf("%sJetSDTbl             0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSDTbl);
    Printf("%sJetSortTbl           0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSortTbl);
    Printf("%sSortColumns          [0x%x,0x%x]\n",
           Indent(nIndents),
           pDBPOS->SortColumns[0],
           pDBPOS->SortColumns[1]);
    Printf("%sJetRetrieveBits      0x%x\n",
           Indent(nIndents),
           pDBPOS->JetRetrieveBits);
    Printf("%sSDEvents             0x%x\n",
           Indent(nIndents),
           pDBPOS->SDEvents);
    Printf("%stransType            0x%x\n",
           Indent(nIndents),
           (pDBPOS->transType) & 3);
    Printf("%sroot                 0x%x\n",
           Indent(nIndents),
           (pDBPOS->root) & 1);
    Printf("%sfHidden              0x%x\n",
           Indent(nIndents),
           (pDBPOS->fHidden) & 1);
    Printf("%sJetCacheRec          0x%x\n",
           Indent(nIndents),
           (pDBPOS->JetCacheRec) & 1);
    Printf("%sJetNewRec            0x%x\n",
           Indent(nIndents),
           (pDBPOS->JetNewRec) & 1);
    Printf("%sfFlushCacheOnUpdate  0x%x\n",
           Indent(nIndents),
           (pDBPOS->fFlushCacheOnUpdate) & 1);
    Printf("%sfScopeLegacyLinks  0x%x\n",
           Indent(nIndents),
           (pDBPOS->fScopeLegacyLinks) & 1);
    Printf("%spDNsAdded          @ %p\n",
           Indent(nIndents),
           pDBPOS->pDNsAdded);
    Printf("%sKEY                @ %p\n",
           Indent(nIndents),
           ((DWORD_PTR)pvProcess +
            OFFSET(DBPOS, Key)));
    Printf("%sfIsMetaDataCached    %s\n",
           Indent(nIndents),
           pDBPOS->fIsMetaDataCached ? "yes" : "no");
    Printf("%sfIsLinkMetaDataCached    %s\n",
           Indent(nIndents),
           pDBPOS->fIsLinkMetaDataCached ? "yes" : "no");
    Printf("%sfMetaDataWriteOptimizable    %s\n",
           Indent(nIndents),
           pDBPOS->fMetaDataWriteOptimizable ? "yes" : "no");
    Printf("%scbMetaDataVecAlloced 0x%x\n",
           Indent(nIndents),
           pDBPOS->cbMetaDataVecAlloced);
    Printf("%spMetaDataVec       @ %p\n",
           Indent(nIndents),
           pDBPOS->pMetaDataVec);
    Printf("%srgLinkMetaData       @ %p\n",
           Indent(nIndents),
           pDBPOS->rgLinkMetaData);
    Printf("%scLinkMetaData %d\n",
           Indent(nIndents),
           pDBPOS->cLinkMetaData);
    Printf("%scbLinkMetaDataAlloced 0x%x\n",
           Indent(nIndents),
           pDBPOS->cbLinkMetaDataAlloced);
    Printf("%stransincount         0x%x\n",
           Indent(nIndents),
           pDBPOS->transincount);
    Printf("%sSearchEntriesVisited  %d\n",
           Indent(nIndents),
           pDBPOS->SearchEntriesVisited);
    Printf("%sSearchEntriesReturned %d\n",
           Indent(nIndents),
           pDBPOS->SearchEntriesReturned);
    Printf("%sNewlyCreatedDNT      0x%x\n",
           Indent(nIndents),
           pDBPOS->NewlyCreatedDNT);

    Printf("%spSecurity          @ %p, isGlobalRef=%d\n",
           Indent(nIndents),
           pDBPOS->pSecurity, pDBPOS->fSecurityIsGlobalRef);

    FreeMemory(pDBPOS);
    return(TRUE);
}

BOOL Dump_DirWaitItem(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    DirWaitItem*    pDirWaitItem = NULL;
    DWORD           cBytes;

    Printf("%sDirWaitItem @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    cBytes = sizeof (DirWaitItem);

    if (!(pDirWaitItem = ReadMemory(pvProcess, cBytes))) {
        return FALSE;
    }

    Printf("%shServer = 0x%x\n",
           Indent(nIndents),
           pDirWaitItem->hServer);

    Printf("%shClient = 0x%x\n",
           Indent(nIndents),
           pDirWaitItem->hClient);

    Printf("%spfPrepareForImpersonate = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pfPrepareForImpersonate);

    Printf("%spfTransmitData = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pfTransmitData);

    Printf("%spfStopImpersonating = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pfStopImpersonating);

    Printf("%sDNT = %d\n",
           Indent(nIndents),
           pDirWaitItem->DNT);

    switch(pDirWaitItem->choice) {
    case SE_CHOICE_BASE_ONLY:
        Printf("%sScope: Base Object\n",Indent(nIndents));
        break;
    case SE_CHOICE_IMMED_CHLDRN:
        Printf("%sScope: One Level\n",Indent(nIndents));
        break;
    case SE_CHOICE_WHOLE_SUBTREE:
        Printf("%sScope: Whole Subtree\n",Indent(nIndents));
        break;
    default:
        Printf("%sScope: invalid %d\n",Indent(nIndents),pDirWaitItem->choice);
        break;
    }

    Printf("%sbOneNC = %d\n",
           Indent(nIndents),
           pDirWaitItem->bOneNC);

    Printf("%spSel = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pSel);

    if (pDirWaitItem->pNextItem) {
        if (!Dump_DirWaitItem (nIndents-1, pDirWaitItem->pNextItem)) {
            FreeMemory(pDirWaitItem);
            return FALSE;
        }
    }

    FreeMemory(pDirWaitItem);
    return TRUE;
}

BOOL Dump_DirWaitEntry(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    DirWaitEntry*   pDirWaitEntry = NULL;
    DWORD           cBytes;

    Printf("%sDirWaitEntry @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    cBytes = sizeof(DirWaitEntry);

    if (!(pDirWaitEntry = ReadMemory(pvProcess, cBytes))) {
        return FALSE;
    }

    Printf("%sDNT = %d\n",
           Indent(nIndents),
           pDirWaitEntry->key.DNT);

    switch(pDirWaitEntry->key.choice) {
    case SE_CHOICE_BASE_ONLY:
        Printf("%sScope: Base Object\n",Indent(nIndents));
        break;
    case SE_CHOICE_IMMED_CHLDRN:
        Printf("%sScope: One Level\n",Indent(nIndents));
        break;
    case SE_CHOICE_WHOLE_SUBTREE:
        Printf("%sScope: Whole Subtree\n",Indent(nIndents));
        break;
    default:
        Printf("%sScope: invalid %d\n",Indent(nIndents),pDirWaitEntry->key.choice);
        break;
    }

    if (pDirWaitEntry->pList) {
        if (!Dump_DirWaitItem(nIndents, pDirWaitEntry->pList)) {
            FreeMemory(pDirWaitEntry);
            return FALSE;
        }
    }

    FreeMemory(pDirWaitEntry);
    return TRUE;
}

BOOL Dump_DirWaitList(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    return Dump_LHT(nIndents, pvProcess, (PFN_DUMP_TYPE)Dump_DirWaitEntry);
}

char * rgszSortType[] = { "none", "optional", "mandatory", "bogus value!" };
void
Dump_CommArgLocal(
             IN DWORD nIndents,
             IN COMMARG* pState)

/*++

Routine Description:

    Private CommArg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pState - address of CommArg in this process

Return Value:

    None

--*/

{
    SVCCNTL Svc;

    Svc = pState->Svccntl;
    Printf("%sSvccntl:\n",
           Indent(nIndents));
    nIndents += 2;
    {
        Printf("%sSecDescFlags:  0x%x\n",
               Indent(nIndents),
               Svc.SecurityDescriptorFlags);
        Printf("%sChaining: %s\n",
               Indent(nIndents),
               Svc.preferChaining ? "preferred" : "not preferred");
        Printf("%sChaining: %s\n",
               Indent(nIndents),
               Svc.chainingProhibited ? "prohibited" : "not prohibited");
        Printf("%slocalScope: %s\n",
               Indent(nIndents),
               Svc.localScope ? "yes" : "no");
        Printf("%sUseCopy: %s\n",
               Indent(nIndents),
               Svc.dontUseCopy ? "forbidden" : "allowed");
        Printf("%sDeletionsAvailable: %s\n",
               Indent(nIndents),
               Svc.makeDeletionsAvail ? "yes" : "no");
        Printf("%fAllowIntraForestFPO: %s\n",
               Indent(nIndents),
               Svc.fAllowIntraForestFPO ? "yes" : "no");
        Printf("%sStringNames: %s\n",
               Indent(nIndents),
               Svc.fStringNames ? "yes" : "no");
        Printf("%sPermissiveModify: %s\n",
               Indent(nIndents),
               Svc.fPermissiveModify ? "yes" : "no");
        Printf("%sUrgentReplication: %s\n",
               Indent(nIndents),
               Svc.fUrgentReplication ? "yes" : "no");
        Printf("%sAuthoritativeModify: %s\n",
               Indent(nIndents),
               Svc.fAuthoritativeModify ? "yes" : "no");
        Printf("%sMaintainSelOrder: %s\n",
               Indent(nIndents),
               Svc.fMaintainSelOrder ? "yes" : "no");
        Printf("%sDontOptimizeSel: %s\n",
               Indent(nIndents),
               Svc.fDontOptimizeSel ? "yes" : "no");
    Printf("%spGCVerifyHint: %p\n",
           Indent(nIndents),
           Svc.pGCVerifyHint);
    }
    nIndents -= 2;

    Printf("%sPagedResult:\n", Indent(nIndents));
    nIndents += 1;
    {
        Printf("%spRestart:     @ %p\n",
               Indent(nIndents),
               pState->PagedResult.pRestart);
        Printf("%sfPresent:       %x\n",
               Indent(nIndents),
               pState->PagedResult.fPresent);
    }
    nIndents -= 1;

    nIndents += 2;

//    Printf("%sOpsate                  0x%x\n",
//         Indent(nIndents),
//         pState->Opsate);
    Printf("%saliasRDN                  0x%x\n",
           Indent(nIndents),
           pState->aliasRDN);
    Printf("%sulSizeLimit               0x%x\n",
           Indent(nIndents),
           pState->ulSizeLimit);
    Printf("%sfForwardSeek              0x%x\n",
           Indent(nIndents),
           (pState->fForwardSeek) & 1);
    Printf("%sSortType                  0x%x (%s)\n",
           Indent(nIndents),
           (pState->SortType) & 3,
           rgszSortType[(pState->SortType) & 3]);
    Printf("%sSortAttr                  0x%x\n",
           Indent(nIndents),
           pState->SortAttr);
    Printf("%sDelta                     0x%x\n",
           Indent(nIndents),
           pState->Delta);
    Printf("%sStartTick                 0x%x\n",
           Indent(nIndents),
           pState->StartTick);
    Printf("%sDeltaTick                 0x%x\n",
           Indent(nIndents),
           pState->DeltaTick);
    Printf("%sfLazyCommit               %s\n",
           Indent(nIndents),
           pState->fLazyCommit ? "True" : "False");
    Printf("%sfFindSidWithinNC          %s\n",
        Indent(nIndents),
        pState->fFindSidWithinNc? "True" : "False");

}
BOOL
Dump_CommArg(
             IN DWORD nIndents,
             IN PVOID pvProcess)

/*++

Routine Description:

    Public CommArg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of CommArg in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    COMMARG *pState = NULL;

    Printf("%sCommArg @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pState = ReadMemory(pvProcess, sizeof(COMMARG)))) {
        return(FALSE);
    }

    Dump_CommArgLocal(nIndents,
                      pState);

    FreeMemory(pState);

    return(TRUE);
}

BOOL
Dump_USN_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USN_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of USN_VECTOR in the address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    USN_VECTOR      *pUsnVec = NULL;

    Printf("%sUSN_VECTOR\n", Indent(nIndents));
    nIndents += 2;

    pUsnVec = (USN_VECTOR *) ReadMemory(pvProcess,
                                              sizeof(USN_VECTOR));

    if ( NULL != pUsnVec )
    {
        Printf("%susnHighObjUpdate: %I64d\n",
               Indent(nIndents),
               pUsnVec->usnHighObjUpdate);

        Printf("%susnHighPropUpdate: %I64d\n",
               Indent(nIndents),
               pUsnVec->usnHighPropUpdate);

        FreeMemory(pUsnVec);

        fSuccess = TRUE;

    }

    return(fSuccess);
}


BOOL
Dump_PROPERTY_META_DATA_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public PROPERTY_META_DATA_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PROPERTY_META_DATA_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                        fSuccess = FALSE;
    PROPERTY_META_DATA_VECTOR   *pMetaData = NULL;
    DWORD                       cNumProps = 0;
    DWORD                       iCursor;

    Printf("%sPROPERTY_META_DATA_VECTOR\n", Indent(nIndents));

    pMetaData = (PROPERTY_META_DATA_VECTOR *) ReadMemory(pvProcess,
                                              MetaDataVecV1SizeFromLen(0));

    if (NULL != pMetaData)
    {
        if (VERSION_V1 == pMetaData->dwVersion)
        {
            cNumProps = pMetaData->V1.cNumProps;
        }
        else
        {
            Printf("%sProperty meta data vector version is NOT %d\n!!!", Indent(nIndents), VERSION_V1);
            fSuccess = TRUE;
        }

        FreeMemory(pMetaData);

        if (0 != cNumProps)
        {
            Printf("%s%d entries.\n", Indent(nIndents), cNumProps);
            pMetaData = (PROPERTY_META_DATA_VECTOR *) ReadMemory(pvProcess,
                                                      MetaDataVecV1SizeFromLen(cNumProps));

            if (NULL != pMetaData)
            {
                DWORD   iprop;
                DWORD   ib;

                Printf(
                    "\n%s%6s%6s%8s%37s%8s%18s\n",
                    Indent(nIndents+1),
                    "AttID",
                    "Ver",
                    "Loc.USN",
                    "Originating DSA",
                    "Org.USN",
                    "Org.Time/Date"
                    );

                Printf(
                    "%s%6s%6s%8s%37s%8s%18s\n",
                    Indent(nIndents+1),
                    "=====",
                    "===",
                    "=======",
                    "===============",
                    "=======",
                    "============="
                    );

                for ( iprop = 0; iprop < pMetaData->V1.cNumProps; iprop++ )
                {
                    CHAR        szLocalUSN[ 40 ];
                    CHAR        szOriginatingUUID[ 40 ];
                    CHAR        szTime[ SZDSTIME_LEN ];
                    struct tm * ptm;

                    if ( 0xffffffffffffffff == pMetaData->V1.rgMetaData[ iprop ].usnProperty )
                    {
                        // Interim in-memory state signifying that this property has
                        // been touched and its meta data will be updated before the
                        // vector is put in the db.
                        strcpy( szLocalUSN, "touched" );
                    }
                    else
                    {
                        RtlLargeIntegerToChar(
                            (LARGE_INTEGER *) &pMetaData->V1.rgMetaData[ iprop ].usnProperty,
                            10,
                            sizeof( szLocalUSN ),
                            szLocalUSN
                            );
                    }

                    DraUuidToStr(
                        &pMetaData->V1.rgMetaData[ iprop ].uuidDsaOriginating,
                        szOriginatingUUID,
                        (sizeof(szOriginatingUUID)/sizeof(szOriginatingUUID[0])) );

                    Printf(
                        "%s%6x%6x%8s%37s%8I64d%18s\n",
                        Indent(nIndents+1),
                        pMetaData->V1.rgMetaData[ iprop ].attrType,
                        pMetaData->V1.rgMetaData[ iprop ].dwVersion,
                        szLocalUSN,
                        szOriginatingUUID,
                        pMetaData->V1.rgMetaData[ iprop ].usnOriginating,
                        DSTimeToDisplayString(pMetaData->V1.rgMetaData[iprop].timeChanged, szTime)
                        );
                }

                FreeMemory(pMetaData);
                fSuccess = TRUE;
            }
        }
    }

    return(fSuccess);
}


BOOL
Dump_PROPERTY_META_DATA_EXT_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public PROPERTY_META_DATA_EXT_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PROPERTY_META_DATA_EXT_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                            fSuccess = FALSE;
    PROPERTY_META_DATA_EXT_VECTOR   *pMetaDataExt = NULL;
    DWORD                           cNumProps;
    DWORD                           iCursor;

    Printf("%sPROPERTY_META_DATA_EXT_VECTOR\n", Indent(nIndents));

    pMetaDataExt = (PROPERTY_META_DATA_EXT_VECTOR *) ReadMemory(pvProcess,
                                              MetaDataExtVecSizeFromLen(0));

    if (NULL != pMetaDataExt)
    {
        cNumProps = pMetaDataExt->cNumProps;
        FreeMemory(pMetaDataExt);

        Printf("%s%d entries.\n", Indent(nIndents), cNumProps);

        pMetaDataExt = (PROPERTY_META_DATA_EXT_VECTOR *) ReadMemory(pvProcess,
                                                  MetaDataExtVecSizeFromLen(cNumProps));

        if (NULL != pMetaDataExt)
        {
            DWORD   iprop;
            DWORD   ib;

            Printf(
                "\n%s%6s%37s%8s%18s\n",
                Indent(nIndents+1),
                "Ver",
                "Originating DSA",
                "Org.USN",
                "Org.Time/Date"
                );

            Printf(
                "%s%6s%37s%8s%18s\n",
                Indent(nIndents+1),
                "===",
                "===============",
                "=======",
                "============="
                );

            for ( iprop = 0; iprop < pMetaDataExt->cNumProps; iprop++ )
            {
                CHAR        szOriginatingUUID[ 40 ];
                CHAR        szTime[ SZDSTIME_LEN ];
                struct tm * ptm;

                DraUuidToStr(
                    &pMetaDataExt->rgMetaData[ iprop ].uuidDsaOriginating,
                    szOriginatingUUID, 
                    (sizeof(szOriginatingUUID)/sizeof(szOriginatingUUID[0])));

                Printf(
                    "%s%6x%37s%8I64d%18s\n",
                    Indent(nIndents+1),
                    pMetaDataExt->rgMetaData[ iprop ].dwVersion,
                    szOriginatingUUID,
                    pMetaDataExt->rgMetaData[ iprop ].usnOriginating,
                    DSTimeToDisplayString(pMetaDataExt->rgMetaData[iprop].timeChanged, szTime)
                    );
            }

            FreeMemory(pMetaDataExt);
            fSuccess = TRUE;
        }
    }

    return(fSuccess);
}


BOOL
Dump_VALUE_META_DATA(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public VALUE_META_DATA dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of VALUE_META_DATA in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                        fSuccess = FALSE;
    VALUE_META_DATA             *pMetaData = NULL;

    Printf("%sVALUE_META_DATA\n", Indent(nIndents));

    pMetaData = (VALUE_META_DATA *) ReadMemory(pvProcess,
                                               sizeof(VALUE_META_DATA));

    if (NULL != pMetaData)
    {
        CHAR        szLocalUSN[ 40 ];
        CHAR        szOriginatingUUID[ 40 ];
        CHAR        szTime[ SZDSTIME_LEN ];
        CHAR        szTime1[ SZDSTIME_LEN ];
        struct tm * ptm;

        Printf(
            "\n%6s%6s%18s%6s%8s%37s%8s%18s\n",
            Indent(nIndents+1),
            "AttrID",
            "Cre.Time/Date",
            "Ver",
            "Loc.USN",
            "Originating DSA",
            "Org.USN",
            "Org.Time/Date"
            );

        Printf(
            "%s%6s%18s%6s%8s%37s%8s%18s\n",
            Indent(nIndents+1),
            "======",
            "=============",
            "===",
            "=======",
            "===============",
            "=======",
            "============="
            );

        RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &pMetaData->MetaData.usnProperty,
            10,
            sizeof( szLocalUSN ),
            szLocalUSN
            );

        DraUuidToStr(
            &pMetaData->MetaData.uuidDsaOriginating,
            szOriginatingUUID, 
            (sizeof(szOriginatingUUID)/sizeof(szOriginatingUUID[0])) );

        Printf(
            "%s%6x%18s%6d%8s%37s%8I64d%18s\n",
            Indent(nIndents+1),
            pMetaData->MetaData.attrType,
            DSTimeToDisplayString(pMetaData->timeCreated, szTime),
            pMetaData->MetaData.dwVersion,
            szLocalUSN,
            szOriginatingUUID,
            pMetaData->MetaData.usnOriginating,
            DSTimeToDisplayString(pMetaData->MetaData.timeChanged, szTime1)
            );

        FreeMemory(pMetaData);
        fSuccess = TRUE;
    }

    return(fSuccess);
}


BOOL
Dump_VALUE_META_DATA_EXT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public VALUE_META_DATA dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of VALUE_META_DATA in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                        fSuccess = FALSE;
    VALUE_META_DATA_EXT        *pMetaData = NULL;

    Printf("%sVALUE_META_DATA_EXT\n", Indent(nIndents));

    pMetaData = (VALUE_META_DATA_EXT *) ReadMemory(pvProcess,
                                                   sizeof(VALUE_META_DATA_EXT));

    if (NULL != pMetaData)
    {
        CHAR        szOriginatingUUID[ 40 ];
        CHAR        szTime[ SZDSTIME_LEN ];
        CHAR        szTime1[ SZDSTIME_LEN ];
        struct tm * ptm;

        Printf(
            "\n%s%18s%6s%37s%8s%18s\n",
            Indent(nIndents+1),
            "Cre.Time/Date",
            "Ver",
            "Originating DSA",
            "Org.USN",
            "Org.Time/Date"
            );

        Printf(
            "%s%18s%6s%37s%8s%18s\n",
            Indent(nIndents+1),
            "=============",
            "===",
            "===============",
            "=======",
            "============="
            );

        DraUuidToStr(
            &pMetaData->MetaData.uuidDsaOriginating,
            szOriginatingUUID, 
            (sizeof(szOriginatingUUID)/sizeof(szOriginatingUUID[0])) );

        Printf(
            "%s%18s%6d%37s%8I64d%18s\n",
            Indent(nIndents+1),
            DSTimeToDisplayString(pMetaData->timeCreated, szTime),
            pMetaData->MetaData.dwVersion,
            szOriginatingUUID,
            pMetaData->MetaData.usnOriginating,
            DSTimeToDisplayString(pMetaData->MetaData.timeChanged, szTime1)
            );

        FreeMemory(pMetaData);
        fSuccess = TRUE;
    }

    return(fSuccess);
}


BOOL
Dump_ENTINF(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ENTINF dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ENTINF in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL     fSuccess = FALSE;
    ENTINF   *pEntInf = NULL;
    DWORD    iCursor;

    Printf("%sENTINF\n", Indent(nIndents));

    pEntInf = (ENTINF *) ReadMemory(pvProcess, sizeof(ENTINF));

    if (NULL != pEntInf)
    {
        fSuccess = Dump_DSNAME(nIndents+1, pEntInf->pName);

        if (fSuccess)
        {
            Printf("%sulFlags: 0x%x\n", Indent(nIndents+1), pEntInf->ulFlags);

            fSuccess = Dump_AttrBlock(nIndents+1, (BYTE *) pvProcess + offsetof(ENTINF, AttrBlock));
        }

        FreeMemory(pEntInf);
    }

    return(fSuccess);
}


BOOL
Dump_ENTINFSEL(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ENTINFSEL dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ENTINFSEL in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = FALSE;
    ENTINFSEL   *pEntInfSel = NULL;
    DWORD       iCursor;

    Printf("%sENTINFSEL\n", Indent(nIndents));

    pEntInfSel = (ENTINFSEL *) ReadMemory(pvProcess, sizeof(ENTINFSEL));

    if (NULL != pEntInfSel)
    {
        Printf("%sattSel: %s\n",
               Indent(nIndents+1),
               PszSelCodeToString(pEntInfSel->attSel));

        Printf("%sinfoTypes: %s\n",
               Indent(nIndents+1),
               PszSelCodeToString(pEntInfSel->infoTypes));

        fSuccess = Dump_AttrBlock_local(
                nIndents+1,
                &(pEntInfSel->AttrTypBlock),
                FALSE);

        FreeMemory(pEntInfSel);
    }

    return fSuccess;
}


BOOL
Dump_RANGEINFSEL(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public RANGEINFSEL dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of RANGEINFSEL in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = FALSE;
    RANGEINFSEL *pRangeInfSel = NULL;
    DWORD       iCursor=0;
    RANGEINFOITEM *pInfo = NULL;

    Printf("%sRANGEINFSEL\n", Indent(nIndents));

    pRangeInfSel = (RANGEINFSEL *) ReadMemory(pvProcess, sizeof(RANGEINFSEL));

    if (NULL != pRangeInfSel)
    {
        Printf("%svalueLimit: %d\n",
               Indent(nIndents+1),
               pRangeInfSel->valueLimit);

        Printf("%sranges [%d]:\n",Indent(nIndents+1),pRangeInfSel->count);
        if(pRangeInfSel->count) {
            pInfo =
                (RANGEINFOITEM *)ReadMemory(
                        pvProcess,
                        min(50,pRangeInfSel->count) * sizeof(RANGEINFOITEM));
            if(pInfo) {
                while(iCursor < 50 && iCursor < pRangeInfSel->count) {
                    Printf("%sATT %d = %d - %d\n",
                           Indent(nIndents+1),
                           pInfo->AttId,
                           pInfo->lower,
                           pInfo->upper);
                    iCursor++;
                }
                if(iCursor == 50 && iCursor < pRangeInfSel->count) {
                    Printf("%sMore not shown.\n",Indent(nIndents+1));
                }
                FreeMemory(pInfo);
            }
        }

        FreeMemory(pRangeInfSel);
    }

    return fSuccess;
}


BOOL
Dump_REPLENTINFLIST(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public REPLENTINFLIST dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLENTINFLIST in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    REPLENTINFLIST  *pReplEntInfList = NULL;

    Printf("%sREPLENTINFLIST\n", Indent(nIndents));

    pReplEntInfList = (REPLENTINFLIST *) ReadMemory(pvProcess, sizeof(REPLENTINFLIST));

    if (NULL != pReplEntInfList)
    {
        Printf("%spNextEntInf: @ 0x%x\n", Indent(nIndents+1), pReplEntInfList->pNextEntInf);

        fSuccess = Dump_ENTINF(nIndents+1, ((BYTE *) pvProcess + offsetof(REPLENTINFLIST, Entinf)));

        if (fSuccess)
        {
            fSuccess = Dump_PROPERTY_META_DATA_EXT_VECTOR(nIndents+1, pReplEntInfList->pMetaDataExt);
        }

        FreeMemory(pReplEntInfList);
    }

    return fSuccess;
}


BOOL
Dump_REPLVALINF(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public REPLVALINF dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLVALINF in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    REPLVALINF     *pReplValInf = NULL;
    UCHAR          *pVal = NULL;

    Printf("%sREPLVALINF @ %p\n", Indent(nIndents), pvProcess);

    pReplValInf = (REPLVALINF *) ReadMemory(pvProcess, sizeof(REPLVALINF));

    if (NULL != pReplValInf)
    {
        // pObject
        Dump_DSNAME(nIndents, pReplValInf->pObject);
        // attrtyp
        Printf("%sAttr type:            0x%x\n",
               Indent(nIndents),  pReplValInf->attrTyp);
        // Aval
        Printf("%sAVal: @ %p, len 0x%x\n", Indent(nIndents+1),
               pReplValInf->Aval.pVal, pReplValInf->Aval.valLen);

        pVal = (UCHAR *) ReadMemory(pReplValInf->Aval.pVal, pReplValInf->Aval.valLen);
        if (NULL != pVal) {
            // I need a way to know which attributes have which syntax. The only syntaxes
            // possible in this context are the DSNAME based ones. Of those, only a handfull
            // at present are DB-BINARY ones. We use a hardcoded list for these.
            // Note the use of "local" dump routines at this point since the blob
            // is now in local memory.
            switch (pReplValInf->attrTyp) {
            case ATT_MS_DS_HAS_INSTANTIATED_NCS:
            case ATT_MS_DS_REPLICATES_NC_REASON:
            case ATT_OTHER_WELL_KNOWN_OBJECTS:
            case ATT_PROXIED_OBJECT_NAME:
            case ATT_WELL_KNOWN_OBJECTS:
            {
                // SYNTAX_DISTNAME_BINARY_TYPE
                SYNTAX_DISTNAME_STRING *pDA =
                    (SYNTAX_DISTNAME_STRING *)pVal;

                if (pReplValInf->Aval.valLen >= NAME_DATA_SIZE(pDA))
                {
                    DSNAME *pDN = NAMEPTR( pDA );
                    SYNTAX_ADDRESS *pSA = DATAPTR( pDA );

                    // Make sure value is good
                    if (pDN->structLen >= DSNameSizeFromLen(0)) {
                        Dump_DSNAME_local( nIndents + 1, pDN );
                    } else {
                        Printf( "invalid DSNAME, too short\n" );
                    }
                    Printf("%sDATA: len 0x%x\n", Indent(nIndents+1), pSA->structLen );
                    ShowBinaryData( nIndents, pSA->uVal, pSA->structLen );
                } else {
                    Printf( "invalid DSNAME_BINARY, too short\n" );
                }

                break;
            }
            default:
            {
                // SYNTAX_DISTNAME_TYPE
                DSNAME *pDN = (DSNAME *)pVal;
                if ( (pReplValInf->Aval.valLen >= pDN->structLen) &&
                     (pDN->structLen >= DSNameSizeFromLen(0)) ) {
                    Dump_DSNAME_local( nIndents + 1, pDN );
                } else {
                    Printf( "invalid DSNAME, too short\n" );
                }
            }
            }
            FreeMemory(pVal);
        }
        // fIsPresent
        Printf("%sIsPresent             0x%x\n",
               Indent(nIndents), pReplValInf->fIsPresent);
        // ValueMetaData
        fSuccess = Dump_VALUE_META_DATA_EXT(nIndents+1,
                     ((PBYTE) pvProcess) + offsetof( REPLVALINF, MetaData )  );

        FreeMemory(pReplValInf);
    }

    return fSuccess;
}


char *PszSelCodeToString(UCHAR ch)
/*++

Routine Description:

    This routine returns the string form of attribute selection code
    corresponding to the given character code.

Arguments:

    ch - character code for the type of attribute selection

Return Value:

    String corresponding to the code, or "Unknown Selection Code" if
    the given selection code is unknown.

--*/

{
    DWORD i;

    for (i = 0; i < cAttrSelectionCode; i++)
    {
        if (ch == rAttrSelectionCode[i].chCode)
            return rAttrSelectionCode[i].pszCode;
    }

    return UNKNOWN_SELECTION_CODE;

}

BOOL
Dump_REPLICA_LINK(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )

/*++

Routine Description:

    Public REPLICA_LINK dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLICA_LINK in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    static struct
    {
        DWORD dw;
        LPSTR psz;
    } rgFlags[] =   {
                        { DRS_INIT_SYNC            , "INIT_SYNC"             },
                        { DRS_PER_SYNC             , "PER_SYNC"              },
                        { DRS_WRIT_REP             , "WRIT_REP"              },
                        { DRS_MAIL_REP             , "MAIL_REP"              },
                        { DRS_DISABLE_AUTO_SYNC    , "DISABLE_AUTO_SYNC"     },
                        { DRS_DISABLE_PERIODIC_SYNC, "DISABLE_PERIODIC_SYNC" },
                        { DRS_FULL_SYNC_IN_PROGRESS, "FULL_SYNC_IN_PROGRESS" },
                        { DRS_FULL_SYNC_PACKET     , "FULL_SYNC_PACKET"      },
                        { DRS_USE_COMPRESSION      , "USE_COMPRESSION"       },
                        { DRS_NEVER_NOTIFY         , "NEVER_NOTIFY"          },
                        { DRS_NEVER_SYNCED         , "NEVER_SYNCED"          },
                        { DRS_TWOWAY_SYNC          , "TWOWAY_SYNC"           },
                        { DRS_SYNC_PAS             , "SYNC_PAS"              },
                        { 0,                         NULL                    }
                    };

    static LPCSTR rgpszDays[] =
    { "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT" };

    static UUID uuidNull = { 0 };

    BOOL            fSuccess = FALSE;
    REPLICA_LINK *  prl;
    DWORD           dwFlags;
    DWORD           iFlag;
    CHAR            szTime[ SZDSTIME_LEN ];
    struct tm *     ptm;
    DWORD           cb;

    prl = (REPLICA_LINK *) ReadMemory( pvProcess, offsetof( REPLICA_LINK, V1.cb ) + sizeof( DWORD ) );

    if ( NULL != prl && VERSION_V1 == prl->dwVersion)
    {
        cb = prl->V1.cb;
        FreeMemory( prl );

        prl = (REPLICA_LINK *) ReadMemory( pvProcess, cb );

        if ( NULL != prl )
        {
            Printf( "%sREPLICA_LINK (Version 1)\n", Indent( nIndents ) );

            cb = sizeof( *prl ) + prl->V1.cbOtherDra;
            if ( prl->V1.cbPASDataOffset ) {
                // calc alignment offset
                cb += prl->V1.cbPASDataOffset - (prl->V1.cbOtherDraOffset + prl->V1.cbOtherDra);
                // and PAS struct contents
                cb += RL_PPAS_DATA(prl)->size;
            }

            if ( prl->V1.cb != cb )
            {
                Printf( "%s!! ReplicaLink length is invalid -- %d != %d  !!\n",
                        Indent( nIndents ), prl->V1.cb, cb);
            }

            if ( prl->V1.cbOtherDraOffset != offsetof( REPLICA_LINK, V1.rgb ) )
            {
                Printf( "%s!! ReplicaLink Other-DRA-Offset is invalid -- %d != %d !!\n",
                        Indent( nIndents ), prl->V1.cbOtherDraOffset, offsetof( REPLICA_LINK, V1.rgb ) );
            }

            //
            // Display server name.
            //

            Printf( "%s%s\n", Indent( nIndents + 2 ), RL_POTHERDRA( prl )->mtx_name );


            //
            // Display DSA objectGuid.
            //

            Printf( "%snstdDsa objectGuid:   ", Indent( nIndents + 2 ) );

            Printf( "%s\n", DraUuidToStr( &prl->V1.uuidDsaObj, NULL, 0 ) );

            if (memcmp(&prl->V1.uuidInvocId, &uuidNull, sizeof(UUID))) {
                //
                // Display DSA invocationId.
                //

                Printf( "%snstdDsa invocationId: ", Indent( nIndents + 2 ) );

                Printf( "%s\n", DraUuidToStr( &prl->V1.uuidInvocId, NULL, 0 ) );
            }

            //
            // Display replica flags.
            //

            Printf( "%s", Indent( nIndents + 2 ) );

            dwFlags = prl->V1.ulReplicaFlags;

            for ( iFlag = 0; NULL != rgFlags[ iFlag ].psz; iFlag++ )
            {
                if ( dwFlags & rgFlags[ iFlag ].dw )
                {
                    Printf( "%s ", rgFlags[ iFlag ].psz );
                    dwFlags &= ~rgFlags[ iFlag ].dw;
                }
            }

            if ( dwFlags )
            {
                Printf( "0x%X", dwFlags );
            }

            Printf( "\n" );


            if ( prl->V1.ulReplicaFlags & DRS_PER_SYNC )
            {
                DWORD   iDay;
                DWORD   ib;

                //
                // Display schedule.
                //

                Printf( "%sPeriodic schedule:\n", Indent( nIndents + 2 ) );
                for ( iDay = 0; iDay < 7; iDay++ )
                {
                    Printf( "%s%s ", Indent( nIndents + 4 ), rgpszDays[ iDay ] );

                    for ( ib = 0; ib < 12; ib++ )
                    {
                        Printf( " %02x", prl->V1.rtSchedule.rgTimes[ iDay * 12 + ib ] );
                    }

                    Printf( "\n" );
                }
            }


            //
            // Display USNs.
            //

            Printf("%sUSNs: %I64d/OU, %I64d/PU\n",
                   Indent( nIndents + 2 ),
                   prl->V1.usnvec.usnHighObjUpdate,
                   prl->V1.usnvec.usnHighPropUpdate);

            //
            // Display status and time of last replication attempt.
            //

            Printf("%sLast attempt %s, result %d.\n",
                   Indent(nIndents + 2),
                   DSTimeToDisplayString(prl->V1.timeLastAttempt, szTime),
                   prl->V1.ulResultLastAttempt);


            //
            // Display time of last successful replication.
            //

            Printf("%sLast success %s.\n",
                   Indent( nIndents + 2 ),
                   DSTimeToDisplayString(prl->V1.timeLastSuccess, szTime));


            Printf( "%s%u consecutive failure(s).\n", Indent(nIndents + 2), prl->V1.cConsecutiveFailures );


//          Printf( "%s dwReserved1: 0x%x\n", Indent(nIndents + 2), prl->V1.dwReserved1 );
            Printf( "%s PAS Data offset: %u\n", Indent(nIndents + 2), prl->V1.cbPASDataOffset);
            if ( prl->V1.cbPASDataOffset) {
                Printf( "%sPAS Data:\n", Indent(nIndents + 2));
                Printf( "%sversion: %d\n", Indent(nIndents + 3), RL_PPAS_DATA(prl)->version );
                Printf( "%ssize: %lu\n", Indent(nIndents + 3), RL_PPAS_DATA(prl)->size );
                Printf( "%sflag: %lu\n", Indent(nIndents + 3), RL_PPAS_DATA(prl)->flag );
                Printf( "%sPARTIAL_ATTR_VECTOR: %d attrs\n",
                        Indent(nIndents + 3),
                        RL_PPAS_DATA(prl)->PAS.V1.cAttrs );
            }


            FreeMemory( prl );
            fSuccess = TRUE;
        }
    }

    return fSuccess;
}

BOOL
Dump_CreateNcInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public CREATENCINFO struct dump routine.  Note really needed, but just to follow suit.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of CREATENCINFO in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = FALSE;
    CREATENCINFO *  pCreateNC;

    pCreateNC = ReadMemory(pvProcess, sizeof(CREATENCINFO));
    if (!pCreateNC) {
        return FALSE;
    }

    Printf("%sCreateNcInfo Struct Object:\n",
           Indent(nIndents));

    if(pCreateNC){
        Printf("%siKind = %X\n", Indent(nIndents), pCreateNC->iKind);
        Printf("%sfNcAbove = %s\n", Indent(nIndents),
               (pCreateNC->fNcAbove) ? "TRUE" : "FALSE");
        Printf("%sfTestAdd = %s\n", Indent(nIndents),
               (pCreateNC->fTestAdd) ? "TRUE" : "FALSE");
        Printf("%sfNullNcGuid = %s\n", Indent(nIndents),
               (pCreateNC->fNullNcGuid) ? "TRUE" : "FALSE");
        Printf("%sfSetRefDom = %s\n", Indent(nIndents),
               (pCreateNC->fSetRefDom) ? "TRUE" : "FALSE");

        if(pCreateNC->pSDRefDomCR){
            Printf("%spSDRefDomCR @ %p\n", Indent(nIndents), pCreateNC->pSDRefDomCR);
        }
    }

    FreeMemory(pCreateNC);

    return TRUE;

}

BOOL
Dump_CrossRefInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public ADDCROSSREFINFO struct dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ADDCROSSREFINFO in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = FALSE;
    ADDCROSSREFINFO *  pCRInfo;

    pCRInfo = ReadMemory(pvProcess, sizeof(ADDCROSSREFINFO));
    if (!pCRInfo) {
        return FALSE;
    }

    Printf("%sAddCrossRefInfo Struct Object:\n",
           Indent(nIndents));

    Printf("%spNCName @ %p\n", Indent(nIndents), pCRInfo->pdnNcName);
    Printf("%sbEnabled = %X\n", Indent(nIndents), pCRInfo->bEnabled);
    Printf("%sulSysFlags = %ul\n", Indent(nIndents), pCRInfo->ulSysFlags);

    Printf("%sulDsCrackChild = %X\n", Indent(nIndents), pCRInfo->ulDsCrackChild);
    Printf("%sulChildCheck = %X\n", Indent(nIndents), pCRInfo->ulChildCheck);
    Printf("%swszChildCheck @ %p\n", Indent(nIndents), pCRInfo->wszChildCheck);

    Printf("%sulDsCrackParent = %X\n", Indent(nIndents), pCRInfo->ulDsCrackParent);
    Printf("%sulParentCheck = %X\n", Indent(nIndents), pCRInfo->ulParentCheck);
    Printf("%sGuid: %s\n", Indent(nIndents), DraUuidToStr(&(pCRInfo->ParentGuid), NULL, 0));

    FreeMemory(pCRInfo);

    return TRUE;
}

BOOL
Dump_AddArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public addarg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of Addarg in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    ADDARG        * pAddArg;

    pAddArg = ReadMemory(pvProcess, sizeof(ADDARG));
    if (!pAddArg) {
        return FALSE;
    }

    Printf("%sAddArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pAddArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pAddArg->CommArg);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents),
           pAddArg->pMetaDataVecRemote);

    fSuccess = Dump_AttrBlock(nIndents+1,
                              (BYTE *) pvProcess + offsetof(ADDARG, AttrBlock));

    Printf("%sResolved parent object:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pAddArg->pResParent));

    Printf("%spCreateNC: @ %p\n", Indent(nIndents), pAddArg->pCreateNC);
    if (pAddArg->pCreateNC) {
        Dump_CreateNcInfo(nIndents+1, (PVOID) (pAddArg->pCreateNC));
    }

    Printf("%spCRInfo: @ %p\n", Indent(nIndents), pAddArg->pCRInfo);
    if(pAddArg->pCRInfo){
        Dump_CrossRefInfo(nIndents+1, (PVOID) (pAddArg->pCRInfo));
    }

    FreeMemory(pAddArg);

    return TRUE;
}

BOOL
Dump_AddRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ADDRES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ADDRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ADDRES *pAddRes;

    Printf("%sADDRES", Indent(nIndents));
    nIndents++;

    if (NULL == (pAddRes = ReadMemory(pvProcess, sizeof(ADDRES)))) {
        return FALSE;
    }

    Printf("%sAlias dereferenced: %s\n",
           Indent(nIndents),
           pAddRes->CommRes.aliasDeref ? "yes" : "no");

    Dump_Error(nIndents,
               pAddRes->CommRes.errCode,
               pAddRes->CommRes.pErrInfo);

    FreeMemory(pAddRes);

    return TRUE;
}

BOOL
Dump_SearchArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SEARCHARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SEARCHARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    SEARCHARG       * pSearchArg;

    pSearchArg = ReadMemory(pvProcess, sizeof(SEARCHARG));
    if (!pSearchArg) {
        return FALSE;
    }

    Printf("%sSearchArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pSearchArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    switch(pSearchArg->choice) {
    case SE_CHOICE_BASE_ONLY:
        Printf("%sScope: Base Object\n",Indent(nIndents));
        break;
    case SE_CHOICE_IMMED_CHLDRN:
        Printf("%sScope: One Level\n",Indent(nIndents));
        break;
    case SE_CHOICE_WHOLE_SUBTREE:
        Printf("%sScope: Whole Subtree\n",Indent(nIndents));
        break;
    default:
        Printf("%sScope: invalid %d\n",Indent(nIndents),pSearchArg->choice);
        break;
    }

    Printf("%sRestrict to NC: %s\n",
           Indent(nIndents),
           (pSearchArg->bOneNC ? "TRUE" : "FALSE"));

    Printf("%sSearchArg Filter:\n",Indent(nIndents));
    fSuccess = Dump_FILTER(nIndents+1,pSearchArg->pFilter);

    Printf("%sSearch Aliases NC: %s\n",
           Indent(nIndents),
           (pSearchArg->searchAliases ? "TRUE" : "FALSE"));

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pSearchArg->CommArg);


    fSuccess = Dump_ENTINFSEL(nIndents+1,
                              pSearchArg->pSelection);


    fSuccess = Dump_RANGEINFSEL(nIndents+1,
                                pSearchArg->pSelectionRange);

    Printf("%sResolved search base:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pSearchArg->pResObj));

    FreeMemory(pSearchArg);

    return fSuccess;
}

BOOL
Dump_SearchRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SEARCHRES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SEARCHRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = TRUE;
    SEARCHRES * pSearchRes;

    Printf("%sSEARCHRES\n", Indent(nIndents));
    nIndents++;

    pSearchRes = ReadMemory(pvProcess, sizeof(SEARCHRES));
    if (!pSearchRes) {
        return FALSE;
    }

    Printf("%sBase object:\n", Indent(nIndents));
    if (pSearchRes->pBase) {
        fSuccess = Dump_DSNAME(nIndents+1, pSearchRes->pBase);
    }
    else {
        Printf("%s(NULL)\n", Indent(nIndents+1));
    }

    if (fSuccess) {
        Printf("%sbaseProvided               0x%x\n",
               Indent(nIndents), pSearchRes->baseProvided);
        Printf("%sbSorted                    0x%x\n",
               Indent(nIndents), pSearchRes->bSorted);
        Printf("%scount                      %d (0x%x)\n",
               Indent(nIndents), pSearchRes->count, pSearchRes->count);

        Printf("%sFirstEntInf              @ %p\n",
               Indent(nIndents),
               (BYTE *) pvProcess + offsetof(SEARCHRES, FirstEntInf));

        Printf("%sFirstRangeInf            @ %p\n",
               Indent(nIndents),
               (BYTE *) pvProcess + offsetof(SEARCHRES, FirstRangeInf));

        Printf("%spPartialOutcomeQualifier @ %p\n",
               Indent(nIndents),
               pSearchRes->pPartialOutcomeQualifier);

        Printf("%sPagedResult              @ %p\n",
               Indent(nIndents),
               (BYTE *) pvProcess + offsetof(SEARCHRES, PagedResult));

        Dump_CommRes(nIndents,
                     (BYTE *) pvProcess + offsetof(SEARCHRES, CommRes));
    }

    return fSuccess;
}

BOOL
Dump_ReadArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public READARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of READARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    READARG       * pReadArg;

    pReadArg = ReadMemory(pvProcess, sizeof(READARG));
    if (!pReadArg) {
        return FALSE;
    }

    Printf("%sReadArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pReadArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pReadArg->CommArg);


    fSuccess = Dump_ENTINFSEL(nIndents+1,
                              pReadArg->pSel);

    Printf("%sResolved object:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pReadArg->pResObj));

    FreeMemory(pReadArg);

    return fSuccess;
}

BOOL
Dump_ReadRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public READRES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of READRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL fSuccess;

    Printf("%sREADRES\n", Indent(nIndents));
    nIndents++;

    /* ENTINF */
    fSuccess = Dump_ENTINF( nIndents, ((BYTE *) pvProcess + offsetof( READRES, entry )));
    /* COMMRES */
    if (fSuccess) {
        Dump_CommRes( nIndents, ((BYTE *) pvProcess + offsetof( READRES, CommRes )));
    }

    return fSuccess;
}

BOOL
Dump_RemoveArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public removearg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of removearg in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = FALSE;
    REMOVEARG * pRemoveArg;

    pRemoveArg = ReadMemory(pvProcess, sizeof(REMOVEARG));
    if (!pRemoveArg) {
        return FALSE;
    }

    Printf("%sRemoveArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pRemoveArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pRemoveArg->CommArg);

    Printf("%sfPreserveRDN         0x%x\n",
           Indent(nIndents),
           pRemoveArg->fPreserveRDN);

    Printf("%sfGarbCollectASAP     0x%x\n",
           Indent(nIndents),
           pRemoveArg->fGarbCollectASAP);

    Printf("%sfTreeDelete          0x%x\n",
           Indent(nIndents),
           pRemoveArg->fTreeDelete);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents),
           pRemoveArg->pMetaDataVecRemote);

    Printf("%sResolved object:\n", Indent(nIndents));
    fSuccess = Dump_RESOBJ(nIndents+1,
                           (PVOID)(pRemoveArg->pResObj));

    FreeMemory(pRemoveArg);

    return fSuccess;
}

BOOL
Dump_RemoveRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public REMOVERES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REMOVERES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    REMOVERES * pRemoveRes;

    Printf("%sREMOVERES", Indent(nIndents));
    nIndents++;

    if (NULL == (pRemoveRes = ReadMemory(pvProcess, sizeof(REMOVERES)))) {
        return FALSE;
    }

    Dump_Error(nIndents,
               pRemoveRes->CommRes.errCode,
               pRemoveRes->CommRes.pErrInfo);

    FreeMemory(pRemoveRes);

    return TRUE;
}

BOOL
Dump_FILTER(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public FILTER dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of FILTER in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    FILTER          *pFilter;
    USHORT          i;
    SUBSTRING       *pSubStr;
    ANYSTRINGLIST   *pAny;
    BOOLEAN         bogus = FALSE;


    Printf("%sFILTER @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if (NULL == (pFilter = ReadMemory(pvProcess, sizeof(FILTER)))) {
        return FALSE;
    }

    switch ( pFilter->choice )
    {
    case FILTER_CHOICE_ITEM:

        Printf("%sFILTER_CHOICE_ITEM\n", Indent(nIndents));
        nIndents++;

        switch ( pFilter->FilterTypes.Item.choice )
        {
        case FI_CHOICE_EQUALITY:

            Printf("%sFI_CHOICE_EQUALITY - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_SUBSTRING:

            Printf("%sFI_CHOICE_SUBSTRING\n", Indent(nIndents));
            Dump_SUBSTRING(nIndents+1,
                           pFilter->FilterTypes.Item.FilTypes.pSubstring);
            break;

        case FI_CHOICE_GREATER:

            Printf("%sFI_CHOICE_GREATER - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_GREATER_OR_EQ:

            Printf("%sFI_CHOICE_GREATER_OR_EQ - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_LESS:

            Printf("%sFI_CHOICE_LESS - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_LESS_OR_EQ:

            Printf("%sFI_CHOICE_LESS_OR_EQ - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_NOT_EQUAL:

            Printf("%sFI_CHOICE_NOT_EQUAL - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_PRESENT:

            Printf("%sFI_CHOICE_PRESENT - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.present);

            break;

        case FI_CHOICE_TRUE:

            Printf("%sFI_CHOICE_TRUE\n", Indent(nIndents));
            break;

        case FI_CHOICE_FALSE:

            Printf("%sFI_CHOICE_FALSE\n", Indent(nIndents));
            break;

        case FI_CHOICE_BIT_AND:

            Printf("%sFI_CHOICE_BIT_AND - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_BIT_OR:

            Printf("%sFI_CHOICE_BIT_OR - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        default:
            Printf("%s*** Unknown choice 0x%x\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.choice);
            bogus = TRUE;
            break;

        }

        Printf("%sExpected Size %d\n", Indent(nIndents), pFilter->FilterTypes.Item.expectedSize);

        nIndents--;
        break;

    case FILTER_CHOICE_AND:

        Printf("%sFILTER_CHOICE_AND[0x%x]\n",
               Indent(nIndents),
               pFilter->FilterTypes.And.count);
        Dump_FILTER(nIndents+1, pFilter->FilterTypes.And.pFirstFilter);

        break;

    case FILTER_CHOICE_OR:

        Printf("%sFILTER_CHOICE_OR[0x%x]\n",
               Indent(nIndents),
               pFilter->FilterTypes.Or.count);
        Dump_FILTER(nIndents+1, pFilter->FilterTypes.Or.pFirstFilter);

        break;

    case FILTER_CHOICE_NOT:

        Printf("%sFILTER_CHOICE_NOT\n", Indent(nIndents));
        Dump_FILTER(nIndents+1, pFilter->FilterTypes.pNot);
        break;

    case FI_CHOICE_UNDEFINED:
        Printf("%sFILTER_CHOICE_UNDEFINED\n", Indent(nIndents));
        break;

    default:

        Printf("%s*** Unknown choice 0x%x\n",
               Indent(nIndents),
               pFilter->choice);
        bogus = TRUE;
        break;
    }

    nIndents--;

    if ( NULL != pFilter->pNextFilter) {
        if (bogus) {
            Printf("%sIgnoring supposed next filter @ %p\n",
                   Indent(nIndents),
                   pFilter->pNextFilter);
        }
        else {
            Dump_FILTER(nIndents, pFilter->pNextFilter);
        }
    }

    FreeMemory(pFilter);

    return(TRUE);
}

BOOL
Dump_SUBSTRING(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SUBSTRING dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SUBSTRING in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    USHORT          i;
    SUBSTRING       *pSubStr;
    ANYSTRINGLIST   *pAnyAddr;
    ANYSTRINGLIST   *pAny;

    Printf("%sSUBSTRING @ %p\n", Indent(nIndents), pvProcess);

    if ( NULL == (pSubStr = ReadMemory(pvProcess, sizeof(SUBSTRING))) )
        return(FALSE);

    Printf("%sATTRTYP(0x%x)\n",
           Indent(nIndents),
           pSubStr->type);

    Printf("%sinitialProvided(0x%x)\n",
           Indent(nIndents),
           pSubStr->initialProvided);

    if ( pSubStr->initialProvided )
        Dump_BinaryCount(nIndents+1,
                         pSubStr->InitialVal.pVal,
                         pSubStr->InitialVal.valLen);

    pAny = &pSubStr->AnyVal.FirstAnyVal;

    for ( i = 0; i < pSubStr->AnyVal.count; i++ )
    {
        Printf("%sAnyVal[%d]\n", Indent(nIndents), i);
        if ( 0 != i )
            if ( NULL == (pAny = ReadMemory(pAnyAddr, sizeof(ANYSTRINGLIST))) )
                break;
        Dump_BinaryCount(nIndents+1, pAny->AnyVal.pVal, pAny->AnyVal.valLen);
        pAnyAddr = pAny->pNextAnyVal;
        if ( 0 != i )
            FreeMemory(pAny);
    }

    Printf("%sfinalProvided(0x%x)\n",
           Indent(nIndents),
           pSubStr->finalProvided);

    if ( pSubStr->finalProvided )
        Dump_BinaryCount(nIndents+1,
                         pSubStr->FinalVal.pVal,
                         pSubStr->FinalVal.valLen);

    FreeMemory(pSubStr);

    return(TRUE);
}

BOOL
Dump_LOCALDNREADCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public LOCALDNREADCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of LOCALDNREADCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                    fSuccess = FALSE;
    LOCALDNREADCACHE  *     pDNReadCache = NULL;
    BYTE *                  pb;
    DWORD                   i,j;
    UUID                    uuidNull = { 0 };
    WCHAR                   *pName=NULL;
    Printf("%sLOCALDNREADCACHE\n", Indent( nIndents ) );
    nIndents += 2;

    pDNReadCache = (LOCALDNREADCACHE *)ReadMemory(pvProcess, sizeof(LOCALDNREADCACHE));

    if(!pDNReadCache) {
        Printf("%sFAILED TO READ DATA\n",Indent(nIndents));
    }
    else {
        Printf("%sSlot\tDNT\tHashKey\tpName\tHits\n",
               Indent(nIndents));
        for(i=0;i<LOCALDNREADCACHE_BUCKET_NUM;i++) {
            Printf("%sBucket %d:\n",Indent(nIndents),i);
            // First, the slots
            if(!pDNReadCache->bucket[i].rgDNT[0]) {
                Printf("%sEmpty\n",Indent(nIndents));
            }
            else {
                BOOL fFoundUnused = FALSE;

                for(j=0;j<LOCALDNREADCACHE_SLOT_NUM;j++) {
                    switch(pDNReadCache->bucket[i].rgDNT[j]) {
                    case 0:
                        // slot is empty
                        Printf("%s%d\tUNUSED\n",
                               Indent(nIndents),
                               j);
                        fFoundUnused = TRUE;
                        break;
                    case INVALIDDNT:
                        // Empty slot (used to have a value in it).
                        Printf("%s%d\tEMPTY\n",
                               Indent(nIndents),
                               j);
                        break;

                    default:
                        // Normally full slot.
                        Printf("%s%d\t0x%x\t0x%x\t@0x%x\t%d\n",
                               Indent(nIndents),
                               j,
                               pDNReadCache->bucket[i].rgDNT[j],
                               pDNReadCache->bucket[i].rgdwHashKey[j],
                               pDNReadCache->bucket[i].slot[j].pName,
                               pDNReadCache->bucket[i].slot[j].hitCount
                               );
                        if(fFoundUnused) {
                            // We've already found a never used slot.  This
                            // shouldn't happen.
                            Printf("%s\tERROR! full slot found after UNUSED!\n",
                                   Indent(nIndents));
                        }
                    }
                }

                Printf("%sNext Slot:  %d\n",
                    Indent(nIndents),
                    pDNReadCache->nextSlot[i]);
            }
        }

        FreeMemory( pDNReadCache );
    }

    return ( NULL == pDNReadCache );
}

BOOL
Dump_GLOBALDNREADCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public LOCALDNREADCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of LOCALDNREADCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    GLOBALDNREADCACHE    *pGlobalDNReadCache = NULL;
    PSDCACHE_ENTRY       *pSDHashTable = NULL;
    GLOBALDNREADCACHESLOT  * pData=NULL;
    DWORD           i,j;
    UUID            uuidNull = { 0 };
    WCHAR          *pName=NULL;

    Printf("%sGLOBALDNREADCACHE\n", Indent( nIndents ) );
    nIndents += 2;

    pGlobalDNReadCache = (GLOBALDNREADCACHE *)
        ReadMemory( pvProcess, sizeof( GLOBALDNREADCACHE ) );

    if(!pGlobalDNReadCache) {
        Printf("%sFAILED TO READ DATA\n",Indent(nIndents));
    }
    else {
        Printf("%s%d elements:\n",Indent(nIndents), pGlobalDNReadCache->count);
        Printf("%s  at 0x%x\n",Indent(nIndents), pGlobalDNReadCache->pData);
        pData = (GLOBALDNREADCACHESLOT *)
            ReadMemory(
                    pGlobalDNReadCache->pData,
                    pGlobalDNReadCache->count * sizeof(GLOBALDNREADCACHESLOT));

        if(!pData) {
            Printf("%sFAILED TO READ DATA\n",Indent(nIndents));
        }
        else {
            for(i=0;i < pGlobalDNReadCache->count;i++) {
                d_memname * pmemname = &pData[i].name;

                if(pData[i].valid) {
                    Printf("%s%03d:   VALID",Indent(nIndents), i);
                }
                else {
                    Printf("%s%03d: INVALID",Indent(nIndents), i);
                }
                Printf(
                       " DNT:0x%x  PDNT:0x%x  rdntype:0x%x  (%s)\n",
                       pmemname->DNT,
                       pmemname->tag.PDNT,
                       pmemname->tag.rdnType,
                       pmemname->objflag ? "OBJECT" : "PHANTOM"
                       );


                Printf( "%s", Indent(nIndents) );
                pName = ReadMemory( pmemname->tag.pRdn,
                                   pmemname->tag.cbRdn);
                if(pName) {
                    for ( j = 0;
                         j < pmemname->tag.cbRdn / sizeof( WCHAR ); j++ ) {
                        Printf( "%C", pName[j]);
                    }
                    FreeMemory(pName);
                }
                else {
                    Printf("%s Unavailable RDN",Indent(nIndents));
                    j=15;
                }
                if ( j < 20 ) {
                    CHAR szSpaces[ 21 ];

                    memset( szSpaces, ' ', sizeof( szSpaces ) - 1 );
                    szSpaces[ sizeof( szSpaces ) - 1 ] = '\0';

                    Printf( &szSpaces[ j ] );
                }
                if ( !memcmp( &pmemname->Guid, &uuidNull, sizeof( GUID ) ) ) {
                    Printf( " (NULL GUID)\n" );
                }
                else {
                    Printf( " (GUID %s)\n",
                            DraUuidToStr( &pmemname->Guid, NULL, 0 ) );
                }
                Printf( "%shash (%x)      ", Indent(nIndents), pData[i].dwHashKey );
                Printf( "SDID %016lx\n\n", pmemname->sdId);
            }
            FreeMemory(pData);
        }

        Printf("%sSD hash table size: %d\n",Indent(nIndents), pGlobalDNReadCache->sdHashTableSize);
        if (pGlobalDNReadCache->pSDHashTable) {
            pSDHashTable = (PSDCACHE_ENTRY*)ReadMemory(pGlobalDNReadCache->pSDHashTable, 
                                                       pGlobalDNReadCache->sdHashTableSize*sizeof(PSDCACHE_ENTRY));
            if (!pSDHashTable) {
                Printf("%sFAILED TO READ HASH TABLE\n",Indent(nIndents));
            }
            else {
                for (i = 0; i < pGlobalDNReadCache->sdHashTableSize; i++) {
                    PSDCACHE_ENTRY pEntry, pEntryData;
                    pEntry = pSDHashTable[i];
                    while (pEntry != NULL) {
                        // read actual memory
                        pEntryData = (PSDCACHE_ENTRY)ReadMemory(pEntry, sizeof(SDCACHE_ENTRY));
                        if (!pEntryData) {
                            Printf("%sFAILED TO READ HASH TABLE ENTRY\n",Indent(nIndents));
                            break;
                        }
                        Printf("%sSDID: %016lx, ", Indent(nIndents), pEntryData->sdID);
                        Printf("pSD: %p, ", (PBYTE)pEntry + offsetof(SDCACHE_ENTRY, SD));
                        Printf("cbSD: %4d bytes\n", pEntryData->cbSD);
                        pEntry = pEntryData->pNext;
                        FreeMemory(pEntryData);
                    }
                }
                FreeMemory(pSDHashTable);
            }
        }


        FreeMemory( pGlobalDNReadCache );
    }

    return ( NULL == pGlobalDNReadCache );
}

BOOL
Dump_BHCache(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public BHCache dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of BHCache in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    static struct
    {
        DWORD   dw;
        CHAR *  psz;
    } rgExtensions[] =  {
                          { DRS_EXT_BASE, "BASE" },
                          { DRS_EXT_ASYNCREPL, "Asyncronous replication" },
                          { DRS_EXT_REMOVEAPI, "Remove Server/Domain" } ,
                          { DRS_EXT_MOVEREQ_V2, "InterNCMove version 2" },
                          { DRS_EXT_GETCHG_COMPRESS, "GetChReply v2" },
                          { DRS_EXT_DCINFO_V1, "DS_DOMAIN_CONTROLLER_INFO_1" },
                          { DRS_EXT_STRONG_ENCRYPTION, "Strong encryption"},
                          { DRS_EXT_ADDENTRY, "Remoted AddEntry (OLD)" },
                          { DRS_EXT_KCC_EXECUTE, "KCC Execute" },
                          { DRS_EXT_DCINFO_V2, "DS_DOMAIN_CONTROLLER_INFO_2" },
                          { DRS_EXT_DCINFO_VFFFFFFFF, "DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF" },
                          { DRS_EXT_ADDENTRY_V2, "Remoted AddEntry V2" },
                          { DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD, "InstType not req on mod" },
                          { DRS_EXT_GET_REPL_INFO, "GetReplInfo" },
                          { DRS_EXT_TRANSITIVE_MEMBERSHIP, "Transitive group Membership" },
                          { DRS_EXT_ADD_SID_HISTORY, "Add SID History" },
                          { DRS_EXT_POST_BETA3, "Post beta 3" },
                          { DRS_EXT_RESTORE_USN_OPTIMIZATION, "Restore USN optimization" },
                          { DRS_EXT_GETMEMBERSHIPS2, "GetMemberships2 (Batchable)" },
                          { DRS_EXT_LINKED_VALUE_REPLICATION, "Linked Value Replication" },
                          { DRS_EXT_GETCHGREQ_V6, "GetChReq V6 (whistler preview)" },
                          { DRS_EXT_GETCHGREQ_V8, "GetChReq V8 (whistler)" },
                          { DRS_EXT_ADDENTRYREPLY_V3, "RemoteAddEntry reply V3 (whistler beta 3)" },
                          { DRS_EXT_GETCHGREPLY_V7, "GetChgReply V7 (whistler beta 3)" },
                          { DRS_EXT_VERIFY_OBJECT, "added IDL_DRSReplicaVerifyObjects() (whistler beta 3)" },
                          { DRS_EXT_XPRESS_COMPRESSION, "Xpress Compression" },
                        };
    static DWORD cNumExtensions = sizeof(rgExtensions) / sizeof(rgExtensions[0]);

    BHCacheElement  *rgBHCache = NULL;
    DWORD           cBytes = BHCacheSize * sizeof(BHCacheElement);
    DWORD           i;
    BOOL            fSuccess;
    char *          pszServer;
    DWORD           iExt;
    DRS_EXTENSIONS *pext;
    DWORD           cbOffset;
    BYTE            bMask;

    Printf("%srgBHCache\n", Indent(nIndents));
    nIndents++;

    rgBHCache = (BHCacheElement *) ReadMemory(pvProcess, cBytes);

    if ( NULL == rgBHCache )
        return(FALSE);

    for ( i = 0, fSuccess = TRUE; fSuccess && (i < BHCacheSize); i++ )
    {
        if ( rgBHCache[i].pszServer )
        {
            pszServer = ReadMemory( rgBHCache[i].pszServer,
                                    rgBHCache[i].cchServer * sizeof(WCHAR) );
            fSuccess = ( NULL != pszServer );

            if ( fSuccess )
            {
                Printf("%s[%4d] - server(%ls) pszServerPrincName(%p) hDrs(%p) "
                            "cRefs(0x%x) fDontUse(0x%x) ext(",
                       Indent(nIndents),
                       i,
                       pszServer,
                       rgBHCache[i].pszServerPrincName,
                       rgBHCache[i].hDrs,
                       rgBHCache[i].cRefs,
                       rgBHCache[i].fDontUse);

                // Dump extensions we know about.
                pext = &rgBHCache[i].extRemote;
                for (iExt = 0; iExt < cNumExtensions; iExt++) {
                    cbOffset = rgExtensions[ iExt ].dw / 8;
                    bMask = 1 << (rgExtensions[ iExt ].dw % 8);

                    if ((cbOffset <= pext->cb)
                        && (bMask & pext->rgb[ cbOffset ])) {
                        // Remote server supports this extension.
                        Printf("%s ", rgExtensions[ iExt ].psz);
                    }
                }

                Printf( ")\n" );

                FreeMemory( pszServer );
            }
        }
    }

    FreeMemory(rgBHCache);
    return(TRUE);
}

BOOL
Dump_MODIFYARG(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public MODIFYARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of MODIFYARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    static struct
    {
        USHORT  usChoice;
        CHAR *  pszChoice;
    } rgChoices[] = {
                        { AT_CHOICE_ADD_ATT,       "ADD_ATT"        },
                        { AT_CHOICE_REMOVE_ATT,    "REMOVE_ATT"     },
                        { AT_CHOICE_ADD_VALUES,    "ADD_VALUES"     },
                        { AT_CHOICE_REMOVE_VALUES, "REMOVE_VALUES"  },
                        { AT_CHOICE_REPLACE_ATT,   "REPLACE_ATT"    },
                    };
    static DWORD cNumChoices = sizeof(rgChoices) / sizeof(rgChoices[0]);

    BOOL            fSuccess = FALSE;
    MODIFYARG *     pModifyArg;
    DWORD           iMod;
    DWORD           iChoice;
    CHAR *          pszChoice;
    ATTRMODLIST *   pMod;
    ATTRMODLIST *   pNextMod;

    pModifyArg = ReadMemory(pvProcess, sizeof(MODIFYARG));
    if (!pModifyArg) {
        return FALSE;
    }

    Printf("%sMODIFYARG Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pModifyArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pModifyArg->CommArg);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents),
           pModifyArg->pMetaDataVecRemote);

    Printf("%sResolved object:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pModifyArg->pResObj));

    Printf("%sATTRMODLIST (%d attributes):\n",
           Indent(nIndents),
           pModifyArg->count);

    pMod = (ATTRMODLIST *) &pModifyArg->FirstMod;

    for ( iMod = 0; fSuccess && (iMod < pModifyArg->count); iMod++ ) {
        // Translate choice to string.
        pszChoice = "???";
        for ( iChoice = 0; iChoice < cNumChoices; iChoice++ ) {
            if ( pMod->choice == rgChoices[ iChoice ].usChoice ) {
                pszChoice = rgChoices[ iChoice ].pszChoice;
                break;
            }
        }

        Printf("%s%s\n",
               Indent(nIndents+1),
               pszChoice);

        fSuccess = Dump_Attr_local(nIndents+2, &pMod->AttrInf, TRUE);

        if ( fSuccess && ( NULL != pMod->pNextMod ) )
        {
            pNextMod = ReadMemory(pMod->pNextMod, sizeof(ATTRMODLIST));
            if (!pNextMod) {
                fSuccess = FALSE;
            }
        }

        if ( iMod != 0 ) {
            FreeMemory(pMod);
        }

        pMod = pNextMod;
    }

    FreeMemory(pModifyArg);

    return TRUE;
}

BOOL
Dump_MODIFYDNARG(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public MODIFYDNARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of MODIFYDNARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    MODIFYDNARG *   pModDNArg;

    pModDNArg = ReadMemory(pvProcess, sizeof(MODIFYARG));
    if (!pModDNArg) {
        return FALSE;
    }

    Printf("%sMODIFYDNARG Object:\n",
           Indent(nIndents));

    Printf("%spObject             @ %p\n",
           Indent(nIndents), pModDNArg->pObject);
    if (NULL != pModDNArg->pObject)
    {
        fSuccess = Dump_DSNAME(nIndents+1,
                               pModDNArg->pObject);
        if (!fSuccess) {
            return FALSE;
        }
    }

    Printf("%sNew parent          @ %p\n",
           Indent(nIndents), pModDNArg->pNewParent);
    if (NULL != pModDNArg->pNewParent) {
        fSuccess = Dump_DSNAME(nIndents+1,
                               pModDNArg->pNewParent);
        if (!fSuccess) {
            return FALSE;
        }
    }

    Printf("%sNew RDN ATTR        @ %p\n",
           Indent(nIndents), pModDNArg->pNewRDN);
    if (NULL != pModDNArg->pNewRDN) {
        fSuccess = Dump_Attr(nIndents+1,
                             pModDNArg->pNewRDN);
        if (!fSuccess) {
            return FALSE;
        }
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pModDNArg->CommArg);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents), pModDNArg->pMetaDataVecRemote);

    Printf("%spDSAName           @ %p\n",
           Indent(nIndents), pModDNArg->pDSAName);

    Printf("%sResolved object    @ %p\n",
           Indent(nIndents), pModDNArg->pResObj);
    if (NULL != pModDNArg->pResObj) {
        Dump_RESOBJ(nIndents+1,
                    pModDNArg->pResObj);
    }

    Printf("%sResolved parent    @ %p\n",
           Indent(nIndents), pModDNArg->pResParent);
    if (NULL != pModDNArg->pResParent) {
        Dump_RESOBJ(nIndents+1,
                    pModDNArg->pResParent);
    }

    FreeMemory(pModDNArg);

    return TRUE;
}

typedef enum _DPRINTOP {
    eInvalid = 0,
    eHelp,
    eShow,
    eLevel,
    eAdd,
    eRemove,
    eThread
} DPRINTOP;

typedef struct _DPRINTCMD {
    char      * pszCmd;
    DPRINTOP    op;
} DPRINTCMD;



DPRINTCMD aDCmd[] = {
    {"help", eHelp},
    {"show", eShow},
    {"level", eLevel},
    {"add", eAdd},
    {"remove", eRemove},
    {"thread", eThread}
};

#define countDCmd (sizeof(aDCmd)/sizeof(DPRINTCMD))

DEBUG_EXT(dprint)
{
    CHAR    *pszCmd;
    DPRINTOP op;
    CHAR    *pszToken;
    CHAR    *pszDelimiters = " \t";
    DWORD   i;
    CHAR    *p, *s;
    BOOL    fGoodSyntax = FALSE;
    BOOL    fUpdate = FALSE;
    DEBUGARG *pProcess, *pLocal;
    CHAR    *pszModule = "ntdsa", szSymbol[30];
    DWORD   len;

    INIT_DEBUG_EXT;

    //
    // Derive command and value from command line.
    //

    // Check for alternate module specification
    pszCmd = strtok(gpszCommand, pszDelimiters);
    if ( NULL != (pszCmd) ) {
        if (strstr( pszCmd, "/m:" ) == pszCmd) {
            pszModule = pszCmd + 3;
            pszCmd = strtok(NULL, pszDelimiters);
        }
    }

    // First token in gpszCommand is the command
    if ( NULL != (pszCmd) ) {
        //
        // Second token is the (optional) argument
        //

        if ( NULL != (pszToken = strtok(NULL, pszDelimiters)) ) {
            //
            // Verify there is no third token.
            //

            if ( NULL == strtok(NULL, pszDelimiters) ) {
                fGoodSyntax = TRUE;
            }
            else {
                fGoodSyntax = FALSE;
            }
        }
        else {
            pszToken = NULL;
            fGoodSyntax = TRUE;
        }
    }

    if ( !fGoodSyntax )
    {
        Printf("Dump command parse error!\n");
        return;
    }

    op = eInvalid;
    for (i=0; i<countDCmd; i++) {
        if (0 == _stricmp(pszCmd, aDCmd[i].pszCmd)) {
            op = aDCmd[i].op;
            break;
        }
    }

    strcpy( szSymbol, pszModule );
    strcat( szSymbol, "!DebugInfo" );
    pProcess = (DEBUGARG*)GetExpr( szSymbol );
    if (pProcess == NULL) {
        Printf("Can't locate address of '%s' - sorry\n", szSymbol);
        return;
    }
    pLocal = (DEBUGARG*)ReadMemory(pProcess,
                                   sizeof(DEBUGARG));
    if (pLocal == NULL) {
        Printf("Can't read debug arg - sorry\n");
        return;
    }

    switch (op) {
      case eHelp:
        Printf("Possible dprint sub-commands include:\n");
        Printf("\t/m:<module>\tSpecify alternate dll symbol scope (default ntdsa)\n");
        Printf("\tadd subsys\tadds new subsystem to dprint list\n");
        Printf("\thelp\t\tshow this message\n");
        Printf("\tlevel newlevel\tset the print level to newlevel (0-5)\n");
        Printf("\tremove subsys\tremoves subsystem from dprint list\n");
        Printf("\tshow\t\tshow the current dprint settings\n");
        Printf("\tthread threadid\tset the thread id (0 = all threads)\n");
        break;

      case eShow:
        Printf("Current dprint state:\n");
        Printf("\tLevel is %d\n", pLocal->severity);
        Printf("\tThread id is %u (0x%x)\n",
               pLocal->threadId, pLocal->threadId);
        Printf("\tSubSystem list is '%s'\n", pLocal->DebSubSystems);
        break;

      case eLevel:
        if (pszToken) {
            i = atoi(pszToken);
            Printf("Setting DPRINT level to %d\n", i);
            pLocal->severity = i;
            fUpdate = TRUE;
        }
        else {
            Printf("You've got to specify a new level\n");
        }
        break;

      case eAdd:
        if (pszToken) {
            if (pLocal->DebSubSystems[0] == '*') {
                pLocal->DebSubSystems[0] = ':';
            }
            strcat(pLocal->DebSubSystems, pszToken);
            strcat(pLocal->DebSubSystems, ":");
            Printf("Adding '%s' to list\n", pszToken);
            fUpdate = TRUE;
        }
        else {
            Printf("You've got to specify something to add\n");
        }
        break;

      case eRemove:
        if (pszToken) {
            len = strlen(pszToken);
            p = alloca(len+3);
            p[0] = ':';
            strcpy(&p[1],pszToken);
            strcat(p,":");
            s = strstr(pLocal->DebSubSystems, p);
            if (s) {
                p = s + len + 1;
                while (*p) {
                    *s++ = *p++;
                }
                *s = '\0';
                if (pLocal->DebSubSystems[1] == '\0') {
                    pLocal->DebSubSystems[0] = '*';
                }
                fUpdate = TRUE;
                Printf("Removing '%s' from list\n", pszToken);
            }
            else {
                Printf("'%s' wasn't in list\n", pszToken);
            }
        }
        else {
            Printf("You've got to specify something to remove\n");
        }
        break;

      case eThread:
        if (pszToken) {
            i = atoi(pszToken);
            Printf("Setting thread id to %d (0x%x)\n", i, i);
            pLocal->threadId = i;
            fUpdate = TRUE;
        }
        else {
            Printf("You've got to specify a new thread id\n");
        }
        break;


      case eInvalid:
      default:
        Printf("Invalid command\n");
    }

    if (fUpdate) {
        fUpdate = WriteMemory(pProcess,
                              pLocal,
                              sizeof(DEBUGARG));
        if (fUpdate) {
            Printf("Updated!\n");
        }
        else {
            Printf("Failed to updated\n");
        }
    }

}

BOOL
Dump_EscrowInfoLocal(
        DWORD nIndents,
        IN ESCROWINFO *pInfo)

/*++

Routine Description:

    Worker routine to dump escrow info from already read memory.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of EscrowItem in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ESCROWITEM      *rItems = NULL;
    DWORD           cBytes = sizeof(ESCROWINFO);
    DWORD           i;

    Printf("%sESCROWINFO\n", Indent(nIndents));
    nIndents++;

    if ( NULL == pInfo )
        return(FALSE);

    Printf("%scItems      0x%x\n", Indent(nIndents), pInfo->cItems);
    Printf("%scItemsMax   0x%x\n", Indent(nIndents), pInfo->cItemsMax);

    nIndents++;

    if ( (0 != pInfo->cItems) && (NULL != pInfo->rItems) )
    {
        cBytes = pInfo->cItems * sizeof(ESCROWITEM);
        rItems = (ESCROWITEM *) ReadMemory(pInfo->rItems, cBytes);

        if ( NULL == rItems )
        {
            FreeMemory(pInfo);
            return(FALSE);
        }

        for ( i = 0; i < pInfo->cItems; i++ )
        {
            Printf("%sDNT(0x%x) - delta(0x%x)\n",
                   Indent(nIndents),
                   rItems[i].DNT,
                   rItems[i].delta);
        }

        FreeMemory(rItems);
    }

    return(TRUE);
}

BOOL
Dump_EscrowInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public EscrowItem dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of EscrowItem in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ESCROWINFO      *pInfo = NULL;
    DWORD           cBytes = sizeof(ESCROWINFO);

    pInfo = (ESCROWINFO *) ReadMemory(pvProcess, cBytes);

    Dump_EscrowInfoLocal(nIndents, pInfo);

    FreeMemory(pInfo);

    return(TRUE);
}

BOOL
Dump_ModifiedObjectInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ModifiedObjectInfo dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of GroupCacheInfo in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    MODIFIED_OBJ_INFO   *pInfo2,*pInfo = NULL;
    DWORD               i, cBytes = sizeof(MODIFIED_OBJ_INFO);

    if (pvProcess == NULL) {
        Printf("%sno MODIFIED_OBJ_INFO present\n", Indent(nIndents));
        return TRUE;
    }

    Printf("%sMODIFIED_OBJ_INFO\n", Indent(nIndents));
    nIndents++;

    pInfo = (MODIFIED_OBJ_INFO *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pInfo )
        return(FALSE);


    Printf("%sNCDNT, cAncestors, pAncestors, fNotifyWaiters\n",Indent(nIndents));
    for(i=0;i<pInfo->cItems;i++) {
        Printf("%s%d, %d, %p, %d\n",
               Indent(nIndents),
               pInfo->Objects[i].ulNCDNT,
               pInfo->Objects[i].cAncestors,
               pInfo->Objects[i].pAncestors,
               pInfo->Objects[i].fNotifyWaiters
               );
    }

    while(pInfo->pNext) {
        pInfo2 = (MODIFIED_OBJ_INFO *) ReadMemory(pInfo->pNext, cBytes);
        FreeMemory(pInfo);
        pInfo=pInfo2;

        if ( NULL == pInfo ) {
            return(FALSE);
        }

        for(i=0;i<pInfo->cItems;i++) {
            Printf("%s%d, %d, %p, %d\n",
                   Indent(nIndents),
                   pInfo->Objects[i].ulNCDNT,
                   pInfo->Objects[i].cAncestors,
                   pInfo->Objects[i].pAncestors,
                   pInfo->Objects[i].fNotifyWaiters
                   );
        }
    }
    Printf("%s.\n", Indent(nIndents));

    FreeMemory(pInfo);

    return(TRUE);
}

BOOL
Dump_HierarchyTableInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public HierarchyTableInfo dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of HierarchyTableInfo in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{

    HIERARCHYTABLEINFO *pInfo2,*pInfo = NULL;
    DWORD               i, cBytes = sizeof(HIERARCHYTABLEINFO);
    DWORD              *pConts;

    if (pvProcess == NULL) {
        Printf("%sno HierarchyTableInfo present\n", Indent(nIndents));
        return TRUE;
    }
    Printf("%sHierarchyTableInfo\n", Indent(nIndents));
    nIndents++;

    pInfo = (HIERARCHYTABLEINFO *) ReadMemory(pvProcess, cBytes);
    while(pInfo) {
        Printf("%sAdjust by %d:",Indent(nIndents),pInfo->adjustment);
        pConts = ReadMemory(pInfo->pABConts, pInfo->Count * sizeof(DWORD));
        if (!pConts) {
            FreeMemory(pInfo);
            return FALSE;
        }
        for(i=0;i<pInfo->Count;i++) {
            Printf("%d, ",pConts[i]);
        }
        Printf("\n");
        FreeMemory(pConts);
        pInfo2 = (HIERARCHYTABLEINFO *) ReadMemory(pInfo->Next, cBytes);
        FreeMemory(pInfo);
        pInfo = pInfo2;
    }

    return TRUE;
}

BOOL Dump_ObjCacheData(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public ObjCache data dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of OBJCACHE_DATA in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    OBJCACHE_DATA   *pOCD, *pOCDprocess;

    pOCDprocess = (OBJCACHE_DATA *)pvProcess;

    if (pOCDprocess == NULL) {
        Printf("%sno ObjCache data present\n", Indent(nIndents));
        return TRUE;
    }

    while (pOCDprocess) {
        pOCD = ReadMemory(pOCDprocess, sizeof(OBJCACHE_DATA));
        if (!pOCD) {
            Printf("%smemory read failure at %p\n",
                   Indent(nIndents),
                   pOCDprocess);
            return FALSE;
        }
        Printf("%sObjCache %s (%u) at %p\n",
               Indent(nIndents),
               ((pOCD->type == OBJCACHE_ADD) ? "Add" :
                ((pOCD->type == OBJCACHE_DEL) ? "Del" : "Error!")),
               pOCD->type,
               pOCDprocess);
        ++nIndents;
        Printf("%spCrossRefList     @%p\n", Indent(nIndents), pOCD->pCRL);
        Printf("%spMtxAddress       @%p\n", Indent(nIndents), pOCD->pMTX);
        Printf("%spRootDnsAddress   @%p\n", Indent(nIndents), pOCD->pRootDNS);
        Printf("%spDN (object)      @%p\n", Indent(nIndents), pOCD->pDN);
        --nIndents;

        pOCDprocess = pOCD->pNext;
        FreeMemory(pOCD);
    }
    return TRUE;
}

BOOL
Dump_CatalogUpdates(
    IN DWORD nIndents,
    IN CATALOG_UPDATES *pCatUpdates)
/*++

Routine Description:

    Public CatalogUpdates dump routine.

Arguments:

    nIndents - Indentation level desired.

    pCatUpdates - address of CatalogUpdates in local address space

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PVOID *pDeleted;
    PVOID pNextNC;
    DWORD i;

    if (pCatUpdates->pAddedEntries != NULL) {
        Dump_NAMING_CONTEXT_LIST(nIndents, "Added NCs:", pCatUpdates->pAddedEntries);
    }
    else {
        Printf("%sAdded NCs: (none)\n", Indent(nIndents));
    }

    if (pCatUpdates->dwDelCount > 0) {
        Printf("%sDeleted NCs:\n", Indent(nIndents));
        pDeleted = (PVOID*)ReadMemory(pCatUpdates->pDeletedEntries, pCatUpdates->dwDelCount*sizeof(PVOID));
        if (pDeleted == NULL) {
            return FALSE;
        }
        for (i = 0; i < pCatUpdates->dwDelCount; i++) {
            if (!Dump_NC_Entry(nIndents+1, pDeleted[i], &pNextNC)) {
                return FALSE;
            }
        }

        FreeMemory(pDeleted);
    }
    else {
        Printf("%sDeleted NCs: (none)\n", Indent(nIndents));
    }
    return TRUE;
}




BOOL
Dump_TransactionalData(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public TransactionalData dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of TransactionalData in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    NESTED_TRANSACTIONAL_DATA      *pInfo = NULL;
    DWORD           cBytes = sizeof(NESTED_TRANSACTIONAL_DATA);

    Printf("%sTRANSACTIONAL_DATA\n", Indent(nIndents));
    nIndents++;

    pInfo = (NESTED_TRANSACTIONAL_DATA *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pInfo )
        return(FALSE);

    Dump_EscrowInfoLocal(nIndents, &(pInfo->escrowInfo));

    // Now, the modified object info
    Dump_ModifiedObjectInfo(nIndents, pInfo->pModifiedObjects);
    Dump_HierarchyTableInfo(nIndents, pInfo->pHierarchyTableInfo);

    if (pInfo->objCachingInfo.fRecalcMapiHierarchy) {
        Printf("%sRequires Recalc of MAPI Hierarchy\n", Indent(nIndents));
    }
    if (pInfo->objCachingInfo.fSignalSCache) {
        Printf("%sWill signal Schema Cache rebuild\n", Indent(nIndents));
    }

    Dump_ObjCacheData(nIndents, pInfo->objCachingInfo.pData);

    Printf("%spMasterNC updates:\n", Indent(nIndents));
    Dump_CatalogUpdates(nIndents + 1, &pInfo->objCachingInfo.masterNCUpdates);

    Printf("%spReplicaNC updates:\n", Indent(nIndents));
    Dump_CatalogUpdates(nIndents + 1, &pInfo->objCachingInfo.replicaNCUpdates);

    if ( NULL != pInfo->pOuter )
        Dump_TransactionalData(nIndents + 1, pInfo->pOuter);

    FreeMemory(pInfo);

    return(TRUE);
}


BOOL
Dump_d_tagname(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public d_tagname dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of d_tagname in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    d_tagname * ptagname;
    WCHAR *     pRDN = NULL;

    Printf("%sd_tagname @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    ptagname = (d_tagname *) ReadMemory(pvProcess, sizeof(d_tagname));

    if (NULL == ptagname) {
        return FALSE;
    }

    if (NULL != ptagname->pRdn) {
        pRDN = (WCHAR *) ReadMemory(ptagname->pRdn, ptagname->cbRdn);
        if (NULL == pRDN) {
            FreeMemory(ptagname);
            return FALSE;
        }
    }

    Printf("%sPDNT = 0x%x, RDN Type = 0x%x, cbRDN = %d, RDN (@ %p) = \"%*.*ls\"\n",
           Indent(nIndents), ptagname->PDNT, ptagname->rdnType, ptagname->cbRdn,
           ptagname->pRdn,
           ptagname->cbRdn / sizeof(WCHAR), ptagname->cbRdn / sizeof(WCHAR),
           pRDN);

    if (NULL != pRDN) {
        FreeMemory(pRDN);
    }

    FreeMemory(ptagname);

    return TRUE;
}

BOOL
Dump_d_memname(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public d_memname dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of d_memname in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    d_memname * pmemname;
    BOOL        fSuccess = TRUE;
    DWORD *     pAncestors;

    Printf("%sd_memname @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmemname = (d_memname *) ReadMemory(pvProcess, sizeof(d_memname));

    if (NULL == pmemname) {
        return FALSE;
    }

    Printf("%sDNT       = 0x%x\n", Indent(nIndents), pmemname->DNT);
    Printf("%sNCDNT     = 0x%x\n", Indent(nIndents), pmemname->NCDNT);

    if (!Dump_d_tagname(nIndents,
                        (BYTE *) pvProcess + offsetof(d_memname, tag))) {
        fSuccess = FALSE;
    }

    Printf("%sGuid      = %s\n",
           Indent(nIndents), DraUuidToStr(&pmemname->Guid, NULL, 0));

    if (pmemname->SidLen) {
        WCHAR SidText[128];
        UNICODE_STRING us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        RtlConvertSidToUnicodeString(&us, &pmemname->Sid, FALSE);
        Printf("%sSID       = %ls\n", Indent(nIndents), SidText);
    }
    else {
        Printf("%sSID       = (none)\n", Indent(nIndents));
    }

    Printf("%sobjflag   = 0x%x (%s)\n", Indent(nIndents), pmemname->objflag,
           pmemname->objflag ? "is an object" : "is a phantom");

    Printf("%sancestors = %d @ %p\n", Indent(nIndents), pmemname->cAncestors,
           pmemname->pAncestors);

    if (pmemname->pAncestors) {
        pAncestors = (DWORD *) ReadMemory(pmemname->pAncestors,
                                          pmemname->cAncestors
                                          * sizeof(pmemname->pAncestors[0]));
        if (NULL == pAncestors) {
            fSuccess = FALSE;
        }
        else {
            DWORD i;

            Printf("%s(", Indent(nIndents+1));

            for (i=0; i < pmemname->cAncestors; i++) {
                Printf(" 0x%x", pAncestors[i]);
            }

            Printf(")\n");

            FreeMemory(pAncestors);
        }
    }

    FreeMemory(pmemname);

    return fSuccess;
}

BOOL
Dump_ProxyVal(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps a proxy value.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of proxy value in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    SYNTAX_DISTNAME_BINARY  *pVal = NULL;
    DWORD                   cBytes;
    DWORD                   type;
    DWORD                   epoch;

    Printf("%sProxy Value\n", Indent(nIndents));
    nIndents++;

    // Know that a SYNTAX_DISTNAME_BINARY always starts with a DSNAME,
    // so go for the minimal DSNAME first.

    cBytes = sizeof(DSNAME);
    pVal = (SYNTAX_DISTNAME_BINARY *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pVal )
        return(FALSE);

    // Now get the full size.
    cBytes = PADDEDNAMESIZE(&pVal->Name) + PROXY_BLOB_SIZE;
    FreeMemory(pVal);
    pVal = (SYNTAX_DISTNAME_BINARY *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pVal )
        return(FALSE);

    // Dump it.
    type = ntohl(* PROXY_DWORD_ADDR(pVal, PROXY_TYPE_OFFSET));
    epoch = ntohl(* PROXY_DWORD_ADDR(pVal, PROXY_EPOCH_OFFSET));
    Printf("%sProxy type:   0x%x (%s)\n",
           Indent(nIndents),
           type,
           ((PROXY_TYPE_MOVED_OBJECT == type)
                ? "PROXY_TYPE_MOVED_OBJECT"
                : ((PROXY_TYPE_PROXY == type)
                      ? "PROXY_TYPE_PROXY"
                      : "PROXY_TYPE_UNKOWN")) );
    Printf("%sProxy epoch: 0x%x\n",
           Indent(nIndents),
           epoch);
    Dump_DSNAME(nIndents, pvProcess);

    FreeMemory(pVal);
    return(TRUE);
}

int __cdecl CompareGuidCache(const void * pv1, const void * pv2)
{
    return memcmp ( &((GuidCache *)pv1)->guid, &((GuidCache *)pv2)->guid, sizeof (GUID));
}

void
LookupGuid(
    GUID    *pg,            // IN
    CHAR    **ppName,       // OUT
    CHAR    **ppLabel,      // OUT
    BOOL    *pfIsClass      // OUT
    )
{
    static CHAR         name[1024];
    static CHAR         label[1024];
    GuidCache           *pGuidCache;
    GuidCache           Key;
    CHAR                *p = NULL;

    *pfIsClass = FALSE;
    *ppName = name;
    *ppLabel = label;

    Key.guid = *pg;

    if (pGuidCache = (GuidCache *)bsearch(&Key,
                                          guidCache,
                                          NUM_KNOWN_GUIDS-1,
                                          sizeof(GuidCache),
                                          CompareGuidCache)) {

        p = pGuidCache->name;
    }

    if (p) {
        strcpy (label, p);
    }
    else {
        strcpy(label, "???");
    }

    sprintf(name,
            "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            pg->Data1,
            pg->Data2,
            pg->Data3,
            pg->Data4[0],
            pg->Data4[1],
            pg->Data4[2],
            pg->Data4[3],
            pg->Data4[4],
            pg->Data4[5],
            pg->Data4[6],
            pg->Data4[7]);
}

BOOL DumpAclHelper (PACL pAcl)
{
    ACE_HEADER *pAce, *ReadAce;
    PSID SidStart = NULL;
    PVOID AcePtr;
    DWORD i;
    DWORD aceSize;
    PACL ReadAcl;
    PSID pSid = NULL;


    ReadAcl = (PACL)ReadMemory(pAcl, sizeof( ACL ));
    if ( NULL == ReadAcl )
        return(FALSE);
    DumpAclHeader (ReadAcl, (AclPrintFunc)Printf);

    AcePtr = ( PUCHAR )pAcl + sizeof( ACL );
    for ( i = 0; i < ReadAcl->AceCount; i++ ) {

        Printf("\tAce[%d]\n", i);
        // First, we need to read the Size/Type of the ace
        ReadAce = (ACE_HEADER *)ReadMemory( AcePtr, sizeof( ACE_HEADER ));
        if ( NULL == ReadAce )
            return(FALSE);

        aceSize = ReadAce->AceSize;

        switch ( ReadAce->AceType ) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            FreeMemory(ReadAce);

            SidStart = ( PSID )( ( PUCHAR )AcePtr + sizeof( KNOWN_ACE ) - sizeof( ULONG ) );
            pSid = (PSID)ReadMemory(SidStart, sizeof( SID ));
            if ( NULL == pSid )
                return(FALSE);

            ReadAce = (ACE_HEADER *)ReadMemory( AcePtr, sizeof( KNOWN_ACE )
                                                + RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ) );
            if ( NULL == ReadAce )
                return(FALSE);

            DumpAce (ReadAce, (AclPrintFunc)Printf, LookupGuid, NULL);
            FreeMemory(pSid);

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            FreeMemory(ReadAce);

            SidStart = ( PSID )( ( PUCHAR )AcePtr + sizeof( KNOWN_OBJECT_ACE ) - sizeof( ULONG ) );

            pSid = (PSID)ReadMemory(SidStart, sizeof( SID ));
            if ( NULL == pSid )
                return(FALSE);


            ReadAce = (ACE_HEADER *)ReadMemory( AcePtr, sizeof( KNOWN_OBJECT_ACE ) + 2 * sizeof( GUID ) + RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ));
            if ( NULL == ReadAce )
                return(FALSE);


            DumpAce (ReadAce, (AclPrintFunc)Printf, LookupGuid, NULL);
            FreeMemory(pSid);
            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        default:
            Printf( "Unsupported AceType %lu encountered... skipping\n", ReadAce->AceType );
            break;
        }
        FreeMemory(ReadAce);

        AcePtr = ( PUCHAR )AcePtr + aceSize;
    }

    return TRUE;
}


BOOL
Dump_SD(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps a Security Descriptor

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SD value in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    #define CONTROL_OFFSET ((ULONGLONG)(&( ((SECURITY_DESCRIPTOR *) NULL)->Control )))
    SECURITY_DESCRIPTOR *pSD = NULL;
    SECURITY_DESCRIPTOR_RELATIVE *pSDRelative = NULL;
    SECURITY_DESCRIPTOR_CONTROL *pSDControl;
    PSID pOwner = NULL, pGroup = NULL;
    PACL pDacl = NULL, pSacl = NULL;
    PSID pSid = NULL;
    PSID ReadSid;

    //
    // Just get the Control element of the struct so that we know
    // how big the SD is since on 64bit archs self relative SD's are
    // a different size than absolute SD's.
    //
    pSDControl = (SECURITY_DESCRIPTOR_CONTROL *) ReadMemory(((PUCHAR)pvProcess) + CONTROL_OFFSET,
                                                  sizeof(SECURITY_DESCRIPTOR_CONTROL));

    if ( NULL == pSDControl )
        return(FALSE);


    if (  ( *pSDControl & SE_SELF_RELATIVE ) == SE_SELF_RELATIVE ) {
        pSDRelative = (SECURITY_DESCRIPTOR_RELATIVE *) ReadMemory(pvProcess,
                                                                  sizeof(SECURITY_DESCRIPTOR_RELATIVE));
        FreeMemory(pSDControl);
        if ( NULL == pSDRelative ) {
            return(FALSE);
        }

        DumpSDHeader ((SECURITY_DESCRIPTOR *)pSDRelative, (AclPrintFunc)Printf);

        if ( pSDRelative->Owner != 0 ) {

            pOwner = ( PSID )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Owner );
        }

        if ( pSDRelative->Group != 0 ) {

            pGroup = ( PSID )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Group );
        }

        if ( pSDRelative->Dacl != 0 ) {

            pDacl = ( PACL )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Dacl );
        }

        if ( pSDRelative->Sacl != 0 ) {

            pSacl = ( PACL )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Sacl );
        }

    } else {
        pSD = (SECURITY_DESCRIPTOR *) ReadMemory(pvProcess,
                                                sizeof(SECURITY_DESCRIPTOR));
        FreeMemory(pSDControl);
        if ( NULL == pSD ) {
            return(FALSE);
        }

        DumpSDHeader (pSD, (AclPrintFunc)Printf);

        pOwner = pSD->Owner;
        pGroup = pSD->Group;
        pDacl = pSD->Dacl;
        pSacl = pSD->Sacl;
    }


    // read the owner
    if (pOwner) {
        Printf("Owner:");
        pSid = (PSID)ReadMemory(pOwner, sizeof( SID ));
        if ( NULL == pSid )
            return(FALSE);

        ReadSid = (PSID)ReadMemory(pOwner, RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ));
        if ( NULL == ReadSid )
            return(FALSE);

        DumpSID (ReadSid, (AclPrintFunc)Printf);
        FreeMemory(pSid);
        FreeMemory(ReadSid);
        Printf("\n");
    }


    // read the group
    if (pGroup) {
        Printf("Group:");
        pSid = (PSID)ReadMemory(pGroup, sizeof( SID ));
        if ( NULL == pSid )
            return(FALSE);

        ReadSid = (PSID)ReadMemory(pGroup, RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ));
        if ( NULL == ReadSid )
            return(FALSE);

        DumpSID (ReadSid, (AclPrintFunc)Printf);
        FreeMemory(pSid);
        FreeMemory(ReadSid);
        Printf("\n");
    }


    // read the DACL
    if (pDacl) {
        Printf("DACL:\n");

        if (!DumpAclHelper (pDacl)) {
             return FALSE;
        }
    }


    // read the SACL
    if (pSacl) {
        Printf("SACL:\n");

        if (!DumpAclHelper (pSacl)) {
             return FALSE;
        }
    }

    if (pSD) {
        FreeMemory(pSD);
    }
    if (pSDRelative) {
        FreeMemory(pSDRelative);
    }
    return(TRUE);
}

BOOL
Dump_LHT(
    IN      DWORD           nIndents,
    IN      PVOID           pvProcess,
    IN      PFN_DUMP_TYPE   pfnDumpType
    )

/*++

Routine Description:

    This routine dumps the contents of a linear hash table.

Arguments:

    nIndents        - Supplies the indention level of the output text
    pvProcess       - Supplies the debuggee address of the LHT
    pfnDumpType     - Supplies the routine to dump each entry in the LHT

Return Value:

    TRUE on success.

 --*/

{
    PLHT            plht            = NULL;
    BYTE*           rgBucket        = NULL;
    PLHT_CLUSTER    pClusterNext    = NULL;
    DWORD           cBytes;
    SIZE_T          crgBucket;
    SIZE_T          irgBucket;
    BYTE*           rgBucketPhys;
    SIZE_T          cBucket;
    SIZE_T          iBucket;
    PLHT_CLUSTER    pCluster;
    PLHT_CLUSTER    pClusterPhys;
    PLHT_CLUSTER    pClusterNextPhys;
    SIZE_T          cEntry;
    SIZE_T          iEntry;

    Printf("%sLHT @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    cBytes = sizeof(LHT);

    if (!(plht = ReadMemory(pvProcess, cBytes))) {
        return FALSE;
    }

    crgBucket = sizeof(plht->rgrgBucket) / sizeof(plht->rgrgBucket[0]);
    for (irgBucket = 0; irgBucket < crgBucket && plht->rgrgBucket[irgBucket]; irgBucket++) {

        cBucket     = max(2, 1 << irgBucket);
        
        pvProcess   = plht->rgrgBucket[irgBucket];
        cBytes      = (DWORD)(cBucket * plht->cbCluster);

        FreeMemory(rgBucket);
        if (!(rgBucket = ReadMemory(pvProcess, cBytes))) {
            FreeMemory(pClusterNext);
            FreeMemory(rgBucket);
            FreeMemory(plht);
            return FALSE;
        }
        rgBucketPhys = pvProcess;

        for (iBucket = 0; iBucket < cBucket; iBucket++) {

            pCluster        = (PLHT_CLUSTER)(rgBucket + iBucket * plht->cbCluster);
            pClusterPhys    = (PLHT_CLUSTER)(rgBucketPhys + iBucket * plht->cbCluster);
            do {

                if ((DWORD_PTR)pCluster->pvNextLast - (DWORD_PTR)pClusterPhys < plht->cbCluster) {
                    cEntry = ((DWORD_PTR)pCluster->pvNextLast - (DWORD_PTR)pClusterPhys->rgEntry) / plht->cbEntry + 1;
                } else if (!pCluster->pvNextLast) {
                    cEntry = 0;
                } else {
                    cEntry = plht->cEntryCluster;
                }

                for (iEntry = 0; iEntry < cEntry; iEntry++) {
                    if (!pfnDumpType(nIndents, pClusterPhys->rgEntry + iEntry * plht->cbEntry)) {
                        FreeMemory(pClusterNext);
                        FreeMemory(rgBucket);
                        FreeMemory(plht);
                        return FALSE;
                    }
                }

                FreeMemory(pClusterNext);
                if ((DWORD_PTR)pCluster->pvNextLast - (DWORD_PTR)pClusterPhys < plht->cbCluster) {
                    pClusterNext        = NULL;
                    pClusterNextPhys    = NULL;
                } else if (!pCluster->pvNextLast) {
                    pClusterNext        = NULL;
                    pClusterNextPhys    = NULL;
                } else {
                    pvProcess   = pCluster->pvNextLast;
                    cBytes      = (DWORD)plht->cbCluster;
                    
                    pClusterNext        = ReadMemory(pvProcess, cBytes);
                    pClusterNextPhys    = pvProcess;
                }
                pCluster        = pClusterNext;
                pClusterPhys    = pClusterNextPhys;
                
            } while (pCluster);
        }
    }

    FreeMemory(pClusterNext);
    FreeMemory(rgBucket);
    FreeMemory(plht);
    return TRUE;
}

BOOL
Dump_INVALIDATED_DC_LIST (
    IN DWORD nIndents,
    IN PVOID pvProcess)
{
    PINVALIDATED_DC_LIST pDCList;
    PWCHAR pDCName;
    FILETIME localFileTime;
    SYSTEMTIME systemTime;

    Printf("%s%-12s %s\n", Indent(nIndents), "Invalidated", "DC name");
    if (pvProcess == NULL) {
        Printf("%s(empty)\n", pvProcess);
    }

    while (TRUE) {
        pDCList = (PINVALIDATED_DC_LIST)ReadMemory(pvProcess, sizeof(INVALIDATED_DC_LIST));
        pDCName = (PWCHAR)ReadUnicodeMemory((PBYTE)pvProcess + offsetof(INVALIDATED_DC_LIST, dcName), 500);
        if (pDCList == NULL || pDCName == NULL) {
            return FALSE;
        }
        // convert filetime to systemtime
        if (
            FileTimeToLocalFileTime((LPFILETIME)&pDCList->lastInvalidation, &localFileTime) &&
            FileTimeToSystemTime(&localFileTime, &systemTime)
            ) 
        {
            Printf("%s%2d:%02d:%02d.%03d ", Indent(nIndents), systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds);
        }
        else {
            Printf("%s%-12s ", Indent(nIndents), "invalid time");
        }
        Printf("%S\n", pDCName);

        FreeMemory(pDCList);
        FreeMemory(pDCName);

        pvProcess = pDCList->pNext;
        if (pvProcess == NULL) {
            break;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\scache.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    md.c

Abstract:

    Dump functions for types used by dsamain\src\scache.c.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Feb-97   DaveStr     Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
#include "objids.h"
#include "drs.h"
#include "scache.h"
#include <ntdsa.h>
#include "mdglobal.h"             // for REPLICA_LINK
#include "drasch.h"               // uses REPLICA_LINK

#define MAX_INDEX_NAME 128        // we can also #include "..dsmain/dblayer/dbintrnl.h"

BOOL
Dump_ArrayOfUlong(
    IN DWORD nIndents,
    IN DWORD count,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps an array of ULONG in pretty print format - 4 to a line.

Arguments:

    nIndents - Indentation level desired.

    count - number of elements in array.

    pvProcess - address of ULONG[] in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG   *rul;
    DWORD   i;

    rul = ReadMemory(pvProcess, count * sizeof(ULONG));

    if ( NULL == rul )
        return(FALSE);

    for ( i = 0; i < count; i++ )
    {
        if ( 0 == (i % 4) )
            Printf("%s", Indent(nIndents));

        Printf("%08x    ", rul[i]);

        if ( (0 == ((i+1) % 4)) || ((i+1) == count) )
            Printf("\n");
    }

    FreeMemory(rul);

    return(TRUE);
}

int __cdecl
sortaux(
    const void * pv1,
    const void * pv2)
{
    // Function to compare two HASHCACHESTRING values.

    HASHCACHESTRING *pHCS1 = (HASHCACHESTRING *) pv1;
    HASHCACHESTRING *pHCS2 = (HASHCACHESTRING *) pv2;
    UCHAR           *value1 = NULL;
    UCHAR           *value2 = NULL;
    int             retVal = 0;

    if ( NULL == pHCS1->value )
        return(-1);

    if ( NULL == pHCS2->value )
        return(1);

    value1 = ReadMemory(
                pHCS1->value,
                sizeof(UCHAR) * (1 + pHCS1->length));

    if ( NULL != value1 )
    {
        value1[pHCS1->length] = '\0';

        value2 = ReadMemory(
                    pHCS2->value,
                    sizeof(UCHAR) * (1 + pHCS2->length));

        if ( NULL != value2 )
        {
            value2[pHCS2->length] = '\0';

            retVal = _stricmp(value1, value2);
        }
    }

    FreeMemory(value1);
    FreeMemory(value2);

    return(retVal);
}

BOOL
Dump_SCHEMAPTR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SCHEMAPTR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG               i, j, cBytes;
    BYTE                *addr;
    SCHEMAPTR           *pSchema = NULL;
    HASHCACHESTRING     *pHCS;
    PrefixTableEntry    *pPTE;
    UCHAR               *value;
    ATTRTYP             *pid;
    BYTE                *pb;
    PVOID               pPFX;
    UCHAR               temp[512];

    do
    {
        pSchema = (SCHEMAPTR *) ReadMemory(pvProcess, sizeof(SCHEMAPTR));

        if ( NULL == pSchema )
            break;

        Printf("%sSCHEMAPTR:\n", Indent(nIndents));
        nIndents++;

        Printf("%sATTCOUNT            0x%x\n",
               Indent(nIndents),
               pSchema->ATTCOUNT);

        Printf("%sCLSCOUNT            0x%x\n",
               Indent(nIndents),
               pSchema->CLSCOUNT);

        Printf("%sPREFIXCOUNT         0x%x\n",
               Indent(nIndents),
               pSchema->PREFIXCOUNT);

        Printf("%snAttInDB            0x%x\n",
               Indent(nIndents),
               pSchema->nAttInDB);

        Printf("%snClsInDB            0x%x\n",
               Indent(nIndents),
               pSchema->nClsInDB);

        Printf("%sPrefixCount         0x%x\n",
               Indent(nIndents),
               pSchema->PrefixTable.PrefixCount);

        Printf("%sahcId             @ %p\n",
               Indent(nIndents),
               pSchema->ahcId);

        Printf("%sahcCol            @ %p\n",
               Indent(nIndents),
               pSchema->ahcCol);

        Printf("%sahcMapi           @ %p\n",
               Indent(nIndents),
               pSchema->ahcMapi);

        Printf("%sahcLink           @ %p\n",
               Indent(nIndents),
               pSchema->ahcLink);

        Printf("%sahcName           @ %p\n",
               Indent(nIndents),
               pSchema->ahcName);

        Printf("%sahcClass          @ %p\n",
               Indent(nIndents),
               pSchema->ahcClass);

        Printf("%sahcClassName      @ %p\n",
               Indent(nIndents),
               pSchema->ahcClassName);

        Printf("%sahcClassAll       @ %p\n",
               Indent(nIndents),
               pSchema->ahcClassAll);

        Printf("%spPrefixEntry      @ %p\n",
               Indent(nIndents),
               pSchema->PrefixTable.pPrefixEntry);

        Printf("%ssysTime             0x%x\n",
               Indent(nIndents),
               pSchema->sysTime);

        Printf("%spPartialAttrVec     @ %p\n",
               Indent(nIndents),
               pSchema->pPartialAttrVec);

        Printf("%sSchemaInfo         ",
               Indent(nIndents));
        pb = (UCHAR *) &(pSchema->SchemaInfo);
        for ( i = 0; i < SCHEMA_INFO_LENGTH; pb++, i++ )
            Printf("%02x", *pb);
        Printf("\n");        
    
        Printf("%sEntryTTLId          0x%x\n",
               Indent(nIndents),
               pSchema->EntryTTLId);
    
        Printf("%sDynamicObjectId     0x%x\n",
               Indent(nIndents),
               pSchema->DynamicObjectId);
    
        Printf("%sForestBehaviorVersion 0x%x\n",
               Indent(nIndents),
               pSchema->ForestBehaviorVersion);
    
        // Now print out the prefix table

        Dump_SCHEMA_PREFIX_TABLE(nIndents+1, ((BYTE *) pvProcess) + OFFSET(SCHEMAPTR, PrefixTable));

        // Now be nice and dump all the class names and pointers.

        Printf("\n%s*** Classes ***\n", Indent(nIndents));
        nIndents++;

        cBytes = pSchema->CLSCOUNT * sizeof(HASHCACHESTRING);
        pHCS = (HASHCACHESTRING *) ReadMemory(pSchema->ahcClassName, cBytes);
        if ( NULL == pHCS )
            break;

        qsort(pHCS, pSchema->CLSCOUNT, sizeof(HASHCACHESTRING), sortaux);

        for ( i = 0; i < pSchema->CLSCOUNT; i++ )
        {
            if ( NULL != pHCS[i].value )
            {
                value = ReadMemory(pHCS[i].value,
                                   sizeof(UCHAR) * (1 + pHCS[i].length));

                if ( NULL != value )
                {
                    value[pHCS[i].length] = '\0';

                    addr = ((BYTE *) pHCS[i].pVal) + OFFSET(CLASSCACHE, ClassId),
                    pid = ReadMemory(addr, sizeof(ULONG));

                    if ( NULL != pid )
                    {
                        Printf("%s%s(%08x) @ %p\n",
                               Indent(nIndents),
                               value,
                               *pid,
                               pHCS[i].pVal);

                        FreeMemory(pid);
                    }

                    FreeMemory(value);
                }
            }
        }

        FreeMemory(pHCS);
        nIndents--;

        // Now be nice and dump all the attr names and pointers.
        Printf("\n%s*** Attributes ***\n", Indent(nIndents));
        nIndents++;

        cBytes = pSchema->ATTCOUNT * sizeof(HASHCACHESTRING);
        pHCS = (HASHCACHESTRING *) ReadMemory(pSchema->ahcName, cBytes);
        if ( NULL == pHCS )
            break;

        qsort(pHCS, pSchema->ATTCOUNT, sizeof(HASHCACHESTRING), sortaux);

        for ( i = 0; i < pSchema->ATTCOUNT; i++ )
        {
            if ( NULL != pHCS[i].value )
            {
                value = ReadMemory(pHCS[i].value,
                                   sizeof(UCHAR) * (1 + pHCS[i].length));

                if ( NULL != value )
                {
                    value[pHCS[i].length] = '\0';

                    addr = ((BYTE *) pHCS[i].pVal) + OFFSET(ATTCACHE, id),
                    pid = ReadMemory(addr, sizeof(ULONG));

                    if ( NULL != pid )
                    {
                        Printf("%s%s(%08x) @ %p\n",
                               Indent(nIndents),
                               value,
                               *pid,
                               pHCS[i].pVal);

                        FreeMemory(pid);
                    }

                    FreeMemory(value);
                }
            }
        }

        FreeMemory(pHCS);
        nIndents--;

    }
    while ( FALSE );

    FreeMemory(pSchema);

    return(TRUE);
}

BOOL
Dump_SCHEMA_PREFIX_TABLE(
    IN DWORD nIndents,
    IN     IN PVOID pvProcess)
/*++

Routine Description:

    Public SCHEMA_PREFIX_TABLE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMA_PREFIX_TABLE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    SCHEMA_PREFIX_TABLE *pPrefixTbl;
    PrefixTableEntry    *pPTE;
    DWORD               cBytes, i, j;
    BYTE                *pb;
    PVOID               pPFX;
    UCHAR               temp[512];

    Printf("\n%s*** Prefixes ***\n", Indent(nIndents));
    nIndents++;

    pPrefixTbl = (SCHEMA_PREFIX_TABLE *) ReadMemory(pvProcess, sizeof(SCHEMA_PREFIX_TABLE));

    if ( NULL == pPrefixTbl ) return FALSE;

    cBytes = (pPrefixTbl->PrefixCount) * sizeof(PrefixTableEntry);
    pPTE = (PrefixTableEntry *) ReadMemory(pPrefixTbl->pPrefixEntry, cBytes);
    if ( NULL == pPTE )
        return FALSE;

    for ( i = 0; i < pPrefixTbl->PrefixCount; i++ )
    {
      pPFX = pPTE[i].prefix.elements;
      if (pPFX != NULL) {
          pb = (LPBYTE) ReadMemory(pPTE[i].prefix.elements, pPTE[i].prefix.length);
          if (NULL == pb) {
              FreeMemory(pPrefixTbl);
              FreeMemory(pPTE);
              return FALSE;
          }
          for ( j = 0; j < pPTE[i].prefix.length; j++ )
          {
             sprintf( &temp[ j * 2 ], "%.2x", *(pb++) );
          }
          temp[2*pPTE[i].prefix.length]='\0';
          Printf("%2d. Ndx=%-4d Length=%-3d Prefix=%s\n",i,pPTE[i].ndx, pPTE[i].prefix.length, temp);
      }
    }

   FreeMemory(pb);
   FreeMemory(pPrefixTbl);
   FreeMemory(pPTE);
   return TRUE;

}


BOOL
Dump_CLASSCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public CLASSCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of CLASSCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG           i, cBytes;
    UCHAR           *pG;
    CLASSCACHE      *pCC = NULL;
    UCHAR           *name = NULL;
    ULONG           *pSubClassOf = NULL;
    UCHAR           *propPage = NULL;
    CHAR            *pStrSD;

    do
    {
        cBytes = sizeof(CLASSCACHE);
        pCC = ReadMemory(pvProcess, cBytes);
        if ( NULL == pCC )
            break;

        cBytes = sizeof(UCHAR) * (1 + pCC->nameLen);
        name = ReadMemory(pCC->name, cBytes);
        if ( NULL == name )
            break;
        name[pCC->nameLen] = '\0';

        Printf("%sCLASSCACHE(%s)\n",
               Indent(nIndents),
               name);
        nIndents++;

        Printf("%sClassId               0x%x\n",
               Indent(nIndents),
               pCC->ClassId);

        Printf("%spSD[SDLen]          @ %p[0x%x]\n",
               Indent(nIndents),
               pCC->pSD,
               pCC->SDLen);

        if(pCC->pStrSD){
            pStrSD = ReadMemory(pCC->pStrSD, pCC->cbStrSD);
            if(pStrSD){
                Printf("%spStrSD                %ls\n",
                       Indent(nIndents),
                       pStrSD);
                FreeMemory(pStrSD);
            } else {
                Printf("%sCouldn't read the pStrSD\n", Indent(nIndents));
            }
        } else {
            Printf("%spStrSD                (Not Cached yet)\n");
        }

        Printf("%sRDNAttIdPresent       0x%x\n",
               Indent(nIndents),
               pCC->RDNAttIdPresent);

        Printf("%sRdnExtId              0x%x\n",
               Indent(nIndents),
               pCC->RdnExtId);

        Printf("%sRdnIntId              0x%x\n",
               Indent(nIndents),
               pCC->RdnIntId);

        Printf("%sClassCategory         0x%x\n",
               Indent(nIndents),
               pCC->ClassCategory);

        Printf("%spDefaultObjectCategory   @ %p\n",
               Indent(nIndents),
               pCC->pDefaultObjCategory);

        Printf("%sSystemOnly            0x%x\n",
               Indent(nIndents),
               pCC->bSystemOnly);

        Printf("%sClosed                0x%x\n",
               Indent(nIndents),
               pCC->bClosed);

        Printf("%sbClosureInProgress    0x%x\n",
               Indent(nIndents),
               pCC->bClosureInProgress);

        Printf("%sbUsesMultInherit      0x%x\n",
               Indent(nIndents),
               pCC->bUsesMultInherit);

        Printf("%sbHideFromAB           0x%x\n",
               Indent(nIndents),
               pCC->bHideFromAB);

        Printf("%sbDefunct              0x%x\n",
               Indent(nIndents),
               pCC->bDefunct);

        Printf("%sbIsBaseScheObj        0x%x\n",
               Indent(nIndents),
               pCC->bIsBaseSchObj);

        Printf("%sbDupLDN               0x%x\n",
               Indent(nIndents),
               pCC->bDupLDN);

        Printf("%sbDupOID               0x%x\n",
               Indent(nIndents),
               pCC->bDupOID);

        Printf("%sbDupPropGuid          0x%x\n",
               Indent(nIndents),
               pCC->bDupPropGuid);

        Printf("%spropGuid              ",
               Indent(nIndents));
        pG = (UCHAR *) &(pCC->propGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");

        Printf("%sMySubClass            0x%x\n",
               Indent(nIndents),
               pCC->MySubClass);

        if ( 0 == pCC->SubClassCount )
        {
            Printf("%sSubClasses[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sSubClasses[0x%x]\n",
                   Indent(nIndents),
                   pCC->SubClassCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->SubClassCount,
                              pCC->pSubClassOf);
        }

        if ( 0 == pCC->AuxClassCount )
        {
            Printf("%sAuxClasses[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sAuxClasses[0x%x]\n",
                   Indent(nIndents),
                   pCC->AuxClassCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->AuxClassCount,
                              pCC->pAuxClass);
        }

        if ( 0 == pCC->PossSupCount )
        {
            Printf("%sPossSup[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sPossSup[0x%x]\n",
                   Indent(nIndents),
                   pCC->PossSupCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->PossSupCount,
                              pCC->pPossSup);
        }

        if ( 0 == pCC->MyPossSupCount )
        {
            Printf("%sMyPossSup[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMyPossSup[0x%x]\n",
                   Indent(nIndents),
                   pCC->MyPossSupCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MyPossSupCount,
                              pCC->pMyPossSup);
        }

        if ( 0 == pCC->MustCount )
        {
            Printf("%sMustAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMustAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MustCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MustCount,
                              pCC->pMustAtts);
        }

        if ( 0 == pCC->MyMustCount )
        {
            Printf("%sMyMustAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMyMustAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MyMustCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MyMustCount,
                              pCC->pMyMustAtts);
        }

        if ( 0 == pCC->MayCount )
        {
            Printf("%sMayAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMayAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MayCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MayCount,
                              pCC->pMayAtts);
        }

        if ( 0 == pCC->MyMayCount )
        {
            Printf("%sMyMayAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMyMayAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MyMayCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MyMayCount,
                              pCC->pMyMayAtts);
        }

        Printf("%sobjectGuid            ",
               Indent(nIndents));
        pG = (UCHAR *) &(pCC->objectGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");
    }
    while ( FALSE );

    FreeMemory(propPage);
    FreeMemory(pSubClassOf);
    FreeMemory(name);
    FreeMemory(pCC);

    return TRUE;
}

BOOL
Dump_ATTCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ATTCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ATTCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG           i, cBytes;
    UCHAR           *pG;
    ATTCACHE        *pAC = NULL;
    UCHAR           *name = NULL;
    char            *pszPdntIndex = NULL;
    char            *pszIndex = NULL;

    do
    {
        cBytes = sizeof(ATTCACHE);
        pAC = ReadMemory(pvProcess, cBytes);
        if ( NULL == pAC )
            break;

        cBytes = sizeof(UCHAR) * (1 + pAC->nameLen);
        name = ReadMemory(pAC->name, cBytes);
        if ( NULL == name )
            break;
        name[pAC->nameLen] = '\0';

        Printf("%sATTCACHE(%s)\n",
               Indent(nIndents),
               name);
        nIndents++;

        Printf("%sATTRTYP               0x%x\n",
               Indent(nIndents),
               pAC->id);

        Printf("%sExtATTRTYP            0x%x\n",
               Indent(nIndents),
               pAC->Extid);

        Printf("%ssyntax                0x%x\n",
               Indent(nIndents),
               pAC->syntax);

        Printf("%sisSingleValued        0x%x\n",
               Indent(nIndents),
               pAC->isSingleValued);

        if ( pAC->rangeLowerPresent )
        {
            Printf("%srangeLower            0x%x\n",
                   Indent(nIndents),
                   pAC->rangeLower);
        }

        if ( pAC->rangeUpperPresent )
        {
            Printf("%srangeUpper            0x%x\n",
                   Indent(nIndents),
                   pAC->rangeUpper);
        }

        Printf("%sjColid                0x%x\n",
               Indent(nIndents),
               pAC->jColid);

        Printf("%sulMapiID              0x%x\n",
               Indent(nIndents),
               pAC->ulMapiID);

        Printf("%sulLinkID              0x%x\n",
               Indent(nIndents),
               pAC->ulLinkID);

        Printf("%spropGuid              ",
               Indent(nIndents));
        pG = (UCHAR *) &(pAC->propGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");

        Printf("%spropSetGuid           ",
               Indent(nIndents));
        pG = (UCHAR *) &(pAC->propSetGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");

        Printf("%sfSearchFlags          0x%x\n",
               Indent(nIndents),
               pAC->fSearchFlags);

        Printf("%sbSystemOnly           0x%x\n",
               Indent(nIndents),
               pAC->bSystemOnly);

        Printf("%sbExtendedChars        0x%x\n",
               Indent(nIndents),
               pAC->bExtendedChars);

        Printf("%sbMemberOfPartialSet   0x%x\n",
               Indent(nIndents),
               pAC->bMemberOfPartialSet);

        Printf("%sbDefunct              0x%x\n",
               Indent(nIndents),
               pAC->bDefunct);

        Printf("%sbIsBaseSchObj         0x%x\n",
               Indent(nIndents),
               pAC->bIsBaseSchObj);

        Printf("%sbIsConstructed        0x%x\n",
               Indent(nIndents),
               pAC->bIsConstructed);

        Printf("%sbIsNotReplicated      0x%x\n",
               Indent(nIndents),
               pAC->bIsNotReplicated);

        Printf("%sbIsOperational        0x%x\n",
               Indent(nIndents),
               pAC->bIsOperational);

        Printf("%sbDupLDN               0x%x\n",
               Indent(nIndents),
               pAC->bDupLDN);

        Printf("%sbDupOID               0x%x\n",
               Indent(nIndents),
               pAC->bDupOID);

        Printf("%sbDupPropGuid          0x%x\n",
               Indent(nIndents),
               pAC->bDupPropGuid);

        Printf("%sbDupMapiID            0x%x\n",
               Indent(nIndents),
               pAC->bDupMapiID);

        Printf("%sbIsRdn                0x%x\n",
               Indent(nIndents),
               pAC->bIsRdn);

        Printf("%sbFlagIsRdn            0x%x\n",
               Indent(nIndents),
               pAC->bFlagIsRdn);

        Printf("%sOMsyntax              0x%x\n",
               Indent(nIndents),
               pAC->OMsyntax);

//      Printf("%sOM_object_identifier\n",
//             Indent(nIndents));
//      Dump_OM_object(nIndents + 1,
//                     ((BYTE *) pvProcess) + OFFSET(ATTCACHE, OMObjClass));

        if (pAC->pszPdntIndex) {
            pszPdntIndex = ReadStringMemory (pAC->pszPdntIndex, MAX_INDEX_NAME);
            if ( NULL == pszPdntIndex )
                break;
            Printf("%spszPdntIndex          %s\n",
                   Indent(nIndents),
                   pszPdntIndex);
        }
        else {
            Printf("%spszPdntIndex          %x\n",
                   Indent(nIndents),
                   pAC->pszPdntIndex);
        }

        if (pAC->pszIndex) {
            pszIndex = ReadStringMemory (pAC->pszIndex, MAX_INDEX_NAME);
            if ( NULL == pszIndex )
                break;

            Printf("%spszIndex              %s\n",
                   Indent(nIndents),
                   pszIndex);
        }
        else {
            Printf("%spszIndex              %x\n",
                   Indent(nIndents),
                   pAC->pszIndex);
        }

        Printf("%sobjectGuid            ",
               Indent(nIndents));
        pG = (UCHAR *) &(pAC->objectGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");
    }
    while ( FALSE );

    FreeMemory(name);
    FreeMemory(pszPdntIndex);
    FreeMemory(pszIndex);
    FreeMemory(pAC);

    return(TRUE);
}

BOOL
Dump_PARTIAL_ATTR_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public PARTIAL_ATTR_VECTOR dump routine - print attids for in
    a row.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PARTIAL_ATTR_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    PARTIAL_ATTR_VECTOR *pPartialAttrVec = NULL;
    DWORD cAttrs = 0;
    DWORD i;

    Printf("%sPARTIAL_ATTR_VECTOR:\n\n", Indent(nIndents));
    nIndents += 2;

    pPartialAttrVec = (PARTIAL_ATTR_VECTOR *) ReadMemory(pvProcess,
                                              PartialAttrVecV1SizeFromLen(0));

    if ( NULL != pPartialAttrVec )
    {
        if (VERSION_V1 == pPartialAttrVec->dwVersion)
        {
            cAttrs = pPartialAttrVec->V1.cAttrs;
        }
        else
        {
            Printf("%sPARTIAL_ATTR_VECTOR version is NOT %d!!!\n", Indent(nIndents), VERSION_V1);
            fSuccess = TRUE;
        }

        FreeMemory( pPartialAttrVec );

        if (0 != cAttrs)
        {

            pPartialAttrVec = (PARTIAL_ATTR_VECTOR *) ReadMemory(pvProcess,
                                                      PartialAttrVecV1SizeFromLen(cAttrs));

            if ( NULL != pPartialAttrVec )
            {
                for ( i = 0; i < cAttrs; i++ )
                {
                    if (!(i % 4))
                        Printf("%s", Indent(nIndents));

                    Printf("0x%-8x    ", pPartialAttrVec->V1.rgPartialAttr[i]);

                    if (!((i+1) % 4) || ((i+1) == cAttrs))
                        Printf("\n");
                }

                FreeMemory( pPartialAttrVec );
                fSuccess = TRUE;
            }
        }
    }

    return(fSuccess);
}

BOOL
Dump_GCDeletionList(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public GCDeletionList dump routine - print attids for in
    a row.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of GCDeletionList in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    GCDeletionList *pGCDList = NULL;
    DWORD cAttrs = 0;
    DWORD i;

    Printf("%sGCDeletionList:\n\n", Indent(nIndents));
    nIndents += 2;

    pGCDList = (GCDeletionList *) ReadMemory(pvProcess,
                                              GCDeletionListSizeFromLen(0));

    if ( NULL != pGCDList )
    {
        if (VERSION_V1 == pGCDList->PartialAttrVecDel.dwVersion)
        {
            cAttrs = pGCDList->PartialAttrVecDel.V1.cAttrs;
        }
        else
        {
            Printf("%sEmbedded PARTIAL_ATTR_VECTOR version is NOT %d!!!\n", Indent(nIndents), VERSION_V1);
            fSuccess = TRUE;
        }

        FreeMemory( pGCDList );

        if (0 != cAttrs)
        {

            pGCDList = (GCDeletionList *) ReadMemory(pvProcess,
                                                      GCDeletionListSizeFromLen(cAttrs));

            if ( NULL != pGCDList )
            {
                Printf("%susnLastProcessed: %I64d\n", Indent(nIndents),
                       pGCDList->usnLastProcessed);

                Printf("%sDeletion List: \n", Indent(nIndents));

                nIndents += 2;

                for ( i = 0; i < cAttrs; i++ )
                {
                    if (!(i % 4))
                        Printf("%s", Indent(nIndents));

                    Printf("0x%-8x    ", pGCDList->PartialAttrVecDel.V1.rgPartialAttr[i]);

                    if (!((i+1) % 4) || ((i+1) == cAttrs))
                        Printf("\n");
                }

                FreeMemory( pGCDList );
                fSuccess = TRUE;
            }
        }
    }

    return(fSuccess);
}

BOOL
Dump_GCDeletionListProcessed(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public GCDeletionListProcessed dump routine - print attids for in
    a row.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of GCDeletionListProcessed in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                    fSuccess = FALSE;
    GCDeletionListProcessed *pGCDListProcessed = NULL;
    DWORD cAttrs, i;

    Printf("%sGCDeletionListProcessed:\n\n", Indent(nIndents));
    nIndents += 2;

    pGCDListProcessed = (GCDeletionListProcessed *) ReadMemory(pvProcess,
                                                        sizeof(GCDeletionListProcessed));

    if ( NULL != pGCDListProcessed )
    {
        if (!pGCDListProcessed->pNC)
        {
            Printf("%sNo Deletion List is currently processed\n", Indent(nIndents));
        }
        else
        {
            Dump_DSNAME(nIndents, pGCDListProcessed->pNC);
            Printf("%spGCDList @ %p\n", Indent(nIndents),
                        pGCDListProcessed->pGCDList);
            Printf("%spurgeCount - %d\n", Indent(nIndents),
                        pGCDListProcessed->purgeCount);
            Printf("%sfReload - %s\n", Indent(nIndents),
                        pGCDListProcessed->fReload ? "true" : "false");
            Printf("%sfNCHeadPurged - %s\n", Indent(nIndents),
                        pGCDListProcessed->fNCHeadPurged ? "true" : "false");
        }

        FreeMemory(pGCDListProcessed);
    }

    return(fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsid\dsid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsid.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <fileno.h>



struct namepair {
    int key;
    char * name;
};

struct namepair dirtbl [] = {
    {DIRNO_COMMON, "common"},
    {DIRNO_DRA, "dra"},
    {DIRNO_DBLAYER, "dblayer"},
    {DIRNO_SRC, "src"},
    {DIRNO_NSPIS, "nspis"},
    {DIRNO_DRS, "drsserv"},
    {DIRNO_XDS, "xdsserv"},
    {DIRNO_BOOT, "boot"},
    {DIRNO_PERMIT, "permit"},
    {DIRNO_ALLOCS, "allocs"},
    {DIRNO_LIBXDS, "libxds"},
    {DIRNO_SAM, "SAM"},
    {DIRNO_LDAP, "ldap"},
    {DIRNO_SDPROP, "sdprop"},
    {DIRNO_TASKQ, "taskq"},
    {DIRNO_KCC, "kcc"},
    {DIRNO_ISMSERV, "ism\\server"},
    {DIRNO_NTDSETUP, "ntdsetup"},
    {DIRNO_NTDSAPI, "ntdsapi"},
    {DIRNO_NTDSCRIPT, "util\\ntdscript"},
    {DIRNO_JETBACK, "jetback"},
    {DIRNO_KCCSIM, "kcc\\sim"},
    {DIRNO_UTIL, "util"},
    {0,0}
};

// Please add constants to this table alphabetically by constant, or
// we'll never find the ones we've missed.

struct namepair filetbl [] = {
    {FILENO_NSPSERV,"nspserv.c"},
    {FILENO_MODPROP,"modprop.c"},
    {FILENO_ABSERV,"abserv.c"},
    {FILENO_MSNOTIF,"msnotif.c"},
    {FILENO_MSDSSERV,"msdsserv.c"},
    {FILENO_DETAILS,"details.c"},
    {FILENO_ABTOOLS,"abtools.c"},
    {FILENO_ABBIND,"abbind.c"},
    {FILENO_ABSEARCH,"absearch.c"},
    {FILENO_ABNAMEID,"abnameid.c"},
    {FILENO_NSPNOTIF,"nspnotif.c"},
    {FILENO_ALERT,"alert.c"},
    {FILENO_ALLOCS,"allocs.c"},
    {FILENO_ATTRLIST,"attrlist.c"},
    {FILENO_BOOT_PARSEINI, "parseini.cxx"},
    {FILENO_CHECKSD,"checksd.c"},
    {FILENO_CLIENT,"client.c"},
    {FILENO_COMPRES,"compres.c"},
    {FILENO_KCC_KCCDSA_HXX, "kccdsa.hxx"},
    {FILENO_KCC_KCCDYNAR_HXX, "kccdynar.hxx"},
    {FILENO_KCC_KCCSCONN_HXX, "kccsconn.hxx"},
    {FILENO_KCC_KCCSTALE_HXX, "kccstale.hxx"},
    {FILENO_KCC_KCCTRANS_HXX, "kcctrans.hxx"},
    {FILENO_KCC_KCCCONN_HXX, "kccconn.hxx"},
    {FILENO_KCC_KCCCREF_HXX, "kcccref.hxx"},
    {FILENO_KCC_KCCSITE_HXX, "kccsite.hxx"},
    {FILENO_KCCSIM_BUILDCFG, "buildcfg.c"},
    {FILENO_KCCSIM_BUILDMAK, "buildmak.c" },
    {FILENO_KCCSIM_DIR, "dir.c" },
    {FILENO_KCCSIM_KCCSIM, "kccsim.c" },
    {FILENO_KCCSIM_LDIF, "ldif.c" },
    {FILENO_KCCSIM_SIMDSAPI, "simdsapi.c" },
    {FILENO_KCCSIM_SIMISM, "simism.c" },
    {FILENO_KCCSIM_SIMMDNAM, "simmdnam.c" },
    {FILENO_KCCSIM_SIMMDREP, "simmdrep.c" },
    {FILENO_KCCSIM_SIMMDWT, "simmdmt.c" },
    {FILENO_KCCSIM_SIMTIME, "simtime.c"},
    {FILENO_KCCSIM_STATE, "state.c"},
    {FILENO_KCCSIM_USER, "user.c" },
    {FILENO_KCCSIM_UTIL, "util.c"},
    {FILENO_LDAP_COMMAND,"command.cxx"},
    {FILENO_LDAP_GLOBALS,"globals.cxx"},
    {FILENO_LDAP_GLOBALS_HXX,"globals.hxx"},
    {FILENO_LDAP_CONN,"connect.cxx"},
    {FILENO_LDAP_REQUEST_HXX, "request.hxx"},
    {FILENO_LDAP_USERDATA_HXX, "userdata.hxx"},
    {FILENO_CONTEXT,"context.c"},
    {FILENO_DEBUG,"debug.c"},
    {FILENO_DRSUAPI,"drsuapi.c"},
    {FILENO_XDSNOTIF,"xdsnotif.c"},
    {FILENO_DSCONFIG,"dsconfig.c"},
    {FILENO_DSEVENT,"dsevent.c"},
    {FILENO_DSEXCEPT,"dsexcept.c"},
    {FILENO_DSLOGEVT, "dslogevt.cxx"},
    {FILENO_DSUTIL, "dsutil.c" },
    {FILENO_ISMSERV_GRAPH, "graph.c"},
    {FILENO_ISMSERV_ISMSERV_HXX, "service.hxx" },
    {FILENO_ISMSERV_MEMORY, "memory.c" },
    {FILENO_ISMSERV_LIST, "list.c" },
    {FILENO_ISMSERV_TABLE, "table.c"},
    {FILENO_ISMSERV_SIMISM, "simism.c"},
    {FILENO_ISMSERV_SIMISMT, "simismt.c"},
    {FILENO_IDLNOTIF,"idlnotif.c"},
    {FILENO_IDLTRANS,"idltrans.c"},
    {FILENO_INFSEL,"infsel.c"},
    {FILENO_LISTRES,"listres.c"},
    {FILENO_XDSAPI,"xdsapi.c"},
    {FILENO_MODIFY,"modify.c"},
    {FILENO_SYNTAX,"syntax.c"},
    {FILENO_SDPGATE, "sdpgate.c" },
    {FILENO_OMTODSA,"omtodsa.c"},
    {FILENO_SEARCHR,"searchr.c"},
    {FILENO_READRES,"readres.c"},
    {FILENO_DSWAIT,"dswait.c"},
    {FILENO_DBEVAL,"dbeval.c"},
    {FILENO_DBFILTER,"dbfilter.c"},
    {FILENO_DBINIT,"dbinit.c"},
    {FILENO_DBISAM,"dbisam.c"},
    {FILENO_DBJETEX,"dbjetex.c"},
    {FILENO_DBOBJ,"dbobj.c"},
    {FILENO_DBOPEN,"dbopen.c"},
    {FILENO_DBSEARCH,"dbsearch.c"},
    {FILENO_DBSUBJ,"dbsubj.c"},
    {FILENO_DBSYNTAX,"dbsyntax.c"},
    {FILENO_DBTOOLS,"dbtools.c"},
    {FILENO_DBINDEX,"dbindex.c"},
    {FILENO_DBMETA,"dbmeta.c"},
    {FILENO_DBESCROW, "dbescrow.c"},
    {FILENO_DBCACHE, "dbcache.c"},
    {FILENO_DBCONSTR, "dbconstr.c"},
    {FILENO_DIRTY,"dirty.c"},
    {FILENO_DRAASYNC,"draasync.c"},
    {FILENO_DRADIR,"dradir.c"},
    {FILENO_DRAERROR,"draerror.c"},
    {FILENO_DRAGTCHG,"dragtchg.c"},
    {FILENO_DRAINST,"drainst.c"},
    {FILENO_DRAMAIL,"dramail.c"},
    {FILENO_DRAMETA,"drameta.c"},
    {FILENO_DRANCADD,"drancadd.c"},
    {FILENO_DRANCDEL,"drancdel.c"},
    {FILENO_DRANCREP,"drancrep.c"},
    {FILENO_DRASERV,"draserv.c"},
    {FILENO_DRASYNC,"drasync.c"},
    {FILENO_DRAUPDRR,"draupdrr.c"},
    {FILENO_DRAUTIL,"drautil.c"},
    {FILENO_DRASIG,"drasig.c"},
    {FILENO_DRARFMOD,"drarfmod.c"},
    {FILENO_DRAMDERR, "dramderr.c"},
    {FILENO_DSAMAIN,"dsamain.c"},
    {FILENO_DSANOTIF,"dsanotif.c"},
    {FILENO_DSATOOLS,"dsatools.c"},
    {FILENO_DSTASKQ,"dstaskq.c"},
    {FILENO_HIERTAB,"hiertab.c"},
    {FILENO_LDAP_INIT,"init.cxx"},
    {FILENO_LDAP_LDAP,"ldap.cxx"},
    {FILENO_LDAP_CONV,"ldapconv.cxx"},
    {FILENO_LOOPBACK,"loopback.c"},
    {FILENO_MAPPINGS,"mappings.c"},
    {FILENO_MDADD,"mdadd.c"},
    {FILENO_MDBIND,"mdbind.c"},
    {FILENO_MDCHAIN,"mdchain.c"},
    {FILENO_MDCOMP,"mdcomp.c"},
    {FILENO_MDDEL,"mddel.c"},
    {FILENO_MDDIT,"mddit.c"},
    {FILENO_MDERRMAP,"mderrmap.c"},
    {FILENO_MDERROR,"mderror.c"},
    {FILENO_MDINIDSA,"mdinidsa.c"},
    {FILENO_MDFIND,"mdfind.c"},
    {FILENO_MDLIST,"mdlist.c"},
    {FILENO_MDMOD,"mdmod.c"},
    {FILENO_MDMODDN,"mdmoddn.c"},
    {FILENO_MDNAME,"mdname.c"},
    {FILENO_MDNDNC, "mdndnc.c"},
    {FILENO_MDNOTIFY,"mdnotify.c"},
    {FILENO_MDREAD,"mdread.c"},
    {FILENO_MDREMOTE,"mdremote.c"},
    {FILENO_MDSEARCH,"mdsearch.c"},
    {FILENO_MDUPDATE,"mdupdate.c"},
    {FILENO_MSRPC,"msrpc.c"},
    {FILENO_NTUTILS,"ntutils.c"},
    {FILENO_NTDSAPI_SPN, "spn.c"},
    {FILENO_NTDSAPI_DSRSA, "dsrsa.c"},
    {FILENO_NTDSAPI_SITEINFO_POSTXP, "siteinfo-postxp.c"},
    {FILENO_NTDSAPI_BIND_POSTXP, "bind-postxp.c"},
    {FILENO_PICKEL,"pickel.c"},
    {FILENO_LDAP_REQ,"request.cxx"},
    {FILENO_IMPERSON,"imperson.c"},
    {FILENO_SAM,"SAM"},
    {FILENO_SCACHE,"scache.c"},
    {FILENO_SAMLOGON,"samlogon.c"},
    {FILENO_SAMWRITE,"samwrite.c"},
    {FILENO_LDAP_SECURE,"secure.cxx"},
    {FILENO_LDAP_USER,"userdata.cxx"},
    {FILENO_X500PERM,"x500perm.c"},
    {FILENO_LDAP_CORE,"ldapcore.cxx"},
    {FILENO_LDAP_LIMITS,"limits.cxx"},
    {FILENO_LDAP_MISC,"misc.cxx"},
    {FILENO_LDAP_ENCODE,"encode.cxx"},
    {FILENO_LDAP_LDAPBER,"ldapber.cxx"},
    {FILENO_LDAP_DECODE,"decode.cxx"},
    {FILENO_DRAXUUID,"draxuuid.c"},
    {FILENO_DRAUPTOD,"drauptod.c"},
    {FILENO_CRACKNAM,"cracknam.c"},
    {FILENO_SPNOP,"spnop.c"},
    {FILENO_DOMINFO,"dominfo.c"},
    {FILENO_DBPROP,"dbprop.c"},
    {FILENO_PROPDMON,"propdmon.c"},
    {FILENO_PROPQ,"propq.c"},
    {FILENO_TASKQ_TASKQ,"taskq.c"},
    {FILENO_TASKQ_TIME,"time.c"},
    {FILENO_KCC_KCCMAIN,"kccmain.cxx"},
    {FILENO_KCC_KCCLINK,"kcclink.cxx"},
    {FILENO_KCC_KCCCONN,"kccconn.cxx"},
    {FILENO_KCC_KCCCREF,"kcccref.cxx"},
    {FILENO_KCC_KCCDSA,"kccdsa.cxx"},
    {FILENO_KCC_KCCDUAPI,"kccduapi.cxx"},
    {FILENO_KCC_KCCTASK,"kcctask.cxx"},
    {FILENO_KCC_KCCTOPL,"kcctopl.cxx"},
    {FILENO_KCC_KCCSITE,"kccsite.cxx"},
    {FILENO_KCC_KCCTOOLS,"kcctools.cxx"},
    {FILENO_KCC_KCCNCTL,"kccnctl.cxx"},
    {FILENO_KCC_KCCDYNAR,"kccdynar.cxx"},
    {FILENO_KCC_KCCSTETL,"kccstetl.cxx"},
    {FILENO_KCC_KCCSCONN,"kccsconn.cxx"},
    {FILENO_KCC_KCCTRANS,"kcctrans.cxx"},
    {FILENO_KCC_KCCCACHE_HXX,"kcccache.hxx"},
    {FILENO_KCC_KCCCACHE,"kcccache.cxx"},
    {FILENO_KCC_KCCSITELINK,"kccsitelink.cxx"},
    {FILENO_KCC_KCCBRIDGE, "kccbridge.cxx"},
    {FILENO_GCVERIFY,"gcverify.c"},
    {FILENO_GCLOGON, "gclogon.c"},
    {FILENO_MDCTRL, "mdctrl.c"},
    {FILENO_DISKBAK,"diskbak.c"},
    {FILENO_NTDSAPI, "ntdsapi.c"},
    {FILENO_NTDSCRIPT, "script.cxx"},
    {FILENO_PARSEDN, "parsedn.c"},
    {FILENO_DRACHKPT,"drachkpt.c"},
    {FILENO_RPCCANCL, "rpccancl.c"},
    {FILENO_GTCACHE, "gtcache.c"},
    {FILENO_DSTRACE, "dstrace.c"},
    {FILENO_ISMSERV_TRANSPRT, "transprt.cxx"},
    {FILENO_ISMSERV_PENDING, "pending.cxx"},
    {FILENO_DRACRYPT, "dracrypt.c"},
    {FILENO_ADDSERV, "addserv.c"},
    {FILENO_INSTALL, "install.cxx"},
    {FILENO_FPOCLEAN, "fpoclean.c"},
    {FILENO_SERVINFO, "servinfo.c"},
    {FILENO_PHANTOM, "phantom.c"},
    {FILENO_ISMSERV_LDAPOBJ, "ldapobj.c"},
    {FILENO_ISMSERV_ISMAPI, "ismapi.cxx"},
    {FILENO_ISMSERV_SERVICE, "service.cxx"},
    {FILENO_ISMSERV_MAIN, "main.cxx"},
    {FILENO_ISMSERV_IPSEND, "ip\\sendrecv.c"},
    {FILENO_ADDOBJ, "addobj.cxx"},
    {FILENO_ISMSERV_XMITRECV, "smtp\\xmitrecv.c"},
    {FILENO_NTDSCRIPT_NTDSCONTENT, "NTDSConent.cxx"},
    {FILENO_NTDSETUP_NTDSETUP, "ntdsetup\\ntdsetup.c"},
    {FILENO_XDOMMOVE, "xdommove.c"},
    {FILENO_ISMSERV_ROUTE, "route.c"},
    {FILENO_ISMSERV_ADSISUPP, "smtp\\adsisupp.cxx"},
    {FILENO_ISMSERV_ISMSMTP, "smtp\\ismsmtp.c"},
    {FILENO_ISMSERV_CDOSUPP, "smtp\\cdosupp.c"},
    {FILENO_NTDSAPI_REPLICA, "replica.c"},
    {FILENO_NTDSCRIPT_LOG,"log.cxx"},
    {FILENO_NTDSCRIPT_PARSERMAIN, "parsermain.cxx"},
    {FILENO_DRAINFO, "drainfo.c"},
    {FILENO_MAPSPN, "mapspn.c"},
    {FILENO_PEK, "pek.c"},
    {FILENO_ADDSID, "addsid.c"},
    {FILENO_DRASCH, "drasch.c"},
    {FILENO_DRAINIT,"drainit.c"},
    {FILENO_SCCHK,"scchk.c"},
    {FILENO_ISMSERV_ISMIP, "ip\\ismip.c"},
    {FILENO_SAMCACHE, "samcache.c"},
    {FILENO_LINKCLEAN, "linkclean.c"},
    {FILENO_DRADEMOT, "drademot.c"},
    {FILENO_DRAMSG, "dramsg.c"},
    {FILENO_DRARPC, "drarpc.c"},
    {FILENO_JETBACK, "jetback.c"},
    {FILENO_JETREST, "jetrest.c"},
    {FILENO_JETBACK_COMMON, "common.c"},
    {FILENO_JETBACK_JETBCLI_JETBCLI, "jetbcli.c"},
    {FILENO_JETBACK_JETBCLI_JETRCLI, "jetrcli.c"},
    {FILENO_JETBACK_JETBACK, "jetback.c"},
    {FILENO_JETBACK_JETREST, "jetrest.c"},
    {FILENO_SNAPSHOT, "snapshot.cxx"},
    {FILENO_DIRAPI, "dirapi.c"},
    {FILENO_LHT, "lht.c"},
    {FILENO_SYNC, "sync.c"},
    {FILENO_UTIL_DNSRESL_DNS, "dnsresl\\dns.c"},
    {FILENO_UTIL_BASE64_BASE64,	"base64\\base64.c"},
    {FILENO_UTIL_REPLSTRUCT_REPLDEMARSHAL, "replstruct\\repldemarshal.cxx"},
    {FILENO_UTIL_REPLSTRUCT_REPLMARSHALBLOB, "replstruct\\replmarshalblob.cxx"},
    {FILENO_UTIL_REPLSTRUCT_REPLMARSHALXML, "replstruct\\replmarshalxml.cxx"},
    {FILENO_UTIL_REPLSTRUCT_REPLSTRUCTINFO, "replstruct\\replstructinfo.cxx"},
    {FILENO_UTIL_XLIST_DCLIST, "x_list\\dc_list.c" },
    {FILENO_UTIL_XLIST_UTIL, "x_list\\util.c" },
    {FILENO_UTIL_XLIST_LDAP, "x_list\\x_list_ldap.c" },
    {FILENO_UTIL_XLIST_ERR, "x_list\\x_list_err.c" },
    {FILENO_UTIL_XLIST_DCLIST, "x_list\\dc_list.c" },
    {FILENO_UTIL_XLIST_SITELIST, "x_list\\site_list.c" },
    {FILENO_UTIL_XLIST_OBJLIST, "x_list\\obj_list.c" },
    {FILENO_UTIL_XLIST_OBJDUMP, "x_list\\obj_dump.c" },
    {FILENO_QUOTA, "quota.c"},
    {FILENO_QTCOMMON, "qtcommon.c"},
    {0, 0}
};




void __cdecl main(int argc, char ** argv)
{
    int line;
    int fileno;
    int dirno;
    int dirfile;
    int i;
    char * stopstring;
    char * dirname;
    char * filename;

    dirname = filename = "huh?";

    if (argc != 2) {
        printf("usage: %s id\n", argv[0]);
        exit(1);
    }

    dirfile = strtol(argv[1], &stopstring, 16);
    if (dirfile == 0) {
        printf("I can't make sense of %s\n", argv[1]);
        exit(1);
    }

    line = dirfile & 0x0000ffff;
    dirno = (dirfile & 0xff000000) >> 24;
    fileno = (dirfile & 0x00ff0000) >> 16;
    dirfile >>= 16;

    for (i=0; dirtbl[i].name; i++) {
        if (dirtbl[i].key == dirno << 8) {
            dirname = dirtbl[i].name;
            break;
        }
    }
    for (i=0; filetbl[i].name; i++) {
        if (filetbl[i].key == dirfile) {
            filename = filetbl[i].name;
            break;
        }
    }

    printf("dir %u, file %u (%s\\%s), line %u\n", dirno, fileno, dirname,
           filename, line);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dsexts\util.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Helper functions for dsexts.dll ntsd/windbg debugger extensions.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    24-Apr-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"

PVOID
ReadMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads memory from the address space of the process
    being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    Pointer to debugger local memory.

--*/

{
    SIZE_T cRead;
    PVOID pv;

    if ( gfVerbose )
        Printf("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = HeapAlloc(GetProcessHeap(), 0, dwSize)) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize);
        return(NULL);
    }

    if ( gfVerbose )
        Printf("ReadProcessMemory(0x%x @ %p)\n", dwSize, pvAddr);

    if ( !ReadProcessMemory(ghDbgProcess, pvAddr, pv, dwSize, &cRead) )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory error %x (%x@%p)\n",
               GetLastError(),
               dwSize,
               pvAddr);
        return(NULL);
    }

    if ( dwSize != cRead )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory size error - off by %x bytes\n",
               (dwSize > cRead) ? dwSize - cRead : cRead - dwSize);
        return(NULL);
    }

    return(pv);
}

PVOID
ReadStringMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads a NULL terminated string from the address space of
    the process being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Maximum size of string

Return Value:

    Pointer to debugger local memory.

--*/

{
    PVOID pv;
    DWORD count;

    if ( gfVerbose )
        Printf("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = HeapAlloc(GetProcessHeap(), 0, dwSize)) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize);
        return(NULL);
    }

    if ( gfVerbose )
        Printf("ReadStringMemory(0x%x @ %p)\n", dwSize, pvAddr);

    for (count =0; count < dwSize; count++) {
        if ( !ReadProcessMemory(ghDbgProcess, (LPVOID)((char *)pvAddr+count), (LPVOID)((char *)pv+count), 1, NULL) )
        {
            FreeMemory(pv);
            Printf("ReadProcessMemory error %x (%x@%p)\n",
                   GetLastError(),
                   1,
                   (char *)pvAddr+count);
            return(NULL);
        }
        if (*((char *)pv+count) == '\0') {
            break;
        }
    }
    *((char *)pv + dwSize - 1) = '\0';

    return(pv);
}

PVOID
ReadUnicodeMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads a NULL terminated unicode string from the address space of
    the process being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Maximum size of string (in WCHARs)

Return Value:

    Pointer to debugger local memory.

--*/

{
    PWCHAR pv;
    DWORD count;

    if ( gfVerbose )
        Printf("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = (PWCHAR)HeapAlloc(GetProcessHeap(), 0, dwSize*sizeof(WCHAR))) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize*sizeof(WCHAR));
        return(NULL);
    }

    if ( gfVerbose )
        Printf("ReadUnicodeMemory(0x%x @ %p)\n", dwSize, pvAddr);

    for (count =0; count < dwSize; count++) {
        if ( !ReadProcessMemory(ghDbgProcess, (LPVOID)((PWCHAR)pvAddr+count), (LPVOID)(pv+count), sizeof(WCHAR), NULL) )
        {
            FreeMemory(pv);
            Printf("ReadProcessMemory error %x (%x@%p)\n",
                   GetLastError(),
                   sizeof(WCHAR),
                   (PWCHAR)pvAddr+count);
            return(NULL);
        }
        if (pv[count] == '\0') {
            break;
        }
    }
    pv[dwSize - 1] = '\0';

    return(pv);
}

VOID
FreeMemory(
    IN PVOID pv)

/*++

Routine Description:

    Frees memory returned by ReadMemory.

Arguments:

    pv - Address of debugger local memory to free.

Return Value:

    None.

--*/

{
    if ( gfVerbose )
        Printf("HeapFree(%p)\n", pv);

    if ( NULL != pv )
    {
        if ( !HeapFree(GetProcessHeap(), 0, pv) )
        {
            Printf("Error %x freeing memory at %p\n", GetLastError(), pv);
        }
    }
}

VOID
ShowBinaryData(
    IN DWORD   nIndents,
    IN PVOID   pvData,
    IN DWORD   dwSize)

/*++

Routine Description:

    Pretty prints debugger local memory to debugger output.

Arguments:

    nIndents - Number of indentation levels desired.

    pvData - Address of debugger local memory to dump.

    dwSize -  Count of bytes to dump.

Return Value:

    None.

--*/

{
    DWORD   i;
    char    line[20];
    PBYTE   pb = (PBYTE) pvData;

    line[16] = '\0';

    if ( dwSize > 65536 )
    {
        Printf("%sShowBinaryData - truncating request to 65536\n",
               Indent(nIndents));
        dwSize = 65536;
    }

    for ( ; dwSize > 0 ; )
    {
        Printf("%s", Indent(nIndents));

        for ( i = 0; (i < 16) && (dwSize > 0) ; i++, dwSize-- )
        {
            Printf("%02x ", (unsigned) *pb);

            if ( isprint(*pb) )
                line[i] = *pb;
             else
                line[i] = '.';

            pb++;
        }

        if ( i < 16 )
        {
            for ( ; i < 16 ; i++ )
            {
                Printf("   ");
                line[i] = ' ';
            }
        }

        Printf("\t%s\n", line);

        if ( CheckC() )
            break;
    }
}

BOOL
Dump_Binary(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps binary data - defaults to 100 bytes.  Most debuggers have
    a native command for this but it serves as a test case for the
    dump mechanism.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - Address in process being debugged to dump.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    PVOID pvLocal;

    if ( NULL != (pvLocal = ReadMemory(pvProcess, 100)) )
    {
        ShowBinaryData(1, pvLocal, 100);
        FreeMemory(pvLocal);
        return(TRUE);
    }

    return(FALSE);
}

BOOL
Dump_BinaryCount(
    IN DWORD nIndents,
    IN PVOID pvProcess,
    IN DWORD cBytes)

/*++

Routine Description:

    Dumps cBytes of binary data.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - Address in process being debugged to dump.

    cBytes - Count of bytes to dump.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    PVOID pvLocal;

    if ( NULL != (pvLocal = ReadMemory(pvProcess, cBytes)) )
    {
        ShowBinaryData(nIndents, pvLocal, cBytes);
        FreeMemory(pvLocal);
        return(TRUE);
    }

    return(FALSE);
}

#define MAX_INDENT          50
#define SPACES_PER_INDENT   2

CHAR    _indents[(SPACES_PER_INDENT * MAX_INDENT) + 1];
DWORD   _lastIndent = (MAX_INDENT + 1);

PCHAR
Indent(
    IN DWORD nIndents)

/*++

Routine Description:

    Returns a pointer to a string with spaces representing the desired
    indentation level.  This function is to be used as follows:

        Printf("%sDataLabel - %d\n", Indent(5), value);

Arguments:

    nIndents - number of indentation levels desired.

Return Value:

    Pointer to indentation string.

--*/

{
    if ( _lastIndent > MAX_INDENT )
    {
        memset(_indents, ' ', sizeof(_indents));
        _lastIndent = 0;
    }

    //
    // Replace NULL character from last call and insert new NULL
    // character as required.
    //

    _indents[SPACES_PER_INDENT * _lastIndent] = ' ';

    if ( nIndents >= MAX_INDENT )
        nIndents = MAX_INDENT;

    _lastIndent = nIndents;

    _indents[SPACES_PER_INDENT * nIndents] = '\0';

    return(_indents);
}

CHAR _oidstring[64];

PCHAR
_DecodeOID(                 // produces a printable decoded OID
    IN PCHAR   pbOID,       // pointer to buffer holding encoded OID
    IN DWORD   cbOID)       // count of bytes in encoded OID
{
    PCHAR pTmp;
    DWORD val;
    DWORD i,j;

    if (cbOID < 2) {
        strcpy(_oidstring, "bogus OID");
	return _oidstring;
    }

    _oidstring[0] = 'O';
    _oidstring[1] = 'I';
    _oidstring[2] = 'D';

    pTmp = &_oidstring[3];

    val = pbOID[0] / 40;
    sprintf(pTmp, ".%u", val);
    while(*pTmp)
      ++pTmp;

    val = pbOID[0] % 40;
    sprintf(pTmp, ".%u", val);
    while(*pTmp)
      ++pTmp;

    i = 1;

    while (i < cbOID) {
	j = 0;
	val = pbOID[i] & 0x7f;
	while (pbOID[i] & 0x80) {
	    val <<= 7;
	    ++i;
	    if (++j > 4 || i >= cbOID) {
		// Either this value is bigger than we can handle (we
		// don't handle values that span more than four octets)
		// -or- the last octet in the encoded string has its
		// high bit set, indicating that it's not supposed to
		// be the last octet.  In either case, we're sunk.
		strcpy (_oidstring, "really bogus OID");
		return _oidstring;
	    }
	    val |= pbOID[i] & 0x7f;
	}
	sprintf(pTmp, ".%u", val);
	while(*pTmp)
	  ++pTmp;
	++i;
    }

    *pTmp = '\0';

    return _oidstring;
}

BOOL
WriteMemory(
    IN PVOID  pvProcess,
    IN PVOID  pvLocal,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function writes memory into the address space of the process
    being debugged

Arguments:

    pvProcess - Address of memory block to write in the address space of the
        process being debugged.

    pvLocal - Address of the local block to be copied

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    TRUE on success, FALSE on failure

--*/

{
    BOOL fSuccess;
    SIZE_T cWritten;

    fSuccess = WriteProcessMemory(ghDbgProcess,
				  pvProcess,
				  pvLocal,
				  dwSize,
				  &cWritten);
    if (fSuccess && (dwSize != cWritten)) {
	Printf("WriteProcessMemory succeeded, but wrote %u bytes instead of %u\n",
	       cWritten,
	       dwSize);
    }

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dslogs\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       main.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : main.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 3/9/1998
*    Description : Main entry point for dslogs
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef MAIN_CXX
#define MAIN_CXX



// include //
#include "helper.h"
#include <stdlib.h>
#include <winldap.h>    // for LDAP handles
#include <rpc.h>        // for SEC_WINNT_AUTH_IDENTITY
#include <algorithm>    // stl for find
#include <string>
#include <winsock2.h>
#include "evtlog.hxx"
#include "cfgstore.hxx"
#include "excpt.hxx"
using   namespace std;


// defines //
// constant strings



// types //
typedef enum _Target { T_ENTERPRISE, T_DOMAIN, T_SERVER, T_NULL } TARGETTYPE;

typedef struct _CmdLine{

   //
   // general
   //
   TARGETTYPE TargetType;
   LPTSTR pszTarget;             // target servers string (see usage)
   //
   //  filters
   //
   ULONG  ulSeconds;             // period filter
   DWORD type;
   //
   // output
   //
   LPTSTR pszLogfile;
   EVTFORMAT format;

} CMDLINE;



// global variables //
CMDLINE g_CmdLine;

// prototypes //
VOID usage(LPTSTR lpProgram);
BOOL ProcessArgs(INT argc, CHAR *argv[]);
VOID InitializeProcess(void);


// functions //




/*+++
Function   : ProcessArgs
Description: process command line arguments, validates & assign globals
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ProcessArgs(INT argc, TCHAR *argv[]){

   INT i;
   LPTSTR pTmp, pEsc, pVal;
   BOOL bStatus = TRUE;
   DWORD EventType=0;
   //
   // init command line defaults
   //
   g_CmdLine.TargetType=T_DOMAIN;
   g_CmdLine.pszTarget=NULL;
   g_CmdLine.ulSeconds=3600*24;        // one day
   g_CmdLine.pszLogfile=(LPTSTR)&(szDefLogfile[0]);
   g_CmdLine.format = EF_TAB;
   g_CmdLine.type = EVENTLOG_ERROR_TYPE|EVENTLOG_WARNING_TYPE;



   _tprintf(_T("Command arguments:\n"));
   dprintf(DBG_FLOW, _T("Call: ProcessArgs"));
   for(i=1; i<argc; i++){

      if((argv[i][0] != '-' &&
         argv[i][0] != '/') ||
         (_tcslen(argv[i]) <= 1))
         usage(argv[0]);          // exit point.

      pEsc = &(argv[i][sizeof(TCHAR)]);

      //
      // get targets
      //
      if(_tcsnicmp(pEsc, _T("ent"), _tcslen(_T("ent"))) == 0){
            g_CmdLine.TargetType=T_ENTERPRISE;
            g_CmdLine.pszTarget = NULL;
            _tprintf(_T("Target: ENTERPRISE\n"));
      }
      else if(_tcsnicmp(pEsc, _T("dmn:"), _tcslen(_T("dmn:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("dmn:"))]);
         if(pVal[0] == '\0'){
            g_CmdLine.TargetType=T_DOMAIN;
            g_CmdLine.pszTarget=NULL;
            _tprintf(_T("Target: Default domain\n"));
         }
         else{
            g_CmdLine.TargetType=T_DOMAIN;
            g_CmdLine.pszTarget=pVal;
            _tprintf(_T("Target: DOMAINS {%s}\n"), pVal);
         }
      }
      else if(_tcsnicmp(pEsc, _T("svr:"), _tcslen(_T("svr:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("svr:"))]);
         if(pVal[0] == '\0'){
            g_CmdLine.TargetType=T_SERVER;
            g_CmdLine.pszTarget=NULL;
            _tprintf(_T("Target: Default server\n"));
         }
         else{
            g_CmdLine.TargetType=T_SERVER;
            g_CmdLine.pszTarget= pVal;
            _tprintf(_T("Target: SERVERS {%s}\n"), g_CmdLine.pszTarget);
         }
      }
      //
      // Event type
      //
      else if(_tcsnicmp(pEsc, _T("type:"), _tcslen(_T("type:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("type:"))]);
         if(pVal[0] == '\0'){
            usage(argv[0]);
         }
         else{
            string strType(pVal);
            ctype<TCHAR> cType;
            cType.tolower(strType.begin(), strType.end());
            if(strType.find(_T("all")) != string::npos){
               EventType |= (DWORD)-1;
            }
            if(strType.find(_T("success")) != string::npos){
               EventType |= EVENTLOG_SUCCESS;
            }
            if(strType.find(_T("error")) != string::npos){
               EventType |= EVENTLOG_ERROR_TYPE;
            }
            if(strType.find(_T("warn")) != string::npos){
               EventType |= EVENTLOG_WARNING_TYPE;
            }
            if(strType.find(_T("info")) != string::npos){
               EventType |= EVENTLOG_INFORMATION_TYPE;
            }
            if(strType.find(_T("audit_success")) != string::npos){
               EventType |= EVENTLOG_AUDIT_SUCCESS;
            }
            if(strType.find(_T("audit_failure")) != string::npos){
               EventType |= EVENTLOG_AUDIT_FAILURE;
            }
            _tprintf(_T("Event Type: 0x%x\n"), EventType);
         }
      }
      //
      // get period
      //
      else if(_tcsnicmp(pEsc, _T("period:"), _tcslen(_T("period:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("period:"))]);
         if(pVal[0] == '\0')
            usage(argv[0]);
         else{
            ULONG ulFactor = 3600;
            if(pVal[_tcslen(pVal)-sizeof(TCHAR)] == 'd'){
               ulFactor *=24;
               pVal[_tcslen(pVal)-sizeof(TCHAR)] = '\0';
            }
            else if(pVal[_tcslen(pVal)-sizeof(TCHAR)] == 'h'){
               pVal[_tcslen(pVal)-sizeof(TCHAR)] = '\0';
            }

            LONG lTmp = _ttol(pVal);
            if(lTmp <= 0)
               usage(argv[0]);
            g_CmdLine.ulSeconds = (ULONG)lTmp;
            g_CmdLine.ulSeconds *= ulFactor;
            _tprintf(_T("Period: %lu (sec)\n"), g_CmdLine.ulSeconds);
         }
      }
      //
      // get output file
      //
      else if(_tcsnicmp(pEsc, _T("file:"), _tcslen(_T("file:"))) == 0){
         pVal = &(pEsc[_tcslen("file:")]);
         if(pVal[0] == '\0')
            usage(argv[0]);
         else{
            g_CmdLine.pszLogfile = pVal;
            _tprintf(_T("Output file: %s\n"), g_CmdLine.pszLogfile);
         }
      }
      //
      // get output format
      //
      else if(_tcsnicmp(pEsc, _T("format:"), _tcslen(_T("format:"))) == 0){
         pVal = &(pEsc[_tcslen("format:")]);
         if(pVal[0] == '\0')
            usage(argv[0]);
         else{
            if(!(_tcsicmp(_T("TAB"), pVal))){
               g_CmdLine.format = EF_TAB;
            }
            else if(!(_tcsicmp(_T("COMMA"), pVal))){
               g_CmdLine.format = EF_COMMA;
            }
            else if(!(_tcsicmp(_T("RECORD"), pVal))){
               g_CmdLine.format = EF_RECORD;
            }
            else{
               usage(argv[0]);
            }
            _tprintf(_T("Output format: %s\n"), pVal);
         }
      }
      //
      // take the rest (inc help)
      //
      else
         usage(argv[0]);
   }

   if(EventType != 0){
      g_CmdLine.type = EventType;
   }

   return bStatus;
}



/*+++
Function   : usage
Description: print usage message & aborts.
Parameters :
Return     :
Remarks    : none.
---*/
VOID usage(LPTSTR lpProgram){

   dprintf(DBG_ERROR, _T("[DsLogs!usage] Error: Invalid usage"));
   _tprintf(_T("Usage: %s [target] [operation] [filters] [output]\n"), lpProgram);

   _tprintf(_T("target: -[ent|dmn:<dmnlist>|svr:<dclist>]\n"));
   _tprintf(_T(" -ent: get enterprise logs OR \n"));
   _tprintf(_T(" -dmn:domain1;domain2;... get domain's logs OR\n"));
   _tprintf(_T(" -svr:dc1;dc2... get specified machine logs\n"));
   _tprintf(_T("filters: -[period:#[d|h] [type:<type combination>]]\n"));
   _tprintf(_T(" -period:#[d|h] where # is number of d for days, h for hours (def: 24h)\n"));
   _tprintf(_T(" -type:[ALL|SUCCESS|ERROR|WARN|INFO|AUDIT_SUCESS|AUDIT_FAILURE]\n\tany combination is valid but none\n"));
   _tprintf(_T("output: [file:<logfile>] [type:[TAB|COMMA|RECORD]]\n"));
   _tprintf(_T(" -file:<logfile> to specify results log file name (def:%s)\n"), szDefLogfile);
   _tprintf(_T(" -format:[TAB|COMMA|RECORD] output format style\n"));
   _tprintf(_T("Notes:\n"));
   _tprintf(_T(" - No spaces in Option formats i.e. Option:value\n"));
   _tprintf(_T(" - Default run is to retreive all type events forthe last\nday from the enterprise.\n"));
   _tprintf(_T(" - Have ntdsmsg.dll in your path to get full event parsing.\n"));
   ExitProcess(1);
}






/*+++
Function   : InitializeProcess
Description: initialize debug info & process command line
Parameters :
Return     :
Remarks    : none.
---*/
VOID InitializeProcess(void){

   WORD wVersionRequested=0;
   WSADATA wsaData;
   INT iStatus=0;

   //
   // initialize winsock
   //
   wVersionRequested = MAKEWORD( 2, 2 );
   iStatus = WSAStartup(wVersionRequested, &wsaData);
   if ( LOBYTE( wsaData.wVersion ) != 2 ||
      HIBYTE( wsaData.wVersion ) != 2 ) {
      WSACleanup( );
      fatal(_T("Cannot initialize winsock"));
   }

   //
   // Set automatic memory diagnostics
   //
#ifdef _DEBUG_MEMLEAK
   _CrtSetDbgFlag(_CRTDBG_CHECK_ALWAYS_DF |
                  _CRTDBG_CHECK_CRT_DF |
                  _CRTDBG_LEAK_CHECK_DF |
                  _CRTDBG_ALLOC_MEM_DF |
                  _CRTDBG_DELAY_FREE_MEM_DF);
#endif

   //
   // application debugging flags
   //
//  g_dwDebugLevel=DBG_ERROR|DBG_FLOW ;
   g_dwDebugLevel=DBG_ERROR;

}





/*+++
Function   : main
Description: PROGRAM ENTRY POINT
Parameters :
Return     :
Remarks    : none.
---*/
INT _cdecl main(INT argc, TCHAR *argv[]){

   //
   // general vars
   //
   ULONG ulStatus = 0;
   INT i=0;

   InitializeProcess();

   dprintf(DBG_FLOW, _T("*** %s entry point ***\n"), argv[0]);
   //
   // program initialization
   //
   if(!ProcessArgs(argc, argv)){
      usage(argv[0]);            // program exit point
   }


   //
   // Get enterprise configuration
   //

   //
   // variables for config parsing
   //
   ConfigStore *cfg  = NULL;
   vector<ServerInfo*> EntSvrLst;
   vector<DomainInfo*>::iterator itDmn;
   vector<ServerInfo*>::iterator itSvr;
   vector<ServerInfo*> ServerList;
   vector<DomainInfo*> Domains;
   LPTSTR pszDmns=NULL, pszSvrs=NULL;
   LPTSTR tkn;

   //
   // skip config fetching if a list of DC's was specified
   //
   if(g_CmdLine.TargetType != T_SERVER){

      _tprintf(_T("> Getting enterprise configuration information...\n"));

      cfg  = new ConfigStore();
      assert(cfg);

      if(!cfg->valid()){
         _tprintf(_T("Failed to create configuration store\n"));
         fatal(_T("Failed to create configuration store\n"));
      }


      Domains = cfg->GetDomainList();

      //
      // Print for debugging
      //
      for(itDmn=Domains.begin();
          itDmn != Domains.end();
          itDmn++){

         _tprintf(_T("Domain %s is hosted on:\n"), (*itDmn)->GetFlatName());

         for(i=1, itSvr=(*itDmn)->ServerList.begin();
             itSvr != (*itDmn)->ServerList.end();
             itSvr++, i++){
            _tprintf(_T(" %d> %s\n"), i, (*itSvr)->m_lpszFlatName);
         }

      }

      EntSvrLst = cfg->GetServerList();
   }



   //
   // Process target
   //
   switch(g_CmdLine.TargetType){
   case T_ENTERPRISE:
      ServerList = EntSvrLst;
      break;
   case T_DOMAIN:
      //
      // For each domain, if we find it, add it's servers to the list of
      // servers.
      //
      if(g_CmdLine.pszTarget == NULL){
         ServerInfo svr;
         if(!svr.valid()){
            _tprintf(_T("Cannot find default domain\n"));
            fatal(_T("Cannot find default domain\n"));
         }
         pszDmns = new TCHAR[_tcslen(svr.m_lpszDomain)+1];
         _tcscpy(pszDmns, svr.m_lpszDomain);
      }
      else{
         pszDmns = new TCHAR[_tcslen(g_CmdLine.pszTarget)+1];
         _tcscpy(pszDmns, g_CmdLine.pszTarget);
      }

      for(i=0, tkn = _tcstok(pszDmns, _T(" ;\0\n"));
             tkn != NULL;
             tkn = _tcstok(NULL, _T(" ;\0\n")), i++){
         //
         // domain string is in tkn. Find it in the domain list & append svr list
         // to global svr list
         //
         vector<ServerInfo*> TmpSvrLst;
         if(cfg->GetServerList(tkn, TmpSvrLst)){
            ServerList.insert(ServerList.end(), TmpSvrLst.begin(), TmpSvrLst.end());

         }

      }

      break;
   case T_SERVER:
      pszSvrs = _strdup(g_CmdLine.pszTarget);
      for(i=0, tkn = _tcstok(pszSvrs, _T(" ;\0\n"));
             tkn != NULL;
             tkn = _tcstok(NULL, _T(" ;\0\n")), i++){
         //
         // No free, but never mind since it's in the program scope
         //
         ServerList.push_back(new ServerInfo(tkn));

      }
      break;
   default:
      _tprintf(_T("Unknown switch case for TargetType\n"));
      fatal(_T("Unknown switch case for TargetType\n"));
   }



   //
   // Fetching event logs
   //
   INT ServerCount = ServerList.size();

   DsEventLogMgr **pDsLogs = new DsEventLogMgr *[ServerCount];
   assert(pDsLogs);

   _tprintf(_T("> Opening %d event logs...\n"), ServerCount);
   //
   // Create & open logs
   //
   for(i=0, itSvr=ServerList.begin();
       itSvr != ServerList.end();
       itSvr++, i++){
      _tprintf(_T(" %d> %s\n"), i+1, (*itSvr)->m_lpszFlatName);
      pDsLogs[i] = new DsEventLogMgr((*itSvr)->m_lpszFlatName);
      assert(pDsLogs[i]);
   }

   //
   // Fork threads & fetch logs
   //
   HANDLE *hThrds = new HANDLE[ServerCount+1];
   INT iThrds=0;
   for(i=0; i<ServerCount; i++){
      if(pDsLogs[i]->valid()){
         if(pDsLogs[i]->startThread())
            hThrds[iThrds++] = pDsLogs[i]->GetThreadHandle();

      }
      else{
         _tprintf(_T("Warning <%lu>: Skipping invalid server %s\n"),
                        pDsLogs[i]->GetLastError(), pDsLogs[i]->name());
      }
   }
   hThrds[i] = NULL;

   //
   // Wait
   //
   _tprintf(_T("Waiting for results...\n"));
   WaitForMultipleObjects(iThrds, hThrds, TRUE, INFINITE);




   //
   // construct event view filter
   //
   EVTFILTER Filter;
   Filter.dwBacklog = g_CmdLine.ulSeconds;
   Filter.bAppend = TRUE;                 // if we overwrite w/ mult threads, we're overwitting ourselves.
   Filter.OutStyle = g_CmdLine.format;
   Filter.dwEvtType = g_CmdLine.type;
   Filter.pMsgLib = (LPTSTR)szMessageLib;


   //
   // print logs
   //
   for(i=0; i<ServerCount; i++){
      _tprintf(_T("Processing Server %s records...\n"), pDsLogs[i]->name());
      INT j=0;
      if(pDsLogs[i]->valid()){
         if(!(pDsLogs[i]->PrintLog(g_CmdLine.pszLogfile, &Filter))){
            _tprintf(_T("Error<%lu>: Failed to write event log\n"), pDsLogs[i]->GetLastError());
         }
         Sleep(500);       // give enough time for close before next open...(nt5 features...)

      }
   }


   dprintf(DBG_FLOW, _T("*** %s exit point ***\n"), argv[0]);

   delete cfg;
   delete []hThrds;
   delete []pDsLogs;
   delete []pszDmns;

   return (INT)ulStatus;
}






#endif

/******************* EOF *********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dswmi\replprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ReplProv.rc
//
#define IDS_PROJNAME                    100
#define IDS_RPCREPLPROV_DESC            101
#define IDR_RpcReplProv                 102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dswmi\replprov\replprov.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    replprov.cpp

Abstract:

    Contains dll entry points for replprov.dll

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000

Environment:

    User Mode - Win32

Revision History:

Notes:
    This cpp file was generated by Visual Studio...(Visual C++ 6.0)

--*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ReplProvps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ReplProv.h"

#include "ReplProv_i.c"
#include "RpcReplProv.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RpcReplProv, CRpcReplProv)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_REPLPROVLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)           
        _Module.Term();
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
// AjayR 7-22-00 modified to add runonce key and then call the
// CComModule::RegisterServer method.
//

STDAPI DllRegisterServer(void)
{
    HKEY hk;
    DWORD dwData, dwErr = 0;
    WCHAR wszFilePath[2*MAX_PATH];HRESULT hr = S_OK;
    DWORD dwFailed = 1;

    dwErr = GetModuleFileNameW(
                _Module.GetModuleInstance(),
                wszFilePath,
                2*MAX_PATH
                );
    //
    // GetModuleFileName returns the length of fileName.
    //
    if (!dwErr) {
        return E_UNEXPECTED;
    }

    // null terminate the path
    wszFilePath[2*MAX_PATH - 1] = L'\0';

    //
    // Add a RunOnce value to do the MOF compile.
    //
    if (RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
            0,
            KEY_WRITE,
            &hk
            )) {
        return E_UNEXPECTED;
    }
    else {
        //
        // This will call the DoMofComp on this dll.
        //
        LPWSTR pszString = NULL;
        DWORD dwLen = wcslen(wszFilePath) 
                     + wcslen(L"rundll32.exe ,DoMofComp")
                     + 1;
        pszString = (LPWSTR) AllocADsMem(sizeof(WCHAR) * dwLen);

        if (!pszString) {
            RegCloseKey(hk);
            return ERROR_OUTOFMEMORY;
        }

        wcscpy(pszString, L"rundll32.exe ");
        wcscat(pszString, wszFilePath);
        wcscat(pszString, L",DoMofComp");

        if (RegSetValueExW(
                hk,
                L"ReplProv1",
                0,
                REG_SZ,
                (LPBYTE)pszString,
                (wcslen(pszString) + 1) * sizeof(WCHAR)
                )
            ) {
            dwErr = GetLastError();
        } 
        else {
            dwErr = 0;
        }

        FreeADsMem(pszString);
        RegCloseKey(hk);
    }

    if (dwErr) {
        return E_UNEXPECTED;
    }

    //
    // Create the key for the event log.
    //
    if (!RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\DSReplicationProvider",
            0, // dwReserved,
            L"", // class name
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &hk,
            NULL // disposition does not matter
            )
        ) {

        DWORD dwLenFile = wcslen(wszFilePath) 
                        + 1;

        if (!RegSetValueExW(
                hk,
                L"EventMessageFile",
                0,
                REG_EXPAND_SZ,
                (LPBYTE)wszFilePath,
                dwLenFile * sizeof(WCHAR)
                )
            ) {
            //
            // Set the supported event types in the TypesSupported subkey.
            //
            DWORD dwData = EVENTLOG_ERROR_TYPE 
                          | EVENTLOG_WARNING_TYPE 
                          | EVENTLOG_INFORMATION_TYPE;

            if (!RegSetValueExW(
                    hk,
                    L"TypesSupported",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwData,
                    sizeof(DWORD))
                ) {
                dwFailed = 0;
            }
        }

        if (dwFailed != 0) {
            //
            // Setting one of the value failed.
            //
            dwFailed = GetLastError();
        }

        //
        // We opened the key successfully so need to close it.
        //
        RegCloseKey(hk);
    }   // event log keys and values.
    else {
        //
        // Creating key failed.
        //
        return E_UNEXPECTED;
    }

    if (dwFailed) {
        return E_UNEXPECTED;
    }

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}


//+----------------------------------------------------------------------------
//
//  Function:  DoMofComp
//
//  Purpose:   Adds the provider classes to the WMI repository.
//
//-----------------------------------------------------------------------------
VOID WINAPI 
DoMofComp(
    HWND hWndParent,
    HINSTANCE hModule,
    PCTSTR ptzCommandLine,
    INT nShowCmd
    )
{
   UNREFERENCED_PARAMETER(hWndParent);
   UNREFERENCED_PARAMETER(hModule);
   UNREFERENCED_PARAMETER(ptzCommandLine);
   UNREFERENCED_PARAMETER(nShowCmd);
   HRESULT hr;
   IMofCompiler *pmc = NULL;
   LPWSTR pszPath = NULL;
   WCHAR wszFilePath[2*MAX_PATH];
   UINT nLen;
   DWORD dwLen = 0;
   HANDLE hEvent = NULL;

   CoInitialize(NULL);

   hr = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (PVOID *)&pmc
            );
   
   if (FAILED(hr)) {
       ASSERT(!"CoInitializeFailed In Replprov1 Setup.");
       return;
   }

   nLen = GetSystemWindowsDirectoryW(wszFilePath, 2*MAX_PATH);
   if (nLen == 0)
   {
      ASSERT(!"Could not get system direcotry in Replprov1 Setup.");
      goto cleanup;
   }

   //
   // Issue 7-22-00 AjayR - define constant for the name.
   //
   dwLen = wcslen(wszFilePath) + wcslen(L"\\System32\\replprov.mof") + 1;
   pszPath = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
   if (!pszPath) {
       ASSERT(!"Could not allocate memory - Replprov1 runonce failed.");
       goto cleanup;
   }
   
   wcscpy(pszPath, wszFilePath);
   wcscat(pszPath, L"\\System32\\replprov.mof");

   WBEM_COMPILE_STATUS_INFO Info;

   hr = pmc->CompileFile(
            pszPath,
            NULL,
            NULL,
            NULL,
            NULL,
            WBEM_FLAG_AUTORECOVER,
            0,
            0,
            &Info
            );

   hEvent = RegisterEventSourceW(NULL, L"DSReplicationProvider");
   
   if (!hEvent) {
       //
       // Could not Register event source to update log file.
       //
       ASSERT(!"Could not RegisterEventSource - Replprov1 runonce");
       goto cleanup;
   }

   if (WBEM_S_NO_ERROR != hr) {
       //
       // Send failure to EventLog.
       //
       WCHAR pszHr[25];
       wsprintfW(pszHr, L"%x", Info.hRes);
       WCHAR pszErrorString[] = 
           L"%systemRoot%\\system32\\replprov.mof with code 0x";
       const PWSTR rgArgs[2] = {pszErrorString, pszHr};
       
       ReportEventW(hEvent,
                   EVENTLOG_ERROR_TYPE,
                   0,                       // wCategory
                   REPLPROV_MOFCOMP_FAILED, // dwEventID
                   NULL,                    // lpUserSID
                   2,                       // wNumStrings
                   0,                       // dwDataSize
                   (LPCWSTR *)rgArgs,       // lpStrings
                   NULL);                   // lpRawData
   }
   else
   {
       //
       // Send success notice to EventLog.
       //
       ReportEventW(hEvent,
                   EVENTLOG_INFORMATION_TYPE,
                   0,                        // wCategory
                   REPLPROV_MOFCOMP_SUCCESS, // dwEventID
                   NULL,                     // lpUserSID
                   0,                        // wNumStrings
                   0,                        // dwDataSize
                   NULL,                     // lpStrings
                   NULL                      // lpRawData
                   );
   }



cleanup:
    
    if (pszPath) {
        FreeADsMem(pszPath);
    }

    if (hEvent) {
        DeregisterEventSource(hEvent);
    }

    if (pmc) {
        pmc->Release();
    }

    CoUninitialize();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dswmi\replprov\rpcreplprov.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RpcReplProv.cpp

Abstract:

    This file contains the implementation of the CRpcReplProv class. 
    The CRpcReplProv class is derived from the WMI classes; IWbemServices,
    IWbemProviderInit.

    The following WMI methods are implemented. 
            
    1) IWbemProviderInit::Initialize    
    2) IWbemServices::CreateInstanceEnumAsync
    3) IWbemServices::GetObjectAsync
    4) IWbemServices::ExecMethodAsync

       <Note that the synchronous version of 2,3 & 4, can still be
     called by a WMI client, but need not be implemented in the actual
     provider. This is because winmgmt.exe (WMI) has its own special
     code that makes turns ExecMethodAsync into a synchronous version etc...>
      
    For definition of the WMI schema outlining the objects,attributes
    and methods supports by this WMI Provider, please refer to replprov.mof
  
Important Notes:

    With respect to the Cursor and PendingOps classes, orginally the 
    Cursors and PendingOps were implemented as an array of embedded
    objects on the NamingContext and DomainController class repectively.
    However, it has been decided that the WMI schema would be better
    organized by using Associations and by eliminating the prescence of 
    embedded objects. Support for 'Association by Rule' will be available
    in Whistler. Please see Lev Novik as a WMI contact with respect to this 
    concept.

    As far as the code is concerned there are two functions that were
    written to support embedded objects (CreateCursors and
    CreatePendingOps) This code and any other associated code has been
    "removed" with an '#ifdef EMBEDDED_CODE_SUPPORT' where 
    EMBEDDED_CODE_SUPPORT is defined as 0 If, for some reason, it is
    desired to revert back to embedded objects, then search for the 
    symbol EMBEDDED_CODE_SUPPORT and remove the handling of these
    classes in CreateInstanceEnumAsync and GetObjectAsync.

    The current implementation generates a flat list of PendingOps and
    Cursors objects. WMI will be able to filter this based on the
    Association rules.

    Note that the PendingOps class will not need to be filtered, since
    only one instance of the DomainController object exists. For that reason
    there does NOT need to be any Association between PendingOps and
    the DomainController class. 
    However, since there can be multiple instances of the NamingContext
    class, and many instances of Cursors per NamingContext, Associations
    are required in this case. 
    Also note this code currently generates a flatlist of Cursors with
    a joint key of NamingContextDN and SrcInvocationUUID

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000


Revision History:
    AjayR made name changes and added param support to methods 27-Jul-2000.

--*/


#include "stdafx.h"
#include "ReplProv.h"
#include "RpcReplProv.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include <adshlp.h>
#include <lmaccess.h>
/////////////////////////////////////////////////////////////////////////////
//


const LPWSTR strReplNeighbor = L"MSAD_ReplNeighbor";
const LPWSTR strDomainController = L"MSAD_DomainController";
const LPWSTR strNamingContext = L"MSAD_NamingContext";
const LPWSTR strDsReplPendingOp = L"MSAD_ReplPendingOp";
const LPWSTR strDsReplCursor = L"MSAD_ReplCursor";
const LPWSTR strKeyReplNeighbor = 
                 L"MSAD_ReplNeighbor.NamingContextDN=\"";
const LPWSTR strKeyReplNeighborGUID = L"SourceDsaObjGuid=\"";
const LPWSTR strKeySettings = L"MSAD_DomainController.DistinguishedName=\"";
const LPWSTR strKeyNamingContext = 
                 L"MSAD_NamingContext.DistinguishedName=\"";
const LPWSTR strKeyPendingOps = L"MSAD_ReplPendingOp.lserialNumber=";
const LPWSTR strKeyCursors = L"MSAD_DsReplCursor.SourceDsaInvocationID=\"";
const LPWSTR strKeyCursors2 = L"\",NamingContextDN=\"";
const LONG   lLengthOfStringizedUuid = 36;

HMODULE LoadLibraryHelper(
    LPTSTR pszFileName
    )
{
    const DWORD iSize = GetSystemDirectory(NULL, 0);
    TCHAR* buffer = NULL;
    DWORD dwTemp = 0;
    HMODULE handle = NULL;

    if(iSize == 0)
    {        
        goto error;
    }

    buffer = new TCHAR[iSize + _tcslen(__TEXT("\\")) + _tcslen(pszFileName)];  // iSize includes the NULL terminiator
    if(!buffer)
    {        
        goto error;
    }

    dwTemp = GetSystemDirectory(buffer, iSize);
    if(dwTemp == 0)
    {
        goto error;
    }

    _tcscat(buffer, __TEXT("\\"));
    _tcscat(buffer, pszFileName);

    handle = LoadLibrary(buffer);

error:

    if(buffer)
    {
        delete [] buffer;
        buffer = NULL;
    }
    return handle;    
        
}

CRpcReplProv::CRpcReplProv()
{  
    _hNetApi32 = NULL;
    _pDsBindWithSpnExW = NULL;
    
    _hNetApi32 = LoadLibraryHelper(__TEXT("ntdsapi.dll"));
     
    if (_hNetApi32)
    {
        _pDsBindWithSpnExW = (DsBindWithSpnExWrapper)GetProcAddress(_hNetApi32, "DsBindWithSpnExW");
    }

}

CRpcReplProv::~CRpcReplProv()
{
     if (_hNetApi32)
        FreeLibrary(_hNetApi32);
}

/*++    IWbemProviderInit

Routine Description:

    This method is required to be implemented by all WMI providers
    The IWbemProviderInitSink::SetStatus() method must be called to
    register the provider with WMI

    1) creates instances of class definitions 
    2) calls IWbemProviderInitSink::SetStatus()

Parameters:

    pNamespace  -  Pointer to a namespace (allows callbacks to WMI)
    pInitSink    -  IWbemProviderInitSink pointer



Return Values:

    Always WBEM_S_NO_ERROR 
    
--*/
STDMETHODIMP
CRpcReplProv::Initialize(
     IN LPWSTR pszUser,
     IN LONG lFlags,
     IN LPWSTR pszNamespace,
     IN LPWSTR pszLocale,
     IN IWbemServices *pNamespace,
     IN IWbemContext *pCtx,
     IN IWbemProviderInitSink *pInitSink
     )
{
    HRESULT hrSetStatus        = WBEM_S_NO_ERROR;
    HRESULT hr2            = WBEM_S_NO_ERROR;
    CComBSTR sbstrObjectName    = strReplNeighbor; 

    if (pNamespace == NULL || pInitSink == NULL)
        return WBEM_E_FAILED;    
        
    //
    // Get the class definitions of the WMI objects supported
    // by this provider... 
    //
    m_sipNamespace = pNamespace;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &m_sipClassDefReplNeighbor,
                NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;
    
    sbstrObjectName = strDomainController;
    hrSetStatus = m_sipNamespace->GetObject( 
                                      sbstrObjectName,
                                      WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                      NULL,
                                      &m_sipClassDefDomainController,
                                      NULL
                                      );
    if(FAILED(hrSetStatus))
         goto cleanup;
    
    sbstrObjectName = strNamingContext;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    NULL,
                                    &m_sipClassDefNamingContext,
                                    NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;
    

    sbstrObjectName = strDsReplPendingOp;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    NULL,
                                    &m_sipClassDefPendingOps,
                                    NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;    

    
    sbstrObjectName = strDsReplCursor;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    NULL,
                                    &m_sipClassDefCursor,
                                    NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;        
   
    //If we got this far, everything went okay
    hrSetStatus = WBEM_S_INITIALIZED;    
    
cleanup:
    
    //Must call this to complete the initialization process
    hr2 = pInitSink->SetStatus( hrSetStatus , 0 );
    ASSERT( !FAILED(hr2) );

    return hr2;
}



/*++    CreateInstanceEnumAsync

Routine Description:

    This method is required to be implemented by all WMI instance providers
    It handles the creation of all instances of a particular class.  
    Using the IWbemProviderObjectSink pointer, that is an IN param, the
    following methods must be called; IWbemProviderObjectSink::Indicate
    and IWbemProviderObjectSink::SetStatus.(See WMI documentation for a
    better understanding of these methods)

    Note that, the helper funciton, EnumAndIndicateReplicaSourcePartner()
    calls IWbemProviderObjectSink::Indicate and SetStatus internally
    (since these functions were hijacked from the WMI provider 
    adreplprov, written by Jon Newman) Whereas the other helper functions
    do not call the ::Indicate and ::SetStatus methods internally.
    
    
Parameters:

    bstrClass        -  BSTR, containing name of class
    pResponseHandler -  IWbemProviderObjectSink pointer, so that we can
                       call ::Indicate and ::SetStatus
Return Values:

      - HRESULT values from internal helper functions...    
      - WBEM_E_INVALID_CLASS, the class name is not serviced
        by this WMI provider

Notes:
      This method checks to make sure that the local machine is
      in fact a Domain Controller. (Fails if not a DC)
--*/
STDMETHODIMP 
CRpcReplProv::CreateInstanceEnumAsync( 
    IN const BSTR bstrClass,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler
    )
{
    HRESULT hr = WBEM_E_FAILED;
    HRESULT hr2 = WBEM_E_FAILED;
    HRESULT hr3 = WBEM_E_FAILED;

    if (pResponseHandler == NULL)
        return WBEM_E_FAILED;
    
    
    if (NULL == bstrClass || IsBadStringPtrW(bstrClass,0))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    
    if (FAILED(CheckIfDomainController()))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    
    if (lstrcmpiW(bstrClass, strReplNeighbor) == 0)
    {    
        hr = EnumAndIndicateReplicaSourcePartner(pResponseHandler );
    }
    else if (lstrcmpiW(bstrClass, strDomainController) == 0)
    {
        IWbemClassObject*   pIndicateItem = NULL;
        hr2 = CreateDomainController( &pIndicateItem );
        if (SUCCEEDED(hr2))
        {
            ASSERT(pIndicateItem != NULL);

            //
            // We know that there will be one and only one instance
            // of the DomainController object
            //
            hr2 = pResponseHandler->Indicate( 1, &pIndicateItem );
        }
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT(!FAILED(hr));
    }
    else if (lstrcmpW(bstrClass, strNamingContext) == 0)
    {
        IWbemClassObject**    ppFullNCObject = NULL;
        IWbemClassObject**    ppPartialNCObject = NULL;
        LONG                nObjectCount = 0L;

        //
        // Full Naming Contexts, if we couldn't create masterNC
        // objects, then something is terribly wrong
        //
        hr2 = CreateNamingContext(TRUE, &nObjectCount, &ppFullNCObject);
        if (SUCCEEDED(hr2))
        {
            hr2 = pResponseHandler->Indicate( nObjectCount, ppFullNCObject );
            
            //
            // Partial Naming Contexts, if we couldn't
            // create partialNC, then continue
            //
            hr3 = CreateNamingContext(
                      FALSE,
                      &nObjectCount,
                      &ppPartialNCObject
                      );
            if (SUCCEEDED(hr3))
            {
                hr3 = pResponseHandler->Indicate(
                          nObjectCount,
                          ppPartialNCObject
                          );
            }    
        }        

        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
    else if (lstrcmpW(bstrClass, strDsReplPendingOp) == 0)
   {
        IWbemClassObject**    ppPendingOp = NULL;
        LONG                nObjectCount = 0L;

        hr2 = CreateFlatListPendingOps(&nObjectCount, &ppPendingOp);
        if (SUCCEEDED(hr2))
        {
            hr2 = pResponseHandler->Indicate( nObjectCount, ppPendingOp );
        }        
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
    else if (lstrcmpW(bstrClass, strDsReplCursor) == 0)
    {
        //
        // IWbemObjectSink::Indicate is called inside CreateFlatListCursors()
        //
        hr2 = CreateFlatListCursors(pResponseHandler);
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
    }
    else
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_INVALID_CLASS,
                 NULL,
                 NULL
                 );
    }
    
cleanup:
    return hr;
}

/*++    GetObjectAsync

Routine Description:

    This method is required to be implemented by all WMI instance
    providers. Given a WMI object path, this method should return
    an instance of that object.
    
    The following WMI methods must be called; 
    IWbemProviderObjectSink::Indicate and IWbemProviderObjectSink::SetStatus.
    (See WMI documentation for a better understanding of these methods)

Parameters:

    bstrObjectPath   -  BSTR, containing name of class
    pResponseHandler -  IWbemProviderObjectSink pointer, so that we
                       can call ::Indicate and ::SetStatus


Return Values:

    - HRESULT values from internal helper functions...    
    - WBEM_E_INVALID_OBJECT_PATH, bad object path
     
Notes:
    This method checks to make sure that the local machine is
    in fact a Domain Controller. (Fails if not a DC)

--*/
STDMETHODIMP 
CRpcReplProv::GetObjectAsync( 
    IN const BSTR bstrObjectPath,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler
    )
{
    HRESULT hr = WBEM_E_FAILED;
    HRESULT hr2 = WBEM_E_FAILED;
    LONG rootlen = 0;
    LONG rootlen2 = 0;

    if (pResponseHandler == NULL)
        return WBEM_E_FAILED;
    
    if (NULL == bstrObjectPath || IsBadStringPtrW(bstrObjectPath,0))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    if (FAILED(CheckIfDomainController()))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    /*******************************************
    * Need to fix this one, not sure how I handle multiple keys.
    ********************************************/
    if (   lstrlenW(bstrObjectPath) > 
            ( (rootlen = lstrlenW(strKeyReplNeighbor))
              + (rootlen2 = lstrlenW(strKeyReplNeighborGUID))
              )
        && 0 == _wcsnicmp(bstrObjectPath, strKeyReplNeighbor, rootlen)
       )
    {
        //
        // The path is being used as the key iteslf, rather than
        // splitting it up. When the comparision is made, the 
        // whole path is used.
        //
        //CComBSTR sbstrKeyValue = bstrObjectPath;
        hr = EnumAndIndicateReplicaSourcePartner(pResponseHandler,
                                                 bstrObjectPath );
    }
    else if (   lstrlenW(bstrObjectPath) > (rootlen = lstrlenW(strKeySettings))
            && 0 == _wcsnicmp(bstrObjectPath, strKeySettings, rootlen))
    {
        IWbemClassObject*  pIndicateItem = NULL;
        CComBSTR sbstrKeyValue = L"";

        //
        // remove prefix
        //
        sbstrKeyValue = (BSTR)bstrObjectPath + rootlen;
        //
        // remove trailing doublequote
        //
        sbstrKeyValue[lstrlenW(sbstrKeyValue)-1] = L'\0';
            
        hr2 = GetDomainController( sbstrKeyValue,&pIndicateItem );
        if (SUCCEEDED(hr2))
        {
            //
            // Need do do this because ATL ASSERTS on CComPTR ptr,
            // if &ptr and ptr != NULL
            //
            hr2 = pResponseHandler->Indicate( 1, &pIndicateItem );
        }
        
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
    else if (lstrlenW(bstrObjectPath) 
                 > (rootlen = lstrlenW(strKeyNamingContext))
            && 0 == _wcsnicmp(bstrObjectPath, strKeyNamingContext, rootlen)
            )
    {
        CComPtr<IWbemClassObject> spIndicateItem;
        CComBSTR sbstrKeyValue = L"";
        IWbemClassObject*    pTemp = NULL;
        
        //
        // remove prefix
        //
        sbstrKeyValue = (BSTR)bstrObjectPath + rootlen;
        //
        // remove trailing doublequote
        //
        sbstrKeyValue[lstrlenW(sbstrKeyValue)-1] = L'\0';
        
        hr2 = GetNamingContext( sbstrKeyValue, &spIndicateItem);
        if (SUCCEEDED(hr2))
        {
            //
            // Need do do this because ATL ASSERTS on CComPTR ptr,
            // if &ptr and ptr != NULL
            //
            pTemp = spIndicateItem;
            hr2 = pResponseHandler->Indicate( 1, &pTemp );
        }
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
            ASSERT( !FAILED(hr) );
   }
   else if ( lstrlenW(bstrObjectPath) > (rootlen = lstrlenW(strKeyPendingOps))
            && 0 == _wcsnicmp(bstrObjectPath, strKeyPendingOps, rootlen)
             )
   {
        CComPtr<IWbemClassObject> spIndicateItem;
        CComBSTR sbstrKeyValue = L"";
        IWbemClassObject*    pTemp = NULL;
        LONG    lNumber = 0L;

        //
        // remove prefix
        //
        sbstrKeyValue = (BSTR)bstrObjectPath + rootlen;
        lNumber = _wtol(sbstrKeyValue);

        hr2 = GetPendingOps( lNumber, &spIndicateItem);
        if (SUCCEEDED(hr2))
        {
            //
            // Need do do this because ATL ASSERTS on CComPTR ptr,
            // if &ptr and ptr != NULL
            //
            pTemp = spIndicateItem;
            hr2 = pResponseHandler->Indicate( 1, &pTemp );
        }
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
        }
        else if (lstrlenW(bstrObjectPath) > (rootlen = lstrlenW(strKeyCursors))
                 && 0 == _wcsnicmp(bstrObjectPath, strKeyCursors, rootlen)
                 )
        {
            //
            // Cursors have multiple keys, so we need to handle
            // this a bit differently
            //
        
            CComPtr<IWbemClassObject> spIndicateItem;
            IWbemClassObject*    pTemp = NULL;
            CComBSTR  sbstrNamingContextValue;
            CComBSTR  sbstrUUIDValue;
        
            //
            // remove prefix, and extract the two key values...
            // since the length of a stringized UUID is fixed,
            // we can easily parse the multiple keys...
            //
            rootlen2 = lstrlenW(strKeyCursors2);
        
            sbstrUUIDValue = (BSTR)bstrObjectPath + rootlen;
            sbstrNamingContextValue = (BSTR)sbstrUUIDValue 
                                      + lLengthOfStringizedUuid 
                                      + rootlen2;
        
            //
            // put null character at the end of the Uuid value...
            //
            sbstrUUIDValue[lLengthOfStringizedUuid] = L'\0';
       
            //
            // remove trailing double quote
            //
            sbstrNamingContextValue[
                lstrlenW(sbstrNamingContextValue) - 1
                ] = L'\0';
        
            hr2 = GetCursor(
                     sbstrNamingContextValue,
                     sbstrUUIDValue,
                     &spIndicateItem
                     );
            if (SUCCEEDED(hr2))
            {

                //
                // Need do do this because ATL ASSERTS on CComPTR ptr,
                // if &ptr and ptr != NULL
                //
                pTemp = spIndicateItem;
                hr2 = pResponseHandler->Indicate( 1, &pTemp );
            }
            hr = pResponseHandler->SetStatus(
                     WBEM_STATUS_COMPLETE,
                     hr2,
                     NULL,
                     NULL
                     );
            ASSERT( !FAILED(hr) );
        }
    else
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_INVALID_OBJECT_PATH,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
cleanup:    
    return hr;
}

/*++    ExecMethodAsync

Routine Description:

    This method is required to be implemented by all WMI method 
    providers Given a WMI method name, and the object path of a
    class instance, a method will be executed.Note that all methods
    defined in replprov.mof are dynamic, meaning they require a class
    instance in order to execute (See WMI documentation for more info)
    
    The following WMI methods must be called; IWbemProviderObjectSink::Indicate
     and IWbemProviderObjectSink::SetStatus.
    (See WMI documentation for a better understanding of these methods)


Parameters:

    strMethodName    -  BSTR, containing name of method
    strObjectPath    -  BSTR, containing object path of instance
                        (needed since the methods are dynamic)
    pInParams        -  Contains the parameters the method takes. This is 
                        needed only if the method takes paramters.
    pResultSink      -  IWbemProviderObjectSink pointer, so that we can
                        call ::Indicate and ::SetStatus


Return Values:

      - HRESULT values from internal helper functions...    
      - WBEM_E_INVALID_METHOD

Notes:
      This method checks to make sure that the local machine is in
      fact a Domain Controller. (Fails if not a DC)

--*/
STDMETHODIMP 
CRpcReplProv::ExecMethodAsync( 
    IN const BSTR strObjectPath,
    IN const BSTR strMethodName,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemClassObject *pInParams,
    IN IWbemObjectSink *pResultSink
    )
{   
    HRESULT hr = WBEM_E_FAILED;
    HRESULT hr2 = WBEM_E_FAILED;
    
    if (pResultSink == NULL)
        return WBEM_E_FAILED;
  
    if ((NULL == strObjectPath || IsBadStringPtrW(strObjectPath,0))
        || (NULL == strMethodName || IsBadStringPtrW(strMethodName,0))
        )
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    
    if (lstrcmpiW(strMethodName, L"ExecuteKCC") == 0)
    {    
        int rootlen = lstrlenW(strKeySettings);
        

        if (   lstrlenW(strObjectPath) > rootlen
            && 0 == _wcsnicmp(strObjectPath, strKeySettings, rootlen)
            && NULL != pInParams
           )
        {
            //
            // remove prefix and then trailing doublequote
            //
            CComBSTR sbstrKeyValue = (BSTR)strObjectPath + rootlen;
            sbstrKeyValue[lstrlenW(sbstrKeyValue)-1] = L'\0';

            IWbemClassObject* pIndicateItem = NULL;
            //
            // Parameters to function.
            //
            CComVariant vardwTaskId;
            CComVariant vardwFlags;

            hr = pInParams->Get(L"TaskID", 0, &vardwTaskId, NULL, NULL);
            if (FAILED(hr)) {
                goto cleanup;
            }

            hr = pInParams->Get(L"dwFlags", 0, &vardwFlags, NULL, NULL);
            if (FAILED(hr)) {
                goto cleanup;
            }

            hr = GetDomainController( sbstrKeyValue, &pIndicateItem);
            ASSERT(pIndicateItem != NULL);
            if (SUCCEEDED(hr))
            {    
                hr = ExecuteKCC(
                         pIndicateItem,
                         vardwTaskId.ulVal,
                         vardwFlags.ulVal
                         );
            }
        }
    }
    else if (lstrcmpiW(strMethodName, L"SyncNamingContext") == 0)
        {
        int rootlen = lstrlenW(strKeyReplNeighbor);
        if (lstrlenW(strObjectPath) > rootlen
            && 0 == _wcsnicmp(
                         strObjectPath,
                         strKeyReplNeighbor,
                         rootlen
                         )
            && NULL != pInParams
           )
        {
            //
            // The key value used for comparisions is precisely the
            // object path.
            //
            CComVariant vardwOptions;

            hr = pInParams->Get(L"Options", 0, &vardwOptions, NULL, NULL);
            if (FAILED(hr)) {
                goto cleanup;
            }

            hr = ProvDSReplicaSync(
                     strObjectPath,
                     vardwOptions.ulVal
                     );
        }
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }
cleanup:
    hr2 = pResultSink->SetStatus(WBEM_STATUS_COMPLETE,hr,NULL,NULL);
    return hr2;
}

/*++    GetNamingContext

Routine Description:

    This is a helper function that retrieves an instance of a
    MSAD_NamingContext object (given an object path). See definition
    of MSAD_NamingContext class in replprov.mof. The object's only key
    is the DN of the naming context. Thus a search is done on the
    NTDS-Settings object of the local server looking at the 
    msDS-HasMasterNC or hasMasterNCs and hasPartialNCs attribute. 
    If a match is found, then the object is returned, otherwise the
    method returns WBEM_E_FAILED

Parameters:

    bstrKeyValue    -  BSTR, from which the Naming Context DN is extracted.
    ppIndicateItem  -  pointer to IWbemClassObject* (contains the instance,
                       if found)
    

Return Values:

      - WBEM_S_NO_ERROR, object found    
      - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object
        (instead of direct ldap calls)

--*/
HRESULT CRpcReplProv::GetNamingContext(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        )
{
    HRESULT hr = WBEM_E_FAILED;
    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant      svarArray;
    CComVariant      svarDN;
    CComBSTR      bstrDSADN;    
    LONG lstart, lend;
    LONG index = 0L;
    SAFEARRAY *sa = NULL;
    CComVariant varItem;
    bool isFullReplica;
    bool bImpersonate = false;
    
    
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrKeyValue);
    ASSERT(ppIndicateItem != NULL);
    if (ppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    bImpersonate = true;
        
    hr = ADsOpenObject( L"LDAP://RootDSE",
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsRootDSE);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsRootDSE != NULL)

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarDN.bstrVal != NULL);

    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( bstrDSADN,
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsDSA);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    
    for(int x = 0; x < 2; x++)
    {
        if (x == 0)
        {
            isFullReplica = true;
            hr = spIADsDSA->GetEx(L"msDS-HasMasterNCs", &svarArray);
            if (FAILED(hr))
            {
                // May just need to fail over to deprecated "old" hasMasterNCs
                hr = spIADsDSA->GetEx(L"hasMasterNCs", &svarArray);
                if (FAILED(hr)) 
                {
                    goto cleanup;
                }
            }

        }
        else
        {
            isFullReplica = false;
            hr = spIADsDSA->GetEx(L"hasPartialNCs", &svarArray );
            if (FAILED(hr))
                goto cleanup;
        }

        sa = svarArray.parray;

        // Get the lower and upper bound
        hr = SafeArrayGetLBound( sa, 1, &lstart );
        if (FAILED(hr))
            goto cleanup;
    
        hr = SafeArrayGetUBound( sa, 1, &lend );
        if (FAILED(hr))
            goto cleanup;

        for (index = lstart; index <= lend; index++)
        {
            hr = SafeArrayGetElement( sa, &index, &varItem );
            if (SUCCEEDED(hr)&&varItem.vt == VT_BSTR)
            {
                if (NULL != bstrKeyValue
                        && (lstrcmpiW(varItem.bstrVal, bstrKeyValue) == 0))
                {
                    //KeyValue matches
                    hr = m_sipClassDefNamingContext->SpawnInstance(
                             0,
                             ppIndicateItem
                             );
                    if (SUCCEEDED(hr))
                    {    
                        CComVariant vTemp = isFullReplica;
                        
                        #ifdef EMBEDDED_CODE_SUPPORT
                        /*EMBEDDED_CODE_SUPPORT*/
                        SAFEARRAY*  pArray = NULL;
                        VARIANT vArray;
                        #endif

                         hr = (*ppIndicateItem)->Put( 
                                  L"DistinguishedName",
                                  0,
                                  &varItem,
                                  0
                                  );
                         if (FAILED(hr))
                             goto cleanup;
                                                
                         hr = (*ppIndicateItem)->Put(
                                  L"IsFullReplica",
                                  0,
                                  &vTemp,
                                  0
                                  );
                             goto cleanup;
                            
                         #ifdef EMBEDDED_CODE_SUPPORT
                         /*EMBEDDED_CODE_SUPPORT*/
        
                         hr = CreateCursors(bstrKeyValue,&pArray);
                         if (FAILED(hr))
                             goto cleanup;
                        
                         VariantInit(&vArray);
                         vArray.vt = VT_ARRAY|VT_UNKNOWN;
                         vArray.parray = pArray;
                         hr = (*ppIndicateItem)->Put(
                                  L"cursorArray",
                                  0,
                                  &vArray,
                                  0
                                  );
                         //goto cleanup irrespective of return value hr...
                         VariantClear(&vArray);
                         #endif
                    }            
                }
            }
        }
    }

cleanup:
    if (FAILED(hr)&&((*ppIndicateItem) != NULL))
    {
        (*ppIndicateItem)->Release();
        *ppIndicateItem = NULL;
    }
        
    if(bImpersonate)
        CoRevertToSelf();
    return hr;
}


/*++    GetCursor

Routine Description:

    GetCursor is retrieves a Cursor object based on the InvocationUUID
    and NamingContext (as multiple keys)
    

Parameters:
    bstrNamingContext         - Naming context DN used to when calling
                                DsReplicaGetInfoW
    bstrSourceDsaInvocationID - Other component of the key
    ppIndicateItem            - Pointer to the instance found
  
Return Values:

      - WBEM_S_NO_ERROR, object found    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*, and 
        information is extracted from there... then a search is
        conducted on each cursor (trying to match the InvocationUUID)

--*/
HRESULT 
CRpcReplProv::GetCursor(
    IN BSTR bstrNamingContext,
    IN BSTR bstrSourceDsaInvocationID,
    OUT IWbemClassObject** ppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = 
        sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_CURSORS_3W*  pCursors3 = NULL;
    DS_REPL_CURSORS*     pCursors = NULL;
    LONG nIndex = 0;
    LONG objectCount = 0L;
    BOOL fOldReplStruct = FALSE;
    DWORD dwError = NO_ERROR;

    ASSERT(ppIndicateItem != NULL);
    if (ppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
        if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,
             UnicodeDnsComputerName,
             &DnsComputerNameLength
             ) 
        )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeDnsComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(
                 UnicodeDnsComputerName,
                 NULL,
                 &hDS
                 );   
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    
    
    //
    // First try the newer level 3 call and then drop down.
    //    
   
    dwError = DsReplicaGetInfoW(
                hDS,                           // hDS
                DS_REPL_INFO_CURSORS_3_FOR_NC, // InfoType
                bstrNamingContext,             // pszObject
                NULL,                          // puuidForSourceDsaObjGuid,
                (void**)&pCursors3             // ppinfo
                );

    hr = HRESULT_FROM_WIN32(dwError);
             

    if (FAILED(hr)
        && hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)
        ) {
        fOldReplStruct = TRUE;
        //
        // Need to try the lower level call as that might be supported.
        //        
        dwError = DsReplicaGetInfoW(
                     hDS,                         // hDS
                     DS_REPL_INFO_CURSORS_FOR_NC, // InfoType
                     bstrNamingContext,             // pszObject
                     NULL,                          // puuidForSourceDsaObjGuid,
                     (void**)&pCursors              // ppinfo
                     );
        hr = HRESULT_FROM_WIN32(dwError);
                 
    }

    if (FAILED(hr))
        goto cleanup;


    if (fOldReplStruct) {
        ASSERT(NULL != pCursors);
        objectCount = (LONG)pCursors->cNumCursors;
    }
    else {
        ASSERT(NULL != pCursors3);
        objectCount = (LONG)pCursors3->cNumCursors;
    }

    for (nIndex = 0; nIndex < objectCount; nIndex++)
    {
        DS_REPL_CURSOR  TempCursor;
        DS_REPL_CURSOR_3W TempCursor3;
        LPWSTR   UuidString = NULL;

        if (fOldReplStruct) {
             TempCursor = pCursors->rgCursor[nIndex];
        }
        else {
            TempCursor3 = pCursors3->rgCursor[nIndex];
        }

        if (UuidToStringW(
                fOldReplStruct ? 
                    &(TempCursor.uuidSourceDsaInvocationID) :
                    &(TempCursor3.uuidSourceDsaInvocationID),
                &UuidString
                ) 
            ==  RPC_S_OK
            )
        {
       
            if (lstrcmpiW(bstrSourceDsaInvocationID, UuidString) == 0)
            {
                 RpcStringFreeW(&UuidString);
                   
                 LPUNKNOWN    pTempUnknown = NULL;
                 CComVariant varItem;
    
                 hr = m_sipClassDefCursor->SpawnInstance(0, ppIndicateItem);
                 if (FAILED(hr))
                     goto cleanup;
                 ASSERT((*ppIndicateItem) != NULL);
      
                 varItem = bstrNamingContext;  
                 hr = (*ppIndicateItem)->Put(
                          L"NamingContextDN",
                          0,
                          &varItem,
                          0
                          );
                 if (FAILED(hr))
                     goto cleanup;
        
                 hr = PutLONGLONGAttribute(
                          (*ppIndicateItem),
                          L"usnattributefilter",
                          fOldReplStruct ?
                              TempCursor.usnAttributeFilter :
                              TempCursor3.usnAttributeFilter
                     );
                 if (FAILED(hr))
                     goto cleanup;
            
                 hr = PutUUIDAttribute(
                          (*ppIndicateItem),
                          L"SourceDsaInvocationID",
                          fOldReplStruct ?
                              TempCursor.uuidSourceDsaInvocationID :
                              TempCursor3.uuidSourceDsaInvocationID
                     );
                 if (FAILED(hr)) {
                     goto cleanup;
                 }
                 

                 if (!fOldReplStruct) {
                     //
                     // In this case we can populate the new attributes.
                     //
                     hr = PutFILETIMEAttribute(
                              (*ppIndicateItem),
                              L"TimeOfLastSuccessfulSync",
                              TempCursor3.ftimeLastSyncSuccess
                              );
                     if (FAILED(hr)) {
                         goto cleanup;
                     }

                     varItem =  TempCursor3.pszSourceDsaDN;
                     hr = (*ppIndicateItem)->Put(
                              L"SourceDsaDN",
                              0,
                              &varItem,
                              0
                              );
                     if (FAILED(hr))
                         goto cleanup;

                 }

                 break; // have a match, do not need to go through rest.
            }
            else {
                RpcStringFreeW(&UuidString);
            }
        }
    }
    
cleanup:
    
    if (FAILED(hr)&& (*ppIndicateItem) != NULL)
    //something failed, make sure to deallocate the spawned instance
    {
        (*ppIndicateItem)->Release();
        (*ppIndicateItem) = NULL;
    }
    
    if (pCursors!= NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        pCursors = NULL;
    }

    if (pCursors3 != NULL) {
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_3_FOR_NC, pCursors3);
    }

    if (hDS != NULL){
        DsUnBind(&hDS);
    }

    if (bImpersonate){    
        CoRevertToSelf();
    }
    return hr;
}

/*++    CreateFlatListCursors

Routine Description:

    CreateFlatListCursors is creates instances of the MSAD_ReplCursor
    object. It retrieves a list of all naming-contexts, then calls
    CreateCursorHelper, passing in the NamingContext DN. Note that this
    method calls IWbemObjectSink::Indicate for each set of cursors retrieved.

Parameters:
       NONE
  
Return Values:

      - WBEM_S_NO_ERROR, object created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*, and
        information is extracted from there...

--*/
HRESULT
CRpcReplProv::CreateFlatListCursors(
    IN IWbemObjectSink *pResponseHandler
    )
{
    HRESULT hr = WBEM_E_FAILED;
        
    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant      svarDN;
    CComBSTR      bstrDSADN;    

        
    if (pResponseHandler == NULL)
        goto cleanup;
    
    hr = ADsOpenObject( L"LDAP://RootDSE",
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsRootDSE);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsRootDSE != NULL);    

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarDN.bstrVal != NULL);
    
    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( bstrDSADN,
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsDSA);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    
    for (int x = 0; x < 2; x++)
    {
        CComVariant      svarArray;
        CComVariant varItem;
        SAFEARRAY *sa = NULL;
        LONG lstart, lend;
        LONG index = 0L;
    

        if (x == 0)
        {
            hr = spIADsDSA->GetEx(L"msDS-HasMasterNCs", &svarArray);
            if (FAILED(hr))
            {
                // May just need to fail over to deprecated "old" hasMasterNCs
                hr = spIADsDSA->GetEx(L"hasMasterNCs", &svarArray);
                if (FAILED(hr)) 
                {
                    //
                    // if we couldn't get the Master NC's then something is
                    // terribly wrong, forget about the PartialNCs
                    //
                    goto cleanup;
                }
            }
        }
        else
        {
            hr = spIADsDSA->GetEx(L"hasPartialNCs", &svarArray );
            if (FAILED(hr))
            {
                //May or may not have partialNCs so don't fail
                hr = WBEM_S_NO_ERROR;
                goto cleanup;
            }
        }
            
        sa = svarArray.parray;
       // Get the lower and upper bound
       hr = SafeArrayGetLBound( sa, 1, &lstart );
       if (FAILED(hr))
          goto cleanup;

       hr = SafeArrayGetUBound( sa, 1, &lend );
       if (FAILED(hr))
           goto cleanup;
                
       for (index = lstart; index <= lend; index++)
       {
            hr = SafeArrayGetElement( sa, &index, &varItem );
            if (SUCCEEDED(hr)&&varItem.vt == VT_BSTR)
            {                                
                IWbemClassObject** ppCursors = NULL;
                LONG               lObjectCount = 0L;

                //
                // Call the helper function, if it fails keep going
                //
                hr = CreateCursorHelper(
                         varItem.bstrVal,
                         &lObjectCount,
                         &ppCursors
                         );
                if (SUCCEEDED(hr))
                    pResponseHandler->Indicate( lObjectCount, ppCursors );
            }               
        }
    }
cleanup:    
    return hr;
}

/*++    CreateCursorHelper

Routine Description:

    CreateCursorHelper is a helper function that creates instances
    of the MSAD_ReplCursor object. An array of IWbemClassObject* is
    returned (as an out parameter)

Parameters:
        bstrNamingContext : Naming context DN used to create the cursors
        pObjectCount      : Pointer to number of instances returned
        pppIndicateItem   : Pointer to an array of IWbemClassObject* 's
  
Return Values:

      - WBEM_S_NO_ERROR, objects created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*,
        and information is extracted from there...

--*/
HRESULT
CRpcReplProv::CreateCursorHelper(
    IN BSTR bstrNamingContext,
    OUT LONG* pObjectCount,
    OUT IWbemClassObject*** pppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = 
        sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_CURSORS*    pCursors  = NULL;
    DS_REPL_CURSORS_3W* pCursors3 = NULL;
    LONG nIndex = 0;
    IWbemClassObject** paIndicateItems = NULL;
    BOOL fOldReplStruct = FALSE;
    DWORD dwError = NO_ERROR;

    ASSERT(pppIndicateItem != NULL);
    if (pppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeDnsComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(UnicodeDnsComputerName,NULL,&hDS);
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    

    dwError = DsReplicaGetInfoW(
                 hDS,                           // hDS
                 DS_REPL_INFO_CURSORS_3_FOR_NC, // InfoType
                 bstrNamingContext,             // pszObject
                 NULL,                          // puuidForSourceDsaObjGuid
                 (void **) &pCursors3           // ppinfo
                 );
         
    hr = HRESULT_FROM_WIN32(dwError);

    if (FAILED(hr)
        && (hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) ||
            hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
        ) {
        fOldReplStruct = TRUE;

        dwError = DsReplicaGetInfoW(
                 hDS,                        // hDS
                 DS_REPL_INFO_CURSORS_FOR_NC, // InfoType
                 bstrNamingContext,          // pszObject
                 NULL,                       // puuidForSourceDsaObjGuid,
                 (void**)&pCursors           // ppinfo
                 );
        hr = HRESULT_FROM_WIN32(dwError);
        
        if (FAILED(hr))
            goto cleanup;
    }

    if (fOldReplStruct) {
        ASSERT(NULL != pCursors);
        *pObjectCount = (LONG)pCursors->cNumCursors;
    }
    else {
        ASSERT(NULL != pCursors3);
        *pObjectCount = (LONG)pCursors3->cNumCursors;
    }

    paIndicateItems = new IWbemClassObject*[(*pObjectCount)];
    if (NULL == paIndicateItems)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }
    ::ZeroMemory(paIndicateItems,(*pObjectCount) * sizeof(IWbemClassObject*));
    
        
    for (nIndex = 0; nIndex < (*pObjectCount); nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_CURSOR  TempCursor;
        DS_REPL_CURSOR_3W TempCursor3;
        CComVariant varItem;

        if (fOldReplStruct) {
             TempCursor = pCursors->rgCursor[nIndex];
        }
        else {
            TempCursor3 = pCursors3->rgCursor[nIndex];
        }
   
        hr = m_sipClassDefCursor->SpawnInstance(0, &(paIndicateItems[nIndex]));
        if (FAILED(hr))
            goto cleanup;
        ASSERT(paIndicateItems[nIndex] != NULL);
      
        varItem = bstrNamingContext;  
        hr = paIndicateItems[nIndex]->Put( L"NamingContextDN", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
        
        hr = PutLONGLONGAttribute(
                 paIndicateItems[nIndex],
                 L"usnattributefilter",
                 fOldReplStruct ?
                     TempCursor.usnAttributeFilter :
                     TempCursor3.usnAttributeFilter
                 );
        if (FAILED(hr))
            goto cleanup;
                        
        hr = PutUUIDAttribute(
                 paIndicateItems[nIndex],
                 L"SourceDsaInvocationID",
                 fOldReplStruct ?
                     TempCursor.uuidSourceDsaInvocationID :
                     TempCursor3.uuidSourceDsaInvocationID
                 );
        if (FAILED(hr))
            goto cleanup;

        //
        // If we have the new struct, we need to set the additional attributes.
        //
        if (!fOldReplStruct) {
            //
            // In this case we can populate the new attributes.
            //
            hr = PutFILETIMEAttribute(
                     paIndicateItems[nIndex],
                     L"TimeOfLastSuccessfulSync",
                     TempCursor3.ftimeLastSyncSuccess
                     );
            if (FAILED(hr)) {
                goto cleanup;
            }

            varItem =  TempCursor3.pszSourceDsaDN;
            hr = (paIndicateItems[nIndex])->Put(
                     L"SourceDsaDN",
                     0,
                     &varItem,
                     0
                     );
            if (FAILED(hr))
                goto cleanup;

        }
     }
    

cleanup:
    
    if (FAILED(hr))
    {
       ReleaseIndicateArray( paIndicateItems, (*pObjectCount) );
       (*pObjectCount) = 0L;
       *pppIndicateItem = NULL;
    }
    else
    {
        *pppIndicateItem = paIndicateItems;
    }
    
    if (pCursors!= NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        pCursors = NULL;
    }

    if (NULL != pCursors3) {
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_3_FOR_NC, pCursors3);
    }

    if (hDS != NULL)
    {
    DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}


 #ifdef EMBEDDED_CODE_SUPPORT
 /*EMBEDDED_CODE_SUPPORT*/
        HRESULT CRpcReplProv::CreateCursors(
        IN  BSTR bstrNamingContext,
        OUT SAFEARRAY** ppArray
        )
{
/*++    CreateCursors

Routine Description:

    CreateCursors is a helper function that creates instances of the MicrosoftAD_DsReplCursors object. 
    Cursors are stored as an array of embedded objects on the MicrosoftAD_DsReplNamingContext object
    This function returns a SAFEARRAY containing pointers to each instances of Cursors (as IUnknown pointers)
    
Parameters:

    bstrNamingContext    -  name of naming context used to create the cursors
    ppArray             -  array of cursors (returned)

Return Values:

      - WBEM_S_NO_ERROR, object created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*, and information is extracted from there...

--*/
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_CURSORS*    pCursors = NULL;
    IWbemClassObject* pTempInstance = NULL;
    LONG nIndex = 0;
    LONG lNumberOfCursors = 0L;
    SAFEARRAY*  pArray = NULL;
    DWORD dwError = NO_ERROR;

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeDnsComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(UnicodeDnsComputerName,NULL,&hDS);
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    

    //
    // Note ********************************
    // This is not currently called as it is in an ifdef.
    // If for some reason, that is changed, then you should add
    // code similar to the other instances of cursors over here too.
    // That is you need to add l3 cursor support - AjayR - 02-10-01.
    //
    dwError = DsReplicaGetInfoW(
            hDS,                        // hDS
            DS_REPL_INFO_CURSORS_FOR_NC, // InfoType
            bstrNamingContext,          // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)&pCursors           // ppinfo
            );
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pCursors);


    SAFEARRAYBOUND rgsabound[1];
    lNumberOfCursors = (LONG)pCursors->cNumCursors;
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lNumberOfCursors;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
    if(pArray == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    for (nIndex = 0; nIndex < lNumberOfCursors; nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_CURSOR  TempCursor = pCursors->rgCursor[nIndex];
        CComVariant varItem;
    
        hr = m_sipClassDefCursor->SpawnInstance(0, &pTempInstance);
        if (FAILED(hr))
            goto cleanup;
           ASSERT(pTempInstance != NULL);
      
        hr = PutLONGLONGAttribute( pTempInstance,
                                    L"usnattributefilter",
                                    TempCursor.usnAttributeFilter);
        if (FAILED(hr))
            goto cleanup;
                        
        hr = PutUUIDAttribute( pTempInstance,
                          L"SourceDsaInvocationID",
                          TempCursor.uuidSourceDsaInvocationID);
        if (FAILED(hr))
            goto cleanup;
           
        hr = pTempInstance->QueryInterface(IID_IUnknown, (void**)&pTempUnknown);
        if (FAILED(hr))
            goto cleanup;
        
        hr = SafeArrayPutElement(pArray, &nIndex, pTempUnknown);          
        if (FAILED(hr))
            goto cleanup;
     }

cleanup:
    
    //In case we failed, deallocate the SafeArray
    if (FAILED(hr))
    {
        if (pArray != NULL)
        {
            SafeArrayDestroy(pArray);
            *ppArray = NULL;
        }
    }
    else
    {
        *ppArray = pArray;
    }


    if (pCursors!= NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        pCursors = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}
#endif

#ifdef EMBEDDED_CODE_SUPPORT
/*EMBEDDED_CODE_SUPPORT*/


/*++    CreatePendingOps

Routine Description:

    CreatePendingOps is a helper function that creates instances of
    the MicrosoftAD_DsReplPendingOps object. PendingOps are stored
         as an array of embedded objects on the MSAD_ReplSettings object
    This function returns a SAFEARRAY containing pointers to each instances of PendingOps (as IUnknown pointers)
    
Parameters:

    ppArray        -  pointer to SAFEARRAY*, array of pending ops

Return Values:

      - WBEM_S_NO_ERROR, array created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplPendingOps*, and information is extracted from there...

--*/
HRESULT CRpcReplProv::CreatePendingOps(
        OUT SAFEARRAY**  ppArray 
        )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_PENDING_OPSW*    pPendingOps = NULL;
    IWbemClassObject* pTempInstance = NULL;
    LONG nIndex = 0;
    LONG lNumberOfPendingOps = 0L;
    SAFEARRAY*  pArray = NULL;
    DWORD dwError = NO_ERROR;

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeDnsComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(UnicodeDnsComputerName,NULL,&hDS);
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    
    
    dwError = DsReplicaGetInfoW(
            hDS,                        // hDS
            DS_REPL_INFO_PENDING_OPS,   // InfoType
            NULL,                       // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)&pPendingOps        // ppinfo
            );
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pPendingOps);


    SAFEARRAYBOUND rgsabound[1];
    lNumberOfPendingOps = (LONG)pPendingOps->cNumPendingOps;
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lNumberOfPendingOps;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
    if(pArray == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    for (nIndex = 0; nIndex < lNumberOfPendingOps; nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_OPW  TempPendingOp = pPendingOps->rgPendingOp[nIndex];
        CComVariant varItem;
    
        hr = m_sipClassDefPendingOps->SpawnInstance(0, &pTempInstance);
        if (FAILED(hr))
            goto cleanup;
           ASSERT(pTempInstance != NULL);
      
        varItem = (LONG)TempPendingOp.ulSerialNumber;
        hr = pTempInstance->Put( L"lserialNumber", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = (LONG)TempPendingOp.ulPriority;
        hr = pTempInstance->Put( L"lPriority", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = (LONG)TempPendingOp.OpType;
        hr = pTempInstance->Put( L"lOpType", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           

        varItem = (LONG)TempPendingOp.ulOptions;
        hr = pTempInstance->Put( L"lOptions", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszNamingContext;
        hr = pTempInstance->Put( L"NamingContext", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaDN;
        hr = pTempInstance->Put( L"DsaDN", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaAddress;
        hr = pTempInstance->Put( L"DsaAddress", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
                   
        hr = PutUUIDAttribute( pTempInstance,
                          L"uuidNamingContextObjGuid",
                          TempPendingOp.uuidNamingContextObjGuid);
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutUUIDAttribute( pTempInstance,
                          L"uuidDsaObjGuid",
                          TempPendingOp.uuidDsaObjGuid);
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutFILETIMEAttribute( pTempInstance,
                            L"ftimeEnqueued",
                            TempPendingOp.ftimeEnqueued);
        if (FAILED(hr))
            goto cleanup;
           
        hr = pTempInstance->QueryInterface(IID_IUnknown, (void**)&pTempUnknown);
        if (FAILED(hr))
            goto cleanup;
        
        hr = SafeArrayPutElement(pArray, &nIndex, pTempUnknown);          
        if (FAILED(hr))
            goto cleanup;
    }
    
cleanup:
    
    //In case we failed, deallocate the SafeArray
    if (FAILED(hr))
    {
        if (pArray != NULL)
        {
            SafeArrayDestroy(pArray);
            *ppArray = NULL;
        }
    }
    else
    {
        *ppArray = pArray;
    }


    if (pPendingOps != NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        pPendingOps = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}
#endif


HRESULT CRpcReplProv::GetPendingOps(
        IN LONG    lSerialNumber,                
        OUT IWbemClassObject** ppIndicateItem
        )
{
/*++    GetPendingOps

Routine Description:

    GetPendingOps is a helper function that gets an instance of the MicrosoftAD_DsReplPendingOps object. 
    based on the serialNumber of that PendingOp
    
Parameters:

    lSerialNumber        -  serial number
    ppIndicateItem     -  pointer to IWbemClassObject*

Return Values:

      - WBEM_S_NO_ERROR, array created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplPendingOps*, and information is extracted from there...

--*/
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_PENDING_OPSW*    pPendingOps = NULL;
    LONG nIndex = 0;
    LONG nTotalPendingOps = 0L;  
    DWORD dwError = NO_ERROR;
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
    goto cleanup;
    else
    bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
    goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeDnsComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(UnicodeDnsComputerName,NULL,&hDS);
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
    goto cleanup;
    ASSERT(NULL != hDS);
    
    
    dwError = DsReplicaGetInfoW(
            hDS,                        // hDS
            DS_REPL_INFO_PENDING_OPS,   // InfoType
            NULL,                       // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)&pPendingOps        // ppinfo
            );
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pPendingOps);


    for (nIndex = 0; nIndex < (LONG)pPendingOps->cNumPendingOps; nIndex++)
    {
        DS_REPL_OPW  TempPendingOp = pPendingOps->rgPendingOp[nIndex];
            
        if (lSerialNumber == (LONG)TempPendingOp.ulSerialNumber)
        {
            //We have found a pending op
            LPUNKNOWN    pTempUnknown = NULL;
            CComVariant varItem;
    
            hr = m_sipClassDefPendingOps->SpawnInstance(0, ppIndicateItem);
            if (FAILED(hr))
                goto cleanup;
               ASSERT((*ppIndicateItem) != NULL);
      
            varItem = (LONG)TempPendingOp.ulSerialNumber;
            hr = (*ppIndicateItem)->Put( L"lserialNumber", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = (LONG)TempPendingOp.ulPriority;
            hr = (*ppIndicateItem)->Put( L"lPriority", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = (LONG)TempPendingOp.OpType;
            hr = (*ppIndicateItem)->Put( L"lOpType", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               

            varItem = (LONG)TempPendingOp.ulOptions;
            hr = (*ppIndicateItem)->Put( L"lOptions", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = TempPendingOp.pszNamingContext;
            hr = (*ppIndicateItem)->Put( L"NamingContext", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = TempPendingOp.pszDsaDN;
            hr = (*ppIndicateItem)->Put( L"DsaDN", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = TempPendingOp.pszDsaAddress;
            hr = (*ppIndicateItem)->Put( L"DsaAddress", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
                       
            hr = PutUUIDAttribute( (*ppIndicateItem),
                              L"uuidNamingContextObjGuid",
                              TempPendingOp.uuidNamingContextObjGuid);
            if (FAILED(hr))
                goto cleanup;
               
            hr = PutUUIDAttribute( (*ppIndicateItem),
                              L"uuidDsaObjGuid",
                              TempPendingOp.uuidDsaObjGuid);
            if (FAILED(hr))
                goto cleanup;
               
            hr = PutFILETIMEAttribute( (*ppIndicateItem),
                                L"ftimeEnqueued",
                                TempPendingOp.ftimeEnqueued);
        }
    }
    

cleanup:
    
    if (FAILED(hr)&&((*ppIndicateItem) != NULL))
    {
        (*ppIndicateItem)->Release();
        *ppIndicateItem = NULL;
    }
        
    if (pPendingOps != NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        pPendingOps = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}

/*++    CreateFlatListPendingOps

Routine Description:

    CreateFlatListPendingOps is a helper function that creates
    instances of the MicrosoftAD_DsReplPendingOps object. An 
    array of IWbemClassObject* is returned (as an OUT param)

Parameters:

    pObjectCount        -  pointer to number of instances
    pppIndicateItem     -  pointer to array of IWbemClassObject*

Return Values:

      - WBEM_S_NO_ERROR, array created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplPendingOps*,
     and information is extracted from there...

--*/
HRESULT 
CRpcReplProv::CreateFlatListPendingOps(
    OUT LONG* pObjectCount,
    OUT IWbemClassObject*** pppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = 
        sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_PENDING_OPSW*    pPendingOps = NULL;
    LONG nIndex = 0;
    IWbemClassObject** paIndicateItems = NULL;
    DWORD dwError = NO_ERROR;
        
    
    ASSERT(pppIndicateItem != NULL);
    if (pppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( 
              ComputerNameDnsFullyQualified,
              UnicodeDnsComputerName,
              &DnsComputerNameLength
              )
         )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeDnsComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(
                 UnicodeDnsComputerName,
                 NULL,
                 &hDS
                 );
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    
    
    dwError = DsReplicaGetInfoW(
                 hDS,                        // hDS
                 DS_REPL_INFO_PENDING_OPS,   // InfoType
                 NULL,                       // pszObject
                 NULL,                       // puuidForSourceDsaObjGuid,
                 (void**)&pPendingOps        // ppinfo
                 );
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pPendingOps);


    (*pObjectCount) = (LONG)pPendingOps->cNumPendingOps;
    paIndicateItems = new IWbemClassObject*[(*pObjectCount)];
    if (NULL == paIndicateItems)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }
    ::ZeroMemory(
          paIndicateItems,
          (*pObjectCount) * sizeof(IWbemClassObject*)
          );
    
    for (nIndex = 0; nIndex < (*pObjectCount); nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_OPW  TempPendingOp = pPendingOps->rgPendingOp[nIndex];
        CComVariant varItem;
    
        //
        // Create and populate the objects corresponding to the
        // pending ops data returned.
        //
        hr = m_sipClassDefPendingOps->SpawnInstance(
                 0,
                 &(paIndicateItems[nIndex])
                 );
        if (FAILED(hr))
            goto cleanup;
           ASSERT(paIndicateItems[nIndex] != NULL);
      
        varItem = (LONG)TempPendingOp.ulSerialNumber;
        hr = paIndicateItems[nIndex]->Put( L"serialNumber", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;

        varItem = nIndex;
        hr = paIndicateItems[nIndex]->Put(
                 L"PositionInQ",
                 0,
                 &varItem,
                 0
                 );
        if (FAILED(hr)) {
            goto cleanup;
        }
           
        varItem = (LONG)TempPendingOp.ulPriority;
        hr = paIndicateItems[nIndex]->Put( L"Priority", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = (LONG)TempPendingOp.OpType;
        hr = paIndicateItems[nIndex]->Put( L"OpType", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           

        varItem = (LONG)TempPendingOp.ulOptions;
        hr = paIndicateItems[nIndex]->Put( L"Options", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszNamingContext;
        hr = paIndicateItems[nIndex]->Put( L"NamingContextDN", 0, &varItem, 0 );
        if (FAILED(hr))                 
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaDN;
        hr = paIndicateItems[nIndex]->Put( L"DsaDN", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaAddress;
        hr = paIndicateItems[nIndex]->Put( L"DsaAddress", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
                   
        hr = PutUUIDAttribute(
                paIndicateItems[nIndex],
                L"NamingContextObjGuid",
                TempPendingOp.uuidNamingContextObjGuid
                );
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutUUIDAttribute(
                 paIndicateItems[nIndex],
                 L"DsaObjGuid",
                 TempPendingOp.uuidDsaObjGuid
                 );
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutFILETIMEAttribute(
                paIndicateItems[nIndex],
                L"timeEnqueued",
                TempPendingOp.ftimeEnqueued
                );
        if (FAILED(hr))
            goto cleanup;

        //
        // For the first item alone we can tell when it was started.
        //
        if (0 == nIndex) {
            //
            // if for some reason, no operation currently executing (for example, replication is stopped on the dc), all operations 
            // are in the queue, then the OpStartTime will be 1601-01-01T00:00:00Z(system time), and 0 (filetime)
            //
            hr = PutFILETIMEAttribute(
                     paIndicateItems[nIndex],
                     L"OpStartTime",
                     pPendingOps->ftimeCurrentOpStarted
                     );

            if (FAILED(hr)) {
                goto cleanup;
            }
        }
           
    }
    

cleanup:
    
    if (FAILED(hr))
    {
       ReleaseIndicateArray( paIndicateItems, (*pObjectCount) );
       (*pObjectCount) = 0L;
       *pppIndicateItem = NULL;
    }
    else
    {
        *pppIndicateItem = paIndicateItems;
    }
    
    
    if (pPendingOps != NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        pPendingOps = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}


    
HRESULT CRpcReplProv::CreateNamingContext(
        IN BOOL    bGetMasterReplica,                
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        )
{
/*++    CreateNamingContext

Routine Description:

    This is a helper function that creates all instances of naming
    context objects.This routine reads the msDS-HasMasterNCs (or hasMasterNCs 
    for win2k's hasMasterNCs) OR the hasPartialNCs object off the
    NTDS-Settings object of the local server.
    

Parameters:

    bGetMasterReplica -  BOOLEAN, specifying whether to create partial
                         or master NamingContexts
    pppIndicateItem   -  pointer to address of array of objects
                         (IWbemClassObject**) 
    pObjectCount      -  LONG*, pointer to number of objects
                         (instances that were created)

Return Values:

     - WBEM_S_NO_ERROR, objects were created    
     - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object
        (instead of direct ldap calls)

--*/
    
    HRESULT hr = WBEM_E_FAILED;
    *pObjectCount = 0L;

    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant      svarArray;
    CComVariant      svarDN;
    CComBSTR      bstrDSADN;    
    LONG lstart, lend;
    LONG index = 0L;
    SAFEARRAY *sa = NULL;
    CComVariant varItem;
    IWbemClassObject** paIndicateItems = NULL;
    
    

    ASSERT(pppIndicateItem != NULL);
    if (pppIndicateItem == NULL)
    {
    hr = WBEM_E_FAILED;
    goto cleanup;
    }
    
    hr = ADsOpenObject( L"LDAP://RootDSE",
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsRootDSE);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsRootDSE != NULL);    

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
    goto cleanup;

    ASSERT(svarDN.bstrVal != NULL);
    
    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( bstrDSADN,
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsDSA);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    
    if (bGetMasterReplica){
        hr = spIADsDSA->GetEx(L"msDS-HasMasterNCs", &svarArray);
        if (FAILED(hr)) {
            // Try failing back to the old hasMasterNCs
            hr = spIADsDSA->GetEx(L"hasMasterNCs", &svarArray);
        }
    } else {
        hr = spIADsDSA->GetEx(L"hasPartialReplicaNCs", &svarArray );
    }

    if (FAILED(hr))
        goto cleanup;
        
    sa = svarArray.parray;
    // Get the lower and upper bound
    hr = SafeArrayGetLBound( sa, 1, &lstart );
    if (FAILED(hr))
        goto cleanup;

    hr = SafeArrayGetUBound( sa, 1, &lend );
    if (FAILED(hr))
        goto cleanup;
    
    (*pObjectCount) = (lend-lstart)+1;
    paIndicateItems = new IWbemClassObject*[(*pObjectCount)];
    if (NULL == paIndicateItems)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }
    ::ZeroMemory( paIndicateItems, (*pObjectCount) * sizeof(IWbemClassObject*) );
        
    for (index = lstart; index <= lend; index++)
    {
        hr = SafeArrayGetElement( sa, &index, &varItem );
        if (SUCCEEDED(hr)&&varItem.vt == VT_BSTR)
        {
            hr = m_sipClassDefNamingContext->SpawnInstance( 0, &(paIndicateItems[index]) );
            if (SUCCEEDED(hr)&&paIndicateItems[index] != NULL)
            {    
                CComVariant vTemp = bGetMasterReplica;
                #ifdef EMBEDDED_CODE_SUPPORT
                /*EMBEDDED_CODE_SUPPORT*/
                SAFEARRAY*  pArray = NULL;
                VARIANT vArray;
                #endif

                hr = paIndicateItems[index]->Put( L"DistinguishedName", 0, &varItem, 0 );
                if (FAILED(hr))
                    goto cleanup;
                                        
                hr = paIndicateItems[index]->Put( L"IsFullReplica", 0, &vTemp, 0 );
                if (FAILED(hr))
                    goto cleanup;
                
                #ifdef EMBEDDED_CODE_SUPPORT
                /*EMBEDDED_CODE_SUPPORT*/
                hr = CreateCursors(varItem.bstrVal,&pArray);
                if (FAILED(hr))
                    goto cleanup;
                
                VariantInit(&vArray);
                vArray.vt = VT_ARRAY|VT_UNKNOWN;
                vArray.parray = pArray;
                hr = paIndicateItems[index]->Put( L"cursorArray", 0, &vArray, 0 );
                VariantClear(&vArray);
                if (FAILED(hr))
                    goto cleanup;
                #endif
             }
        }
    }

cleanup:    

    if (FAILED(hr))
    {
       ReleaseIndicateArray( paIndicateItems, (*pObjectCount) );
       (*pObjectCount) = 0L;
       *pppIndicateItem = NULL;
    }
    else
    {
        *pppIndicateItem = paIndicateItems;
    }
    
    return hr;
}


/*++    GetDomainController

Routine Description:

    GetDomainContorller is a helper function that matches the "key" of
    the DomainController object to an object path (bstrKeyValue).
    Note that in this case the key is the DN of the server.

Parameters:

    bstrKeyValue    -  BSTR, from which the Server DN is extracted.
    ppIndicateItem  -  pointer to IWbemClassObject* 
                       (contains the instance, if found).

Return Values:

      - WBEM_S_NO_ERROR, object found    
      - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object 
        (instead of direct ldap calls).

--*/
HRESULT CRpcReplProv::GetDomainController(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant svarDN;
    CComVariant svarNC;
    CComPtr<IADsPathname> spPathCracker;
    CComBSTR    bstrDSADN;    
    IWbemClassObject* pIndicateItem = NULL;
    BOOL    bImpersonate = FALSE;

    if (NULL == bstrKeyValue || IsBadStringPtrW(bstrKeyValue,0))
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
        bImpersonate = TRUE;
        
    hr = ADsOpenObject(
             L"LDAP://RootDSE",
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsRootDSE
             );
    if (FAILED(hr))
        goto cleanup;

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT( VT_BSTR == svarDN.vt );
    
    //
    // If the DN doesn't match the key value, then exit!
    // (since an incorrect DN has been provided)
    //
    if (  NULL != bstrKeyValue
        && (lstrcmpiW(svarDN.bstrVal, bstrKeyValue) != 0)
        )
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    //
    // The defaultNamingContext attribute is also needed.
    //
    hr = spIADsRootDSE->Get(L"defaultNamingContext", &svarNC);
    if (FAILED(hr)) {
        goto cleanup;
    }
    ASSERT( VT_BSTR == svarNC.vt);

    //
    // Key value matched, so lets create an instance
    //
    hr= m_sipClassDefDomainController->SpawnInstance( 0, &pIndicateItem );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(pIndicateItem != NULL);
    
    //
    // Get the DSA object
    //
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject(
             bstrDSADN,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsDSA
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    //
    // Prepare a path cracker object
    //
    hr = CoCreateInstance(
             CLSID_Pathname,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsPathname,
             (PVOID *)&spPathCracker
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spPathCracker != NULL);

    hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    if (FAILED(hr))
        goto cleanup;

    hr = PutAttributesDC(
            pIndicateItem,
            spPathCracker,
            spIADsDSA,
            svarDN.bstrVal,
            svarNC.bstrVal
            );

cleanup:
    
    *ppIndicateItem = pIndicateItem;
    if (FAILED(hr))
    {
        //
        // Error getting DomainController object, deallocate it,
        // if SpawnInstance has been called.
        //
        if (pIndicateItem != NULL)
        {
            pIndicateItem->Release();
            pIndicateItem = NULL;
        }
    }
    if(bImpersonate)
    {    
        CoRevertToSelf();
    }    
    return hr;
}

/*++    CreateDomainController

Routine Description:

    CreateDomeainController is a helper function that creates instances of 
    the MSAD_DomainController object 
    
Parameters:

    pIndicateItem  -  pointer to IWbemClassObject* 
                     (contains the instance, if found)
    

Return Values:

      - WBEM_S_NO_ERROR, object created    
      - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object (instead of direct
        ldap calls)

--*/
HRESULT 
CRpcReplProv::CreateDomainController(
    OUT IWbemClassObject** ppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant svarDN;
    CComVariant svarNC;
    CComPtr<IADsPathname> spPathCracker;
    CComBSTR    bstrDSADN;    
    IWbemClassObject* pIndicateItem = NULL;
    BOOL        bImpersonate = FALSE;

    hr= m_sipClassDefDomainController->SpawnInstance( 0, &pIndicateItem );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(pIndicateItem != NULL);
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    bImpersonate = TRUE;
        
    hr = ADsOpenObject(
             L"LDAP://RootDSE",
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsRootDSE
             );
    if (FAILED(hr))
        goto cleanup;

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT( VT_BSTR == svarDN.vt );

    hr = spIADsRootDSE->Get(L"defaultNamingContext", &svarNC);
    if (FAILED(hr)) {
        goto cleanup;
    }
    ASSERT( VT_BSTR == svarNC.vt);
    
    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( 
             bstrDSADN,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsDSA
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    // Prepare a path cracker object
    hr = CoCreateInstance(
            CLSID_Pathname,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsPathname,
            (PVOID *)&spPathCracker
            );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spPathCracker != NULL);

    hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    if (FAILED(hr))
        goto cleanup;

    hr = PutAttributesDC(
             pIndicateItem,
             spPathCracker,
             spIADsDSA,
             svarDN.bstrVal,
             svarNC.bstrVal
             );
cleanup:
    
    if(bImpersonate)
    {    
        CoRevertToSelf();
    }    
    
    if (FAILED(hr))
    {
        //
        // We failed to create DomainController object, deallocate object
        //
        pIndicateItem->Release();
        pIndicateItem = NULL;
    }
    *ppIndicateItem = pIndicateItem;
    return hr;
}


/*++    PutAttributesDC

Routine Description:

    This function fills attribute values on a 
    MSAD_DomainController object (via pIndicateItem)

Parameters:

    pPathCracker        -  pointer to path cracker object
    pIndicateItem       -  pointer to IWbemClassObject* 
    spIADsDSA           -  pointer to IADs
    bstrDN              -  DN of Server

Return Values:

     
Notes:
        ADSI is used to get at the NTDS-Settings object
        (instead of direct ldap calls)

--*/
HRESULT
CRpcReplProv::PutAttributesDC(
    IN IWbemClassObject*    pIndicateItem,
    IN IADsPathname*        pPathCracker,
    IN IADs*                spIADsDSA,
    IN BSTR                 bstrDN,
    IN BSTR                 bstrDefaultNC 
    )
{
    WBEM_VALIDATE_INTF_PTR( pIndicateItem );
    WBEM_VALIDATE_INTF_PTR( pPathCracker );

    HRESULT hr = WBEM_S_NO_ERROR;
    CComVariant svar;
    CComVariant svar2;
    BOOL fBoolVal;
    BOOL fBool;
    
    #ifdef EMBEDDED_CODE_SUPPORT
    /*EMBEDDED_CODE_SUPPORT*/
    SAFEARRAY*  pArray = NULL;    
    #endif

    CComBSTR sbstrServerCN, sbstrSite, sbstrObjectGUID;
    VARIANT vObjGuid;
    LPWSTR pszStrGuid = NULL;
    DWORD dwPercentRidAvailable;
    VariantInit(&vObjGuid);

    do 
    {
        hr = spIADsDSA->Get(L"objectGuid", &vObjGuid);
        BREAK_ON_FAIL;

        ASSERT( (VT_ARRAY|VT_UI1) == vObjGuid.vt);
        
        hr = ConvertBinaryGUIDtoUUIDString(
                 vObjGuid,
                 &pszStrGuid
                 );
        BREAK_ON_FAIL;

        //
        // The Guid needs to be put as a UUID attribute.
        //
        svar = pszStrGuid;
        ASSERT( VT_BSTR == svar.vt );

        hr = pIndicateItem->Put( L"NTDsaGUID", 0, &svar, 0 );
        BREAK_ON_FAIL;
        
        hr = pPathCracker->Set(bstrDN , ADS_SETTYPE_DN );
        BREAK_ON_FAIL;
        hr = pPathCracker->GetElement( 1L, &sbstrServerCN );
        BREAK_ON_FAIL;
        hr = pPathCracker->GetElement( 3L, &sbstrSite );
        BREAK_ON_FAIL;

        svar = bstrDN;
        hr = pIndicateItem->Put( L"DistinguishedName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrServerCN;
        hr = pIndicateItem->Put( L"CommonName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrSite;
        hr = pIndicateItem->Put( L"SiteName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        
        //check to see if DC is a GC...
        hr = spIADsDSA->Get(L"options", &svar);
        svar2 = false;
        if (hr == S_OK)
        {
            if  ((svar.vt == VT_I4)&&(NTDSDSA_OPT_IS_GC & svar.lVal))
            {
                svar2 = true;
            }
        }
        hr = pIndicateItem->Put( L"IsGC", 0, &svar2, 0 );
        BREAK_ON_FAIL;

        //
        // Query the status of DNS updates performed by netlogon.
        //
        hr = GetDNSRegistrationStatus(&fBool);
        //
        // For the the client whose server does not have support of NETLOGON_CONTROL_QUERY_DNS_REG
        // it is OK to fail
        //
        if(SUCCEEDED(hr)) {
            svar2 = fBool;
            hr = pIndicateItem->Put( L"IsRegisteredInDNS", 0, &svar2, 0);
            BREAK_ON_FAIL;
        }

        //
        // IsAdvertisingToLocator.
        //
        hr = GetAdvertisingToLocator(&fBoolVal);
        //
        // This is defaulted to false, so even if the read
        // failed, it is ok to proceed.
        //      
        if (SUCCEEDED(hr)) {
            svar2 = fBoolVal;
            hr = pIndicateItem->Put(L"IsAdvertisingToLocator", 0, &svar2, 0);
            BREAK_ON_FAIL;
        }
        
        hr = GetSysVolReady(&fBoolVal);
        if (SUCCEEDED(hr)) {
            svar2 = fBoolVal;
            hr = pIndicateItem->Put(L"IsSysVolReady", 0, &svar2, 0);
            BREAK_ON_FAIL;
        }

        hr = GetRidStatus(
                 bstrDefaultNC,
                 &fBoolVal,
                 &dwPercentRidAvailable
                 );
        BREAK_ON_FAIL;

        svar2 = fBoolVal;
        hr = pIndicateItem->Put(L"IsNextRIDPoolAvailable", 0, &svar2, 0);
        BREAK_ON_FAIL;

        svar2 = (LONG) dwPercentRidAvailable;
        hr = pIndicateItem->Put(L"PercentOfRIDsLeft", 0, &svar2, 0);
        BREAK_ON_FAIL;

        //
        // Now the queue statistics. The function will fail on Win2k platform. So for the compatibility with win2k, we
        // do not bail out and clear the error code
        //
        hr = GetAndUpdateQueueStatistics(pIndicateItem);
        hr = WBEM_S_NO_ERROR;
        
        
        #ifdef EMBEDDED_CODE_SUPPORT
        /*EMBEDDED_CODE_SUPPORT*/
        //Get PendingOps, note that these are embedded objects (stored in a SAFEARRAY)
        hr = CreatePendingOps(&pArray);
        BREAK_ON_FAIL;

        VARIANT vTemp;
        VariantInit(&vTemp);
        vTemp.vt = VT_ARRAY|VT_UNKNOWN;
        vTemp.parray = pArray;
        hr = pIndicateItem->Put( L"pendingOpsArray", 0, &vTemp, 0 );
        VariantClear(&vTemp);
        BREAK_ON_FAIL;
        #endif    
        
    } while (false);

    //
    // Cleanup strings and variant if need be.
    //
    if (pszStrGuid) {
        RpcStringFreeW(&pszStrGuid);
    }

    VariantClear(&vObjGuid);

    return hr;
}

HRESULT 
CRpcReplProv::GetDNSRegistrationStatus(
    OUT BOOL *pfBool
    )
{
    PNETLOGON_INFO_1 NetlogonInfo1 = NULL;
    LPBYTE InputDataPtr = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;
    NET_API_STATUS NetStatus = 0;
    DWORD dwSize = 0;
    LPWSTR pszName = NULL;

    *pfBool = FALSE;

    //
    // Get the length of this computers name and alloc buffer
    // and retrieve the name.
    //
    GetComputerNameExW(
        ComputerNameDnsFullyQualified,
        NULL,
        &dwSize
        );

    if (dwSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (FAILED(hr))
            goto cleanup;
    }

    pszName = new WCHAR[dwSize];

    if (!pszName) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,
             pszName,
             &dwSize
             )
        ) {
        //
        // Call failed for some reason.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (FAILED(hr))
            goto cleanup;
    }
        
    NetStatus = I_NetLogonControl2( pszName,    // this is the name of server where to execute this RPC call
                                     NETLOGON_CONTROL_QUERY_DNS_REG,
                                     1,
                                     (LPBYTE) &InputDataPtr,
                                     (LPBYTE *)&NetlogonInfo1
                                     );

    if ( NetStatus == NO_ERROR ) {
        if ( NetlogonInfo1->netlog1_flags & NETLOGON_DNS_UPDATE_FAILURE ) {
            *pfBool = FALSE;
        } 
        else {
            *pfBool = TRUE;
        }
    }

    hr = HRESULT_FROM_WIN32( NetStatus );

cleanup:

    if(pszName) {
    	delete [] pszName;
    }

    if(NetlogonInfo1) {
    	NetApiBufferFree( NetlogonInfo1 );
    }
    return hr;
    
}





/*++    THE FOLLOWING COMMENT APPLIES TO THE NEXT 11 functions

        EnumAndIndicateReplicaSourcePartner, EnumAndIndicateWorker, BuildIndicateArrayStatus, ReleaseIndicateArray
        BuildListStatus, ExtractDomainName: 
            Are helper functions that facilitate the creation or the retrieval of instances of the 
        MicrosoftAD_ReplicaSourcePartner object. 
        
        PutAttributesStatus, PutUUIDAttribute, PutLONGLONGAttribute, PutFILETIMEAttribute
        PutBooleanAttributes: 
        Are helper functions that fill attribute values on the MicrosoftAD_ReplicaSourcePartner object.

        The following steps occur:
            
            1) CoImpersonateClient is called
            2) DsReplicaGetInfo is called
            3) Information is extracted, to build an array of "connections"
            4) Object is checked against the key value 
                If kevalue != NULL, then 
                    If keyvalue matches "key" of object then, that object is returned, and the array is deallocated
                    Otherwise S_FALSE is returned and the array is deallocated
                If keyvalue == NULL
                    Then CreateInstanceEnumAsync is the caller. That means all instances are returned 
            5) IWbemObjectSink::Indicate and IWbemObjectSink::SetStatus are called  
            6) CoRevertToSelf is called

--*/

HRESULT 
CRpcReplProv::EnumAndIndicateReplicaSourcePartner(
    IN IWbemObjectSink *pResponseHandler,
    IN const BSTR bstrKeyValue
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HANDLE hDS = NULL;
    bool fImpersonating = false;

    WCHAR UnicodeComputerName[MAX_PATH];
    DWORD dwSize = sizeof(UnicodeComputerName)/sizeof(WCHAR);
    DWORD dwError = NO_ERROR;
    
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        fImpersonating = true;

    if ( !GetComputerNameExW(
             ComputerNameDnsFullyQualified,  
             UnicodeComputerName,
             &dwSize 
             )
         )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(
                     UnicodeComputerName, // DomainControllerName
                     NULL,            // DnsDomainName
                     &hDS             // phDS
                     );
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT( NULL != hDS );

    hr = EnumAndIndicateWorker(
             hDS,
             pResponseHandler,
             bstrKeyValue 
             );
cleanup:
        
    if (fImpersonating)
    {
        // CODEWORK do we want to keep impersonating and reverting?
        HRESULT hr2 = CoRevertToSelf();
        ASSERT( !FAILED(hr2) );
    }

    if (NULL != hDS)
    {
        (void) DsUnBind( &hDS );
    }
    return hr;
}


HRESULT 
CRpcReplProv::EnumAndIndicateWorker(
    IN HANDLE hDS,
    IN IWbemObjectSink *pResponseHandler,
    IN const BSTR bstrKeyValue,
    IN const BSTR bstrDnsDomainName
    )
{
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrKeyValue);
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrDnsDomainName);

    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hr2 = WBEM_S_NO_ERROR;
    DS_REPL_NEIGHBORSW* pneighborsstruct = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 * pDCs = NULL; // BUGBUG not needed
    ULONG cDCs = 0;
    DWORD cIndicateItems = 0;
    IWbemClassObject** paIndicateItems = NULL;

    hr = BuildListStatus( hDS, &pneighborsstruct );
    if (FAILED(hr))
        goto cleanup;

    hr = BuildIndicateArrayStatus( 
             pneighborsstruct,
             bstrKeyValue,
             &paIndicateItems,
             &cIndicateItems
             );
    if (FAILED(hr))
        goto cleanup;

    //
    // Send the objects to the caller
    //
    // [In] param, no need to addref.
    hr2 = pResponseHandler->Indicate( cIndicateItems, paIndicateItems );

    // Let CIMOM know you are finished
    // return value and SetStatus param should be consistent, so ignore
    // the return value from SetStatus itself (in retail builds)
    hr = pResponseHandler->SetStatus( WBEM_STATUS_COMPLETE, hr2,
                                              NULL, NULL );
    ASSERT( !FAILED(hr) );

cleanup:
        
    ReleaseIndicateArray( paIndicateItems, cIndicateItems );

    if ( NULL != pneighborsstruct )
    {
        (void) DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pneighborsstruct );
    }
    if ( NULL != pDCs )
    {
        (void) NetApiBufferFree( pDCs );
    }

    return hr;
}


HRESULT 
CRpcReplProv::BuildIndicateArrayStatus(
    IN  DS_REPL_NEIGHBORSW*  pneighborstruct,
    IN  const BSTR          bstrKeyValue,
    OUT IWbemClassObject*** ppaIndicateItems,
    OUT DWORD*              pcIndicateItems
    )
{
    WBEM_VALIDATE_IN_STRUCT_PTR( pneighborstruct, DS_REPL_NEIGHBORSW );
    WBEM_VALIDATE_IN_MULTISTRUCT_PTR( pneighborstruct->rgNeighbor,
                                      DS_REPL_NEIGHBORSW,
                                      pneighborstruct->cNumNeighbors );
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL( bstrKeyValue );
    WBEM_VALIDATE_OUT_PTRPTR( ppaIndicateItems );
    WBEM_VALIDATE_OUT_STRUCT_PTR( pcIndicateItems, DWORD );

    HRESULT hr = WBEM_S_NO_ERROR;
    DS_REPL_NEIGHBORW* pneighbors = pneighborstruct->rgNeighbor;
    DWORD cneighbors = pneighborstruct->cNumNeighbors;
    if (0 == cneighbors)
        return WBEM_S_NO_ERROR;

    IWbemClassObject** paIndicateItems = NULL;
    DWORD cIndicateItems = 0;

    *ppaIndicateItems = NULL;
    *pcIndicateItems = 0;

    do
    {
        paIndicateItems = new IWbemClassObject*[cneighbors];
        if (NULL == paIndicateItems)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        ::ZeroMemory( paIndicateItems, cneighbors * sizeof(IWbemClassObject*) );
        for (DWORD i = 0; i < cneighbors; i++)
        {
            DS_REPL_NEIGHBORW* pneighbor = &(pneighbors[i]);

            hr = PutAttributesStatus(
                     &paIndicateItems[cIndicateItems],
                     bstrKeyValue,
                     pneighbor
                     );
            if (S_FALSE == hr)
                continue;
            cIndicateItems++;
            BREAK_ON_FAIL;
        }

    } while (false);

    if (!FAILED(hr))
    {
        *ppaIndicateItems = paIndicateItems;
        *pcIndicateItems  = cIndicateItems;
    }
    else
    {
        ReleaseIndicateArray( paIndicateItems, cneighbors );
    }

    if (bstrKeyValue 
        && *bstrKeyValue
        && *pcIndicateItems
        && hr == S_FALSE ) {
        //
        // We were looking for just one entry and we found it
        //
        hr = S_OK;
    }
    return hr;
}

void CRpcReplProv::ReleaseIndicateArray(
    IWbemClassObject**  paIndicateItems,
    DWORD               cIndicateItems,
    bool                fReleaseArray)
{
    if (paIndicateItems != NULL)
    {
        for (DWORD i = 0; i < cIndicateItems; i++)
        {
            if (NULL != paIndicateItems[i])
                paIndicateItems[i]->Release();
        }
        if (fReleaseArray)
        {
            delete[] paIndicateItems;
        }
        else
        {
            ::ZeroMemory( *paIndicateItems,
                          cIndicateItems * sizeof(IWbemClassObject*) );

        }
    }
}


// does not validate resultant structs coming from API
HRESULT CRpcReplProv::BuildListStatus(
    IN HANDLE hDS,
    OUT DS_REPL_NEIGHBORSW** ppneighborsstruct )
{
   WBEM_VALIDATE_OUT_STRUCT_PTR(ppneighborsstruct,DS_REPL_NEIGHBORSW*);

   HRESULT hr = WBEM_S_NO_ERROR;
   DWORD dwError = NO_ERROR;

   do {
       dwError = DsReplicaGetInfoW(
                    hDS,                        // hDS
                    DS_REPL_INFO_NEIGHBORS,     // InfoType
                    NULL,                       // pszObject
                    NULL,                       // puuidForSourceDsaObjGuid,
                    (void**)ppneighborsstruct   // ppinfo
                    );
       hr = HRESULT_FROM_WIN32(dwError);
       
       BREAK_ON_FAIL;

       if ( BAD_IN_STRUCT_PTR(*ppneighborsstruct,DS_REPL_NEIGHBORSW) )
       {
           break;
       }

   } while (false);

   return hr;
}

//
// if this returns S_FALSE, skip this connection but do not
// consider this an error
//
HRESULT 
CRpcReplProv::PutAttributesStatus(
    IWbemClassObject**  pipNewInst,
    const BSTR          bstrKeyValue,
    DS_REPL_NEIGHBORW*   pneighbor
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LPWSTR   UuidString = NULL;

    if (   BAD_IN_STRING_PTR(pneighbor->pszNamingContext)
        || BAD_IN_STRING_PTR(pneighbor->pszSourceDsaDN)
        || BAD_IN_STRING_PTR_OPTIONAL(pneighbor->pszSourceDsaAddress)
        || BAD_IN_STRING_PTR_OPTIONAL(pneighbor->pszAsyncIntersiteTransportDN)
       )
    {
        return S_FALSE;
    }

    CComPtr<IADsPathname> spPathCracker;
    CComBSTR sbstrReplicatedDomain, // DNS name of replicated domain
    sbstrSourceServer,     // CN= name of source server
    sbstrSourceSite,       // name of site containing source server
    sbstrCompositeName;    // composite name for WMI

    do {
        hr = ExtractDomainName(
                 pneighbor->pszNamingContext,
                 &sbstrReplicatedDomain
                 );
        BREAK_ON_FAIL;

        boolean bIsConfigNC = (0 == _wcsnicmp(pneighbor->pszNamingContext,
                                             L"CN=Configuration,",
                                             17));
        boolean bIsSchemaNC = (0 == _wcsnicmp(pneighbor->pszNamingContext,
                                             L"CN=Schema,",
                                             10));
        boolean bIsDeleted = (pneighbor->pszSourceDsaDN 
                              && (wcsstr( 
                                      pneighbor->pszSourceDsaDN,
                                      L"\nDEL:"
                                      )
                                  || wcsstr(
                                      pneighbor->pszSourceDsaDN,
                                      L"\\0ADEL:"
                                      )
                                  )
                              );

        //
        // retrieve source server name and site name
        //
        hr = CoCreateInstance(
                 CLSID_Pathname,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_IADsPathname,
                 (PVOID *)&spPathCracker
                 );
        BREAK_ON_FAIL;
        ASSERT( !!spPathCracker );
        hr = spPathCracker->Set( pneighbor->pszSourceDsaDN, ADS_SETTYPE_DN );
        BREAK_ON_FAIL;
        hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_ON_FAIL;
        hr = spPathCracker->GetElement( 1L, &sbstrSourceServer );
        BREAK_ON_FAIL;
        hr = spPathCracker->GetElement( 3L, &sbstrSourceSite );
        BREAK_ON_FAIL;

        //
        // Build the composite name.
        // This will be something like :
        // MSAD_ReplNeighbor.NamingContextDN="dc=config,dc=mycom ...",
        // SourceDsaObjGuid="245344d6-018e-49a4-b592-f1974fd91cc6"
        //
        sbstrCompositeName = strKeyReplNeighbor;
        sbstrCompositeName += pneighbor->pszNamingContext;
        sbstrCompositeName += L"\",";
        sbstrCompositeName += strKeyReplNeighborGUID;
        //
        // Need to get the UUID in the correct format now.
        //

        if (UuidToStringW(
                &pneighbor->uuidSourceDsaObjGuid,
                &UuidString
                ) != RPC_S_OK
            ) {
            hr = WBEM_E_FAILED;
        }
        BREAK_ON_FAIL;

        sbstrCompositeName += UuidString;
        sbstrCompositeName += L"\"";

        if(UuidString != NULL)
            RpcStringFreeW(&UuidString);

        //
        // Test the composite name against the key value
        //
        if (   NULL != bstrKeyValue
            && (lstrcmpiW(sbstrCompositeName, bstrKeyValue) != 0)
        )
        {
            hr = S_FALSE;
            break;
        }

        //
        // Create a new instance of the data object
        //
        hr = m_sipClassDefReplNeighbor->SpawnInstance( 0, pipNewInst );
        BREAK_ON_FAIL;
        IWbemClassObject* ipNewInst = *pipNewInst;
        if (NULL == ipNewInst)
        {
            hr = S_FALSE;
            break;
        }

        CComVariant svar;

        svar = pneighbor->pszNamingContext;
        hr = ipNewInst->Put( L"NamingContextDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszSourceDsaDN;
        hr = ipNewInst->Put( L"SourceDsaDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszSourceDsaAddress;
        hr = ipNewInst->Put( L"SourceDsaAddress", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszAsyncIntersiteTransportDN;
        hr = ipNewInst->Put( L"AsyncIntersiteTransportDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)pneighbor->dwReplicaFlags;
        hr = ipNewInst->Put( L"ReplicaFlags", 0, &svar, 0 );
        BREAK_ON_FAIL;

        if (bIsDeleted)
        {
            svar = TRUE;
            hr = ipNewInst->Put( L"IsDeletedSourceDsa", 0, &svar, 0 );
            BREAK_ON_FAIL;
        }
        
        svar = sbstrSourceSite;
        hr = ipNewInst->Put( L"SourceDsaSite", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrSourceServer;
        hr = ipNewInst->Put( L"SourceDsaCN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrReplicatedDomain;
        hr = ipNewInst->Put( L"Domain", 0, &svar, 0 );
        BREAK_ON_FAIL;

LPCWSTR aBooleanAttrNames[12] = {
    L"Writeable",
    L"SyncOnStartup",
    L"DoScheduledSyncs",
    L"UseAsyncIntersiteTransport",
    L"TwoWaySync",
    L"FullSyncInProgress",
    L"FullSyncNextPacket",
    L"NeverSynced",
    L"IgnoreChangeNotifications",
    L"DisableScheduledSync",
    L"CompressChanges",
    L"NoChangeNotifications"
    };

DWORD aBitmasks[12] = {
    DS_REPL_NBR_WRITEABLE,
    DS_REPL_NBR_SYNC_ON_STARTUP,
    DS_REPL_NBR_DO_SCHEDULED_SYNCS,
    DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT,
    DS_REPL_NBR_TWO_WAY_SYNC,
    DS_REPL_NBR_FULL_SYNC_IN_PROGRESS,
    DS_REPL_NBR_FULL_SYNC_NEXT_PACKET,
    DS_REPL_NBR_NEVER_SYNCED,
    DS_REPL_NBR_IGNORE_CHANGE_NOTIFICATIONS,
    DS_REPL_NBR_DISABLE_SCHEDULED_SYNC,
    DS_REPL_NBR_COMPRESS_CHANGES,
    DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS
    };

    hr = PutBooleanAttributes(
             ipNewInst,
             12,
             aBooleanAttrNames,
             aBitmasks,
             pneighbor->dwReplicaFlags
             );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                                L"NamingContextObjGuid",
                                pneighbor->uuidNamingContextObjGuid );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                               L"SourceDsaObjGuid",
                               pneighbor->uuidSourceDsaObjGuid );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                                L"SourceDsaInvocationID",
                                pneighbor->uuidSourceDsaInvocationID );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                                L"AsyncIntersiteTransportObjGuid",
                                pneighbor->uuidAsyncIntersiteTransportObjGuid );
        BREAK_ON_FAIL;

        hr = PutLONGLONGAttribute( ipNewInst,
                                    L"USNLastObjChangeSynced",
                                    pneighbor->usnLastObjChangeSynced);
        BREAK_ON_FAIL;

        hr = PutLONGLONGAttribute( ipNewInst,
                                    L"USNAttributeFilter",
                                    pneighbor->usnAttributeFilter);
        BREAK_ON_FAIL;

        hr = PutFILETIMEAttribute( ipNewInst,
                                    L"TimeOfLastSyncSuccess",
                                    pneighbor->ftimeLastSyncSuccess);
        BREAK_ON_FAIL;

        hr = PutFILETIMEAttribute( ipNewInst,
                                    L"TimeOfLastSyncAttempt",
                                    pneighbor->ftimeLastSyncAttempt);
        BREAK_ON_FAIL;

        svar = (long)pneighbor->dwLastSyncResult;
        hr = ipNewInst->Put( L"LastSyncResult", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)pneighbor->cNumConsecutiveSyncFailures;
        hr = ipNewInst->Put( L"NumConsecutiveSyncFailures", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)((bIsDeleted) ? 
                      0L 
                      : pneighbor->cNumConsecutiveSyncFailures);
        hr = ipNewInst->Put( 
                 L"ModifiedNumConsecutiveSyncFailures",
                 0,
                 &svar,
                 0
                 );
        BREAK_ON_FAIL;

    } while (false);

    return hr;
}


HRESULT CRpcReplProv::PutUUIDAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    UUID&             refuuid)
{
    LPWSTR   UuidString = NULL;
    HRESULT hr = WBEM_E_FAILED;
    CComVariant svar;
     
    if (UuidToStringW(&refuuid, &UuidString) == RPC_S_OK)
    {
        svar = UuidString;
        hr = ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if(UuidString != NULL)
        RpcStringFreeW(&UuidString);    
        
    return hr; 
}


HRESULT CRpcReplProv::PutLONGLONGAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    LONGLONG          longlong)
{
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    _ui64tow( longlong, ach, 10 );
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT CRpcReplProv::PutFILETIMEAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    FILETIME&         reffiletime)
{
    SYSTEMTIME systime;
    FILETIME   localtime;
    ::ZeroMemory( &systime, sizeof(SYSTEMTIME) );
    ::ZeroMemory( &localtime, sizeof(FILETIME) );

    // if the filetime is zero, it means that the operation has not started yet.
    // it will be 1601-01-01T00:00:00Z. In order not to break the existing app, we will keep it as it used to be
    if(reffiletime.dwLowDateTime == 0 && reffiletime.dwHighDateTime == 0)
    {
        if ( !FileTimeToSystemTime( &reffiletime, &systime ) )
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    else
    {
        if ( !FileTimeToLocalFileTime( &reffiletime, &localtime ))
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }
        if ( !FileTimeToSystemTime( &localtime, &systime ) )
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    swprintf( ach, L"%04u%02u%02u%02u%02u%02u.%06u+000", 
        systime.wYear,
        systime.wMonth,
        systime.wDay,
        systime.wHour,
        systime.wMinute,
        systime.wSecond,
        systime.wMilliseconds
        );
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT CRpcReplProv::PutBooleanAttributes(
    IWbemClassObject* ipNewInst,
    UINT              cNumAttributes,
    LPCWSTR*          aAttributeNames,
    DWORD*            aBitmasks,
    DWORD             dwValue)
{
    WBEM_VALIDATE_READ_PTR( aAttributeNames, cNumAttributes*sizeof(LPCTSTR) );
    WBEM_VALIDATE_READ_PTR( aBitmasks,       cNumAttributes*sizeof(DWORD) );

    HRESULT hr = WBEM_S_NO_ERROR; 
    CComVariant svar = true;
    for (UINT i = 0; i < cNumAttributes; i++)
    {
        WBEM_VALIDATE_IN_STRING_PTR( aAttributeNames[i] );
        if (dwValue & aBitmasks[i])
        {
            hr = ipNewInst->Put( aAttributeNames[i], 0, &svar, 0 );
            BREAK_ON_FAIL;
        }
    }
    return hr;
}


HRESULT CRpcReplProv::ExtractDomainName(
    IN LPCWSTR pszNamingContext,
    OUT BSTR*   pbstrDomainName )
{
    WBEM_VALIDATE_IN_STRING_PTR( pszNamingContext );
    WBEM_VALIDATE_OUT_PTRPTR( pbstrDomainName );

    PDS_NAME_RESULTW pDsNameResult = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;

    do {
        DWORD dwErr = DsCrackNamesW(
                (HANDLE)-1,
                DS_NAME_FLAG_SYNTACTICAL_ONLY,
                DS_FQDN_1779_NAME,
                DS_CANONICAL_NAME,
                1,
                &pszNamingContext,
                &pDsNameResult);
        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            break;
        }
        if (   BAD_IN_STRUCT_PTR(pDsNameResult,DS_NAME_RESULT)
            || 1 != pDsNameResult->cItems
            || DS_NAME_NO_ERROR != pDsNameResult->rItems->status
            || BAD_IN_STRUCT_PTR(pDsNameResult->rItems,DS_NAME_RESULT_ITEM)
            || BAD_IN_STRING_PTR(pDsNameResult->rItems->pDomain)
           )
        {
            hr = WBEM_E_FAILED;
            break;
        }

        *pbstrDomainName = ::SysAllocString(pDsNameResult->rItems->pDomain);
        if (NULL == *pbstrDomainName)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }

    } while (false);

    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}

/*++  ExecuteKCC

Routine Description:

    This function is a helper function that is a wrapper for
    the DsReplicaConsistencyCheck RPC call.

Parameters:

    pInstance        -  pointer to instance of MSAD_DomainContoller class

Return Values:

      - WBEM_S_NO_ERROR, success    
      - WBEM_E_FAILED, error
      - RPC errors (translated to HRESULTS)

Notes:
        CoImpersonateClient and CoRevertToSelf are used "around" the RPC call.

--*/
HRESULT 
CRpcReplProv::ExecuteKCC(
    IN IWbemClassObject* pInstance,
    IN DWORD dwTaskId,
    IN DWORD dwFlags
    )
{
    HANDLE            hDS            = NULL;
    HRESULT            hr            = WBEM_E_FAILED;
    CComVariant        vDRA;
    CComBSTR        bstrCommonName = L"CommonName"; 
    BOOLEAN            bImpersonate = FALSE;
    DWORD             dwError = NO_ERROR;

    hr = pInstance->Get(
             bstrCommonName,
             0,
             &vDRA,
             NULL,
             NULL
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(vDRA.bstrVal != NULL);
    
    hr = CoImpersonateClient();
        if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(vDRA.bstrVal, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(
                 vDRA.bstrVal,    // DomainControllerName
                 NULL,            // DnsDomainName
                 &hDS             // phDS
                 );
    }
    
    hr = HRESULT_FROM_WIN32(dwError);
    
    ASSERT(NULL != hDS);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(hDS != NULL);

    dwError = DsReplicaConsistencyCheck(
                 hDS,
                 (DS_KCC_TASKID)dwTaskId,
                 dwFlags
                 );    //only use synchronous ExecKCC
    hr = HRESULT_FROM_WIN32(dwError);

cleanup: 
    if (hDS)
        DsUnBindW(&hDS);

    if(bImpersonate)
        CoRevertToSelf();
       
    return hr;
}

/*++    ProvDSReplicaSync

Routine Description:

    This function is a helper function that is a wrapper
    for the DsReplicaSync RPC call


Parameters:

    bstrKeyValue  -  KeyValue containing object path of
                     MSAD_Connections object.
                     That should be MSAD_ReplNeighbors class.
    dwOptions     -  Type of sync call to make.                 


Return Values:

      - WBEM_S_NO_ERROR, success    
      - WBEM_E_FAILED, error
      - RPC errors (translated to HRESULTS)

Notes:
        CoImpersonateClient and CoRevertToSelf are used "around" the RPC call.

--*/
HRESULT 
CRpcReplProv::ProvDSReplicaSync(
    IN BSTR    bstrKeyValue,
    IN ULONG   dwOptions
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HANDLE hDS = NULL;
    DS_REPL_NEIGHBORSW* pneighborsstruct = NULL;
    DWORD cIndicateItems = 0;
    IWbemClassObject** paIndicateItems = NULL;
    WCHAR UnicodeComputerName[MAX_PATH];
    DWORD dwSize = sizeof(UnicodeComputerName)/sizeof(WCHAR);
    CComBSTR    sbstrNamingContextDN = L"NamingContextDN";
    CComBSTR    sbstrObjectGUID = L"SourceDsaObjGuid";
    CComVariant    svarUUID;
    CComVariant    svarNamingContextDN;
    UUID        uuid;
    BOOL    bImpersonate = FALSE;
    DWORD dwError = NO_ERROR;


    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,  
             UnicodeComputerName,
             &dwSize
             )
        )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;

    if(_pDsBindWithSpnExW)
    {
        dwError = (*_pDsBindWithSpnExW)(UnicodeComputerName, // DomainControllerName
                                       NULL,            // DnsDomainName
                                       NULL,            // authidentity     
                                       NULL,            // SPN
                                       0,               // not using delegation
                                       &hDS            // phDS
                                       );
    }
    else
    {
        dwError = DsBindW(
                     UnicodeComputerName, // DomainControllerName
                     NULL,            // DnsDomainName
                     &hDS             // phDS
                     );
    }
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    

    hr = BuildListStatus( hDS, &pneighborsstruct );
    if (FAILED(hr))
        goto cleanup;

    hr = BuildIndicateArrayStatus(
             pneighborsstruct,
             bstrKeyValue,
             &paIndicateItems,
             &cIndicateItems
             );
    if (FAILED(hr))
        goto cleanup;

    if (hr == S_FALSE) {
        //
        // We could not find the matching entry
        //
        hr = WBEM_E_NOT_FOUND;
        goto cleanup;
    }
    
    if (cIndicateItems < 1) {
        hr = WBEM_E_INVALID_OBJECT_PATH;
    }
    
    hr = paIndicateItems[0]->Get(
             sbstrNamingContextDN,
             0,
             &svarNamingContextDN,
             NULL,
             NULL
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarNamingContextDN.bstrVal != NULL);

    hr = paIndicateItems[0]->Get(
             sbstrObjectGUID,
             0,
             &svarUUID,
             NULL,
             NULL
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarUUID.bstrVal != NULL);

    
    hr = HRESULT_FROM_WIN32(UuidFromStringW(svarUUID.bstrVal, &uuid));
    if (FAILED(hr))
        goto cleanup;
    
    dwError = DsReplicaSyncW(
                 hDS, 
                 svarNamingContextDN.bstrVal,           
                 &uuid,
                 dwOptions
                 );
    hr = HRESULT_FROM_WIN32(dwError);
 
cleanup:
    
    ReleaseIndicateArray( paIndicateItems, cIndicateItems );

    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    if (NULL != pneighborsstruct)
    {
        (void) DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pneighborsstruct );
    }
    if (NULL != hDS)
    {
        DsUnBind(&hDS);
    }
    return hr;
}


HRESULT CRpcReplProv::CheckIfDomainController()
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomaininfo = NULL;
    HRESULT hr = WBEM_E_FAILED;
    DWORD dwError = NO_ERROR;
    
    dwError = DsRoleGetPrimaryDomainInformation(
        NULL,                           // lpServer = local machine
        DsRolePrimaryDomainInfoBasic,   // InfoLevel
        (PBYTE*)&pdomaininfo            // pBuffer
        );
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (FAILED(hr))
        goto cleanup;
    ASSERT( NULL != pdomaininfo );
    
    if((pdomaininfo->MachineRole == DsRole_RoleBackupDomainController)||
        (pdomaininfo->MachineRole == DsRole_RolePrimaryDomainController))
    {
        // this is a DC
        hr = WBEM_S_NO_ERROR;
    }

cleanup:    
    if (NULL != pdomaininfo)
        {
            DsRoleFreeMemory( pdomaininfo );
        }
    return hr;
}

/*
Input should be a variant that is a VT_ARRAY | VT_UI1 that is the 
length of a GUID. Output is the equivalen UUID in readable string format.
*/
HRESULT CRpcReplProv::ConvertBinaryGUIDtoUUIDString(
    IN  VARIANT vObjGuid,
    OUT LPWSTR * ppszStrGuid
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0, dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    DWORD dwLength = 0;
    UUID uuidTemp;

    if (vObjGuid.vt != (VT_ARRAY | VT_UI1)) {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = SafeArrayGetLBound(
             V_ARRAY(&vObjGuid),
             1,
             (long FAR *) &dwSLBound
             );
    if FAILED(hr) 
        goto cleanup;

    hr = SafeArrayGetUBound(
             V_ARRAY(&vObjGuid),
             1,
             (long FAR *) &dwSUBound
             );
    if FAILED(hr) 
        goto cleanup;

    dwLength = dwSUBound - dwSLBound + 1;

    if (dwLength != sizeof(UUID)) {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = SafeArrayAccessData(
             V_ARRAY(&vObjGuid),
             (void HUGEP * FAR *) &pArray
             );
    if FAILED(hr) 
        goto cleanup;

    memcpy(
        &uuidTemp,
        pArray,
        sizeof(UUID)
        );

    if (UuidToStringW( &uuidTemp, ppszStrGuid ) != RPC_S_OK) {
        hr = E_FAIL;
        goto cleanup;
    }

    SafeArrayUnaccessData( V_ARRAY(&vObjGuid) );

    return hr;

cleanup:

    if (pArray) {
        SafeArrayUnaccessData( V_ARRAY(&vObjGuid));
    }
 
    return hr;
}

/*
       Simple routine that returns true if dns registration
   for the DC is correct and false otherwise.
*/
HRESULT 
CRpcReplProv::GetDnsRegistration(
    BOOL *pfBool
    )
{
    return E_NOTIMPL;
}
    
/*
       This routine verifies that the host computer name and the
   name returned by DsGetDCName are the same. In that case the 
   return value is true, if not it is false.
*/
HRESULT 
CRpcReplProv::GetAdvertisingToLocator(
    BOOL *pfBool
    )
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    DWORD dwErr = 0;
    LPWSTR pszName = NULL;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;

    *pfBool = FALSE;
    //
    // Get the length of this computers name and alloc buffer
    // and retrieve the name.
    //
    GetComputerNameExW(
        ComputerNameDnsFullyQualified,
        NULL,
        &dwSize
        );

    if (dwSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    pszName = new WCHAR[dwSize];

    if (!pszName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,
             pszName,
             &dwSize
             )
        ) {
        //
        // Call failed for some reason.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    //
    // We now need the name from DsGetDcName
    //
    dwErr = DsGetDcNameW(
                NULL, // ComputerName
                NULL, // DomainName
                NULL, // DomainGUID
                NULL, // SiteName
                DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                &pDcInfo
                );

    if (dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure the names are valid and compare them.
    // We need to go past the \\ in the name.
    //
    if (pDcInfo->DomainControllerName
        && pszName
        && !lstrcmpiW(pszName, pDcInfo->DomainControllerName+2)
        ) {
        *pfBool = TRUE;
    }

cleanup:

    delete pszName;

    if (pDcInfo) {
        NetApiBufferFree(pDcInfo);
    }
    return hr;
}

HRESULT
CRpcReplProv::GetSysVolReady(
    BOOL *pfBool
    )
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    DWORD dwKeyVal = 0;
    DWORD dwType;
    DWORD dwBufSize = sizeof(DWORD);
    
    *pfBool = FALSE;

    if (RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
            0,
            KEY_QUERY_VALUE,
            &hKey
            )
        ) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    if (!RegQueryValueExW(
             hKey,
             L"SysVolReady",
             NULL,
             &dwType,
             (LPBYTE)&dwKeyVal,
             &dwBufSize
             ) 
        ) {
        if ((dwType == REG_DWORD)
            && (dwKeyVal == 1)) {
            *pfBool = TRUE;
        }
    }

cleanup:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    return hr;
}

/***
    This routine first locates the computer object for the domain
    controller and reads the rIDSetReference from this object.
    Then the Rid detailsa re read from the rIDSetReference (this is
    a dn value) and the return values computed accrodingly.
***/
HRESULT
CRpcReplProv::GetRidStatus(
    LPWSTR pszDefaultNamingContext,
    PBOOL  pfNextRidAvailable,
    PDWORD pdwPercentRidAvailable
    )
{
    HRESULT hr = S_OK;
    CComPtr<IADs> spIADs;
    CComPtr<IDirectoryObject> spIDirObj;
    CComBSTR bstrCompName;
    CComVariant svarRid;
    ADS_ATTR_INFO *pAttrInfo = NULL;
    LPWSTR pszCompObjName = NULL;
    LPWSTR  pszAttrNames[] = {
        L"rIDNextRID",
        L"rIDPreviousAllocationPool",
        L"rIDAllocationPool"
    };
    DWORD dwSize = 0;
    DWORD dwErr = 0;
    DWORD dwNextRID = 0;
    ULONGLONG ridPrevAllocPool = 0;
    ULONGLONG ridAllocPool = 0;
    ULONGLONG Hvalue, Lvalue;


    *pfNextRidAvailable = FALSE;
    *pdwPercentRidAvailable = 0;

    //
    // First get the compter object name length.
    //
    dwErr = GetComputerObjectNameW(
                NameFullyQualifiedDN,
                NULL,
                &dwSize
                );
    if (dwSize > 0) {
        pszCompObjName = new WCHAR[dwSize];
        
        if (!pszCompObjName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        dwErr = GetComputerObjectNameW(
                    NameFullyQualifiedDN,
                    pszCompObjName,
                    &dwSize
                    );
    }

    if (!dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // Now get the object and from it the ridSetReference.
    //
    bstrCompName = L"LDAP://";
    bstrCompName += pszCompObjName;
    
    hr = ADsOpenObject(
             bstrCompName,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADs
             );
    BAIL_ON_FAILURE(hr);

    hr = spIADs->Get(L"rIDSetReferences", &svarRid);
    BAIL_ON_FAILURE(hr);

    bstrCompName = L"LDAP://";
    bstrCompName += svarRid.bstrVal;

    hr = ADsOpenObject(
             bstrCompName,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectoryObject,
             OUT (void **)&spIDirObj
             );
    BAIL_ON_FAILURE(hr);

    dwSize = 0;
    hr = spIDirObj->GetObjectAttributes(
             pszAttrNames,
             3,
             &pAttrInfo,
             &dwSize
             );
    BAIL_ON_FAILURE(hr);

    //
    // Go through the attributes and update values accrodingly.
    //
    for (DWORD dwCtr = 0; dwCtr < dwSize; dwCtr++) {

        if (pAttrInfo && pAttrInfo[dwCtr].pszAttrName) {
            
            LPWSTR pszTmpStr = pAttrInfo[dwCtr].pszAttrName;

            if (!_wcsicmp(pszAttrNames[0], pszTmpStr)) {
                //
                // Found rIDNextRID.
                //
                if ((pAttrInfo[dwCtr].dwNumValues == 1)
                    && (pAttrInfo[dwCtr].dwADsType == ADSTYPE_INTEGER)) {

                         dwNextRID = pAttrInfo[dwCtr].pADsValues[0].Integer;
                }
            }
            else if (!_wcsicmp(pszAttrNames[1], pszTmpStr)) {
                //
                // Found rIDPreviousAllocationPool.
                //
                if ((pAttrInfo[dwCtr].dwNumValues == 1)
                    && (pAttrInfo[dwCtr].dwADsType == ADSTYPE_LARGE_INTEGER)) {
                    ridPrevAllocPool = (ULONGLONG)
                        pAttrInfo[dwCtr].pADsValues[0].LargeInteger.QuadPart;
                }
            }
            else if (!_wcsicmp(pszAttrNames[2], pszTmpStr)) {
                //
                // Found rIDAllocationPool.
                //
                if ((pAttrInfo[dwCtr].dwNumValues == 1)
                    && (pAttrInfo[dwCtr].dwADsType == ADSTYPE_LARGE_INTEGER)) {
                    ridAllocPool = (ULONGLONG)
                        pAttrInfo[dwCtr].pADsValues[0].LargeInteger.QuadPart;

                }
            }

        }
    }

    if (ridAllocPool != ridPrevAllocPool) {
        //
        // New pool has not been allocated.
        //
        *pfNextRidAvailable = TRUE;
    }

    Hvalue = Lvalue = ridPrevAllocPool;

    Lvalue<<=32;
    Lvalue>>=32;

    Hvalue>>=32;

    dwSize = (DWORD) (Hvalue-Lvalue);

    if (dwSize != 0) {
        *pdwPercentRidAvailable 
            = (DWORD)(100-((dwNextRID-Lvalue)*100/dwSize));
    }

cleanup:

    if (pszCompObjName) {
        delete pszCompObjName;
    }

    if (pAttrInfo) {
        FreeADsMem(pAttrInfo);
    }

    return hr;
}

/***
    This routine gets the statistics for the replication queue
    on the DC and sets then on the DomainController object.
***/
HRESULT
CRpcReplProv::GetAndUpdateQueueStatistics(
    IN IWbemClassObject* pIndicateItem
    )
{
    HRESULT hr = E_NOTIMPL;
    CComVariant svar;
    CComPtr<IDirectoryObject> spRootDSE;
    CComBSTR sbstrPath;
    LPWSTR pszAttrs[1] = { L"msDS-ReplQueueStatistics;binary"};
    DWORD dwSize = 0;
    DWORD dwErr = 0;
    LPWSTR pszName = NULL;
    PADS_ATTR_INFO pAttrInfo = NULL;
    DS_REPL_QUEUE_STATISTICSW dsReplStat;
    BOOL fFoundStats = FALSE;

    GetComputerNameExW(
        ComputerNameDnsFullyQualified,
        NULL,
        &dwSize
        );

    if (dwSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    pszName = new WCHAR[dwSize];

    if (!pszName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    dwErr = GetComputerNameExW(
                ComputerNameDnsFullyQualified,
                pszName,
                &dwSize
                );
    if (!dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // The path has to be GC://CompName:389
    // as then we will get back an IADs ptr that we can call
    // GetInfoEx on to retrieve the replication queue stats.
    // LDAP://CompName will go the default NC and going to 
    // LDAP://CompName/RootDSE will not help as RootDSE does
    // not support the GetInfoEx method.
    //
    sbstrPath = L"GC://";
    sbstrPath += pszName;
    sbstrPath += L":389";

    hr = ADsOpenObject(
             sbstrPath,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectoryObject,
              OUT (void **)&spRootDSE
             );
    BAIL_ON_FAILURE(hr);

    ASSERT(spRootDSE != NULL);

    hr = spRootDSE->GetObjectAttributes(
             pszAttrs,
             1,
             &pAttrInfo,
             &dwSize
             );
    BAIL_ON_FAILURE(hr);

    if (!dwSize || !pAttrInfo) {
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    for (DWORD dwCtr = 0; dwCtr < dwSize; dwCtr++) {
        if (pAttrInfo[dwCtr].pszAttrName
            && !_wcsicmp(
                    pszAttrs[0],
                    pAttrInfo[dwCtr].pszAttrName
                    )
            ) {
            //
            // Found the attribute, verify type and copy to struct.
            //
            if ((pAttrInfo[dwCtr].dwNumValues == 1)
                && ((pAttrInfo[dwCtr].dwADsType == ADSTYPE_PROV_SPECIFIC)
                   || (pAttrInfo[dwCtr].dwADsType == ADSTYPE_OCTET_STRING))
                && (pAttrInfo[dwCtr].pADsValues[0].OctetString.dwLength 
                     == sizeof(DS_REPL_QUEUE_STATISTICSW))
                ) {
                //
                // This has to be the right data !
                //
                memcpy(
                    &dsReplStat, 
                    pAttrInfo[dwCtr].pADsValues[0].OctetString.lpValue,
                    sizeof(DS_REPL_QUEUE_STATISTICSW)
                    );
                fFoundStats = TRUE;
            } 
        } // does attribute match
    } // for - going through all the attributes

    if (!fFoundStats) {
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    //
    // Now we finally get to put the data into the object.
    //
    hr = PutFILETIMEAttribute(
            pIndicateItem,
            L"TimeOfOldestReplSync",
            dsReplStat.ftimeOldestSync
            );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
            pIndicateItem,
            L"TimeOfOldestReplAdd",
            dsReplStat.ftimeOldestAdd
            );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
            pIndicateItem,
            L"TimeOfOldestReplDel",
            dsReplStat.ftimeOldestDel
            );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
             pIndicateItem,
             L"TimeOfOldestReplMod",
             dsReplStat.ftimeOldestMod
             );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
             pIndicateItem,
             L"TimeOfOldestReplUpdRefs",
             dsReplStat.ftimeOldestUpdRefs
             );
    BAIL_ON_FAILURE(hr);

cleanup:   

    if (pszName) {
        delete pszName;
    }

    if (pAttrInfo) {
        FreeADsMem(pAttrInfo);
    }

    return hr;
}
/**************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dswmi\replprov\rpcreplprov.h ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    RpcReplProv.h: Definition of the RpcReplProv class
    

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000


Revision History:


--*/


#if !defined(AFX_RPCREPLPROV_H__46D0A58E_207D_4584_BBB4_A357CEB3A51C__INCLUDED_)
#define AFX_RPCREPLPROV_H__46D0A58E_207D_4584_BBB4_A357CEB3A51C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "stdafx.h"
#include "resource.h"       // main symbols

typedef DWORD (*DsBindWithSpnExWrapper)(
                        IN LPCWSTR DomainControllerName OPTIONAL,
                        IN LPCWSTR DnsDomainNamee OPTIONAL,
                        IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity OPTIONAL,
                        IN LPCWSTR ServicePrincipalName OPTIONAL,
                        IN DWORD BindFlags,
                        HANDLE  *phDS);

/////////////////////////////////////////////////////////////////////////////
// RpcReplProv

class CRpcReplProv : 
    public IWbemProviderInit,
    public IWbemServices,
    public CComObjectRoot,
    public CComCoClass<CRpcReplProv,&CLSID_RpcReplProv>
{
public:
    CRpcReplProv();
    ~CRpcReplProv();
    
BEGIN_COM_MAP(CRpcReplProv)
    COM_INTERFACE_ENTRY(IWbemProviderInit)
    COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(RpcReplProv) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_RpcReplProv)

// IWbemProviderInit

    STDMETHOD(Initialize)(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink
         );

// IWbemServices

    
    //Implemented...
    STDMETHOD(CreateInstanceEnumAsync)( 
        IN const BSTR bstrClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);
    
    STDMETHOD(GetObjectAsync)( 
        IN const BSTR bstrObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);

    
     STDMETHOD(ExecMethodAsync)( 
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN IWbemObjectSink *pResponseHandler);
    
    
    //Not Implemented...
    
    STDMETHOD(CreateInstanceEnum)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
    { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(GetObject)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemClassObject **ppObject,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    

    STDMETHOD(OpenNamespace)( 
        IN const BSTR strNamespace,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemServices **ppWorkingNamespace,
        IN OUT IWbemCallResult **ppResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CancelAsyncCall)( 
        IN IWbemObjectSink *pSink)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(QueryObjectSink)( 
        IN long lFlags,
        OUT IWbemObjectSink **ppResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    
    STDMETHOD(PutClass)( 
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutClassAsync)( 
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteClass)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
            
    STDMETHOD(DeleteClassAsync)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateClassEnum)( 
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateClassEnumAsync)( 
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutInstance)( 
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutInstanceAsync)( 
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteInstance)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteInstanceAsync)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecQuery)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecQueryAsync)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecMethod)( 
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN OUT IWbemClassObject **ppOutParams,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
        
    STDMETHOD(ExecNotificationQuery)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

private:

    #ifdef EMBEDDED_CODE_SUPPORT
    HRESULT CreatePendingOps(
        OUT SAFEARRAY** ppArray
        );
    
    HRESULT CreateCursors(
        IN  BSTR bstrNamingContext,
        OUT SAFEARRAY** ppArray
        );
    #endif
        
    HRESULT CreateFlatListCursors(
        IN IWbemObjectSink *pResponseHandler
        );

    HRESULT CreateCursorHelper(
        IN  BSTR  bstrNamingContext,
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        );
    
    HRESULT GetCursor(
        IN  BSTR  bstrNamingContext,
        IN  BSTR  bstrSrcDsanvocationUUID,
        OUT IWbemClassObject** ppIndicateItem
        );


    HRESULT GetPendingOps(
        IN LONG lSerialNumber,              
        OUT IWbemClassObject** ppIndicateItem
        );
    
    HRESULT CreateFlatListPendingOps(
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        );

        //bGetFullReplica == TRUE -> function returns the full replica NC's
    //bGetFullReplica == FALSE -> function returns the full replica NC's
    HRESULT CreateNamingContext(
        IN BOOL bGetFullReplica,                
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        );
    
    HRESULT GetNamingContext(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        );
    
    HRESULT GetDomainController(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        );
    
    HRESULT CreateDomainController(
        IN IWbemClassObject** ppIndicateItem
        );


    HRESULT PutAttributesDC(
        IN IWbemClassObject*    pIndicateItem,
        IN IADsPathname*        pPathCracker,
        IN IADs*                pIADsDSA,
        IN BSTR                 bstrDN,
        IN BSTR                 bstrDefaultNC
        );
    
    HRESULT GetDNSRegistrationStatus(
    	OUT BOOL* pfool
    	);

    HRESULT PutUUIDAttribute(
    IN IWbemClassObject* ipNewInst,
    IN LPCWSTR           pstrAttributeName,
    IN UUID&             refuuid);

    HRESULT EnumAndIndicateReplicaSourcePartner(
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrKeyValue = NULL );

    HRESULT EnumAndIndicateWorker(
        IN HANDLE hDS,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrKeyValue = NULL,
        IN const BSTR bstrDnsDomainName = NULL );

    HRESULT BuildListStatus(
        IN HANDLE hDS,
        OUT DS_REPL_NEIGHBORSW** ppneighborsstruct);

    HRESULT BuildIndicateArrayStatus(
        IN  DS_REPL_NEIGHBORSW*  pneighborstruct,
        IN  const BSTR          bstrKeyValue,
        OUT IWbemClassObject*** ppaIndicateItems,
        OUT DWORD*              pcIndicateItems);

    void ReleaseIndicateArray(
        IWbemClassObject**  paIndicateItems,
        DWORD               cIndicateItems,
        bool                fReleaseArray = true);

    HRESULT PutAttributesStatus(
        IWbemClassObject**  pipNewInst,
        const BSTR          bstrKeyValue,
        DS_REPL_NEIGHBORW*   pneighbor);

    HRESULT PutBooleanAttributes(
    IWbemClassObject* ipNewInst,
    UINT              cNumAttributes,
    LPCWSTR*          aAttributeNames,
    DWORD*            aBitmasks,
    DWORD             dwValue);
    
    HRESULT PutFILETIMEAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    FILETIME&         reffiletime);
    
    HRESULT PutLONGLONGAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    LONGLONG          longlong);

    HRESULT ExtractDomainName(
    LPCWSTR pszNamingContext,
    BSTR*   pbstrDomainName );

    
    //Method helper functions...    
    HRESULT ExecuteKCC(
        IWbemClassObject* pInstance,
        DWORD dwTaskId,
        DWORD dwFlags
        );

    HRESULT ProvDSReplicaSync(
        BSTR bstrFilter,
        ULONG dwOptions
        );

    HRESULT CheckIfDomainController();

    HRESULT ConvertBinaryGUIDtoUUIDString(
        IN  VARIANT vObjGuid,
        OUT LPWSTR * ppszStrGuid
        );
    HRESULT GetDnsRegistration(
        OUT BOOL *pfBool
        );

    HRESULT GetAdvertisingToLocator(
        OUT BOOL *pfBool
        );

    HRESULT GetSysVolReady(
        OUT BOOL *pfBool
        );

    HRESULT GetRidStatus(
        IN  LPWSTR pszDefaultNamingContext,
        OUT PBOOL  pfNextRidAvailable,
        OUT PDWORD  pdwPercentRidAvailable
        );

    HRESULT GetAndUpdateQueueStatistics(
        IN IWbemClassObject*    pIndicateItem
        );
    
    CComPtr<IWbemServices>      m_sipNamespace;
    CComPtr<IWbemClassObject>   m_sipClassDefReplNeighbor;
    CComPtr<IWbemClassObject>   m_sipClassDefDomainController;
    CComPtr<IWbemClassObject>   m_sipClassDefNamingContext;
    CComPtr<IWbemClassObject>   m_sipClassDefPendingOps;
    CComPtr<IWbemClassObject>   m_sipClassDefCursor;

    HINSTANCE _hNetApi32;
    DsBindWithSpnExWrapper _pDsBindWithSpnExW;
 
};

#endif 
// !defined(AFX_RPCREPLPROV_H__46D0A58E_207D_4584_BBB4_A357CEB3A51C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dswmi\replprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dswmi\replprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__987EF1F3_2F82_469E_889E_316F39649396__INCLUDED_)
#define AFX_STDAFX_H__987EF1F3_2F82_469E_889E_316F39649396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <wbemprov.h>
#include <stdio.h>
#include "repmsg.h"

//added
#include <ntdsapi.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <ntdsadef.h>
#include <iads.h> // IADsPathname
#include <adshlp.h> // ADSI helper functions
#include <wchar.h>
#include <adserr.h>

#define SECURITY_WIN32 1
#include <sspi.h>
#include <secext.h>

//MACROS!
#if DBG == 1 
#define ASSERT(f) if (!(f)) {_ASSERTE(false);}
#else
#define ASSERT(f) if (false && !(f)) {_ASSERTE(false);}
#endif
#define BAD_IN_STRING_PTR(p) (NULL == p || IsBadStringPtrW(p,0))
#define BAD_IN_STRING_PTR_OPTIONAL(p) (NULL != p && IsBadStringPtrW(p,0))
#define BAD_IN_READ_PTR(p,size) (NULL == p || IsBadReadPtr(p,size))
#define BAD_IN_STRUCT_PTR(p,s) BAD_IN_READ_PTR(p,sizeof(s))
#define BAD_IN_MULTISTRUCT_PTR(p,s,n) BAD_IN_READ_PTR(p,n*sizeof(s))
#define ASSERT_AND_RETURN {ASSERT(false); return WBEM_E_INVALID_PARAMETER;}
#define ASSERT_AND_BREAK {ASSERT(false); break;}
#define BREAK_ON_FAIL if (FAILED(hr)) ASSERT_AND_BREAK;
#define WBEM_VALIDATE_READ_PTR(p,size) \
            if (BAD_IN_READ_PTR(p,size)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRUCT_PTR(p,s) \
            WBEM_VALIDATE_READ_PTR(p,sizeof(s));
#define WBEM_VALIDATE_IN_MULTISTRUCT_PTR(p,s,n) \
            WBEM_VALIDATE_READ_PTR(p,n*sizeof(s));
#define WBEM_VALIDATE_OUT_STRUCT_PTR(p,s) \
            if (NULL == p || IsBadWritePtr(p,sizeof(s))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_OUT_PTRPTR(p) \
            if (NULL == p || IsBadWritePtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_INTF_PTR(p) \
            if (NULL == p || IsBadReadPtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR(p) \
            if (BAD_IN_STRING_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(p) \
            if (BAD_IN_STRING_PTR_OPTIONAL(p)) ASSERT_AND_RETURN;
#define BAIL_ON_FAILURE(hr) if (FAILED((hr))) goto cleanup;



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__987EF1F3_2F82_469E_889E_316F39649396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\fixguids\main.cxx ===
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <stdio.h>
#include <atlbase.h>
#include <objbase.h>
#include <activeds.h>
#include <winnt.h>


//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ 
// Main process for this utility.
// 
// 
void
__cdecl wmain(
    int     cArgs,
    LPWSTR  *pArgs
    )
    {
    HRESULT 			hr = CoInitialize(NULL);
    CLSID 				guidObject;
	WCHAR 				wszObject[2000];
    IDirectoryObject	*pDirObject=NULL;
    DWORD				dwReturn = 0;
    ADSVALUE			snValue;
    ADS_OCTET_STRING	octString = { sizeof(guidObject), (unsigned char *)&guidObject };
    ADS_ATTR_INFO		attrInfo[] = { { L"objectGuid", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, &snValue, 1} };

    ADS_ATTR_INFO		*pAttrInfo=NULL;
    DWORD				dwAttrs = sizeof(attrInfo)/sizeof(ADS_ATTR_INFO); 
	LPWSTR				pAttrNames[]={L"objectGuid" };
	DWORD				dwNumAttr=sizeof(pAttrNames)/sizeof(LPWSTR);


	
    if ( cArgs < 3 ) 
    {
		goto Usage;
    }

    // verify given GUID is correct length
    //
    if( ( wcslen( pArgs[1] ) != 32 ) )
    {
    	printf("Incorrect GUID %S.\n", pArgs[1] );
        goto CleanUp;
    }

    //	convert to string GUID to binary GUID
    //
    unsigned char bT = 0;
    unsigned char *pbT = (unsigned char *)&guidObject;
    for ( int iwchT = 0; iwchT < 32; iwchT++ )
    {
		switch ( pArgs[1][iwchT] )
        {
        case '0':
        	bT += 0;
            break;
        case '1':
        	bT += 1;
        	break;
        case '2':
         	bT += 2;
            break;
        case '3':
         	bT += 3;
            break;
        case '4':
        	bT += 4;
 			break;
        case '5':
        	bT += 5;
			break;
        case '6':
        	bT += 6;
             break;
        case '7':
         	bT += 7;
            break;
        case '8':
        	bT += 8;
             break;
        case '9':
         	bT += 9;
            break;
        case 'A':
        case 'a':
         	bT += 10;
            break;
        case 'B':
        case 'b':
         	bT += 11;
			break;
        case 'C':
        case 'c':
        	bT += 12;
			break;
        case 'D':
        case 'd':
           	bT += 13;
			break;
        case 'E':
        case 'e':
         	bT += 14;
			break;
        case 'F':
        case 'f':
        	bT += 15;
			break;
        default:
			printf("Error: guid string %s is not valid.\n\n", pArgs[1] );
            goto CleanUp;
            break;
            }
        
	    if ( ( iwchT % 2 ) == 0 )
	    {
	        bT<<=4;
		}
	    else
	    {
	    	*pbT = bT;
	    	pbT++;
	    	bT = 0;
	    }
    }


	//	make object location string including:
	//		LDAP://
	//		pArgs[3] provided DC name
	//		/
	//		pArgs[2] provided DN
	//
	wcscpy( wszObject, L"");
	wcscat( wszObject, L"LDAP://" );
	if( wcslen( wszObject ) + wcslen(pArgs[3] + 1) >= sizeof(wszObject)/sizeof(WCHAR) )
    {		
    	printf("Input parameter is too long %S.\n", pArgs[3] );
        goto CleanUp;
    }
	wcscat( wszObject, pArgs[3] );
	wcscat( wszObject, L"/" );
	if( wcslen( wszObject ) + wcslen(pArgs[2] ) >= sizeof(wszObject)/sizeof(WCHAR) )
    {		
    	printf("Input parameter is too long %S.\n", pArgs[2] );
        goto CleanUp;
    }
  	wcscat( wszObject, pArgs[2] );

    snValue.dwType=ADSTYPE_OCTET_STRING;
    snValue.OctetString = octString;
   
 	hr = ADsGetObject( wszObject,
		IID_IDirectoryObject, 
		(void**) &pDirObject );
 	if ( !SUCCEEDED(hr) )
    {
        printf("DN (%S) not found in DC(%S).\n", pArgs[2], pArgs[3] );
        goto CleanUp;
    }

	//	check for NULL GUID
	//
 	hr = pDirObject->GetObjectAttributes(
 		pAttrNames, 
		dwNumAttr, 
		&pAttrInfo, 
		&dwReturn );
	if ( SUCCEEDED(hr) )
		{
		if ( dwReturn > 0 )
		{
		if ( ADSTYPE_OCTET_STRING != pAttrInfo[0].dwADsType )
			{
				printf( "Invalid ADsType for GUID: %d\n", pAttrInfo[0].dwADsType );
				goto CleanUp;
			}
//		if ( pAttrInfo[0].pADsValues[0].OctetString.dwLength > 0 )
			{
				printf("Object %S already has a non-NULL GUID.\n", pArgs[2] );
				goto CleanUp;
			}
		}
		}
	else
		{
		printf("Could not confirm absence of GUID on object.\n");
		goto CleanUp;
		}


	//	set GUID value
	//
	hr=pDirObject->SetObjectAttributes( attrInfo, dwAttrs, &dwReturn );
	if ( SUCCEEDED(hr) )
	{
		printf("Successfully set NULL GUID for object.\n");
	}
	else
	{
		printf("Failed to set GUID(%S) for object(%S) in DC(%S).\n", pArgs[1], pArgs[2], pArgs[3] );
	}

CleanUp:
	if ( !SUCCEEDED(hr) )
		{
		printf("Operation failed with %d.\n", hr );
		}
	
	// clean up
	//
	if ( NULL != pAttrInfo )
	{
		FreeADsMem( pAttrInfo );
	}
		
	if ( NULL != pDirObject )
		{
		pDirObject->Release();
		}
	
	CoUninitialize( );
	return;

Usage:
   printf("Usage: fixguids <32 hex character guid> <DN of object to update> <DC>\n");
   printf("       Note guids should be 32 character hex representation, no back slashes, no braces\n");
   printf("\n");

   	CoUninitialize( );
   	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\attributes.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    attributes.c

Abstract:

    This file contains variables only. These variables are related to attributes
    that are going to be used for synchronization process. Currently there are 17
    attributes and 3 classes which have these attributes.

    If new attributes are needed, add them to the Attributes array and modify
    ATTRIBUTE_NAMES enum to reflect the change.

    If a new class is going to be added and a <class-name>Attributes array defined
    as ATTRIBUTE_NAMES. Place attributes in this array. Add this class to OBJECT_CLASS
    enum. Also add this class'es properties to AllAttributes and AttributeCounts arrays.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:


--*/

#include "attributes.h"

//
// Names of attributes of groups, users, and contacts
//  indexed by ATTRIBUTE_NAMES enumeration type
//
PWSTR Attributes[] = {

        L"C",
        L"Cn",
        L"Company",
        L"Displayname",
        L"Employeeid",
        L"Givenname",
        L"L",
        L"Mail",
        L"Mailnickname",
        L"Msexchhidefromaddresslists",
        L"Name",
        L"Proxyaddresses",
        L"Samaccountname",
        L"Sn",
        L"Legacyexchangedn",
        L"textencodedoraddress",
        L"targetAddress",
    };

//
// User Attributes
//

ATTRIBUTE_NAMES ADUserAttributes[] = {

        C,
        Cn,
        Company,
        DisplayName,
        EmployeeId,
        GivenName,
        L,
        Mail,
        MailNickname,
        MsexchHideFromAddressLists,
        Name,
        ProxyAddresses,
        SamAccountName,
        Sn,
        LegacyExchangeDn,
        TextEncodedOrAddress
    };

//
// Group Attributes
//
ATTRIBUTE_NAMES ADGroupAttributes[] = {

        Cn,
        DisplayName,
        Mail,
        MailNickname,
        SamAccountName,
        MsexchHideFromAddressLists,
        ProxyAddresses,
        TextEncodedOrAddress,
        LegacyExchangeDn
        };

//
// Contact Attributes
//
ATTRIBUTE_NAMES ADContactAttributes[] = {

        Cn,
        DisplayName,
        GivenName,
        LegacyExchangeDn,
        Mail,
        MailNickname,
        ProxyAddresses,
        Sn,
        TextEncodedOrAddress
        };

//
// Attributes stored in an array
//  All outside access is allowed through
//  this variable
//

ATTRIBUTE_NAMES *ADAttributes[] = {
    ADUserAttributes,
    ADGroupAttributes,
    ADContactAttributes
    };

//
// Counts of attributes in each class of object
//

const ULONG ADAttributeCounts[] = {
    sizeof( ADUserAttributes ) / sizeof( ADUserAttributes[0] ),
    sizeof( ADGroupAttributes ) / sizeof( ADGroupAttributes[0] ),
    sizeof( ADContactAttributes ) / sizeof( ADContactAttributes[0] )
    };

PWSTR ADClassNames[] = {
    L"user",
    L"group",
    L"contact"
    };


ATTRIBUTE_NAMES MVPersonAttributes[] = {

        Cn,
        Company,
        DisplayName,
        EmployeeId,
        GivenName,
        L,
        LegacyExchangeDn,
        Mail,
        MailNickname,
        ProxyAddresses,
        Sn,
        TargetAddress,
        TextEncodedOrAddress
    };

//
// Group Attributes
//
ATTRIBUTE_NAMES MVGroupAttributes[] = {

        Cn,
        DisplayName,
        Mail,
        MailNickname,
        ProxyAddresses,
        TargetAddress,
        TextEncodedOrAddress,
        };

//
// Attributes stored in an array
//  All outside access is allowed through
//  this variable
//

ATTRIBUTE_NAMES *MVAttributes[] = {
    MVPersonAttributes,
    MVGroupAttributes,
    };

//
// Counts of attributes in each class of object
//

const ULONG MVAttributeCounts[] = {
    sizeof( MVPersonAttributes ) / sizeof( MVPersonAttributes[0] ),
    sizeof( MVGroupAttributes ) / sizeof( MVGroupAttributes[0] ),
    };

PWSTR MVClassNames[] = {
    L"person",
    L"group",
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\attributes.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    attributes.h

Abstract:

    This file is for encapsulation of the attributes that are going
    to be used for synchronization.

    ATTRIBUTE_NAMES enum has all the attributes related to GAL Sync. These
    also index Attributes array for the ldap representation of the attribute.

    OBJECT_CLASS contains the object classes that are relevent in GAL Sync.

    See attributes.c for more details.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include <windows.h>

//
// This enumeration type is used to index the Attributes array
//
typedef enum {
    C,
    Cn,
    Company,
    DisplayName,
    EmployeeId,
    GivenName,
    L,
    Mail,
    MailNickname,
    MsexchHideFromAddressLists,
    Name,
    ProxyAddresses,
    SamAccountName,
    Sn,
    LegacyExchangeDn,
    TextEncodedOrAddress,
    TargetAddress,
    DummyAttribute
} ATTRIBUTE_NAMES;

//
// Objects classes in AD supported for synchronization
//
typedef enum {
    ADUser,
    ADGroup,
    ADContact,
    ADDummyClass
} AD_OBJECT_CLASS;

//
// Objects classes in MV supported for synchronization
//
typedef enum {
    MVPerson,
    MVContact,
    MVDummyClass
} MV_OBJECT_CLASS;

//
// Global variables available to outside
//
extern PWSTR Attributes[];

extern ATTRIBUTE_NAMES *ADAttributes[];
extern const ULONG ADAttributeCounts[];
extern PWSTR ADClassNames[];

extern ATTRIBUTE_NAMES *MVAttributes[];
extern const ULONG MVAttributeCounts[];
extern PWSTR MVClassNames[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\findguidless\main.cxx ===
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <stdio.h>
#include <atlbase.h>
#include <objbase.h>
#include <activeds.h>
#include <winnt.h>


//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ 
// Main process for this utility.
// 
// 
void
__cdecl wmain(
    int     cArgs,
    LPWSTR  *pArgs
    )
    {
    HRESULT 				hr = CoInitialize(NULL);
	WCHAR 					wszDC[2000];
    DWORD					dwReturn = 0;
	IDirectorySearch		*pDSSearch = NULL;
	ADS_SEARCH_HANDLE		hSearch;
	LPWSTR 					pszAttr[] = { L"distinguishedname" };
	DWORD					dwAttrNameSize = sizeof(pszAttr)/sizeof(LPWSTR);
	LPWSTR					szUsername = NULL; // Username
	LPWSTR					szPassword = NULL; // Password
 	LPWSTR					pszColumn;
 	ADS_SEARCH_COLUMN		colT;  // COL for iterations
	ADS_SEARCHPREF_INFO		prefInfo[1];
	GUID 					guidT;
	int						iwchT;
	unsigned char			bT;
	
    if ( cArgs != 2 ) 
    {
		goto Usage;
    }

	//	make DC string including:
	//		LDAP://
	//		pArgs[3] provided DC name
	//		/
	//		pArgs[2] provided DN
	//
	wcscpy( wszDC, L"");
	wcscat( wszDC, L"LDAP://" );
	if( wcslen( wszDC ) + wcslen(pArgs[1] ) >= sizeof(wszDC)/sizeof(WCHAR) )
    {		
    	printf("Input parameter is too long %S.\n", pArgs[1] );
        goto CleanUp;
    }
	wcscat( wszDC, pArgs[1] );

 	//	Open a connection with server.
	//
	hr = ADsOpenObject( wszDC, 
		szUsername,
		szPassword,
		ADS_SECURE_AUTHENTICATION,
		IID_IDirectorySearch,
		(void **)&pDSSearch );
	if ( !SUCCEEDED(hr) )
		{
		goto CleanUp;
		}
	
	prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
	prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
	prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;
	hr = pDSSearch->SetSearchPreference( prefInfo, sizeof(prefInfo)/sizeof(prefInfo[0]) );
	if ( !SUCCEEDED(hr) )
		{
		goto CleanUp;
		}

	//	Search for all objects without an objectguid
	//
	hr = pDSSearch->ExecuteSearch( L"(!(objectguid<=\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF\\FF))",
		pszAttr,
		dwAttrNameSize,
		&hSearch );
	if ( !SUCCEEDED(hr) )
		{
		goto CleanUp;
		}

	while( pDSSearch->GetNextRow( hSearch) != S_ADS_NOMORE_ROWS )
    {
        hr = pDSSearch->GetColumn( hSearch, L"distinguishedname", &colT );
        if ( SUCCEEDED(hr) )
       	{
       		if ( colT.dwADsType == ADSTYPE_DN_STRING && colT.pADsValues )
            {
            	//	allocate and output GUID
            	//
            	UuidCreate( &guidT );
            	for ( iwchT = 0; iwchT < 32; iwchT++ )
            		{
					bT = ((unsigned char *)&guidT)[iwchT/2];
					if ( 1 == ( iwchT % 2 ) )
						{
						bT &=0x0f;
						}
					else
						{
						bT>>=4;
						}
					switch ( bT )
					{
						case 0:
							wprintf( L"0" );
							break;
						case 1:
							wprintf( L"1" );
							break;
						case 2:
							wprintf( L"2" );
							break;
						case 3: 
							wprintf( L"3" );
							break;
						case 4: 
							wprintf( L"4" );
							break;
						case 5: 
							wprintf( L"5" );
							break;
						case 6: 
							wprintf( L"6" );
							break;
						case 7:
							wprintf( L"7" );
							break;
						case 8:
							wprintf( L"8" );
							break;
						case 9:
							wprintf( L"9" );
							break;
						case 10:
							wprintf( L"a" );
							break;
						case 11: 
							wprintf( L"b" );
							break;
						case 12: 
							wprintf( L"c" );
							break;
						case 13: 
							wprintf( L"d" );
							break;
						case 14: 
							wprintf( L"e" );
							break;
						default:
							wprintf( L"f" );
							break;	
					}
            	}

            	//	output DN
            	//
                wprintf( L" %s \n", colT.pADsValues->DNString );
            }
			pDSSearch->FreeColumn( &colT );
       	}
    }
    hr = 0;

 CleanUp: 
	// clean up
	//	
	if ( NULL != pDSSearch )
	{
		if ( NULL != hSearch )
		{
			pDSSearch->CloseSearchHandle(hSearch);
			hSearch = NULL;
		}
  		pDSSearch->Release();
  		pDSSearch = NULL;
	}
  
	if ( !SUCCEEDED(hr) )
		{
		printf("Operation failed with %d.\n", hr );
		}
	

	CoUninitialize( );
	return;

Usage:
   printf("Usage: findguidless <name of DC or domain>\n\n");
   printf("    This command will perform a sub-tree search from rootDSE for all objects w/o guids.\n");
   printf("    A GUID will be allocated and output for each object found.  Note, only objects under\n");
   printf("    the FPO container should be fixed with fixoneguid.exe unless directed by a\n");
   printf("    Microsoft representative.\n");
   printf("\n");

   	CoUninitialize( );
   	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\forest.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    forest.c

Abstract:

    This file contains Forest specific functions. Any function that is related to
    forest should be here.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include "Forest.h"
#include "texts.h"
#include <Winber.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <shlwapi.h>
#include <ntdsapi.h>
#include <ntdsadef.h>

BOOLEAN
ConnectToForest(
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function tries to connect to a forest distinguished by the first
    parameter. If the connection is established, the function returns TRUE,
    if for any reason, the connection cannot be established the function
    returns FALSE and writes the reason of the problem to stdout.

Arguments:

    ForestInformation - This variable distinguishes the forest to be
            connected to. The only property that has to be present in this
            struct is the ForestName. Connection property mustn't be
            initiliazed, otherwise it will be overwritten.

Return Values:

    TRUE - connection established and the connection is placed in Connection
            attribute of the ForestInformation. You will need to close the
            connection when you are done.

    FALSE - for some reason the connection cannot be established. The reason
            is outputed to stdout.

--*/
{
    ULONG LdapResult;
    PLDAP Connection;

    Connection = ldap_initW(
                    ForestInformation->ForestName,
                    LDAP_PORT
                    );

    if( Connection == NULL ) {

        LdapResult = LdapGetLastError();
        PRINTLN( ldap_err2stringW( LdapResult ) );
        return FALSE;
    }

    LdapResult = ldap_connect( Connection, NULL );

    if( LdapResult != LDAP_SUCCESS ) {

        PRINTLN( ldap_err2stringW( LdapResult ) );
        LdapResult = ldap_unbind( Connection );
        return FALSE;
    }

    ForestInformation->Connection = Connection;

    return TRUE;
}

BOOLEAN
BindToForest(
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function tries to bind to a forest distinguished by the first
    parameter. The connection must have already been established and
    credentials must be present in the AuthInfo property of the parameter.

Arguments:

    ForestInformation - This variable distinguishes the forest to be bind to
                and provides the credentials for connection. Use BuildAuthInfo
                after placing the credentails before calling this function.
                Connection property of this variable must already be initialized.

Return Values:

    TRUE - bind successful

    FALSE - for some reason the bind was unsuccessfull. The reason is outputed
        to stdout.

--*/
{
    ULONG LdapResult;

    LdapResult = ldap_bind_sW(
                    ForestInformation->Connection,
                    NULL,
                    ( PWCHAR ) &( ForestInformation->AuthInfo ),
                    LDAP_AUTH_NTLM
                    );

    if( LdapResult != LDAP_SUCCESS ) {

        PRINTLN( ldap_err2stringW( LdapResult ) );
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
FindOU(
    IN PLDAP Connection,
    IN PWSTR OU
    )
/*++

Routine Description:

    This function tries to locate an OU using the connection provided. If the
    OU can be located then this function returns TRUE, if not returns FALSE.
    If this function fails but this failure was not due to non-existence of
    the OU, the error is displayed on stdout.

Arguments:

    Connection - LDAP connection object to search the OU

    OU - name of the ou to be located. It must be the DN of the OU
            like cn=x, dc=y, dc=com

Return Values:

    TRUE - OU is successfully located.

    FALSE - for some reason OU cannot be located. If no output is displayed
            on stdout, OU doesn't exist.

--*/
{
    ULONG LdapResult;
    LDAPMessage *Result;
    PWCHAR Attr[] ={ L"cn", NULL };

    LdapResult = ldap_search_sW(
                    Connection,
                    OU,
                    LDAP_SCOPE_BASE,
                    L"objectclass=*",
                    Attr,
                    1,          // try to minimize the return, select types only
                    &Result
                    );

    ldap_msgfree( Result );

    if( LdapResult != LDAP_SUCCESS ) {

        if( LdapResult != LDAP_NO_SUCH_OBJECT ) {

            PRINTLN( ldap_err2stringW( LdapResult ) );
        }
        return FALSE;
    }
    return TRUE;
}

VOID
BuildAuthInfo(
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthInfo
    )
/*++

Routine Description:

    This function is a helper function to modify SEC_WINNT_AUTH_IDENTITY_W
    class after the credentials are placed so that the structure is in a
    consistent state.

Arguments:

    AuthInfo - the credentials are present in this structure.

Return Values:

    VOID

--*/
{
    AuthInfo->UserLength = wcslen( AuthInfo->User );
    AuthInfo->DomainLength = wcslen( AuthInfo->Domain );
    AuthInfo->PasswordLength = wcslen( AuthInfo->Password );
    AuthInfo->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
}

VOID
FreeAuthInformation(
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthInfo
    )
/*++

Routine Description:

    This function frees the memory allocated in AuthInfo variable.

Arguments:

    AuthInfo - the structure to be freed. The structure itself is not freed
        but the properties are freed.

Return Values:

    VOID

--*/
{
    FREE_MEMORY( AuthInfo->User );
    FREE_MEMORY( AuthInfo->Domain );
    SecureZeroMemory( AuthInfo->Password,
        AuthInfo->PasswordLength * sizeof( WCHAR ) );
    SecureZeroMemory( &( AuthInfo->PasswordLength ), sizeof( AuthInfo->PasswordLength ) );
    FREE_MEMORY( AuthInfo->Password );
}

VOID
FreeForestInformationData(
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function frees the forest information in the structure.

Arguments:

    ForestInformation - the structure to be freed. The structure itself is
                        not freed but the properties are freed.

Return Values:

    VOID

--*/
{
    FreeAuthInformation( &( ForestInformation->AuthInfo ) );
    FREE_MEMORY( ForestInformation->ForestName );
    FREE_MEMORY( ForestInformation->MMSSyncedDataOU );
    FREE_MEMORY( ForestInformation->ContactOU );
    FREE_MEMORY( ForestInformation->SMTPMailDomains );

    if( ForestInformation->Connection != NULL ) {

        ldap_unbind( ForestInformation->Connection );
    }
}

BOOLEAN
GetAttributeFrom(
    IN PLDAP Connection,
    IN PWSTR ObjectName,
    IN PWSTR *Attr,
    IN OPTIONAL PWSTR RequiredSubstring,
    OUT OPTIONAL PWSTR *Result
    )
/*++

Routine Description:

    This function searches for an object with the ObjectName using the
    Connection. Then it gets the attributes asked for in the Attr.
    RequiredSubString is an optional parameter to search in the attribute.

Arguments:

    Connection - the search and read will be done using this connection

    ObjectName - the dn of the object who has the attribute

    Attr - Attributes to be searched for. This is an array, last element must
            be null.

    RequiredSubstring - Optional parameter to search for a substring in the
            attribute and put the remaining of the attribute to the Result. If
            not present no substring search will be done.

    Result - Optional parameter to see what is the attribute. If not present
            the function can be used to see if the object has this attribute.

Return Values:

    TRUE - The attributes are found and put into result if present.

    FALSE - Some kind of error occured. Call LdapGetLastError to see if it is
            ldap related. If not, attribute could not be found.

--*/
{
    ULONG LdapResult;
    ULONG IgnoreResult;
    LDAPMessage *ResultMessage;
    BOOLEAN RetVal = FALSE;

    LdapResult = ldap_search_sW(
                    Connection,
                    ObjectName,
                    LDAP_SCOPE_BASE,
                    L"objectclass=*",
                    Attr,
                    0,
                    &ResultMessage
                    );

    if( LdapResult == LDAP_SUCCESS ) {

        LDAPMessage *Entry;

        Entry = ldap_first_entry(
                    Connection,
                    ResultMessage
                    );

        while( Entry != NULL && RetVal == FALSE ) {

            PWSTR *Value;

            Value = ldap_get_valuesW(
                        Connection,
                        Entry,
                        Attr[0]
                        );

            if( Value != NULL ) {

                ULONG i;

                for( i = 0; Value[i] != NULL; ++i ) {

                    PWSTR CopyFrom;

                    if( !RequiredSubstring ||
                        ( CopyFrom = StrStrIW( Value[i], RequiredSubstring ) ) ) {

                        if( Result ) {

                            if( RequiredSubstring ) {

                                CopyFrom += wcslen( RequiredSubstring );

                            } else {

                                CopyFrom = Value[i];
                            }

                            DUPLICATE_STRING( *Result, CopyFrom );
                        }

                        RetVal = TRUE;
                        break;
                    }
                }

                ldap_value_freeW( Value );
            }

            Entry = ldap_next_entry(
                        Connection,
                        Entry
                        );
        }
    }

    LdapResult = LdapGetLastError();

    if( LdapResult != LDAP_SUCCESS ) {

        PRINTLN( ldap_err2stringW( LdapResult ) );
    }

    IgnoreResult = ldap_msgfree( ResultMessage );

    return RetVal;
}

BOOLEAN
WriteAccessGrantedToOU(
    IN PLDAP Connection,
    IN PWSTR OU
    )
/*++

Routine Description:

    This function finds out if the caller has write access to the OU. To be
    more specific, in this case, the function looks for if "container",
    "contact" and "group" classes can be created under this OU.

Arguments:

    Connection - the search and read will be done using this connection

    OU - the dn of the object (container) for which we check the access

Return Values:

    TRUE - Access granted

    FALSE - Access denied

--*/
{
    PWSTR Attr[] ={ L"allowedChildClassesEffective", NULL };

    //
    // We can increase performance here!
    //
    return GetAttributeFrom( Connection, OU, Attr, L"container", NULL ) &&
           GetAttributeFrom( Connection, OU, Attr, L"contact", NULL ) &&
           GetAttributeFrom( Connection, OU, Attr, L"group", NULL );

}

BOOLEAN
ReadFromUserContainer(
    IN PLDAP Connection
    )
/*++

Routine Description:

    This function checks if the caller can read from User Container.

Arguments:

    Connection - the search and read will be done using this connection

Return Values:

    TRUE - the caller can read from users container.

    FALSE - Some kind of error occured. Call LdapGetLastError to see if it is
            ldap related. If not, users container could not be read.

--*/
{
    PWSTR Attr1[] = { L"defaultNamingContext", NULL };
    PWSTR Attr2[] = { L"wellKnownObjects", NULL };
    BOOLEAN RetVal = FALSE;
    PWSTR UsersOU;
    PWSTR RootDomainNC;

    RetVal = GetAttributeFrom(
                Connection,
                NULL,
                Attr1,
                NULL,
                &RootDomainNC
                );

    if( !RetVal ) {

        return FALSE;
    }

    RetVal = GetAttributeFrom(
                Connection,
                RootDomainNC,
                Attr2,
                GUID_USERS_CONTAINER_W,
                &UsersOU
                );

    FREE_MEMORY( RootDomainNC );

    if( !RetVal ) {

        return RetVal;
    }

    RetVal = FindOU( Connection, UsersOU + 1 );

    FREE_MEMORY( UsersOU );

    return RetVal;
}

VOID
ReadPartitionInformation(
    IN PLDAP Connection,
    OUT PULONG nPartitions,
    OUT PPARTITION_INFORMATION *PInfo
    )
/*++

Routine Description:

    This function reads partition information from the connection

Arguments:

    Connection - connection to the forest

    nPartitions - number of partitions found in the forest

    PInfo - nPartitions size array containing information about the
        partitions

Return Values:

    VOID

--*/
{
    PWSTR Attr1[] = { L"configurationNamingContext", NULL };
    PWSTR Attr2[] = { L"dnsRoot", L"systemFlags", L"nCName", L"objectGUID", NULL };
    BOOLEAN RetVal;
    PWSTR ConfigNC;
    ULONG LdapResult;
    ULONG IgnoreResult;
    LDAPMessage *ResultMessage;
    PPARTITION_INFORMATION PartitionInfo = NULL;
    ULONG nEntries = 0;
    WCHAR PartitionsDN[0xFF] = L"CN=Partitions,";

    *nPartitions = 0;
    RetVal = GetAttributeFrom(
                Connection,
                NULL,
                Attr1,
                NULL,
                &ConfigNC
                );

    if( !RetVal ) {
        exit(1);
    }

    wcscat( PartitionsDN, ConfigNC );

    FREE_MEMORY( ConfigNC );

    LdapResult = ldap_search_sW(
                    Connection,
                    PartitionsDN,
                    LDAP_SCOPE_ONELEVEL,
                    L"objectclass=crossRef",
                    Attr2,
                    0,
                    &ResultMessage
                    );


    if( LdapResult == LDAP_SUCCESS ) {

        LDAPMessage *Entry;
        ULONG i;

        Entry = ldap_first_entry(
                    Connection,
                    ResultMessage
                    );

        while( Entry != NULL ) {

            nEntries++;

            Entry = ldap_next_entry(
                        Connection,
                        Entry
                        );
        }

        ALLOCATE_MEMORY( PartitionInfo, sizeof( PARTITION_INFORMATION ) * nEntries );
        ZeroMemory( PartitionInfo, sizeof( PARTITION_INFORMATION ) * nEntries );

        Entry = ldap_first_entry(
                    Connection,
                    ResultMessage
                    );

        for( i = 0; i < nEntries; ++i ) {

            ULONG j;

            for( j = 0; j < 3; ++j ) {

                PWSTR *Value;
                struct berval ** ObjectGUID;

                Value = ldap_get_valuesW(
                            Connection,
                            Entry,
                            Attr2[j]
                            );

                if( Value != NULL ) {

                    switch( j ) {

                        case 0:
                            DUPLICATE_STRING( PartitionInfo[i].DnsName, Value[0] );
                            break;

                        case 1: {
                            ULONG Flag = _wtoi( Value[0] );
                            PartitionInfo[i].isDomain = !!( Flag & FLAG_CR_NTDS_DOMAIN );
                            break;
                            }

                        case 2:
                            DUPLICATE_STRING( PartitionInfo[i].DN, Value[0] );
                            break;

                    }

                    ldap_value_freeW( Value );
                }

                ObjectGUID = ldap_get_values_lenW(
                                Connection,
                                Entry,
                                Attr2[3]
                                );
                CopyMemory( &( PartitionInfo[i].GUID ), ObjectGUID[0]->bv_val, sizeof( UUID ) );

                ldap_value_free_len( ObjectGUID );
            }

            Entry = ldap_next_entry(
                        Connection,
                        Entry
                        );
        }
    }

    IgnoreResult = ldap_msgfree( ResultMessage );

    *PInfo = PartitionInfo;
    *nPartitions = nEntries;
}

VOID
FreePartitionInformation(
    IN ULONG nPartitions,
    IN PPARTITION_INFORMATION PInfo
    )
/*++

Routine Description:

    This function frees the memory allocated in PInfo array.

Arguments:

    nPartitions - number of elements in PInfo array

    PInfo - is an array of PARTITION_INFORMATION structure to be freed

Return Values:

    VOID

--*/
{
    ULONG i;

    for( i = 0; i < nPartitions; ++i ) {

        FREE_MEMORY( PInfo[i].DN );
        FREE_MEMORY( PInfo[i].DnsName );
    }
    FREE_MEMORY( PInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\galsync.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    GalSync.c

Abstract:

    This file contains the main flow of the GALSync tool. It also includes
    the user interface of the tool.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include "MA.h"
#include <stdlib.h>
#include <wchar.h>

//#define DEFAULT_FOLDER_NAME L""

VOID
GetForestInformation(
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function gets the Forest information from the user. This includes
    forest name, credentials for the forest, the ou in which the synced data
    will be placed.

Arguments:

    ForestInformation - information gathered will be placed in this
        variable.

Return Values:

    VOID

--*/
{

    HANDLE InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    DWORD OriginalMode = 0;
    BOOLEAN ForestNameCollected;
    BOOLEAN CredentialsCollected;
    BOOLEAN MMSSyncedOUCollected;

    ZeroMemory( ForestInformation, sizeof( ForestInformation ) );

    do {

        //
        // Get forest name
        //
        GetInformationFromConsole(
            ForestNameRequest,
            FALSE,   // empty string not allowed
            &( ForestInformation->ForestName )
            );

        ForestNameCollected = ConnectToForest( ForestInformation );

        if( !ForestNameCollected ) {

            FREE_MEMORY( ForestInformation->ForestName );
        }

    } while( !ForestNameCollected );

    do {

        CredentialsCollected = FALSE;

        //
        // Get domain name
        //
        GetInformationFromConsole(
            DomainNameRequest,
            FALSE,   // empty string not allowed
            &( ForestInformation->AuthInfo.Domain )
            );

        //
        // Get MMS account name
        //
        GetInformationFromConsole(
            MMSUserNameRequest,
            FALSE,   // empty string not allowed
            &( ForestInformation->AuthInfo.User )
            );

        //
        // Hide password while being typed in
        //

        GetConsoleMode(InputHandle, &OriginalMode);
        SetConsoleMode(InputHandle,
                       ~ENABLE_ECHO_INPUT & OriginalMode);

        //
        // Get password
        //

        GetInformationFromConsole(
            PasswordRequest,
            TRUE,   // empty string allowed
            &( ForestInformation->AuthInfo.Password )
            );

        SetConsoleMode(InputHandle, OriginalMode);
        PRINT( L"\n" );

        //
        // Build authentication information
        //

        BuildAuthInfo( &( ForestInformation->AuthInfo ) );

        //
        // Try to bind with the authentication information
        //

        if( BindToForest( ForestInformation ) ) {

            //
            // Try to read from user container to see if the account has
            //  enough rights
            //
            CredentialsCollected = ReadFromUserContainer( ForestInformation->Connection );

            if( !CredentialsCollected ) {

                OUTPUT_TEXT( MMSAccountDoesntHaveRights );
            }
        }

        if( CredentialsCollected ) {

            do {

                //
                // Get the DN for MMS Synced Data
                //

                GetInformationFromConsole(
                    MMSSyncedDataOURequest,
                    FALSE,   // empty string not allowed
                    &( ForestInformation->MMSSyncedDataOU )
                    );

                //
                // See if the OU exits
                //

                MMSSyncedOUCollected = FindOU( ForestInformation->Connection, ForestInformation->MMSSyncedDataOU );

                if( MMSSyncedOUCollected ) {

                    MMSSyncedOUCollected = WriteAccessGrantedToOU( ForestInformation->Connection, ForestInformation->MMSSyncedDataOU );

                    if( !MMSSyncedOUCollected ) {

                        OUTPUT_TEXT( MMSAccountDoesntHaveRights );
                        FREE_MEMORY( ForestInformation->MMSSyncedDataOU );
                        ForestInformation->MMSSyncedDataOU = NULL;

                        MMSSyncedOUCollected = TRUE;
                        CredentialsCollected = FALSE;
                    }

                }

                if( !MMSSyncedOUCollected ) {

                    FREE_MEMORY( ForestInformation->MMSSyncedDataOU );
                    ForestInformation->MMSSyncedDataOU = NULL;

                    if( GetAnswerToAYesNoQuestionFromConsole( MMSSyncedDataOUNotFoundQuestion ) ) {

                        return;
                    }
                }

            }while( !MMSSyncedOUCollected );
        }

        if( !CredentialsCollected ) {

            FreeAuthInformation( &( ForestInformation->AuthInfo ) );
        }

    }while( !CredentialsCollected );

}


VOID
GetFileInformation(
    OUT PWSTR *FolderName
    )
/*++

Routine Description:

    This function will get the folder where the XML file for this forest will
    be placed from the user. If the folder doesn't exist, the user will be
    given an option to create the folder or not. If the user doesn't specify
    a valid foldername, he cannot continue

Arguments:

    Foldername - foldername given by the user. must be freed when no longer
        needed

Return Values:

    VOID

--*/
{
    PWSTR Foldername;
    BOOLEAN FoldernameCollected;

    do {
        LONG Result;

        FoldernameCollected = FALSE;

        //
        // Get the folder name for the xml file to be placed in
        //

        GetInformationFromConsole(
            XMLFoldernameRequest,
            FALSE,   // empty string not allowed
            &Foldername
            );

        //
        // Check if the folder exits
        //

        Result = _waccess(
            Foldername,
            0       // existence check
            );

        if( Result == 0 ) {

            FoldernameCollected = TRUE;
        }

        if( !FoldernameCollected ) {

            //
            // Folder doesn't exist
            //

            if( GetAnswerToAYesNoQuestionFromConsole( XMLFolderDoesntExistQuestion ) ) {

                FoldernameCollected = ( BOOLEAN )
                                      CreateDirectoryW(
                                        Foldername,   // directory name
                                        NULL        // SD
                                        );

                if( !FoldernameCollected ) {

                    OUTPUT_TEXT( CannotCreateDirectory );
                }
            }
        }
    } while( !FoldernameCollected );
    *FolderName = Foldername;
}

VOID
GetAttributesToSync(
    IN AD_OBJECT_CLASS Class,
    IN TEXT_INDEX Text1,
    IN TEXT_INDEX Text2,
    OUT BOOLEAN *UnSelectedAttributes
    )
/*++

Routine Description:

    This function gets the attributes to be synced out of this forest. The user
    will be given a bunch of attributes to unselect from. If nothing is entered,
    every attribute will be synced out.

Arguments:

    Class - which class of object attributes are to be synced out

    Text1 - the heading before the attributes are listed.

    Text2 - the question of which attributes are to be selected

    UnSelectedAttributes - a Boolean array to distinguish between unselected and
            selected attributes.

Return Values:

    VOID

--*/
{
    ULONG i;
    PWSTR Output;
    PWSTR pOutput;
    BOOLEAN ValidInput;

    do {

        ValidInput = TRUE;

        //
        // Zero out the unselected attributes
        //

        ZeroMemory( UnSelectedAttributes, sizeof( BOOLEAN ) * ADAttributeCounts[Class] );

        //
        // Display the attributes
        //

        OUTPUT_TEXT( Text1 );

        for( i = 0; i < ADAttributeCounts[Class]; ++i ) {

            fwprintf( OutputStream,  L"%d %s\n", i + 1, Attributes[ ADAttributes[Class][i] ] );
        }

        //
        // Get the attributes to be unselected
        //

        GetInformationFromConsole(
            Text2,
            TRUE,   // empty string allowed
            &Output
            );

        if( Output[0] != 0 ) {

            pOutput = Output;

            //
            // Parse input and unselected the attributes
            //

            do {

                PWSTR Start = pOutput;
                PWSTR Temp;

                //
                // Skip spaces
                //
                while( *Start == L' ' ) {

                    Start++;
                }

                //
                // Find the asterix in the input, the number must be before this
                //
                pOutput = wcschr( Start, L'*' );

                //
                // If there is no asterix then the input is invalid
                //
                if( pOutput == NULL ) {

                    ValidInput = FALSE;
                    break;
                }

                //
                // From the start to the asterix there can only be digits
                //
                Temp = Start;
                while( *Temp >= L'0' && *Temp <= L'9' ) {

                    Temp ++;
                }

                if( Temp != pOutput ) {

                    ValidInput = FALSE;
                    break;
                }

                //
                // Replace asterix by NULL and skip it
                //
                *pOutput = 0;
                pOutput ++;

                //
                // Convert the number
                //
                i = _wtoi( Start );

                //
                // If it is 0 or bigger than number of attributes then
                //  it is invalid
                //
                if( i <= 0 || i > ADAttributeCounts[ Class ] ) {

                    ValidInput = FALSE;
                    break;
                }

                //
                // Unselect the attribute
                //
                UnSelectedAttributes[i - 1] = TRUE;

                //
                // Skip spaces
                //

                while( *pOutput == L' ' ) {

                    pOutput++;
                }

                //
                // If there is a comma skip that too.
                //
                if( *pOutput == L',' ) {

                    pOutput++;

                } else {

                    //
                    // If there is no comma then we must have reached the
                    //  end of the string. If not then the input is invalid
                    //
                    if( *pOutput != 0 ) {

                        ValidInput = FALSE;
                    }
                    break;
                }
            }while( *pOutput != 0 );

            FREE_MEMORY( Output );

            if( !ValidInput ) {

                OUTPUT_TEXT( InvalidInput );
            }
        }
    }while( !ValidInput );
}

VOID
GetContactOU(
    IN PLDAP Connection,
    OUT PWSTR *ContactOU
    )
/*++

Routine Description:

    This function gets the contact ou from the user. Contact ou is the ou
    where the contacts are to be placed under, if the admin wants the contacts to
    be exported. If such an ou doesn't exist the user is reasked.

Arguments:

    Connection - Connection to the forest where the contact ou must reside

    ContactOU - will receive the OU's dn


Return Values:

    VOID

--*/
{
    BOOLEAN ContactOUCollected;

    //
    // Ask if the contacts are going to be exported
    //

    if( GetAnswerToAYesNoQuestionFromConsole( ContactsToBeExportedQuestion ) ) {

        do {

            //
            // Get the OU where the contacts reside
            //

            GetOUFromConsole(
                ContactsOULocationRequest,
                ContactOU
                );

            //
            // Find if the OU exists
            //

            ContactOUCollected = FindOU( Connection, *ContactOU );

            if( !ContactOUCollected ) {

                FREE_MEMORY( *ContactOU );
                *ContactOU = NULL;

                ContactOUCollected = GetAnswerToAYesNoQuestionFromConsole( ContactsOUNotFoundQuestion );
            }

        } while( !ContactOUCollected );

    } else {

        *ContactOU = NULL;
    }
}

VOID
GetContactInformation(
    IN PLDAP Connection,
    OUT PWSTR *ContactOU,
    OUT BOOLEAN *UnSelectedAttributes
    )
/*++

Routine Description:

    This function gets the contact ou from the user. Contact ou is the ou
    where the contacts are to be placed under, if the admin wants the contacts to
    be exported. If such an ou doesn't exist the user is reasked. Plus, the user
    is given the option to select which attributes of contact class are to be synced.

Arguments:

    Connection - Connection to the forest where the contact ou must reside

    ContactOU - will receive the OU's dn

    UnSelectedAttributes - a Boolean array to distinguish between unselected and
            selected attributes.

Return Values:

    VOID

--*/
{
    //
    // Zero out the unselected attributes
    //

    ZeroMemory( UnSelectedAttributes, sizeof( BOOLEAN ) * ADAttributeCounts[ADContact] );

    GetContactOU(
        Connection,
        ContactOU
        );

    GetAttributesToSync(
        ADContact,
        ContactAttributesToSync,
        ContactAttributesToSyncQuestion,
        UnSelectedAttributes
        );

}

VOID
GetSMTPMailDomains(
    IN OUT PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function gets the smtp mail domains in this forest from the user.
    They will be placed under SMTPMailDomains property of this structure.
    This is a one-dimensional array every domain is seperated by a single null
    character and at the end of the string there are two null characters.

Arguments:

    ForestInformation - SMTPMailDomains attribute of this variable is going to be
        filled. SMTPMailDomainsSize will be the size of the string allocated.

Return Values:

    VOID

--*/
{
    PWSTR MailDomains;
    PWSTR Response;
    PWCHAR pResponse;
    ULONG DomainsSize = 2;  // two nulls at the end of the string
    BOOLEAN MailDomainNameStarted;
    BOOLEAN HitSpace;
    BOOLEAN SMTPDomainsCollected;

    do {

        SMTPDomainsCollected = FALSE;

        //
        // Get SMTP mail domains
        //
        GetInformationFromConsole(
            SMTPMailDomainsRequest,
            TRUE,   // empty string allowed
            &Response
            );

        //
        // if nothing was entered, return
        //
        if( Response[0] == 0 ) {

            ForestInformation->SMTPMailDomainsSize = 0;
            ForestInformation->SMTPMailDomains = NULL;
            return;
        }

        //
        // Find the size of the output string
        //

        for( pResponse = Response; *pResponse != 0; ++pResponse ) {

            if( *pResponse != L' ' ) {

                DomainsSize ++;
            }

        }

        DomainsSize *= sizeof( WCHAR );
        ALLOCATE_MEMORY( MailDomains, DomainsSize );

        ForestInformation->SMTPMailDomains = MailDomains;
        ForestInformation->SMTPMailDomainsSize = DomainsSize;


        //
        // Parse the input
        //

        MailDomainNameStarted = FALSE;
        HitSpace = FALSE;

        for( pResponse = Response; *pResponse != 0; ++pResponse ) {

            BOOLEAN InvalidInput = FALSE;

            switch( *pResponse ) {

                case L' ':

                    if( MailDomainNameStarted ) {

                        HitSpace = TRUE;
                    }
                    break;

                case L',':
                    MailDomainNameStarted = FALSE;
                    HitSpace = FALSE;
                    *MailDomains = 0;
                    MailDomains ++;
                    break;

                default:

                    MailDomainNameStarted = TRUE;

                    if( HitSpace ) {

                        InvalidInput = TRUE;
                    }
                    *MailDomains = *pResponse;
                    MailDomains ++;
                    break;
            }

            if( InvalidInput ) {

                break;
            }
        }

        SMTPDomainsCollected = !!( *pResponse == 0 );

        if( !SMTPDomainsCollected ) {

            OUTPUT_TEXT( InvalidInput );
            FREE_MEMORY( ForestInformation->SMTPMailDomains );
        }

        FREE_MEMORY( Response );
    } while( !SMTPDomainsCollected );

    //
    // Add to two 0s to the end of the string
    //
    *MailDomains = 0;
    MailDomains++;
    *MailDomains = 0;

}

VOID
DisplayConfigurationInformation(
    IN PFOREST_INFORMATION ForestInformation,
    IN PWSTR FolderName,
    IN BOOLEAN **UnSelectedAttributes
)
/*++

Routine Description:

    This function will display the information that is entered for sanity check.

Arguments:

    ForestInformation - Information specific to the forest

    Foldername - the name of the folder where the XML file is going to be placed.

    UnSelectedAttributes - a Boolean array to distinguish between unselected and
            selected attributes for each class

Return Values:

    VOID

--*/
{
    ULONG i;
    AD_OBJECT_CLASS Class;
    TEXT_INDEX Indices[] = {
        UserAttributesTitle,
        GroupAttributesTitle,
        ContactAttributesTitle,
        };

    //
    // Display Forest related information
    //  1. MAName
    //  2. Forest name
    //  3. Account name
    //  4. MMS Synced Data OU
    //
    OUTPUT_TEXT( ConfigurationTitle );
    OUTPUT_TEXT( MANameTitle );
    fwprintf( OutputStream,  L"%sADMA\n", ForestInformation->ForestName );
    OUTPUT_TEXT( ForestNameTitle );
    fwprintf( OutputStream,  L"%s\n", ForestInformation->ForestName );
    OUTPUT_TEXT( UserNameTitle );
    fwprintf( OutputStream,  L"%s\n", ForestInformation->AuthInfo.User );
    OUTPUT_TEXT( MMSSyncedDataOUTitle );

    if( ForestInformation->MMSSyncedDataOU == NULL ) {

        OUTPUT_TEXT( NoMMSSyncedDataOU );

    } else {

        fwprintf( OutputStream,  L"%s\n", ForestInformation->MMSSyncedDataOU );
    }

    //
    // Display which attributes were selected
    //

    for ( Class = ADUser; Class < ADDummyClass; ++Class ) {

        BOOLEAN FirstAttribute = TRUE;

        OUTPUT_TEXT( Indices[Class] );

        for( i = 0; i < ADAttributeCounts[Class]; ++i ) {
            if( !UnSelectedAttributes[Class][i] ) {

                if( FirstAttribute ) {

                    PRINT( Attributes[ADAttributes[Class][i]] );
                    FirstAttribute = FALSE;

                } else {

                    fwprintf( OutputStream,  L", %s", Attributes[ADAttributes[Class][i]] );
                }
            }
        }
        PRINT( L"\n" );
    }

    //
    // Display where the contacts OU reside
    //

    OUTPUT_TEXT( ContactOUTitle );
    if( ForestInformation->ContactOU == NULL ) {

        OUTPUT_TEXT( NoContactOU );

    } else {

        fwprintf( OutputStream,  L"%s\n", ForestInformation->ContactOU );
    }
}

VOID
FreeAllocatedMemory(
    IN PFOREST_INFORMATION ForestInformation,
    IN BOOLEAN **UnSelectedAttributes,
    IN BOOLEAN DontFreeUnselectedAttributes
)
/*++

Routine Description:

    This function frees the information entered in.

Arguments:

    ForestInformation - Information specific to the forest

    UnSelectedAttributes - a Boolean array to distinguish between unselected and
            selected attributes for each class

    DontFreeUnselectedAttributes - true if we dont want to free unselectedAttributes

Return Values:

    VOID

--*/
{
    //
    // Free forest related information
    //
    FreeForestInformationData( ForestInformation );

    //
    // Free unselected attributes
    //

    if( !DontFreeUnselectedAttributes ) {

        ULONG i;

        for( i = 0; i < 3; ++i ) {

            FREE_MEMORY( UnSelectedAttributes[i] );
        }
    }
}

VOID __cdecl
main( int argc, WCHAR *argv[] )
{
    FOREST_INFORMATION TempForestInformation;
    BOOLEAN **UnSelectedAttributes;
    BOOLEAN UsingATemplate = FALSE;
    MA_LIST MAList = NULL;
    BOOLEAN SetupMA;
    BOOLEAN CheckMMSServerInstallation;

    if( argc > 2 ||
        ( argc == 2 && !wcscmp( argv[1], Text[SkipMMSInstallationCheck] ) )
        ) {

        OUTPUT_TEXT( Usage );
        EXIT_WITH_ERROR( InvalidSwitch );
    }

    CheckMMSServerInstallation = ( argc == 1 );

    //
    // Check if MMS server is installed!
    //

    if( !MMSServerInstalled() && CheckMMSServerInstallation ) {

        EXIT_WITH_ERROR( MMSServerNotInstalled );
    }

    //
    // Get XML File folder
    //

    GetFileInformation( &FolderName );

    do {

        //
        // Get forest information
        //

        GetForestInformation( &TempForestInformation );

        //
        // If not using a template, ask for which attributes to be synced
        //

        if( !UsingATemplate ) {

            ALLOCATE_MEMORY( UnSelectedAttributes, sizeof( PBOOLEAN ) * 3 );
            ALLOCATE_MEMORY( UnSelectedAttributes[ADUser], ADAttributeCounts[ADUser] * sizeof( BOOLEAN ) );
            ALLOCATE_MEMORY( UnSelectedAttributes[ADGroup], ADAttributeCounts[ADGroup] * sizeof( BOOLEAN ) );
            ALLOCATE_MEMORY( UnSelectedAttributes[ADContact], ADAttributeCounts[ADContact] * sizeof( BOOLEAN ) );

            GetAttributesToSync(
                ADUser,
                UserAttributesToSync,
                UserAttributesToSyncQuestion,
                UnSelectedAttributes[ADUser]
                );

            GetAttributesToSync(
                ADGroup,
                GroupAttributesToSync,
                GroupAttributesToSyncQuestion,
                UnSelectedAttributes[ADGroup]
                );

            GetContactInformation(
                TempForestInformation.Connection,
                &( TempForestInformation.ContactOU ),
                UnSelectedAttributes[ADContact]
                );

        } else {

            //
            // If using a template ask for contact ou only
            //
            GetContactOU(
                TempForestInformation.Connection,
                &( TempForestInformation.ContactOU )
                );

        }

        //
        // Get SMTP Mail domains in this forest
        //
        GetSMTPMailDomains(
            &TempForestInformation
            );

        //
        // Display the information gathered
        //
        DisplayConfigurationInformation(
            &TempForestInformation,
            FolderName,
            UnSelectedAttributes
            );

        //
        // If the information was incorrect return back and re-ask everything
        //

        if( !GetAnswerToAYesNoQuestionFromConsole( EnteredInformationCorrectQuestion ) ) {

            FreeAllocatedMemory(
                &TempForestInformation,
                UnSelectedAttributes,
                UsingATemplate
                );

            continue;
        }

        //
        // Insert this MA to the MA List
        //
        InsertInformationToList(
            &MAList,
            &TempForestInformation,
            UnSelectedAttributes
            );

        //
        // If another forest is to be configured,
        //  1. Display previously configured forests
        //  2. Ask if the user wants to use a template or start over
        //  3. If a template is going to be used, do so.
        //  4. If no template is going to be used, start over
        //

        if( GetAnswerToAYesNoQuestionFromConsole( WantToConfigureAnotherForestQuestion ) ) {

            PWSTR Response;
            BOOLEAN Successful = FALSE;

            do {
                DisplayAvailableMAs( MAList );

                GetInformationFromConsole(
                    TemplateMARequest,
                    FALSE,   // empty not string allowed
                    &Response
                    );

                if( wcscmp( Response, Text[New] ) == 0 ) {

                    Successful = TRUE;
                    UsingATemplate = FALSE;

                } else {

                    if( FoundTemplate( MAList, Response, &UnSelectedAttributes ) ) {

                        Successful = TRUE;
                        UsingATemplate = TRUE;
                    }
                }

            } while( !Successful );

            continue;
        }

        do {

            //
            // Ask if the user wants to setup the MAs
            //
            SetupMA = GetAnswerToAYesNoQuestionFromConsole( SetupMAsQuestion );

            //
            // Warn the user that if he is not going to setup MAs now,
            //  everything will be lost
            //
            if( !SetupMA ) {

                if( GetAnswerToAYesNoQuestionFromConsole( SetupMAsWarning ) ) {

                    return;
                }
            }

        } while( !SetupMA );

        if( SetupMA ) {

            break;
        }
    } while( 1 );

    //
    // Write gathered information to registery and XML files
    //
    WriteOutput( MAList );

    OUTPUT_TEXT( YouAreFinished );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\forest.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    forest.h

Abstract:

    Include this file if you want to connect/query a forest.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include <windows.h>
#include <winldap.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <Rpc.h> //for Uuid

typedef struct {

    PWSTR ForestName;
    SEC_WINNT_AUTH_IDENTITY_W AuthInfo;
    PWSTR MMSSyncedDataOU;
    PWSTR ContactOU;
    PLDAP Connection;
    PWSTR SMTPMailDomains;
    ULONG SMTPMailDomainsSize;

} FOREST_INFORMATION, *PFOREST_INFORMATION;

typedef struct {

    BOOLEAN isDomain;
    PWSTR DN;
    UUID GUID;
    PWSTR DnsName;

} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

//
// Connects to the forest, and places the connection to the connection
//  attribute of the input. ForestName attribute has to be filled in
//  before calling this function
//

BOOLEAN
ConnectToForest(
    IN PFOREST_INFORMATION ForestInformation
    );

//
// Binds to the forest with the supplied credentials. AuthInfo attribute
//  of the input has to be filled in, plus connection has to be made before
//  calling this function using ConnectToForest.
//

BOOLEAN
BindToForest(
    IN PFOREST_INFORMATION ForestInformation
    );

//
// Using the connection input, this function tries to locate the OU.
//  If it is located then TRUE is returned, if not false is returned.
//

BOOLEAN
FindOU(
    IN PLDAP Connection,
    IN PWSTR OU
    );

//
// Builds the authentication information. Username, domain and password
//  must be present before calling this function.
//

VOID
BuildAuthInfo(
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthInfo
    );

//
// Frees the authentication information. Call this function when you
//  don't need the authentication information since it zeroes out
//  the password.
//
VOID
FreeAuthInformation(
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthInfo
    );

//
// Frees the memory held by the ForestInformation structure
//

VOID
FreeForestInformationData(
    IN PFOREST_INFORMATION ForestInformation
    );

//
// Checks if the current connection has access to the OU.
//
BOOLEAN
WriteAccessGrantedToOU(
    IN PLDAP Connection,
    IN PWSTR OU
    );

BOOLEAN
ReadFromUserContainer(
    IN PLDAP Connection
    );

VOID
ReadPartitionInformation(
    IN PLDAP Connection,
    OUT PULONG nPartitions,
    OUT PPARTITION_INFORMATION *PInfo
    );

VOID
FreePartitionInformation(
    IN ULONG nPartitions,
    IN PPARTITION_INFORMATION PInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\ma.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ma.h

Abstract:

    This file includes functions about storing, gathering information
    about how to create a MA XML file.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include "Forest.h"
#include "Attributes.h"
#include "Texts.h"
#include <Rpc.h> //for UuidCreate

//
// Contains the path where the output files are going to be
//  stored.
//

PWSTR FolderName;

//
// This structure contains information that is required to create
//  a MA file.
//
// MAName is the name of the MA and the name of the file as well.
//
// Forest information contains the information about the forest, like
//  forest name, credentials for the forest.
//
// UnselectedAttributes are the attributes which are not selected for
//  attribute synchronization.
//
// MAGuid is a guid that uniquely identifies the MA. It shouldn't be
//  forest guid or anything unique about the forest. It must be created.
//

typedef struct {

    PWSTR MAName;
    FOREST_INFORMATION ForestInformation;
    BOOLEAN **UnSelectedAttributes;
    UUID MAGuid;

} MA, *PMA;

//
// Stores a list of MAs.
//
typedef struct _MA_LIST_ELEMENT {

    MA MA;
    struct _MA_LIST_ELEMENT *NextElement;

} MA_LIST_ELEMENT, *PMA_LIST_ELEMENT;

typedef PMA_LIST_ELEMENT MA_LIST;
typedef MA_LIST *PMA_LIST;

#define CREATE_GUID( Guid )                 \
    if( UuidCreate( Guid ) ) {              \
        EXIT_WITH_ERROR( CantCreateGUID )   \
    }

//
// Inserts the information gathered to the list. It doesn't make
//  its own copies so you shouldn't free any structure you pass in
//  as parameter
//
VOID
InsertInformationToList(
    IN OUT PMA_LIST MAList,
    IN PFOREST_INFORMATION ForestInformation,
    IN BOOLEAN **UnSelectedAttributes
    );

//
// Displays the information already put in list
//
VOID
DisplayAvailableMAs(
    IN MA_LIST MAList
    );

//
// Checks if a template is present, if it returns TRUE
//  unselected attributes of the object classes will be
//  outputed in the last parameter.
//
BOOLEAN
FoundTemplate(
    IN MA_LIST MAList,
    IN PWSTR MAName,
    OUT BOOLEAN ***UnSelectedAttributes
    );

//
// Writes the output, both XML files and registery changes
//
VOID
WriteOutput(
    IN MA_LIST MAList
    );

//
// Checks if the mms server is installed on this machine.
//
BOOLEAN
MMSServerInstalled(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\texts.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    texts.c

Abstract:

    This file contains all text related functions and variables. Also memory
    management functions (ALLOCATE_MEMORY, FREE_MEMORY ) in this file should
    be used in the project.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include "Texts.h"
#include <stdio.h>
#include <stdlib.h>

FILE *OutputStream = stdout;
FILE *InputStream = stdin;

//
// All the text that can be displayed to the user.
//  It is indexed by TEXT_INDEX enum
//

PWSTR Text[DummyTextIndex] = {
        L"This program runs without any parameters;\n\t> GALSync.exe\n",
        L"You have provided an invalid switch\n",
        L"-smms",
        L"MMS Server is not installed on this machine. Please run this program "
            L"on a machine that has MMS installed.\n",
        L"Program has run out of memory...\n"
            L"Please close some other applications and restart the program\n",
        L"Please Enter Forest Name >",
        L"Please Enter Domain Name >",
        L"Please Enter MMS User Name >",
        L"Password >",
        L"Where will MMS synced data be stored? "
            L"Please enter the DN of the container in the form cn=x, ou=y, dc=z >",
        L"Supplied OU doesn't exist, this means no information will be synced "
            L"or contacts created in this forest? Is that OK? Y or N >",
        L"Please create this OU to proceed\n",
        L"Account provided for MMS to run has insufficient rights, please ensure "
            L"it has read access to the directory and write access to the OU supplied\n",
        L"Where will the generated XML files be stored? Please enter the location in "
            L"the form c:\\MMS Folder\\Filename >",
        L"Folder doesn't exist, Create? Enter Y to create it, N to go back. Tool cannot "
            L"continue unless you specify one of the above >",
        L"Error! Cannot create folder.Please retry\n",
        L"User Attributes to be synchronized are:\n",
        L"Please enter the number of the attribute followed by * to deselect. Seperate "
            L"multiple attributes with a comma (for example 1*, 2* deselects C and Cn "
            L"for synchronization) >",
        L"Group Attributes to be synchronized are:\n",
        L"Please enter the number of the attribute followed by * to deselect. Seperate "
            L"multiple attributes with a comma (for example 1*, 2* deselects C and Cn "
            L"for synchronization) >",
        L"Are there contacts to be exported? Please enter Y or N? >",
        L"Please enter the DN of the container where these contacts are located (For example "
            L" cn=JSmith, ou=promotions, ou=marketing, dc=reskit, dc=com) >",
        L"OU doesn't exist, contacts will not be synced. Type Y to accept and N to go back >",
        L"Contact Attributes to be synchronized are:\n",
        L"Please enter the number of the attribute followed by * to deselect. Seperate "
            L"multiple attributes with a comma (for example 1*, 2* deselects C and Cn "
            L"for synchronization) >",
        L"What SMTP mail domains are managed by this forest, please enter the list of "
            L"domain names separated by commas >",
        L"You have configured the following:\n",
        L"MA Name = ",
        L"Forest name = ",
        L"User name = ",
        L"Target location for MMS synced data flowing into this forest = ",
        L"no information flowing into this forest\n",
        L"Attributes for users = ",
        L"Attributes for groups = ",
        L"Attributes for contacts = ",
        L"Source location for MMS synced contacts flowing out of this forest = ",
        L"no contacts information flowing out of this forest\n",
        L"Please review the information above. Is this information correct? Enter Y or N? >",
        L"Want to configure another forest? Y or N? >",
        L"Shall we set up a Management Agent for this forest and any others you may have pending? Y or N? >",
        L"If you do no set up an agent now, you will lose data you have just configured. "
            L"Are you sure you don't want to create MAs? Type Y to exit and N to go back. >",
        L"MA's available preconfigured are:",
        L"Please type in MA name to use it as a template or New to create a new configuration. "
            L"If you use an existing MA then all the attributes selected from users, groups and "
            L"contacts for previous that template will be reused. >",
        L"You are finished, please follow the documented instructions to set up and run GAL Sync.",
        L"New",
        L"Input is invalid. Please correct\n",
        L"Cannot create a GUID. Make sure that this computer has an ethernet/token ring (IEEE 802.x) address\n",
        L"Cannot open MV-TemplateFile\n",
        L"Cannot read from MV-TemplateFile\n",
        L"Cannot write to MV-File\n",
        L"MV-Template file is corrupted!\n",
        L"Cannot create MA file\n",
        L"Cannot write to MA File\n",
    };

VOID
GetInformationFromConsole(
    IN TEXT_INDEX Index,
    IN BOOLEAN EmtpyStringAllowed,
    OUT PWSTR *Output
    )
/*++

Routine Description:

    This function outputs the text indexed by Index and waits for an input.
    EmptyStringAllowed, as name suggests, controls if empty string is allowed or not.
    If it is not allowed and the user gives an empty string, he will be reasked.
    The caller is responsible to free the Output.

Arguments:

    Index - index of the text that contains the question

    EmptyStringAllowed - true if empty string is allowed

    Output - the response from the user

Return Values:

    VOID

--*/
{
#define MAXIMUM_LENGTH_INPUT 0xFF
    WCHAR TempBuffer[ MAXIMUM_LENGTH_INPUT + 1 ];

    do {
        OUTPUT_TEXT( Index );

        fgetws( TempBuffer, MAXIMUM_LENGTH_INPUT, stdin );

        //
        // Get rid of the enter at the end
        //
        TempBuffer[ wcslen( TempBuffer ) - 1 ] = 0;

        //
        // If nothing was entered, display invalid input error
        //  and retry
        //

        if( TempBuffer[0] == 0 && !EmtpyStringAllowed ) {

            OUTPUT_TEXT( InvalidInput );
        }

    } while( TempBuffer[0] == 0 && !EmtpyStringAllowed );

    DUPLICATE_STRING( *Output, TempBuffer );
}

BOOLEAN
GetAnswerToAYesNoQuestionFromConsole(
    IN TEXT_INDEX Index
    )
/*++

Routine Description:

    This is a wrapper aroung GetInformationFromConsole that only accepts
    'y', 'Y', 'n', 'N' as an input.

Arguments:

    Index - index of the text that contains the question

Return Values:

    VOID

--*/
{
    PWSTR Response;
    ULONG ReturnVal = 0;

    while( ReturnVal == 0 ) {

        GetInformationFromConsole(
            Index,
            FALSE,   // empty string not allowed
            &Response
            );

        if( wcslen( Response ) == 1 ) {

            switch( Response[0] ) {

                case L'Y':
                case L'y':
                    ReturnVal = 1;
                    break;
                case L'N':
                case L'n':
                    ReturnVal = 2;
                    break;
            }
        }

        FREE_MEMORY( Response );

        if( ReturnVal == 0 ) {

            OUTPUT_TEXT( InvalidInput );
        }

    }

    return ( ReturnVal == 1 );
}

VOID
GetOUFromConsole(
    IN TEXT_INDEX Index,
    OUT PWSTR *Output
    )
/*++

Routine Description:

    This is a wrapper aroung GetInformationFromConsole that doesn't
    accept empty string

Arguments:

    Index - index of the text that contains the question

    Output - the OU will be here

Return Values:

    VOID

--*/
{
    GetInformationFromConsole(
        Index,
        FALSE,  // empty string not allowed
        Output
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\ma.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ma.c

Abstract:

    This file includes functions about storing, gathering information
    about how to create a MA XML file.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include "MA.h"
#include <shlwapi.h>

#define TEMPLATE_FILENAME L"MV-Template.xml"
#define MV_FILENAME L"MV.xml"

#define WriteStringToMAFile( String )   \
    WriteStringToFile( MAFile, String, CannotWriteToMAFile )

#define WriteSchema( MAFile, MA )
#define WriteMAUISettings( MAFile, MA )
#define WriteRunProfile( MAFile )
#define MMS_REG_KEY L"Software\\MicrosoftMetadirectoryServices"

VOID
WriteStringToFile(
    IN HANDLE File,
    IN PWSTR String,
    IN TEXT_INDEX ErrorIndex
    )
/*++

Routine Description:

    This function will write a specific string to the file. If there is
    a problem while writing, then the program exists after printing the
    error with the error index.

Arguments:

    File - The file handle to write to

    String - String to write to the file

    ErrorIndex - if an error occurs the program will exit after printing
        the error message.

Return Values:

    VOID

--*/
{
    BOOL NoError;
    ULONG BytesWritten;

    NoError = WriteFile(
                File,
                String,
                wcslen( String ) * sizeof( WCHAR ),
                &BytesWritten,
                NULL
                );

    if( !NoError || wcslen( String ) * sizeof( WCHAR ) != BytesWritten ) {

        EXIT_WITH_ERROR( ErrorIndex )
    }
}

VOID
InsertInformationToList(
    IN OUT PMA_LIST MAList,
    IN PFOREST_INFORMATION ForestInformation,
    IN BOOLEAN **UnSelectedAttributes
    )
/*++

Routine Description:

    This function will insert an MA to the MAList with the information provided

Arguments:

    MAList - List of MAs where the new MA will be placed.

    ForestInformation - Information specific to the forest

    Foldername - the name of the folder where the XML file is going to be placed.

    UnSelectedAttributes - a Boolean array to distinguish between unselected and
            selected attributes for each class

Return Values:

    VOID

--*/
{
    PMA_LIST_ELEMENT MAListElement;

    ALLOCATE_MEMORY( MAListElement, sizeof( *MAListElement ) );
    ALLOCATE_MEMORY( MAListElement->MA.MAName,
        sizeof( WCHAR ) * ( wcslen( ForestInformation->ForestName ) + wcslen( L"ADMA" ) + 1 ) );

    MAListElement->NextElement = *MAList;
    *MAList = MAListElement;

    wcscpy( MAListElement->MA.MAName, ForestInformation->ForestName );
    wcscat( MAListElement->MA.MAName, L"ADMA" );
    MAListElement->MA.ForestInformation = *ForestInformation;
    MAListElement->MA.UnSelectedAttributes = UnSelectedAttributes;
    CREATE_GUID( &( MAListElement->MA.MAGuid ) )
}

VOID
DisplayAvailableMAs(
    IN MA_LIST MAList
    )
/*++

Routine Description:

    This function displays the names of the MAs for template selection.

Arguments:

    MAList - List of MAs

Return Values:

    VOID

--*/
{
    PMA_LIST_ELEMENT MAListElement = MAList;
    OUTPUT_TEXT( AvailableMAs );

    while( MAListElement != NULL ) {

        fwprintf( OutputStream,  L"%s\n", MAListElement->MA.MAName );

        MAListElement = MAListElement->NextElement;
    }
}

BOOLEAN
FoundTemplate(
    IN MA_LIST MAList,
    IN PWSTR MAName,
    OUT BOOLEAN ***UnSelectedAttributes
    )
/*++

Routine Description:

    This function searches the names of the MAs for template selection.

Arguments:

    MAList - List of MAs

    MAName - the name of the MA that will be used as a template.

    UnSelectedAttributes - the attributes that are unselected will be TRUE
        in this array.

Return Values:

    TRUE - if the MAName is found in the MAList

    FALSE - otherwise

--*/
{
    PMA_LIST_ELEMENT MAListElement = MAList;

    while( MAListElement != NULL ) {

        if( _wcsicmp( MAName, MAListElement->MA.MAName ) == 0 ) {

            break;
        }

        MAListElement = MAListElement->NextElement;
    }

    if( MAListElement == NULL ) {

        *UnSelectedAttributes = NULL;

    } else {

        *UnSelectedAttributes = MAListElement->MA.UnSelectedAttributes;
    }
    return ( *UnSelectedAttributes != NULL );
}

BOOLEAN
CopyFileUntil(
    IN HANDLE To,
    IN HANDLE From,
    IN OPTIONAL PWSTR String1,
    IN OPTIONAL PWSTR String2
    )
{
/*++

Routine Description:

    This function copies from file From, to file To until it reaches one of
    the strings provided. If string1 is reached first, then the function
    returns false. If string2 is reached true is returned. If end of the file
    is reached the program exits. String1 and String2 are optional. If none of
    them is provided the copy is done to the end of the file. If just String1 is
    present the function won't return true.

Arguments:

    To - File to copy to

    From - File to copy from

    String1 - Optional string to search and copy until

    String2 - Optional string to search and copy until

        For difference of String1 and String2 see routine description.

Return Values:

    TRUE - if string2 is reached

    FALSE - if string2 is reached

--*/
#define BUFFER_SIZE 0xFFFF
    WCHAR Buffer[BUFFER_SIZE + 1];
    ULONG BytesRead;
    ULONG BytesWritten;
    BOOLEAN Continue = TRUE;
    PWCHAR FoundPosition;
    BOOL NoError;
    LONG MoveBack = 0;
    LONG ResultOfSetPointer;
    BOOLEAN RetVal;
    do {

        NoError = ReadFile(
                    From,       // handle to file
                    Buffer,     // data buffer
                    BUFFER_SIZE * sizeof( WCHAR ),// number of bytes to read
                    &BytesRead, // number of bytes read
                    NULL        // overlapped buffer
                    );
        if( !NoError ) {

            EXIT_WITH_ERROR( CannotReadFromTemplateFile )
        }

        Buffer[BytesRead/sizeof(WCHAR)] = 0;

        if( BytesRead == 0 ) {

            if( String1 == NULL ) {

                return TRUE;

            } else {

                EXIT_WITH_ERROR( CannotReadFromTemplateFile )
            }
        }

        if( String1 ) {

            FoundPosition = StrStrIW( Buffer, String1 );

            if( FoundPosition ) {

                MoveBack = ( FoundPosition - Buffer ) * sizeof( WCHAR ) - BytesRead;
                BytesRead = ( FoundPosition - Buffer ) * sizeof( WCHAR );
                Continue = FALSE;
                RetVal = FALSE;
            }
        }

        if( String2 && Continue ) {

            FoundPosition = StrStrIW( Buffer, String2 );

            if( FoundPosition ) {

                MoveBack = ( FoundPosition - Buffer ) * sizeof( WCHAR ) - BytesRead;
                BytesRead = ( FoundPosition - Buffer ) * sizeof( WCHAR );
                Continue = FALSE;
                RetVal = TRUE;
            }
        }

        NoError = WriteFile(
                    To,             // handle to file
                    Buffer,         // data buffer
                    BytesRead,      // number of bytes to write
                    &BytesWritten,  // number of bytes written
                    NULL            // overlapped buffer
                    );
        if( !NoError || BytesRead != BytesWritten ) {

            EXIT_WITH_ERROR( CannotWriteToMVFile )
        }

    } while( Continue );

    ResultOfSetPointer = SetFilePointer(
                            From,         // handle to file
                            MoveBack,     // bytes to move pointer
                            NULL,         // bytes to move pointer
                            FILE_CURRENT  // starting point
                            );

    if( ResultOfSetPointer == INVALID_SET_FILE_POINTER ) {

        //
        // Not %100 accurate error
        //
        EXIT_WITH_ERROR( CannotReadFromTemplateFile )
    }
    return RetVal;
}

VOID
ReadFileUntil(
    IN HANDLE File,
    IN PWSTR String,
    IN PWSTR *Output
    )
/*++

Routine Description:

    This function reads the file File until String is reached. The result is
    copied into Output. The caller is responsible to free the Output with
    FREE_MEMORY when not needed. If end of file is reached before String is
    reached, this function will halt execution.

Arguments:

    File - File to read from

    String1 - string to search

    Output - the result will be in this variable

Return Values:

    VOID

--*/
{
#define BUFFER_SIZE 0xFFFF
    WCHAR Buffer[BUFFER_SIZE + 1];
    ULONG BytesRead;
    BOOL NoError;
    PWSTR FoundPosition;
    LONG MoveBack;
    LONG ResultOfSetPointer;

    NoError = ReadFile(
                File,       // handle to file
                Buffer,     // data buffer
                BUFFER_SIZE * sizeof( WCHAR ),// number of bytes to read
                &BytesRead, // number of bytes read
                NULL        // overlapped buffer
                );

    if( !NoError ) {

        EXIT_WITH_ERROR( CannotReadFromTemplateFile )
    }

    Buffer[BytesRead/sizeof(WCHAR)] = 0;

    FoundPosition = StrStrIW( Buffer, String );

    if( !FoundPosition ) {

        EXIT_WITH_ERROR( CannotReadFromTemplateFile )
    }
    *FoundPosition = 0;
    MoveBack = ( FoundPosition - Buffer ) * sizeof( WCHAR ) - BytesRead;
    BytesRead = ( FoundPosition - Buffer ) * sizeof( WCHAR );

    ResultOfSetPointer = SetFilePointer(
                            File,         // handle to file
                            MoveBack,     // bytes to move pointer
                            NULL,         // bytes to move pointer
                            FILE_CURRENT  // starting point
                            );

    if( ResultOfSetPointer == INVALID_SET_FILE_POINTER ) {

        //
        // Not %100 accurate error
        //
        EXIT_WITH_ERROR( CannotReadFromTemplateFile )
    }
    DUPLICATE_STRING( *Output, Buffer );
}

VOID
WriteToFileUsingMAInfo(
    IN HANDLE File,
    IN UUID *Guid,
    IN OUT PWSTR String
    )
/*++

Routine Description:

    This function is very specific to its task. I cannot see any other place
    that is can be used. String must contain something in the following form:

<import-flow src-ma="{3BB035B4-7AA0-4674-972A-34E3A2D26D04}" cd-object-type="person"
    id="{2953E0F4-8763-4866-BA0F-4DFA1BC774D5}">

    First GUID will be replaced by the guid in the parameter list, second GUID
    will be generated and replaced. The file is going to be written with this
    information.

    String will contain the updated information at the end of this function call.

Arguments:

    File - File to write to

    Guid - GUID to replace

    String - contains the information what is going to be written into the file

Return Values:

    VOID

--*/
{
    PWSTR FoundPosition;
    GUID Id;
    BOOL NoError;
    ULONG BytesWritten;
    PWSTR StringGuid;

    FoundPosition =  StrStrIW( String, L"\"{" );

    if( FoundPosition == NULL ) {

        EXIT_WITH_ERROR( CorruptedTemplateFile );
    }

    if( UuidToStringW( Guid, &StringGuid ) ) {

        EXIT_WITH_ERROR( RunOutOfMemoryError );
    }

    swprintf( FoundPosition + 2, L"%s", StringGuid );

    FoundPosition[2 + wcslen( StringGuid )] = L'}';

    RpcStringFreeW( &StringGuid );

    FoundPosition =  StrStrIW( FoundPosition + 2, L"\"{" );

    if( FoundPosition == NULL ) {

        EXIT_WITH_ERROR( CorruptedTemplateFile );
    }

    CREATE_GUID( &Id );

    if( UuidToStringW( &Id, &StringGuid ) ) {

        EXIT_WITH_ERROR( RunOutOfMemoryError );
    }

    swprintf( FoundPosition + 2, L"%s", StringGuid );

    FoundPosition[2 + wcslen( StringGuid )] = L'}';

    RpcStringFreeW( &StringGuid );

    WriteStringToFile( File, String, CannotWriteToMVFile );

}

VOID
WriteToFileReplacingIDWithAGUID(
    IN HANDLE File,
    IN OUT PWSTR Buffer
    )
/*++

Routine Description:

    This function is very specific to its task. I cannot see any other place
    that is can be used. Buffer must contain something in the following form:

<mv-deletion-rule mv-object-type="person" id="{7F8FC09E-EEEF-4D47-BE7F-3C510DF58C66}"
    type="declared">

    A GUID will be generated and replaced with the GUID in the string. The file is
    going to be written with this information.

    Buffer will contain the updated information at the end of this function call.

Arguments:

    File - File to write to

    Buffer - contains the information what is going to be written into the file

Return Values:

    VOID

--*/
{
    PWSTR FoundPosition;
    GUID Id;
    PWSTR StringGuid;
    FoundPosition =  StrStrIW( Buffer, L"\"{" );
    CREATE_GUID( &Id );

    if( UuidToStringW( &Id, &StringGuid ) ) {

        EXIT_WITH_ERROR( RunOutOfMemoryError );
    }

    swprintf( FoundPosition + 2, L"%s", StringGuid );
    FoundPosition[2 + wcslen( StringGuid )] = L'}';

    RpcStringFreeW( &StringGuid );

    WriteStringToFile( File, Buffer, CannotWriteToMVFile );
}

VOID
WriteMAData(
    IN HANDLE MAFile,
    IN PMA MA
    )
/*++

Routine Description:

    This function writes the basic MA data to MAFile. Basic information includes

        MA name
        Category
        descrition
        id
        format-version
        version

Arguments:

    MAFile - File to write to

    MA - MA about which the information is going to be written

Return Values:

    VOID

--*/
{
#define MA_DATA_START L"<ma-data>"
#define MA_DATA_END L"</ma-data>"
#define NAME_START L"<name>"
#define NAME_END L"</name>"
#define CATEGORY L"<category>ADMA</category><description>GAL Sync</description>"
#define ID_START L"<id>{"
#define ID_END L"}</id>"
#define FORMAT_VERSION L"<format-version>1</format-version>"
#define VERSION L"<version>0</version>"

    PWSTR Guid;

    WriteStringToMAFile( MA_DATA_START );
    WriteStringToMAFile( NAME_START );
    WriteStringToMAFile( MA->MAName );
    WriteStringToMAFile( NAME_END );
    WriteStringToMAFile( CATEGORY );
    WriteStringToMAFile( ID_START );

    if( UuidToStringW( &( MA->MAGuid ), &Guid ) ) {

        EXIT_WITH_ERROR( RunOutOfMemoryError );
    }
    WriteStringToMAFile( Guid );
    RpcStringFreeW( &Guid );
    WriteStringToMAFile( ID_END );
    WriteStringToMAFile( FORMAT_VERSION );
    WriteStringToMAFile( VERSION );
    WriteStringToMAFile( MA_DATA_END );
}

VOID
WriteMVXMLFile(
    IN MA_LIST MAList,
    OUT PWSTR *Header
    )
/*++

Routine Description:

    This function reads from a template MV file, and creates an MV file using,
    the MAs present. It also returns the header of the MV file to be used by
    all other MA files.

Arguments:

    MAList - List of MAs to be generated

    Header - the header of the template MV file will be returned here

Return Values:

    VOID

--*/
{
#define IMPORT_ATTRIBUTE_FLOW_END L"</import-attribute-flow>"
#define IMPORT_FLOW_SRC_MA L"<import-flow src-ma="
#define IMPORT_FLOW_END L"</import-flow>"

#define MV_DELETION_RULE L"<mv-deletion-rule"
#define MV_DELETION_RULE_END L"</mv-deletion-rule>"
#define MV_DELETION_END L"</mv-deletion>"
#define HEADER_END L"<mv-data>"

    BOOLEAN Finished = FALSE;
    HANDLE TemplateFile;
    HANDLE MVFile;
    ULONG BytesWritten;
    BOOL NoError;
    WCHAR Filename[_MAX_FNAME];

    wcscpy( Filename, FolderName );
    wcscat( Filename, L"\\" );
    wcscat( Filename, MV_FILENAME );


    TemplateFile = CreateFileW(
                    TEMPLATE_FILENAME,      // file name
                    GENERIC_READ,           // access mode
                    FILE_SHARE_READ,        // share mode
                    NULL,                   // SD
                    OPEN_EXISTING,          // how to create
                    FILE_ATTRIBUTE_NORMAL,  // file attributes
                    NULL                    // handle to template file
                    );

    if( TemplateFile == INVALID_HANDLE_VALUE ) {

        EXIT_WITH_ERROR( MVTemplateFileError )
    }

    MVFile = CreateFileW(
                Filename,               // file name
                GENERIC_WRITE,          // access mode
                FILE_SHARE_READ,        // share mode
                NULL,                   // SD
                CREATE_ALWAYS,          // how to create
                FILE_ATTRIBUTE_NORMAL,  // file attributes
                NULL                    // handle to template file
                );

    if( MVFile == INVALID_HANDLE_VALUE ) {

        EXIT_WITH_ERROR( MVTemplateFileError )
    }

    ReadFileUntil( TemplateFile, HEADER_END, Header );

    NoError = WriteFile(
                MVFile,          // handle to file
                *Header,         // data buffer
                wcslen( *Header ) * sizeof( WCHAR ),// number of bytes to write
                &BytesWritten,  // number of bytes written
                NULL            // overlapped buffer
                );

    if( !NoError || wcslen( *Header ) * sizeof( WCHAR ) != BytesWritten ) {

        EXIT_WITH_ERROR( CannotWriteToMVFile )
    }

    while( !CopyFileUntil( MVFile, TemplateFile,
            IMPORT_FLOW_SRC_MA, IMPORT_ATTRIBUTE_FLOW_END ) ) {

            PWSTR Buffer;
            PMA_LIST_ELEMENT MAListElement = MAList;


            ReadFileUntil( TemplateFile, IMPORT_FLOW_END, &Buffer );

            while( MAListElement != NULL ) {

                WriteToFileUsingMAInfo( MVFile, &( MAListElement->MA.MAGuid ), Buffer );
                MAListElement = MAListElement->NextElement;

                if( MAListElement != NULL ) {

                    WriteStringToFile( MVFile, IMPORT_FLOW_END, CannotWriteToMVFile );
                }
            }

            FREE_MEMORY( Buffer );
    }

    while( !CopyFileUntil( MVFile, TemplateFile,
            MV_DELETION_RULE, MV_DELETION_END ) ) {

            PWSTR Buffer;
            PMA_LIST_ELEMENT MAListElement = MAList;


            ReadFileUntil( TemplateFile, MV_DELETION_RULE_END, &Buffer );

            while( MAListElement != NULL ) {

                WriteToFileReplacingIDWithAGUID( MVFile, Buffer );
                MAListElement = MAListElement->NextElement;

                if( MAListElement != NULL ) {

                    WriteStringToFile( MVFile, MV_DELETION_RULE_END, CannotWriteToMVFile );
                }
            }

            FREE_MEMORY( Buffer );
    }

    CopyFileUntil( MVFile, TemplateFile, NULL, NULL );
    CloseHandle( TemplateFile );
    CloseHandle( MVFile );
}

VOID
WritePrivateConfiguration(
    IN HANDLE MAFile,
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function fills in the <private-configuration> tag. Here we need
    the forestname, and credentials.

Arguments:

    MAFile - File to write to

    ForestInformation - Information about the forest

Return Values:

    VOID

--*/
{
#define PRIVATE_CONFIGURATION_START L"<private-configuration>"
#define PRIVATE_CONFIGURATION_END L"</private-configuration>"
#define ADMA_CONFIGURATION_START L"<adma-configuration>"
#define ADMA_CONFIGURATION_END L"</adma-configuration>"
#define FOREST_NAME_START L"<forest-name>"
#define FOREST_NAME_END L"</forest-name>"
#define DOMAIN_START L"<forest-login-domain>"
#define DOMAIN_END L"</forest-login-domain>"
#define LOGIN_START L"<forest-login-user>"
#define LOGIN_END L"</forest-login-user>"

    WriteStringToMAFile( PRIVATE_CONFIGURATION_START );
    WriteStringToMAFile( ADMA_CONFIGURATION_START );

    WriteStringToMAFile( FOREST_NAME_START );
    WriteStringToMAFile( ForestInformation->ForestName );
    WriteStringToMAFile( FOREST_NAME_END );

    WriteStringToMAFile( DOMAIN_START );
    WriteStringToMAFile( ForestInformation->AuthInfo.Domain );
    WriteStringToMAFile( DOMAIN_END );

    WriteStringToMAFile( LOGIN_START );
    WriteStringToMAFile( ForestInformation->AuthInfo.User );
    WriteStringToMAFile( LOGIN_END );

    WriteStringToMAFile( ADMA_CONFIGURATION_END );
    WriteStringToMAFile( PRIVATE_CONFIGURATION_END );

}

VOID
WriteProjection(
    IN HANDLE MAFile
    )
/*++

Routine Description:

    This function fills in the <projection> tag. Three classes (user, group, contact) will be
    used and all of them will be scripted.

Arguments:

    MAFile - File to write to

Return Values:

    VOID

--*/
{
#define PROJECTION_START L"<projection>"
#define PROJECTION_END L"</projection>"
#define CLASS_MAPPING_START L"<class-mapping type = \"scripted\" id=\"{"
#define CD_OBJECT_TYPE2 L"}\" cd-object-type=\""
#define CLASS_MAPPING_END L"\"> </class-mapping>"

    GUID Id;
    PWSTR String;
    AD_OBJECT_CLASS ADClass;

    WriteStringToMAFile( PROJECTION_START );

    for( ADClass = ADUser; ADClass != ADDummyClass; ++ADClass ) {

        WriteStringToMAFile( CLASS_MAPPING_START );

        CREATE_GUID( &Id );

        if( UuidToStringW( &Id, &String ) ) {

            EXIT_WITH_ERROR( RunOutOfMemoryError );
        }

        WriteStringToMAFile( String );

        RpcStringFreeW( &String );

        WriteStringToMAFile( CD_OBJECT_TYPE2 );

        WriteStringToMAFile( ADClassNames[ ADClass ] );

        WriteStringToMAFile( CLASS_MAPPING_END );
    }

    WriteStringToMAFile( PROJECTION_END );
}

VOID
WriteDisconnectorPCleanupAndExtension(
    IN HANDLE MAFile
    )
/*++

Routine Description:

    This function fills in the some tags that are static.

        Stay-disconnector
        Provisioning-cleanup
        extension

Arguments:

    MAFile - File to write to

Return Values:

    VOID

--*/
{
#define STAY_DISCONNECTOR L"<stay-disconnector />"
#define PROVISIONING_CLEANUP L"<provisioning-cleanup type=\"scripted\" />"
#define EXTENSION L"<extension> <assembly-name>ADMA.dll</assembly-name><application-protection>low"\
                  L"</application-protection></extension>"

    WriteStringToMAFile( STAY_DISCONNECTOR );
    WriteStringToMAFile( PROVISIONING_CLEANUP );
    WriteStringToMAFile( EXTENSION );

}

VOID
WriteAttributeInclusions(
    IN HANDLE MAFile,
    IN BOOLEAN **UnselectedAttributes
    )
/*++

Routine Description:

    This function fills in the <attribute-inclusion> tag. In this tag, the attributes
    which are going to be synced out are present.

Arguments:

    MAFile - File to write to

    UnselectedAttributes - boolean array that marks attributes that are not selected/synced out

Return Values:

    VOID

--*/
{
#define ATTRIBUTE_INCLUSION_START L"<attribute-inclusion>"
#define ATTRIBUTE_INCLUSION_END L"</attribute-inclusion>"
#define ATTRIBUTE_START L"<attribute>"
#define ATTRIBUTE_END L"</attribute>"

    ULONG Unselected[DummyAttribute];
    AD_OBJECT_CLASS Class;
    ATTRIBUTE_NAMES i;

    ZeroMemory( Unselected, sizeof( ULONG ) * DummyAttribute );

    for( Class = ADUser; Class != ADDummyClass; ++Class ) {
        for( i = 0; i < DummyAttribute; ++i ) {

            if( UnselectedAttributes[Class][i] ) {
                Unselected[i] ++;
            }
        }
    }

    WriteStringToMAFile( ATTRIBUTE_INCLUSION_START );

    for( i = C; i < DummyAttribute; ++i ) {

        if( Unselected[i] != ADContact ) {

            WriteStringToMAFile( ATTRIBUTE_START );
            WriteStringToMAFile( Attributes[i] );
            WriteStringToMAFile( ATTRIBUTE_END );
        }
    }
    WriteStringToMAFile( ATTRIBUTE_INCLUSION_END );
}

VOID
WriteExportAttributeFlow(
    IN HANDLE MAFile
    )
/*++

Routine Description:

    This function fills in the <export-attribute-flow> tag. This tag is divided into
    classes, currently 3 classes are present. In every class, attributes that are going
    to be exported from MV to AD for this MA, is present.

Arguments:

    MAFile - File to write to

Return Values:

    VOID

--*/
{
#define EXPORT_ATTRIBUTE_FLOW_START L"<export-attribute-flow>"
#define EXPORT_ATTRIBUTE_FLOW_END   L"</export-attribute-flow>"
#define EXPORT_FLOW_SET_START       L"<export-flow-set "
#define CD_OBJECT_TYPE              L"cd-object-type=\""
#define MV_OBJECT_TYPE              L"\" mv-object-type=\""
#define END_EXPORT_FLOW_SET_START   L"\">"
#define EXPORT_FLOW_SET_END         L"</export-flow-set>"
#define EXPORT_FLOW_START           L"<export-flow "
#define CD_ATTRIBUTE                L"cd-attribute=\""
#define ID                          L"\" id=\"{"
#define SUPPRESS_DELETIONS          L"}\" suppress-deletions=\"false\">"
#define EXPORT_FLOW_END             L"</export-flow>"
#define DIRECT_MAPPING_START        L"<direct-mapping>"
#define DIRECT_MAPPING_END          L"</direct-mapping>"
#define SCRIPTED_MAPPING_START      L"<scripted-mapping>"
#define SCRIPTED_MAPPING_END        L"</scripted-mapping>"
#define SOURCE_ATTRIBUTE_START      L"<source-attribute>"
#define SOURCE_ATTRIBUTE_END        L"</source-attribute>"
#define SCRIPT_CONTEXT_START        L"<script-context>"
#define SCRIPT_CONTEXT_END          L"</script-context>"

    MV_OBJECT_CLASS MVClass;
    AD_OBJECT_CLASS ADClass = ADContact;
    ULONG i;

    WriteStringToMAFile( EXPORT_ATTRIBUTE_FLOW_START );

    for( MVClass = MVPerson; MVClass < MVDummyClass; ++MVClass ) {

        BOOLEAN ProxyAddressesPresent = FALSE;
        WriteStringToMAFile( EXPORT_FLOW_SET_START );
        WriteStringToMAFile( CD_OBJECT_TYPE );
        WriteStringToMAFile( ADClassNames[ADClass] );
        WriteStringToMAFile( MV_OBJECT_TYPE );
        WriteStringToMAFile( MVClassNames[MVClass] );
        WriteStringToMAFile( END_EXPORT_FLOW_SET_START );

        for( i = 0; i < MVAttributeCounts[MVClass]; ++i ) {

            UUID Guid;
            PWSTR StringGuid;


            if( MVAttributes[MVClass][i] == ProxyAddresses ) {

                ProxyAddressesPresent = TRUE;
                continue;
            }

            CREATE_GUID( &Guid );

            if( UuidToStringW( &Guid, &StringGuid ) ) {

                EXIT_WITH_ERROR( RunOutOfMemoryError );
            }
            WriteStringToMAFile( EXPORT_FLOW_START );
            WriteStringToMAFile( CD_ATTRIBUTE );
            WriteStringToMAFile( Attributes[MVAttributes[MVClass][i]] );
            WriteStringToMAFile( ID );
            WriteStringToMAFile( StringGuid );
            WriteStringToMAFile( SUPPRESS_DELETIONS );
            WriteStringToMAFile( DIRECT_MAPPING_START );
            WriteStringToMAFile( Attributes[MVAttributes[MVClass][i]] );
            WriteStringToMAFile( DIRECT_MAPPING_END );
            WriteStringToMAFile( EXPORT_FLOW_END );
            RpcStringFreeW( &StringGuid );
        }

        if( ProxyAddressesPresent ) {

            UUID Guid;
            PWSTR StringGuid;


            CREATE_GUID( &Guid );

            if( UuidToStringW( &Guid, &StringGuid ) ) {

                EXIT_WITH_ERROR( RunOutOfMemoryError );
            }

            WriteStringToMAFile( EXPORT_FLOW_START );
            WriteStringToMAFile( CD_ATTRIBUTE );
            WriteStringToMAFile( Attributes[ProxyAddresses] );
            WriteStringToMAFile( ID );
            WriteStringToMAFile( StringGuid );
            WriteStringToMAFile( SUPPRESS_DELETIONS );
            WriteStringToMAFile( SCRIPTED_MAPPING_START );

            WriteStringToMAFile( SOURCE_ATTRIBUTE_START );
            WriteStringToMAFile( Attributes[LegacyExchangeDn] );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_END );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_START );
            WriteStringToMAFile( Attributes[ProxyAddresses] );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_END );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_START );
            WriteStringToMAFile( Attributes[TextEncodedOrAddress] );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_END );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_START );
            WriteStringToMAFile( Attributes[TargetAddress] );
            WriteStringToMAFile( SOURCE_ATTRIBUTE_END );

            WriteStringToMAFile( SCRIPT_CONTEXT_START );
            WriteStringToMAFile( Attributes[ProxyAddresses] );
            WriteStringToMAFile( SCRIPT_CONTEXT_END );

            WriteStringToMAFile( SCRIPTED_MAPPING_END );
            WriteStringToMAFile( EXPORT_FLOW_END );
            RpcStringFreeW( &StringGuid );
        }

        WriteStringToMAFile( EXPORT_FLOW_SET_END );

    }

    WriteStringToMAFile( EXPORT_ATTRIBUTE_FLOW_END );
}

VOID
WritePartitionData(
    IN HANDLE MAFile,
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function fills in the <ma-partition-data> tag. Here goes all naming context
    information, (domain, nondomain) filters of which object types are allowed to pass
    and which domains must be excluded or included.

Arguments:

    MAFile - File to write to

    ForestInformation - Information about the forest whose partition information is going
        to be written

Return Values:

    VOID

--*/
{
#define MA_PARTITION_DATA_START     L"<ma-partition-data>"
#define MA_PARTITION_DATA_END       L"</ma-partition-data>"
#define PARTITION_START             L"<partition>"
#define PARTITION_END               L"</partition>"
#define ID_START                    L"<id>{"
#define ID_END                      L"}</id>"
#define VERSION_START               L"<version>"
#define VERSION_END                 L"</version>"
#define SELECTED_START              L"<selected>"
#define SELECTED_END                L"</selected>"
#define NAME_START                  L"<name>"
#define NAME_END                    L"</name>"
#define CUSTOM_DATA_START           L"<custom-data>"
#define CUSTOM_DATA_END             L"</custom-data>"
#define ADMA_PARTITION_DATA_START   L"<adma-partition-data>"
#define ADMA_PARTITION_DATA_END     L"</adma-partition-data>"
#define IS_DOMAIN                   L"<is-domain>1</is-domain>"
#define DN_START                    L"<dn>"
#define DN_END                      L"</dn>"
#define GUID_START                  L"<guid>{"
#define GUID_END                    L"}</guid>"
#define CREATION_TIME_START         L"<creation-time>"
#define CREATION_TIME_END           L"</creation-time>"
#define LAST_MODIFICATION_TIME_START    L"<last-modification-time>"
#define LAST_MODIFICATION_TIME_END  L"</last-modification-time>"
#define FILTER_START                L"<filter>"
#define FILTER_END                  L"</filter>"
#define OBJECT_CLASSES_START        L"<object-classes>"
#define OBJECT_CLASSES_END          L"</object-classes>"
#define OBJECT_CLASS_START          L"<object-class>"
#define OBJECT_CLASS_END            L"</object-class>"
#define CONTAINERS_START            L"<containers>"
#define CONTAINERS_END              L"</containers>"
#define EXCLUSIONS_START            L"<exclusions>"
#define EXCLUSIONS_END              L"</exclusions>"
#define EXCLUSION_START             L"<exclusion>"
#define EXCLUSION_END               L"</exclusion>"
#define INCLUSIONS_START            L"<inclusions>"
#define INCLUSIONS_END              L"</inclusions>"
#define INCLUSION_START             L"<inclusion>"
#define INCLUSION_END               L"</inclusion>"

    ULONG i, j;
    ULONG nPartitions;
    PPARTITION_INFORMATION PartitionInfo;

    ReadPartitionInformation(
        ForestInformation->Connection,
        &nPartitions,
        &PartitionInfo
        );

    WriteStringToMAFile( MA_PARTITION_DATA_START );

    for( i = 0; i < nPartitions; ++i ) {

        AD_OBJECT_CLASS ADClass;
        UUID Guid;
        PWSTR StringGuid;

        CREATE_GUID( &Guid );

        if( UuidToStringW( &Guid, &StringGuid ) ) {

            EXIT_WITH_ERROR( RunOutOfMemoryError );
        }

        WriteStringToMAFile( PARTITION_START );

            WriteStringToMAFile( ID_START );
            WriteStringToMAFile( StringGuid );
            WriteStringToMAFile( ID_END );

            RpcStringFreeW( &StringGuid );

            WriteStringToMAFile( VERSION_START );
            WriteStringToMAFile( L"0" );
            WriteStringToMAFile( VERSION_END );

            WriteStringToMAFile( SELECTED_START );
            WriteStringToMAFile( PartitionInfo[i].isDomain? L"1" : L"0" );
            WriteStringToMAFile( SELECTED_END );

            WriteStringToMAFile( NAME_START );
            WriteStringToMAFile( PartitionInfo[i].DN );
            WriteStringToMAFile( NAME_END );

            WriteStringToMAFile( CUSTOM_DATA_START );

                WriteStringToMAFile( ADMA_PARTITION_DATA_START );

                    if( PartitionInfo[i].isDomain ) {

                        WriteStringToMAFile( IS_DOMAIN );
                    }

                    WriteStringToMAFile( DN_START );
                    WriteStringToMAFile( PartitionInfo[i].DN );
                    WriteStringToMAFile( DN_END );

                    WriteStringToMAFile( NAME_START );
                    WriteStringToMAFile( PartitionInfo[i].DnsName );
                    WriteStringToMAFile( NAME_END );

                    if( UuidToStringW( &( PartitionInfo[i].GUID ), &StringGuid ) ) {

                        EXIT_WITH_ERROR( RunOutOfMemoryError );
                    }
                    WriteStringToMAFile( GUID_START );
                    WriteStringToMAFile( StringGuid );
                    WriteStringToMAFile( GUID_END );
                    RpcStringFreeW( &StringGuid );

                WriteStringToMAFile( ADMA_PARTITION_DATA_END );

            WriteStringToMAFile( CUSTOM_DATA_END );

            WriteStringToMAFile( CREATION_TIME_START );
            WriteStringToMAFile( CREATION_TIME_END );

            WriteStringToMAFile( LAST_MODIFICATION_TIME_START );
            WriteStringToMAFile( LAST_MODIFICATION_TIME_END );

            WriteStringToMAFile( FILTER_START );

                WriteStringToMAFile( OBJECT_CLASSES_START );

                    WriteStringToMAFile( OBJECT_CLASS_START );
                    WriteStringToMAFile( L"organizationalUnit" );
                    WriteStringToMAFile( OBJECT_CLASS_END );

                    for( ADClass = ADUser; ADClass < ADDummyClass; ++ADClass ) {

                        WriteStringToMAFile( OBJECT_CLASS_START );
                        WriteStringToMAFile( ADClassNames[ADClass] );
                        WriteStringToMAFile( OBJECT_CLASS_END );
                    }

                WriteStringToMAFile( OBJECT_CLASSES_END );

                WriteStringToMAFile( CONTAINERS_START );

                    WriteStringToMAFile( EXCLUSIONS_START );

                        for( j = 0; j < nPartitions; ++j ) {

                            PWSTR NextComponent;

                            if( i == j ) {

                                continue;
                            }

                            NextComponent = wcschr( PartitionInfo[j].DN, L',' );

                            if( NextComponent == NULL ||
                                wcscmp( NextComponent + 1, PartitionInfo[i].DN ) ) {

                                continue;
                            }

                            WriteStringToMAFile( EXCLUSION_START );

                            WriteStringToMAFile( PartitionInfo[j].DN );

                            WriteStringToMAFile( EXCLUSION_END );
                        }

                    WriteStringToMAFile( EXCLUSIONS_END );

                    WriteStringToMAFile( INCLUSIONS_START );

                        WriteStringToMAFile( INCLUSION_START );

                        WriteStringToMAFile( PartitionInfo[i].DN );

                        WriteStringToMAFile( INCLUSION_END );

                    WriteStringToMAFile( INCLUSIONS_END );

                WriteStringToMAFile( CONTAINERS_END );

            WriteStringToMAFile( FILTER_END );

        WriteStringToMAFile( PARTITION_END );

    }

    WriteStringToMAFile( MA_PARTITION_DATA_END );

    FreePartitionInformation(
        nPartitions,
        PartitionInfo
        );
}

VOID
WriteMAXMLFile(
    IN PMA MA,
    IN PWSTR Header
    )
/*++

Routine Description:

    This function creates an MA file using the information in MA parameter. Header
    is the string that must be present in the beginning of the file. It currently
    contains servername and the time it is generated.

Arguments:

    MA - information of the MA for which the file is going to be generated.

    Header - this is the string to be placed in the begining of the file

Return Values:

    VOID

--*/
{
#define SAVED_MA_CONFIGRATIONS_END L"</saved-ma-configrations>"

    WCHAR FileName[_MAX_PATH + 1];
    HANDLE MAFile;
    BOOL NoError;
    ULONG BytesWritten;
    PWSTR MAPosition;

    wcscpy( FileName, FolderName );
    wcscat( FileName, L"\\" );
    wcscat( FileName, MA->MAName );
    wcscat( FileName, L".xml" );

    //
    // Change saved-mv-configrations to saved-ma-configrations
    //
    MAPosition = StrStrIW( Header, L"-mv-" );

    if( MAPosition != NULL ) {

        MAPosition[2] = 'a';
    }

    MAFile = CreateFileW(
                FileName,               // file name
                GENERIC_WRITE,          // access mode
                FILE_SHARE_READ,        // share mode
                NULL,                   // SD
                CREATE_ALWAYS,          // how to create
                FILE_ATTRIBUTE_NORMAL,  // file attributes
                NULL                    // handle to template file
                );

    if( MAFile == INVALID_HANDLE_VALUE ) {

        EXIT_WITH_ERROR( MAFileError )
    }


    NoError = WriteFile(
                MAFile,         // handle to file
                Header,         // data buffer
                wcslen( Header ) * sizeof( WCHAR ),// number of bytes to write
                &BytesWritten,  // number of bytes written
                NULL            // overlapped buffer
                );

    if( !NoError || wcslen( Header ) * sizeof( WCHAR ) != BytesWritten ) {

        EXIT_WITH_ERROR( CannotWriteToMVFile )
    }

    fwprintf( OutputStream,  L"**************************\n"
             L"Creating the required XML file is not yet fully implemented\n"
             L"**************************\n");

    WriteMAData( MAFile, MA );

    WriteSchema( MAFile, MA );

    WriteAttributeInclusions( MAFile, MA->UnSelectedAttributes );

    WritePrivateConfiguration( MAFile, &( MA->ForestInformation ) );

    WriteMAUISettings( MAFile, MA );

    WriteProjection( MAFile );

    WriteExportAttributeFlow( MAFile );

    WriteDisconnectorPCleanupAndExtension( MAFile );

    WritePartitionData( MAFile, &( MA->ForestInformation ) );

    WriteRunProfile( MAFile );

    WriteStringToMAFile( SAVED_MA_CONFIGRATIONS_END );

    CloseHandle( MAFile );
}

VOID
WriteInformationToReg(
    IN PFOREST_INFORMATION ForestInformation
    )
/*++

Routine Description:

    This function creates a reg key for the forest under ParentRegKey. Under that
    it places the following information that are gathered from user;

        MMSSyncedDataOU
        ContactOU
        SMTPMailDomains

Arguments:

    ForestInformation - information about the forest for which the reg key is going to
        be generated

Return Values:

    VOID

--*/
{
#define LENGTH_OF_STRING( String )  \
    ( ( String == NULL || (String)[0] == 0 ) ? 0 : ( wcslen( String ) + 1 ) * sizeof( WCHAR ) )

    static const PWSTR ParentRegKey = MMS_REG_KEY L"\\MMSServer\\MMSGALSync\\";
    HKEY KeyHandle;
    LONG Status;
    ULONG Disposition;
    PWSTR RegKey;
    ULONG SizeOfRegKey;
    LONG IgnoreStatus;


    SizeOfRegKey = wcslen( ParentRegKey ) + wcslen( ForestInformation->ForestName ) + wcslen( L"GALADMA" ) + 1;
    ALLOCATE_MEMORY( RegKey, SizeOfRegKey );

    wcscpy( RegKey, ParentRegKey );
    wcscat( RegKey, ForestInformation->ForestName );
    wcscat( RegKey, L"GALADMA" );

    Status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE, // handle to open key
                RegKey,             // subkey name
                0,                  // reserved
                NULL,               // class string
                0,                  // special options
                KEY_SET_VALUE,      // desired security access
                NULL,               // inheritance
                &KeyHandle,         // key handle
                &Disposition        // disposition value buffer
                );

    FREE_MEMORY( RegKey );

    if( Status != ERROR_SUCCESS ) {

        return;
    }

    IgnoreStatus = RegSetValueExW(
                        KeyHandle,              // handle to key
                        L"MMSSynchronizedOU",   // value name
                        0,                      // reserved
                        REG_SZ,                 // value type
                        ( CONST BYTE * ) ForestInformation->MMSSyncedDataOU,    // value data
                        LENGTH_OF_STRING( ForestInformation->MMSSyncedDataOU )  // size of value data
                        );

    IgnoreStatus = RegSetValueExW(
                        KeyHandle,
                        L"ContactsSyncSourceOU",
                        0,
                        REG_SZ,
                        ( CONST BYTE * ) ForestInformation->ContactOU,
                        LENGTH_OF_STRING( ForestInformation->ContactOU )
                        );

    IgnoreStatus = RegSetValueExW(
                        KeyHandle,
                        L"MailDomain",
                        0,
                        REG_MULTI_SZ,
                        ( CONST BYTE * ) ForestInformation->SMTPMailDomains,
                        ForestInformation->SMTPMailDomainsSize
                        );

    IgnoreStatus = RegCloseKey( KeyHandle );
}

VOID
WriteOutput(
    IN MA_LIST MAList
    )
/*++

Routine Description:

    This function will write the output for the whole tool, one MV file and per each forest
    one MA file and a reg key. Any failure at this stage is fatal and the program
    will be aborted.

Arguments:

    MAList - List of MAs for which the output is going to be created

Return Values:

    VOID

--*/
{
    PMA_LIST_ELEMENT MAListElement = MAList;
    PWSTR Header;

    WriteMVXMLFile( MAList, &Header );

    while( MAListElement != NULL ) {

        WriteInformationToReg( &( MAListElement->MA.ForestInformation ) );
        WriteMAXMLFile( &( MAListElement->MA ), Header );

        MAListElement = MAListElement->NextElement;
    }

    FREE_MEMORY( Header );
}

BOOLEAN
MMSServerInstalled(
    )
/*++

Routine Description:

    This function checks if the machine has MMS Server installed. To do this check
    it checks the reg for a certain key namely MMS_REG_KEY.

Arguments:

    VOID

Return Values:

    TRUE - MMS Server is installed

    FALSE - MMS Server is not installed or cannot check if it is installed or not.

--*/
{
    LONG Result;
    HKEY RegKey;

    Result = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE, // handle to open key
                MMS_REG_KEY,    // subkey name
                0,              // reserved
                KEY_READ,       // security access mask
                &RegKey          // handle to open key
                );

    if( Result == ERROR_SUCCESS ) {

        LONG IgnoreStatus;

        IgnoreStatus = RegCloseKey( RegKey );

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\galsync\texts.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    texts.h

Abstract:

    This file contains all text related functions and variables. Also memory
    management functions (ALLOCATE_MEMORY, FREE_MEMORY ) in this file should
    be used in the project.

Author:

    Umit AKKUS (umita) 15-Jun-2002

Environment:

    User Mode - Win32

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

extern FILE *OutputStream;
extern FILE *InputStream;

//
// This enum type indexes Text array
//

typedef enum {
    Usage,
    InvalidSwitch,
    SkipMMSInstallationCheck,
    MMSServerNotInstalled,
    RunOutOfMemoryError,
    ForestNameRequest,
    DomainNameRequest,
    MMSUserNameRequest,
    PasswordRequest,
    MMSSyncedDataOURequest,
    MMSSyncedDataOUNotFoundQuestion,
    CreateMMSSyncedDataOURequest,
    MMSAccountDoesntHaveRights,
    XMLFoldernameRequest,
    XMLFolderDoesntExistQuestion,
    CannotCreateDirectory,
    UserAttributesToSync,
    UserAttributesToSyncQuestion,
    GroupAttributesToSync,
    GroupAttributesToSyncQuestion,
    ContactsToBeExportedQuestion,
    ContactsOULocationRequest,
    ContactsOUNotFoundQuestion,
    ContactAttributesToSync,
    ContactAttributesToSyncQuestion,
    SMTPMailDomainsRequest,
    ConfigurationTitle,
    MANameTitle,
    ForestNameTitle,
    UserNameTitle,
    MMSSyncedDataOUTitle,
    NoMMSSyncedDataOU,
    UserAttributesTitle,
    GroupAttributesTitle,
    ContactAttributesTitle,
    ContactOUTitle,
    NoContactOU,
    EnteredInformationCorrectQuestion,
    WantToConfigureAnotherForestQuestion,
    SetupMAsQuestion,
    SetupMAsWarning,
    AvailableMAs,
    TemplateMARequest,
    YouAreFinished,
    New,
    InvalidInput,
    CantCreateGUID,
    MVTemplateFileError,
    CannotReadFromTemplateFile,
    CannotWriteToMVFile,
    CorruptedTemplateFile,
    MAFileError,
    CannotWriteToMAFile,
    DummyTextIndex
} TEXT_INDEX;

extern PWSTR Text[];

#define PRINT( String ) \
    fwprintf( OutputStream, L"%s", String )

#define PRINTLN( String ) \
    fwprintf( OutputStream, L"%s\n", String )

#define OUTPUT_TEXT( Index )    \
    PRINT( Text[Index] )

#define EXIT_WITH_ERROR( Index )        \
{                                       \
    OUTPUT_TEXT( Index );               \
    PRINT( L"Therefore exiting\n" );    \
    exit( 1 );                          \
}

#define EXIT_IF_NULL( Pointer )                 \
    if( Pointer == NULL ) {                     \
        EXIT_WITH_ERROR( RunOutOfMemoryError )  \
    }

#define ALLOCATE_MEMORY( Pointer, Size )    \
{                                           \
    Pointer = malloc( Size );               \
    EXIT_IF_NULL( Pointer )                 \
}

#define FREE_MEMORY( Pointer )  \
    free( Pointer )

#define DUPLICATE_STRING( Dest, Src )   \
{                                       \
    Dest = _wcsdup( Src );              \
    EXIT_IF_NULL( Dest )                \
}

VOID
GetInformationFromConsole(
    IN TEXT_INDEX Index,
    IN BOOLEAN EmtpyStringAllowed,
    OUT PWSTR *Output
    );

BOOLEAN
GetAnswerToAYesNoQuestionFromConsole(
    IN TEXT_INDEX Index
    );

VOID
GetOUFromConsole(
    IN TEXT_INDEX Index,
    OUT PWSTR *Output
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\gpfixup\appfixup.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2002.
//
//  File:       appfixup.cpp
//
//  Contents:   Implementation of the software installation fixup
//                  portion of the gpfixup tool
//
//
//  History:    9-14-2001  adamed   Created
//
//---------------------------------------------------------------------------


#include "gpfixup.h"

PFNCSGETCLASSSTOREPATH        gpfnCsGetClassStorePath;
PFNCSSERVERGETCLASSSTORE      gpfnCsServerGetClassStore;
PFNRELEASEPACKAGEINFO         gpfnReleasePackageInfo;
PFNRELEASEPACKAGEDETAIL       gpfnReleasePackageDetail;
PFNCSSETOPTIONS               gpfnCsSetOptions;
PFNGENERATESCRIPT             gpfnGenerateScript;

//---------------------------------------------------------------------------- 
// Function:   InitializeSoftwareInstallationAPI                               
//                                                                             
// Synopsis:   This function loads the dlls for software installation group     
//                 policy and binds to the required api's                      
//                                                                             
// Arguments:                                                                  
//                                                                             
// pHinstDll   out parameter for dll hinstance used to unload the dll --       
//                caller should use this in a call to FreeLibrary to unload it 
//                                                                             
// Returns:    S_OK on success, other failure hresult otherwise                
//                                                                             
// Modifies:   pHinstDll                                                       
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
InitializeSoftwareInstallationAPI(
    HINSTANCE* pHinstAppmgmt,
    HINSTANCE* pHinstAppmgr
    )
{
    HINSTANCE hInstAppmgmt;
    HINSTANCE hInstAppmgr;

    HRESULT   hr;

    hr = S_OK;

    gpfnCsGetClassStorePath = NULL;
    gpfnCsServerGetClassStore = NULL;
    gpfnReleasePackageInfo = NULL;
    gpfnReleasePackageDetail = NULL;
    gpfnGenerateScript = NULL;
    gpfnCsSetOptions = NULL;

    hInstAppmgr = NULL;

    hInstAppmgmt = LoadLibrary(L"appmgmts.dll");

    if ( ! hInstAppmgmt )
    {
        goto error;
    }

    hInstAppmgr = LoadLibrary(L"appmgr.dll");

    if ( ! hInstAppmgr )
    {
        goto error;
    }

    //
    // Attempt to bind to all the entry points -- note that we
    // abort as soon as there's a failure to ensure that last error
    // is set correctly.
    //

    if ( hInstAppmgmt && hInstAppmgr )
    {
        gpfnCsGetClassStorePath = (PFNCSGETCLASSSTOREPATH)
            GetProcAddress( hInstAppmgmt, "CsGetClassStorePath" );

        if ( gpfnCsGetClassStorePath )
        {
            gpfnCsServerGetClassStore = (PFNCSSERVERGETCLASSSTORE) 
                GetProcAddress( hInstAppmgmt, "CsServerGetClassStore" );
        }

        if ( gpfnCsServerGetClassStore )
        {
            gpfnReleasePackageInfo = (PFNRELEASEPACKAGEINFO) 
                GetProcAddress( hInstAppmgmt, "ReleasePackageInfo" );
        }

        if ( gpfnReleasePackageInfo )
        {
            gpfnReleasePackageDetail = (PFNRELEASEPACKAGEDETAIL) 
                GetProcAddress( hInstAppmgmt, "ReleasePackageDetail" );
        }

        if ( gpfnReleasePackageDetail )
        {
            gpfnCsSetOptions = (PFNCSSETOPTIONS) 
                GetProcAddress( hInstAppmgmt, "CsSetOptions" );
        }

        if ( gpfnCsSetOptions )
        {
            gpfnGenerateScript = (PFNGENERATESCRIPT)
                GetProcAddress( hInstAppmgr, "GenerateScript" );
        }
    }

error:

    if ( ! gpfnCsGetClassStorePath ||
         ! gpfnCsServerGetClassStore ||
         ! gpfnReleasePackageInfo ||
         ! gpfnReleasePackageDetail ||
         ! gpfnCsSetOptions ||
         ! gpfnGenerateScript )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        if ( SUCCEEDED(hr) )
        {
            hr = E_FAIL;
        }

        if ( hInstAppmgmt )
        {
            FreeLibrary( hInstAppmgmt );
            
            hInstAppmgmt = NULL;
        }

        if ( hInstAppmgr )
        {
            FreeLibrary( hInstAppmgr );
            
            hInstAppmgr = NULL;
        }
    }

    *pHinstAppmgmt = hInstAppmgmt;
    *pHinstAppmgr = hInstAppmgr;

    if ( FAILED(hr) )
    {
        fwprintf(stderr, SI_DLL_LOAD_ERROR);
    }

    //
    // Ensure that software installation api's
    // use administrative tool settings for
    // communication with the directory
    //
    if ( SUCCEEDED(hr) )
    {
        gpfnCsSetOptions( CsOption_AdminTool );
    }

    return hr;
}

//---------------------------------------------------------------------------- 
// Function:   GetDomainDNFromDNSName
// Synopsis:   Returns the DN from the DNS Name
//                                                                               
//                                                                             
// Returns:    S_OK on success, other error on failure                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
WCHAR*
GetDomainDNFromDNSName(
    WCHAR* wszDnsName
    )
{
    DWORD  cElements;
    WCHAR* wszCurrent;

    cElements = 0;
    wszCurrent = wszDnsName;
    
    do
    {
        cElements++;

        wszCurrent = wcschr( wszCurrent, L'.' );

    } while ( wszCurrent++ );

    DWORD cDNLength;

    cDNLength = wcslen( wszDnsName ) + cElements * DNDCPREFIXLEN;

    size_t cchDN = cDNLength + 1;
    WCHAR* wszDN = new WCHAR [cchDN];

    if ( wszDN )
    {
        HRESULT hr = S_OK;
        size_t cchContainer = cchDN;
        WCHAR* wszContainer = wszDN;

        wszCurrent = wszDnsName;

        for ( DWORD iCurrent = 0; iCurrent < cElements; iCurrent++ )
        {
            hr = StringCchCopy( wszContainer, cchContainer, DNDCPREFIX ); 
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
            hr = StringCchCat( wszContainer, cchContainer, wszCurrent ); 
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

            WCHAR* wszNext;

            wszNext = wcschr( wszCurrent, L'.' );

            //
            // Also check *wszContainer to handle the case where 
            // the last character is a "." -- because
            // we iterate one past each time through the loop, we have to
            // check to see if we're already at the end of the string
            // 

            if ( wszNext && *wszContainer )
            {
                wszContainer = wcschr( wszContainer, L'.' );

                if ( ! wszContainer )
                {
                    goto error;
                }

                cchContainer = cchDN - (wszContainer - wszDN);

                *wszContainer = L',';
                wszContainer++;
                wszNext++;

                if ( cchContainer == 0 )
                {
                    goto error;
                }
            }

            wszCurrent = wszNext;
        }
    }

    return wszDN;

error:
    delete [] wszDN;
    return 0;
}




//---------------------------------------------------------------------------- 
// Function:   GetDomainFromFileSysPath                                        
// Synopsis:   Returns the name of the domain in a domain dfs path             
// Arguments:                                                                  
//                                                                               
// wszPath:     a domain-based dfs path                                        
// ppwszDomain: out parameter allocated by this function containing            
//                  the name of the domain, must be freed by caller.           
//                  If the path is not a domain-based dfs, this is NULL,       
//                  and the function still returns success.                    
//                  If this is NULL then only the subpath is returned          
// ppwszSubpath: out parameter not allocated by this function containing the   
//                  subpath after the domain name, including preceding '\'     
//                  if this is NULL on return, this was not a domain based dfs 
//                                                                             
// Returns:    S_OK on success, other error on failure                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT
GetDomainFromFileSysPath(
    WCHAR*  wszPath,
    WCHAR** ppwszDomain,
    WCHAR** ppwszSubPath
    )
{
    HRESULT hr;

    hr = S_OK;

    *ppwszDomain = NULL;
    *ppwszSubPath = NULL;

    //
    // Check to see if this starts with leading unc path chars --
    // if not, this is no a path we can fix
    //
    if ( 0 == wcsncmp(L"\\\\", wszPath, 2) )
    {
        WCHAR* wszDomainEnd;

        wszDomainEnd = wcschr( wszPath + 2, L'\\' );

        if ( wszDomainEnd )
        {
            DWORD cDomainLength;

            cDomainLength = (DWORD) (wszDomainEnd - wszPath);

            *ppwszDomain = new WCHAR [ cDomainLength + 1 ];

            if ( *ppwszDomain )
            {
                DWORD iCurrent;

                for ( iCurrent = 0; iCurrent < cDomainLength; iCurrent++ )
                {
                    (*ppwszDomain)[iCurrent] = wszPath[iCurrent];
                }

                (*ppwszDomain)[iCurrent] = L'\0';

                *ppwszSubPath = wszDomainEnd;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    }

    return hr;
}

//---------------------------------------------------------------------------- 
// Function:   GetRenamedDomainName                                            
// Synopsis:   Returns the new name for a domain name                          
// Arguments:                                                                  
//                                                                               
// argInfo         Information user passes in through command line             
// wszDomain:      the current name of a domain                                
//                  that contains the new domain name for this domain          
//                                                                             
// Returns:    NULL if there is no new name for this domain, otherwise         
//             a string that contains the new name of the domain.              
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
WCHAR*
GetRenamedDomain(
    const ArgInfo* pargInfo,
          WCHAR*   wszDomain)
{
    if ( pargInfo->pszOldDNSName && 
         ( 0 == _wcsicmp( pargInfo->pszOldDNSName, wszDomain ) ) )
    {
        return pargInfo->pszNewDNSName;
    }
    else if ( pargInfo->pszOldNBName && 
              ( 0 == _wcsicmp( pargInfo->pszOldNBName, wszDomain ) ) )
    {
        return pargInfo->pszNewNBName;
    }

    return NULL;
}



//---------------------------------------------------------------------------- 
// Function:   GetDNSServerName
// Synopsis:   Returns the new name for a server with a dns name
// Arguments:                                                                  
//                                                                               
// argInfo         Information user passes in through command line             
// wszServerName:  
//
//                                                                             
// Returns:    NULL if there is no new dns name for this server, otherwise         
//             a string that contains the new name of the domain.              
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
GetRenamedDNSServer(
    const ArgInfo* pargInfo,
          WCHAR*   wszServerName,
          WCHAR**  ppwszNewServerName)
{
    HRESULT hr;

    hr = S_OK;

    *ppwszNewServerName = NULL;

    if ( pargInfo->pszNewDNSName )
    {
        DWORD  cServerLen;
        DWORD  cOldDomainLen;

        cServerLen = wcslen( wszServerName );

        cOldDomainLen = wcslen( pargInfo->pszOldDNSName );

        if ( cServerLen > ( cOldDomainLen + 1 ) )
        {
            WCHAR* wszDomainSuffix;

            wszDomainSuffix = wszServerName + ( cServerLen - cOldDomainLen ) - 1;

            if ( L'.' == *wszDomainSuffix )
            {
                size_t cchNewServerName = ( cServerLen - cOldDomainLen - 1 ) + 
                                            1 + 
                                            wcslen( pargInfo->pszNewDNSName ) + 1;
                *ppwszNewServerName = new WCHAR [cchNewServerName];

                if ( ! *ppwszNewServerName )
                {
                    hr = E_OUTOFMEMORY;

                    BAIL_ON_FAILURE(hr);
                }

                wcsncpy( *ppwszNewServerName, 
                         wszServerName,
                         cServerLen - cOldDomainLen - 1 );

                (void) StringCchCopy( *ppwszNewServerName + cServerLen - cOldDomainLen - 1,
                               2,
                               L"." );

                (void) StringCchCat( *ppwszNewServerName, cchNewServerName, pargInfo->pszNewDNSName );
            }
        }
    }

error:

    return hr;
}


//---------------------------------------------------------------------------- 
// Function:   GetNewDomainSensitivePath
//                                                                             
// Synopsis:   Transforms a domain-based dfs path to have the new domain name  
//
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo      Information user passes in through command line                
// wszPath      old domain-based dfs path
// ppwszNewPath new domain-based dfs path -- must be freed by caller           
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
GetNewDomainSensitivePath(
    const ArgInfo* pargInfo,
          WCHAR*   wszPath,
          BOOL     bRequireDomainDFS,
          WCHAR**  ppwszNewPath)
{
    HRESULT hr;
    WCHAR*  wszDomain;
    WCHAR*  wszSubPath;
    WCHAR*  wszServerName;
    DWORD   cUncPrefixLen;
    BOOL    bHasQuotes;
    BOOL    bDomainBasedPath;

    *ppwszNewPath = NULL;

    wszDomain = NULL;

    bDomainBasedPath = TRUE;

    //
    // First, skip white space
    //
    while ( L' ' == *wszPath  )
    {
        wszPath++;
    }

    bHasQuotes = L'\"' == *wszPath;

    wszServerName = wszPath;

    if ( bHasQuotes )
    {
        wszServerName++;

        while ( L' ' == *wszServerName  )
        {
            wszServerName++;
        }
    }

    cUncPrefixLen = UNCPREFIXLEN + ( bHasQuotes ? 1 : 0 );

    hr = GetDomainFromFileSysPath(
        wszServerName,
        &wszDomain,
        &wszSubPath);

    BAIL_ON_FAILURE(hr);

    WCHAR* wszNewDomain;

    wszNewDomain = NULL;

    if ( wszDomain )
    {
        wszNewDomain = GetRenamedDomain(
            pargInfo,
            wszDomain + UNCPREFIXLEN );
    }

    if ( wszNewDomain )
    {
        wszServerName = wszNewDomain;
    }
    else if ( ! bRequireDomainDFS )
    {   
        hr = GetRenamedDNSServer(
            pargInfo,
            wszDomain + UNCPREFIXLEN,
            &wszNewDomain );

        BAIL_ON_FAILURE(hr);

        bDomainBasedPath = FALSE;

        wszServerName = wszNewDomain;
    }

    if ( wszDomain )
    {
        DWORD  cLengthNewPath;
        DWORD  cLengthSysvol;
        WCHAR* wszJunction;

        cLengthSysvol = 0;
        wszJunction = L"";

        if ( 
             pargInfo->pszOldDNSName &&
             bDomainBasedPath && 
             ( 0 == _wcsnicmp(
                 SYSVOLSHAREPATH,
                 wszSubPath,
                 SYSVOLPATHLENGTH) )
           )
        {
            //
            // This path has sysvol in it, we may need to
            // repair the junction name to contain the dns name --
            // we check for a dns name with the old junction name
            // below
            //

            if ( pargInfo->pszOldDNSName && 
                   ( 0 == _wcsnicmp(
                    wszSubPath + SYSVOLPATHLENGTH,
                    pargInfo->pszOldDNSName,
                    wcslen( pargInfo->pszOldDNSName )
                    ) )
               )
            {
                //
                // We know now that the dns name is contained in the 
                // junction, but the user may have specified a partial dns name
                // and thus right now we only know that we have part of the junction.
                // We should verify that this dns name is the entire junction name, which means
                // this is the full dns name and we can continue to fix the junction
                //

                //
                // To do this, we check for a path separator after the point at which we feel
                // the junction path ends
                //

                if ( L'\\' == *( wszSubPath + SYSVOLPATHLENGTH + wcslen( pargInfo->pszOldDNSName ) ) )
                {
                    //
                    // This path contains the old junction name, we
                    // repair this below
                    //

                    cLengthSysvol = SYSVOLPATHLENGTH;

                    wszJunction = pargInfo->pszNewDNSName;

                    wszSubPath += cLengthSysvol + wcslen(pargInfo->pszOldDNSName);
                }
            }
        }
        
        if ( cLengthSysvol || wszNewDomain )
        {
            cLengthNewPath = 
                cUncPrefixLen +
                wcslen( wszServerName ) +
                cLengthSysvol +
                wcslen( wszJunction ) +
                wcslen( wszSubPath ) + 1;

            *ppwszNewPath = (WCHAR*) LocalAlloc( LPTR, sizeof(WCHAR) * cLengthNewPath );

            if ( ! *ppwszNewPath )
            {
                hr = E_OUTOFMEMORY;

                BAIL_ON_FAILURE(hr);
            }

            if ( bHasQuotes )
            {
                (void) StringCchCopy( *ppwszNewPath, cLengthNewPath, L"\"\\\\");
            }
            else
            {
                (void) StringCchCopy( *ppwszNewPath, cLengthNewPath, L"\\\\" );
            }
            
            (void) StringCchCat( *ppwszNewPath, cLengthNewPath, wszServerName );

            if ( cLengthSysvol )
            {
                (void) StringCchCat( *ppwszNewPath, cLengthNewPath, SYSVOLSHAREPATH );
            }

            (void) StringCchCat( *ppwszNewPath, cLengthNewPath, wszJunction );
            (void) StringCchCat( *ppwszNewPath, cLengthNewPath, wszSubPath );
        }
    }

error:

    if ( ! bDomainBasedPath )
    {
        delete [] wszNewDomain;
    }

    delete [] wszDomain;

    return hr;
}


//---------------------------------------------------------------------------- 
// Function:   GetNewUpgradeList
//                                                                             
// Synopsis:   This function updates the ldap paths in the upgrade list
//                 to reflect the new domain name
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo            Information user passes in through command line           
// cUpgrades          The number of upgrades in the upgrade vector
// prgUpgradeInfoList A vector of upgrades that contain ldap paths that
//                       need to be updated -- on input, this contains
//                       the old paths, on output it will contain new paths
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
GetNewUpgradeList(
    const ArgInfo*        pargInfo,
          DWORD           cUpgrades,
          UPGRADEINFO*    prgUpgradeInfoList
    )
{
    HRESULT hr;
    WCHAR*  wszNewDomainDN;
    WCHAR*  wszOldDomainDN;
    BOOL    bChangedUpgrades;

    hr = S_OK;

    bChangedUpgrades = TRUE;

    wszNewDomainDN = NULL;
    wszOldDomainDN = NULL;

    if ( cUpgrades )
    {
        wszNewDomainDN = GetDomainDNFromDNSName( pargInfo->pszNewDNSName );

        wszOldDomainDN = GetDomainDNFromDNSName( pargInfo->pszOldDNSName );

        if ( ! wszOldDomainDN || ! wszNewDomainDN )
        {
            hr = E_OUTOFMEMORY;

            BAIL_ON_FAILURE(hr);
        }
    }

    for ( DWORD iCurrent = 0; iCurrent < cUpgrades; iCurrent++ )
    {
        DWORD cOldDNLength;
        DWORD cOldDomainDNLength;

        cOldDNLength = wcslen( prgUpgradeInfoList[ iCurrent ].szClassStore );

        cOldDomainDNLength = wcslen (wszOldDomainDN);

        if ( cOldDNLength < cOldDomainDNLength )
        {
            hr = E_INVALIDARG;

            BAIL_ON_FAILURE(hr);
        }

        WCHAR* wszUpgradeDomainDN;

        wszUpgradeDomainDN = prgUpgradeInfoList[ iCurrent ].szClassStore + cOldDNLength - cOldDomainDNLength;

        if ( 0 == _wcsicmp( wszOldDomainDN, wszUpgradeDomainDN ) )
        {
            DWORD cNewDNLength;

            cNewDNLength = cOldDNLength + wcslen( wszNewDomainDN );

            WCHAR* wszNewUpgradeDN;

            wszNewUpgradeDN = (WCHAR*) LocalAlloc( LPTR, sizeof(WCHAR) * ( cNewDNLength + 1 ) );

            if ( wszNewUpgradeDN )
            {
                *wszUpgradeDomainDN = L'\0';

                (void) StringCchCopy( wszNewUpgradeDN, cNewDNLength + 1, prgUpgradeInfoList[ iCurrent ].szClassStore );
                (void) StringCchCat( wszNewUpgradeDN, cNewDNLength + 1, wszNewDomainDN );

                LocalFree( prgUpgradeInfoList[ iCurrent ].szClassStore );
                
                prgUpgradeInfoList[ iCurrent ].szClassStore = wszNewUpgradeDN;

                bChangedUpgrades = TRUE;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        BAIL_ON_FAILURE(hr);
    }

    if ( SUCCEEDED(hr) && ! bChangedUpgrades )
    {
        hr = S_FALSE;
    }

error:

    delete [] wszNewDomainDN;
    delete [] wszOldDomainDN;

    return hr;
}


//---------------------------------------------------------------------------- 
// Function:   GetNewSourceList
//                                                                             
// Synopsis:   This function determines the new sourcelist for a package
//                 based on the old sourcelist  and the new domain name          
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo     Information user passes in through command line           
// cSources    The number of sources in the list
// pSources    Contains the old sourcelist on input, contains new sources on output
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
GetNewSourceList(
    const ArgInfo*   pargInfo,
          DWORD      cSources,
          LPOLESTR*  pSources,
          LPOLESTR** ppOldSources
    )
{
    HRESULT  hr;
    BOOL     bChangedSourceList;

    hr = S_OK;

    bChangedSourceList = FALSE;

    //
    // If there are no sources, then there's nothing to do --
    // currently, no sources is not a valid configuration anyway.
    //
    if ( 0 == cSources )
    {
        return S_OK;
    }

    *ppOldSources = (LPOLESTR*) LocalAlloc( LPTR, cSources * sizeof(LPOLESTR) );

    if ( ! *ppOldSources )
    {
        hr = E_OUTOFMEMORY;

        BAIL_ON_FAILURE(hr);
    }

    DWORD iCurrent;
    size_t cchOldSource = 0;

    memset( *ppOldSources, 0, cSources * sizeof(LPOLESTR) );

    for ( iCurrent = 0; iCurrent < cSources; iCurrent++ )
    {
        cchOldSource = wcslen( pSources[iCurrent] ) + 1;
        (*ppOldSources)[iCurrent] = (LPOLESTR) LocalAlloc( LPTR, sizeof(WCHAR) * cchOldSource );

        if ( ! (*ppOldSources)[iCurrent] )
        {
            hr = E_OUTOFMEMORY;

            BAIL_ON_FAILURE(hr);
        }

        (void) StringCchCopy( (*ppOldSources)[iCurrent], cchOldSource, pSources[iCurrent] );
    }

    for ( iCurrent = 0; iCurrent < cSources; iCurrent++ )
    {
        WCHAR* wszNewPath;

        wszNewPath = NULL;

        hr = GetNewDomainSensitivePath(
            pargInfo,
            pSources[iCurrent],
            FALSE,
            &wszNewPath);

        BAIL_ON_FAILURE(hr);

        if ( wszNewPath )
        {
            LocalFree( pSources[ iCurrent ] );

            pSources[ iCurrent ] = (LPOLESTR) wszNewPath;

            bChangedSourceList = TRUE;
        }
    }

    BAIL_ON_FAILURE(hr);

    if ( ! bChangedSourceList )
    {
        hr = S_FALSE;
    }

error:

    if ( FAILED(hr) && *ppOldSources )
    {
        DWORD iSource;

        for ( iSource = 0; iSource < cSources; iSource++ )
        {
            LocalFree( (*ppOldSources)[iSource] );
        }

        LocalFree( *ppOldSources );

        *ppOldSources = NULL;
    }

    return hr;
}

//---------------------------------------------------------------------------- 
// Function:   GetServerBasedDFSPath
// Synopsis:   Given a serverless DFS path, returns a server based dfs path
//                                                                               
//                                                                             
// Returns:    S_OK on success, other error on failure                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
GetServerBasedDFSPath(
    WCHAR*  wszServerName,
    WCHAR*  wszServerlessPath,
    WCHAR** ppwszServerBasedDFSPath)
{
    DWORD  cchDomain = 0;
    WCHAR* wszSubPath = wszServerlessPath;

    *ppwszServerBasedDFSPath = NULL;

    while ( *wszSubPath )
    {    
        if ( L'\\' == *wszSubPath )
        {
            if ( cchDomain > UNCPREFIXLEN )
            {
                break;
            }
        }

        cchDomain++;
        wszSubPath++;
    }

    if ( cchDomain <= UNCPREFIXLEN )
    {
        return E_INVALIDARG;
    }
    
    DWORD cchPath = wcslen( wszServerlessPath ) + 1;

    //
    // The old path is in the form
    // 
    // \\<domainname>\<subpath>
    //
    // The new path should be in the form
    //
    // \\<servername>>\<subpath> where
    //
    //    
    
    //
    // Take out the length of the domain (which includes the unc prefix )
    //
    cchPath -= cchDomain;

    //
    // Now add in the uncprefix and server name
    //
    cchPath += UNCPREFIXLEN + wcslen( wszServerName );

    *ppwszServerBasedDFSPath = new WCHAR [ cchPath ];

    if ( ! * ppwszServerBasedDFSPath )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Build the path back by adding the uncprefix, server, and remainder
    //
    (void) StringCchCopy( *ppwszServerBasedDFSPath, cchPath, UNCPREFIX );
    (void) StringCchCat( *ppwszServerBasedDFSPath, cchPath, wszServerName );
    (void) StringCchCat( *ppwszServerBasedDFSPath, cchPath, wszSubPath );
    
    return S_OK;
}



//---------------------------------------------------------------------------- 
// Function:   FixDeployedSoftwareObjectSysvolData                             
//                                                                             
// Synopsis:   This function updates sysvol metadata for a deployed application       
//                 to reflect the new domain name                              
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo      Information user passes in through command line                 
// pPackageInfo structure representing the application to update
// fVerbose     flag indicating verbose output
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT 
FixDeployedSoftwareObjectSysvolData(
    const ArgInfo*  pargInfo,
    PACKAGEDETAIL*  pPackageDetails,
    WCHAR**         pOldSources,
    BOOL*           pbForceGPOUpdate,
    BOOL            fVerbose
    )
{
    HRESULT        hr;
 
    hr = S_OK;

    //
    // We attempt to regenerate the msi advertise script only if the following conditions hold:
    // 1. This is actually an msi app, and not some other app type (such as zap) -- only msi's have scripts to regenerate
    // 2. This application is not in the undeployed state (i.e. it is not in the orphan or uninstall states) -- for 
    //    such apps we only need the script to remove profile information that roamed to a machine where the app
    //    is not installed, and in that case the sdp does not need to be reachable since msi has everything
    //    it needs to remove the profile information in the script itself and will never access the sdp -- thus
    //    invalid references to the old sdp in the script do not need to be fixed up, and we will avoid fixing this
    //    in order to avoid failures in script fixup that do not matter and cannot be easily addressed by an
    //    admin anyway since undeployed apps do not even appear in the admin tools
    //
    if ( ( DrwFilePath == pPackageDetails->pInstallInfo->PathType ) && 
         ! ( ( ACTFLG_Orphan & pPackageDetails->pInstallInfo->dwActFlags ) ||
             ( ACTFLG_Uninstall & pPackageDetails->pInstallInfo->dwActFlags ) ) )
    {
        WCHAR* wszScriptPath = pPackageDetails->pInstallInfo->pszScriptPath;
        WCHAR* wszServerBasedPath = NULL;

        if ( pargInfo->pszDCName )
        {
            hr = GetServerBasedDFSPath(
                pargInfo->pszDCName,
                pPackageDetails->pInstallInfo->pszScriptPath,
                &wszServerBasedPath);

            BAIL_ON_FAILURE(hr);

            wszScriptPath = wszServerBasedPath;
        }
            
        hr = gpfnGenerateScript( pPackageDetails, wszScriptPath );

        delete [] wszServerBasedPath;
    }

    BAIL_ON_FAILURE(hr);

    //
    // We've regenerated the script, so now the application needs to
    // be reinstalled, so we must force the GPO to be updated
    // so that clients will see the changes
    //
    *pbForceGPOUpdate = TRUE;

error:
    
    if ( FAILED(hr) )
    {
        fwprintf(stderr, L"%s\n", SOFTWARE_SCRIPTGEN_WARNING);

        DWORD iSoftwareLocation;

        for ( iSoftwareLocation = 0; iSoftwareLocation < pPackageDetails->cSources; iSoftwareLocation++ )
        {
            WCHAR* wszNewLocation;
            WCHAR* wszOriginalLocation;

            wszNewLocation = pPackageDetails->pszSourceList[ iSoftwareLocation ];

            if ( ! wszNewLocation )
            {
                wszNewLocation = L"";
            }

            wszOriginalLocation = pOldSources[ iSoftwareLocation ];

            if ( ! wszOriginalLocation )
            {
                wszOriginalLocation = L"";
            }

            fwprintf(stderr, L"%s\n", SOFTWARE_SDP_LISTITEM);
            fwprintf(stderr, L"%s%s\n", SOFTWARE_SDP_ORIGINAL, wszOriginalLocation);
            fwprintf(stderr, L"%s%s\n", SOFTWARE_SDP_RENAMED, wszNewLocation);
        }

        fwprintf(stderr, L"%s%x\n", SOFTWARE_SYSVOL_WRITE_WARNING, hr);
        PrintGPFixupErrorMessage(hr);
    }

    return hr;
}


//---------------------------------------------------------------------------- 
// Function:   FixDeployedSoftwareObjectDSData                                 
//                                                                             
// Synopsis:   This function updates metadata for a deployed application       
//                 to reflect the new domain name                              
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo     Information user passes in through command line                 
// wszGPODN    Distinguished name of gpo containing the applications           
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT 
FixDeployedSoftwareObjectDSData(
    const ArgInfo*          pargInfo,
    const WCHAR*            wszGPOName,
          IClassAdmin*      pClassAdmin,
          PACKAGEDETAIL*    pPackageDetails,         
          BOOL*             pbForceGPOUpdate,
          BOOL              fVerbose
    )
{
    HRESULT   hr;
    WCHAR*    wszNewScriptPath;
    WCHAR*    wszOldScriptPath;
    LPOLESTR* pOldSources;

    hr = S_OK;

    pOldSources = NULL;

    wszOldScriptPath = pPackageDetails->pInstallInfo->pszScriptPath;

    if ( ! wszOldScriptPath )
    {
        hr = E_INVALIDARG;
    }

    BAIL_ON_FAILURE(hr);

    hr = GetNewDomainSensitivePath(
        pargInfo,
        wszOldScriptPath,
        TRUE,
        &wszNewScriptPath
        );

    BAIL_ON_FAILURE(hr);

    if ( wszNewScriptPath )
    {
        LocalFree( wszOldScriptPath );

        pPackageDetails->pInstallInfo->pszScriptPath = (LPOLESTR) wszNewScriptPath;
    }
    
    hr = GetNewSourceList(
            pargInfo,
            pPackageDetails->cSources,
            pPackageDetails->pszSourceList,
            &pOldSources
            );

    BAIL_ON_FAILURE(hr);

    BOOL bSourceListChanged;

    bSourceListChanged = S_OK == hr;

    if ( pargInfo->pszNewDNSName )
    {
        hr = GetNewUpgradeList(
            pargInfo,
            pPackageDetails->pInstallInfo->cUpgrades,
            pPackageDetails->pInstallInfo->prgUpgradeInfoList);

        BAIL_ON_FAILURE(hr);
    }

    BOOL bUpgradesChanged;
    BOOL bNewScriptNeeded;

    bUpgradesChanged = S_OK == hr;

    bNewScriptNeeded = bSourceListChanged;

    if ( ( DrwFilePath == pPackageDetails->pInstallInfo->PathType ) &&
         bNewScriptNeeded )
    {
        hr = FixDeployedSoftwareObjectSysvolData(
            pargInfo,
            pPackageDetails,
            pOldSources,
            pbForceGPOUpdate,
            fVerbose);

        if ( SUCCEEDED(hr) )
        {
            (pPackageDetails->pInstallInfo->dwRevision)++;
        }
        else
        {
            //
            // We will ignore this failure and continue the fixup -- this may have occurred
            // because the software distribution point of the package is located on a domain
            // name sensitive path and a new fixup is needed.  If that path is to a dc, dc's
            // do not get renamed as part of the domain rename, so it is non-fatal if the path
            // to the sdp is not regenerated.
            //

            hr = S_OK;

            //
            // Use the old set of sdp's since the new one failed
            //

            LPOLESTR* pNewSources;

            pNewSources = pPackageDetails->pszSourceList;

            pPackageDetails->pszSourceList = pOldSources;

            pOldSources = pNewSources;

            fwprintf(stderr, L"%s%s\n", SOFTWARE_SETTING_WARNING, pPackageDetails->pszPackageName );            
            fwprintf(stderr, L"%s%s\n", SOFTWARE_GPO_STATUS_WARNING, wszGPOName );            
        }
    }

    BAIL_ON_FAILURE(hr);

    if ( bNewScriptNeeded ||
         bUpgradesChanged )
    {
        pPackageDetails->pInstallInfo->dwActFlags |= ACTFLG_PreserveClasses;

        hr = pClassAdmin->RedeployPackage(
            &(pPackageDetails->pInstallInfo->PackageGuid),
            pPackageDetails);
    }

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

error:

    if ( FAILED(hr) )
    {
        fwprintf(stderr, L"%s%x\n", SOFTWARE_DS_WRITE_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
    }

    if ( pOldSources )
    {
        DWORD iCurrent;

        for ( iCurrent = 0; iCurrent < pPackageDetails->cSources; iCurrent++ )
        {
            LocalFree( pOldSources[iCurrent] );
        }

        LocalFree( pOldSources );
    }

    return hr;
}

//---------------------------------------------------------------------------- 
// Function:   FixDeployedApplication
//                                                                             
// Synopsis:   This function fixes the ds attributes and sysvol data of
//                 a deployed application
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo      Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
FixDeployedApplication(
    const ArgInfo*         pargInfo,
    const WCHAR*           wszGPOName,
          IClassAdmin*     pClassAdmin,
          PACKAGEDETAIL*   pPackageDetails,
          BOOL*            pbForceGPOUpdate,
          BOOL             fVerbose
    )
{
    HRESULT hr;

    hr = FixDeployedSoftwareObjectDSData(
        pargInfo,
        wszGPOName,
        pClassAdmin,
        pPackageDetails,
        pbForceGPOUpdate,
        fVerbose);

    BAIL_ON_FAILURE(hr);
    
error:

    if ( FAILED(hr) )
    {
        fwprintf(stderr, L"%s%s\n", SOFTWARE_SETTING_FAIL, pPackageDetails->pszPackageName );
        PrintGPFixupErrorMessage(hr);
    }

    return hr;
}

//---------------------------------------------------------------------------- 
// Function:   FixGPOSubcontainerSoftware
//                                                                             
// Synopsis:   This function searches for software installation ds objects     
//                 contained by a group policy container and calls a fixup     
//                 routine for each deployed software object                   
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo     Information user passes in through command line                 
// wszGPODN    Distinguished name of gpo containing the applications           
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT
FixGPOSubcontainerSoftware(
    const ArgInfo* pargInfo,
    const WCHAR*   wszGPODN,
    const WCHAR*   wszGPOName,
          BOOL     bUser,
          BOOL*    pbAppFailed,
          BOOL*    pbForceGPOUpdate,
          BOOL     fVerbose
    )
{
    IClassAdmin*   pClassAdmin;
    IEnumPackage*  pEnumPackage;
    LPOLESTR       wszClassStorePath;
    WCHAR*         wszSubcontainer;
    WCHAR*         wszPolicySubcontainerDNPath;
    HRESULT        hr;

    hr = S_OK;

    wszClassStorePath = NULL;
    wszPolicySubcontainerDNPath = NULL;

    pClassAdmin = NULL;
    pEnumPackage = NULL;

    *pbAppFailed = FALSE;

    if ( ! wszGPOName )
    {
        wszGPOName = wszGPODN;
    }

    if ( bUser )
    {
        wszSubcontainer = USERCONTAINERPREFIX;
    }
    else
    {
        wszSubcontainer = MACHINECONTAINERPREFIX;
    }

    DWORD cSubcontainerDNPathLength;

    cSubcontainerDNPathLength = wcslen( wszSubcontainer ) + wcslen( wszGPODN );

    wszPolicySubcontainerDNPath = new WCHAR [ cSubcontainerDNPathLength + 1 ];

    if ( ! wszPolicySubcontainerDNPath )
    {
        hr = E_OUTOFMEMORY;
    }

    BAIL_ON_FAILURE(hr);

    (void) StringCchCopy( wszPolicySubcontainerDNPath, cSubcontainerDNPathLength + 1, wszSubcontainer );
    (void) StringCchCat( wszPolicySubcontainerDNPath, cSubcontainerDNPathLength + 1, wszGPODN );
    
    hr = gpfnCsGetClassStorePath( (LPOLESTR) wszPolicySubcontainerDNPath, &wszClassStorePath );

    BAIL_ON_FAILURE(hr);

    hr = gpfnCsServerGetClassStore(
        pargInfo->pszDCName,
        wszClassStorePath,
        (LPVOID*) &pClassAdmin);

    if ( CS_E_OBJECT_NOTFOUND == hr )
    {
        hr = S_OK;
        goto exit_success;
    }

    BAIL_ON_FAILURE(hr);

    hr = pClassAdmin->EnumPackages(
        NULL,
        NULL,
        APPQUERY_ALL,
        NULL,
        NULL,   
        &pEnumPackage);

    if ( ( CS_E_OBJECT_NOTFOUND == hr ) ||
         ( CS_E_NO_CLASSSTORE == hr ) )
    {
        hr = S_OK;
        goto exit_success;
    }

    BAIL_ON_FAILURE(hr);

    while ( S_OK == hr )
    {
        ULONG           cRetrieved;
        PACKAGEDISPINFO PackageDispInfo;

        memset( &PackageDispInfo, 0, sizeof(PackageDispInfo) );

        hr = pEnumPackage->Next(
            1,
            &PackageDispInfo,
            &cRetrieved);

        if ( SUCCEEDED(hr) && ( 1 == cRetrieved ) )
        {
            PACKAGEDETAIL PackageDetails;

            memset( &PackageDetails, 0, sizeof(PackageDetails) );

            hr = pClassAdmin->GetPackageDetailsFromGuid( 
                PackageDispInfo.PackageGuid,
                &PackageDetails );            

            if ( SUCCEEDED(hr) )
            {
                HRESULT       hrApplication;

                hrApplication = FixDeployedApplication(
                    pargInfo,
                    wszGPOName,
                    pClassAdmin,
                    &PackageDetails,
                    pbForceGPOUpdate,
                    fVerbose);

                if ( FAILED(hrApplication) )
                {
                    *pbAppFailed = TRUE;
                }

                gpfnReleasePackageDetail( &PackageDetails );
            }

            gpfnReleasePackageInfo( &PackageDispInfo );
        }

        if ( FAILED(hr) )
        { 
            fwprintf(stderr, L"%s%x\n", SOFTWARE_READ_ERROR, hr );
            PrintGPFixupErrorMessage(hr);
        }
    }
    
    BAIL_ON_FAILURE(hr);

    if ( SUCCEEDED(hr) )
    {
        hr = S_OK;
    }

exit_success:

error:
    
    if ( pEnumPackage )
    {
        pEnumPackage->Release();
    }

    if ( pClassAdmin )
    {
        pClassAdmin->Release();
    }

    if ( wszClassStorePath )
    {
        LocalFree( wszClassStorePath );
    }
    
    delete [] wszPolicySubcontainerDNPath;

    return hr;
}


//---------------------------------------------------------------------------- 
// Function:   FixGPOSoftware
//                                                                             
// Synopsis:   This function searches for software installation ds objects     
//                 contained by a group policy container and calls a fixup     
//                 routine for each deployed software object                   
//                                                                             
// Arguments:                                                                  
//                                                                               
// argInfo     Information user passes in through command line                 
// wszGPODN    Distinguished name of gpo containing the applications           
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT 
FixGPOSoftware(
    const ArgInfo* pargInfo,
    const WCHAR*   wszGPODN,
    const WCHAR*   wszGPOName,
          BOOL*    pbForceGPOUpdate,
          BOOL     fVerbose
    )
{
    HRESULT           hr;
    BOOL              bMachineAppFailed;
    BOOL              bUserAppFailed;

    bMachineAppFailed = FALSE;
    bUserAppFailed = FALSE;

    hr = FixGPOSubcontainerSoftware(
        pargInfo,
        wszGPODN,
        wszGPOName,
        FALSE,
        &bMachineAppFailed,
        pbForceGPOUpdate,
        fVerbose);

    BAIL_ON_FAILURE(hr);

    hr = FixGPOSubcontainerSoftware(
        pargInfo,
        wszGPODN,
        wszGPOName,
        TRUE,
        &bUserAppFailed,
        pbForceGPOUpdate,
        fVerbose);

error:

    if ( FAILED(hr) )
    {
        fwprintf(stderr, L"%s%s\n", SOFTWARE_SEARCH_ERROR, wszGPOName);
        PrintGPFixupErrorMessage(hr);
    }

    if ( FAILED(hr) || bMachineAppFailed || bUserAppFailed )
    {
        fwprintf(stderr, L"%s%s\n", SOFTWARE_GPO_STATUS, wszGPOName);

        if ( FAILED(hr) )
        {
            PrintGPFixupErrorMessage(hr);
        }
    }
	
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\gpfixup\appfixup.hpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2002.
//
//  File:       appfixup.hpp
//
//  Contents:   General declarations for the software installation fixup
//                  portion of the gpfixup tool
//
//
//  History:    9-14-2001  adamed   Created
//
//---------------------------------------------------------------------------

#define SYSVOLSHAREPATH     L"\\Sysvol\\"
#define SYSVOLPATHLENGTH    ( sizeof( SYSVOLSHAREPATH ) / sizeof(WCHAR) - 1 )
#define USERCONTAINERPREFIX        L"LDAP://CN=User,"
#define MACHINECONTAINERPREFIX     L"LDAP://CN=Machine,"
#define UNCPREFIX                  L"\\\\"
#define UNCPREFIXLEN               ( sizeof( UNCPREFIX ) / sizeof(WCHAR) - 1 )
#define DNDCPREFIX                 L"DC="
#define DNDCPREFIXLEN              ( sizeof( DNDCPREFIX ) / sizeof(WCHAR) - 1 )

typedef HRESULT (*PFNCSGETCLASSSTOREPATH)(LPOLESTR DSProfilePath, LPOLESTR *pCSPath);
typedef HRESULT (*PFNCSSERVERGETCLASSSTORE)(LPWSTR szServerName, LPWSTR szPath, void **ppIClassAdmin);
typedef HRESULT (*PFNRELEASEPACKAGEINFO)(PACKAGEDISPINFO *pPackageInfo);
typedef HRESULT (*PFNRELEASEPACKAGEDETAIL)(PACKAGEDETAIL *pPackageDetail);
typedef void    (*PFNCSSETOPTIONS)( DWORD dwOptions );
typedef HRESULT (*PFNGENERATESCRIPT)( PACKAGEDETAIL* pd, WCHAR* wszScriptPath );

HRESULT
InitializeSoftwareInstallationAPI(
    HINSTANCE* pHinstAppmgmt,
    HINSTANCE* pHinstAppmgr
    );

WCHAR*
GetDomainDNFromDNSName(
    WCHAR* wszDnsName
    );

HRESULT
GetDomainFromFileSysPath(
    WCHAR*  wszPath,
    WCHAR** ppwszDomain,
    WCHAR** ppwszSubPath
    );

WCHAR*
GetRenamedDomain(
    const ArgInfo*       pargInfo,
          WCHAR*         wszDomain);

HRESULT
GetRenamedDNSServer(
    const ArgInfo* pargInfo,
          WCHAR*   wszServerName,
          WCHAR**  ppwszNewServerName);

HRESULT
GetNewDomainSensitivePath(
    const ArgInfo*       pargInfo,
          WCHAR*         wszPath,
          BOOL           bRequireDomainDFS,
          WCHAR**        ppwszNewPath
    );

HRESULT
GetNewSourceList(
    const ArgInfo*  pargInfo,
          DWORD     cSources,
          LPOLESTR* pSources
    );

HRESULT
GetNewUpgradeList(
    const ArgInfo*        pArgInfo,
          DWORD           cUpgrades,
          UPGRADEINFO*    prgUpgradeInfoList
    );

HRESULT
GetServerBasedDFSPath(
    WCHAR*  wszServerName,
    WCHAR*  wszServerlessPath,
    WCHAR** ppwszServerBasedDFSPath);

HRESULT 
FixDeployedSoftwareObjectSysvolData(
    const ArgInfo*  pargInfo,
    PACKAGEDETAIL*  pPackageDetails,
    WCHAR**         pOldSources,
    BOOL*           pbForceGPOUpdate,
    BOOL            fVerbose
    );

HRESULT 
FixDeployedSoftwareObjectDSData(
    const ArgInfo*          pargInfo,
    const WCHAR*            wszGPOName,
          IClassAdmin*      pClassAdmin,
          PACKAGEDETAIL*    pPackageDetails,
          BOOL*             pbForceGPOUpdate,
          BOOL              fVerbose
    );

HRESULT
FixDeployedApplication(
    const ArgInfo*         pArgInfo,
    const WCHAR*           wszGPOName,
          IClassAdmin*     pClassAdmin,
          PACKAGEDETAIL*   pPackageDetails,
          BOOL*            pbForceGPOUpdate,
          BOOL             fVerbose
    );

HRESULT
FixGPOSubcontainerSoftware(
    const ArgInfo* pargInfo,
    const WCHAR*   wszGPODN,
    const WCHAR*   wszGPOName,
          BOOL     bUser,
          BOOL*    pbForceGPOUpdate,
          BOOL     fVerbose
    );

HRESULT 
FixGPOSoftware(
    const ArgInfo* pargInfo,
    const WCHAR*   wszGPODN,
    const WCHAR*   wszGPOName,
          BOOL*    pbForceGPOUpdate,
          BOOL     fVerbose
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\gpfixup\gpfixup.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2002.
//
//  File:       gpfixup.h
//
//  Contents:   General declarations for the gpfixup tool
//
//
//  History:    9-14-2001  adamed   Created
//
//---------------------------------------------------------------------------

#define UNICODE
#define _UNICODE

#include <ole2.h>
#include <ole2ver.h>
#include <iads.h>
#include <adshlp.h>
#include <stdio.h>
#include <activeds.h>
#include <string.h>
#include <Dsgetdc.h>
#include <Dsrole.h>
#include <Lm.h>
#include <wincred.h>
#include <lmcons.h>
#include <windns.h>
#include <crtdbg.h>
#include <ntsecapi.h>
#include <wincrypt.h>
#include "resource.h"
#include "helper.h"
#include "cstore.h"
#include "scriptgen.h"

#include <strsafe.h>

#define CR                  L'\r'
#define BACKSPACE           L'\b'
#define NULLC               L'\0'
#define PADDING             256
#define MAX_DNSNAME         DNS_MAX_NAME_LENGTH + PADDING
#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#if DBG == 1 
#define ASSERT(f) if (!(f)) {_ASSERTE(false);}
#else
#define ASSERT(f) if (false && !(f)) {_ASSERTE(false);}
#endif


struct TokenInfo
{
    BOOL     fPasswordToken;
    BOOL     fHelpToken;
    BOOL     fOldDNSToken;
    BOOL     fNewDNSToken;
    BOOL     fOldNBToken;
    BOOL     fNewNBToken;
    BOOL     fDCNameToken;
    BOOL     fVerboseToken;
    BOOL     fSIOnlyToken;
    TokenInfo() 
    {
        fPasswordToken = FALSE;
        fHelpToken = FALSE;
        fOldDNSToken = FALSE;
        fNewDNSToken = FALSE;
        fOldNBToken = FALSE;
        fNewNBToken = FALSE;
        fDCNameToken = FALSE;
        fVerboseToken = FALSE;
        fSIOnlyToken = FALSE;
    }
};


struct ArgInfo
{
    WCHAR*   pszUser;
    WCHAR*   pszPassword;
    WCHAR*   pszOldDNSName;
    WCHAR*   pszNewDNSName;
    WCHAR*   pszOldNBName;
    WCHAR*   pszNewNBName;
    WCHAR*   pszDCName;
    USHORT   sPasswordLength;
        
    ArgInfo()
    {
        pszUser = NULL;
        pszPassword = NULL;
        pszOldDNSName = NULL;
        pszNewDNSName = NULL;
        pszOldNBName = NULL;
        pszNewNBName = NULL;
        pszDCName = NULL;
        sPasswordLength = 0;
    }

};

#include "appfixup.hpp"

void PrintGPFixupErrorMessage(DWORD dwErr);

#define MSG_BAIL_ON_FAILURE(hr, msgID) \
        if(FAILED(hr)) { \
            fwprintf(stderr, L"%s%x\n", (msgID) , (hr)); \
            PrintGPFixupErrorMessage(hr); \
            goto error; \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\gpfixup\gpfixup.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2002.
//
//  File:       gpfixup.cpp
//
//  Contents:   Implementation of the gpfixup tool
//
//
//  History:    5-9-2001  weiqingt   Created
//
//---------------------------------------------------------------------------

#include "gpfixup.h"

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    
    HANDLE hOut;
    DWORD currentMode;
    const DWORD dwBufferMessageSize = 4096;
    HRESULT hr = S_OK;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    DWORD  cchWChar;
    WCHAR  szBufferMessage[dwBufferMessageSize];    
    hr = StringCchVPrintfW( szBufferMessage, dwBufferMessageSize, format, argptr );
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    szBufferMessage[dwBufferMessageSize-1] = L'\0';
    
    cchWChar = wcslen(szBufferMessage);

    //  if it is console, we can use WriteConsoleW
    if (GetFileType(hOut) == FILE_TYPE_CHAR && GetConsoleMode(hOut, &currentMode)) {
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
    }
    //  otherwise, we need to convert Unicode to potential character sets
    //  and use WriteFile
    else {
        int charCount = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, 0, 0, 0, 0);
        char* szaStr = new char[charCount];
        if (szaStr != NULL) {
            DWORD dwBytesWritten;
            WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, szaStr, charCount, 0, 0);
            WriteFile(hOut, szaStr, charCount - 1, &dwBytesWritten, 0);
            delete[] szaStr;
        }
        else
            cchWChar = 0;
    }

error:
    
    return cchWChar;
}



void PrintStatusInfo(
    BOOL fVerbose, PWSTR pszfmt, ...)
{
    va_list args;

    if(fVerbose)
    {
        va_start(args, pszfmt);    
        My_vfwprintf(stdout,pszfmt,args);   
        va_end(args);
        fwprintf(stdout, L"\n");
    }
    else
    {
        // just print dot to indicate we are processing
        fwprintf(stdout, L"%s", L".");
    }
    
    return;
}


//---------------------------------------------------------------------------- 
// Function:   PrintGPFixupErrorMessage                                        
//                                                                             
// Synopsis:   This function prints out the win32 error msg corresponding      
//             to the error code it receives                                   
//                                                                             
// Arguments:                                                                  
//                                                                             
// dwErr       The win32 error code                                            
//                                                                             
// Returns:    Nothing                                                         
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

void PrintGPFixupErrorMessage(DWORD dwErr)
{

    WCHAR   wszMsgBuff[512];  // Buffer for text.

    DWORD   dwChars;  // Number of chars returned.

	

    // Try to get the message from the system errors.
    dwChars = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             dwErr,
                             0,
                             wszMsgBuff,
                             512,
                             NULL );

    if (0 == dwChars)
    {
        // The error code did not exist in the system errors.
        // Try ntdsbmsg.dll for the error code.

        HINSTANCE hInst;

        // Load the library.
        hInst = LoadLibrary(L"ntdsbmsg.dll");
        if ( NULL == hInst )
        {            
	    fwprintf(stderr, DLL_LOAD_ERROR);
            return;  
        }

        // Try getting message text from ntdsbmsg.
        dwChars = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 hInst,
                                 dwErr,
                                 0,
                                 wszMsgBuff,
                                 512,
                                 NULL );

        // Free the library.
        FreeLibrary( hInst );

    }

    // Display the error message, or generic text if not found.
    fwprintf(stderr, L" %ws\n", dwChars ? wszMsgBuff : ERRORMESSAGE_NOT_FOUND );

}

HRESULT
EncryptString(
    LPWSTR pszString,
    LPWSTR *ppszSafeString,
    USHORT* psLen
    )
{
    HRESULT hr = S_OK;
    USHORT sLenStr = 0;
    USHORT sPwdLen = 0;
    LPWSTR pszTempStr = NULL;
    NTSTATUS errStatus = 0;
    USHORT sPadding = 0;

    *ppszSafeString = NULL;
    *psLen = 0;

    //
    // If the string is valid, then we need to get the length
    // and initialize the unicode string.
    //
    if (pszString) {
        UNICODE_STRING Password;

        //
        // Determine the length of buffer taking padding into account.
        //
        sLenStr = (USHORT) wcslen(pszString);
        sPwdLen = (sLenStr + 1) * sizeof(WCHAR);

        sPadding = CRYPTPROTECTMEMORY_BLOCK_SIZE - (sPwdLen % CRYPTPROTECTMEMORY_BLOCK_SIZE);

        if( sPadding == CRYPTPROTECTMEMORY_BLOCK_SIZE )
        {
            sPadding = 0;
        }

        sPwdLen += sPadding;

        pszTempStr = (LPWSTR) AllocADsMem(sPwdLen);

        if (!pszTempStr) {
            MSG_BAIL_ON_FAILURE(hr = E_OUTOFMEMORY, MEMORY_ERROR);
        }
       
        hr = StringCchCopy(pszTempStr, sLenStr + 1, pszString);
        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
        
        Password.MaximumLength = sPwdLen;
        Password.Buffer = pszTempStr;
        Password.Length = sLenStr * sizeof(WCHAR);
        

        errStatus = CryptProtectMemory(
                        Password.Buffer,
                        Password.MaximumLength,
                        0
                        );

        if (errStatus != 0) {
            MSG_BAIL_ON_FAILURE(hr = HRESULT_FROM_NT(errStatus), ENCRYPTION_ERROR);
        }

        *psLen = Password.MaximumLength;
        *ppszSafeString = pszTempStr;
    }

error:
    if (FAILED(hr) && pszTempStr) {
        SecureZeroMemory(pszTempStr, sPwdLen);
        FreeADsMem(pszTempStr);
    }

    return hr;
}


HRESULT
DecryptString(
    LPWSTR pszEncodedString,
    LPWSTR *ppszString,
    USHORT  sLen
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTempStr = NULL;    
    NTSTATUS errStatus = 0;
    
    if (!sLen || !ppszString) {
        return E_FAIL;
    }

    *ppszString = NULL;

    if (sLen) {
        pszTempStr = (LPWSTR) AllocADsMem(sLen);
        if (!pszTempStr) {
            MSG_BAIL_ON_FAILURE(hr = E_OUTOFMEMORY, MEMORY_ERROR);
        }

        memcpy(pszTempStr, pszEncodedString, sLen);


        errStatus = CryptUnprotectMemory(pszTempStr, sLen, 0);
        if (errStatus != 0) {
            MSG_BAIL_ON_FAILURE(hr = HRESULT_FROM_NT(errStatus), DECRYPTION_ERROR);
        }
        *ppszString = pszTempStr;
    }

error:

    if (FAILED(hr) && pszTempStr) {
        SecureZeroMemory(pszTempStr, sLen);
        FreeADsMem(pszTempStr);
    }

    return hr;
}




//---------------------------------------------------------------------------- 
// Function:   GetDCName                                                       
//                                                                             
// Synopsis:   This function locates a DC in the renamed domain given by       
//             NEWDNSNAME or NEWFLATNAME                                       
//                                                                             
// Arguments:                                                                  
//                                                                             
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT 
GetDCName(
	ArgInfo* argInfo,
	BOOL fVerbose
	)
{
    LPCWSTR     ComputerName = NULL;
    GUID*       DomainGuid = NULL;
    LPCWSTR     SiteName = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD       dwStatus = 0;
    LPWSTR      pszNetServerName = NULL;
    HRESULT     hr = S_OK;
    ULONG       ulDsGetDCFlags = DS_WRITABLE_REQUIRED | DS_PDC_REQUIRED | DS_RETURN_DNS_NAME;

    dwStatus =  DsGetDcName(
                        ComputerName,
                        argInfo->pszNewDNSName ? argInfo->pszNewDNSName: argInfo->pszNewNBName,
                        DomainGuid,
                        SiteName,
                        ulDsGetDCFlags,
                        &pDomainControllerInfo
                        );
                   
    if(dwStatus != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
	    fwprintf(stderr, L"%s%x\n", GETDCNAME_ERROR1, hr);
	    PrintGPFixupErrorMessage(hr);

    }
    else if(!pDomainControllerInfo)
    {
        ASSERT(NULL != pDomainControllerInfo);
        hr = E_FAIL;
        fwprintf(stderr, L"%s%x\n", GETDCNAME_ERROR1, hr);
    }
    else
    {
        // returned computer name has prefix, so need to escape this prefix        
        if(pDomainControllerInfo->DomainControllerName) 
        {
            argInfo->pszDCName = AllocADsStr(&(pDomainControllerInfo->DomainControllerName)[wcslen(L"\\\\")]);
            if(!argInfo->pszDCName)
            {
                hr = E_OUTOFMEMORY;
		
                fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
                PrintGPFixupErrorMessage(hr);
                BAIL_ON_FAILURE(hr);
	        }
		
	        hr = S_OK;
	        if(fVerbose)
	        {
    	        fwprintf(stdout, L"%s%s\n", DC_NAME, argInfo->pszDCName);
	        }
        }
        else
        {
            hr = E_FAIL;
            fwprintf(stderr, L"%s%x\n", GETDCNAME_ERROR1, hr);
	        PrintGPFixupErrorMessage(hr);

	    }
	}
    

	
error:

	if (pDomainControllerInfo)
	{
	    (void) NetApiBufferFree(pDomainControllerInfo);
	}

	return hr;

}

BOOL
ImpersonateWrapper(
    ArgInfo argInfo,
    HANDLE* phUserToken
    )
{
    BOOL       fImpersonate = FALSE;    
    DWORD     credStatus = SEC_E_OK;
    HRESULT    hr = S_OK;
    WCHAR*    pszNTLMUser = NULL;
    WCHAR*    pszNTLMDomain = NULL;
    WCHAR*    pszTempPassword = NULL;

    if(argInfo.pszPassword)
    {
        hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
        BAIL_ON_FAILURE(hr);
    }       


    // doing impersonation if necessary
    if(pszTempPassword|| argInfo.pszUser)
    {
        // get the username
        if(argInfo.pszUser)
        {
            pszNTLMUser = new WCHAR[wcslen(argInfo.pszUser)+1];
            pszNTLMDomain = new WCHAR[wcslen(argInfo.pszUser)+1];
            if(!pszNTLMUser || !pszNTLMDomain)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                MSG_BAIL_ON_FAILURE(hr, MEMORY_ERROR);   
            }

            //
            // CredUIParseUserName will parse NT4 type name, UPN and MarshalledCredentialReference
            //
            credStatus = CredUIParseUserName(argInfo.pszUser, 
                            		pszNTLMUser, 
                            		wcslen(argInfo.pszUser) + 1,  
                            		pszNTLMDomain, 
		                            wcslen(argInfo.pszUser) + 1
		                            );   
        
            if(credStatus)
            {
                // there is the case that user just passes in "administrator" instead of "domain\administrator"
                (void) StringCchCopy(pszNTLMUser, wcslen(argInfo.pszUser)+1, argInfo.pszUser);
            }
        }       
        
        
        if(LogonUser(pszNTLMUser,
                   argInfo.pszDCName,
                   pszTempPassword,
                   LOGON32_LOGON_NEW_CREDENTIALS,
                   LOGON32_PROVIDER_WINNT50,
                   phUserToken
                   ))
        {
            if (ImpersonateLoggedOnUser(*phUserToken)) {
                        fImpersonate = TRUE;
                    } 
                
        }
            
    }

error:

    if(pszNTLMDomain)
    {
        delete [] pszNTLMDomain;
    }

    if(pszNTLMUser)
    {
        delete [] pszNTLMUser;
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }
    

    
    return fImpersonate;
}



//---------------------------------------------------------------------------- 
// Function:   VerifyName                                                      
//                                                                             
// Synopsis:   This function verifies that DC is writeable, and the domain DNS 
//             name as well as the domain NetBIOS name provided corresspond    
//             to the same domain naming context in the AD forest              |
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// tokenInfo   Information about what switches user has turned on              |                                                                           
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
VerifyName(
	TokenInfo tokenInfo,
	ArgInfo argInfo
	)
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomaininfo = NULL;
    HRESULT hr = E_FAIL;
    DWORD dwError = NO_ERROR;
    BOOL       fImpersonate = FALSE;
    HANDLE     hUserToken = INVALID_HANDLE_VALUE;

    fImpersonate = ImpersonateWrapper(argInfo, &hUserToken);
    
    dwError = DsRoleGetPrimaryDomainInformation(    
                            argInfo.pszDCName,                      
                            DsRolePrimaryDomainInfoBasic,   // InfoLevel
                            (PBYTE*)&pdomaininfo            // pBuffer
                            );

    // revert to itself if appropriately
    if(fImpersonate)
    {
        RevertToSelf();
    }
    
    hr = HRESULT_FROM_WIN32(dwError);


    if (FAILED(hr))
    {
        fwprintf(stderr, L"%s%x\n", VERIFYNAME_ERROR1, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }
    else if(!pdomaininfo)
    {        
        ASSERT(NULL != pdomaininfo);
        hr = E_FAIL;
        fwprintf(stderr, L"%s%x\n", VERIFYNAME_ERROR1, hr);
        BAIL_ON_FAILURE(hr);
    }

    // determine that dc is writable, we assume that all win2k dc is writeable

    if(!(pdomaininfo->Flags & DSROLE_PRIMARY_DS_RUNNING))
    {
        fwprintf(stderr, VERIFYNAME_ERROR2);
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }	

    // determine that new dns name is correct when compared with the dc name

    if(argInfo.pszNewDNSName && _wcsicmp(argInfo.pszNewDNSName, pdomaininfo->DomainNameDns))
    {
        fwprintf(stderr, VERIFYNAME_ERROR3);
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    // determine that new netbios name is correct when compared with the dc name

    if(tokenInfo.fNewNBToken)
    {
        if(_wcsicmp(argInfo.pszNewNBName, pdomaininfo->DomainNameFlat))
        {
            fwprintf(stderr, VERIFYNAME_ERROR4);
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);			
        }
    }

error:
    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }    

    if ( pdomaininfo )
    {
        DsRoleFreeMemory(pdomaininfo);
    }
    return hr;


}


//---------------------------------------------------------------------------- 
// Function:   PrintHelpFile                                                   
//                                                                             
// Synopsis:   This function prints out the help file for this tool            
//                                                                             
// Arguments:  Nothing                                                         
//                                                                             
//                                                                             
// Returns:    Nothing                                                         
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


void PrintHelpFile()
{
    WCHAR szBuffer[1200] = L"";

    LoadString(NULL, IDS_GPFIXUP1, szBuffer, 1200);
    fwprintf(stdout, L"%s\n", szBuffer);
	
}

//---------------------------------------------------------------------------- 
// Function:   GetPassword                                                     
//                                                                             
// Synopsis:   This function retrieves the password user passes in from        |
//             command line                                                    |
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// szBuffer    Buffer to store the password                                    |                                                                           
// dwLength    Maximum length of the password                                  
// pdwLength   The length of the password user passes in                       | 
//                                                                             
// Returns:    TRUE on success, FALSE on failure                               
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR    ch;
    PWSTR    pszBufCur = szBuffer;
    DWORD    c;
    int      err;
    DWORD    mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putwchar(L'\n');

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}

//---------------------------------------------------------------------------- 
// Function:   Validations                                                     
//                                                                             
// Synopsis:   This function verifies whether the switch turned on by user is  
//             correct                                                         
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// tokenInfo   Information about what switches user has turned on              |                                                                           
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT
Validations( 
	TokenInfo tokenInfo,
	ArgInfo argInfo
	)
{
    HRESULT hr = S_OK;   
    BOOL fEqual = FALSE;


    // At least one of the switches /newdsn or /newnb must be specified
    if(!(tokenInfo.fNewDNSToken | tokenInfo.fNewNBToken))
    {
        fwprintf(stderr, VALIDATIONS_ERROR1);
        return E_FAIL;
    }
	
    // The switch /newdns can be specified if and only if the switch /olddns is also specifed
    if((tokenInfo.fNewDNSToken && !tokenInfo.fOldDNSToken) || (!tokenInfo.fNewDNSToken && tokenInfo.fOldDNSToken))
    {
        fwprintf(stderr, VALIDATIONS_ERROR7);
        return E_FAIL;
    }
    
    // The switch /newnb can be specified if and only if the switch /oldnb is also specifed
    if((tokenInfo.fNewNBToken && !tokenInfo.fOldNBToken) || (!tokenInfo.fNewNBToken && tokenInfo.fOldNBToken))
    {
        fwprintf(stderr, VALIDATIONS_ERROR2);
        return E_FAIL;
    }

    // Currently we support /sionly switch, so /newdns and /olddns are not mandatory
	    
    // compare whether the new and old DNS names are identical
    if(argInfo.pszNewDNSName && argInfo.pszOldDNSName && _wcsicmp(argInfo.pszNewDNSName, argInfo.pszOldDNSName) == 0)
    {
        if(!tokenInfo.fNewNBToken)
        {
            // new and old dns names are identical, and netbios names are not specified, there is nothing to do
            fwprintf(stderr, VALIDATIONS_ERROR3);
            return E_FAIL;
        }
        fEqual = TRUE;
    }

    // compare whether the new and old NetBIOS names are identical
    if(argInfo.pszNewNBName && argInfo.pszOldNBName && _wcsicmp(argInfo.pszNewNBName, argInfo.pszOldNBName) == 0)
    {
        // if dns and netbios name are both specified, then at least one pair of them should differ
        if(fEqual)
        {
            fwprintf(stderr, VALIDATIONS_ERROR3);
            return E_FAIL;
        }

        if(!tokenInfo.fNewDNSToken)
        {
            // new and old netbios names are identical, and dns names are not specified, there is nothing to do
            fwprintf(stderr, VALIDATIONS_ERROR3);
            return E_FAIL;
        }
        
    }

	
    if(SUCCEEDED(hr) && tokenInfo.fVerboseToken)
    {
        fwprintf(stdout, VALIDATIONS_RESULT);
    }

    return hr;


}


//---------------------------------------------------------------------------- 
// Function:   UpdateVersionInfo                                               
//                                                                             
// Synopsis:   This function fixes the version number                                                         
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// dwVersionNumber       versionNumber of the object                                                      |                                                                          
//                                                                             
// Returns:    No                                                              
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

void UpdateVersionInfo(DWORD& dwVersionNumber)
{
    WORD wLowVersion = 0;
    WORD wHighVersion = 0;

    // extract low word and increment
    wLowVersion = LOWORD(dwVersionNumber);
    // we don't do update if it is zero
    if(wLowVersion)
    {
        // bump up version number
        wLowVersion += 1;
        // take care of wrapping to zero
        wLowVersion = (wLowVersion ? wLowVersion : 1);
    }

    // extract high word and increment
    wHighVersion = HIWORD(dwVersionNumber);
    // we don't do update if it is zero
    if(wHighVersion)
    {
        // bump up version number
        wHighVersion += 1;
        // take care of wrapping to zero        
        wHighVersion = (wHighVersion ? wHighVersion : 1);
    }

    // make DWORD out of the two parts
    dwVersionNumber = MAKELONG(wLowVersion, wHighVersion);

    return;
    
}

//---------------------------------------------------------------------------- 
// Function:   FixGPTINIFile                                               
//                                                                             
// Synopsis:   This function fixes the version number of gpt.ini                
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszDN       DN of the object                                                |                                                                          
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
FixGPTINIFile(
	WCHAR* pszSysPath,
	const ArgInfo argInfo,
	DWORD& dwSysVNCopy,
	DWORD& dwSysNewVersionNum
	)
{
    HRESULT    hr = S_OK;
    WCHAR*     pszGPTIniPath = NULL;
    size_t     cchGPTIniPath = 0;
    DWORD      dwVersionNumber = 0;
    WCHAR      szVersion [MAX_PATH] = L"";
    BOOL       fResult = FALSE;
    DWORD      dwLength = 0;    
    BOOL       fImpersonate = FALSE;
    HANDLE     hUserToken = INVALID_HANDLE_VALUE;  
    
    
    cchGPTIniPath = wcslen(pszSysPath) + 1 + wcslen(L"\\gpt.ini");
    pszGPTIniPath = new WCHAR[cchGPTIniPath];
     
    if(!pszGPTIniPath)
    {			
        hr = E_OUTOFMEMORY;
			
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }	
    
    (void) StringCchCopy(pszGPTIniPath, cchGPTIniPath, pszSysPath);
    (void) StringCchCat(pszGPTIniPath, cchGPTIniPath, L"\\gpt.ini");
    

    fImpersonate = ImpersonateWrapper(argInfo, &hUserToken);

    // fetch value of version key (current version), the version actually is an integer, the length of the version should be less than MAX_PATH  
    dwLength = GetPrivateProfileStringW(L"General", L"Version", 0, szVersion, MAX_PATH, pszGPTIniPath );
    if(!dwLength)
    {
        hr = E_FAIL;
        fwprintf(stderr, L"%s file name is %s\n", GPTINIFILE_ERROR1, pszGPTIniPath);
        BAIL_ON_FAILURE(hr);
    }
    
    dwSysVNCopy = dwVersionNumber = _wtoi(szVersion);

    // don't do update if it is zero
    if(dwVersionNumber)
    {
    
        UpdateVersionInfo(dwVersionNumber);

        // write the incremented version number value back
        _itow(dwVersionNumber, szVersion, 10);
    
        fResult = WritePrivateProfileStringW(L"General", L"Version", szVersion, pszGPTIniPath);
        if(!fResult)
        {
            // failed to copy the string to the ini file
            hr = HRESULT_FROM_WIN32(GetLastError());
            fwprintf(stderr, L"%s%x, file name is %s\n", GPTINIFILE_ERROR2, hr, pszGPTIniPath);
            PrintGPFixupErrorMessage(hr);
        }

        dwSysNewVersionNum = dwVersionNumber;
    }

error:

    // revert to itself if appropriately
    if(fImpersonate)
    {
        RevertToSelf();
    }

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }	
      
    if(pszGPTIniPath)
    {
        delete [] pszGPTIniPath;
    }
    
    return hr;


    
}

HRESULT 
RestoreGPTINIFile(
	WCHAR* pszDN,	
	const ArgInfo argInfo,
	DWORD dwSysVNCopy
	)
{
    HRESULT    hr = S_OK;
    WCHAR*     pszGPTIniPath = NULL;
    size_t     cchGPTIniPath = 0;
    WCHAR      szVersion [MAX_PATH] = L"";
    BOOL       fResult = FALSE;    
    IADs*      pObject = NULL;
    VARIANT    varProperty;
    WCHAR      szTempPath [MAX_DNSNAME] = L"LDAP://";
    BOOL       fImpersonate = FALSE;
    HANDLE     hUserToken = INVALID_HANDLE_VALUE;
    WCHAR*    pszTempPassword = NULL;
    IADsPathname* pPathname = NULL;
    BSTR       bstrPath = NULL;

    VariantInit(&varProperty);   
    
    hr = StringCchCat(szTempPath, MAX_DNSNAME, argInfo.pszDCName);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(szTempPath, MAX_DNSNAME, L"/");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

    // using IADsPathname to escape the path properly
    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**) &pPathname);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_COCREATE);
    
    hr = pPathname->Set(pszDN, ADS_SETTYPE_DN);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_SET);

    hr = pPathname->put_EscapedMode(ADS_ESCAPEDMODE_ON);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_MODE);

    hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_RETRIEVE);
    
    hr = StringCchCat(szTempPath, MAX_DNSNAME,bstrPath);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

    if(argInfo.pszPassword)
    {
        hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
        BAIL_ON_FAILURE(hr);
    }
    hr = ADsOpenObject(szTempPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND |ADS_USE_SIGNING, IID_IADs,(void**)&pObject);


    if(!SUCCEEDED(hr))
    {		
        fwprintf(stderr, L"%s%x\n", GPTINIFILE_ERROR3, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }    

    BSTR bstrGpcFileSysPath = SysAllocString( L"gPCFileSysPath" );
    if(!bstrGpcFileSysPath)
    {			
        hr = E_OUTOFMEMORY;
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        goto error;
    }	
    hr = pObject->Get(bstrGpcFileSysPath, &varProperty );
    SysFreeString(bstrGpcFileSysPath);
    if(!SUCCEEDED(hr))
    {
		
        fwprintf(stderr, L"%s%x\n", GPTINIFILE_ERROR4 , hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }
    cchGPTIniPath = wcslen(V_BSTR( &varProperty ) ) + 1 + wcslen(L"\\gpt.ini");
    pszGPTIniPath = new WCHAR[cchGPTIniPath];
     
    if(!pszGPTIniPath)
    {			
        hr = E_OUTOFMEMORY;
			
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }	
    
    (void) StringCchCopy(pszGPTIniPath, cchGPTIniPath, V_BSTR( &varProperty ));
    (void) StringCchCat(pszGPTIniPath, cchGPTIniPath, L"\\gpt.ini");
    

    fImpersonate = ImpersonateWrapper(argInfo, &hUserToken);

    
    _itow(dwSysVNCopy, szVersion, 10);

    fResult = WritePrivateProfileStringW(L"General", L"Version", szVersion, pszGPTIniPath);
    if(!fResult)
    {
        // failed to copy the string to the ini file
        hr = HRESULT_FROM_WIN32(GetLastError());
        fwprintf(stderr, L"%s%x, file name is %s\n", GPTINIFILE_ERROR2, hr, pszGPTIniPath);
        PrintGPFixupErrorMessage(hr);        
    }

error:

    // revert to itself if appropriately
    if(fImpersonate)
    {
        RevertToSelf();
    }

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }
	
    // clear the memory
    VariantClear(&varProperty);
    
    if(pObject)
    {
        pObject->Release();
    }
    
    if(pszGPTIniPath)
    {
        delete [] pszGPTIniPath;
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    if(pPathname)
        pPathname->Release();

    if(bstrPath)
        SysFreeString(bstrPath);


    return hr;


    
}

HRESULT 
FixGPCVersionNumber(
	DWORD dwVersionNumber, 
	WCHAR* pszDN,
	const ArgInfo argInfo
	)
{
    WCHAR*     pszLDAPPath = NULL;
    size_t     cchLDAPPath = 0;
    HRESULT    hr = S_OK;
    IADs*      pObject = NULL;
    VARIANT    var;
    WCHAR*     pszTempPassword = NULL;
    IADsPathname* pPathname = NULL;
    BSTR       bstrPath = NULL;
    

    // using IADsPathname to escape the path properly
    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**) &pPathname);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_COCREATE);
    
    hr = pPathname->Set(pszDN, ADS_SETTYPE_DN);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_SET);

    hr = pPathname->put_EscapedMode(ADS_ESCAPEDMODE_ON);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_MODE);

    hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
    MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_RETRIEVE);

    cchLDAPPath = wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/") + wcslen(bstrPath) + 1;
    pszLDAPPath = new WCHAR[cchLDAPPath];

    if(!pszLDAPPath)
    {			
        hr = E_OUTOFMEMORY;
			
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }		
    
    (void) StringCchCopy(pszLDAPPath, cchLDAPPath, L"LDAP://");
    (void) StringCchCat(pszLDAPPath, cchLDAPPath, argInfo.pszDCName);
    (void) StringCchCat(pszLDAPPath, cchLDAPPath, L"/");
    (void) StringCchCat(pszLDAPPath, cchLDAPPath, bstrPath);
		

    if(argInfo.pszPassword)
    {
        hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
        BAIL_ON_FAILURE(hr);
    }
    hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND | ADS_USE_SIGNING, IID_IADs,(void**)&pObject);


    if(!(SUCCEEDED(hr)))
    {
	
        fwprintf(stderr, L"%s%x\n", GPCVERSIONNUMBER_ERROR1, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&var);

    V_VT(&var) = VT_I4;
    V_I4(&var) = dwVersionNumber;

    BSTR bstrVersionNumber = SysAllocString( L"versionNumber" );
    if(!bstrVersionNumber)
    {
        VariantClear(&var);
        hr = E_OUTOFMEMORY;
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        goto error;
    }	
    hr = pObject->Put( bstrVersionNumber, var );   
    SysFreeString(bstrVersionNumber);
    VariantClear(&var);
    MSG_BAIL_ON_FAILURE(hr, GPCVERSIONNUMBER_ERROR3);

    hr = pObject->SetInfo();       

		
    if(!(SUCCEEDED(hr)))
    {

        fwprintf(stderr, L"%s%x\n", GPCVERSIONNUMBER_ERROR2, hr);
        PrintGPFixupErrorMessage(hr);
    }

    error:

	
    // clear the memory
    if(pszLDAPPath)
    {
        delete [] pszLDAPPath;
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    if(pPathname)
        pPathname->Release();

    if(bstrPath)
        SysFreeString(bstrPath);
    

    if(pObject)
        pObject->Release(); 
    
    return hr;
    
    
}

//---------------------------------------------------------------------------- 
// Function:   FixGPCFileSysPath                                               
//                                                                             
// Synopsis:   This function fixes the gpcFileSysPath attribute                
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszSysPath  value of the gpcFileSysPath attribute                           |
// pszDN       DN of the object                                                |                                                                          
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT
FixGPCFileSysPath(
	LPWSTR pszSysPath, 
	WCHAR* pszDN,
	const ArgInfo argInfo,
	BOOL &fGPCFileSysPathChange,
	DWORD& dwSysVNCopy,
	DWORD  dwDSVNCopy,
	const BOOL fVerbose,
	DWORD& dwSysNewVersionNum,
	WCHAR** ppszNewGPCFileSysPath
	)
{
    HRESULT    hr = S_OK;
    WCHAR*     token = NULL;
    WCHAR*     pszNewPath = NULL;
    size_t     cchNewPath = 0;
    WCHAR*     pszPathCopier = NULL;    
    WCHAR*     pszLDAPPath = NULL;
    size_t     cchLDAPPath = 0;
    IADs*      pObject = NULL;
    VARIANT    var;
    WCHAR*     pszReleasePosition = NULL;
    size_t     cchReleasePosition = 0;
    DWORD      dwCount = 0;
    WCHAR* pszTempPassword = NULL;
    IADsPathname* pPathname = NULL;
    BSTR       bstrPath = NULL;
    BOOL       fSysVersionFixed = FALSE;


    // copy the value over
    cchReleasePosition = wcslen(pszSysPath) + 1;
    pszReleasePosition = new WCHAR[cchReleasePosition];
    if(!pszReleasePosition)
    {
        hr = E_OUTOFMEMORY;
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }

    pszPathCopier = pszReleasePosition;	
    (void) StringCchCopy(pszReleasePosition, cchReleasePosition, pszSysPath);

    // initialize the new property value
    cchNewPath = wcslen(pszSysPath) + MAX_DNSNAME;
    pszNewPath = new WCHAR[cchNewPath];
    if(!pszNewPath)
    {
        hr = E_OUTOFMEMORY;
		
    	fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
    	PrintGPFixupErrorMessage(hr);
    	BAIL_ON_FAILURE(hr);
    }

    (void) StringCchCopy(pszNewPath, cchNewPath, L"");


    // process the old property

    // solving the possible problem of leading space
    while(pszReleasePosition[dwCount] != L'\0' && pszReleasePosition[dwCount] == L' ')
        dwCount ++;

    pszPathCopier = &pszReleasePosition[dwCount];

	

    // first do the check whether the value of property is what we expect
    if(wcscmp(pszPathCopier, L"") == 0)
    {
        goto error;
    }

    if( _wcsnicmp(pszPathCopier, L"\\", 1))
    {
        goto error;
    }

    token = wcstok( pszPathCopier, L"\\" );
	
    while( token != NULL )
    {
        /* While there are tokens in "string" */
		
        if(!_wcsicmp(token, argInfo.pszOldDNSName))
        {
            if(!wcscmp(pszNewPath, L""))
            {
                hr = StringCchCopy(pszNewPath, cchNewPath, L"\\\\");
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                hr = StringCchCat(pszNewPath, cchNewPath, argInfo.pszNewDNSName);
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                
                fGPCFileSysPathChange = TRUE;
            }
            else
            {
	            hr = StringCchCat(pszNewPath, cchNewPath, argInfo.pszNewDNSName);
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                
    	        fGPCFileSysPathChange = TRUE;
	        }
	    }
  	    else
	    {
	        if(!wcscmp(pszNewPath, L""))
	        {
	            hr = StringCchCopy(pszNewPath, cchNewPath, L"\\\\");
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	            hr = StringCchCat(pszNewPath, cchNewPath, token);
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	        }
  	        else
 	        {
		        hr = StringCchCat(pszNewPath, cchNewPath, token);
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	        }
	    }   

        /* Get next token: */
        token = wcstok( NULL, L"\\" );
	    if(token != NULL)
	    {
	        hr = StringCchCat(pszNewPath, cchNewPath, L"\\");
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	    }
    }

    // before updating the gpcfilesyspath, we need to fix the sys version number     
    
    hr = FixGPTINIFile(pszNewPath, argInfo, dwSysVNCopy, dwSysNewVersionNum);
    BAIL_ON_FAILURE(hr);

    // we fixed the version numbe of gpt.ini on sysvol.
    fSysVersionFixed = TRUE;    
    
    if(fGPCFileSysPathChange)
    {
        // get a copy of new gpcFileSysPath
        *ppszNewGPCFileSysPath = new WCHAR[wcslen(pszNewPath) + 1];
        if(!(*ppszNewGPCFileSysPath))
        {
            MSG_BAIL_ON_FAILURE(hr = E_OUTOFMEMORY, MEMORY_ERROR);
        }
        (void) StringCchCopy(*ppszNewGPCFileSysPath, wcslen(pszNewPath) + 1, pszNewPath);
    
        // using IADsPathname to escape the path properly
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**) &pPathname);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_COCREATE);

        hr = pPathname->Set(pszDN, ADS_SETTYPE_DN);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_SET);

        hr = pPathname->put_EscapedMode(ADS_ESCAPEDMODE_ON);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_MODE);

        hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_RETRIEVE);
    
        // update the properties for the object

        cchLDAPPath = wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/") + wcslen(bstrPath) + 1;
        pszLDAPPath = new WCHAR[cchLDAPPath];

        if(!pszLDAPPath)
        {			
            hr = E_OUTOFMEMORY;
			
            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }
		
        (void) StringCchCopy(pszLDAPPath, cchLDAPPath, L"LDAP://");
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, argInfo.pszDCName);
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, L"/");
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, bstrPath);


        if(argInfo.pszPassword)
        {
            hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
            BAIL_ON_FAILURE(hr);
        }
        hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND |ADS_USE_SIGNING, IID_IADs,(void**)&pObject);

        if(!(SUCCEEDED(hr)))
        {
	
            fwprintf(stderr, L"%s%x\n", GPCFILESYSPATH_ERROR1, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }


        VariantInit(&var);

        V_BSTR(&var) = SysAllocString(pszNewPath);
        V_VT(&var) = VT_BSTR;


        BSTR bstrGpcFileSysPath = SysAllocString( L"gpcFileSysPath" );
        if(!bstrGpcFileSysPath)
        {
            VariantClear(&var);
            hr = E_OUTOFMEMORY;
            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
            PrintGPFixupErrorMessage(hr);
            goto error;
        }	
        hr = pObject->Put( bstrGpcFileSysPath, var );
        SysFreeString(bstrGpcFileSysPath);
        VariantClear(&var);

        MSG_BAIL_ON_FAILURE(hr, GPCFILESYSPATH_ERROR3);

        hr = pObject->SetInfo();              

		
        if(!(SUCCEEDED(hr)))
        {

            fwprintf(stderr, L"%s%x\n", GPCFILESYSPATH_ERROR2, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }
        else
        {
            // print status infor
            PrintStatusInfo(fVerbose, L"%s%s%s%s%s", PROCESSING_GPCFILESYSPATH, OLDVALUE, pszSysPath, NEWVALUE, pszNewPath);
        }
        
    }

error:

    // restore the version if necessary
    if(FAILED(hr))
    {       
        // restore the ds version number
        FixGPCVersionNumber(dwDSVNCopy, pszDN, argInfo);

        // if gpt.ini version number is also changed, restore it
        if(fSysVersionFixed)
            RestoreGPTINIFile(pszDN, argInfo, dwSysVNCopy);        
    
    }

	
    // clear the memory
    if(pszNewPath)
    {
        delete [] pszNewPath;
    }

    if(pszReleasePosition)
    {
        delete [] pszReleasePosition;
    }

    if(pszLDAPPath)
    {
        delete [] pszLDAPPath;
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    if(pPathname)
        pPathname->Release();

    if(bstrPath)
        SysFreeString(bstrPath);

    if(pObject)
        pObject->Release();

    
    return hr;


}

//---------------------------------------------------------------------------- 
// Function:   FixGPCWQLFilter                                                 
//                                                                             
// Synopsis:   This function fixes the gpcWQLFilter attribute                  
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszFilter   value of the gpcWQLFilter attribute                             |
// pszDN       DN of the object                                                
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
FixGPCWQLFilter(
	LPWSTR pszFilter, 
	WCHAR* pszDN,
	const ArgInfo argInfo,
	const BOOL fVerbose
	)
{
    HRESULT    hr = S_OK;
    WCHAR*     token1 = NULL;
    WCHAR*     token2 = NULL;
    WCHAR*     temp = NULL;
    WCHAR*     pszFilterCopier = NULL;
    WCHAR*     pszNewPath = NULL;
    size_t     cchNewPath = 0;
    IADs*      pObject = NULL;
    VARIANT    var;
    WCHAR*     pszLDAPPath = NULL;
    size_t     cchLDAPPath = 0;
    DWORD      dwToken1Pos = 0;
    BOOL       fChange = FALSE;
    WCHAR*     pszReleasePosition = NULL;
    size_t     cchReleasePosition = 0;
    DWORD      dwCount = 0;
    DWORD      dwFilterCount = 0;
    DWORD      dwIndex;
    WCHAR*     pszTempPassword = NULL;
    IADsPathname* pPathname = NULL;
    BSTR       bstrPath = NULL;

	
    // copy over the filter

    cchReleasePosition = wcslen(pszFilter) + 1;
    pszReleasePosition = new WCHAR[cchReleasePosition];
    if(!pszReleasePosition)
    {
        hr = E_OUTOFMEMORY;
        
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }
    pszFilterCopier = pszReleasePosition;
    (void) StringCchCopy(pszReleasePosition, cchReleasePosition, pszFilter);

    // find out how many filters are there
    for(dwIndex =0; dwIndex < wcslen(pszReleasePosition); dwIndex++)
    {
        if(L'[' == pszReleasePosition[dwIndex])
            dwFilterCount ++;
    }	
    
    // initilize the new property

    cchNewPath = wcslen(pszFilter) + DNS_MAX_NAME_LENGTH * dwFilterCount;
    pszNewPath = new WCHAR[cchNewPath];
    if(!pszNewPath)
    {
        hr = E_OUTOFMEMORY;

        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }
    (void) StringCchCopy(pszNewPath, cchNewPath, L"");


    // begin process the property

    // solving the possible problem of leading space
    while(pszReleasePosition[dwCount] != L'\0' && pszReleasePosition[dwCount] == L' ')
	dwCount ++;

    pszFilterCopier = &pszReleasePosition[dwCount];

	
	
    // first do the check whether the value of property is what we expect
    if(wcscmp(pszFilterCopier, L"") == 0)
    {
        goto error;
    }

    if( _wcsnicmp(pszFilterCopier, L"[", 1))
    {
        goto error;
    }


    token1 = wcstok(pszFilterCopier, L"[");
    if(token1 != NULL)
    {
        dwToken1Pos += wcslen(token1) + wcslen(L"[");
    }
		
    while(token1 != NULL)
    {
        WCHAR* mytoken = token1;

        token1 = token1 + wcslen(token1) + 1;

		token2 = wcstok( mytoken, L";" );
		if(token2 != NULL)
		{		        
	        if(_wcsicmp(token2, argInfo.pszOldDNSName) == 0)
    	    {
    	        hr = StringCchCat(pszNewPath, cchNewPath, L"[");
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    	        hr = StringCchCat(pszNewPath, cchNewPath, argInfo.pszNewDNSName);
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    	        hr = StringCchCat(pszNewPath, cchNewPath, L";");				
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

    	        fChange = TRUE;
    	    }
	        else
	        {
	            hr = StringCchCat(pszNewPath, cchNewPath, L"[");
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	            hr = StringCchCat(pszNewPath, cchNewPath, token2);
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	            hr = StringCchCat(pszNewPath, cchNewPath, L";");				
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	        }

     	    token2 = wcstok(NULL, L"]");
	        if(token2 != NULL)
	        {
	            hr = StringCchCat(pszNewPath, cchNewPath, token2);
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	            hr = StringCchCat(pszNewPath, cchNewPath, L"]");				
    	        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
	        }
	    }
		
	    if(dwToken1Pos < wcslen(pszFilter))
	    {
    	    token1 = wcstok( token1, L"[" );
    	    dwToken1Pos = dwToken1Pos + wcslen(token1) + wcslen(L"[");
	    }
	    else
	    {
	        token1 = NULL;
	    }       
				
    }

    		
    // wrtie the new property back to the gpcWQLFilter of the object

    if(fChange)
    {
        // using IADsPathname to escape the path properly
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**) &pPathname);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_COCREATE);

        hr = pPathname->Set(pszDN, ADS_SETTYPE_DN);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_SET);

        hr = pPathname->put_EscapedMode(ADS_ESCAPEDMODE_ON);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_MODE);

        hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_RETRIEVE);
        
        
        // update the properties for the object

        cchLDAPPath = wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/") + wcslen(bstrPath) + 1;
        pszLDAPPath = new WCHAR[cchLDAPPath];

        if(!pszLDAPPath)
        {
            hr = E_OUTOFMEMORY;

            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }
		
        (void) StringCchCopy(pszLDAPPath, cchLDAPPath, L"LDAP://");
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, argInfo.pszDCName);
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, L"/");
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, bstrPath);

        if(argInfo.pszPassword)
        {
            hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
            BAIL_ON_FAILURE(hr);
        }
        hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND | ADS_USE_SIGNING, IID_IADs,(void**)&pObject);

        if(!(SUCCEEDED(hr)))
        {
			
    	    fwprintf(stderr, L"%s%x\n", GPCWQLFILTER_ERROR1, hr);
    	    PrintGPFixupErrorMessage(hr);
    	    BAIL_ON_FAILURE(hr);
    	}

        VariantInit(&var);

    	V_BSTR(&var) = SysAllocString(pszNewPath);
        V_VT(&var) = VT_BSTR;

        BSTR bstrgPCWQLFilter = SysAllocString( L"gPCWQLFilter" );
        if(!bstrgPCWQLFilter)
        {
            VariantClear(&var);
            hr = E_OUTOFMEMORY;
            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
            PrintGPFixupErrorMessage(hr);
            goto error;
        }	
        hr = pObject->Put( bstrgPCWQLFilter, var );
        SysFreeString(bstrgPCWQLFilter);
        VariantClear(&var);

        MSG_BAIL_ON_FAILURE(hr, GPCWQLFILTER_ERROR3);

        hr = pObject->SetInfo();        

        if(!(SUCCEEDED(hr)))
        {
			
            fwprintf(stderr, L"%s%x\n", GPCWQLFILTER_ERROR2, hr);
            PrintGPFixupErrorMessage(hr);
        }
        else
        {
            // print status information
            PrintStatusInfo(fVerbose, L"%s%s%s%s%s", PROCESSING_GPCWQLFILTER, OLDVALUE, pszFilter, NEWVALUE, pszNewPath);
        }

		
    }
 
error:


    // clear the memory
    if(pszNewPath)
    {
        delete [] pszNewPath;
    }

    if(pszReleasePosition)
    {
        delete [] pszReleasePosition;
    }

    if(pszLDAPPath)
    {
        delete [] pszLDAPPath;
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    if(pPathname)
        pPathname->Release();

    if(bstrPath)
        SysFreeString(bstrPath);

    if(pObject)
        pObject->Release();
	
    return hr;


}


//---------------------------------------------------------------------------- 
// Function:   SearchGroupPolicyContainer                                      
//                                                                             
// Synopsis:   This function searchs the group policy container and calls      
//             the FixGPCFileSysPath and FixGPCQWLFilter                       |
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
SearchGroupPolicyContainer(
	const ArgInfo argInfo,
	const TokenInfo tokenInfo	
	)
{
    HRESULT    hr = S_OK;
    HRESULT    hrFix = S_OK;
    IDirectorySearch *m_pSearch;
    LPWSTR     pszAttr[] = { L"distinguishedName", L"gpcFileSysPath", L"gpcWQLFilter", L"versionNumber", L"displayName" };
    ADS_SEARCH_HANDLE hSearch;
    DWORD      dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
    WCHAR*     pszDN = NULL;
    WCHAR*     pszSysPath = NULL;
    size_t     cchDN = 0;
    WCHAR*     pszLDAPPath = NULL;
    size_t     cchLDAPPath = 0;
    ADS_SEARCH_COLUMN col;
    ADS_SEARCHPREF_INFO prefInfo[1];
    BOOL       fBindObject = FALSE;
    BOOL       fSearch = FALSE;
    BOOL       fSucceeded = TRUE;
    DWORD      dwVersionNumber = 0;
    BOOL       fGPCFileSysPathChange = FALSE;
    BOOL       fGetDisplayName = FALSE;
    WCHAR*     pszTempPassword = NULL;
    DWORD      dwDSVNCopy = 0;
    DWORD      dwSysVNCopy = 0;   
    BOOL       fVersionUpdated = FALSE;
    DWORD      dwSysNewVersonNum = 0;
    WCHAR*     pszNewGPCFileSysPath = NULL;

    PrintStatusInfo(TRUE, L"\n%s", SEARCH_GROUPPOLICY_START);

    cchLDAPPath = wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + 1;
    pszLDAPPath = new WCHAR[cchLDAPPath];
    if(!pszLDAPPath)
    {
        hr = E_OUTOFMEMORY;

        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }

    (void) StringCchCopy(pszLDAPPath, cchLDAPPath, L"LDAP://");
    (void) StringCchCat(pszLDAPPath, cchLDAPPath, argInfo.pszDCName);

    if(argInfo.pszPassword)
    {
        hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
        BAIL_ON_FAILURE(hr);
    }
    hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND |ADS_USE_SIGNING, IID_IDirectorySearch,(void**)&m_pSearch);


    if(!SUCCEEDED(hr))
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR1, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }


    // we successfully bind to the object
    fBindObject = TRUE;

    // set search preference, it is a paged search
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = 100;

    hr = m_pSearch->SetSearchPreference( prefInfo, 1);

    if(!SUCCEEDED(hr))
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR2, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }
		

    // we successfully set the search preference, now execute search

    hr = m_pSearch->ExecuteSearch(L"(objectCategory=groupPolicyContainer)", pszAttr, dwCount, &hSearch );
		
	
    if(!SUCCEEDED(hr))
    {
		
        fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR3, hr);
        BAIL_ON_FAILURE(hr);
    }

    // we successfully execute the search
    fSearch = TRUE;

    // begin the search
    hr = m_pSearch->GetNextRow(hSearch);
    
    MSG_BAIL_ON_FAILURE(hr, NEXTROW_ERROR);

    while( hr != S_ADS_NOMORE_ROWS )    
    {
        // clean the memory
        if(pszNewGPCFileSysPath)
        {
            delete [] pszNewGPCFileSysPath;
            pszNewGPCFileSysPath = NULL;
        }
                  
        // Get the distinguished name
        hr = m_pSearch->GetColumn( hSearch, pszAttr[0], &col );
	   
        if ( SUCCEEDED(hr) )
        {
            if ( pszDN )
            {
                delete [] pszDN;
                pszDN = NULL;
            }

            cchDN = wcslen(col.pADsValues->CaseIgnoreString) + 1;
            pszDN = new WCHAR[cchDN];
	        if(!pszDN)
	        {
	            hr = E_OUTOFMEMORY;
			   
	            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
	            PrintGPFixupErrorMessage(hr);
	            BAIL_ON_FAILURE(hr);
	        }
	        (void) StringCchCopy(pszDN, cchDN, col.pADsValues->CaseIgnoreString);	        
	        m_pSearch->FreeColumn( &col );

	        // print status
	        PrintStatusInfo(tokenInfo.fVerboseToken, L"%s%s", STARTPROCESSING1, pszDN);
	        
	    }
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            // dn must exist
            fSucceeded = FALSE;
	        fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR8, hr);
	        PrintGPFixupErrorMessage(hr);
            hr = m_pSearch->GetNextRow(hSearch);
            continue;
        }
        else
        {
            fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR4, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }

        // Get the gpcFileSysPath
        hr = m_pSearch->GetColumn( hSearch, pszAttr[1], &col );
        if ( SUCCEEDED(hr) )
        {
            if(col.pADsValues != NULL)
            {
                // fix the possible problem for property gpcFileSysPath
                if ( pszSysPath )
                {
                    delete [] pszSysPath;
                    pszSysPath = NULL;
                }

                cchDN = wcslen(col.pADsValues->CaseIgnoreString) + 1;
                pszSysPath = new WCHAR[cchDN];
                if(!pszSysPath)
                {
                    hr = E_OUTOFMEMORY;
                    fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
                    PrintGPFixupErrorMessage(hr);
                    BAIL_ON_FAILURE(hr);
                }

                (void) StringCchCopy(pszSysPath, cchDN, col.pADsValues->CaseIgnoreString);
                m_pSearch->FreeColumn( &col );
            }
        }
    	else if(hr == E_ADS_COLUMN_NOT_SET)
    	{
    	    // gpcFileSysPath must exist
    	    fSucceeded = FALSE;
    	    fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR7, hr);
    	    PrintGPFixupErrorMessage(hr);
    	    hr = m_pSearch->GetNextRow(hSearch);
    	    continue;
    	}
    	else
        {
            fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR5, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }


        // update the version number, if later found it is not required, we will restore it.

        {
            ADS_SEARCH_COLUMN GPOColumn;

            hr = m_pSearch->GetColumn( hSearch, pszAttr[3], &GPOColumn );

            if ( SUCCEEDED(hr) )
            {
                if(GPOColumn.pADsValues != NULL)
                {
                    
                    // fix the versionNumber
                    dwDSVNCopy = dwVersionNumber = GPOColumn.pADsValues->Integer;

                    // don't do update if it is zero
                    if(dwVersionNumber)
                    {                    
                        UpdateVersionInfo(dwVersionNumber);
                    
                        hrFix = FixGPCVersionNumber(dwVersionNumber, pszDN, argInfo);
                        if(!SUCCEEDED(hrFix))
                        {
                            fSucceeded = FALSE;
                        }
                        
                    }
			   
                    m_pSearch->FreeColumn( &GPOColumn );

                    // continue to next object if version number update failed
                    if(FAILED(hrFix))
                    {
                        hr = m_pSearch->GetNextRow(hSearch);
                        continue;
                    }
                }
            }
            else if(hr != E_ADS_COLUMN_NOT_SET)
            {
                fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR9, hr);
                PrintGPFixupErrorMessage(hr);
                BAIL_ON_FAILURE(hr);
            }
            
        }

        // if /sionly is specified, gpcFileSysPath, gpcWQLFilter operations do not need to be done
        if(!tokenInfo.fSIOnlyToken)
        {
        
            // fix the possible problem for property gpcFileSysPath
            
            hrFix = FixGPCFileSysPath(pszSysPath, pszDN, argInfo, fGPCFileSysPathChange, dwSysVNCopy, dwDSVNCopy, tokenInfo.fVerboseToken, dwSysNewVersonNum, &pszNewGPCFileSysPath);
            if(!SUCCEEDED(hrFix))
            {
                fSucceeded = FALSE;
                hr = m_pSearch->GetNextRow(hSearch);
                continue;
            }                    			   

            fVersionUpdated = TRUE;
                    
            // Get the gpcWQLFilter
            hr = m_pSearch->GetColumn( hSearch, pszAttr[2], &col );

	     
            if ( SUCCEEDED(hr) )
            {
                if(col.pADsValues != NULL)
                {
			    
                    // fix the possible problem for property gpcWQLFilter

                    hrFix = FixGPCWQLFilter(col.pADsValues->CaseIgnoreString, pszDN, argInfo, tokenInfo.fVerboseToken);
                    if(!SUCCEEDED(hrFix))
                    {
                        fSucceeded = FALSE;
                    }
			   
                    m_pSearch->FreeColumn( &col );
	            }
	        }
            else if(hr != E_ADS_COLUMN_NOT_SET)
        	{
		   
                fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR6, hr);
                PrintGPFixupErrorMessage(hr);
                BAIL_ON_FAILURE(hr);
            }
        }
        else
        {            
            // fix the version number of the gpt.ini
            hrFix = FixGPTINIFile(pszSysPath, argInfo, dwSysVNCopy, dwSysNewVersonNum);
            if(FAILED(hrFix))
            {
                fSucceeded = FALSE;

                // restore the ds version number
                FixGPCVersionNumber(dwDSVNCopy, pszDN, argInfo);

                hr = m_pSearch->GetNextRow(hSearch);
                continue;                
            }

            fVersionUpdated = TRUE;
        }

        WCHAR* wszGPOName;

        wszGPOName = L"";

        hr = m_pSearch->GetColumn( hSearch, pszAttr[4], &col );

        if ( SUCCEEDED(hr) )
        {
            wszGPOName = col.pADsValues->CaseIgnoreString;
            fGetDisplayName = TRUE;
        }

        // Fix up the software installation data
        
        BOOL   bSoftwareRequiresGPOUpdate = FALSE;
        HANDLE hUserToken = NULL;

        BOOL   fImpersonate = ImpersonateWrapper(argInfo, &hUserToken);

        hr = FixGPOSoftware(
            &argInfo,
            pszDN,
            wszGPOName,
            &bSoftwareRequiresGPOUpdate,
            tokenInfo.fVerboseToken);

        if(FAILED(hr))
        {
            fSucceeded = FALSE;
        }

        if ( fImpersonate )
        {
            RevertToSelf();

            CloseHandle( hUserToken );
        }

        if ( !fGPCFileSysPathChange && !bSoftwareRequiresGPOUpdate )
        {
            // no change so that we need to restore the version number

            // restore the ds version number
            hrFix = FixGPCVersionNumber(dwDSVNCopy, pszDN, argInfo);
            if(FAILED(hrFix))
            {
                fSucceeded = FALSE;
            }

            // restore the sys vol version number
            hrFix = RestoreGPTINIFile(pszDN, argInfo, dwSysVNCopy);
            if(FAILED(hrFix))
            {
                fSucceeded = FALSE;
            }

            fVersionUpdated = FALSE;
            
        }

        if(fVersionUpdated)
        {
            // print the status
            PrintStatusInfo(tokenInfo.fVerboseToken, L"%s%s%d%s%d", PROCESSING_GPCVERSIONNUMBER, OLDVALUE, dwDSVNCopy, NEWVALUE, dwVersionNumber);            
            PrintStatusInfo(tokenInfo.fVerboseToken, L"versionnumber in %s\\gpt.ini file is updated, old value is %d, new value is %d", pszNewGPCFileSysPath ? pszNewGPCFileSysPath : pszSysPath, dwSysVNCopy, dwSysNewVersonNum);
        }

        // free the memory
        if(fGetDisplayName)
        {
            m_pSearch->FreeColumn( &col ); 
        }

        BAIL_ON_FAILURE(hr);

        // go to next row
        fGPCFileSysPathChange = FALSE;
        hr = m_pSearch->GetNextRow(hSearch);


    }

    MSG_BAIL_ON_FAILURE(hr, NEXTROW_ERROR);

    // if succeed, print out the summary
    if( fSucceeded && tokenInfo.fVerboseToken)
    {
        fwprintf(stdout, SEARCH_GROUPPOLICY_RESULT);
    }

    if(!fSucceeded)
    {
        // some failure happens, we want to return a failure hresult
        hr = E_FAIL;
    }

error:

    if(pszLDAPPath)
    {
        delete [] pszLDAPPath;
    }

    if(pszDN)
    {
        delete [] pszDN;
    }

    if(pszSysPath)
    {
        delete [] pszSysPath;
    }

    if(pszNewGPCFileSysPath)
    {
        delete [] pszNewGPCFileSysPath;
    }

    if(fSearch)
    {
        m_pSearch->CloseSearchHandle( hSearch );
    }

    if(fBindObject)
    {
        m_pSearch->Release();
    }    

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

	
    return hr;



}

//---------------------------------------------------------------------------- 
// Function:   FixGPCLink                                                      
//                                                                             
// Synopsis:   This function fixes the gpLink attribute                        
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszSysPath  value of the gpLink attribute                                   |
// pszDN       DN of the object                                                |                                                                        
// argInfo     Information user passes in through command line                 
// pszOldDomainDNName                                                          |
//	           New Domain DN                                               |
// pszNewDomainDNName                                                          |
//             Old Domain DN                                                   |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT 
FixGPLink(
	LPWSTR pszLink,
	WCHAR* pszDN,
	const ArgInfo argInfo,
	const WCHAR  pszOldDomainDNName[],
	const WCHAR  pszNewDomainDNName[],
	const BOOL fVerbose
	)
{
    HRESULT    hr = S_OK;
    WCHAR      seps1[] = L"[";
    WCHAR      seps2[] = L",;";	
    WCHAR      separator1 [] = L"DC";
    WCHAR      separator2 [] = L"0";
    WCHAR      DNSName [MAX_DNSNAME] = L"";
	
    WCHAR*     token1 = NULL;
    WCHAR*     token2 = NULL;
	
    WCHAR*     pszMyPath = NULL;
    size_t     cchMyPath = 0;
    WCHAR      tempOldDNName [MAX_DNSNAME] = L"";
    DWORD      dwLength = 0;
    DWORD      dwToken1Pos = 0;
    WCHAR*     pszLinkCopier = NULL;
    BOOL       fChange = FALSE;
    WCHAR*     pszReleasePosition = NULL;
    size_t     cchReleasePosition = 0;
    IADs*      pObject = NULL;
    VARIANT    var;
    WCHAR*     pszLDAPPath = NULL;
    size_t     cchLDAPPath = 0;
    DWORD      i;
    DWORD      dwCount = 0;
    DWORD      dwLinkCount = 0;
    DWORD      dwIndex;
    BOOL       fGetDCBefore = FALSE;
    WCHAR*     pszTempPassword = NULL;
    IADsPathname* pPathname = NULL;
    BSTR       bstrPath = NULL;

    hr = StringCchCopy(tempOldDNName, MAX_DNSNAME, pszOldDomainDNName);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(tempOldDNName, MAX_DNSNAME, L",");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);


    cchReleasePosition = wcslen(pszLink) + 1;
    pszReleasePosition = new WCHAR[cchReleasePosition];

    if(!pszReleasePosition)
    {
        hr = E_OUTOFMEMORY;
		
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }
	
    (void) StringCchCopy(pszReleasePosition, cchReleasePosition, pszLink);
    pszLinkCopier = pszReleasePosition;
	

    dwLength = wcslen(pszLink);

    // find out how many filters are there
    for(dwIndex =0; dwIndex < wcslen(pszReleasePosition); dwIndex++)
    {
        if(L'[' == pszReleasePosition[dwIndex])
            dwLinkCount ++;
    }	

    cchMyPath = wcslen(pszLink) + DNS_MAX_NAME_LENGTH * dwLinkCount;
    pszMyPath = new WCHAR[cchMyPath];
	
    if(!pszMyPath)
    {
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
	
    (void) StringCchCopy(pszMyPath, cchMyPath, L"");

		
    // begin process the property

    // solving the possible problem of leading space
    while(pszReleasePosition[dwCount] != L'\0' && pszReleasePosition[dwCount] == L' ')
        dwCount ++;

    pszLinkCopier = &pszReleasePosition[dwCount];

    // first do the check whether the value of property is what we expect
    if(wcscmp(pszLinkCopier, L"") == 0)
    {
		
        goto error;
    }

    if( _wcsnicmp(pszLinkCopier, L"[", 1))
    {
        goto error;
    }

	 

    /* Establish string and get the first token: */
    token1 = wcstok( pszLinkCopier, seps1 );
    if(token1 != NULL)
    {
        dwToken1Pos += wcslen(token1) + wcslen(L"[");
        
    }
	
    while( token1 != NULL )
    {
        hr = StringCchCat(pszMyPath, cchMyPath, L"[");
        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    
        /* While there are tokens in "string" */
        WCHAR* temp = token1;
		
        token1 = token1 + wcslen(token1) + 1;
		
        
        //GetToken2(temp);
        token2 = wcstok( temp, seps2 );
	    
        while( token2 != NULL )
        {
	        // not begin with dc
     	    if(_wcsnicmp(token2, separator1, wcslen(L"DC")) != 0)
	        {
	            // need to concat the domain DNS name
                if(fGetDCBefore)
                {
                    if(_wcsicmp(DNSName, tempOldDNName) == 0)
                    {
                        fChange = TRUE;
                        
                        hr = StringCchCat(pszMyPath, cchMyPath, pszNewDomainDNName);
                        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                        hr = StringCchCat(pszMyPath, cchMyPath, L";");
                        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                        hr = StringCchCat(pszMyPath, cchMyPath, token2);
                        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                        
                        (void) StringCchCopy(DNSName, MAX_DNSNAME, L"");
                        fGetDCBefore = FALSE;
						
                    }
                    else
                    {
                        // remove the last ,
                        DNSName[wcslen(DNSName) - 1] = '\0';
                        
                        hr = StringCchCat(pszMyPath, cchMyPath, DNSName);
                        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                        hr = StringCchCat(pszMyPath, cchMyPath, L";");
                        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                        hr = StringCchCat(pszMyPath, cchMyPath, token2);                        
                        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                        
                        (void) StringCchCopy(DNSName, MAX_DNSNAME, L"");
                        fGetDCBefore = FALSE;
                    }
                }
                else
                {
                    hr = StringCchCat(pszMyPath, cchMyPath, token2);
                    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                    hr = StringCchCat(pszMyPath, cchMyPath, L",");
                    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                }
            }
            // begin with dc
            else
            {
                hr = StringCchCat(DNSName, MAX_DNSNAME, token2);
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
                hr = StringCchCat(DNSName, MAX_DNSNAME, L",");
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

                fGetDCBefore = TRUE;
            }
            		
            token2 = wcstok( NULL, seps2 );
			
        }
		
        if(dwToken1Pos < wcslen(pszLink))
        {
            token1 = wcstok( token1, seps1 );
            dwToken1Pos = dwToken1Pos + wcslen(token1) + wcslen(L";");
        }
        else
        {
            token1 = NULL;
        }
        
    }



    // if fChange is true, then write the object property gpLink back with the given dn

    if(fChange)
    {
        // using IADsPathname to escape the path properly
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**) &pPathname);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_COCREATE);

        hr = pPathname->Set(pszDN, ADS_SETTYPE_DN);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_SET);

        hr = pPathname->put_EscapedMode(ADS_ESCAPEDMODE_ON);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_MODE);

        hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
        MSG_BAIL_ON_FAILURE(hr, PATHNAME_ERROR_RETRIEVE);
    
        // update the properties for the object

        cchLDAPPath = wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/") + wcslen(bstrPath) + 1;
        pszLDAPPath = new WCHAR[cchLDAPPath];

        if(!pszLDAPPath)
        {
            hr = E_OUTOFMEMORY;

            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }
		
        (void) StringCchCopy(pszLDAPPath, cchLDAPPath, L"LDAP://");
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, argInfo.pszDCName);
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, L"/");
        (void) StringCchCat(pszLDAPPath, cchLDAPPath, bstrPath);

		if(argInfo.pszPassword)
        {
            hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
            BAIL_ON_FAILURE(hr);
        }
        hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND | ADS_USE_SIGNING, IID_IADs,(void**)&pObject);


        if(!(SUCCEEDED(hr)))
        {
			
            fwprintf(stderr, L"%s%x\n", GPLINK_ERROR1, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }


        VariantInit(&var);

        V_BSTR(&var) = SysAllocString(pszMyPath);
        V_VT(&var) = VT_BSTR;

        BSTR bstrgPLink = SysAllocString( L"gPLink" );
        if(!bstrgPLink)
        {
            VariantClear(&var);
            hr = E_OUTOFMEMORY;
            fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
            PrintGPFixupErrorMessage(hr);
            goto error;
        }	
        hr = pObject->Put( bstrgPLink, var );
        SysFreeString(bstrgPLink);
        VariantClear(&var);        

        MSG_BAIL_ON_FAILURE(hr, GPLINK_ERROR3);

        hr = pObject->SetInfo();        

        if(!(SUCCEEDED(hr)))
        {
			
            fwprintf(stderr, L"%s%x\n", GPLINK_ERROR2, hr);
            PrintGPFixupErrorMessage(hr);
        }
        else
        {
            // print status information
            PrintStatusInfo(fVerbose, L"%s%s%s%s%s", PROCESSING_GPLINK, OLDVALUE, pszLink, NEWVALUE, pszMyPath);
            
        }
    }

error:

    // clear the memory
    if(pszMyPath)
    {
        delete [] pszMyPath;
    }

    if(pszReleasePosition)
    {
        delete [] pszReleasePosition;
    }

    if(pszLDAPPath)
    {
		delete [] pszLDAPPath;
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    if(pPathname)
        pPathname->Release();

    if(bstrPath)
        SysFreeString(bstrPath);

    if(pObject)
        pObject->Release();		
	
    return hr;



}

//---------------------------------------------------------------------------- 
// Function:   SearchGPLinkofSite                                              
//                                                                             
// Synopsis:   This function searches for all objects of type site under       |
//             the Site container in the configuration naming context          |
//             and calls FixGPLink                                             
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argInfo     Information user passes in through command line                 
// pszOldDomainDNName                                                          |
//	           New Domain DN                                               |
// pszNewDomainDNName                                                          |
//             Old Domain DN                                                   |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT 
SearchGPLinkofSite(
	const ArgInfo argInfo,
	BOOL fVerbose,
	const WCHAR  pszOldDomainDNName[],
	const WCHAR  pszNewDomainDNName[]
	)
{
    HRESULT    hr = S_OK;
    HRESULT    hrFix = S_OK;
    IDirectorySearch *m_pSearch;
    LPWSTR     pszAttr[] = { L"distinguishedName",L"gpLink"};
    ADS_SEARCH_HANDLE hSearch;
    DWORD      dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
    ADS_SEARCH_COLUMN col;
    WCHAR*     pszDN = NULL;
    size_t     cchDN = 0;
    ADS_SEARCHPREF_INFO prefInfo[1];
    WCHAR      szForestRootDN [MAX_DNSNAME] = L"";
    IADs*      pObject;
    WCHAR      szTempPath [MAX_DNSNAME] = L"LDAP://";
    VARIANT    varProperty;
    BOOL       fBindRoot = FALSE;
    BOOL       fBindObject = FALSE;
    BOOL       fSearch = FALSE;
    BOOL       fSucceeded = TRUE;
    WCHAR*     pszTempPassword = NULL; 

    PrintStatusInfo(TRUE, L"\n%s", SEARCH_GPLINK_SITE_START);

    // get the forestroot dn

    hr = StringCchCat(szTempPath, MAX_DNSNAME, argInfo.pszDCName);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(szTempPath, MAX_DNSNAME, L"/");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(szTempPath, MAX_DNSNAME, L"RootDSE");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

	if(argInfo.pszPassword)
    {
        hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
        BAIL_ON_FAILURE(hr);
    }
    hr = ADsOpenObject(szTempPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND | ADS_USE_SIGNING, IID_IADs,(void**)&pObject);


    if(!SUCCEEDED(hr))
    {
		
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR1, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }

    // we get to the rootdse
    fBindRoot = TRUE;
    VariantInit(&varProperty);

    BSTR bstrRootDomainNamingContext = SysAllocString( L"rootDomainNamingContext" );
    if(!bstrRootDomainNamingContext)
    {
        hr = E_OUTOFMEMORY;
        fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
        PrintGPFixupErrorMessage(hr);
        goto error;
    }	
    hr = pObject->Get(bstrRootDomainNamingContext, &varProperty );
    SysFreeString(bstrRootDomainNamingContext);
    if ( SUCCEEDED(hr) )
    {		
        hr = StringCchCopy( szForestRootDN, MAX_DNSNAME , V_BSTR( &varProperty ) );
        VariantClear(&varProperty);
        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    }
    else
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR2, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }

    VariantClear(&varProperty);

    // bind to the forestrootdn
    hr = StringCchCopy(szTempPath, MAX_DNSNAME, L"LDAP://");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(szTempPath, MAX_DNSNAME, argInfo.pszDCName);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(szTempPath, MAX_DNSNAME, L"/CN=Sites,CN=Configuration,");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(szTempPath, MAX_DNSNAME, szForestRootDN);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

    hr = ADsOpenObject(szTempPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND | ADS_USE_SIGNING, IID_IDirectorySearch,(void**)&m_pSearch);



    if(!SUCCEEDED(hr))
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR3, hr);
        PrintGPFixupErrorMessage(hr);		
        BAIL_ON_FAILURE(hr);
    }


    // set search preference, it is a paged search
    fBindObject = TRUE;

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = 100;
    
    hr = m_pSearch->SetSearchPreference( prefInfo, 1);

    if(!SUCCEEDED(hr))
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR4, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }	


    // execute the search
    hr = m_pSearch->ExecuteSearch(L"(objectCategory=site)", pszAttr, dwCount, &hSearch );
    
	
    if(!SUCCEEDED(hr))
    {
		
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR5, hr);
        BAIL_ON_FAILURE(hr);
    }

    // executeSearch succeeds
    fSearch = TRUE;


    // begin the search
    hr = m_pSearch->GetNextRow(hSearch);
    
    MSG_BAIL_ON_FAILURE(hr, NEXTROW_ERROR);

    while( hr != S_ADS_NOMORE_ROWS )
    {
        // Get the distinguished name
        hr = m_pSearch->GetColumn( hSearch, pszAttr[0], &col );
	   
        if ( SUCCEEDED(hr) )
	    {
	        if (pszDN)
	        {
	            delete [] pszDN;
	            pszDN = NULL;
	        }
	        
            cchDN = wcslen(col.pADsValues->CaseIgnoreString) + 1;
            pszDN = new WCHAR[cchDN];
            if(!pszDN)
            {
                hr = E_OUTOFMEMORY;
		        
                fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
                PrintGPFixupErrorMessage(hr);
                BAIL_ON_FAILURE(hr);
            }
            (void) StringCchCopy(pszDN, cchDN, col.pADsValues->CaseIgnoreString);            
            m_pSearch->FreeColumn( &col );

            // print status
            PrintStatusInfo(fVerbose, L"%s%s", STARTPROCESSING1, pszDN);
        }  
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            // dn must exist
            fSucceeded = FALSE;
	        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR8, hr);
	        PrintGPFixupErrorMessage(hr);
            hr = m_pSearch->GetNextRow(hSearch);
            continue;
        }
        else
        {
		    
            fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR6, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }

        // Get the gpLink
        hr = m_pSearch->GetColumn( hSearch, pszAttr[1], &col );

        if ( SUCCEEDED(hr) )
        {
            if(col.pADsValues != NULL)
            {			    
                hrFix = FixGPLink(col.pADsValues->CaseIgnoreString, pszDN, argInfo, pszOldDomainDNName, pszNewDomainDNName, fVerbose); 
                if(!SUCCEEDED(hrFix))
                {
                    fSucceeded = FALSE;
                }
			    
                m_pSearch->FreeColumn( &col );
            }
        }
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            hr = m_pSearch->GetNextRow(hSearch);
            continue;
        }
        else
        {
		    
            fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR7, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }

        // go to next row
        hr = m_pSearch->GetNextRow(hSearch);
    }

    MSG_BAIL_ON_FAILURE(hr, NEXTROW_ERROR);

    if( fSucceeded && fVerbose)
    {
		
        fwprintf(stdout, SEARCH_GPLINK_SITE_RESULT);

    }

    if(!fSucceeded)
    {
        hr = E_FAIL;
    }

error:

    if(pszDN)
    {
        delete [] pszDN;
    }

    if(fBindRoot)
    {
        pObject->Release();
    }

    if(fSearch)
    {
        m_pSearch->CloseSearchHandle( hSearch );
    }

    if(fBindObject)
    {
        m_pSearch->Release();
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    return hr;



}


//---------------------------------------------------------------------------- 
// Function:   SearchGPLinkofOthers                                            
//                                                                             
// Synopsis:   This function searchs for all objects of type domainDNS or      |
//             organizationalUnit under the domain root of the renamed domain  |
//             and calls FixGPLink                                             
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argInfo     Information user passes in through command line                 
// pszOldDomainDNName                                                          |
//	           New Domain DN                                               |
// pszNewDomainDNName                                                          |
//             Old Domain DN                                                   |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT
SearchGPLinkofOthers(
	const ArgInfo argInfo,
	BOOL fVerbose,
	const WCHAR  pszOldDomainDNName[],
	const WCHAR  pszNewDomainDNName[]
	)
{
    HRESULT    hr = S_OK;
    HRESULT    hrFix = S_OK;
    IDirectorySearch *m_pSearch;
    LPWSTR     pszAttr[] = { L"distinguishedName",L"gpLink"};
    ADS_SEARCH_HANDLE hSearch;
    DWORD      dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
    ADS_SEARCH_COLUMN col;
    WCHAR*     pszDN = NULL;
    size_t     cchDN = 0;
    WCHAR      tempPath [MAX_DNSNAME] = L"";
    ADS_SEARCHPREF_INFO prefInfo[1];
    BOOL       fBindObject = FALSE;
    BOOL       fSearch = FALSE;
    BOOL       fSucceeded = TRUE;
    WCHAR*     pszTempPassword = NULL;

    PrintStatusInfo(TRUE, L"\n%s", SEARCH_GPLINK_OTHER_START);

    hr = StringCchCopy(tempPath, MAX_DNSNAME, L"LDAP://");
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
    hr = StringCchCat(tempPath, MAX_DNSNAME, argInfo.pszDCName);
    MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

    if(argInfo.pszPassword)
    {
        hr = DecryptString(argInfo.pszPassword, &pszTempPassword, argInfo.sPasswordLength);
        BAIL_ON_FAILURE(hr);
    }
    hr = ADsOpenObject(tempPath, argInfo.pszUser, pszTempPassword, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND |ADS_USE_SIGNING, IID_IDirectorySearch,(void**)&m_pSearch);




    if(!SUCCEEDED(hr))
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR1, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }

    // we successfully bind to the object
    fBindObject = TRUE;

    // set search preference, it is a paged search
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = 100;
    
    hr = m_pSearch->SetSearchPreference( prefInfo, 1);

    if(!SUCCEEDED(hr))
    {
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR2, hr);
        PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
    }	

    // execute the search

    hr = m_pSearch->ExecuteSearch(L"(|(objectCategory=domainDNS)(objectCategory=organizationalUnit))", pszAttr, dwCount, &hSearch );
		
	
    if(!SUCCEEDED(hr))
    {
		
        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR3, hr);
        BAIL_ON_FAILURE(hr);
    }

    // we successfully execute the search
    fSearch = TRUE;

    // begin the search
    hr = m_pSearch->GetNextRow(hSearch);
    
    MSG_BAIL_ON_FAILURE(hr, NEXTROW_ERROR);

    while( hr != S_ADS_NOMORE_ROWS )
    {

        // Get the distinguished name
        hr = m_pSearch->GetColumn( hSearch, pszAttr[0], &col );
	   
        if ( SUCCEEDED(hr) )
        {
            if (pszDN)
            {
                delete [] pszDN;
                pszDN = NULL;
            }

            cchDN = wcslen(col.pADsValues->CaseIgnoreString) + 1;
            pszDN = new WCHAR[cchDN];
            if(!pszDN)
            {
                hr = E_OUTOFMEMORY;

                fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
                PrintGPFixupErrorMessage(hr);
                BAIL_ON_FAILURE(hr);
            }
            (void) StringCchCopy(pszDN, cchDN, col.pADsValues->CaseIgnoreString);            
            m_pSearch->FreeColumn( &col );

            // print status
            PrintStatusInfo(fVerbose, L"%s%s", STARTPROCESSING1, pszDN);
        }
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            // dn must exist
            fSucceeded = FALSE;
	        fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR6, hr);
	        PrintGPFixupErrorMessage(hr);
            hr = m_pSearch->GetNextRow(hSearch);
            continue;
        }
        else
        {
		
            fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR4, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }

        // Get the gpLink
        hr = m_pSearch->GetColumn( hSearch, pszAttr[1], &col );
	    
        if ( SUCCEEDED(hr) )
        {
            if(col.pADsValues != NULL)
            {
                
                hrFix = FixGPLink(col.pADsValues->CaseIgnoreString, pszDN, argInfo, pszOldDomainDNName, pszNewDomainDNName, fVerbose); 
                if(!SUCCEEDED(hrFix))
                {
                    fSucceeded = FALSE;
                }
			        
                m_pSearch->FreeColumn( &col );
            }
        }
        else if(hr == E_ADS_COLUMN_NOT_SET)
        {
            hr = m_pSearch->GetNextRow(hSearch);
            continue;
        }
        else
        {
			
            fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR5, hr);
            PrintGPFixupErrorMessage(hr);
            BAIL_ON_FAILURE(hr);
        }

        // go to next row
        hr = m_pSearch->GetNextRow(hSearch);

	   
    }

    MSG_BAIL_ON_FAILURE(hr, NEXTROW_ERROR);

    if( fSucceeded && fVerbose)
    {
		
        fwprintf(stdout, SEARCH_GPLINK_OTHER_RESULT);
    }

    if(!fSucceeded)
    {
        hr = E_FAIL;
    }

error:

    if(pszDN)
    {
        delete [] pszDN;
    }
	
    if(fSearch)
    {
        m_pSearch->CloseSearchHandle( hSearch );
    }

    if(fBindObject)
    {
        m_pSearch->Release();
    }

    if(pszTempPassword)
    {
        SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
        FreeADsMem(pszTempPassword);
    }

    return hr;



}



//---------------------------------------------------------------------------- 
// Function:   wmain                                                           
//                                                                             
// Synopsis:   entry point of the program                                      
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argc        number of passed in arguments                                   
// argv        arguments                                                       |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

__cdecl wmain(int argc, WCHAR* argv[])
{

    DWORD    dwLength;
    WCHAR    *token1 = NULL;
    WCHAR    tempParameters [MAX_DNSNAME] = L"";
    HRESULT  hr = S_OK;
    WCHAR    szBuffer[PWLEN+1];
    WCHAR*   pszTempPassword = NULL;
	
    WCHAR    pszNewDomainDNName [MAX_DNSNAME] = L"";
    WCHAR    pszOldDomainDNName [MAX_DNSNAME] = L"";
	
    TokenInfo tokenInfo;
    ArgInfo argInfo;

    HINSTANCE hInstSoftwareDeploymentLibrary = NULL;
    HINSTANCE hInstScriptGenerationLibrary = NULL;

    HRESULT hrResult = S_OK;    
    
    // the number of parameters passed in is not correct
    if(argc > 9 || argc == 1)
    {        
        PrintHelpFile();
        return ;
    }

    // process the parameters passed in
    for(int i = 1; i < argc; i++)
    {
	
        // want help file
        if(_wcsicmp(argv[i], szHelpToken) == 0)
        {
            tokenInfo.fHelpToken = TRUE;
            break;
            
        }
        // get olddnsname
        else if(_wcsnicmp(argv[i], szOldDNSToken,wcslen(szOldDNSToken)) == 0)
        {
            tokenInfo.fOldDNSToken = TRUE;			
            argInfo.pszOldDNSName = &argv[i][wcslen(szOldDNSToken)];
			

        }
        // get newdnsname
        else if(_wcsnicmp(argv[i], szNewDNSToken,wcslen(szNewDNSToken)) == 0)
        {
            tokenInfo.fNewDNSToken = TRUE;
            argInfo.pszNewDNSName = &argv[i][wcslen(szNewDNSToken)];
        }
        // get oldnbname
        else if(_wcsnicmp(argv[i], szOldNBToken, wcslen(szOldNBToken)) == 0)
        {
            tokenInfo.fOldNBToken = TRUE;
            argInfo.pszOldNBName = &argv[i][wcslen(szOldNBToken)];
            
        }
        // get newnbname
        else if(_wcsnicmp(argv[i], szNewNBToken, wcslen(szNewNBToken)) == 0)
        {
            tokenInfo.fNewNBToken = TRUE;
            argInfo.pszNewNBName = &argv[i][wcslen(szNewNBToken)];
            
        }
        // get dcname
        else if(_wcsnicmp(argv[i], szDCNameToken, wcslen(szDCNameToken)) == 0)
        {
            tokenInfo.fDCNameToken = TRUE;
            argInfo.pszDCName = &argv[i][wcslen(szDCNameToken)];
            
        }
        // get the username
        else if(_wcsnicmp(argv[i], szUserToken, wcslen(szUserToken)) == 0)
        {
            argInfo.pszUser = &argv[i][wcslen(szUserToken)];
			
        }
        // get password
        else if(_wcsnicmp(argv[i], szPasswordToken, wcslen(szPasswordToken)) == 0)
        {
            argInfo.pszPassword = &argv[i][wcslen(szPasswordToken)];
			
            if(wcscmp(argInfo.pszPassword, L"*") == 0)
            {
                // prompt the user to pass in the password
				
                fwprintf( stdout, PASSWORD_PROMPT );

                if (GetPassword(szBuffer,PWLEN+1,&dwLength))
                {
                    argInfo.pszPassword = AllocADsStr(szBuffer);   

                    if(szBuffer && !(argInfo.pszPassword))
                    {
                        MSG_BAIL_ON_FAILURE(hr = E_OUTOFMEMORY, MEMORY_ERROR);
                    }
					
					
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
					
                    fwprintf(stderr, L"%s%x\n", PASSWORD_ERROR, hr);
                    fwprintf(stdout, SUMMARY_FAILURE);
                    return;
                }
            }
            else
            {
                // we use the password user passes in directly
                tokenInfo.fPasswordToken = TRUE;
             }

            pszTempPassword = argInfo.pszPassword;

            // if password is not NULL 
            if(pszTempPassword)
            {
                argInfo.pszPassword = NULL;
                hr = EncryptString(pszTempPassword, &(argInfo.pszPassword), &(argInfo.sPasswordLength));
                
                if(!tokenInfo.fPasswordToken)
                {
                    SecureZeroMemory(pszTempPassword, wcslen(pszTempPassword)*sizeof(WCHAR));
                    FreeADsStr(pszTempPassword);
                    pszTempPassword = NULL;
                }

                if(FAILED(hr))
                {
                    fwprintf(stdout, SUMMARY_FAILURE);
                    goto error;
                }
            }			
			
        }
        // get /v switch
        else if(_wcsicmp(argv[i], szVerboseToken) == 0)
        {
            tokenInfo.fVerboseToken = TRUE;
        }       
        // get /sionly switch
        else if(_wcsicmp(argv[i], szSIOnlyToken) == 0)
        {
            tokenInfo.fSIOnlyToken = TRUE;
        }
        else
        {
            fwprintf(stderr, WRONG_PARAMETER);
            PrintHelpFile();            
            return;
        }
		
		

    }

    // print out the version of gpfixup utility
    fwprintf(stdout, GPFIXUP_VERSION);


    if(tokenInfo.fHelpToken)
    {
        // user wants the helpfile
        PrintHelpFile();
        return;
    }


    // Begin the validation process
    hr = Validations(tokenInfo, argInfo);

    if(!SUCCEEDED(hr))
    {
	    fwprintf(stdout, SUMMARY_FAILURE);
        BAIL_ON_FAILURE(hr);
    }

    // if the user does not specify DNS name or old and new DNS names are identical, it means that nothing has been changed on the ds side, ds fixes will not be needed
    if(!tokenInfo.fNewDNSToken)
    {
        tokenInfo.fSIOnlyToken = TRUE;
    
    }

    if(argInfo.pszNewDNSName && argInfo.pszOldDNSName && _wcsicmp(argInfo.pszNewDNSName, argInfo.pszOldDNSName) == 0)
    {
        tokenInfo.fSIOnlyToken = TRUE;
    }
    
    

    
    // get the dc name
    if(!tokenInfo.fDCNameToken)
    {
        hr = GetDCName(&argInfo, tokenInfo.fVerboseToken);
        // get dc name failed
        if(!SUCCEEDED(hr))
        {
            // we can't get the dc name, fail here. exit gpfixup
			
            if(tokenInfo.fVerboseToken)
            {
                fwprintf(stdout, VALIDATIONS_ERROR6);
            }
            fwprintf(stdout, SUMMARY_FAILURE);
            BAIL_ON_FAILURE(hr);
        }

    }

    // if /sionly is not specified, we need to do the domain name validation
    if(!tokenInfo.fSIOnlyToken)
    {

    
        // verify dc is writeable, domain dns name and domain netbios name correspond to the same one
        hr = VerifyName(tokenInfo, argInfo);

        if(!SUCCEEDED(hr))
        {
	        fwprintf(stdout, SUMMARY_FAILURE);
            BAIL_ON_FAILURE(hr);
        }


        // get the new domain dn

        if(wcslen(argInfo.pszNewDNSName) > DNS_MAX_NAME_LENGTH)
        {
            fwprintf(stderr, L"%s\n", DNSNAME_ERROR);
            fwprintf(stdout, SUMMARY_FAILURE);
            BAIL_ON_FAILURE(hr);
        }
	
        hr = StringCchCopy(tempParameters, MAX_DNSNAME, argInfo.pszNewDNSName);
        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
		
        token1 = wcstok( tempParameters, L"." );
        while( token1 != NULL )
        {
            hr = StringCchCat(pszNewDomainDNName, MAX_DNSNAME, L"DC=");
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
            hr = StringCchCat(pszNewDomainDNName, MAX_DNSNAME, token1);
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
				
            token1 = wcstok( NULL, L"." );
            if(token1 != NULL)
            {
                hr = StringCchCat(pszNewDomainDNName, MAX_DNSNAME, L",");
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
            }
        }

		
        // get the old domain dn
 
        if(wcslen(argInfo.pszOldDNSName) > DNS_MAX_NAME_LENGTH)
        {
            fwprintf(stderr, L"%s\n", DNSNAME_ERROR);
            fwprintf(stdout, SUMMARY_FAILURE);
            BAIL_ON_FAILURE(hr);
        }

        hr = StringCchCopy(tempParameters, MAX_DNSNAME, argInfo.pszOldDNSName);
        MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);

	
        token1 = wcstok( tempParameters, L"." );
        while( token1 != NULL )
        {
            hr = StringCchCat(pszOldDomainDNName, MAX_DNSNAME, L"DC=");
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
            hr = StringCchCat(pszOldDomainDNName, MAX_DNSNAME, token1);
            MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
				
            token1 = wcstok( NULL, L"." );
            if(token1 != NULL)
            {
                hr = StringCchCat(pszOldDomainDNName, MAX_DNSNAME, L",");
                MSG_BAIL_ON_FAILURE(hr, STRING_ERROR);
            }
        }

    }

    hr = InitializeSoftwareInstallationAPI(
        &hInstSoftwareDeploymentLibrary,
        &hInstScriptGenerationLibrary );

    BAIL_ON_FAILURE(hr);

    // Fix groupPolicyContainer
    CoInitialize(NULL);

    hr = SearchGroupPolicyContainer(argInfo, tokenInfo);

    hrResult = SUCCEEDED(hr) ? hrResult : hr;


    // if /sionly is not specified, do GPLink operation
    if(!tokenInfo.fSIOnlyToken)
    {

    
        // Fix gpLink, first is the site, then is the objects of type domainDNS or organizationalUnit
        hr = SearchGPLinkofSite(argInfo, tokenInfo.fVerboseToken, pszOldDomainDNName, pszNewDomainDNName);

        hrResult = SUCCEEDED(hr) ? hrResult : hr;
    

        hr = SearchGPLinkofOthers(argInfo, tokenInfo.fVerboseToken, pszOldDomainDNName, pszNewDomainDNName);

        hrResult = SUCCEEDED(hr) ? hrResult : hr;
    }

    
    CoUninitialize( );

    if(SUCCEEDED(hrResult))
    {
    	fwprintf(stdout, SUMMARY_SUCCESS);
    }
    else
    {
    	fwprintf(stdout, SUMMARY_FAILURE);
    }


error:

    if ( hInstSoftwareDeploymentLibrary )
    {
        FreeLibrary( hInstSoftwareDeploymentLibrary );
    }

    if ( hInstScriptGenerationLibrary )
    {
        FreeLibrary( hInstScriptGenerationLibrary );
    }

    // it means that we dynamically allocation memory for pszDCNane
    if(!tokenInfo.fDCNameToken && argInfo.pszDCName)
    {
        FreeADsStr(argInfo.pszDCName);
		
    }

    if(argInfo.pszPassword)
    {
		
        FreeADsMem(argInfo.pszPassword);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\gpfixup\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_GPFIXUP1      1

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\jetinfo\jetinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jetinfo.h
//
//--------------------------------------------------------------------------

//jetinfo.h

#ifndef _JETINFO_H
#define _JETINFO_H

#define     IDM_DA_OPEN     100
#define     IDM_DA_CLOSE    101
#define		IDM_DA_EXIT     102

#define	    IDM_IN_TABLE    200
#define	    IDM_IN_COLUMN   201
#define     IDM_IN_INDEX    203

#define	    IDM_RE_COLUMN   300
#define	    IDM_RE_SEEK     301
#define     IDM_RE_MODIFY   302
#define	    IDM_RE_FIRST    303
#define	    IDM_RE_LAST     304
#define	    IDM_RE_PREV     305
#define	    IDM_RE_NEXT     306

#define IDD_DIALOG1                     101
#define IDD_DIALOG2                     102
#define IDD_DIALOG3                     103
#define IDD_DIALOG4                     104
#define IDD_DIALOG5                     105
#define IDD_DIALOG6                     106

#define IDC_BUTTON1                     1000
#define IDC_BUTTON2                     1001
#define IDC_BUTTON3                     1002
#define IDC_BUTTON4                     1003
#define IDC_BUTTON5                     1004

#define IDC_COMBO1                      1010
#define IDC_COMBO2                      1011

#define IDC_CHECK1                      1020

#define IDC_LIST1                       1030
#define IDC_LIST2                       1031

#define IDC_EDIT1                       1040
#define IDC_EDIT2                       1041
#define IDC_EDIT3                       1042
#define IDC_EDIT4                       1043
#define IDC_EDIT5                       1044

#define IDC_STATIC                      -1

#define MAX_CHAR    110
#define MAX_LINE    64
extern int giLine;
extern char aLines[MAX_LINE][MAX_CHAR];
extern long aLen[MAX_LINE];

extern HINSTANCE   ghInstance;
extern char achDbName[MAX_PATH];

extern JET_INSTANCE    gjInst;
extern JET_SESID       gjSesId;
extern JET_DBID        gjDbId;
extern JET_TABLEID     gjTblId;
extern char            gszTblName[JET_cbNameMost+1];
extern JET_COLUMNDEF*  gpjColDef;
extern char**          gppColName;
extern long            glColCount;

//status flags
extern BOOL            gfSesId;
extern BOOL            gfDbId;     
extern BOOL            gfTblId;     

//Record page
#define RECORD_PAGE 10

int OutputMessage( char* szMsg );
int AppendMessage( char* szMsg );
int OutputBuffer( char* szMsg, long lLen );
int AppendBuffer( char* szMsg, long lLen );
int AppendLineMessage( char* szMsg );
int AppendLineOutput( char* szMsg, long lLen );
int ResetScreenContent();
JET_ERR JetError( JET_ERR jErr, char* sz );

int OpenDatabase( HWND hwnd );
int CloseDatabase();
int GetTableInfo( HWND hwnd );
int GetColumnInfo( HWND hwnd );
int GetIndexInfo( HWND hwnd );
int GetTableName( HWND hCombo );
int GetColumnName( HWND hCombo1, HWND hCombo2, UINT uMsg );
int GetTableIndexName( char* szTable, HWND hCombo );
int SelectColumn( HWND hwnd );
int PrintRecord( int iRecCount );
int DoSeekRecord( HWND hwnd );
int DoModifyRecord( HWND hwnd );
int ColtypToStr( JET_COLTYP coltyp, char* szBuf );
int GrbitToStr( JET_GRBIT grbit, char* szBuf );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\jetinfo\getinfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       getinfo.c
//
//--------------------------------------------------------------------------

//getinfo.c

#include <windows.h>
#include <commdlg.h>
#include <dsjet.h>
#include <dbopen.h>
#include "jetinfo.h"

INT_PTR CALLBACK GetTableDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK GetColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK GetIndexDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
int PrintTableInfo( HWND hCombo );
int PrintColumnInfo( HWND hCombo1, HWND hCombo2 );
int GetIndexName( HWND hCombo1, HWND hCombo2 );
int PrintIndexInfo( HWND hCombo1, HWND hCombo2 );

char gszDbFilter[] = "Database Files (*.DIT)|*.DIT|Database Files (*.EDB)|*.EDB|All Files (*.*)|*.*|";

BOOL DoFileOpen( HWND hwnd, char* szFilter )
{
    OPENFILENAME ofn;
    int iLen;

    memset( &ofn, 0, sizeof(OPENFILENAME) );

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achDbName;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST;

    for( iLen = strlen(szFilter); iLen > 0; iLen-- )
    {
        if( szFilter[iLen-1] == '|' )
            szFilter[iLen-1] = '\0';
    }

    return GetOpenFileName( &ofn );
}

int OpenDatabase( HWND hwnd )
{
    JET_ERR jError;
    
    if( !DoFileOpen( hwnd, gszDbFilter ) )
        return -1;

    CloseDatabase();

    if( gfDbId )
        return -1;

    //
    // Do JetInit, BeginSession, Attach/OpenDatabase
    //

    jError = DBInitializeJetDatabase( &gjInst, &gjSesId, &gjDbId, achDbName, FALSE);
    if( jError != JET_errSuccess )
    {
        JetError( jError, "DBInit" );
        return -1;
    }
    
    gfDbId = TRUE;
    gfSesId = TRUE;
    OutputMessage( achDbName );
    AppendLineMessage( " is open" );

    return 0;
}

int CloseDatabase()
{
    if( gfDbId )
    {
        if( JetError( JetCloseDatabase( gjSesId, gjDbId, 0 ), "JetCloseDatabase" )
                == JET_errSuccess )
        {
            gfDbId = FALSE;
            achDbName[0] = '\0';
            OutputMessage( "Database is closed" );
            gfTblId = FALSE;
            gszTblName[0] = '\0';
            
            if( gfSesId )
                JetError( JetEndSession( gjSesId, 0 ), "JetEndSession" );
            JetError( JetTerm( gjInst ), "JetTerm" );
            gfSesId = FALSE;
        }
    }

    return 0;
}

int GetTableInfo( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG1), hwnd, GetTableDlgProc );

    return 0;
}

INT_PTR CALLBACK GetTableDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    PrintTableInfo( hCombo );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetTableName( HWND hCombo )
{
    JET_OBJECTLIST  jObjList;
    JET_ERR         jError;
    char szBuf[JET_cbNameMost+1];
    unsigned long ul;
    int iRet = 0;

    memset( szBuf, 0, JET_cbNameMost+1 );

	if( JetError( JetGetObjectInfo( gjSesId, gjDbId, JET_objtypTable, NULL, NULL, &jObjList, 
			sizeof(JET_OBJECTLIST), JET_ObjInfoList ), "JetGetObjectInfo" ) != JET_errSuccess )
        return -1;

	if( JetError( jError=JetMove( gjSesId, jObjList.tableid, JET_MoveFirst, 0 ), "JetMove" ) == JET_errSuccess )
	{
		do
		{
			if( JetError( JetRetrieveColumn( gjSesId, jObjList.tableid, jObjList.columnidobjectname, szBuf, 
						JET_cbNameMost, &ul, 0, NULL ), "JetRetrieveColumn" ) != JET_errSuccess )
			{
				iRet = -1;
				break;
			}

			if( ul <= JET_cbNameMost )
				szBuf[ul] = '\0';
			else
				szBuf[JET_cbNameMost] = '\0';

            SendMessage( hCombo, CB_ADDSTRING, 0, (LPARAM)szBuf );
		}
		while( (jError = JetMove( gjSesId, jObjList.tableid, JET_MoveNext, 0 )) == JET_errSuccess );
	}
	if( jError != JET_errNoCurrentRecord )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}
    
    JetError( JetCloseTable(gjSesId, jObjList.tableid), "JetCloseTable" );

    return iRet;
}

int PrintTableInfo( HWND hCombo )
{
    int iIndex;
    char szBuf[JET_cbNameMost+1];

    iIndex = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );

    if( iIndex == CB_ERR )
        return 0;

    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)szBuf );

    OutputMessage( szBuf );

    return 0;
}

int GetColumnInfo( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG2), hwnd, GetColumnDlgProc );

    return 0;
}

INT_PTR CALLBACK GetColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo1, hCombo2;

                    hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                    hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                    PrintColumnInfo( hCombo1, hCombo2 );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            if( LOWORD(wParam) == IDC_BUTTON1 )
                            {
                                HWND hCombo1, hCombo2;

                                hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                GetColumnName( hCombo1, hCombo2, CB_ADDSTRING );
                                return TRUE;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hCombo2;

                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                SendMessage( hCombo2, CB_RESETCONTENT, 0, 0 );
                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetColumnName( HWND hCombo1, HWND hCombo2, UINT uMsg )
{
    JET_COLUMNLIST jColList;
    JET_ERR        jError;
    char szBuf[JET_cbNameMost+1];
    int iRet;
    unsigned long ulCount, ul;

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szBuf );

	if( JetError( JetGetColumnInfo( gjSesId, gjDbId, szBuf, NULL, &jColList, 
		sizeof(JET_COLUMNLIST), JET_ColInfoList ), "JetGetColumnInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jColList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

	for( ulCount=0; ulCount<jColList.cRecord && jError==JET_errSuccess; ulCount++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jColList.tableid, jColList.columnidcolumnname, szBuf, 
					JET_cbNameMost, &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        if( ul <= JET_cbNameMost )
            szBuf[ul] = '\0';
        else
            szBuf[JET_cbNameMost] = '\0';
        SendMessage( hCombo2, uMsg, 0, (LPARAM)szBuf );

		jError = JetMove( gjSesId, jColList.tableid, JET_MoveNext, 0 );
	}

    if( ulCount < jColList.cRecord )
		JetError( jError, "JetMove" );
    else
        SendMessage( hCombo2, CB_SETCURSEL, 0, 0 );

    JetError( JetCloseTable( gjSesId, jColList.tableid ), "JetCloseTable" );

    return iRet;
}

int PrintColumnInfo( HWND hCombo1, HWND hCombo2 )
{
    JET_COLUMNDEF   jColDef;
    char szTable[JET_cbNameMost+1];
    char szColumn[JET_cbNameMost+1];
    int iRet;

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szTable );

    iRet = (int)SendMessage( hCombo2, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo2, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szColumn );

	if( JetError( JetGetColumnInfo( gjSesId, gjDbId, szTable, szColumn, &jColDef, 
		    sizeof(JET_COLUMNDEF), JET_ColInfo ), "JetGetColumnInfo" ) != JET_errSuccess )
		return -1;

    OutputMessage( szTable );
    AppendMessage( szColumn );
    wsprintf( szColumn, "Column ID: %lu", jColDef.columnid );
    AppendMessage( szColumn );
    strcpy( szColumn, "Column Type: " );
    ColtypToStr( jColDef.coltyp, szColumn + strlen(szColumn) );
    AppendMessage( szColumn );
    wsprintf( szColumn, "cbMax: %lu", jColDef.cbMax );
    AppendMessage( szColumn );
    strcpy( szColumn, "Column grbit: " );
    GrbitToStr( jColDef.grbit, szColumn + strlen(szColumn) );
    AppendMessage( szColumn );

    return 0;
}

int GetIndexInfo( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG3), hwnd, GetIndexDlgProc );

    return 0;
}

INT_PTR CALLBACK GetIndexDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo1, hCombo2;

                    hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                    hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                    PrintIndexInfo( hCombo1, hCombo2 );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            if( LOWORD(wParam) == IDC_BUTTON1 )
                            {
                                HWND hCombo1, hCombo2;

                                hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                GetIndexName( hCombo1, hCombo2 );
                                return TRUE;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hCombo2;

                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                SendMessage( hCombo2, CB_RESETCONTENT, 0, 0 );
                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetIndexName( HWND hCombo1, HWND hCombo2 )
{
    int iRet;
    char szBuf[JET_cbNameMost+1];

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szBuf );

    return GetTableIndexName( szBuf, hCombo2 );
}

int GetTableIndexName( char* szTable, HWND hCombo2 )
{
    JET_INDEXLIST  jIndexList;
    JET_ERR        jError;
    char szBuf[JET_cbNameMost+1];
    int iRet = 0;
    unsigned long ulCount, ul;

	if( JetError( JetGetIndexInfo( gjSesId, gjDbId, szTable, NULL, &jIndexList, 
		sizeof(JET_INDEXLIST), JET_IdxInfoList ), "JetGetIndexInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

	for( ulCount=0; ulCount<jIndexList.cRecord && jError==JET_errSuccess; ulCount++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidindexname, szBuf, 
					JET_cbNameMost, &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        if( ul <= JET_cbNameMost )
            szBuf[ul] = '\0';
        else
            szBuf[JET_cbNameMost] = '\0';

        if( SendMessage( hCombo2, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)szBuf ) == CB_ERR )
            SendMessage( hCombo2, CB_ADDSTRING, 0, (LPARAM)szBuf );

		jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveNext, 0 );
	}

    if( ulCount < jIndexList.cRecord )
		JetError( jError, "JetMove" );
    else
        SendMessage( hCombo2, CB_SETCURSEL, 0, 0 );

    JetError( JetCloseTable( gjSesId, jIndexList.tableid ), "JetCloseTable" );

    return iRet;
}

int PrintIndexInfo( HWND hCombo1, HWND hCombo2 )
{
    JET_INDEXLIST  jIndexList;
    JET_GRBIT      jgrBit;
    JET_ERR         jError;
    char szTable[JET_cbNameMost+1];
    char szIndex[JET_cbNameMost+1];
    int iRet;
    unsigned long ul, ulCount;

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szTable );

    iRet = (int)SendMessage( hCombo2, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo2, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szIndex );

    OutputMessage( szTable );
    AppendMessage( szIndex );

	if( JetError( JetGetIndexInfo( gjSesId, gjDbId, szTable, szIndex, &jIndexList, 
		    sizeof(JET_INDEXLIST), JET_IdxInfo ), "JetGetIndexInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

    if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidgrbitIndex, &jgrBit, 
					sizeof(JET_GRBIT), &ul, 0, NULL ) ) != JET_errSuccess )
	{
		JetError( jError, "JetRetrieveColumn" );
		return -1;
	}

    wsprintf( szTable, "Index grbit: 0X%lX", jgrBit );
    AppendMessage( szTable );

	for( ulCount=0; ulCount<jIndexList.cRecord && jError==JET_errSuccess; ulCount++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidcolumnname, 
                    szIndex, JET_cbNameMost, &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        if( ul <= JET_cbNameMost )
            szIndex[ul] = '\0';
        else
            szIndex[JET_cbNameMost] = '\0';

        AppendMessage( szIndex );

		jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveNext, 0 );
	}

    if( ulCount < jIndexList.cRecord )
		JetError( jError, "JetMove" );

    JetError( JetCloseTable( gjSesId, jIndexList.tableid ), "JetCloseTable" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\gpfixup\helper.h ===
// Help information
#define PASSWORD_PROMPT                 L"Please type the password: "
#define PASSWORD_ERROR                  L"There was an error in reading the password: "
#define WRONG_PARAMETER                 L"Invalid parameter.\n"

#define VALIDATIONS_ERROR1              L"Invalid parameter, either /newdns or /newnb must be specified.\n"
#define VALIDATIONS_ERROR2              L"Invalid parameter, /newnb and /oldnb should both be specified.\n"
#define VALIDATIONS_ERROR3              L"There is no fix up to be done as the DNS name and NetBIOS name of domain have not changed.\n"
#define VALIDATIONS_ERROR6              L"Failed to get the domain controller name.\n"
#define VALIDATIONS_ERROR7              L"Invalid parameter, /newdns and /olddns should both be specified.\n"
#define VALIDATIONS_RESULT              L"\nValidations of gpfixup passed.\n"

#define VERIFYNAME_ERROR1               L"Failed to get the domain controller info : "
#define VERIFYNAME_ERROR2               L"Domain controller is not writable, exit from gpfixup.\n"
#define VERIFYNAME_ERROR3               L"New Domain DNS name does not exist on the specified domain controller.\n"
#define VERIFYNAME_ERROR4               L"New Domain NetBIOS name does not exist on the specified domain controller.\n"

#define MEMORY_ERROR                    L"Out of memory: "
#define STRING_ERROR                    L"String buffer error: "
#define ENCRYPTION_ERROR                L"Encryption error: "
#define DECRYPTION_ERROR                L"Decryption error: "
#define PATHNAME_ERROR_COCREATE         L"Failed to create Pathname object: "
#define PATHNAME_ERROR_SET              L"Failed to do Set on Pathname object: "
#define PATHNAME_ERROR_MODE             L"Failed to set escaping mode on Pathname object: "
#define PATHNAME_ERROR_RETRIEVE         L"Failed to do Retrieve on Pathname object: "
#define NEXTROW_ERROR                   L"Failed to retrieve next row of search result: "

#define GPCFILESYSPATH_ERROR1           L"Failed to bind to the object when trying to update gPCFileSysPath: "
#define GPCFILESYSPATH_ERROR2           L"Failed to do SetInfo when trying to update gPCFileSysPath: "
#define GPCFILESYSPATH_ERROR3           L"Failed to do Put when trying to update gPCFileSysPath: "
#define GPCWQLFILTER_ERROR1             L"Failed to bind to the object when trying to update gPCWQLFilter: "
#define GPCWQLFILTER_ERROR2             L"Failed to do SetInfo when trying to update gPCWQLFilter: "
#define GPCWQLFILTER_ERROR3             L"Failed to do Put when trying to update gPCWQLFilter: "
#define GPCVERSIONNUMBER_ERROR1         L"Failed to bind to the object when trying to update versionNumber: "
#define GPCVERSIONNUMBER_ERROR2         L"Failed to do SetInfo when trying to update versionNumber: "
#define GPCVERSIONNUMBER_ERROR3         L"Failed to do Put when trying to update versionNumber: "

#define GPTINIFILE_ERROR1               L"Can't retrieve versionNumber from GPT.INI file in SYSVOL:\n"
#define GPTINIFILE_ERROR2               L"Failed to update the versionNumber from GPT.INI file in SYSVOL :\n"
#define GPTINIFILE_ERROR3               L"Failed to bind to the object when trying to get the gpcFileSysPath: \n" 
#define GPTINIFILE_ERROR4               L"Failed to get the gpcFileSysPath value: \n"

#define GPLINK_ERROR1                   L"Failed to bind to the object when trying to update group policy link : "
#define GPLINK_ERROR2                   L"Failed to do SetInfo when trying to update group policy link : "
#define GPLINK_ERROR3                   L"Failed to do Put when trying to update group policy link : "

#define GETDCNAME_ERROR1                L"Could not get the domain controller name: "
#define DC_NAME                         L"Domain controller name is "

#define SEARCH_GPLINK_OTHER_START        L"\nStart fixing non-site group policy links:"
#define SEARCH_GPLINK_OTHER_ERROR1       L"Failed to bind to the object when trying to do the search for fixing non-site group policy link : "
#define SEARCH_GPLINK_OTHER_ERROR2       L"Failed to set the search preference when trying to do the search for fixing gpLink other than site : "
#define SEARCH_GPLINK_OTHER_ERROR3       L"Failed to execute search when trying to search for non-site group policy link : "
#define SEARCH_GPLINK_OTHER_ERROR4       L"Failed to get DN when trying to search for non-site group policy link : "
#define SEARCH_GPLINK_OTHER_ERROR5       L"Failed to get gpLink when trying to search for non-site group policy link : "
#define SEARCH_GPLINK_OTHER_ERROR6       L"dn does not exist, it is a must-exist property :"
#define SEARCH_GPLINK_OTHER_RESULT       L"\nFixup of non-site group policy links succeeded\n"

#define SEARCH_GPLINK_SITE_START         L"\nStart fixing site group policy links:"
#define SEARCH_GPLINK_SITE_ERROR1        L"Failed to bind to the RootDSE when trying to search for fixing site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR2        L"Failed to get rootDomainNamingContext when trying to search for fixing site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR3        L"Failed to bind to the object when trying to search for fixing site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR4        L"Failed to set the search preference when trying to search for fixing site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR5        L"Failed to execute search when trying to do search for site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR6        L"Failed to get dn when trying to search for site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR7        L"Failed to get gpLink when trying to search for site group policy link : "
#define SEARCH_GPLINK_SITE_ERROR8        L"dn does not exist, it is a must-exist property :"
#define SEARCH_GPLINK_SITE_RESULT        L"\nFixup of site group policy links succeeded\n"

#define SEARCH_GROUPPOLICY_START         L"\nStart fixing group policy (GroupPolicyContainer) objects:"
#define SEARCH_GROUPPOLICY_ERROR1        L"Failed to bind to the object when trying to search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR2        L"Failed to set the search preference when trying to search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR3        L"Failed to execute search when trying to search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR4        L"Failed to get dn when trying to do search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR5        L"Failed to get gpcFileSysPath when trying to search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR6        L"Failed to get gpcWQLFilter when trying to search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR7        L"gpcFileSysPath does not exist, it is a must-exist property : "
#define SEARCH_GROUPPOLICY_ERROR8        L"dn does not exist, it is a must-exist property :"
#define SEARCH_GROUPPOLICY_ERROR9        L"Failed to get versionNumber when trying to search for GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_RESULT        L"\nFixup of group policy (GroupPolicyContainer) objects succeeded\n"

#define SOFTWARE_SEARCH_ERROR            L"Failed to search the Group Policy Object for Software Installation Settings : "
#define SOFTWARE_READ_ERROR              L"Failed to read Active Directory data for a Software Installation setting : "
#define SOFTWARE_DS_WRITE_ERROR          L"Failed to write Active Directory data for a Software Installation setting : "
#define SOFTWARE_SCRIPTGEN_WARNING       L"Warning: Failed to write sysvol data for a Software Installation setting deployed at the following file system paths -- this is only fatal if any these paths require a change due to a domain rename : "
#define SOFTWARE_SDP_LISTITEM            L"\tPossible failure changing making the following change : "
#define SOFTWARE_SDP_ORIGINAL            L"\tOriginal Path : "
#define SOFTWARE_SDP_RENAMED             L"\tRenamed Path : "
#define SOFTWARE_SYSVOL_WRITE_WARNING    L"Warning: Failed to write sysvol data for a Software Installation setting with the following error : "

#define SOFTWARE_SETTING_FAIL            L"Failed to update the following Software Installation setting : "
#define SOFTWARE_SETTING_WARNING         L"Warning: Failed to update the following Software Installation setting : "
#define SOFTWARE_GPO_STATUS_WARNING      L"Warning: A possible failure occurred attempting to update Software Installation settings for the following Group Policy Object : "
#define SOFTWARE_GPO_STATUS              L"A failure occurred attempting to update Software Installation settings for the following Group Policy Object : "

#define DLL_LOAD_ERROR                   L"Could not load ntdsbmsg.dll\n"
#define SI_DLL_LOAD_ERROR                L"Could not load appmgmts.dll and appmgr.dll\n"
#define ERRORMESSAGE_NOT_FOUND           L"Error message not found\n"

#define DNSNAME_ERROR                    L"DNSName is too long (more than 1024 characters)\n"

#define SUMMARY_SUCCESS                  L"\ngpfixup tool executed with success.\n"
#define SUMMARY_FAILURE                  L"\nThere are some errors during the execution of gpfixup tool, please check.\n"

#define GPFIXUP_VERSION                  L"Group Policy fix up utility Version 1.1 (Microsoft)\n"
#define STARTPROCESSING1                 L"\nStart processing object "
#define OLDVALUE                         L"old value is "
#define NEWVALUE                         L", new value is "
#define PROCESSING_GPCVERSIONNUMBER      L"versionnumber attribute is updated, "
#define PROCESSING_GPCWQLFILTER          L"gPCWQLFilter attribute is updated, "
#define PROCESSING_GPLINK                L"gPLink attribute is updated, "
#define PROCESSING_GPCFILESYSPATH        L"gPCFileSysPath attribute is updated, "




const WCHAR    szHelpToken [] = L"/?";
const WCHAR    szOldDNSToken [] = L"/OLDDNS:";
const WCHAR    szNewDNSToken [] = L"/NEWDNS:";
const WCHAR    szOldNBToken [] = L"/OLDNB:";
const WCHAR    szNewNBToken [] = L"/NEWNB:";
const WCHAR    szDCNameToken [] = L"/DC:";
const WCHAR    szUserToken [] = L"/USER:";
const WCHAR    szPasswordToken [] = L"/PWD:";
const WCHAR    szVerboseToken [] = L"/v";
const WCHAR    szSIOnlyToken [] = L"/sionly";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\jetinfo\record.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       record.c
//
//--------------------------------------------------------------------------

//record.c

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dsjet.h>
#include "jetinfo.h"

#define TEMP_BUF_SIZE   MAX_CHAR

INT_PTR CALLBACK SelectColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK SeekRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ModifyRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

int OpenTable( HWND hCombo );
int MoveColumnName( HWND hList1, HWND hList2 );
int MoveSelectColumnName( HWND hList1, HWND hList2 );
int GetColumns( HWND hCombo, HWND hCtrl );
int SeekRecord( HWND hCombo, HWND hList );
int SelectCurrentIndex( HWND hCombo );
int AppendCurrentRecord();
int PrintCurrentRecord();
int GetOpenTableColumns( HWND hCombo );
int SetColumnProperties( int iCol, HWND hEditType, HWND hEditGrbit );
int GetColumnValue( int iCol, HWND hList );
int ResetNewValue( HWND hwnd );
int ModifyRecordColumn( int iCol, HWND hEditNewValue, HWND hEditTagSeq, HWND hEditLongOffset );

int SelectColumn( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG4), hwnd, SelectColumnDlgProc );

    return 0;
}

INT_PTR CALLBACK SelectColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo, hList2;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    if( ! OpenTable( hCombo ) )
                    {
                        hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                        GetColumns( hCombo, hList2 );
                    }
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            switch( LOWORD(wParam) )
                            {
                                case IDC_BUTTON1:
                                {
                                    HWND hCombo, hList;

                                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                                    SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                    GetColumnName( hCombo, hList, LB_ADDSTRING );
                                    //Clear the content in list box 2
                                    hList = GetDlgItem( hwnd, IDC_LIST2 );
                                    SendMessage( hList, LB_RESETCONTENT, 0, 0 );

                                    return TRUE;
                                }

                                case IDC_BUTTON2:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveColumnName( hList1, hList2 );

                                    return TRUE;
                                }

                                case IDC_BUTTON3:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveSelectColumnName( hList1, hList2 );

                                    return TRUE;
                                }

                                case IDC_BUTTON4:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveSelectColumnName( hList2, hList1 );

                                    return TRUE;
                                }

                                case IDC_BUTTON5:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveColumnName( hList2, hList1 );

                                    return TRUE;
                                }

                                default:
                                    break;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hList;

                                hList = GetDlgItem( hwnd, IDC_LIST1 );
                                SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                hList = GetDlgItem( hwnd, IDC_LIST2 );
                                SendMessage( hList, LB_RESETCONTENT, 0, 0 );

                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int OpenTable( HWND hCombo )
{
    int iRet;

    if( gfTblId )
    {
        if( JetError( JetCloseTable( gjSesId, gjTblId ), "JetCloseTable" ) == JET_errSuccess )
        {
            gfTblId = FALSE;
            gszTblName[0] = '\0';
        }
        else
            return -1;
    }

    //Gettable name
    iRet = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)gszTblName );

    if( JetError( JetOpenTable( gjSesId, gjDbId, gszTblName, NULL, 0, 0, &gjTblId ), "JetOpenTable" )
            == JET_errSuccess )
    {
        gfTblId = TRUE;
        OutputMessage( gszTblName );
        AppendLineMessage( " is open" );
        return 0;
    }
    else
    {
        gszTblName[0] = '\0';
        return -1;
    }
}

int MoveColumnName( HWND hList1, HWND hList2 )
{
    char szBuf[JET_cbNameMost+1];
    int iCount, i;

    iCount = (int)SendMessage( hList1, LB_GETCOUNT, 0, 0 );
    for( i=0; i<iCount; i++ )
    {
        SendMessage( hList1, LB_GETTEXT, (WPARAM)i, (LPARAM)szBuf );
        SendMessage( hList2, LB_ADDSTRING, 0, (LPARAM)szBuf );
    }

    SendMessage( hList1, LB_RESETCONTENT, 0, 0 );

    return 0;
}

int MoveSelectColumnName( HWND hList1, HWND hList2 )
{
    char szBuf[JET_cbNameMost+1];
    int iIndex;

    iIndex = (int)SendMessage( hList1, LB_GETCURSEL, 0, 0 );
    if( iIndex == LB_ERR )
        return -1;

    SendMessage( hList1, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)szBuf );
    SendMessage( hList2, LB_ADDSTRING, 0, (LPARAM)szBuf );
    SendMessage( hList1, LB_DELETESTRING, (WPARAM)iIndex, 0 );

    return 0;
}

int GetColumns( HWND hCombo, HWND hList )
{
    char szTable[JET_cbNameMost+1];
    char szColumn[JET_cbNameMost+1];
    int iIndex, i;

    iIndex = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
    if( iIndex == CB_ERR )
        return -1;
    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)szTable );

    iIndex = (int)SendMessage( hList, LB_GETCOUNT, 0, 0 );
    if( iIndex == LB_ERR )
        return -1;

    if( gppColName )
    {
        for( i=0; i<glColCount; i++ )
        {
            if( *(gppColName + i) )
                free( *(gppColName + i) );
        }
    }

    if( iIndex == 0 )
    {
        if( gpjColDef )
        {
            free( gpjColDef );
            gpjColDef = NULL;
        }

        if( gppColName )
        {
            free( gppColName );
            gppColName = NULL;
        }
    }
    else {
        PVOID tmp;
        tmp = realloc( gpjColDef, iIndex * sizeof(JET_COLUMNDEF) );
        if (tmp == NULL) return -1;
        gpjColDef = (JET_COLUMNDEF*)tmp;
        tmp = realloc( gppColName, iIndex * sizeof(char*) );
        if (tmp == NULL) return -1;
        gppColName = (char**)tmp;
        memset( gppColName, 0, iIndex * sizeof(char*) );
    }
    glColCount = iIndex;

    for( i=0; i<iIndex; i++ )
    {
        SendMessage( hList, LB_GETTEXT, (WPARAM)i, (LPARAM)szColumn );
        
        *(gppColName + i) = (char*)malloc( strlen(szColumn) + 1);
        if( *(gppColName + i) == NULL )
            return -1;
        strcpy( *(gppColName + i), szColumn );
	    if( JetError( JetGetColumnInfo( gjSesId, gjDbId, szTable, szColumn, gpjColDef + i, 
		        sizeof(JET_COLUMNDEF), JET_ColInfo ), "JetGetColumnInfo" ) != JET_errSuccess )
		    return -1;
    }

    return 0;
}

int PrintRecord( int iRecCount )
{//Table cursor has been moved to the location of the first record to print
    int i;
    JET_ERR jError = JET_errSuccess;

    if( glColCount == 0 )
        return 0;
    OutputMessage( *gppColName );
    for( i=1; i<glColCount; i++ )
    {
        AppendLineOutput( ";", 1 );
        AppendLineOutput( *(gppColName+i), strlen(*(gppColName+i)) );
    }

    for( i=0; (i<iRecCount) && (jError==JET_errSuccess); i++ )
    {
        if( AppendCurrentRecord() )
            break;
        jError = JetMove( gjSesId, gjTblId, JET_MoveNext, 0 );
    }

    return 0;
}

int AppendCurrentRecord()
{
    int j, iOffset, iSize;
    char pBuf[TEMP_BUF_SIZE];
    char pCol[TEMP_BUF_SIZE];
    unsigned long ulActual;
    JET_ERR jError = JET_errSuccess;
    JET_COLUMNDEF* pjColDef;
    JET_RETINFO jRetInfo;

    jRetInfo.cbStruct = sizeof( JET_RETINFO );
    jRetInfo.ibLongValue = 0;

    for( j=0, iOffset=0; j<glColCount; j++ )
    {
        jRetInfo.itagSequence = 1;
        pjColDef = gpjColDef + j;

        do
        {
            jError = JetRetrieveColumn( gjSesId, gjTblId, pjColDef->columnid, pCol, TEMP_BUF_SIZE,
                        &ulActual, 0, &jRetInfo );

            if( jError != JET_errSuccess )
            {
                if( jError == JET_wrnColumnNull )
                {//If this is the first tag sequence, print "(0)", plus separator ";" when needed
                    if( jRetInfo.itagSequence == 1 )
                    {
                        if( j == 0 )
                            AppendMessage( "(0)" );
                        else
                            AppendLineMessage( ";(0)" );
                    }

                    break;
                }
                else if( jError != JET_wrnBufferTruncated )
                {
                    JetError( jError, "JetRetrieveColumn" );
                    return -1;
                }
            }

            wsprintf( pBuf, "(%lu)", ulActual );
            if( j==0 && jRetInfo.itagSequence == 1 )
                AppendMessage( pBuf );
            else
            {
                if( jRetInfo.itagSequence == 1 )
                    AppendLineMessage( ";" );
                else
                    AppendLineMessage( "," );
                AppendLineOutput( pBuf, strlen(pBuf) );
            }

            switch( pjColDef->coltyp )
            {
                case JET_coltypText:
                case JET_coltypLongText:
                    AppendLineOutput( pCol, (ulActual>TEMP_BUF_SIZE) ? TEMP_BUF_SIZE : (long)ulActual );
                    break;

                case JET_coltypLong:
                    iSize = wsprintf( pBuf, "%li", *(long*)pCol );
                    AppendLineOutput( pBuf, iSize );
                    break;

                default:
                    iSize = 0;
                    for( iOffset = 0; ulActual > 0 && iOffset < 8; ulActual--, iOffset++ )
                    {
                        iSize += wsprintf( pBuf + iSize, "%02X", *(pCol+iOffset) );
                    }
                    AppendLineOutput( pBuf, iSize );
                    break;
            }

            jRetInfo.itagSequence++;
        }
        while( JET_bitColumnTagged & pjColDef->grbit );
    }

    return 0;
}

int PrintCurrentRecord()
{//Table cursor has been moved to the location of the current record to print
    int i;

    if( glColCount == 0 )
        return 0;
    OutputMessage( *gppColName );
    for( i=1; i<glColCount; i++ )
    {
        AppendLineOutput( ";", 1 );
        AppendLineOutput( *(gppColName+i), strlen(*(gppColName+i)) );
    }

    AppendCurrentRecord();

    return 0;
}

int DoSeekRecord( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfTblId )
    {
        OutputMessage( "Table not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG5), hwnd, SeekRecordDlgProc );

    return 0;
}

INT_PTR CALLBACK SeekRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo, hList;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                    SeekRecord( hCombo, hList );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            switch( LOWORD(wParam) )
                            {
                                case IDC_BUTTON1:
                                {
                                    HWND hEdit, hList;
                                    char pKey[TEMP_BUF_SIZE+1];

                                    hEdit = GetDlgItem( hwnd, IDC_EDIT1 );
                                    GetWindowText( hEdit, pKey, TEMP_BUF_SIZE );
                                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                                    SendMessage( hList, LB_ADDSTRING, 0, (LPARAM)pKey );
                                    return TRUE;
                                }

                                case IDC_BUTTON2:
                                {
                                    HWND hList;

                                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                                    SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                    return TRUE;
                                }

                                default:
                                    break;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hList;

                                hList = GetDlgItem( hwnd, IDC_LIST1 );
                                SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableIndexName( gszTblName, hCombo );
            SelectCurrentIndex( hCombo );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int SelectCurrentIndex( HWND hCombo )
{
    char szIndex[JET_cbNameMost+1];
    int iIndex = 0;

    if( JetError( JetGetCurrentIndex( gjSesId, gjTblId, szIndex, JET_cbNameMost ), "JetGetCurrentIndex" ) 
            == JET_errSuccess )
    {
        iIndex = (int)SendMessage( hCombo, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)szIndex );
        iIndex = (iIndex == CB_ERR) ? 0 : iIndex;
    }

    SendMessage( hCombo, CB_SETCURSEL, (WPARAM)iIndex, 0 );

    return 0;
}

int SeekRecord( HWND hCombo, HWND hList )
{
    JET_INDEXLIST  jIndexList;
    JET_COLTYP      jColtyp;
    JET_ERR         jError;
    char szBuf[JET_cbNameMost+1];
    int iIndex, iCount, iLen, i, iRet;
    unsigned long ul;

    iIndex = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
    if( iIndex == CB_ERR )
        return -1;
    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)szBuf );

    iCount = (int)SendMessage( hList, LB_GETCOUNT, 0, 0 );

    if( JetError( JetSetCurrentIndex2(gjSesId, gjTblId, szBuf, JET_bitMoveFirst), "JetSetCurrentIndex" ) 
            != JET_errSuccess )
        return -1;

	if( JetError( JetGetIndexInfo( gjSesId, gjDbId, gszTblName, szBuf, &jIndexList, 
		    sizeof(JET_INDEXLIST), JET_IdxInfo ), "JetGetIndexInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

	for( iIndex=0; (iIndex<iCount) && (iIndex<(int)jIndexList.cRecord) && (jError==JET_errSuccess); 
            iIndex++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidcoltyp, 
                    &jColtyp, sizeof(JET_COLTYP), &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        iLen = (int)SendMessage( hList, LB_GETTEXTLEN, (WPARAM)iIndex, 0 );
        if( (iLen != LB_ERR) && (iLen <= JET_cbNameMost) )
            SendMessage( hList, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)szBuf );
        else
        {
            OutputMessage( "Value too long" );
			iRet = -1;
			break;
        }

        switch( jColtyp )
        {
            case JET_coltypText:
            case JET_coltypLongText:
                break;

            case JET_coltypLong:
            {
                long lTemp;

                lTemp = atol(szBuf);
                memcpy( szBuf, &lTemp, sizeof(long) );
                iLen = sizeof(long);
            }
                break;

            default:
                //binary format
                iLen /= 2;
                for( i=0; i<iLen; i++ )
                {
                    unsigned long ulTemp;
                    if (sscanf( szBuf+2*i, "%2x", &ulTemp ) == 1)
                        szBuf[i] = (char)((unsigned char)ulTemp);
                    else
                        szBuf[i] = '?';
                }
                break;
        }

		if( (jError = JetMakeKey( gjSesId, gjTblId, szBuf, (unsigned long)iLen, 
                iIndex ? 0 : JET_bitNewKey )) != JET_errSuccess )
		{
			JetError( jError, "JetMakeKey" );
			iRet = -1;
			break;
		}

		jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveNext, 0 );
	}

    if( (iIndex != iCount) && (iIndex != (int)jIndexList.cRecord) )
		JetError( jError, "JetMove" );

    JetError( JetCloseTable( gjSesId, jIndexList.tableid ), "JetCloseTable" );

    jError = JetError( JetSeek( gjSesId, gjTblId, JET_bitSeekGE ), "JetSeek" );
    if( jError == JET_errSuccess 
     || jError == JET_wrnSeekNotEqual )
        PrintCurrentRecord();   //Cursor remains on current record

    return 0;
}

int DoModifyRecord( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfTblId )
    {
        OutputMessage( "Table not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG6), hwnd, ModifyRecordDlgProc );

    return 0;
}

INT_PTR CALLBACK ModifyRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo, hEditNewValue, hEditTagSeq, hEditLongOffset;
                    int iCol;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    iCol = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
                    hEditNewValue = GetDlgItem( hwnd, IDC_EDIT3 );
                    hEditTagSeq = GetDlgItem( hwnd, IDC_EDIT4 );
                    hEditLongOffset = GetDlgItem( hwnd, IDC_EDIT5 );
                    ModifyRecordColumn( iCol, hEditNewValue, hEditTagSeq, hEditLongOffset );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    if( (HIWORD(wParam) == CBN_SELCHANGE) && (LOWORD(wParam) == IDC_COMBO1) )
                    {
                        HWND hCombo, hEditType, hEditGrbit, hList;
                        int iItem;

                        hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                        iItem = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
                        hEditType = GetDlgItem( hwnd, IDC_EDIT1 );
                        hEditGrbit = GetDlgItem( hwnd, IDC_EDIT2 );
                        SetColumnProperties( iItem, hEditType, hEditGrbit );
                        hList = GetDlgItem( hwnd, IDC_LIST1 );
                        GetColumnValue( iItem, hList );
                        ResetNewValue( hwnd );
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo, hEditType, hEditGrbit, hList;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetOpenTableColumns( hCombo );
            hEditType = GetDlgItem( hwnd, IDC_EDIT1 );
            hEditGrbit = GetDlgItem( hwnd, IDC_EDIT2 );
            SetColumnProperties( 0, hEditType, hEditGrbit );
            hList = GetDlgItem( hwnd, IDC_LIST1 );
            GetColumnValue( 0, hList );
            ResetNewValue( hwnd );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetOpenTableColumns( HWND hCombo )
{
    long lCount;

	for( lCount=0; lCount<glColCount; lCount++ )
	{				
        SendMessage( hCombo, CB_ADDSTRING, 0, (LPARAM)*(gppColName + lCount) );
	}

    SendMessage( hCombo, CB_SETCURSEL, 0, 0 );

    return 0;
}

int SetColumnProperties( int iCol, HWND hEditType, HWND hEditGrbit )
{
    char szBuf[64];

    ColtypToStr( gpjColDef[iCol].coltyp, szBuf );
    SetWindowText( hEditType, szBuf );

    GrbitToStr( gpjColDef[iCol].grbit, szBuf );
    SetWindowText( hEditGrbit, szBuf );

    return 0;
}

int ColtypToStr( JET_COLTYP coltyp, char* szBuf )
{
    switch( coltyp )
    {
        case JET_coltypBit:
            strcpy( szBuf, "Bit" );
            break;
        case JET_coltypUnsignedByte:
            strcpy( szBuf, "UnsignedByte" );
            break;
        case JET_coltypShort:
            strcpy( szBuf, "Short" );
            break;
        case JET_coltypLong:
            strcpy( szBuf, "Long" );
            break;
        case JET_coltypCurrency:
            strcpy( szBuf, "Currency" );
            break;
        case JET_coltypIEEESingle:
            strcpy( szBuf, "IEEESingle" );
            break;
        case JET_coltypIEEEDouble:
            strcpy( szBuf, "IEEEDouble" );
            break;
        case JET_coltypDateTime:
            strcpy( szBuf, "DateTime" );
            break;
        case JET_coltypBinary:
            strcpy( szBuf, "Binary" );
            break;
        case JET_coltypText:
            strcpy( szBuf, "Text" );
            break;
        case JET_coltypLongBinary:
            strcpy( szBuf, "LongBinary" );
            break;
        case JET_coltypLongText:
            strcpy( szBuf, "LongText" );
            break;
        default:
            strcpy( szBuf, "Unknown" );
            break;
    }

    return 0;
}

int GrbitToStr( JET_GRBIT grbit, char* szBuf )
{
    szBuf[0] = '\0';
    if( grbit & JET_bitColumnFixed )
        strcat( szBuf, "Fixed;" );
    if( grbit & JET_bitColumnTagged )
        strcat( szBuf, "Tagged;" );
    if( grbit & JET_bitColumnNotNULL )
        strcat( szBuf, "NotNULL;" );
    if( grbit & JET_bitColumnVersion )
        strcat( szBuf, "Version;" );
    if( grbit & JET_bitColumnAutoincrement )
        strcat( szBuf, "Autoincrement;" );
    if( grbit & JET_bitColumnMultiValued )
        strcat( szBuf, "MultiValued;" );

    if( szBuf[0] != '\0' )
        szBuf[strlen(szBuf) - 1] = '\0';

    return 0;
}

int GetColumnValue( int iCol, HWND hList )
{
    JET_RETINFO jRetInfo;
    JET_ERR jError;
    char szBuf[TEMP_BUF_SIZE];
    unsigned long ulActual;

    SendMessage( hList, LB_RESETCONTENT, 0, 0 );

    jRetInfo.cbStruct = sizeof(JET_RETINFO);
    jRetInfo.ibLongValue = 0;
    jRetInfo.itagSequence = 0;
    do
    {
        jRetInfo.itagSequence++;
        jError = JetRetrieveColumn( gjSesId, gjTblId, gpjColDef[iCol].columnid, szBuf, TEMP_BUF_SIZE,
                        &ulActual, 0, &jRetInfo );

        if( jError != JET_errSuccess )
        {
            if( jError == JET_wrnColumnNull )
                break;
            else if( jError != JET_wrnBufferTruncated )
            {
                JetError( jError, "JetRetrieveColumn" );
                return -1;
            }
        }

        switch( gpjColDef[iCol].coltyp )
        {
            case JET_coltypText:
            case JET_coltypLongText:
                if( ulActual < TEMP_BUF_SIZE )
                    szBuf[ulActual] = '\0';
                else
                    szBuf[TEMP_BUF_SIZE - 1] = '\0';
                break;

            case JET_coltypLong:
            {
                long lTemp;

                lTemp = *(long*)szBuf;
                wsprintf( szBuf, "%li", lTemp );
            }
                break;

            default:
            {
                char szTemp[TEMP_BUF_SIZE];
                int iOffset;

                memcpy( szTemp, szBuf, TEMP_BUF_SIZE );
                iOffset = wsprintf( szBuf, "0X%02X", *szTemp );
                iOffset += wsprintf( szBuf + iOffset, "%02X", *(szTemp+1) );
                iOffset += wsprintf( szBuf + iOffset, "%02X", *(szTemp+2) );
                wsprintf( szBuf + iOffset, "%02X", *(szTemp+3) );
            }
                break;
        }

        SendMessage( hList, LB_ADDSTRING, 0, (LPARAM)szBuf );
    }
    while( gpjColDef[iCol].grbit & JET_bitColumnTagged );

    return 0;
}

int ResetNewValue( HWND hwnd )
{
    HWND hEdit;

    hEdit = GetDlgItem( hwnd, IDC_EDIT3 );
    SetWindowText( hEdit, "" );

    hEdit = GetDlgItem( hwnd, IDC_EDIT4 );
    SetWindowText( hEdit, "1" );

    hEdit = GetDlgItem( hwnd, IDC_EDIT5 );
    SetWindowText( hEdit, "0" );

    return 0;
}

int ModifyRecordColumn( int iCol, HWND hEditNewValue, HWND hEditTagSeq, HWND hEditLongOffset )
{
    JET_SETINFO jSetInfo;
    char* pData = NULL;          //initialized to avoid C4701
    unsigned long cbData, ulTemp;
    char szBuf[TEMP_BUF_SIZE + 1];

    if( GetWindowTextLength( hEditNewValue ) >= TEMP_BUF_SIZE )
    {
        OutputMessage( "Value too long" );
        return -1;
    }

    jSetInfo.cbStruct = sizeof( JET_SETINFO );
    GetWindowText( hEditLongOffset, szBuf, TEMP_BUF_SIZE );
    jSetInfo.ibLongValue = atol( szBuf );
    GetWindowText( hEditTagSeq, szBuf, TEMP_BUF_SIZE );
    jSetInfo.itagSequence = atol( szBuf );

    cbData = GetWindowText( hEditNewValue, szBuf, TEMP_BUF_SIZE );
    switch( gpjColDef[iCol].coltyp )
    {
        case JET_coltypText:
        case JET_coltypLongText:
            pData = (char*)szBuf;
            break;

        case JET_coltypLong:
            if( cbData )
            {
                ulTemp = (unsigned long)atol( szBuf );
                pData = (char*)&ulTemp;
                cbData = sizeof( unsigned long );
            }
            break;
                                                                  
        default:
        {//binary format
            unsigned long ul;

            cbData /= 2;
            for( ul=0; ul<cbData; ul++ )
            {
                if (sscanf( szBuf+2*ul, "%2x", &ulTemp ) == 1)
                    szBuf[ul] = (char)((unsigned char)ulTemp);
                else 
                    szBuf[ul] = '?';
            }
            pData = (char*)szBuf;
        }
            break;
    }

    if( JetError( JetBeginTransaction( gjSesId ), "JetBeginTransaction" ) != JET_errSuccess 
     || JetError( JetPrepareUpdate( gjSesId, gjTblId, JET_prepReplace ), "JetPrepareUpdate" ) 
                != JET_errSuccess 
     || JetError( JetSetColumn( gjSesId, gjTblId, gpjColDef[iCol].columnid, pData, cbData, 0, &jSetInfo ), 
                "JetSetColumn" )!= JET_errSuccess 
     || JetError( JetUpdate( gjSesId, gjTblId, NULL, 0, &ulTemp ), "JetUpdate" ) != JET_errSuccess 
     || JetError( JetCommitTransaction( gjSesId, 0 ), "JetCommitTransaction" ) != JET_errSuccess )
        JetError( JetRollback( gjSesId, 0 ), "JetRollback" );
    else
        PrintCurrentRecord();   //Cursor remains on current record

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\jetinfo\jetinfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jetinfo.c
//
//--------------------------------------------------------------------------

#define STRICT
#include <windows.h>
#include <dsjet.h>
#include <dbopen.h>
#include "jetinfo.h"
#include <stdlib.h>

LRESULT CALLBACK JetInfoWndProc(HWND, UINT, WPARAM, LPARAM);

HINSTANCE   ghInstance;
HWND        ghWnd;
char achWndClass[] = "JETINFO:MAIN";
char achAppName[] = "JetInfo";

char achDbName[MAX_PATH];

//screen data
//giLine is the number of lines containing content, or the next available line index (0 based)
int giLine = 0; 
char aLines[MAX_LINE][MAX_CHAR];
long aLen[MAX_LINE];

//JET variables
JET_INSTANCE    gjInst;
JET_SESID       gjSesId;
JET_DBID        gjDbId;
JET_TABLEID     gjTblId;
char            gszTblName[JET_cbNameMost+1];
JET_COLUMNDEF*  gpjColDef = NULL;
char**          gppColName = NULL;
long            glColCount = 0;

//status flags
BOOL            gfSesId = FALSE;
BOOL            gfDbId = FALSE;     
BOOL            gfTblId = FALSE;     

int PASCAL WinMain ( HINSTANCE hInstance,
					 HINSTANCE hPrevInstance,
					 LPSTR	lpszCmdLine,
					 int	cmdShow)
{
	HWND	hwnd;
	MSG		msg;
	WNDCLASS	wndclass;

	if (!hPrevInstance)
	{
		wndclass.lpszClassName	= achWndClass;
		wndclass.hInstance	    = hInstance;
		wndclass.lpfnWndProc	= JetInfoWndProc;
		wndclass.hCursor	    = LoadCursor (NULL, IDC_ARROW);
		wndclass.hIcon		    = LoadIcon (NULL, IDI_APPLICATION);
		wndclass.lpszMenuName	= "MainMenu";
		wndclass.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
		wndclass.style		    = CS_HREDRAW | CS_VREDRAW;
		wndclass.cbClsExtra	    = 0;
		wndclass.cbWndExtra	    = 0;

		RegisterClass(&wndclass);
	} 
    else
        return 0;

    ghInstance = hInstance;
	
	hwnd = CreateWindowEx(0L,
						achWndClass,
						achAppName,
						WS_OVERLAPPEDWINDOW,
						CW_USEDEFAULT,
						0,
						CW_USEDEFAULT,
						0,
						NULL,
						NULL,
						hInstance,
						NULL);
	
    ghWnd = hwnd;
    					
	ShowWindow(hwnd, cmdShow);
   
	while (GetMessage(&msg,0,0,0))
	{	
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
    
	return 0;
}

LRESULT CALLBACK JetInfoWndProc (HWND	hwnd,
							 UINT	mMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	switch (mMsg)
	{
        case WM_COMMAND:
        {
            switch ( wParam )
            {
                case IDM_DA_OPEN:
                    OpenDatabase( hwnd );
                    break;

                case IDM_DA_CLOSE:
                    CloseDatabase();
                    break;

                case IDM_DA_EXIT:
                    DestroyWindow( hwnd );
                    break;

                case IDM_IN_TABLE:
                    GetTableInfo( hwnd );
                    break;

                case IDM_IN_COLUMN:
                    GetColumnInfo( hwnd );
                    break;

                case IDM_IN_INDEX:
                    GetIndexInfo( hwnd );
                    break;

                case IDM_RE_COLUMN:
                    SelectColumn( hwnd );
                    break;

                case IDM_RE_SEEK:
                    DoSeekRecord( hwnd );
                    break;

                case IDM_RE_MODIFY:
                    DoModifyRecord( hwnd );
                    break;

                case IDM_RE_FIRST:
                    if( gfTblId )
                    {
                        if( JetError( JetMove( gjSesId, gjTblId, JET_MoveFirst, 0 ), "JetMove" )
                                == JET_errSuccess )
                            PrintRecord( RECORD_PAGE );
                    }
                    else
                        OutputMessage( "Table not open" );
                    break;

                case IDM_RE_LAST:
                    if( gfTblId )
                    {
                        JET_ERR jError;

                        if( JetError( JetMove( gjSesId, gjTblId, JET_MoveLast, 0 ), "JetMove" )
                                == JET_errSuccess )
                        {
                            jError = JetMove( gjSesId, gjTblId, 1 - RECORD_PAGE, 0 );
                            if( jError == JET_errSuccess
                             || ( jError == JET_errNoCurrentRecord 
                                && JetError( JetMove( gjSesId, gjTblId, JET_MoveFirst, 0 ), "JetMove" )
                                    == JET_errSuccess ) )
                                PrintRecord( RECORD_PAGE );
                        }
                    }
                    else
                        OutputMessage( "Table not open" );
                    break;

                case IDM_RE_PREV:
                    if( gfTblId )
                    {
                        JET_ERR jError;

                        jError = JetMove( gjSesId, gjTblId, -2 * RECORD_PAGE, 0 );
                        if( jError == JET_errSuccess
                         || ( jError == JET_errNoCurrentRecord 
                            && JetError( JetMove( gjSesId, gjTblId, JET_MoveFirst, 0 ), "JetMove" )
                                == JET_errSuccess ) )
                            PrintRecord( RECORD_PAGE );
                    }
                    else
                        OutputMessage( "Table not open" );
                    break;

                case IDM_RE_NEXT:
                    if( gfTblId )
                        PrintRecord( RECORD_PAGE );
                    else
                        OutputMessage( "Table not open" );
                    break;

                default:
                    break;
            }

            InvalidateRect(hwnd, NULL, TRUE);
        }
            break;

        case WM_CREATE:
            ResetScreenContent();

            DBSetRequiredDatabaseSystemParameters (&gjInst);

            break;

        case WM_DESTROY:
            CloseDatabase();
            if( gpjColDef )
            {
                free( gpjColDef );
                gpjColDef = NULL;
            }
            if( gppColName )
            {
                int i;

                for( i=0; i<glColCount; i++ )
                {
                    if( *(gppColName + i) )
                        free( *(gppColName + i) );
                }
                free( gppColName );
            }

			PostQuitMessage(0);
			break;
        
        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            int iLine, ix, iy;
            TEXTMETRIC tm;
            HFONT hOldFont;

            BeginPaint( hwnd, &ps );
            hOldFont = SelectObject( ps.hdc, GetStockObject(ANSI_FIXED_FONT) );
            GetTextMetrics( ps.hdc, &tm );
            for( iLine=0, ix=tm.tmAveCharWidth/2, iy=(tm.tmHeight+tm.tmExternalLeading)/2; 
                iLine < giLine; iLine++, iy+=tm.tmHeight+tm.tmExternalLeading )
            {
                TextOut( ps.hdc, ix, iy, aLines[iLine], 
                        aLen[iLine] > MAX_CHAR ? MAX_CHAR : aLen[iLine] );
            }
            SelectObject( ps.hdc, hOldFont );
            EndPaint( hwnd, &ps );
        }
            break;

		default:
			return (DefWindowProc(hwnd,mMsg,wParam,lParam));
	}
	return 0L;
}

int OutputMessage( char* szMsg )
{
    return OutputBuffer( szMsg, strlen(szMsg) );
}

int OutputBuffer( char* szMsg, long lLen )
{
    ResetScreenContent();

    return AppendBuffer( szMsg, lLen );
}

int AppendMessage( char* szMsg )
{
    return AppendBuffer( szMsg, strlen(szMsg) );
}

int AppendBuffer( char* szMsg, long lLen )
{
    long lOffset = 0;

    while( lLen >= MAX_CHAR && giLine < MAX_LINE )
    {
        memcpy( aLines[giLine], szMsg + lOffset, MAX_CHAR );
        aLen[giLine] = MAX_CHAR;
        lOffset += MAX_CHAR;
        lLen -= MAX_CHAR;
        giLine++;
    }

    if( lLen > 0 && giLine < MAX_LINE )
    {
        memcpy( aLines[giLine], szMsg + lOffset, lLen );
        aLen[giLine] = lLen;
        giLine++;
    }

    return 0;
}

int ResetScreenContent()
{
    memset( aLines[0], 0, MAX_LINE*MAX_CHAR );
    memset( aLen, 0, MAX_LINE*sizeof(long) );
    giLine = 0;

    return 0;
}

int AppendLineMessage( char* szMsg )
{
    return AppendLineOutput( szMsg, strlen(szMsg) );
}

int AppendLineOutput( char* szMsg, long lLen )
{//This function appends szMsg to the end of last line (line index is giLine-1)
    if( giLine > MAX_LINE )
        return -1;

    if( aLen[giLine-1] + lLen < MAX_CHAR )
    {
        memcpy( aLines[giLine-1] + aLen[giLine-1], szMsg, lLen );
        aLen[giLine-1] += lLen;
    }
    else
    {//advance line
        long lOffset;

        memcpy( aLines[giLine-1] + aLen[giLine-1], szMsg, MAX_CHAR - aLen[giLine-1] );
        lOffset = MAX_CHAR - aLen[giLine-1];
        lLen -= (MAX_CHAR - aLen[giLine-1]);
        aLen[giLine-1] = MAX_CHAR;

        while( lLen >= MAX_CHAR && giLine < MAX_LINE )
        {
            memcpy( aLines[giLine], szMsg + lOffset, MAX_CHAR );
            aLen[giLine] = MAX_CHAR;
            lOffset += MAX_CHAR;
            lLen -= MAX_CHAR;
            giLine++;
        }

        if( lLen > 0 && giLine < MAX_LINE )
        {
            memcpy( aLines[giLine], szMsg + lOffset, lLen );
            aLen[giLine] = lLen;
            giLine++;
        }
    }

    return 0;
}

JET_ERR JetError( JET_ERR jErr, char* sz )
{
    if( jErr != JET_errSuccess )
    {
        wsprintf( aLines[giLine], "%s returns error: %li", sz, jErr );
        giLine++;
    }

    return jErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\dsldap\dsldap.h ===
// Function Prototypes for ldap calls for NTDS changes

ULONG NTDS_ldap_add_sW( LDAP *ld, PWCHAR dn, LDAPModW *attrs[] );
ULONG NTDS_ldap_add_sA( LDAP *ld, PCHAR dn, LDAPModA *attrs[] ); 


ULONG NTDS_ldap_modify_sW( LDAP *ld, PWCHAR dn, LDAPModW *mods[] );
ULONG NTDS_ldap_modify_sA( LDAP *ld, PCHAR dn, LDAPModA *mods[] );

ULONG NTDS_ldap_delete_sW( LDAP *ld, PWCHAR dn );
ULONG NTDS_ldap_delete_sA( LDAP *ld, PCHAR dn );

ULONG NTDS_ldap_modrdn2_sW( 
    LDAP    *ExternalHandle,
    PWCHAR  DistinguishedName,
    PWCHAR  NewDistinguishedName,
    INT     DeleteOldRdn
    );

ULONG NTDS_ldap_modrdn2_sA( 
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    );




#ifdef UNICODE

#define NTDS_ldap_add_s      NTDS_ldap_add_sW
#define NTDS_ldap_modify_s   NTDS_ldap_modify_sW
#define NTDS_ldap_delete_s   NTDS_ldap_delete_sW
#define NTDS_ldap_modrdn2_s  NTDS_ldap_modrdn2_sW

#else

#define NTDS_ldap_add_s      NTDS_ldap_add_sA
#define NTDS_ldap_modify_s   NTDS_ldap_modify_sA
#define NTDS_ldap_delete_s   NTDS_ldap_delete_sA
#define NTDS_ldap_modrdn2_s  NTDS_ldap_modrdn2_sA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\inc\async.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    async.h

Abstract:

    Asynchronous LDAP support routines

Environment:

    User mode

Revision History:

    05/15/00 -mattrim-
        Created it

--*/

#ifndef _ASYNC_H_
#define _ASYNC_H_

#ifdef __cplusplus
extern "C" {
#endif

extern LDAP_TIMEVAL * g_pLdapTimeout;
extern LDAP_TIMEVAL   g_LdapTimeout;


ULONG LDAPAPI LdapResult(
    LDAP *ld, 
    ULONG msgnum,
    LDAPMessage **ppres
    );

#ifdef __cplusplus
}
#endif

#endif // _ASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\dsldap\dsldap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsldap.c

ABSTRACT:

     Functions for dsldap.lib

DETAILS:

     Contains NTDS-specific functions corresponding to ldap_add_s,
     ldap_modify_s, ldap_delete_s, and ldap_modrdn2_s. The parameters
     are excatly same as the corresponding ldap calls. These functions
     are called by ldifde on NTDS-specific changetypes (ntdsSchemaAdd,
     ntdsSchemaModify, ntdsSchemaDelete, and ntdsSchemaModRdn) in an
     ldif file.

     The functions are similar to normal ldap calls, except that certain
     error codes are ignored in specific cases and success is returned
     instead to the calling function
  

CREATED:

    05/27/98    Arobinda Gupta (arobindg)

REVISION HISTORY:

--*/


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>

//
// CRunTime Includes
//
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

//
// LDAP Includes
//
#include <winldap.h>

#include "dsldap.h"
#include "async.h"

ULONG 
NTDS_ldap_add_sW(
    LDAP *ld, 
    PWCHAR dn, 
    LDAPModW *attrs[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_addW(ld, dn, attrs);

    Ldap_err = LdapResult(ld, msgnum, NULL);


    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry


    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;

}


ULONG 
NTDS_ldap_modify_sW( 
    LDAP *ld, 
    PWCHAR dn, 
    LDAPModW *mods[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_modifyW( ld, dn, mods );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        case LDAP_NO_SUCH_ATTRIBUTE:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


ULONG 
NTDS_ldap_modrdn2_sW(
    LDAP    *ExternalHandle,
    PWCHAR  DistinguishedName,
    PWCHAR  NewDistinguishedName,
    INT     DeleteOldRdn
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;
    
    // make the normal ldap call

    msgnum = ldap_modrdn2W (
                      ExternalHandle,
                      DistinguishedName,
                      NewDistinguishedName,
                      DeleteOldRdn
               );

    Ldap_err = LdapResult(ExternalHandle, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


ULONG 
NTDS_ldap_delete_sW(
    LDAP *ld, 
    PWCHAR dn 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_deleteW( ld, dn );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


// Implement the ascii versions

ULONG 
NTDS_ldap_add_sA(
    LDAP *ld, 
    PCHAR dn, 
    LDAPModA *attrs[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call
    
    msgnum = ldap_addA( ld, dn, attrs );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry


    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    } 

    return Ldap_err;
}


ULONG 
NTDS_ldap_modify_sA( 
    LDAP *ld, 
    PCHAR dn, 
    LDAPModA *mods[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_modifyA( ld, dn, mods );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        case LDAP_NO_SUCH_ATTRIBUTE:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


ULONG 
NTDS_ldap_delete_sA( 
    LDAP *ld, 
    PCHAR dn 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_deleteA( ld, dn );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}

ULONG 
NTDS_ldap_modrdn2_sA(
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;
    
    // make the normal ldap call

    msgnum = ldap_modrdn2A ( 
                      ExternalHandle,
                      DistinguishedName,
                      NewDistinguishedName,
                      DeleteOldRdn
               );

    Ldap_err = LdapResult(ExternalHandle, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\inc\debug.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debugging support for the DirSync project. None of these
    generate any code in the retail build.

Environment:

    User mode

Revision History:

    03/18/98 -srinivac-
        Created it

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

//
// External functions
//

STDAPI_(PCSTR) StripDirPrefixA(PCSTR);

//
// This variable maintains the current debug level. Any calls to generate
// debug messages succeeds if the requested level is greater than or equal
// to the current level.
//

extern DWORD gdwDebugLevel;

//
// List of debug levels for gdwDebugLevel
//

#define DBG_LEVEL_VERBOSE   0x00000001
#define DBG_LEVEL_INFO      0x00000002
#define DBG_LEVEL_WARNING   0x00000003
#define DBG_LEVEL_ERROR     0x00000004


//
// Internal macros. Don't call these directly
//

#define CHECK_DBG_LEVEL(level)  ((level) >= gdwDebugLevel)

#define DBGMSG(level, msg)                                              \
        {                                                               \
            if (CHECK_DBG_LEVEL(level))                                 \
            {                                                           \
                DbgPrint("DirSync(%d): %s(%u): ",                       \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DbgPrint msg;                                           \
            }                                                           \
        }


#define DBGPRINT(level, msg)                                            \
        {                                                               \
            if (CHECK_DBG_LEVEL(level))                                 \
            {                                                           \
                DbgPrint msg;                                           \
            }                                                           \
        }


//
// These are the main macros that you'll be using in your code.
// Note that you should enclose the msg in additional
// paranthesis as shown in the example below.
//
// WARNING(("Out of memory"));
// ERR(("Incorrect return value: %d", rc));
//

#define VERBOSE(msg)       DBGMSG(DBG_LEVEL_VERBOSE, msg)
#define INFO(msg)          DBGMSG(DBG_LEVEL_INFO,   msg)
#define WARNING(msg)       DBGMSG(DBG_LEVEL_WARNING, msg)
#define ERR(msg)           DBGMSG(DBG_LEVEL_ERROR,   msg)
#define ERR_RIP(msg)       DBGMSG(DBG_LEVEL_ERROR,   msg);RIP()
#define RIP()              DebugBreak()
#define DEBUGOUT(msg)      DbgPrint msg


//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//
// ASSERT(x > 0);
// ASSERTMSG(x > 0, ("x less than 0: x=%d", x));
//

#ifdef ASSERT
#undef ASSERT
#undef ASSERTMSG
#endif

#define ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                DbgPrint("DirSync(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                DbgPrint("DirSync(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DbgPrint msg;                                           \
                DbgPrint("\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

#else // !DBG

#define DBGMSG(level, msg)
#define VERBOSE(msg)
#define INFO(msg)
#define WARNING(msg)
#define ERR(msg)
#define ERR_RIP(msg)
#define RIP()
#define DEBUGOUT(msg)

#ifndef ASSERT
#define ASSERT(expr)
#endif

#ifndef ASSERTMSG
#define ASSERTMSG(expr, msg)
#endif

#endif

//
// The following macros let you enable debugging on a per feature basis.
// To use these macros, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  1. Define a bit constant for each capability you want to debug
//  2. For each feature, add the following line
//       DEFINE_FEATURE_FLAGS(featurename, flags);
//     where flags is a bit-wise OR of the capabilities you want to debug for
//     that feature
//  3. In your code add the following line wherever you want debug messages
//       FEATURE_DEBUG(featurename, flag, (msg));
//
//  E.g. let us say I am implementing a memory manager, and I would like to
//       trace memory allocations and frees. Here is what I would do
//
//       #define FLAG_ALLOCATE   1
//       #define FLAG_FREE       2
//
//       DEFINE_FEATURE_FLAGS(MemMgr, FLAG_ALLOCATE);
//
//       void *MemAlloc(DWORD dwSize)
//       {
//           FEATURE_DEBUG(MemMgr, FLAG_ALLOCATE, ("Memory of size %d allocated", dwSize));
//           ...
//       }
//
//       void MemFree(void *pvMem)
//       {
//           FEATURE_DEBUG(MemMgr, FKAG_FREE, ("Memory freed"));
//           ...
//       }
//
//  Note that I have set this up to send only alloc messages to the debugger,
//  but I can break into the debugger and modify dwMemMgrDbgFlags to
//  send free messages as well.
//
//  Once component testing of a feature is completed, flags parameter in
//  DEFINE_FEATURE_FLAGS should be changed to 0, so by default this feature
//  does not send debug messages to the debugger.
//

#if DBG

//
// Global debug flag that can used to set values to all other flags
//

extern DWORD gdwGlobalDbgFlags;

#define DEFINE_FEATURE_FLAGS(feature, flags)                            \
            DWORD gdw##feature##DbgFlags = (flags)

#define EXTERN_FEATURE_FLAGS(feature)                                   \
            extern DWORD gdw##feature##DbgFlags

#define FEATURE_DEBUG(feature, flag, msg)                               \
        {                                                               \
            if (gdw##feature##DbgFlags & (flag) ||                      \
                gdwGlobalDbgFlags & (flag))                             \
            {                                                           \
                DbgPrint msg;                                           \
            }                                                           \
        }

#define FEATURE_DEBUG_FN(feature, flag, func)                           \
        {                                                               \
            if (gdw##feature##DbgFlags & (flag) ||                      \
                gdwGlobalDbgFlags & (flag))                             \
            {                                                           \
                func;                                                   \
            }                                                           \
        }

#define FLAG_INFO               0x01
#define FLAG_VERBOSE            0x02
#define FLAG_FNTRACE            0x04
#define FLAG_FULLTRACE          0xFFFF

#else // !DBG

#define DEFINE_FEATURE_FLAGS(feature, flags)
#define EXTERN_FEATURE_FLAGS(feature)
#define FEATURE_DEBUG(feature, flag, msg)
#define FEATURE_DEBUG_FN(feature, flag, func)

#endif // !DBG

//
// Macros for error handling
//

#define BAIL_ON_FAILURE(hr)                             \
            if (FAILED(hr))                             \
            {                                           \
                goto error;                             \
            }

#define BAIL_ON_FAILURE_WITH_MSG(err, msg)              \
            if (FAILED(hr))                             \
            {                                           \
                ERR(msg);                               \
                goto error;                             \
            }

#define BAIL_ON_NULL(ptr)                               \
            if ((ptr) == NULL)                          \
            {                                           \
                ERR(("Error allocating memory\n"));     \
                hr = E_OUTOFMEMORY;                     \
                goto error;                             \
            }

#define BAIL()  goto error


#ifdef __cplusplus
}
#endif

#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\inc\ldifext.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ldifext.h

Abstract:

    Header for users of the library

Environment:

    User mode

Revision History:

    07/17/99 -t-romany-
        Created it

--*/
#ifndef _LDIFEXT_H
#define _LDIFEXT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <..\ldifldap\base64.h>

extern BOOLEAN g_fUnicode;         // whether we are using UNICODE or not

//
// When the parser returns with an ldif-change-record, the result will be in a 
// null terminated linked list of the following struct. a pointer to the head of 
// this list will be found in the LDIF_Record defined below. The DN of the entry 
// will also be in the changerecord. 
//

//
// The node for the linked list built up while parsing a changerecord list.
// Note: because of an ambigiouty in the LDIF spec, nothing can follow a 
// change: add entry in the same ldif-change-record
//
struct change_list {
    union {
        LDAPModW **mods;    // if this is a changetype: add, modify
        PWSTR     dn;       // if this is a changetype: mod(r)dn
    } stuff;

    int operation;         
    int deleteold;         // This the the deleteold option in moddn. Note 
                           // that only deleteold==1 works with our DS.
                           // I mean I could've made a struct within the 
                           // union, but thats way too complicated. Having 
                           // it here is much easier.
    struct change_list *next;
};

#define mods_mem        stuff.mods
#define dn_mem          stuff.dn


//
// The codes inside in the operation field inside a change_list node.
//

enum _CHANGE_OP
{
    CHANGE_ADD             =  1,  // a change: add with an attrval spec list
    CHANGE_DEL             =  2,  // a delete without anything
    CHANGE_DN              =  3,  // a chdn with a new dn and deleteoldrdn
    CHANGE_MOD             =  4,  // a modify
    CHANGE_NTDSADD         =  5,  // a change: add with an attrval spec list
    CHANGE_NTDSDEL         =  6,  // a delete without anything
    CHANGE_NTDSDN          =  7,  // a chdn with a new dn and deleteoldrdn
    CHANGE_NTDSMOD         =  8   // a modify
};


//
// The ldif functions will work with the following structure 
//
typedef struct {
    PWSTR dn;

    //
    // TRUE implies this is a change record and the "changes" linked list is 
    // valid
    // FALSE implies this is a content record and the "contents" array of 
    // pointers is valid.
    //
    BOOL fIsChangeRecord;

    union {
        struct change_list *changes;
        LDAPModW **        content;
    };

} LDIF_Record;

//
// Errors to the calling program are returned in this struct.
//
typedef struct ldiferror {
    DWORD error_code;  // error codes as defined below
    WCHAR token_start; // if its a syntax error, indicate start of the token
    PWSTR szTokenLast; // if its a syntax error, indicate start of the token
    long  line_number; // line number of error
    long  line_begin;  // beginning line of this record
    int   ldap_err;    // LDIF_LoadRecord may detect an error in an ldap call 
    int   RuleLastBig; // The last rule the grammar parsed successfully.
                       // codes defined in ldifext.h 
    int   RuleLast;    // the last lower level rule parsed successfully 
    int   RuleExpect;  // The rule the grammar expects to see next 
    int   TokenExpect; // The token the grammar expects to see next 
    long  the_modify;  // LDIF_GenerateEntry can tell the world          
                       // where the modify portion starts. -1 if none */
} LDIF_Error;


//
// Various exceptions that could be raised by the program. These also double as 
// error codes in the returned error struct
//

#define LL_SUCCESS         0          // The function executed successfully
#define LL_INIT_REENTER    0x00000200
#define LL_FILE_ERROR      0x00000300
#define LL_INIT_NOT_CALLED 0x00000400
#define LL_EOF             0x00000500
#define LL_SYNTAX          0x00000600   
                                      //
                                      // Syntax error, token_start contains the 
                                      // start of the token at or after which 
                                      // the error occurs and line_number 
                                      // contains the line_number of the error.
                                      //
// the following exceptions aim at providing detailed parsing errors
#define LL_MISSING_MOD_SPEC_TERMINATOR       0x00000601

#define LL_URL             0x00000700
#define LL_EXTRA           0x00000800 // Extraneous attributes in a mod-spec
#define LL_LDAP            0x00000900 // LDAP call failed. Errcode in 
                                      // error->ldap_err
#define LL_MULTI_TYPE      0x00000A00 
#define LL_INTERNAL        0x00000B00 
                                      //
                                      // you have uncovered a bug in 
                                      // ldifldap.lib. Please report it. 
                                      //
#define LL_DUPLICATE       0x00000C00
#define LL_FTYPE           0x00000D00 //
                                      // Illegal mix of ldif-records and 
                                      // ldif-changerecords
                                      //
#define LL_INITFAIL        0x00000E00  
#define LL_INTERNAL_PARSER 0x00000F00 // internal error in parser

//
// NOTE: THIS ERROR NO LONGER EXITS!!!
// The implementation has been changed to allow the mixing of values.
// I leave it here (and some dormant codepaths) in case the old
// string functionality needs to be resurrected and this error 
// will live again!
//
// The above error (LL_MULTI_TYPE) is such:
//  Each attribute may have one or more values. For example:
//      description: tall
//      description: beautiful
// Notice how both of these values are strings. Another example 
// is:
//      description:: [some base64 value]
//      description:< file://c:\myfile
// The first example winds up as multiple strings in a single LDAPMod
// struct.The second winds up as multiple bervals. Although the LDIF spec
// does not specifically mention this, it is illegal to combine the two 
// in one entry. What this means is that as multilple values for the same 
// attribute, one cannot specify both a string and a URL. 
// i.e.
//      description:< file://c:\myfile
//      description:  HI!
//  BAD!!!
// The reason for this is that that these multiple values (according to the 
// spirit of the LDAP API and the LDIF specification) are meant to wind up 
// in the same LDAPMod struct, which is impossible if they are strings and 
// bervals. 
// This is not a problem however, considering that if a value is meant to 
// take one, the user should not want to specify the other. Specifying 
// different types for different attributes is of course fine. If the user 
// wants to accomplish what he intends in the incorrect exmaple, he should 
// split the operation into two entries. (One that creates the attribute 
// with some values of one type and one that adds some of the other) 
//

//
// The following values will be found in lastrule, lastsmall, expectrule,
// expecttoken members of the error struct if the error was a syntax error.
// They help explain what the parser was doing and expecting. 
//

// 
// lastrule field - this field tells the last major rule the parser accepted. 
// Refer to the LDIF draft of June 9, 1997. 
// For an example of how to use these 4 fields, see the ClarifyErr() helper 
// function in rload.c 
// Note: R stands for Rule.
//
enum _RULE
{
    R_VERSION      = 1,  // the version-spec rule. version: #
    R_REC          = 2,  // the ldif-attrval-record rule. dn SEP (list of) 
                         // [attrval-spec SEP] 
    R_CHANGE       = 3,  // the ldif-change-record rule. dn SEP (list of)  
                         // [changerecord SEP]   
    R_DN           = 4,  // the dn-spec rule. dn:(:) the DN
    R_AVS          = 5,  // an attrval-spec.
    R_C_ADD        = 6,  // a change: add changerecord
    R_C_DEL        = 7,  // a change: delete changerecord
    R_C_DN         = 8,  // a change: dn changerecord
    R_C_NEWSUP     = 9,  // a change: dn changerecord with a newsup addendum
    R_C_MOD        = 10, // a changetype: modify
    R_C_MODSPEC    = 11  // a mod-spec
};

// 
// lastsmall field - this field tells the last minor rule or token the 
// parser accepted. The line between this and the above is vague.
// Basically, if I felt it was a major rule, it was major,
// and if I didn't, it was minor. Generally, you'll find the major rules 
// higher up in the BNF tree than the minor ones. The minor rule 
// will usually show the last part of the major rule, unless it doesn't.
// Together with the "expecting" information, these two will
// will clarify where the parser was able to get up to and where it
// was forced to stop. (RS stands for rule small)
//
enum _RULESMALL
{
    RS_VERNUM      = 1,        // the version-number rule
    RS_ATTRNAME    = 2,        // a valid attribute name followed by colon
    RS_ATTRNAMENC  = 3,        // an attribute name without colon. (mod-spec)
    RS_DND         = 4,        // a dn::
    RS_DN          = 5,        // a dn:
    RS_DIGITS      = 6,        // some digits
    RS_VERSION     = 7,        // version: 
    RS_BASE64      = 8,        // a base64 string
    RS_SAFE        = 9,        // a regular safe string
    RS_DC         = 10,        // good old double colon 
    RS_URLC       = 11,        // a URL colon :<
    RS_C          = 12,        // a single colon
    RS_MDN        = 13,        // a modrdn or a moddn
    RS_NRDNC      = 14,        // a newrdn:
    RS_NRDNDC     = 15,        // a newrdn::
    RS_DORDN      = 16,        // a deleteoldrdn:
    RS_NEWSUP     = 17,        // a newsuperior: 
    RS_NEWSUPD    = 18,        // a newsuperior:: 
    RS_DELETEC    = 19,        // a delete:
    RS_ADDC       = 20,        // a add:
    RS_REPLACEC   = 21,        // a replace:
    RS_CHANGET    = 22,        // a changetype: 
    RS_C_ADD      = 23,        // an add
    RS_C_DELETE   = 24,        // a delete
    RS_MINUS      = 25,        // a minus
    RS_C_MODIFY   = 26         // a modify
};

//
// expectrule - this field shows which rule (there maybe more than one option)
// that the parser wanted to see after the last rule that it parsed. RE stands
// for Rule Expect.
//
enum _EXPECTRULE
{
    RE_REC_OR_CHANGE   = 1,   // ldif-attrval-record or an ldif-change-record
    RE_REC             = 2,   // ldif-attrval-record
    RE_CHANGE          = 3,   // ldif-change-record
    RE_ENTRY           = 4,   // the post-DN body of an ldif-c-r or ldif-a-r
    RE_AVS_OR_END      = 5,   // another attribute value spec or list 
                              // termination.
    RE_CH_OR_NEXT      = 6,   // another changetype: * or end of entry
    RE_MODSPEC_END     = 7    // another mod-sepc or entry's end
};


//
// expecttoken - this field will show the token or small rule (there may
// again be more than one option that the parse wanted to see next.
// RT stands for rule token.
//

enum _EXPECTTOKEN
{
    RT_DN              = 1,    // a dn: or a dn::
    RT_ATTR_OR_CHANGE  = 2,    // an [attribute name]: or a changetype: 
                               // (add|delete|etc.)
    RT_ATTR_MIN_SEP    = 3,    // an attribte name, a minus or (at least) 
                               // two separators
    RT_CH_OR_SEP       = 4,    // a changetype: or another SEP signifying 
                               // entry's end
    RT_MODBEG_SEP      = 5,    // a (add|delete|replace), or a another SEP 
                               // signifying end
    RT_C_VALUE         = 6,    // one of the colons followed by the appropriate 
                               // value
    RT_ATTRNAME        = 7,    // an attribute name followed by the colons.            
    RT_VALUE           = 8,    // a regular safevalue
    RT_MANY            = 9,    // any number of different things
    RT_DIGITS          = 10,   // some digits 
    RT_BASE64          = 11,   // a base64 as defined in RFC 1521. 
                               // (length mod 4 MUST ==0)
    RT_URL             = 12,   // a URL
    RT_NDN             = 13,   // a newrdn: or a newrdn::
    RT_ATTRNAMENC      = 14,   // an attribute name without a colon
    RT_ADM             = 15,   // an add, delete, or a modify
    RT_ACDCRC          = 16    // and add: delete: or replace:
};


// 
// functions accessible to the user
//

STDAPI_(LDIF_Error)
LDIF_InitializeImport(
    LDAP *pLdap,
    PWSTR filename,
    PWSTR szFrom,
    PWSTR szTo,
    BOOL *pfLazyCommitAvail);
    
STDAPI_(LDIF_Error)
LDIF_InitializeExport(
    LDAP *pLdap,
    PWSTR *omit,
    DWORD dwFlag,
    PWSTR *ppszNamingContext,
    PWSTR szFrom,
    PWSTR szTo,
    BOOL *pfPagingAvail,
    BOOL *pfSAMAvail);

enum _LL_INIT_FLAGS
{
    LL_INIT_NAMINGCONTEXT = 1,   
    LL_INIT_BACKLINK = 2
};

STDAPI_(void)
LDIF_CleanUp();

//
// Description - LDIF_Parse:
//  This is the main function in the ldifldap library. After calling LL_init,
//  this function is called to retrieve entries from the specified file. 
//  The entries are returned one-by-one. If there is a syntax or other error,
//  the error structure returned  will contain 
//  details. A successfully parsed record will result in several things:
//  
//  1) The dn member of the LDIF_Record struct pointed to by the argument
//     will contain the DN of the entry we're working on.
//              -AND one of the following-
//  2) If the record was a regular record,
//     The content member of that same struct will contain the LDAPMods**
//     array containing the attributes and values. The fIsChangeRecord member
//     will be FALSE.
//  3) If the record was a change record,
//     The changes member of the LDIF_Record will point to the first element
//     of the linked list of changes (in the same order they were sepcified in 
//     the source file). Each of these is a struct change_list. The 
//     fIsChangeRecord member will be TRUE. 
//
//  If any sort of error occured, it 
//  will be reported in the error struct. i.e. If the error is LL_syntax,
//  the other fields of the error struct will be filled with the appropriate 
//  details. 
//   
//  The user is responsible for using and freeing the memory in the returned 
//  structures.
//  This memory may be freed by calling LDIF_ParseFree();
//
//  Also, please note that the allocated memory is only valid before you call 
//  another LL library fucntion (ie. calling LDIF_Parse again), This is 
//  because if some sort of fatal error occurs (i.e. syntax),
//  all resources related to the current ldifldap session will be freed,
//  thus destroying these structures. The user must either use these constructs 
//  and free them, or copy them elsewhere. (There are originally allocated from 
//  the library's private heap.)
//
//  If the entry read was the last one in the file, the return code will
//  be LL_EOF instead of LL_SUCCESS. LDIF_Parse will also return LL_EOF
//  on any subsequent calls until LDIF_CleanUp and LL_init are called to start a
//  new session.  
//
//  Arguments:
//      LL_Record//pRecord; (OUT)
//          This argument takes a pointer to an LDIF_Record the user has created. 
//          This object will be filled with data if the function exits without 
//          error.
//      
//  Return Value:
//      LDIF_Error
//         An LDIF_Error struct. 
//  
//  Example:
//  
//  LDIF_Error            error;
//  LDIF_Record           returned;
//
//  error=LDIF_Parse(&returned);
//  if((error.error_code==LL_SUCCESS)||((error.error_code==LL_EOF)) {
//      LDIF_ParseFree(&returned);
//  }
// 
STDAPI_(LDIF_Error)
LDIF_Parse(LDIF_Record *pRecord);


//
// Description - LDIF_LoadRecord:
//  LDIF_LoadRecord takes the return values of LDIF_Parse, namely the LL_rec, 
//  and loads them into the DS over the specified 
//  LDAP connection. The user is also free to construct his own structures 
//  and pass them to LDIF_LoadRecord. However, they must follow the conventions 
//  that LDIF_Parse follows when returning these to the user. LDIF_LoadRecord does
//  not free anything by itself, however an LDAP error will raise an exception 
//  and cause it to shut down all state in the current ldifldap session. 
//  The function returns the usual error struct. If an error occurs, the 
//  error_code will contain LL_LDAP, and the ldap_err field will contain the 
//  error code the ldap call returned. 
//  
// Arguments:
//  LDAP//ld (IN)   - connection over which to send entries. This must be 
//                    initialized properly.
//  LDIF_Record//pRecord (IN) - the LL_rec argument filled in by LDIF_Parse
//  int active  -   0  for "don't actually do the LDAP calls" Just go through 
//                     the data printing it out if compiled with the DEVELOP 
//                     flag
//              -   1  Go LDAP calls hot. (read: do the actual calls)
// 
// Return Values:
//          The usual error struct.
//
STDAPI_(LDIF_Error)
LDIF_LoadRecord(LDAP   *ld, LDIF_Record *pRecord, int active, 
                BOOL fLazyCommit, BOOLEAN fDoEndIfFail);


//
// Description: LDIF_ParseFree
//      Free the resources allocated by LDIF_Parse associated with the 
//      argument. This function should be called after the data returned by 
//      LL_ldif parse has been used. It should not be called after an LDIF_CleanUp 
//      or after an LDAP library call returned with an error. (That means all 
//      resources have already been freed.) 
// Arguments:
//      LDIF_Record//pRecord;
// Return values:
//      The regular error struct deal. 
// 
//
STDAPI_(LDIF_Error)
LDIF_ParseFree(LDIF_Record *pRecord);


//
//  Description: LDIF_GenerateEntry 
//      This function takes an entry such as those returned by 
//      ldap_first_entry( ld, res );, the LDAP connection it was generated
//      over and a pointer to a char**. It creates an array of
//      strings in the LDIF format, corresponding to the entry.
//      this list is NULL terminated.
//      If any one of the values in any of the attributes are 
//      outside the normal printable text range 0x20-0x7E, it base64
//      encodes all the values of that attribute and outputs them 
//      accordingly. All values that would exceed 80 characters are
//      wrapped. If the samLogic parameter is non-zero, much special
//      processing (like omitting various attributes and separating
//      off membership information will be done for samObjects.) 
//      The the_modify member of error struct will contain the array index 
//      where the group additions start or -1 if there is no modify section. 
//      See rload.doc for details. Also, if you want to import, don't forget 
//      to omit objectGUID for all objects.
//      One last caveat is that if objectClass is one
//      of the attribures, it only outputs the last value (being 
//      the actual class) LDAP returns the entire inheritance tree
//      leading to the specific class but barfs if its sees them all on the
//      way back, when we try to add the entry. Since the file 
//      needs to be digestible on the way back, we need to make this 
//      adjustment. Also the user may specify a null terminated list
//      of attribute names that the function will omit on output.
//      Each line is terminated by carriage returns and \0s, so
//      sample usage of the function that would print out all the entries
//      in a given search result would look like:
//    
//    fputs("# Generated by LDIF_GenerateEntry. Have a nice day.\n", Generated);
//         
//    for ( entry = ldap_first_entry( ld, res ); 
//         entry != NULL; 
//         entry = ldap_next_entry( ld, entry ) ) { 
//         //Call the library function
//         llerr=LDIF_GenerateEntry(ld, entry, &parsed, NULL);
//         i=0;
//         while(parsed[i]) {
//             printf("%s", parsed[i]); 
//             if (fputs(parsed[i], Generated)==EOF) {
//               perror("Stream error");
//             }
//             free(parsed);
//             i++;
//         }
//         free(parsed);
//         if (fputs("\n", Generated)==EOF) {
//            perror("Stream error");
//         }
//         printf("\n\r");
//   }
//  
//  Args:
//      ld (IN) - the connection over which the LDAPMessage e was retrieved
//      e  (IN) - The entry to process as returned by ldap_(first/next)_entry
//      to_return (OUT) - A pointer to a char//*. Will be filled with the
//                        address of the array of strings.
//      omit    - A null terminated array of strings to omit on output. 
//      samLogic - non-zero to treat SamObjects specially, 0 for not to.
// Return Values:   
//      LDIF_Error   -   Regular LDIF_Error struct.
//
STDAPI_(LDIF_Error)
LDIF_GenerateEntry(
    LDAP        *pLdap, 
    LDAPMessage *pMessage, 
    PWSTR       **ppReturn, 
    BOOLEAN     fSamLogic,
    BOOLEAN     fIgnoreBinary,
    PWSTR       **pppszAttrsWithRange,
    BOOL        fAttrsWithRange);

STDAPI_(LDIF_Error) LDIF_FreeStrs(PWSTR *rgpszStr);

typedef struct ldapmodW_Ext {
    ULONG     mod_op;
    PWCHAR    mod_type;
    union {
        PWCHAR  *modv_strvals;
        struct berval   **modv_bvals;
    } mod_vals;
    BOOLEAN    fString;
} LDAPModW_Ext, *PLDAPModW_Ext;


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\inc\memory.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    memory.h

Abstract:

    This is the header file that will be precompiled. Include this in all
    the source files

Environment:

    User mode

Revision History:

    10/08/98 -felixw-
        Created it

--*/

#ifndef _MEMORY
#define _MEMORY

#ifdef __cplusplus
extern "C" {
#endif

#define LL_MEMORY_ERROR    0x00000100 

STDAPI_(PSTR)
MemAllocStr_E(PSTR in);
STDAPI_(PWSTR)
MemAllocStrW_E(PWSTR in);
STDAPI_(LPVOID)
MemAlloc_E(DWORD dwBytes);
STDAPI_(LPVOID)
MemRealloc_E(LPVOID IpMem, DWORD dwBytes);

DWORD
MemSize(
   LPVOID pMem
);

LPVOID
MemAlloc(
    DWORD cb
);

BOOL
MemFree(
   LPVOID pMem
);

LPVOID 
MemReallocEx(
    LPVOID IpMem, 
    DWORD dwBytes
    );

LPVOID
MemRealloc(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

PSTR
MemAllocStr(
    PSTR pStr
);

PWSTR
MemAllocStrW(
    PWSTR pStr
);


BOOL
MemReallocStr(
   PSTR *ppStr,
   PSTR pStr
);

int UnicodeToAnsiString(PCWSTR pszUnicode,PSTR pszAnsi);
PSTR AllocateAnsiString(PCWSTR  pszUnicodeString);
PWSTR AllocateUnicodeString(PCSTR  pszAnsiString);
int AnsiToUnicodeString(PCSTR pszAnsi,PWSTR pszUnicode);

#if DBG

extern LIST_ENTRY MemList ;

extern CRITICAL_SECTION MemCritSect ;

STDAPI_(VOID) InitMem(
    VOID
    ) ;

VOID AssertMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();

#else

#define InitMem()
#define AssertMemLeaks()
#define DumpMemoryTracker()

#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\inc\utils.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This is the header file that will be precompiled. Include this in all
    the source files

Environment:

    User mode

Revision History:

    03/20/98 -srinivac-
        Created it

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <objidl.h>
#include <stdio.h>

#include "symhelp.h"
#include "debug.h"
#include "memory.h"
#include "async.h"

#endif // ifndef _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifde\main.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    The LDIF Bulk Import/Export Utility

DETAILS:
    
CREATED:

    08/10/97       Felix Wong (felixw)

REVISION HISTORY:

--*/

#include "ldifde.hxx"
#pragma hdrstop

#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#define UNICODE_MARK 0xFEFF

//
// Global variables (necessary for printouts)
//
FILE *g_pFileLog = NULL;            // Status log
FILE *g_pFileErrorLog = NULL;       // Error log              
BOOLEAN g_fDot = FALSE;             // Info for Status Tracker
BOOLEAN g_fError = FALSE;

BOOLEAN g_fVerbose = FALSE;         // SelectivePrint needs this info
BOOLEAN g_fWriteLogs = FALSE;       // Should we write to ldif.log and ldif.err

PWSTR g_szErrorFilename = NULL;
PWSTR g_szDefaultFilter = L"(objectClass=*)";


PWSTR GetDCName(BOOLEAN fWritable);
BOOL GetPassword(PWSTR szBuffer, DWORD dwLength, DWORD *pdwLengthReturn);
#define     CR              0xD
#define     BACKSPACE       0x8
#define     NULLC           '\0'
#define     NEWLINE         '\n'


int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );


//+---------------------------------------------------------------------------
// Function: InitArgument    
//
// Synopsis: Initialization of Argument variables to default settings
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void InitArgument(ds_arg *pArg)
{
    pArg->dwPort = 389;
    pArg->szGenFile = NULL;    
    pArg->szFilename = NULL;
    pArg->szDSAName = NULL;
    pArg->szRootDN = NULL;
    pArg->szFilter = NULL;
    pArg->szFromDN = NULL;
    pArg->szToDN = NULL;
    pArg->attrList = NULL;
    pArg->omitList = NULL;
    pArg->dwScope = -1;
    pArg->creds.User = NULL;
    pArg->creds.Domain = NULL;
    pArg->creds.Password = NULL;
    pArg->fCopiedPassword = FALSE;
    pArg->fActive = TRUE;
    pArg->fSimple = FALSE;
    pArg->fSealing = FALSE;
    pArg->fExport = TRUE;
    pArg->fVerbose = FALSE; 
    pArg->fSAM = FALSE;
    pArg->fErrorExplain = TRUE;
    pArg->fPaged = TRUE;
    pArg->fSkipExist = FALSE;
    pArg->fBinary = TRUE;
    pArg->fSpanLine = FALSE;
    pArg->szLocation = NULL;
    pArg->fUnicode = FALSE;
    pArg->fLazyCommit = FALSE;
    pArg->dwLDAPConcurrent = 1;

}         


//+---------------------------------------------------------------------------
// Function: FreeArgument   
//
// Synopsis: Free argument variables   
//
// Arguments:  
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeArgument(ds_arg *pArg)
{
    if (pArg->szFromDN) {
        MemFree(pArg->szFromDN);
    }
    if (pArg->szToDN) {
        MemFree(pArg->szToDN);
    }
    if (pArg->attrList) {
        MemFree(pArg->attrList);
    }
    if (pArg->omitList) {
        MemFree(pArg->omitList);
    }
}




//+---------------------------------------------------------------------------
// Function:  Main  
//
// Synopsis: Main Program Entry
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
extern "C" int __cdecl wmain(
    IN  int     argc,
    IN  PWSTR  argv[]
)
{
    
    DWORD hr = ERROR_SUCCESS;
    LDAP    *pLdap[MAX_LDAP_CONCURRENT];
    unsigned long err;
    ds_arg Argument;
    VOID *data;
    PWSTR szLogfileName = NULL;
    PWSTR szDSAName = NULL;
    PWSTR pszPassword = NULL;

    ULONG msgnum;
    
    InitArgument(&Argument);
    
    InitMem();

    SetThreadUILanguage(0);

    // Initialize each connection
    for (int i=0; i<MAX_LDAP_CONCURRENT; i++) {
	    pLdap[i] = NULL;
    }

    hr = ProcessArgs(argc,
                     argv,
                     &Argument);
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // Setting up Logfile location
    //
    if (Argument.szLocation) {

        g_fWriteLogs = TRUE;
    
        CStringW str;
        hr = str.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(Argument.szLocation);
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"\\");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"ldif.log");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.GetCopy(&szLogfileName); 
        DIREXG_BAIL_ON_FAILURE(hr);

        hr = str.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(Argument.szLocation);
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"\\");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"ldif.err");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.GetCopy(&g_szErrorFilename); 
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    else {
        szLogfileName = MemAllocStrW(L"ldif.log");
        if (!szLogfileName) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        g_szErrorFilename = MemAllocStrW(L"ldif.err");
        if (!g_szErrorFilename) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    if (g_fWriteLogs) {
        if (g_fUnicode) {
            if ((g_pFileLog = _wfopen(szLogfileName , 
                                      L"wb")) == NULL) {
                hr = ERROR_OPEN_FAILED;
                SelectivePrintW(PRT_STD,
                               MSG_LDIFDE_UNABLEOPEN);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        
            if(fputwc(UNICODE_MARK,
                      g_pFileLog)==WEOF) {
                hr = ERROR_OPEN_FAILED;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        else {
            if ((g_pFileLog = _wfopen(szLogfileName, 
                                      L"wt")) == NULL) {
                hr = ERROR_OPEN_FAILED;
                SelectivePrintW(PRT_STD,
                               MSG_LDIFDE_UNABLEOPEN);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }

    //
    //  Check whether the import file can be read
    //
    if (!Argument.fExport) {
    FILE* pFileIn = _wfopen(Argument.szFilename, L"rb");
        WCHAR wChar;
        BOOLEAN failed = FALSE;
        if (pFileIn == NULL || (wChar = fgetwc(pFileIn)) == WEOF)
            failed = TRUE;
        if (pFileIn)
            fclose(pFileIn);
        if (failed) {
            hr = ERROR_OPEN_FAILED;
            SelectivePrintW(PRT_STD, MSG_LDIFDE_IMPORTFILE_FAILED_READ,
                Argument.szFilename);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    //
    // Required by SelectivePrint
    //
    g_fVerbose = Argument.fVerbose;

    if (Argument.szDSAName == NULL) {
        szDSAName = GetDCName(!Argument.fExport);
        if (szDSAName != NULL) {
            Argument.szDSAName = szDSAName;
        }
        else {
            SelectivePrintW(PRT_STD,
                           MSG_LDIFDE_NODCAVAILABLE);
            hr = ERROR_DS_SERVER_DOWN;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    //
    // If the user inputs '*', we'll get the password without 
    // echoing the output
    //
    
    if (Argument.creds.Password && 
        (wcscmp(Argument.creds.Password,L"*") == 0)) {
        WCHAR szBuffer[PWLEN+1];
        DWORD dwLength;

        SelectivePrintW(PRT_STD,
                        MSG_LDIFDE_GETPASSWORD,
                        Argument.szDSAName);

        if (GetPassword(szBuffer,PWLEN+1,&dwLength)) {
            pszPassword = MemAllocStrW(szBuffer);   
            if (!pszPassword && szBuffer) {
                SecureZeroMemory(szBuffer, sizeof(szBuffer));
                hr = ERROR_NOT_ENOUGH_MEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            SecureZeroMemory(szBuffer, sizeof(szBuffer));
            Argument.creds.Password = pszPassword;
            Argument.creds.PasswordLength = dwLength;
            Argument.fCopiedPassword = TRUE;
        }
        else {
            SelectivePrintW(PRT_STD,
                            MSG_LDIFDE_PASSWORDTOLONG,
                            Argument.szDSAName);
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // CONNECTION section
    //
        
    SelectivePrintW(PRT_STD|PRT_LOG,
                   MSG_LDIFDE_CONNECT,
                   Argument.szDSAName);
  
    if (Argument.fExport){
	    Argument.dwLDAPConcurrent = 1;
    }

    for( i=0; i<(int)Argument.dwLDAPConcurrent; i++){
        //
        // start as many connections as needed
        //
        
        if ( (pLdap[i] = ldap_initW( Argument.szDSAName, 
                                     Argument.dwPort )) == NULL )  {
            hr = LdapToWinError(LdapGetLastError());
            if (i == 0) {
                //
                // Couldn't create any connections, so bail.
                //
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_CONNECT_FAIL,hr);
                
                Argument.dwLDAPConcurrent = 0;
    	        DIREXG_BAIL_ON_FAILURE(hr);
    	    }
            else {
                //
    	        // have at least one connection, so use them,
    	        // but first warn the user
    	        //
                SelectivePrintW(PRT_STD|PRT_LOG,
                               MSG_LDIFDE_THREAD_FAILED_CONNECT,
                               i);    	        
    	        Argument.dwLDAPConcurrent = i;
    	        hr = ERROR_SUCCESS;
    	        break;
           }
        }
        else {
            if (err = ldap_connect(pLdap[i], g_pLdapTimeout) != LDAP_SUCCESS) {
                hr = LdapToWinError(err);
    	        if (i == 0) {
    	            //
    	            // Couldn't create any connections, so bail.
    	            //
                    SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                            MSG_LDIFDE_CONNECT_FAIL,hr);
        	            
                    Argument.dwLDAPConcurrent = 0;
    	            DIREXG_BAIL_ON_FAILURE(hr);
    	        }
                else {
                    //
    	            // have at least one connection, so use what
    	            // we have, but first warn the user
    	            //
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                   MSG_LDIFDE_THREAD_FAILED_CONNECT,
                                   i);    	        
        	            
    	            ldap_unbind(pLdap[i]);  // free the connection we ldap_init'ed
    	            Argument.dwLDAPConcurrent = i;
    	            hr = ERROR_SUCCESS;
    	            break;
    	        }
            }
        }

        data = (VOID*)LDAP_OPT_OFF;
        ldap_set_option( pLdap[i], LDAP_OPT_REFERRALS, &data );
        data = (VOID*)LDAP_VERSION3 ;
        ldap_set_option( pLdap[i], LDAP_OPT_VERSION, &data );
        if (Argument.fSealing)
        {
            data = (VOID*)LDAP_OPT_ON;
            err = ldap_set_option(pLdap[i], LDAP_OPT_ENCRYPT, &data);
            if (err != LDAP_SUCCESS)
            {
                SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                           MSG_LDIFDE_CANNOT_SET_LDAP_OPT_ENCRYPT_FLAG,
                                           ldap_err2string(err));
                hr = LdapToWinError(err);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }

        if (Argument.creds.User) {
            if (Argument.fSimple) {

                if (i == 0) {
                    // only show this status message once
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                   MSG_LDIFDE_SIMPLEBIND,
                                   Argument.creds.User);
                }
                
                msgnum = ldap_simple_bindW( pLdap[i], 
                                            Argument.creds.User, 
                                            Argument.creds.Password);

                err = LdapResult(pLdap[i], msgnum, NULL);
                                      
                if ( err != LDAP_SUCCESS ) {
                    if (err != LDAP_INVALID_CREDENTIALS) {
                        //
                        // If it is not invalid crednetials, we'll fall to version
                        // 2 and try again
                        //
                        data = (VOID*)LDAP_VERSION2 ;
                        ldap_set_option( pLdap[i], LDAP_OPT_VERSION, &data );
                        
                        msgnum =ldap_simple_bindW( pLdap[i], 
                                                   Argument.creds.User, 
                                                   Argument.creds.Password);

                        err = LdapResult(pLdap[i], msgnum, NULL);
                        
                        if ( err != LDAP_SUCCESS ) {
                            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                           MSG_LDIFDE_SIMPLEBINDRETURN, 
                                           ldap_err2string(err) );
                            hr = LdapToWinError(err);
                            DIREXG_BAIL_ON_FAILURE(hr);
                        }
                    }
                    else {
                        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                       MSG_LDIFDE_SIMPLEBINDRETURN, 
                                       ldap_err2string(err) );
                        hr = LdapToWinError(err);
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
            } 
            else {
                if (i == 0) {
                    // only show this status message once
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                    MSG_LDIFDE_SSPI,
                                    Argument.creds.User,
                                    Argument.creds.Domain);
                }
                
                Argument.creds.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
                if ( (err=ldap_bind_sW( pLdap[i], 
                                       NULL, 
                                       (PWSTR)&(Argument.creds), 
                                       LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
                    SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                   MSG_LDIFDE_SSPIRETURN, 
                                   ldap_err2string(err) );
                    hr = LdapToWinError(err);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }   
            } 
        }
        else {
            if (i == 0) {
                // only show this status message once
                SelectivePrintW(PRT_STD|PRT_LOG,
                               MSG_LDIFDE_SSPILOCAL);
            }
            
            if ( (err = ldap_bind_s( pLdap[i], 
                                     NULL, 
                                     NULL, 
                                     LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
                SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_SSPILOCALRETURN, 
                                ldap_err2string(err) );
                hr = LdapToWinError(err);
                DIREXG_BAIL_ON_FAILURE(hr);
            }   
        }
    }   // end of connection creation loop


    //
    // Destroy our copy of the password so it's not sitting around
    // in memory after we're done with it.  We only do this if we
    // made a copy of it --- if it's in the command-line buffer,
    // we can't do anything about it (and entering a password on the
    // command-line isn't very secure anyway).
    //
    if (Argument.fCopiedPassword && Argument.creds.Password) {
        SecureZeroMemory(Argument.creds.Password, wcslen(Argument.creds.Password)*sizeof(WCHAR));
    }

        
    //
    //  ACTION section
    //
    if (Argument.fExport) {
        hr = DSExport(pLdap[0], 
                      &Argument);
    } else {    
        hr = DSImport(pLdap, 
                      &Argument);
    }    
    
    //
    // Printing results
    //
    if (hr == ERROR_SUCCESS) {
        SelectivePrint2W(PRT_STD|PRT_LOG,
                         L"\n");
        SelectivePrintW(PRT_STD|PRT_LOG,
                       MSG_LDIFDE_COMPLETE);
    }
    else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_MEMERROR);
    }
    else if (hr == ERROR_TIMEOUT) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_LDIFDE_TIMEOUT);
    }
    else {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_ERROROCCUR);
    }


error:  

    if ((hr != ERROR_SUCCESS) && !g_fWriteLogs) {

        // Tell the user how to get the logs if an error occurred
        SelectivePrintW(PRT_STD, MSG_LDIFDE_NOLOGSWRITTEN);
    }

    if (szDSAName) {
        MemFree(szDSAName);          
    }
    if (g_szErrorFilename) {
        MemFree(g_szErrorFilename);
    }
    if (szLogfileName) {
        MemFree(szLogfileName);
    }
    if (g_pFileLog) {
        fclose(g_pFileLog);
    }
    if (g_pFileErrorLog) {
        fclose(g_pFileErrorLog);
    }
    if (pszPassword) {
        MemFree(pszPassword);
        pszPassword = NULL;
    }

    if ((Argument.dwLDAPConcurrent == 1) && pLdap[0]) {
        ldap_unbind(pLdap[0]);
        pLdap[0] = NULL;
    }
    else {
        // do the rest of the unbinds
    	for (i=0; i<(int)Argument.dwLDAPConcurrent; i++) {
    	    ldap_unbind(pLdap[i]);
    	    pLdap[i] = NULL;
    	}
    }
    
    FreeArgument(&Argument);
    DumpMemoryTracker();
    return(hr);
}


//+---------------------------------------------------------------------------
// Function:  ProcessArgs  
//
// Synopsis:  Process the Argument list passed into Main()  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD 
ProcessArgs(
    int argc,
    PWSTR argv[],
    ds_arg* pArg   
    )
{
    int i;
    DWORD hr = ERROR_SUCCESS;
    BOOLEAN bCredentials = FALSE;
    BOOLEAN bLazyCommit = FALSE;
    BOOLEAN rgbUsed[26];
    WCHAR cKey;
    PWSTR s;
    DWORD dwMaxThread = 0;


    memset(rgbUsed,0,sizeof(BOOLEAN) * 26);

    if (argc == 1) {
        hr = ERROR_INVALID_PARAMETER;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    for (i=1; i < argc; i++) {

        if (((argv[i][0] != '-') && (argv[i][0] != '/')) || 
            (argv[i][1] && (argv[i][2] != NULL))) {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARGUMENT, argv[i]);
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        cKey = argv[i][1];
        if ((cKey >= 'a') && (cKey <= 'z')) {
            cKey = towupper(argv[i][1]);
        }
        if ((cKey >= 'A') && (cKey <= 'Z')) {
            if (rgbUsed[cKey-'A']) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_ARGUMENTTWICE, argv[i]);
                hr = ERROR_INVALID_PARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                rgbUsed[cKey-'A'] = TRUE;
            }
        }
        else {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_UNKNOWN); 
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        switch (argv[i][1]) {

            case 'g':
            case 'G':
                pArg->fPaged = FALSE;
                break;

            case 'i':
            case 'I':
                pArg->fExport = FALSE;
                if (!bLazyCommit)
                    pArg->fLazyCommit = TRUE;
                break;
        
            case 't':
            case 'T':
                if ((++i >= argc) || (!argv[i])) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_PARAM_PORT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->dwPort = _wtoi(argv[i]);
                if (pArg->dwPort == 0) {
                    // If dwPort returns 0, we check whether it is really 0 or if it was
                    // a failure in atoi
                    if (wcscmp(argv[i],L"0") != 0) {
                        SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_PARAM_PORT);
                        hr = ERROR_INVALID_PARAMETER;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                break;

            case 'w':
            case 'W':
                if ((++i >= argc) || (!argv[i])) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_TIMEOUT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                // Validate that specified value is entirely numeric.
                s=argv[i];
                while (*s) {
                    if (!iswdigit(*s)) {
                        SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_TIMEOUT);
                        hr = ERROR_INVALID_PARAMETER;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    s++;
                }
                
                g_LdapTimeout.tv_sec = _wtoi(argv[i]);

                if (g_LdapTimeout.tv_sec <= 0) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_TIMEOUT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                g_pLdapTimeout = &g_LdapTimeout;
                break;


            case 'f':
            case 'F':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FILENAME);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szGenFile = argv[i];
                pArg->szFilename = argv[i];
                break;
            
            case 'j':
            case 'J':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_LOGFILE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szLocation = argv[i];
                break;

            case 's':
            case 'S':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_SERVERNAME);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szDSAName = argv[i];
                break;

            case 'v':
            case 'V':
                pArg->fVerbose = TRUE;
                break;

            case '?':
                PrintUsage();       
                break;

            //
            // Export Parameters
            //

            case 'd':
            case 'D':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ROOTDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szRootDN = argv[i];
                break;

            case 'r':
            case 'R':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FILTER);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szFilter = argv[i];
                break;

            case 'p':
            case 'P':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_SCOPE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
               
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_SCOPE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!_wcsicmp(argv[i], L"Base" ))
                    pArg->dwScope = LDAP_SCOPE_BASE;
                else if (!_wcsicmp(argv[i], L"OneLevel" ))
                    pArg->dwScope = LDAP_SCOPE_ONELEVEL;
                else if (!_wcsicmp(argv[i], L"Subtree" ))
                    pArg->dwScope = LDAP_SCOPE_SUBTREE;
                else {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_BADSCOPE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                break;
       
            case 'c':
            case 'C':
            {
                PWSTR pszTrimmedString, pszBuffer;
            
                if ((i+2) >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FROMDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                i++;
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FROMDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpacesW(pszBuffer);
                pArg->szFromDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szFromDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);

                
                i++;
                if (!argv[i]) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FROMDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpacesW(pszBuffer);
                pArg->szToDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szToDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);
                
                break;
            }
            

            case 'l':
            case 'L':
            {
                PWSTR *rgszArgument = NULL;
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);
                pArg->attrList = rgszArgument;
                break;
            }

            case 'o':
            case 'O':
            {
                PWSTR *rgszArgument = NULL;

                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR2);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR2);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);
                pArg->omitList = rgszArgument;
                break;
            }

            case 'm':
            case 'M':
                pArg->fSAM = TRUE;
                break;

            case 'n':
            case 'N':
                pArg->fBinary = FALSE;
                break;

            //
            // Import Parameters
            //
            
            case 'k':
            case 'K':
                pArg->fSkipExist = TRUE;
                break;

            //
            // Credentials Establishment
            //
                
            case 'a':
            case 'A':
                if (bCredentials) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPCRED);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+2) >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQUSRPWD);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;
                pArg->fSimple = TRUE; 
                
                i++;
                pArg->creds.User = argv[i];
                if (!pArg->creds.User) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Password = argv[i];
                if (!pArg->creds.Password) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;
            
            case 'u':
            case 'U':
                pArg->fUnicode = TRUE;
                g_fUnicode = TRUE;
                break;

            case 'b':
            case 'B':
                if (bCredentials) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPCRED);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+3) >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQUSRDOMPWD);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;

                i++;
                pArg->creds.User = argv[i];
                if (!pArg->creds.User) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Domain = argv[i];
                if (!pArg->creds.Domain) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.DomainLength = wcslen(argv[i]);

                i++;
                pArg->creds.Password = argv[i];
                if (!pArg->creds.Password) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;

            case 'h':
            case 'H':
                pArg->fSealing = TRUE;
                break;

            case 'y':
            case 'Y':
                if (bLazyCommit) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPLAZYCOMMIT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            
                pArg->fLazyCommit = TRUE;
                bLazyCommit = TRUE;
                break; 

            case 'e':
            case 'E':
                if (bLazyCommit) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPLAZYCOMMIT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            
                pArg->fLazyCommit = FALSE;
                bLazyCommit = TRUE;
                break;

            case 'q':
            case 'Q':
                if ((++i > argc) || (!argv[i])) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_PARAM_THREAD);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                dwMaxThread = _wtoi(argv[i]);
                if (((LONG)dwMaxThread) <= 0) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_THREAD_COUNT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if (dwMaxThread > MAX_LDAP_CONCURRENT) {
                    SelectivePrintW(PRT_STD, MSG_LDIFDE_TOO_MANY_THREADS, MAX_LDAP_CONCURRENT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);                    
                }
                pArg->dwLDAPConcurrent = dwMaxThread;
                break;
                
            default:
                SelectivePrintW( PRT_STD,MSG_LDIFDE_UNKNOWN);
                hr = ERROR_INVALID_PARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
        } 
    } 
        
    // 
    // Checking Mandatory Options
    //
    if (hr == ERROR_SUCCESS) {
        if (!pArg->szFilename) {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQFILE);
            hr = ERROR_INVALID_PARAMETER;
        }
        /*
        if (!pArg->szDSAName) {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQSERVER);
            hr = ERROR_INVALID_PARAMETER;
        }
        */

        if (!pArg->fExport) {
            // Require for Import

            // Not Require
            if (pArg->szRootDN) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQROOTDN);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->szFilter) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQFILTER);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->dwScope != -1) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQSCOPE);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->fSAM) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQSAM);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->omitList) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQOMIT);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->attrList) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQATTR);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (!pArg->fBinary) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQBINARY);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->fSpanLine) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQSPAN);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->fPaged == FALSE) { 
                SelectivePrintW(PRT_STD,
                               MSG_LDIFDE_BADARG_NREQPAGE);
                hr = ERROR_INVALID_PARAMETER;
            }
        }
        else {
            // Require for Export
            if (!pArg->szFilter) {
                pArg->szFilter = g_szDefaultFilter;
            }
            if (pArg->dwScope == -1) {
                pArg->dwScope = LDAP_SCOPE_SUBTREE;
            }

            // Not Require
            if (pArg->fSkipExist) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQ_SKIP);
                hr = ERROR_INVALID_PARAMETER;
            }

            if (pArg->fLazyCommit || bLazyCommit) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQ_LAZY_COMMIT);
                hr = ERROR_INVALID_PARAMETER;
            }

            if (pArg->dwLDAPConcurrent != 1) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQ_NUM_THREADS);
                hr = ERROR_INVALID_PARAMETER;
            }
        }
    }
error:  
    if (hr != ERROR_SUCCESS) {
        PrintUsage();
    }
    return (hr);
}


//***************************
//  UTILITIES SECTION
//***************************

//+---------------------------------------------------------------------------
// Function:  RemoveWhiteSpaces  
//
// Synopsis:  Removes trailing and starting white spaces  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
LPSTR
RemoveWhiteSpaces(
    LPSTR pszText)
{
    LPSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && isspace(*pszText))
        pszText++;

    for(pChar = pszText + strlen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!isspace(*pChar))
            break;
        else
            *pChar = '\0';
    }
    return pszText;
}

//+---------------------------------------------------------------------------
// Function:  RemoveWhiteSpacesW  
//
// Synopsis:  Removes trailing and starting white spaces  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
PWSTR
RemoveWhiteSpacesW(
    PWSTR pszText)
{
    PWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = '\0';
    }
    return pszText;
}



//+---------------------------------------------------------------------------
// Function:  PrintUsage  
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void PrintUsage() {
    SelectivePrintW(PRT_STD,
                   MSG_LDIFDE_HELP);
}

#if 0
//+---------------------------------------------------------------------------
// Function:   SelectivePrint 
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint(
    DWORD dwTarget, DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    PSTR pszMessageBuffer = NULL;
    va_list ap;
    DWORD dwSize;

    va_start(ap, messageID);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE |FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                  NULL, 
                  messageID, 
                  0, 
                  (PSTR)&pszMessageBuffer, 
                  4095, 
                  &ap);

    if (!pszMessageBuffer) {
        goto error;
    }
    
    dwSize = strlen(pszMessageBuffer);
    if (g_fUnicode == FALSE) {
        if (pszMessageBuffer [dwSize-2] == '\r') {
            pszMessageBuffer [dwSize-2] = '\n';
            pszMessageBuffer [dwSize-1] = '\0';
        }
    }

    fflush(stdout);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        fprintf(stdout,pszMessageBuffer);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        fprintf(stdout,pszMessageBuffer );
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        fprintf(stdout,pszMessageBuffer);
    }

    if (g_fWriteLogs) {
        if (dwTarget & PRT_LOG) {
            fflush(g_pFileLog);    
            fprintf(g_pFileLog,pszMessageBuffer);
            fflush(g_pFileLog);
        }
        if (dwTarget & PRT_ERROR) {
            if (!g_fError) {
                g_fError = TRUE;
            }
            if (!g_pFileErrorLog) {   // If log file is not opened
                if (!bTriedOpen) {          // If we haven't tried
                    if (g_fUnicode == FALSE) {
                        if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                       L"wt")) == NULL) {
                            SelectivePrintW(PRT_STD|PRT_LOG,
                                           MSG_LDIFDE_UNABLEOPENERR);
                            bTriedOpen = TRUE;
                            goto error;
                        }
                    }
                    else {
                        if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                       L"wb")) == NULL) {
                            SelectivePrintW(PRT_STD|PRT_LOG,
                                           MSG_LDIFDE_UNABLEOPENERR);
                            bTriedOpen = TRUE;
                            goto error;
                        }
                        if(fputwc(UNICODE_MARK,
                                  g_pFileErrorLog)==WEOF) {
                            goto error;
                        }
                    }
                }
            }
            fflush(g_pFileErrorLog);
            fprintf(g_pFileErrorLog,pszMessageBuffer);
            fflush(g_pFileErrorLog);
            
        }
    }
error:
    fflush(stdout);

    va_end(ap);
    if (pszMessageBuffer) {
        LocalFree(pszMessageBuffer);
    }

    return;
}
#endif

//+---------------------------------------------------------------------------
// Function:   SelectivePrintW
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrintW(
    DWORD dwTarget, DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    PWSTR pszMessageBuffer = NULL;
    DWORD dwSize;
    va_list ap;

    va_start(ap, messageID);

    FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                   NULL, 
                   messageID, 
                   0, 
                   (PWSTR)&pszMessageBuffer, 
                   4095, 
                   &ap);

    if (!pszMessageBuffer) {
        goto error;
    }
    
    dwSize = wcslen(pszMessageBuffer);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,pszMessageBuffer);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_fwprintf(stdout,pszMessageBuffer);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,pszMessageBuffer);
    }

    if (g_fWriteLogs) {
        if (dwTarget & PRT_LOG) {
            fwprintf(g_pFileLog,pszMessageBuffer);
        }
        if (dwTarget & PRT_ERROR) {
            if (!g_fError) {
                g_fError = TRUE;
            }
            if (!g_pFileErrorLog) {   // If log file is not opened
                if (!bTriedOpen) {          // If we haven't tried
                    if (g_fUnicode == FALSE) {
                        if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                       L"wt")) == NULL) {
                            SelectivePrintW(PRT_STD|PRT_LOG,
                                           MSG_LDIFDE_UNABLEOPENERR);
                            bTriedOpen = TRUE;
                            goto error;
                        }
                    }
                    else {
                        if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                       L"wb")) == NULL) {
                            SelectivePrintW(PRT_STD|PRT_LOG,
                                           MSG_LDIFDE_UNABLEOPENERR);
                            bTriedOpen = TRUE;
                            goto error;
                        }
                        if(fputwc(UNICODE_MARK,
                                  g_pFileErrorLog)==WEOF) {
                            goto error;
                        }
                    }
                }
                else {          // we have tried so proceed as an error
                    goto error;
                }
            }
            fwprintf(g_pFileErrorLog,pszMessageBuffer);

        }
    }
error:

    va_end(ap);
    if (pszMessageBuffer) {
        LocalFree(pszMessageBuffer);
    }
    
    return;
}

//+---------------------------------------------------------------------------
// Function:   SelectivePrint2W
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint2W(
    DWORD dwTarget, PWSTR pszfmt, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    va_list args;
    
    va_start(args, pszfmt);

    if (g_fUnicode) {
        if (pszfmt && wcscmp(pszfmt,L"\n") == 0) {
            pszfmt = L"\r\n";
        }
    }


    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }

    if (g_fWriteLogs) {
        if (dwTarget & PRT_LOG) {
            vfwprintf(g_pFileLog,pszfmt,args);
        }
        if (dwTarget & PRT_ERROR) {
            if (!g_fError) {
                g_fError = TRUE;
            }
            if (!g_pFileErrorLog) {   // If log file is not opened
                if (!bTriedOpen) {          // If we haven't tried
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wt")) == NULL) {
                        SelectivePrintW(PRT_STD|PRT_LOG,
                                       MSG_LDIFDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                }
                else {
                    goto error;
                }
            }
            vfwprintf(g_pFileErrorLog,pszfmt,args);

        }
    }
error:

    va_end(args);
    
    return;
}

#if 0

//+---------------------------------------------------------------------------
// Function:   SelectivePrint2
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint2(
    DWORD dwTarget, char *pszfmt, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    va_list args;
    
    va_start(args, pszfmt);
        
    if (g_fUnicode) {
        if (pszfmt && strcmp(pszfmt,"\n") == 0) {
            pszfmt = "\r\n";
        }
    }

    fflush(stdout);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        vfprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        vfprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        vfprintf(stdout,pszfmt,args);
    }

    if (g_fWriteLogs) {
        if (dwTarget & PRT_LOG) {
            fflush(g_pFileLog);
            vfprintf(g_pFileLog,pszfmt,args);
            fflush(g_pFileLog);
            
        }
        if (dwTarget & PRT_ERROR) {
            if (!g_fError) {
                g_fError = TRUE;
            }
            if (!g_pFileErrorLog) {   // If log file is not opened
                if (!bTriedOpen) {          // If we haven't tried
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wt")) == NULL) {
                        SelectivePrintW(PRT_STD|PRT_LOG,
                                       MSG_LDIFDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                }
                else {
                    goto error;
                }
            }
            fflush(g_pFileErrorLog);
            vfprintf(g_pFileErrorLog,pszfmt,args);
            fflush(g_pFileErrorLog);

        }
    }
error:
    fflush(stdout);

    va_end(args);
    
    return;
}

#endif

#define UNIT    2           // This is the number of entries each dot represents
#define DOTS    20          // This is the number of dots before we roll back

//+---------------------------------------------------------------------------
// Function:   TrackStatus
//
// Synopsis:   Print a dot to indicate status, turn on g_fDot to indicate
//             that a dot has been printed. Any subsequent outputs require
//             a carriage return. (handled by SelectivePrint)
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void TrackStatus()
{
/*
    //  
    // This static count keeps track of where we are
    //
    static DWORD dwCount = 0;

    if (!g_fVerbose) {
        if (dwCount == (DOTS*UNIT)) {
            DWORD i;
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",' ');
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            dwCount = 0;
        }
        //
        // Only if we reached UNIT we'll print out a dot now
        //
        if (dwCount % UNIT == 0)
            printf(".");
        dwCount++;
        g_fDot = TRUE;
    }
*/
    if (!g_fVerbose) {
        wprintf(L".");
    }
    g_fDot = TRUE;
}
//+---------------------------------------------------------------------------
// Function:   GetNextEntry 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
BOOLEAN GetNextEntry(PWSTR szInput, 
                     PWSTR *pszEntry,
                     PWSTR *pszNext)
{
    PWSTR szFinal = szInput;
    
    while ((*szFinal != ',') && (*szFinal != '\0')) {
        if (*szFinal == '\\') {
            szFinal++;
            if (*szFinal == '\0') {
                return FALSE;
            }
        }
        szFinal++;
    }

    if (*szFinal == ',') {
        *szFinal = '\0';
        *pszEntry = RemoveWhiteSpacesW(szInput);
        *pszNext = szFinal+1;
        return (TRUE);
    }
    else {
        *pszEntry = RemoveWhiteSpacesW(szInput);
        *pszNext = NULL;
        return (TRUE);
    }
}



//+---------------------------------------------------------------------------
// Function:  GetAllEntries  
//
// Synopsis:  Get all the entries from a list of comma separated values
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD GetAllEntries(PWSTR szInput, 
                         PWSTR **ppszOutput)
{
    DWORD cNumberAttributes = 0;
    PWSTR *pszReturn = NULL;
    PWSTR szCurrent = NULL;
    PWSTR szEntry = NULL;
    PWSTR szNext = NULL;     
    DWORD hr = ERROR_SUCCESS;

    DWORD cNumberNeeded = 1;

    // Allocating array to store entries    
    szCurrent = szInput;
    while (*szCurrent != '\0') {
        if (*szCurrent == '\\') {
            if (*(szCurrent+1) == '\0') {
                hr = ERROR_GEN_FAILURE;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            szCurrent+=2;
            continue;
        }
        if (*szCurrent == ',') {
            cNumberNeeded++;
        }
        szCurrent++;
    }
    pszReturn = (PWSTR*)MemAlloc((cNumberNeeded+1)*sizeof(PWSTR));
    if (!pszReturn) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    szCurrent = szInput;
    if (GetNextEntry(szCurrent,
                     &szEntry,
                     &szNext) == FALSE) {
        hr = ERROR_INVALID_PARAMETER;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    pszReturn[cNumberAttributes] = szEntry;
    cNumberAttributes++;

    while (szNext) {
        szCurrent = szNext;
        if (GetNextEntry(szCurrent,
                          &szEntry,
                          &szNext) == FALSE) {
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        pszReturn[cNumberAttributes] = szEntry;
        cNumberAttributes++;
    }
    pszReturn[cNumberAttributes] = NULL;

    cNumberAttributes--;

    *ppszOutput = pszReturn;

error:
    return hr;
}


PWSTR GetDCName(BOOLEAN fWritable)
{
    DWORD dwError = 0;
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    PWSTR szDCName = NULL;

    if (fWritable) {
        //
        // Looking for a writable server
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_WRITABLE_REQUIRED,
                               &pDomainControllerInfo);
    }
    else {
        //
        // Looking for a GC first, if it fails, goto any DC
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_GC_SERVER_REQUIRED,
                               &pDomainControllerInfo);
        if (dwError != 0) {
            dwError = DsGetDcNameW(NULL, //ComputerName 
                                   NULL, //DomainName 
                                   NULL, //DomainGuid 
                                   NULL, //SiteName 
                                   DS_DIRECTORY_SERVICE_REQUIRED,
                                   &pDomainControllerInfo);
        }
    }

    if ((dwError == 0) && 
        pDomainControllerInfo && 
        (pDomainControllerInfo->DomainControllerName)) {
        szDCName = MemAllocStrW(pDomainControllerInfo->DomainControllerName+2);
    }
    if (pDomainControllerInfo) {
        NetApiBufferFree(pDomainControllerInfo);
    }
    return szDCName;
}

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR   ch;
    PWSTR   pszBufCur = szBuffer;
    DWORD   c;
    int     err;
    DWORD   mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putwchar(L'\n');

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}






 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    
    HANDLE hOut;
    DWORD currentMode;
    const DWORD dwBufferMessageSize = 4096;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    DWORD  cchWChar;
    WCHAR  szBufferMessage[dwBufferMessageSize];
    _vsnwprintf( szBufferMessage, dwBufferMessageSize, format, argptr );
    szBufferMessage[dwBufferMessageSize-1] = L'\0';
    
    cchWChar = wcslen(szBufferMessage);

    //  if it is console, we can use WriteConsoleW
    if (GetFileType(hOut) == FILE_TYPE_CHAR && GetConsoleMode(hOut, &currentMode)) {
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
    }
    //  otherwise, we need to convert Unicode to potential character sets
    //  and use WriteFile
    else {
        int charCount = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, 0, 0, 0, 0);
        char* szaStr = new char[charCount];
        if (szaStr != NULL) {
            DWORD dwBytesWritten;
            WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, szaStr, charCount, 0, 0);
            WriteFile(hOut, szaStr, charCount - 1, &dwBytesWritten, 0);
            delete[] szaStr;
        }
        else
            cchWChar = 0;
    }
    return cchWChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifde\utils.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.cxx

Abstract:
    
    Utilities

Author:

    Felix Wong [FelixW]    06-Sep-1997
    
++*/

#include "ldifde.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
// Class:  CStringPlex
//
// Synopsis: A Class that encapsulates an array of zero terminated strings    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CStringPlex::CStringPlex()
{
    m_cszMax = 0;
    m_iszNext = 0;
    m_rgsz = NULL;
}

CStringPlex::~CStringPlex()
{
    Free();
}

DWORD CStringPlex::GetCopy(LPSTR **prgszReturn)
{
    LPSTR *rgszReturn = NULL;
    DWORD hr = ERROR_SUCCESS;
    DWORD i;

    if (m_iszNext == 0) {
        hr = ERROR_INVALID_FUNCTION;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    rgszReturn = (LPSTR*)MemAlloc( m_iszNext * sizeof(LPSTR) );
    if (!rgszReturn) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    memset(rgszReturn, 0, m_iszNext * sizeof(LPSTR) );

    for (i=0;i<m_iszNext;i++) {
        rgszReturn[i] = MemAllocStr(m_rgsz[i]); 
        if (!rgszReturn[i]) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    *prgszReturn = rgszReturn;
    return hr;

error:
    if (rgszReturn) {
        i = 0;
        while ((i<m_iszNext) && rgszReturn[i]) {
            MemFree(rgszReturn[i]);
            i++;
        }
        MemFree (rgszReturn);
    }
    return hr;
}

DWORD CStringPlex::NumElements()
{
    return m_iszNext;
}

LPSTR *CStringPlex::Plex()
{
    return m_rgsz;
}


DWORD CStringPlex::Init()
{
    DWORD hr = ERROR_SUCCESS;

    Free();

    m_rgsz = (LPSTR*)MemAlloc( STRINGPLEX_INC * sizeof(LPSTR) );
    if (!m_rgsz ) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_cszMax = STRINGPLEX_INC;
    m_iszNext = 0;
    memset(m_rgsz, 0, STRINGPLEX_INC * sizeof(LPSTR) );

error:
    return hr;
}

DWORD CStringPlex::AddElement(LPSTR szValue)
{
    DWORD hr = ERROR_SUCCESS;
    LPSTR *rgszT = NULL;

    if (!szValue) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If next index is larger than largest index
    //
    if (m_iszNext > (m_cszMax-1)) {
        rgszT = (LPSTR*)MemReallocEx(m_rgsz , 
                                (m_cszMax + STRINGPLEX_INC)*sizeof(LPSTR));
        if (!rgszT) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_rgsz = rgszT;
        m_cszMax+=STRINGPLEX_INC;
    }

    m_rgsz [m_iszNext] = MemAllocStr(szValue);
    if (!m_rgsz [m_iszNext]) {
         hr = ERROR_NOT_ENOUGH_MEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_iszNext++;
error:
    return hr;
}

void CStringPlex::Free()
{
    DWORD isz = 0;

    if (m_rgsz) {
        for (isz=0;isz<m_iszNext;isz++) {
            if (m_rgsz[isz]) {
                MemFree(m_rgsz[isz]);
            }
        }
        MemFree (m_rgsz);
        m_rgsz = NULL;
    }
    m_cszMax = 0;
    m_iszNext = 0;
}

//+---------------------------------------------------------------------------
// Class:  CString
//
// Synopsis: A class that encapsulates a variable size string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CString::CString()
{
    m_sz = NULL;
    m_ichNext = 0;
    m_cchMax = 0;
}

CString::~CString()
{
    Free();
}

DWORD CString::Init()
{
    Free();
    m_sz = (LPSTR)MemAlloc(STRING_INC * sizeof(char));
    if (!m_sz) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    m_cchMax = STRING_INC;
    m_ichNext = 0;
    m_sz[0] = '\0';
    return ERROR_SUCCESS;
}

DWORD CString::GetCopy(LPSTR *pszReturn)
{
    LPSTR szReturn = NULL;
    szReturn = MemAllocStr(m_sz);
    if (!szReturn) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pszReturn = szReturn;
    return ERROR_SUCCESS;
}

LPSTR CString::String()
{
    return m_sz;
}


DWORD CString::Append(LPSTR szAppend)
{
    DWORD hr = ERROR_SUCCESS;
    LPSTR szT;
    DWORD cchResult;
    DWORD cchAppend;
    
    cchAppend = strlen(szAppend);
    if ((cchAppend + m_ichNext) > (m_cchMax - 1)) {
        //
        // If normal addition of memory is not enough
        //
        if ((cchAppend + m_ichNext) > (m_cchMax + STRING_INC - 1)) {
            cchResult = m_cchMax + STRING_INC + cchAppend;
        }
        else {
            cchResult = m_cchMax + STRING_INC;
        }
        szT = (LPSTR)MemReallocEx(m_sz, sizeof(char) * cchResult);
        if (!szT) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_sz = szT;
        m_cchMax = cchResult;
    }
    m_ichNext += cchAppend;
    strcat(m_sz, szAppend);

error:
    return hr;
}

DWORD CString::Backup()
{
    DWORD hr = ERROR_GEN_FAILURE;

    if (m_sz && (m_ichNext > 0)) {
        m_sz[m_ichNext-1] = '\0';
        m_ichNext--;
        hr = ERROR_SUCCESS;
    }
    return hr;
}

void CString::Free()
{
    if (m_sz) {
        MemFree(m_sz);
        m_sz = NULL;
    }
    m_ichNext = 0;
    m_cchMax = 0;
}

//+---------------------------------------------------------------------------
// Class:  CStringW
//
// Synopsis: A class that encapsulates a variable size string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CStringW::CStringW()
{
    m_sz = NULL;
    m_ichNext = 0;
    m_cchMax = 0;
}

CStringW::~CStringW()
{
    Free();
}

DWORD CStringW::Init()
{
    Free();
    m_sz = (PWSTR)MemAlloc(STRING_INC * sizeof(WCHAR));
    if (!m_sz) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    m_cchMax = STRING_INC;
    m_ichNext = 0;
    m_sz[0] = '\0';
    return ERROR_SUCCESS;
}

DWORD CStringW::GetCopy(PWSTR *pszReturn)
{
    PWSTR szReturn = NULL;
    szReturn = (PWSTR)MemAlloc((wcslen(m_sz) + 1) * sizeof(WCHAR));
    if (!szReturn) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(szReturn,m_sz,(wcslen(m_sz) + 1) * sizeof(WCHAR));
    *pszReturn = szReturn;
    return ERROR_SUCCESS;
}

PWSTR CStringW::String()
{
    return m_sz;
}


DWORD CStringW::Append(PWSTR szAppend)
{
    DWORD hr = ERROR_SUCCESS;
    PWSTR szT;
    DWORD cchResult;
    DWORD cchAppend;
    
    cchAppend = wcslen(szAppend);
    if ((cchAppend + m_ichNext) > (m_cchMax - 1)) {
        //
        // If normal addition of memory is not enough
        //
        if ((cchAppend + m_ichNext) > (m_cchMax + STRING_INC - 1)) {
            cchResult = m_cchMax + STRING_INC + cchAppend;
        }
        else {
            cchResult = m_cchMax + STRING_INC;
        }
        szT = (PWSTR)MemReallocEx(m_sz, sizeof(WCHAR) * cchResult);
        if (!szT) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_sz = szT;
        m_cchMax = cchResult;
    }
    m_ichNext += cchAppend;
    wcscat(m_sz, szAppend);

error:
    return hr;
}

DWORD CStringW::Backup()
{
    DWORD hr = ERROR_GEN_FAILURE;

    if (m_sz && (m_ichNext > 0)) {
        m_sz[m_ichNext-1] = '\0';
        m_ichNext--;
        hr = ERROR_SUCCESS;
    }
    return hr;
}

void CStringW::Free()
{
    if (m_sz) {
        MemFree(m_sz);
        m_sz = NULL;
    }
    m_ichNext = 0;
    m_cchMax = 0;
}



//+---------------------------------------------------------------------------
// Function:  SubString
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            ERROR_SUCCESS with szOutput = NULL;
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD SubString(LPSTR szInput,
                  LPSTR szFrom,
                  LPSTR szTo,
                  LPSTR *pszOutput)
{
    DWORD hr = ERROR_SUCCESS;
    LPSTR szOutput = NULL;
    LPSTR szLast = NULL;
    LPSTR szReturn = NULL;
    DWORD cchToCopy = 0;            // count of number of char to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    cchFrom    = strlen(szFrom);
    cchTo      = strlen(szTo);
    cchInput   = strlen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = strstr(szInput,
                      szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return ERROR_SUCCESS;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = strstr(szOutput,
                          szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (LPSTR)MemAlloc(sizeof(char) * cchReturn);
    if (!szReturn) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = strstr(szInput,
                      szFrom);
    cchToCopy = (ULONG)(szOutput - szInput);
    strncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    strcat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = strstr(szInput,
                      szFrom);
    while (szOutput) {
        cchToCopy = (ULONG)(szOutput - szInput);
        strncat(szReturn,
                szInput,
                cchToCopy);
        strcat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = strstr(szInput,
                          szFrom);
    }

    strcat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:  GetLine
//
// Synopsis:  will return the new line in the allocated buffer, must be MemFreed
//            by user
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD GetLine(FILE* pFileIn,
                LPSTR *pszLine)
{
    CString String;
    DWORD hr = ERROR_SUCCESS;
    char szValue[256];

    hr = String.Init();
    DIREXG_BAIL_ON_FAILURE(hr);
    
    //
    // First Buffer
    //
    if(fgets(szValue,
             256,
             pFileIn) == NULL) {
        //
        // The new line does not exist, will still return ERROR_SUCCESS 
        // with szLine == NULL
        //
        *pszLine = NULL;
        goto error;
    };

    hr = String.Append(szValue);
    DIREXG_BAIL_ON_FAILURE(hr);

    // 
    // Subsequent buffers
    //
    while ((strlen(szValue) == 255) && szValue[254] != '\n') {
        if(fgets(szValue,
                 256,
                 pFileIn) == NULL) {
            hr = ERROR_GEN_FAILURE;
            DIREXG_BAIL_ON_FAILURE(hr);
        };
        hr = String.Append(szValue);
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // Removing \n
    // fgets always return '\n' as last character
    //
    hr = String.Backup();
    DIREXG_BAIL_ON_FAILURE(hr);

    hr = String.GetCopy(pszLine);
    DIREXG_BAIL_ON_FAILURE(hr);

error:
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:   AppendFile 
//
// Synopsis:   Append fileAppend to fileTarget
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD AppendFile(HANDLE hFileAppend,
                   HANDLE hFileTarget)
{
    DWORD hr = ERROR_SUCCESS;
    char szBuffer[100];
    DWORD cchRead = 0;
    DWORD cchWrite = 0;
    BOOL bResult;

    bResult = ReadFile(hFileAppend,
                       (LPVOID)szBuffer,
                       100,
                       &cchRead,
                       NULL);
    while (bResult && cchRead != 0) {
         if (WriteFile(hFileTarget,
                       (LPCVOID)szBuffer,
                       cchRead,
                       &cchWrite,
                       NULL) == FALSE) {
            hr = ERROR_GEN_FAILURE;
            DIREXG_BAIL_ON_FAILURE(hr);
         }
         bResult = ReadFile(hFileAppend,
                            (LPVOID)szBuffer,
                            100,
                            &cchRead,
                            NULL);
    }
    
    if (!bResult) {
        hr = GetLastError();
    }

error:
    return hr;
}

//+---------------------------------------------------------------------------
// Function:  PrintError  
//
// Synopsis:  Print the error returned from the LDIF engine plus convert it
//            to a win32 error code.
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD PrintError(DWORD dwType, DWORD error) 
{
    DWORD WinError = ERROR_GEN_FAILURE;

    switch(error) {
        case STATUS_ACCESS_VIOLATION:
            SelectivePrintW(dwType,MSG_LDIFDE_EXCEPTION);
            break;
        case LL_MEMORY_ERROR: 
            WinError = ERROR_OUTOFMEMORY;
            SelectivePrintW(dwType,MSG_LDIFDE_MEMERROR);
            break;
        case LL_INIT_REENTER: 
            SelectivePrintW(dwType,MSG_LDIFDE_INITAGAIN);
            break;
        case LL_FILE_ERROR:   
            WinError = ERROR_OPEN_FAILED;
            SelectivePrintW(dwType,MSG_LDIFDE_FILEOPERFAIL);
            break;
        case LL_INIT_NOT_CALLED:   
            SelectivePrintW(dwType,MSG_LDIFDE_INITNOTCALLED);
            break;
        case LL_EOF:          
            SelectivePrintW(dwType,MSG_LDIFDE_ENDOFINPUT);
            break;
        case LL_SYNTAX:
        case LL_MISSING_MOD_SPEC_TERMINATOR:
            SelectivePrintW(dwType,MSG_LDIFDE_SYNTAXERR);
            break;
        case LL_URL:          
            SelectivePrintW(dwType,MSG_LDIFDE_URLERROR);
            break;
        case LL_EXTRA:        
            SelectivePrintW(dwType,MSG_LDIFDE_EXTSPECLIST);
            break;
        case LL_LDAP:         
            SelectivePrintW(dwType,MSG_LDIFDE_LDAPFAILED);
            break;
        case LL_MULTI_TYPE:   
            SelectivePrintW(dwType,MSG_LDIFDE_BOTHSTRBERVAL);  
            break;
        case LL_INTERNAL:
        case LL_INTERNAL_PARSER:
            SelectivePrintW(dwType,MSG_LDIFDE_INTERNALERROR);  
            break;
        case LL_INITFAIL:     
            SelectivePrintW(dwType,MSG_LDIFDE_FAILEDINIT);  
            break;
        case LL_DUPLICATE:    
            SelectivePrintW(dwType,MSG_LDIFDE_MULTIINST);  
            break;
        default:
            SelectivePrintW(dwType,MSG_LDIFDE_UNDEFINED);  
            break;
    }
    return WinError;
}

//+---------------------------------------------------------------------------
// Function:  OutputExtendedErrorByConnection
//
// Synopsis:  This function is called right after an error occurs. Using the
//            pLdap pointer, it will call ldap to retrieve the win32 error
//            code, get the error msg string and output it.
//
//----------------------------------------------------------------------------
void OutputExtendedErrorByConnection(LDAP *pLdap) 
{
    DWORD dwWinError = 0;

    if (GetLdapExtendedError(pLdap, &dwWinError)) {
        OutputExtendedErrorByCode(dwWinError);
    }
}


//+---------------------------------------------------------------------------
// Function:  GetLdapExtendedError
//
// Synopsis:  This function is called right after an error occurs. Using the
//            pLdap pointer, it will call ldap to retrieve the win32 error
//            code.
//
//----------------------------------------------------------------------------
BOOL GetLdapExtendedError(LDAP *pLdap, DWORD *pdwWinError) 
{
    DWORD dwWinError = 0;
    
    if (ldap_get_optionW( pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwWinError) == LDAP_SUCCESS) {
        *pdwWinError = dwWinError;
        return TRUE;
    }
    else {
        return FALSE;
    }
    
}


//+---------------------------------------------------------------------------
// Function:  OutputExtendedErrorByCode
//
// Synopsis:  Given a  win32 error code, get the error msg string
//            and output it.
//
//----------------------------------------------------------------------------
void OutputExtendedErrorByCode(DWORD dwWinError) 
{
    DWORD dwError;
    DWORD dwLen;
    WCHAR szMsg[MAX_PATH];

    if (dwWinError) {
        dwLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwWinError,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              szMsg,
                              MAX_PATH,
                              NULL);
        if (dwLen == 0) {
            _itow(dwWinError, szMsg, 10);
        }
        else {
            //
            // If we get a message, we'll remove all the linefeeds in it
            // and replace it with a space, except the last one.
            // FormatMessage always end with a single \r\n, in that case
            // we'll just copy the rest of the string over, which is a
            // null terminator.
            //
            PWSTR pszNew = szMsg;
            while (pszNew && (pszNew = wcsstr(pszNew,L"\r\n"))) {
                if ((*(pszNew+2))) {
                    wcscpy(pszNew, L" ");                                           
                    wcscpy(pszNew+1, (pszNew + 2));
                }
                else {
                    *pszNew = NULL;
                }
            }
        }

        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_LDIFDE_EXTENDERROR, 
                        szMsg);
    }
}


DWORD
LdapToWinError(
    int     ldaperr
    )
{
    DWORD dwStatus = NO_ERROR;
    DWORD dwErr = NO_ERROR;

    // first set the dwErr, then we can see if we can get
    // more information from ldap_parse_resultW
    switch (ldaperr) {

    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;

    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;

    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;

    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;

    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;

    // LDAP_REFERRAL_V2 has same value as LDAP_PARTIAL_RESULTS
    case LDAP_PARTIAL_RESULTS :
        dwErr = ERROR_MORE_DATA;
        break ;

    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;

    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;

    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;

    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;

    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;

    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;

    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;

    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;

    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;

    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;

    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;

    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;

    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;

    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;

    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;

    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;

    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;

    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;

    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;

    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;

    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;

    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;

    case LDAP_USER_CANCELLED :
       dwErr = ERROR_CANCELLED;
       break;

    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;

    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;

    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;

    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;

    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;

    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;

    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;

    default:
        //
        // It may not be a bad idea to add range checking here
        //
        dwErr = (DWORD) LdapMapErrorToWin32(ldaperr);

    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\base64.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    The base64 funcionality for ldifldap.lib.

DETAILS:
    
    This code is essentially the same as util\base64, except that it uses 
    h* memory allocation funciton which use ldifldap's provate heap.
    
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/
#include <precomp.h>

//-------------------------------------------------------------------------------------------
// Function:     base64decode()
//
// Description:  base-64 decode a string of data. The data must be '\0' terminated.
//
// Arguments:    bufcoded       -pointer to encoded data
//               pcbDecoded     -number of decode bytes
//
// Return Value: Returns pointer to byte blob  is successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PBYTE 
base64decode(
    PWSTR pszBufCoded, 
    long * plDecodedSize
    )
{
    long lBytesDecoded;
    int pr2six[256];
    int i;
    int j=0;
    PWSTR pszCur = pszBufCoded;
    int fDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    PWSTR pszBufIn = NULL;
    PBYTE pbBufOut = NULL;
    PBYTE pbTemp = NULL;    
    PBYTE pbBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=wcslen(pszCur)-1+4;
    *plDecodedSize = lBufSize;

    pbBufDecoded = (PBYTE)MemAlloc_E(lBufSize*sizeof(BYTE));
    if(!pbBufDecoded) {
        hr = E_OUTOFMEMORY;
        BAIL();
    }

        
    lCount=wcslen(pszCur);

    // Do the decoding to new buffer
    pszBufIn = pszCur;
    pbBufOut = pbBufDecoded;

    while(lCount > 0) {
        *(pbBufOut++) = (BYTE) (pr2six[*pszBufIn] << 2 | pr2six[pszBufIn[1]] >> 4);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[1]] << 4 | pr2six[pszBufIn[2]] >> 2);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[2]] << 6 | pr2six[pszBufIn[3]]);
        pszBufIn += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(pbBufOut++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(pbBufOut-pbBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (pszBufIn[-1]=='=') lop_off++;
    if (pszBufIn[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    pbTemp = (PBYTE) MemAlloc_E((*plDecodedSize)*sizeof(BYTE));
    if (!pbTemp) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memcpy(pbTemp, pbBufDecoded, (*plDecodedSize)*sizeof(BYTE));
error:
    if (pbBufDecoded) {
        MemFree(pbBufDecoded);
    }
    return pbTemp; 
}

//
// the map for the encoder, according to RFC 1521
//
WCHAR _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


//-------------------------------------------------------------------------------------------
// Function:     base64encode()
//
// Description:  base-64 encode a string of data
//
// Arguments:    bufin          -pointer to data to encode
//               nbytes         -number of bytes to encode (do not include the trailing '\0'
//                                                               in this measurement if it is a string.)
//
// Return Value: Returns '\0' terminated string if successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    )
{
    PWSTR pszOut = NULL;
    PWSTR pszReturn = NULL;
    long i;
    long OutBufSize;
    PWSTR six2pr = _six2pr64;
    PBYTE pbBufIn = NULL;
    PBYTE pbBuffer = NULL;
    DWORD nPadding;

    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nBytes + ((nBytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nBytes
    //
    pszOut = (PWSTR)MemAlloc_E((OutBufSize + 1)*sizeof(WCHAR));
    pszReturn = pszOut;

    nPadding = 3 - (nBytes % 3);
    if (nPadding == 3) {
        pbBufIn = pbBufInput;
    }
    else {
        pbBuffer = (PBYTE)MemAlloc_E(nBytes + nPadding);
        pbBufIn = pbBuffer;
        memcpy(pbBufIn,pbBufInput,nBytes);
        while (nPadding) {
            pbBufIn[nBytes+nPadding-1] = 0;
            nPadding--;
        }
    }
    

    //
    // Encode everything
    //  
    for (i=0; i<nBytes; i += 3) {
        *(pszOut++) = six2pr[*pbBufIn >> 2];                                     // c1 
        *(pszOut++) = six2pr[((*pbBufIn << 4) & 060) | ((pbBufIn[1] >> 4) & 017)]; // c2
        *(pszOut++) = six2pr[((pbBufIn[1] << 2) & 074) | ((pbBufIn[2] >> 6) & 03)];// c3
        *(pszOut++) = six2pr[pbBufIn[2] & 077];                                  // c4 
        pbBufIn += 3;
    }

    //
    // If nBytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if (i == nBytes+1) {
        // There were only 2 bytes in that last group 
        pszOut[-1] = '=';
    } 
    else if (i == nBytes+2) {
        // There was only 1 byte in that last group 
        pszOut[-1] = '=';
        pszOut[-2] = '=';
    }

    *pszOut = '\0';

    if (pbBuffer) {
        MemFree(pbBuffer);
    }

    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\base64.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.h

ABSTRACT:

    The base64 funcionality for ldifldap.lib.

DETAILS:
    
    It follows the base64 encoding standard of RFC 1521.
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/
#ifndef _BASE_H
#define _BASE_H

PBYTE base64decode(PWSTR bufcoded, long * plDecodedSize);
PWSTR base64encode(PBYTE bufin, long nbytes);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifde\export.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    export.cxx

ABSTRACT:

DETAILS:
    
CREATED:

    09/02/97    Felix Wong (felixw)

REVISION HISTORY:

--*/


#include "ldifde.hxx"
#pragma hdrstop

WCHAR szTempExtraFile[MAX_PATH] = L"";
BOOLEAN bExtraExist = FALSE;
HANDLE hFileExtra = NULL;
DWORD dwWritten;
PWSTR g_szFrom = NULL;
PWSTR g_szTo = NULL;

#define UNICODE_MARK 0xFEFF
//+---------------------------------------------------------------------------
// Function:   DSExport 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD DSExport(LDAP *pLdap, ds_arg *pArg)
{
    DWORD           hr = ERROR_SUCCESS;
    int             search_err;
    LDIF_Error        ll_err;
    LDAPMessage     *res = NULL;
    LDAPMessage     *entry = NULL;
    HANDLE          hFileOut = NULL;
    PLDAPSearch     pSearch = NULL;
    DWORD           cEntriesExported = 0;
    PWSTR           pszRootDN = NULL;
    DWORD           dwFlag = 0;
    BOOL            fPagingAvail = FALSE;
    BOOL            *pfPagingAvail = &fPagingAvail;
    BOOL            fSAMAvail = FALSE;
    PWSTR           *ppszAttrsWithRange = NULL;
    BOOL            fSearchStart = TRUE, fAttrsWithRange = FALSE;
    BOOL            fEntryExported = FALSE;
    
    SelectivePrintW(PRT_STD|PRT_LOG,
                   MSG_LDIFDE_EXPORTING,
                   pArg->szFilename);
    
    SelectivePrintW(PRT_STD|PRT_LOG,
                   MSG_LDIFDE_SEARCHING);

    if (pArg->fSAM) {
        dwFlag |= LL_INIT_BACKLINK;
    }
    if (pArg->szRootDN == NULL) {
        dwFlag |= LL_INIT_NAMINGCONTEXT;
    }
    
    //
    // If paging is off already, we don't need to ask whether paging is 
    // available or not.
    // pfPagingAvail is used to pass into InitExport to get paging status.
    //
    if (!pArg->fPaged) {
        pfPagingAvail = NULL;
    }


    ll_err = LDIF_InitializeExport(pLdap,
                            pArg->omitList,
                            dwFlag,
                            &pszRootDN,
                            pArg->szFromDN,
                            pArg->szToDN,
                            pfPagingAvail,
                            &fSAMAvail);    
    if (ll_err.error_code!=LL_SUCCESS) {
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);      
        
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // If RootDN is NULL, we check if InitExport returns the naming context
    // correctly
    //
    if (pArg->szRootDN == NULL) {
        //
        // Output error message if we failed to get default naming context
        //
        if (pszRootDN == NULL) {
            SelectivePrintW(PRT_STD,
                            MSG_LDIFDE_ROOTDN_NOTAVAIL); 
            /*
            hr = ERROR_INVALID_PARAMETER;
            BAIL();
            */
        }
        else {
        //
        // else use it
        //
            pArg->szRootDN = pszRootDN;
        }
    }

    //
    // If we asked for SAM and it is not available, output error message and
    // turn off SAM logic, but still go on
    // 
    if (pArg->fSAM && (fSAMAvail == FALSE)) {
        SelectivePrintW(PRT_STD,
                        MSG_LDIFDE_SAM_NOTAVAIL); 
        pArg->fSAM = FALSE;
    }

    //
    // If the user requests paging, but it is not available, we'll inform the
    // user and turn off paging
    //
    if (pArg->fPaged) {

        //
        // If user requested paging, we must have passed in a valid entry
        // to initExport to get back status
        //
        ASSERT(pfPagingAvail);

        if (fPagingAvail == FALSE) {
            SelectivePrintW(PRT_STD,
                            MSG_LDIFDE_PAGINGNOTAVAIL); 
            pArg->fPaged = FALSE;
        }
    }

    __try {
        if (pArg->szFromDN) {
            g_szFrom = MemAllocStrW_E(pArg->szFromDN);
        }
        if (pArg->szToDN) {
            g_szTo = MemAllocStrW_E(pArg->szToDN);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);        
    }
    
    do { // keep retrieving results till all values of all multivalued
        // attributes are returned. 

      if (!pArg->fPaged) {

        // ****************
        // NON-PAGED SEARCH
        // ****************
        ULONG msgnum;

        msgnum = ldap_searchW(pLdap, 
                              pArg->szRootDN, 
                              pArg->dwScope, 
                              pArg->szFilter, 
                              ppszAttrsWithRange ? ppszAttrsWithRange:
                                                   pArg->attrList,  
                              0);
                                       
        search_err = LdapResult(pLdap, msgnum, &res);
        
        if ( search_err!= LDAP_SUCCESS ) {
            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_SEARCHERROR, 
                            ldap_err2string(search_err));
            OutputExtendedErrorByConnection(pLdap);
            hr = LdapToWinError(search_err);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if(ppszAttrsWithRange)
        {
            // free any previous attribute names with range values in them

            int i = 0; 

            while(ppszAttrsWithRange[i])
            {
                MemFree(ppszAttrsWithRange[i]);
                i++;
            }

            MemFree(ppszAttrsWithRange);
            ppszAttrsWithRange = NULL;
            fAttrsWithRange = TRUE;
        }
        else
            fAttrsWithRange = FALSE;
   
        if(fSearchStart) // first time through do-while loop
        { 
            if ((hFileOut = CreateFileW(pArg->szGenFile, 
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL | 
                                   FILE_FLAG_SEQUENTIAL_SCAN,
                                   NULL)) == INVALID_HANDLE_VALUE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ERROR_OPENOUTPUT,
                                    hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            if (g_fUnicode) {
                WCHAR wchar = UNICODE_MARK;
                if (WriteFile(hFileOut,
                          &wchar,
                          sizeof(WCHAR),
                          &dwWritten,
                          NULL) == FALSE) {
                    hr = GetLastError();
                    SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_FAILEDWRITETEMP,hr);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }

            //
            // Step through each entry
            //
            SelectivePrintW(PRT_STD|PRT_LOG,
                        MSG_LDIFDE_WRITINGOUT);
            SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
                         L"\n");
            TrackStatus();

            fSearchStart = FALSE;
         } // if(fSearchStart)
         
         for ( entry = ldap_first_entry( pLdap, 
                                         res ); 
               entry != NULL; 
               entry = ldap_next_entry( pLdap, 
                                        entry ) ) { 
             fEntryExported = FALSE;
             hr = ParseEntry(pArg,
                             pLdap,
                             entry,
                             hFileOut,
                             &ppszAttrsWithRange,
                             fAttrsWithRange,
                             &fEntryExported);
             DIREXG_BAIL_ON_FAILURE(hr);
             if(fEntryExported)
                 cEntriesExported++;
         }
                
      }
      else {
        
        // ****************
        // PAGED SEARCH
        // ****************

        pSearch = ldap_search_init_pageW( pLdap,
                                          pArg->szRootDN,
                                          pArg->dwScope, 
                                          pArg->szFilter, 
                                          ppszAttrsWithRange ? ppszAttrsWithRange :
                                                             pArg->attrList,  
                                          FALSE,
                                          NULL,        // server controls
                                          NULL,
                                          0,
                                          20000,
                                          NULL         // sort keys
                                        );
    
        search_err = LDAP_SUCCESS;

        if(ppszAttrsWithRange)
        {
            // free any previous attribute names with range values in them

            int i = 0;

            while(ppszAttrsWithRange[i])
            {
                MemFree(ppszAttrsWithRange[i]);
                i++;
            }

            MemFree(ppszAttrsWithRange);
            ppszAttrsWithRange = NULL;
            fAttrsWithRange = TRUE;
        }
        else
            fAttrsWithRange = FALSE;
    
        if (pSearch == NULL) {
            search_err = LdapGetLastError();
            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_LDIFDE_SEARCHFAILED);
            OutputExtendedErrorByConnection(pLdap);
            hr = LdapToWinError(search_err);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if(fSearchStart)
        {
            if ((hFileOut = CreateFileW(pArg->szGenFile, 
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL |
                                   FILE_FLAG_SEQUENTIAL_SCAN,
                                   NULL)) == INVALID_HANDLE_VALUE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_LDIFDE_ERROR_OPENOUTPUT,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            if (g_fUnicode) {
                WCHAR wchar = UNICODE_MARK;
                if (WriteFile(hFileOut,
                          &wchar,
                          sizeof(WCHAR),
                          &dwWritten,
                          NULL) == FALSE) {
                    hr = GetLastError();
                    SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_FAILEDWRITETEMP,hr);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }
        }
         
        while ((search_err == LDAP_SUCCESS) && (pSearch != NULL)) {
    
            ULONG totalCount;
    
            search_err = ldap_get_next_page_s(  pLdap,
                                                pSearch,
                                                g_pLdapTimeout,
                                                256,
                                                &totalCount,
                                                &res );
    
            if (fSearchStart) {
                SelectivePrintW(PRT_STD|PRT_LOG,
                               MSG_LDIFDE_WRITINGOUT);
                SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
                                L"\n");
                fSearchStart = FALSE;
                g_fDot = TRUE;  // Turn on dots so that a 'new line' char will
                                // be added before printing next statement.
            }

            if (res != NULL) {
    
                ULONG rc;
                PWSTR matchedDNs = NULL;
                PWSTR errors     = NULL;
                PWSTR *referrals  = NULL;
    
                search_err = ldap_parse_result( pLdap,
                                                 res,
                                                 &rc,
                                                 &matchedDNs,
                                                 &errors,
                                                 &referrals,
                                                 NULL,
                                                 FALSE      // don't free it.
                                                );
    
                if (referrals != NULL) {
                    PWSTR *val = referrals;
                    while (*val != NULL) {
                        wprintf(L"%s\n", *val );
                        val++;
                    }
                    ldap_value_free( referrals );
                }
    
                if (errors != NULL) {
                    ldap_memfree( errors );
                }
    
                if (matchedDNs != NULL) {
                    ldap_memfree( matchedDNs );
                }
            
                //
                // Step through each entry
                //
                for ( entry = ldap_first_entry( pLdap, 
                                                 res ); 
                      entry != NULL; 
                      entry = ldap_next_entry( pLdap, 
                                                entry ) ) { 
                    fEntryExported = FALSE;
                    hr = ParseEntry(pArg,
                                    pLdap,
                                    entry,
                                    hFileOut,
                                    &ppszAttrsWithRange,
                                    fAttrsWithRange,
                                    &fEntryExported);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    if(fEntryExported)
                        cEntriesExported++;
                }
            }
            ldap_msgfree(res);
            res = NULL;
        }

        if ((search_err != LDAP_SUCCESS) && (search_err != LDAP_NO_RESULTS_RETURNED)) {
            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_LDIFDE_SEARCHFAILED);
            OutputExtendedErrorByConnection(pLdap);
            hr = LdapToWinError(search_err);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    
      }

    } while(ppszAttrsWithRange);

    if (hFileExtra) {
        CloseHandle(hFileExtra);
        if ((hFileExtra = CreateFile(szTempExtraFile, 
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                                   NULL)) == INVALID_HANDLE_VALUE) {
            hr = GetLastError();
            SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ERROR_OPENTEMP,hr);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        hr = AppendFile(hFileExtra,
                        hFileOut);
        if (hr != 0) {
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_ERRORWRITE,hr);
        }
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    
    if (cEntriesExported == 0) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_NOENTRIES);
    }
    else {
        SelectivePrintW(PRT_STD|PRT_LOG,
                       MSG_LDIFDE_NUMEXPORTED,
                       cEntriesExported);
    }
error:
    if (hFileExtra) {
        CloseHandle(hFileExtra);
    }

    if (pSearch != NULL) {
        ldap_search_abandon_page( pLdap, pSearch );
    }

    if (hFileOut) {
        CloseHandle(hFileOut);
    }

    if (res) {
        ldap_msgfree(res);
    }

    if (pszRootDN) {
        MemFree(pszRootDN);
    }

    if (g_szFrom) {
        MemFree(g_szFrom);
    }

    if (g_szTo) {
        MemFree(g_szTo);
    }

    if(ppszAttrsWithRange)
    {
        // free any previous attribute names with range values in them

        int i = 0;

        while(ppszAttrsWithRange[i])
        {
            MemFree(ppszAttrsWithRange[i]);
            i++;
        }

        MemFree(ppszAttrsWithRange);
        ppszAttrsWithRange = NULL;
    }

#ifndef LEAVE_TEMP_FILES
    if (szTempExtraFile[0]) {
        DeleteFile(szTempExtraFile);
        szTempExtraFile[0] = NULL;
    }
#endif

    LDIF_CleanUp();
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:  ParseEntry  
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD ParseEntry(ds_arg *pArg,
                   LDAP *pLdap,
                   LDAPMessage *entry,
                   HANDLE hFileOut,
                   PWSTR **pppszAttrsWithRange,
                   BOOL fAttrsWithRange,
                   BOOL *pfEntryExported)
{
    LDIF_Error        ll_err;
    DWORD           i;
    DWORD           hr = ERROR_SUCCESS;
    PWSTR           *rgszParsed = NULL;
    PWSTR           szParsedOutput = NULL;
    DWORD           j;
    PWSTR           szReplace = NULL;
    PWSTR           szTemp;

    TrackStatus();
    
    rgszParsed = NULL;
    ll_err = LDIF_GenerateEntry(pLdap, 
                           entry, 
                           (PWSTR**)&rgszParsed, 
                           pArg->fSAM,
                           !pArg->fBinary,
                           pppszAttrsWithRange,
                           fAttrsWithRange);
    if((ll_err.error_code!=LL_SUCCESS)) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_PARSE_FAILED);
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if (ll_err.the_modify != -1) {
        
        //
        // Write out to temporary file
        //
        WCHAR szTempExtraPath[MAX_PATH];

        if (!bExtraExist) {
            bExtraExist = TRUE;
            if (!(GetTempPath(MAX_PATH, szTempExtraPath))) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_LDIFDE_ERROR_CREATETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            
            if (!(GetTempFileName(szTempExtraPath, 
                                  L"ldif", 
                                  0, 
                                  szTempExtraFile))) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_LDIFDE_ERROR_CREATETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            if ((hFileExtra = CreateFile(szTempExtraFile, 
                                       GENERIC_WRITE,
                                       0,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL)) == INVALID_HANDLE_VALUE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_ERROR_OPENOUTPUT,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }

        j = ll_err.the_modify;            
        while(rgszParsed[j]) {
            szReplace = rgszParsed[j];
            DWORD dwSize;
            if (g_fUnicode) {
                dwSize = wcslen(szReplace) * sizeof(WCHAR);             
            }
            else {
                if (UnicodeToAnsiString(szReplace,
                                        (PSTR)szReplace) == 0) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                dwSize = strlen((PSTR)szReplace) * sizeof(CHAR);
            }
            if (WriteFile(hFileExtra,
                           (PBYTE)szReplace,
                           dwSize,
                           &dwWritten,
                           NULL) == FALSE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_FAILEDWRITETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            if (szParsedOutput) {
                MemFree(szParsedOutput);
                szParsedOutput = NULL;
            }
            j++;
        }

        // we will always print a newline here as we are guaranteed that there
        // is at least one linked atribute printed out for this object 
        // if the_modify is != -1.
        DWORD dwSize;
        PBYTE pByte;
        if (g_fUnicode) {
            pByte = (PBYTE)L"\r\n";
            dwSize = 2 * sizeof(WCHAR);             
        }
        else {
            pByte = (PBYTE)"\r\n";
            dwSize = 2 * sizeof(CHAR);              
        }
        if (WriteFile(hFileExtra,
                   (LPCVOID)pByte,
                   dwSize,
                   &dwWritten,
                   NULL) == FALSE) {
            hr = GetLastError();
            SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_FAILEDWRITETEMP,hr);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
   
    if (ll_err.the_modify != -1) {
        j = ll_err.the_modify;
    }
    else {
        j = -1;
    }
    if (rgszParsed) {
        i = 0;            
        // added check for j == 1 below since rgszParsed[0] would contain 
        // "\r\n" if we were dealing only with linked attributes and we don't 
        // want to count this as an entry in the output file. The output for
        // the linked attributes goes into a separate file which gets appended
        // to the output file below. j == 1 would not occur in the normal case
        // as any entry will have at lease two lines - for dn and changetype.
        while(rgszParsed[i] && (i < j) && (j != 1)) {

            szReplace = rgszParsed[i];

            DWORD dwSize;
            if (g_fUnicode) {
                dwSize = wcslen(szReplace) * sizeof(WCHAR);             
            }
            else {
                if (UnicodeToAnsiString(szReplace,
                                        (PSTR)szReplace) == 0) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                dwSize = strlen((PSTR)szReplace) * sizeof(CHAR);
            }
            if (WriteFile(hFileOut,
                           (PBYTE)szReplace,
                           dwSize,
                           &dwWritten,
                           NULL) == FALSE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                         MSG_LDIFDE_FAILEDWRITETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }         
        
            if (szParsedOutput) {
                MemFree(szParsedOutput);
                szParsedOutput = NULL;
            }
            i++;
        }

        // don't double count for objects which are being retrieved for
        // the second time due to an attribute having a range specifier
        if((i != 0) && (FALSE == fAttrsWithRange))
            *pfEntryExported = TRUE;
        else
            *pfEntryExported = FALSE;

        if(rgszParsed[0])
        {
            if (g_fUnicode) {
                rgszParsed[0][wcslen(rgszParsed[0]) - 1] = NULL;
                rgszParsed[0][wcslen(rgszParsed[0]) - 1] = NULL;
                SelectivePrintW(PRT_STD_VERBOSEONLY|PRT_LOG,
                            MSG_LDIFDE_EXPORT_ENTRY,
                            rgszParsed[0]+4);
            }
            else {
                ((PSTR)rgszParsed[0])[strlen((PSTR)rgszParsed[0]) - 1] = NULL;
                ((PSTR)rgszParsed[0])[strlen((PSTR)rgszParsed[0]) - 1] = NULL;
                szTemp = AllocateUnicodeString(((PSTR)rgszParsed[0])+4);
                if (szTemp) {
                    SelectivePrintW(PRT_STD_VERBOSEONLY|PRT_LOG,
                               MSG_LDIFDE_EXPORT_ENTRY,
                               szTemp);
                    MemFree(szTemp);
                }

            }
        }
        LDIF_FreeStrs(rgszParsed);
        rgszParsed = NULL;
    }
     
    // if something was printed out to hFileOut, print out a newline too.
    // Nothing may be printed if LDAP only returns teh DN of an object and 
    // does not return any of its attributes (which may happen if the object
    // does not have the specified attribute).  
    if(*pfEntryExported)
    { 
        DWORD dwSize;
        PBYTE pByte;

        if (g_fUnicode) {
            pByte = (PBYTE)L"\r\n";
            dwSize = 2 * sizeof(WCHAR);             
        }
        else {
            pByte = (PBYTE)"\r\n";
            dwSize = 2 * sizeof(CHAR);              
        }
        if (WriteFile(hFileOut,
                  (LPCVOID)pByte,
                  dwSize,
                  &dwWritten,
                  NULL) == FALSE) {
            hr = GetLastError();
            SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_FAILEDWRITETEMP,hr);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

error:
    if (rgszParsed) {
        LDIF_FreeStrs(rgszParsed);
    }
    if (szParsedOutput) {
        MemFree(szParsedOutput);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\globals.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    This file contains global variables

Environment:

    User mode

Revision History:

    04/30/98 -felixw-
        Created it

--*/
#include <precomp.h>
#include "ntldap.h"

//
// Variables for status information
//
int Mode        = C_NORMAL; // The current lexing mode
WCHAR cLast;                 // Last Character before error occurred
BOOL fEOF       = FALSE;    // Whether the end of file has been reached
BOOL fNewLine   = TRUE;     // Used to tell whether we are just after a NewLine.
                            // It is used only in the CLEAR mode.
PWSTR g_pszLastToken = NULL;


//
// Variables for the line-counting
//
long LineClear       = 0;          // for initial line counting
long Line            = 0;          // for while-processing countint
long LineGhosts      = 0;
long *rgLineMap      = NULL;
long cLineMax;

int FileType;       // making sure that the input file is just either LDIF-recs 
                    // or LDIF-c-recs

int RuleLast;       // The last lower level rule parsed successfully
int TokenExpect;    // The token the grammar expects to see next               
int RuleLastBig;    // The last rule the grammar parsed successfully codes 
int RuleExpect;     // The rule the grammar expects to see next

//
// An a ldif-record (or only the DN for a changes list will be recorded here)
//
LDIF_Object g_pObject;
WCHAR       g_szTempUrlfilename[MAX_PATH] = L"";
FILE        *g_pFileUrlTemp          =  NULL;
BOOLEAN     g_fUnicode               = FALSE;   // whether we are using UNICODE or not

DWORD g_dwBeginLine = 0;

// Search control for lazy commit
LDAPControlW g_wLazyCommitControl = { LDAP_SERVER_LAZY_COMMIT_OID_W,
                                      {0, NULL},
                                      FALSE 
                                    };

PLDAPControlW g_ppwLazyCommitControl[] = { &g_wLazyCommitControl, NULL };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\globals.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This file contains global variables extern declarations

Environment:

    User mode

Revision History:

    04/30/99 -felixw-
        Created it

--*/
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

//
// Global variables
//

//
// Variables for status information
//
extern int Mode;                    // The current lexing mode
extern WCHAR cLast;                  // Last Character before error occurred
extern BOOL fEOF;                   // Whether the end of file has been reached
extern BOOL fNewLine;               // Used to tell whether we are just after a NewLine.
                                    // It is used only in the CLEAR mode.

//
// Variables for the line-counting
//
extern long LineClear;              // for initial rgLineMap
extern long Line;                   // for while-processing countint
extern long LineGhosts;
extern long *rgLineMap;
extern long cLineMax;

extern int FileType; // making sure that the input file is just either 
                     // LDIF-recs or LDIF-c-recs

//
// Information for the user on error
//
extern int RuleLast;       // The last lower level rule parsed successfully
extern int TokenExpect;    // The token the grammar expects to see next               
extern int RuleLastBig;    // The last rule the grammar parsed successfully codes 
extern int RuleExpect;     // The rule the grammar expects to see next

//
// An a ldif-record (or only the DN for a changes list will be recorded here)
//
extern LDIF_Object  g_pObject;
extern WCHAR        g_szTempUrlfilename[MAX_PATH];
extern FILE         *g_pFileUrlTemp;
extern PWSTR g_pszLastToken;

extern DWORD g_dwBeginLine;

extern LDAPControlW g_wLazyCommitControl;
extern PLDAPControlW g_ppwLazyCommitControl[];

#endif  // ifndef _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifde\import.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    import.cxx

Abstract:
    
    Import operations of LDIF

Author:

    Felix Wong [FelixW]    22-Jul-1997
    
++*/

#include "ldifde.hxx"

//
// Multithreaded support structures
//

// the records that will be stored on the queues
#define QUEUE_ENTRIES 256
LdifRecordQueue g_LdifEntries[QUEUE_ENTRIES];

// FreeQueue
//   empty records, available for use
//   (only one thread ever accesses this list, so not
//    crit-sect protected)
LIST_ENTRY g_LFreeEntry;

// ParsedQueue
//   parsed records, waiting to send to server
LIST_ENTRY g_LParseList;
CRITICAL_SECTION g_csParseList;

// SentQueue
//   sent records, awaiting recycling to the FreeQueue
LIST_ENTRY g_LSentList; 
CRITICAL_SECTION g_csSentList;

// if the queue critical sections have been initialized
BOOL g_fSentListCritSectInitialized = FALSE;
BOOL g_fParseListCritSectInitialized = FALSE;

DWORD g_EofReached = 0; // has the parser reached the end of the LDIF file?
DWORD g_SentAllFileItems = 0;  // have all entries been sent?
LONG  g_cAdded = 0;     // count of the number of entries successfully added



void
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *ppszUnicode,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    PWSTR pszUnicode = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the Unicode String
    //
    pszUnicode = (PWSTR)MemAlloc_E((dwLen + 1) * sizeof(WCHAR));

    nReturn = LdapUTF8ToUnicode((PSTR)pVal,
                                dwLen,
                                pszUnicode,
                                dwLen + 1);

    //
    // NULL terminate it
    //

    pszUnicode[nReturn] = '\0';

    *ppszUnicode = pszUnicode;
    *pdwLen = (nReturn + 1);//* sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
// Function:    DSImport
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DWORD
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD DSImport(LDAP **pLdap, ds_arg *pArg)
{
    DWORD hr = ERROR_SUCCESS;
    DWORD hrWorker = ERROR_SUCCESS;     // overall worker thread exit code
    DWORD dwThreadCode = ERROR_SUCCESS; // worker thread exit code
    LDIF_Error    ll_err;
    LDIF_Record   *recReturned;
    BOOL        bEndOfFile = FALSE;
    DWORD       cLine = 0;
    DWORD       cLineReturn = 0;

    BOOL fLazyCommitAvail = TRUE;
    LdifRecordQueue *pRecEnt=NULL;
    BOOL fInitializedQueues = FALSE;
    BOOL fStartedThreads = FALSE;
    BOOL fErrorDuringParse = FALSE;
    
    tParameter LDIFParameter[MAX_LDAP_CONCURRENT];
    HANDLE LDAPSendThreadHandle[MAX_LDAP_CONCURRENT];
    DWORD ThreadId;
    DWORD dwNumThreads = 0;

    
    SelectivePrintW(PRT_STD|PRT_LOG,
                    MSG_LDIFDE_IMPORTDIR,
                    pArg->szFilename);
    ll_err = LDIF_InitializeImport(pLdap[0],
                                   pArg->szFilename,
                                   pArg->szFromDN,
                                   pArg->szToDN,
                                   &fLazyCommitAvail);
                                   
    if (ll_err.error_code!=LL_SUCCESS) {
        SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_LDIFDE_ERR_INIT);
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // If we asked for lazy commit and it is not available, output error message and
    // turn off lazy commit, but still go on
    // 
    if (pArg->fLazyCommit && (fLazyCommitAvail == FALSE)) {
        SelectivePrintW(PRT_STD,
                        MSG_LDIFDE_LAZYCOMMIT_NOTAVAIL); 
        pArg->fLazyCommit = FALSE;
    }

    //
    // init the MT part
    //
    DWORD rc = InitLDIFDEMT();
    DIREXG_BAIL_ON_FAILURE(HRESULT_FROM_WIN32(rc));
    fInitializedQueues = TRUE;

    //
    // Call LDAP Send Threads
    //
    dwNumThreads = pArg->dwLDAPConcurrent;

    for (int i = 0; i < (int)pArg->dwLDAPConcurrent; i++) {
        LDIFParameter[i].pLdap=pLdap[i];
        LDIFParameter[i].pArg=pArg;
        LDIFParameter[i].dwThreadNum = i;

        LDAPSendThreadHandle[i] =
            CreateThread(
                NULL,       // default security
                0,          // default stack size
                (LPTHREAD_START_ROUTINE)LDIF_LoadRecordThread,
                (LPVOID)&LDIFParameter[i],          // parameter
                0,          // creation flag, no suspend
                &ThreadId );

        if( LDAPSendThreadHandle[i]  == NULL ) {
            hr = GetLastError();
            // print message on fail threadstart
            if (i==0) {
                //
                // Couldn't start any threads, give up
                //
                SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                 MSG_LDIFDE_THREADFAIL);            
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                //
                // failed to start this thread 
                // continue with whatever threads we
                // have so far
                //
                SelectivePrintW( PRT_STD|PRT_LOG,
                                 MSG_LDIFDE_THREADFAIL_SOME,
                                 i);            
                dwNumThreads = i;
                hr = ERROR_SUCCESS;
                break;	    
            }
        } 
    }

    fStartedThreads = TRUE;

    SelectivePrintW( PRT_STD|PRT_LOG,
                    MSG_LDIFDE_LOADING);
    SelectivePrint2W( PRT_STD_VERBOSEONLY|PRT_LOG,
                    L"\n");    
    TrackStatus();
    //
    // Parsing
    //
    while(!bEndOfFile && !g_SentAllFileItems) {
        
        if (!FreeQueueGetEntry(&pRecEnt)){
            // could not get the entry
            // Lets free some from the process list
            SentQueueFreeAllEntries();

            // now get another one
            if (!FreeQueueGetEntry(&pRecEnt)){
                //if none can be freed wait and try again later
                Sleep(1);
                continue;	      
            }
        }

        recReturned = &pRecEnt->i_record;

        memset(recReturned, 0, sizeof(LDIF_Record));

        ll_err = LDIF_Parse(recReturned);
        
        if((ll_err.error_code!=LL_SUCCESS)&&(ll_err.error_code!=LL_EOF)) {
            //
            // We'll narrow down the error and display the appropriate
            // message in the cleanup code.
            //
            fErrorDuringParse = TRUE;

            hr = ERROR_GEN_FAILURE;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        cLineReturn = ll_err.line_begin;
        cLine++;
        	
        pRecEnt->dwLineNumber = cLineReturn;
        pRecEnt->dwRecordIndex = cLine;

        //
        // Important: Adding the entry must be done BEFORE setting the
        // EOF flag.  In the worker thread, we'll test them in the reverse
        // order, thereby guaranteeing that if we read the EOF flag as true,
        // the parse thread will have completed adding any entries to the
        // parse queue.  Otherwise, we may read the flag as true when not
        // all entries have yet been added to the parsed queue, see that the
        // queue is empty, and terminate prematurely.
        //
        ParsedQueueAddEntry(pRecEnt);

        //
        // Checking EOF
        //
        if (ll_err.error_code==LL_EOF) {
            bEndOfFile = TRUE;
            InterlockedExchange((LONG*)&g_EofReached, 1);
        }

    }
    // end of parsing
    
error:

    if (fStartedThreads) {
    
        //
        // wait for sending threads to finish
        //
        InterlockedExchange((LONG*)&g_EofReached, 1);  // signal we're done, if we haven't already

        //if (fErrorDuringParse) {
        //    // error occurred in parser thread -> force immediate shutdown
        //    // of worker threads (don't wait for them to empty their queues)
        //    InterlockedIncrement((long *)&g_SentAllFileItems);
        //}
        
        WaitForMultipleObjects(dwNumThreads,
                               LDAPSendThreadHandle, 
                               TRUE,    // wait for all to terminate
                               INFINITE);
        for (i = 0; i < (int)dwNumThreads; i++) {

            //
            // Need to find out if the thread exited with an error
            // and, if so, preserve that error code so we can return it
            //
            if (GetExitCodeThread(LDAPSendThreadHandle[i], &dwThreadCode)) {
                if (dwThreadCode != ERROR_SUCCESS) {
                    hrWorker = dwThreadCode;
                }
            }
        
    	    CloseHandle(LDAPSendThreadHandle[i]);
        }
    }

    //
    // Now we cleanup and display any errors.
    // First, we display the results of the worker threads
    //  (this is done inside SentQueueFreeAllEntries)
    // Second, we display the parse error, if any.
    // Finally, we display the overall count of entries
    // modified successfull.
    //
    if (fInitializedQueues) {
        ParsedQueueFreeAllEntries();
        SentQueueFreeAllEntries();
    }

    if (fErrorDuringParse) {
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);
        if (ll_err.szTokenLast) {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                             MSG_LDIFDE_FAILLINETOKEN,
                             ll_err.line_number,
                             ll_err.szTokenLast); 
        }
        else {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_FAILLINE,
                            ll_err.line_number,
                            ll_err.token_start); 
        }
#if DBG
        if (ll_err.error_code == LL_SYNTAX || ll_err.error_code == LL_MISSING_MOD_SPEC_TERMINATOR) {
            ClarifyErr(&ll_err);
        }
#endif
        if (ll_err.error_code == LL_MISSING_MOD_SPEC_TERMINATOR) {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_MISSING_MOD_SPEC_TERMINATOR);
        }
    }

    if (g_cAdded == 1) {
        SelectivePrintW( PRT_STD|PRT_LOG,
                        MSG_LDIFDE_MODENTRYSUC_1);
    }
    else {
        SelectivePrintW( PRT_STD|PRT_LOG,
                        MSG_LDIFDE_MODENTRYSUC,
                        g_cAdded);
    }
    
    LDIF_CleanUp();
    CleanupLDIFDEMT();
    
    if (ll_err.szTokenLast) {
        MemFree(ll_err.szTokenLast);
    }

    //
    // We want to return the parse error if there was one, otherwise,
    // the worker thread error code (which will still be ERROR_SUCCESS
    // if no worker thread experienced an error)
    //
    return ( (hr != ERROR_SUCCESS) ? hr : hrWorker);
}


//+---------------------------------------------------------------------------
// Function:   PrintRecord 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void PrintRecord(LDIF_Record *IpLLrec, DWORD dwType) {
    struct change_list  *c_current;
    
    if (IpLLrec->fIsChangeRecord==FALSE) {    
        SelectivePrint2W(dwType,L"\ndn: %s\n",IpLLrec->dn);
        PrintMod(IpLLrec->content, dwType);
    } else if (IpLLrec->fIsChangeRecord==TRUE) {
        SelectivePrint2W(dwType,L"Entry DN: %s\n", IpLLrec->dn);
        c_current=IpLLrec->changes;
        while(c_current!=NULL) {
            switch(c_current->operation) {
                case CHANGE_ADD:  
                    SelectivePrint2W(dwType,L"changetype: add\n");
                    PrintMod(c_current->mods_mem, dwType);
                    break;
                
                case CHANGE_DEL:
                    SelectivePrint2W(dwType,L"changetype: delete\n");
                    break;
                
                case CHANGE_DN:
                    SelectivePrint2W(dwType,L"changetype: dn\n");
                    SelectivePrint2W(dwType,L"Renaming to %s with deleteold of %d\n",
                                    c_current->dn_mem,
                                    c_current->deleteold);
                    break;
                case CHANGE_MOD:
                    SelectivePrint2W(dwType,L"changetype: modify\n");
                    PrintMod(c_current->mods_mem, dwType); 
                    break;
            } 
            c_current=c_current->next;
        } 
    } 
}


//+---------------------------------------------------------------------------
// Function:    PrintMod
//
// Synopsis:    Print out the values in the LDAP MOD structure
//
// Arguments:   LDAPMod **pMod
//
// Returns:     DWORD
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD
PrintMod(LDAPModW **ppMod, DWORD dwType)
{
    DWORD        cAttribute = 0;
    PWSTR        *string_array;
    struct       berval **ber_array;
   
    if (!ppMod) {
        return ERROR_INVALID_PARAMETER;
    }
    
    while(*ppMod) {
        PLDAPModW_Ext pModExt = (PLDAPModW_Ext )(*ppMod);
        if (!pModExt->fString) {
            
            //
            // BVALUE
            //
            SelectivePrint2W(dwType,
                             L"Attribute %d) %s:",
                             cAttribute,
                             (*ppMod)->mod_type); 
            
            ber_array=(*ppMod)->mod_bvalues;
            if (ber_array) {
                while (*ber_array) {
                    SelectivePrint2W(dwType,
                                    L" UNPRINTABLE BINARY(%d)",
                                    (*ber_array)->bv_len);
                    ber_array++;
                }
            }
            SelectivePrint2W(dwType,
                            L"\n");
        } else {
            
            //
            // STRING
            //
            SelectivePrint2W(dwType,
                             L"Attribute %d) %s:",
                             cAttribute,
                             (*ppMod)->mod_type); 
            
            //
            // string is always UTF-8 --- we always read it in as Unicode, then
            // in GenereateModFromAttr we convert it to UTF-8, so by this time
            // it's UTF-8 no matter whether the source file was Unicode or not
            //
            ber_array=(*ppMod)->mod_bvalues;
            if (ber_array) {
                while (*ber_array) {
                    PSTR szString;
                    PWSTR pszUnicode;
                    DWORD dwLen;

                    __try {
                        ConvertUTF8ToUnicode(
                            (unsigned char*)(*ber_array)->bv_val,
                            (*ber_array)->bv_len,
                            &pszUnicode,
                            &dwLen
                            );
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    
                    /*
                    szString = (PSTR)MemAlloc_E(((*ber_array)->bv_len)+1);
                    memcpy(szString,(*ber_array)->bv_val,(*ber_array)->bv_len);
                    szString[(*ber_array)->bv_len] = NULL;
                    */
                    SelectivePrint2W(dwType,
                                    L"%s",
                                    pszUnicode);
                    ber_array++;
                    if (*ber_array)
                        SelectivePrint2W(dwType, L" ");
                    //MemFree(szString);
                    MemFree(pszUnicode);
                }
            }
            
            SelectivePrint2W(dwType,
                           L"\n");
        }   
        
        ppMod++;
        cAttribute++;
    }
    SelectivePrint2W(dwType,
                   L"\n");
    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
// Function:   ClarifyErr 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void ClarifyErr(
    LDIF_Error* err
    ) 
{

    int RuleLastBig  = err->RuleLastBig;
    int lastsmall    = err->RuleLast;
    int RuleExpect   = err->RuleExpect;
    int expecttoken  =err->TokenExpect;
    
    //If there is an error in a wrapped line, it will be reported as the last 
    //line of the wrapped value in the original file. Please note that the token 
    //start indicates the point AT which or AFTER which the error occurred. The 
    //info below indicates the LAST correct rule and what was expected thereafter. 
    //Sometimes one of these pieces of info may be slightly grammatically ahead
    //of the other. However, a good knoweldge of the LDIF grammar, and these
    //two pieces of info should be more than enough to indicate the error. The 
    //error will be AT or AFTER the further one. It will also be AT OR BEFORE 
    //the indicated linenumber.
    
    wprintf(L"Last major rule: ");
    switch(RuleLastBig) {
        case R_VERSION:   wprintf(L"version-spec\n");
                          break;
        case R_REC:       wprintf(L"ldif-attrval-record\n");
                          break;
        case R_CHANGE:    wprintf(L"ldif-change-record\n");  
                          break;           
        case R_DN:        wprintf(L"dn-spec\n");
                          break;
        case R_AVS:       wprintf(L"attrval-spec.\n");
                          break;
        case R_C_ADD:     wprintf(L"change-add\n");
                          break;
        case R_C_DEL:     wprintf(L"change-delete\n");
                          break;
        case R_C_DN:      wprintf(L"change-moddn\n");
                          break;
        case R_C_NEWSUP:  wprintf(L"change-moddn + newsuperior\n");
                          break;
        case R_C_MOD:     wprintf(L"change-modify\n");
                          break;
        case R_C_MODSPEC: wprintf(L"mod-spec\n");
                          break;
        
    }

    wprintf(L"Last minor rule: ");
    switch(lastsmall) {
        case RS_VERNUM:     wprintf(L"version-number\n");
                            break;
        case RS_ATTRNAME:   wprintf(L"attrname:\n");
                            break;
        case RS_ATTRNAMENC: wprintf(L"attrname\n");
                            break;
        case RS_DND:        wprintf(L"dn::\n");
                            break;
        case RS_DN:         wprintf(L"dn:\n");
                            break;
        case RS_DIGITS:     wprintf(L"DIGITs\n");
                            break;
        case RS_VERSION:    wprintf(L"version:\n");
                            break;
        case RS_BASE64:     wprintf(L"base64 value\n");
                            break;
        case RS_SAFE:       wprintf(L"safe value\n");
                            break;
        case RS_DC:         wprintf(L"::\n"); 
                            break;
        case RS_URLC:       wprintf(L":<\n");
                            break;
        case RS_C:          wprintf(L":\n");
                            break;
        case RS_MDN:        wprintf(L"moddn | modrdn\n");
                            break;
        case RS_NRDNC:      wprintf(L"newrdn:\n");
                            break;
        case RS_NRDNDC:     wprintf(L"newrdn::\n"); 
                            break;
        case RS_DORDN:      wprintf(L"deleteoldrdn:\n");
                            break;
        case RS_NEWSUP:     wprintf(L"newsuperior:\n");
                            break;
        case RS_NEWSUPD:    wprintf(L"newsuperior::\n");
                            break;
        case RS_DELETEC:    wprintf(L"delete:\n");
                            break;
        case RS_ADDC:       wprintf(L"add:\n");
                            break;
        case RS_REPLACEC:   wprintf(L"replace:\n");
                            break;
        case RS_CHANGET:    wprintf(L"changetype:\n");
                            break;
        case RS_C_ADD:      wprintf(L"add\n");
                            break;
        case RS_C_DELETE:   wprintf(L"delete\n");
                            break;
        case RS_MINUS:      wprintf(L"-\n");
                            break;
        case RS_C_MODIFY:   wprintf(L"modify\n");
                            break;
    }

    wprintf(L"Expecting rule: ");
    switch(RuleExpect) {
        case RE_REC_OR_CHANGE:  wprintf(L"ldif-attrval-record | ldif-change-record\n");
                                break;
        case RE_REC:            wprintf(L"ldif-attrval-record\n");
                                break;
        case RE_CHANGE:         wprintf(L"ldif-change-record\n");
                                break;
        case RE_ENTRY:          wprintf(L"attrval-spec | changerecord\n");
                                break;
        case RE_AVS_OR_END:     wprintf(L"attrval-spec | end of list.\n");
                                break;
        case RE_CH_OR_NEXT:     wprintf(L"changetype: * | end of entry\n");
                                break;
        case RE_MODSPEC_END:    wprintf(L"mod-spec | end of entry\n");
                                break;
    }   

    wprintf(L"Expecting token: ");
    switch(expecttoken) {
        case RT_DN:              wprintf(L"dn: | dn::\n");
                                 break;
        case RT_ATTR_OR_CHANGE:  wprintf(L"attrname | changetype:\n");
                                 break;
        case RT_ATTR_MIN_SEP:    wprintf(L"attrname (:|::|:<) | '2+ separators'\n");
                                 break;
        case RT_CH_OR_SEP:       wprintf(L"changetype | separator\n");
                                 break;
        case RT_MODBEG_SEP:      wprintf(L"add: | delete: | replace: | separator\n");
                                 break;   
        case RT_C_VALUE:         wprintf(L": value | :: value\n");
                                 break;
        case RT_ATTRNAME:        wprintf(L"attrname:\n");
                                 break;
        case RT_VALUE:           wprintf(L"safe value\n");
                                 break;
        case RT_MANY:            wprintf(L"undetermined\n");
                                 break;
        case RT_DIGITS:          wprintf(L"DIGIT\n");
                                 break;
        case RT_BASE64:          wprintf(L"BASE64 Vvalue\n");
                                 break;
        case RT_URL:             wprintf(L"URL\n");
                                 break;
        case RT_NDN:             wprintf(L"newrdn: | newrdn::\n");
                                 break;
        case RT_ATTRNAMENC:      wprintf(L"attrname\n");
                                 break;
        case RT_ADM:             wprintf(L"add | delete | modify\n");
                                 break;
        case RT_ACDCRC:          wprintf(L"add: | delete: | replace:\n");
                                 break;
    }
}

/*
*   Threads to load records thread  
*/
DWORD LDIF_LoadRecordThread (LPVOID Parameter){

    tParameter *t = (tParameter *) Parameter;
    LDIF_Record   *recReturned;
    LDAP *pLdap = t->pLdap;
    ds_arg *pArg = t->pArg;
    LDIF_Error    ll_err;
    LdifRecordQueue *pRecord=NULL;
    DWORD hr = ERROR_SUCCESS;
    DWORD cLineReturn, cLine;

    BOOL fGotRecord = FALSE;
    BOOL fEOF = FALSE;

    while(!g_SentAllFileItems){

        // Get Element from queue
        // Important: Reading the entry must be done AFTER reading the
        // EOF flag.  In the parser thread, we set them in the reverse
        // order, thereby guaranteeing that if we read the EOF flag as true,
        // the parse thread will have completed adding any entries to the
        // parse queue.  Otherwise, we may read the flag as true when not
        // all entries have yet been added to the parsed queue, see that the
        // queue is empty, and terminate prematurely.

        fEOF = g_EofReached;
        fGotRecord = ParsedQueueGetEntry(&pRecord);

        if (!fGotRecord) {
            // this happens once at startup
            if(fEOF) {
                //
                // no more entries in parsed queue and we reached
                // EOF --> nothing more to do, all entries have been
                // sent
                //
                InterlockedIncrement((long *)&g_SentAllFileItems);
                return (hr);
            }
            else {
                //
                // Can happen if we ever run out of entries in the queue
                // while there are more to go in the file.  The parser thread
                // will notice this and start stuffing more entries into
                // the queue, eventually.
                //
                Sleep(1);

                //try again
                continue; 
            }
        }

    	recReturned = &pRecord->i_record;
        cLineReturn = pRecord->dwLineNumber;
        cLine = pRecord->dwRecordIndex;

        //
        // Loading
        //
        ll_err = LDIF_LoadRecord(pLdap, 
                                 recReturned, 
                                 pArg->fActive,
                                 pArg->fLazyCommit,
                                 FALSE);

        //
        // Fill in the results of the import
        //
        pRecord->dwError = ll_err.error_code;
        pRecord->dwLdapError = ll_err.ldap_err;
        pRecord->dwLdapExtError = ERROR_SUCCESS;
        pRecord->fSkipExist = pArg->fSkipExist;

        //
        // Determine whether an error occurred and if we
        // need to abort (actual logging/reporting of the
        // error will be handled separately, once the record
        // is on the sent queue).
        //
        if((ll_err.error_code!=LL_SUCCESS)) {
                        
            if (ll_err.error_code == LL_LDAP) {
                if (pArg->fSkipExist && ll_err.ldap_err == LDAP_OTHER) {
                    DWORD dwWinError = ERROR_SUCCESS;
                    BOOL fError = GetLdapExtendedError(pLdap, &dwWinError);
                                                      
                    pRecord->dwLdapExtError = dwWinError;
                    
                    if ((fError) || (dwWinError != ERROR_MEMBER_IN_ALIAS)) {

                        //
                        // Unignorable errors -> program termination
                        //

                        hr = LdapToWinError(ll_err.ldap_err);
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                } 
                //
                // If skip is on, and if we get objectclass violation, it means
                // the objectclass does not exist. We then check the item 
                // actually has no attributes, we'll ignore that if it's the 
                // case
                //
                else if (pArg->fSkipExist && 
                         (ll_err.ldap_err == LDAP_OBJECT_CLASS_VIOLATION) &&
                         recReturned->fIsChangeRecord && 
                         (recReturned->changes->mods_mem && (*(recReturned->changes->mods_mem) == NULL))) {
                    //
                    // Error that can be ignored
                    //
                }
                else if (pArg->fSkipExist && 
                        (ll_err.ldap_err == LDAP_ALREADY_EXISTS || 
                         ll_err.ldap_err == LDAP_CONSTRAINT_VIOLATION ||
                         ll_err.ldap_err == LDAP_ATTRIBUTE_OR_VALUE_EXISTS ||
                         ll_err.ldap_err == LDAP_NO_SUCH_OBJECT)) {
                    //
                    // Error that can be ignored
                    //
                }
                else {
                    //
                    // Unignorable errors -> program termination
                    //
                    hr = LdapToWinError(ll_err.ldap_err);
                    GetLdapExtendedError(pLdap, &(pRecord->dwLdapExtError));
                    DIREXG_BAIL_ON_FAILURE(hr);
                }                
            }
            else {
                //
                // Unignorable errors -> program termination
                //
                hr = ll_err.error_code;
                DIREXG_BAIL_ON_FAILURE(hr);
            }

        }
        else {
            //
            // SUCCESS
            //
            InterlockedIncrement(&g_cAdded);
        }
        
        //
        //load proccesed record into Sent Queue
        //
        SentQueueAddEntry(pRecord);
        pRecord = NULL;

        TrackStatus();

    }
    
error: 

    //
    // If record has not been added to the sent queue yet,
    // do so now.  This way, the logging code will be
    // able to pull the record from the sent queue and
    // log the error that occurred.
    //
    if (pRecord != NULL) {
        SentQueueAddEntry(pRecord);
        pRecord = NULL;
    }

    //
    // if we hit an error, we set this flag which will
    // make it look like we completed loading all entries
    // and terminate the process
    //
    InterlockedIncrement((long *)&g_SentAllFileItems);

    return (hr);
}


//
// Compute a spin count to be used for the queue critical sections
//
DWORD
ComputeCritSectSpinCount(LPSYSTEM_INFO psysInfo, DWORD dwSpin)
{
    if(psysInfo->dwNumberOfProcessors > 1)
    {
        return(dwSpin +
               (((psysInfo->dwNumberOfProcessors - 2) * dwSpin) / 10));
    }
    return(0);
}


//
// Cleanup structures used for multi-threaded operation
//
void
CleanupLDIFDEMT()
{
    if (g_fSentListCritSectInitialized)
        DeleteCriticalSection(&g_csSentList);

    if (g_fParseListCritSectInitialized)
        DeleteCriticalSection(&g_csParseList);
}


//
// Initialize structures for multi-threaded operation
//
DWORD 
InitLDIFDEMT()
{

    int i;
    SYSTEM_INFO psysInfo;
    DWORD dwSpinCount;

    //
    // Initialize the critical sections that protect the queues
    //
    GetSystemInfo(&psysInfo);

    dwSpinCount = ComputeCritSectSpinCount(&psysInfo, (DWORD)500);

    if(dwSpinCount)
    {
        if (InitializeCriticalSectionAndSpinCount( &g_csSentList, dwSpinCount ))
        {
            g_fSentListCritSectInitialized = TRUE;
            if (InitializeCriticalSectionAndSpinCount( &g_csParseList, dwSpinCount ))
            {
                g_fParseListCritSectInitialized = TRUE;
            }
        }
    }
    else
    {
        InitializeCriticalSection(&g_csSentList);
        g_fSentListCritSectInitialized = TRUE;
        InitializeCriticalSection(&g_csParseList);
        g_fParseListCritSectInitialized = TRUE;
    }

    if (!g_fSentListCritSectInitialized || !g_fParseListCritSectInitialized)
    {
        return GetLastError();
    }
    
    //
    // Initialize the queue records
    //
    memset (g_LdifEntries,0,sizeof(LdifRecordQueue) * QUEUE_ENTRIES);

    //
    // Initialize the queues themselves
    //
    InitializeListHead(&g_LFreeEntry);
    InitializeListHead(&g_LParseList);
    InitializeListHead(&g_LSentList);


    //
    // Load the FreeQueue with the queue records
    //
    for ( i = 0; i< (int)(QUEUE_ENTRIES) ; i++) {
        InitializeListHead(&g_LdifEntries[i].pqueue);
        InsertTailList( &g_LFreeEntry, &g_LdifEntries[i].pqueue );
    }

    // Global Status Vars

    g_EofReached = 0 ;
    g_SentAllFileItems =0;


    return 0;
}


//+---------------------------------------------------------------------------
// Function:   FreeQueueGetEntry 
//
// Synopsis:   Retrieves an empty record from the FreeQueue, if
//             one is available   
//
// Arguments:  pEnt - on return, set to ptr to retrieved record
//
// Returns:    TRUE if it retrieved a empty record, FALSE otherwise 
//
// Modifies:   g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
BOOL 
FreeQueueGetEntry(PLdifRecordQueue *pEnt)
{
    int i;

    //
    // try 3 times
    //
    for ( i = 0; i<3; i++) {

        if( !IsListEmpty( &g_LFreeEntry ) ) {
            //
            // Take element from free list
            //
            *pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LFreeEntry );
          
            return TRUE;
          
        }
        else {
            //
            // wait
            //
            
            //
            // get one from the proccesed list
            //
            if(!SentQueueFreeAllEntries()){  
                   Sleep(4-i);
            }
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
// Function:   FreeQueueFreeEntry 
//
// Synopsis:   returns an empty record to the FreeQueue
//
// Arguments:  pEnt - the record to return to the FreeQueue
//
// Returns:    - 
//
// Modifies:   g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
VOID
FreeQueueFreeEntry(LdifRecordQueue *pEnt)
{
    //
    //free and insert processed entrie 
    //
    InsertTailList( &g_LFreeEntry, &pEnt->pqueue );
}


//+---------------------------------------------------------------------------
// Function:   SentQueueAddEntry 
//
// Synopsis:   adds a record to the SentQueue
//
// Arguments:  pEnt - the record to add to the SentQueue
//
// Returns:    - 
//
// Modifies:   g_LSentList (the SentQueue)
//
//----------------------------------------------------------------------------
VOID 
SentQueueAddEntry(LdifRecordQueue *pEnt)
{
    EnterCriticalSection(&g_csSentList);

    InsertTailList( &g_LSentList, &pEnt->pqueue );

    LeaveCriticalSection(&g_csSentList);
}


//+---------------------------------------------------------------------------
// Function:   SentQueueFreeAllEntries 
//
// Synopsis:   clears all records on the SentQueue and returns
//             them to the FreeQueue
//
// Arguments:  -
//
// Returns:    TRUE if it freed one or more records, FALSE otherwise
//
// Modifies:   g_LSentList (the SentQueue), g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
BOOL
SentQueueFreeAllEntries (void)
{

    LdifRecordQueue *pEnt;
    BOOL ListEmpty = FALSE;
    BOOL FreedSome = FALSE;

    EnterCriticalSection(&g_csSentList);  
    
    while (!ListEmpty) {

        if( !IsListEmpty( &g_LSentList ) ) {
            //
            // Take element from sent List
            //
            pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LSentList );

            //
            // Log the results of this import
            //
            OutputResult(pEnt);

            //
            // now free the element and place it back on the free queue
            //
    	    LDIF_ParseFree(&pEnt->i_record);   
            FreeQueueFreeEntry(pEnt);

            FreedSome = TRUE;
        }
        else {
            ListEmpty=TRUE;
        }
    }

    LeaveCriticalSection(&g_csSentList);
    return FreedSome;
}


//+---------------------------------------------------------------------------
// Function:   ParsedQueueAddEntry 
//
// Synopsis:   adds a record to the ParsedQueue
//
// Arguments:  pEnt - the record to add to the ParsedQueue
//
// Returns:    -
//
// Modifies:   g_LParseList (the ParsedQueue)
//
//----------------------------------------------------------------------------
VOID 
ParsedQueueAddEntry(
                    LdifRecordQueue *pEnt
                    )
{

    EnterCriticalSection(&g_csParseList);

    InsertTailList( &g_LParseList, &pEnt->pqueue );

    LeaveCriticalSection(&g_csParseList);
}


//+---------------------------------------------------------------------------
// Function:   ParsedQueueGetEntry 
//
// Synopsis:   gets a record off the ParsedQueue, ready to be sent
//             to the server
//
// Arguments:  pEnt - on return, set to ptr to retrieved record
//
// Returns:    TRUE if it retrieved a record, FALSE otherwise
//
// Modifies:   g_LParseList (the ParsedQueue)
//
//----------------------------------------------------------------------------
BOOL
ParsedQueueGetEntry(
                    PLdifRecordQueue *pEnt
                    )
{

    EnterCriticalSection(&g_csParseList);
    
    if( !IsListEmpty( &g_LParseList ) ) {
        //
        // Take element from free list
        //
        *pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LParseList );

        LeaveCriticalSection(&g_csParseList);
        
        return TRUE;

    }
    else {
        //
        // wait
        //
        LeaveCriticalSection(&g_csParseList);
        
        Sleep(1);
    }
    
    return FALSE;

}



//+---------------------------------------------------------------------------
// Function:   ParsedQueueFreeAllEntries 
//
// Synopsis:   clears all records on the ParsedQueue and returns
//             them to the FreeQueue
//
// Arguments:  -
//
// Returns:    TRUE if it freed one or more records, FALSE otherwise
//
// Modifies:   g_LParseList (the ParsedQueue), g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
BOOL
ParsedQueueFreeAllEntries (void)
{

    LdifRecordQueue *pEnt;
    BOOL ListEmpty = FALSE;
    BOOL FreedSome = FALSE;

    EnterCriticalSection(&g_csParseList);  
    
    while (!ListEmpty) {

        if( !IsListEmpty( &g_LParseList ) ) {
            //
            // Take element from sent List
            //
            pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LParseList );

            // now free the element
            LDIF_ParseFree(&pEnt->i_record); 
            FreeQueueFreeEntry(pEnt);
            
            FreedSome = TRUE;
        }
        else {
            ListEmpty=TRUE;
        }
    }

    LeaveCriticalSection(&g_csParseList);
    return FreedSome;
}


//+---------------------------------------------------------------------------
// Function:   OutputResult 
//
// Synopsis:   given a queue entry filled in with the results
//             of an import operation, outputs those results to
//             log files/console
//
// Arguments:  pRecord - a queue record
//
// Returns:    -
//
// Modifies:   -
//
//----------------------------------------------------------------------------
void OutputResult (LdifRecordQueue *pRecord)
{
   
	LDIF_Record *recReturned = &pRecord->i_record;
    DWORD cLineReturn = pRecord->dwLineNumber;
    DWORD cLine = pRecord->dwRecordIndex;
    DWORD dwError = pRecord->dwError;
    DWORD dwLdapError = pRecord->dwLdapError;
    DWORD dwLdapExtError = pRecord->dwLdapExtError;
    BOOL  fSkipExist = pRecord->fSkipExist;

  
    if(dwError != LL_SUCCESS) {
        SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
                 L"%d: %s\n",
                 cLine,
                 recReturned->dn);
        PrintRecord(recReturned, 
                    PRT_LOG|PRT_ERROR);
                    
        if (dwError == LL_LDAP) {
            if (fSkipExist && (dwLdapError == LDAP_OTHER)) {
                if (dwLdapExtError == ERROR_MEMBER_IN_ALIAS) {
                    SelectivePrint2W( PRT_ERROR,
                                     L"%d: ",
                                     cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                     MSG_LDIFDE_MEMBEREXIST);
                }
                else {
                    //
                    // Unignorable errors -> program termination
                    //
                    SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ADDERROR,
                                    cLineReturn, 
                                    ldap_err2string(dwLdapError));
                    OutputExtendedErrorByCode(dwLdapExtError);
                    
                    return;
                }
            } 
            //
            // If skip is on, and if we get objectclass violation, it means
            // the objectclass does not exist. We then check the item 
            // actually has no attributes, we'll ignore that if it's the 
            // case
            //
            else if (fSkipExist && 
                     (dwLdapError == LDAP_OBJECT_CLASS_VIOLATION) &&
                     recReturned->fIsChangeRecord && 
                     (recReturned->changes->mods_mem && (*(recReturned->changes->mods_mem) == NULL))) {
                SelectivePrint2W( PRT_ERROR,
                                  L"%d: ",
                                  cLineReturn );
                SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_NOATTRIBUTES);
            }
            else if (fSkipExist && 
                    (dwLdapError == LDAP_ALREADY_EXISTS || 
                     dwLdapError == LDAP_CONSTRAINT_VIOLATION ||
                     dwLdapError == LDAP_ATTRIBUTE_OR_VALUE_EXISTS ||
                     dwLdapError == LDAP_NO_SUCH_OBJECT)) {
                //
                // Error that can be ignored
                //
                if (dwLdapError == LDAP_ALREADY_EXISTS) {
                    SelectivePrint2W( PRT_ERROR,
                                    L"%d: ",
                                    cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ENTRYEXIST);
                }
                else if (dwLdapError == LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                    SelectivePrint2W( PRT_ERROR,
                                    L"%d: ",
                                    cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ATTRVALEXIST);
                }
                else if (dwLdapError == LDAP_NO_SUCH_OBJECT) {
                    SelectivePrint2W( PRT_ERROR,
                                    L"%d: ",
                                    cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_OBJECTNOEXIST);
                }
                else {
                    SelectivePrint2W( PRT_ERROR,
                                     L"%d: ",
                                     cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_CONSTRAINTVIOLATE);
                } 
            }
            else {
                //
                // Unignorable errors -> program termination
                //
                SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_ADDERROR,
                                cLineReturn, 
                                ldap_err2string(dwLdapError)); 
                OutputExtendedErrorByCode(dwLdapExtError);
                
                return;
            }                
        }
        else {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_ERRLOAD);

            return;
        }

    }
    else {
        //
        // SUCCESS
        //
        SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
             L"%d: %s\n",
             cLine,
             recReturned->dn);
        PrintRecord(recReturned, PRT_LOG);
        SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG,
                        MSG_LDIFDE_ENTRYMODIFIED);
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\incpch.c ===
#include <ldifds.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\lexerinc.c ===
#include <precomp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\ldifldap.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ldifldap.c

Abstract:

    Header for main support routine for ldif parser and generaetor

Environment:

    User mode

Revision History:

    07/17/99 -t-romany-
        Created it

    05/12/99 -felixw-
        Rewrite + unicode support

--*/
#ifndef _LDIFLDAP_H
#define _LDIFLDAP_H

#include <winldap.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <debug.h>

#define UNICODE_MARK 0xFEFF

//
// Structure Definitions
//
typedef struct object {
    LDAPModW    **ppMod;
    PWSTR       pszDN;
} LDIF_Object;

typedef struct _hashcachestring {
    PWSTR    value;
    ULONG    length;
    BOOLEAN  bUsed;
} HASHCACHESTRING;

//
// The node for the linked list built up while parsing an attrval spec list 
//
struct l_list {
    LDAPModW        *mod;
    struct l_list   *next;
};

//
// The name table entry used for doing things based on the attrname.
// Used in NameTableProcess.
//
struct name_entry {
    LDAPModW_Ext    *mod;   
    PWSTR           *next_val;
    struct berval   **next_bval;
    long            count;
}; 

//
// typedefs for structures to be stored in name to index mapping tables 
//
typedef struct _NAME_MAP {
    PWSTR szName;
    long  index;
} NAME_MAP, *PNAME_MAP;

typedef struct _NAME_MAPW {
    PWSTR szName;
    long  index;
} NAME_MAPW, *PNAME_MAPW;


//
// Switches for nametable operations
//
#define BINARY          0 /* The value is a binary to be berval'd */
#define REGULAR         1 /* Regular text value */
#define ALLOCATED_B     0 /* Memory has been allocated for binary */
#define ALLOCATED       1 /* Memory has been allocated for regular */  
#define NOT_ALLOCATED   2 /* memory has not yet been allocated */

//
// The commands the parser issues to the lexer for switching lexical modes
//
enum LEXICAL_MODE {
    NO_COMMAND             =  0,
    C_ATTRNAME             =  1,
    C_SAFEVAL              =  2,
    C_NORMAL               =  3,
    C_M_STRING             =  4,
    C_M_STRING64           =  5,
    C_DIGITREAD            =  7,
    C_URLSCHEME            =  9,
    C_TYPE                 =  10,
    C_CLEAR                =  12,
    C_URLMACHINE           =  13,
    C_CHANGETYPE           =  14,
    C_SPECIAL1             =  15,
    C_ATTRNAMENC           =  16,
    C_SEPBC                =  17
};

//
//  Parser return codes.
//  I am breaking with convention here and using the return code of yyparse to 
//  indicate to the calling funciton the type of entry that was read. (Usually 
//  yyparse returns 0 on success and non-0 otherwise. 
//  yyparse returns 1 on failure and 0 on success, so the following enum RETURN_CODE
//  should try to avoid these two particular numbers.
//
enum RETURN_CODE {
    LDIF_REC               = 2,  // entry is a regular add
    LDIF_CHANGE            = 3  // entry is a change
};

//
// Below are the parameters to GenerateModFromList()
//
enum CONVERTLIST_PARAM {
    NORMALACT              = 0, // Take the default action
    PACK                   = 1, // If there are several attrval-spec's with 
                                // the same attrname place them into one 
                                // LDAPMod struct (As multiple values)
                                //  
    EMPTY                  = 2  // An empty list
};

// 
// Different commands for name table operations
//
enum NAMETABLE_OP {
    SETUP   = 1,
    COUNT   = 2,  
    ALLOC   = 3,
    PLACE   = 4
};

enum CLASS_LOC {
    LOC_NOTSET,
    LOC_FIRST,
    LOC_LAST
};

enum FileType {
    F_NONE      = 0,
    F_REC       = 1,
    F_CHANGE    = 2
};

extern int yyparse();

LDAPModW*  GenereateModFromAttr(PWSTR type, PBYTE value, long bin);
LDAPModW** GenerateModFromList(int);
void       AddModToSpecList(LDAPModW *elem);
void       FreeAllMods(LDAPModW** mods);
void       SetModOps(LDAPModW** mods, int op);
void       ChangeListAdd(struct change_list *elem);
int        NameTableProcess(
                  struct name_entry table[], 
                  long table_size, 
                  int op, 
                  int ber, 
                  LDAPModW  *mod,
                  PRTL_GENERIC_TABLE NtiTable);
void       CreateOmitBacklinkTable(
                  LDAP *pLdap,
                  PWSTR *rgszOmit,
                  DWORD dwFlag,
                  PWSTR *ppszNamingContext,
                  BOOL *pfPagingAvail,
                  BOOL *pfSAMAvail);
void       samTablesCreate();
void       samTablesDestroy();
int        samCheckObject(PWSTR *rgpVals);
BOOLEAN    samCheckAttr(PWSTR attribute, int table);

int __cdecl LoadedCompare(const void *arg1, const void *arg2);

void        ProcessException (DWORD exception, LDIF_Error *pError);

int         SCGetAttByName(ULONG ulSize, PWSTR pVal);

void GetNewRange(PWSTR szAttribute, DWORD dwAttrNoRange,
                 PWSTR szAttrNoRange, DWORD dwNumAttr,
                 PWSTR **pppszAttrsWithRange);

PWSTR StripRangeFromAttr(PWSTR szAttribute);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\lexeru.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lexeru.c

Abstract:

    Unicode Lexer. Designed to be compatible with lex.

Environment:

    User mode

Revision History:

    04/26/99 -felixw-
        Created it

--*/

#include <precomp.h>
#include "y_tab.h"


DEFINE_FEATURE_FLAGS(Lexer, 0);

#define ECHO(c) fwprintf(yyout, L"%c", c)
FILE *yyin      = NULL;         // Input file stream
FILE *yyout     = NULL;         // Output file stream for first phase (CLEAR)
BOOLEAN fNewFile = FALSE;
PWSTR g_szInputFileName = NULL; // name of input file

//
// Variables for Stack
//
STACK *g_pStack = NULL;
STACK *g_pFilteredCharStack = NULL;
STACK *g_pRawCharStack = NULL;


/*++

Routines Description:
    
    Character Stack Implementation. This stack is designed for handling 
    characters we get back from the file stream. It allows us to store 
    characters in the stack and roll back to the original state if the 
    charactesr that we get does not meet our requirement.

--*/

void LexerInit(PWSTR szInputFileName)
{
    g_pStack = (STACK*)MemAlloc_E(sizeof(STACK));
    g_pStack->rgcStack = (PWSTR)MemAlloc_E(sizeof(WCHAR) * INC);
    g_pStack->dwSize = INC;
    g_pStack->dwIndex = 0;

    g_pFilteredCharStack = (STACK*)MemAlloc_E(sizeof(STACK));
    g_pFilteredCharStack->rgcStack = (PWSTR)MemAlloc_E(sizeof(WCHAR) * INC);
    g_pFilteredCharStack->dwSize = INC;
    g_pFilteredCharStack->dwIndex = 0;

    g_pRawCharStack = (STACK*)MemAlloc_E(sizeof(STACK));
    g_pRawCharStack->rgcStack = (PWSTR)MemAlloc_E(sizeof(WCHAR) * INC);
    g_pRawCharStack->dwSize = INC;
    g_pRawCharStack->dwIndex = 0;

    g_szInputFileName = MemAllocStrW_E(szInputFileName);
}

void LexerFree()
{
    if (g_pStack) {
        if (g_pStack->rgcStack) {
            MemFree(g_pStack->rgcStack);
            g_pStack->rgcStack = NULL;
        }
        MemFree(g_pStack);
        g_pStack = NULL;
    }

    if (g_pFilteredCharStack) {
        if (g_pFilteredCharStack->rgcStack) {
            MemFree(g_pFilteredCharStack->rgcStack);
            g_pFilteredCharStack->rgcStack = NULL;
        }
        MemFree(g_pFilteredCharStack);
        g_pFilteredCharStack = NULL;
    }

    if (g_pRawCharStack) {
        if (g_pRawCharStack->rgcStack) {
            MemFree(g_pRawCharStack->rgcStack);
            g_pRawCharStack->rgcStack = NULL;
        }
        MemFree(g_pRawCharStack);
        g_pRawCharStack = NULL;
    }

    if (g_szInputFileName) {
        MemFree(g_szInputFileName);
        g_szInputFileName = NULL;
    }
}

void Push(STACK *pStack,WCHAR c)
{
    if (pStack->dwIndex >= pStack->dwSize) {
        pStack->rgcStack = (PWSTR)MemRealloc_E(pStack->rgcStack,sizeof(WCHAR) * (pStack->dwSize + INC));
        pStack->dwSize += INC;
    }
    pStack->rgcStack[pStack->dwIndex++] = c;
}

BOOL Pop(STACK *pStack,WCHAR *pChar)
{
    if (pStack->dwIndex > 0) {
        *pChar =  pStack->rgcStack[--pStack->dwIndex];
        return TRUE;
    }
    else {
        return FALSE;
    }
}

void Clear(STACK *pStack)
{
    pStack->dwIndex = 0;
}



BOOL GetNextCharExFiltered(
    WCHAR *pChar, 
    BOOL fStart
    )

/*++

Routine Description:

    Special version of GetNextCharFiltered that stores the values in the stack. The
    RollBack function can be used to restore all the values from the stack.

Arguments:

    pChar - Character to return
    fStart - Start recording in the stack from fresh, or continue pushing

Return Value:
    
    TRUE if succeeds, FALSE if fails to get value

--*/

{
    if (GetNextCharFiltered(pChar)) {
        
        //
        // If we start from scratch, we'll clear the stack first
        //
        if (fStart) {
            Clear(g_pStack);
        }
        Push(g_pStack,*pChar);
        return TRUE;
    }
    return FALSE;
}

void RollBack()

/*++

Routine Description:

    RollBack all the characters from the stack into the file stream

Arguments:
    None

Return Value:
    None
    
--*/

{
    WCHAR c;
    while (Pop(g_pStack,&c)) {
        UnGetCharFiltered(c);
    }
}

BOOL GetNextCharFiltered(
    WCHAR *pChar
    )

/*++

Routine Description:

    Get the next character from the file stream, filtering
    out comments and line continuations

Arguments:

    pChar - Character to be returned

Return Value:
    
    TRUE if succeeds, FALSE if fails to retrieval 

--*/

{
    WCHAR c;

    if (Pop(g_pFilteredCharStack,&c)) {
        *pChar = c;
        return TRUE;
    }

    c = GetFilteredWC();
    if (c == WEOF) {
        return FALSE;
    }
    else {
        *pChar = c;
        return TRUE;
    }
}

void UnGetCharFiltered(WCHAR c) 

/*++

Routine Description:
    
    Pushes the input character back into the file stream

Arguments:

    c - the character to push back

Return Value:
    None
    
--*/

{
    WCHAR cReturn;
    WCHAR cGet;

    if (c == WEOF) {
        ERR(("UnGetCharFiltered: Invalid input value, WEOF.\n"));
        RaiseException(LL_SYNTAX, 0, 0, NULL);
    }

    Push(g_pFilteredCharStack,c);
}

void UnGetCharExFiltered(WCHAR c) 

/*++

Routine Description:
    
    Pushes the input character back into the file stream

Arguments:

    c - the character to push back

Return Value:
    None
    
--*/

{
    WCHAR cGet;
    UnGetCharFiltered(c);
    Pop(g_pStack,&cGet);
}


/*++

Routine Description:

    Get the next character from the file stream
    This routine should only be used internally
    by the comment preprocessor.

Arguments:

    pChar - Character to be returned

Return Value:
    
    TRUE if succeeds, FALSE if fails to retrieval 
++*/
BOOL GetNextCharRaw(WCHAR *pChar)
{
    WCHAR c;

    if (Pop(g_pRawCharStack,&c)) {
        *pChar = c;
        return TRUE;
    }

    c = g_fUnicode ? getwc(yyin) : (WCHAR) getc(yyin);
    if (c == WEOF) {
        if (ferror(yyin)) {
            ERR(("GetNextCharRaw: An error occurred while reading char.\n"));
            RaiseException(LL_SYNTAX, 0, 0, NULL);
        }
        return FALSE;
    }
    else {
        *pChar = c;
        return TRUE;
    }
}


/*++

Routine Description:
    
    Pushes the input character back into the file stream
    This routine should only be used internally
    by the comment preprocessor.

Arguments:

    c - the character to push back

Return Value:
    None
    
--*/
void UnGetCharRaw(WCHAR c)
{
    WCHAR cReturn;
    WCHAR cGet;

    if (c == WEOF) {
        ERR(("UnGetCharRaw: Invalid input value, WEOF.\n"));
        RaiseException(LL_SYNTAX, 0, 0, NULL);
    }

    Push(g_pRawCharStack,c);
}


/*++

Routine Description:
    Reads the next character from the input file, skipping over
    line continuations and comments.  This replaces "getwc" by
    providing pre-processed input.

Arguments:
    None

Return Value:
    A character 
    
--*/

WCHAR GetFilteredWC(void)
{
    static BOOL fFirstTime = TRUE;   // first time we're being called?
    static BOOL fReturnedNewLine = FALSE;// was the last char we returned
                                         // a new line?
                                         
    static __int64 cBytesProcessed = 0; // bytes processed so far of the file
    static __int64 cBytesTrimmed = 0;   // "trimmed" file size
    
    WCHAR c;
    WCHAR wszVersionHeader[] = L"ersion: 1\n";  // version spec (minus 'v')
    DWORD i;

    if (fFirstTime) {

        fFirstTime = FALSE;

        //
        // We need to insert a "version: 1\n" header string.  To quote
        // the original author:
        //   There is a pressing problem of the user putting in opening newlines
        //   before his first valid token. This is prohibited by the LDIF spec,
        //   however due to some flex/yacc peculiarity, it is allowed to pass.
        //   Which is good, because it is an unreasonable restriction.
        //   However, what it does is mess up our line counting. The solution
        //   is to put in a version spec line automatically. This would
        //   simultaneously remove opening newlines and set the version spec to 
        //   some default value.
        //   (I am not currently doing anything with it, but if the need
        //   ever arose)...
        //   The grammar is also changed to accomodate 0, one or two
        //   version specs.
        //
        // To do this, we return the character 'v' and stuff the character stack
        // with the remainer of the header string for subsequent calls to
        // GetNextCharFiltered to read
        //

        c = L'v';
        
        for (i = (sizeof(wszVersionHeader)/sizeof(WCHAR))-1; // -1 for the NULL
             i > 0;
             i--) {

            //
            // We have to push the characters in reverse order
            // so they come out in correct order when popped
            //
            Push(g_pFilteredCharStack, wszVersionHeader[i-1]);
        }
        

        //
        // In addition to prepending the version header string, we also
        // need to simulate trimming extra newlines at the end of the file,
        // otherwise the parser will reject the file with a syntax error
        //
        // To do this, we get the total file size, determine how many (if any)
        // newlines are at the end of the file, and subtract the two to determine
        // the "trimmed" file size.  In the future, we avoid returning characters
        // past the end of this "trimmed" file".  We'll also have to insert
        // a newline character into the stream so that the file is terminated
        // by exactly one newline.
        //

        if (!GetTrimmedFileSize(g_szInputFileName, &cBytesTrimmed)) {
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }

        //
        // Return the first character of the version header string
        //
        return c;   // 'v'
    }

    
    //
    // We determine if we've reached the end of the "trimmed" file.
    // Note: Since this is _before_ we start scanning, we need to
    // check if we're _at_ or past the end, i.e., >=, since if
    // we're at the end there's nothing more to scan
    //
    if (cBytesProcessed >= cBytesTrimmed) {
        // Reached the end, inject a newline if needed
        if (!fReturnedNewLine) {
            fReturnedNewLine = TRUE;
            return L'\n';
        }
        else {
            return WEOF;
        }
    }
    else {
    
        // Haven't reached the end, keep processing characters
        
        while (1) {
            c = L'\0';
            if (!ScanClear(&c, &cBytesProcessed)) {
                // ScanClear reached EOF, pass it up, injecting
                // a terminating newline if needed
                if (!fReturnedNewLine) {
                    fReturnedNewLine = TRUE;
                    return L'\n';
                }
                else {
                    return WEOF;
                }
            }

            // ScanClear may have gone past the end of our "trimmed" file.
            // Check for this.
            // Note: It's okay if the scanning put us _at_ the end, it
            // just can't put us _past_ the end, i.e., >
            if (cBytesProcessed > cBytesTrimmed) {
                // Reached the end, inject a newline if needed
                if (!fReturnedNewLine) {
                    fReturnedNewLine = TRUE;
                    return L'\n';
                }
                else {
                    return WEOF;
                }
            }

            // Otherwise, if ScanClear got a character, return it, else
            // keep scanning.
            if (c != L'\0') {
                if (c == L'\n') {
                    fReturnedNewLine = TRUE;
                }
                else {
                    fReturnedNewLine = FALSE;
                }
                return c;
            }
        }
    }
}


BOOL GetTrimmedFileSize(PWSTR szFilename,
                        __int64 *pTrimmedSize
                        )
{
        BOOL fSuccess = TRUE;

        HANDLE hFile = INVALID_HANDLE_VALUE;
        DWORD dwSize;               // size of a char
        DWORD dwErr;
        BOOL bRes;
        BOOL fDone = FALSE;
        BOOL fReachedTop = FALSE;
        DWORD dwBytesRead=0;
        BYTE rgByte[256];
        WCHAR CharCur;              // current char we just read
        WCHAR CharLastNonSep = 0;   // previous char we read that wasn't a newline
        LARGE_INTEGER TotalFileSize;
        DWORD dwTrimCount = 0;      // bytes we know we need to trim so far
        DWORD dwPossibleTrimCount = 0; // bytes we might have to trim

        hFile = CreateFile(szFilename,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

        if (hFile==INVALID_HANDLE_VALUE) {
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }


        //
        // Determine the total file size
        //
        if (!GetFileSizeEx(hFile, &TotalFileSize)) {
            ERR(("Couldn't get file size\n"));
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }

        //
        // Compute the amount to be "trimmed"
        //
        dwSize = (g_fUnicode ? sizeof(WCHAR) : sizeof(CHAR));

        //
        // First point to one char left of FILE_END
        //
        dwErr = SetFilePointer(hFile, -1 * dwSize, NULL, FILE_END);
        if (dwErr==INVALID_SET_FILE_POINTER) {
            ERR(("Failed setting file pointer\n"));
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }

        //
        // Read in the last character
        //
        bRes = ReadFile(hFile, rgByte, dwSize, &dwBytesRead, NULL);
        if ((!bRes)||(dwBytesRead!=dwSize)) {
            ERR(("Failed reading file\n"));
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }


        //
        // Now we keep moving back until we find a line that isn't
        // either a newline, a comment, or a continuation of a comment
        // (i.e., the first line that's a actual LDIF record)
        //

        //
        // We first get the char that we got from readfile
        //
        CharCur = (g_fUnicode ? ((PWSTR)rgByte)[0] : rgByte[0]);

        while (!fDone) {

            //
            // Count up all the chars until we reach a newline
            // These characters will go into the "possible trim" count:
            // they may get trimmed (if this turns out to be a comment line
            // or a continuation of a comment line), or not trimmed (if it turns
            // out to be part of a LDIF record)
            //
            while((CharCur!='\n')&&(CharCur!='\r')) {

                dwPossibleTrimCount += dwSize;
                CharLastNonSep = CharCur;
                
                //
                // Move back 2 chars, to point to the char before the character we
                // just read
                //
                dwErr = SetFilePointer(hFile, -2 * dwSize, NULL, FILE_CURRENT);
                if (dwErr==INVALID_SET_FILE_POINTER) {
                    if (GetLastError() == ERROR_NEGATIVE_SEEK) {
                        // reached the top of the file
                        fReachedTop = TRUE;
                        break;
                    }
                    else {
                        ERR(("Failed setting file pointer\n"));                   
                        fSuccess=FALSE;
                        BAIL_ON_FAILURE(E_FAIL);
                    }
                }
        
                //
                // Get the next char
                //
                bRes = ReadFile(hFile, rgByte, dwSize, &dwBytesRead, NULL);
                if ((!bRes)||(dwBytesRead!=dwSize)) {
                    ERR(("Failed reading char\n"));
                    fSuccess=FALSE;
                    BAIL_ON_FAILURE(E_FAIL);
                }
                
                CharCur = (g_fUnicode ? ((PWSTR)rgByte)[0] : rgByte[0]);
            }

            //
            // Depending on the last character before the newline, we
            // may need to either increase the trim count, keep going, or
            // terminate
            //
            // in each of the following, adding the extra "dwSize" accounts
            // for the newline we hit to get out of the previous loop and
            // into this block of code (unless we exited the loop because
            // we reached the top of the file)
            //

            if (CharLastNonSep == L'#') {

                // this was a comment line at the end of the file--> trim it
                dwTrimCount += dwPossibleTrimCount;
                dwTrimCount += (!fReachedTop ? dwSize : 0);
                dwPossibleTrimCount = 0;
                CharLastNonSep = 0; 
            }
            else if (CharLastNonSep == L' ') {
                // this was a continuation line, so it may need to be trimmed
                // or it may need to not be trimmed, depending on what it was
                // a continuation of --> do nothing for now and keep going
                dwPossibleTrimCount += (!fReachedTop ? dwSize : 0);
            }
            else if (CharLastNonSep == 0) {
                // just a plain newline --> trim it
                dwTrimCount += (!fReachedTop ? dwSize : 0);
            }
            else {
                // The last non-separator character was neither a # nor a continuation
                // --> we hit a valid LDIF record line --> don't trim the line and
                // stop processing, we're no longer at the end of the file
                fDone = TRUE;
                break;
            }

            // if we reached the top, no point to trying to continue
            if (fReachedTop) {
                fDone = TRUE;
                break;
            }

            //
            // Move back 2 chars, to point to the char before the character we
            // just read
            //
            dwErr = SetFilePointer(hFile, -2 * dwSize, NULL, FILE_CURRENT);
            if (dwErr==INVALID_SET_FILE_POINTER) {
                if (GetLastError() == ERROR_NEGATIVE_SEEK) {
                    // reached the top of the file
                    fReachedTop = TRUE;
                    fDone = TRUE;
                    break;
                }
                else {
                    ERR(("Failed setting file pointer\n"));
                    fSuccess=FALSE;
                    BAIL_ON_FAILURE(E_FAIL);
                }
            }

            //
            // Get the next char
            //
            bRes = ReadFile(hFile, rgByte, dwSize, &dwBytesRead, NULL);
            if ((!bRes)||(dwBytesRead!=dwSize)) {
                ERR(("Failed reading char\n"));
                fSuccess=FALSE;
                BAIL_ON_FAILURE(E_FAIL);
            }
            
            CharCur = (g_fUnicode ? ((PWSTR)rgByte)[0] : rgByte[0]);
        }
        
        //
        // Compute the trimmed size
        //
        *pTrimmedSize = TotalFileSize.QuadPart - dwTrimCount;

error:

        if (hFile != INVALID_HANDLE_VALUE) {
            if(!CloseHandle(hFile)) {
                ERR(("Failed closing file handle\n"));
                fSuccess=FALSE;
            }
        }

        return fSuccess;
}


int yylex ()

/*++

Routine Description:

    Main lexing routine. Take input from yyin.

Arguments:

Return Value:

    The token found.

--*/

{
    DWORD Token;                            // Returning pToken
    int Mode_last; 
    BOOL fMatched;

    FEATURE_DEBUG(Lexer,
                  FLAG_FNTRACE,
                  ("yylex()\n"));

    if (Mode == NO_COMMAND) {
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("yylex: NO_COMMAND, Returning MODESWITCH\n"));
        return MODESWITCH;
    }
    
    //
    // After storing the old mode, we reset Mode to NO_COMMAND 
    // indicitating that if we're not in NORMAL mode, we must switch modes 
    // according to the grammar again.
    //
    Mode_last = Mode;
    if (Mode != C_NORMAL) {
        Mode = NO_COMMAND;
    }
        
    while (1) {

        //
        // Depending on our current mode, we use a different lexing routine
        //
        switch (Mode_last) {
            case C_NORMAL:
                fMatched = ScanNormal(&Token);
                break;
            case C_SAFEVAL:
                fMatched = ScanVal(&Token);
                break;
            case C_ATTRNAME:
                fMatched = ScanName(&Token);
                break;
            case C_ATTRNAMENC:
                fMatched = ScanNameNC(&Token);
                break;
            case C_M_STRING:
                ERR_RIP(("M_STRING is an unsupported mode command.\n"));
                return YY_NULL;
                break;
            case C_M_STRING64:
                fMatched = ScanString64(&Token);
                break;
            case C_DIGITREAD:
                fMatched = ScanDigit(&Token);
                break;
            case C_TYPE:
                fMatched = ScanType(&Token);
                break;
            case C_URLSCHEME:
                ERR_RIP(("URLSCHEME is an unsupported mode command.\n"));
                return YY_NULL;
                break;
            case C_URLMACHINE:
                fMatched = ScanUrlMachine(&Token);
                break;
            case C_CHANGETYPE:
                fMatched = ScanChangeType(&Token);
                break;
            default:
                ERR_RIP(("Unexpected command type %d.\n",Mode_last));
                return YY_NULL;
                break;
        }

        //
        // If no match can be found, goto the default handling case
        //
        if (!fMatched) {
            WCHAR c;
            if (g_pszLastToken) {
                MemFree(g_pszLastToken);
                g_pszLastToken = NULL;
            }

            if (GetNextCharFiltered(&c)) {
                cLast = c;
                UnGetCharFiltered(c);
                /*
                if (GetToken(&g_pszLastToken)) {
                    RollBack();
                };
                */

                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("yylex: Uncongnized char, Returning MODESWITCH\n"));
                return MODESWITCH; 
            }
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("yylex: YY_NULL\n"));
            fEOF = TRUE;
            return YY_NULL; 
        }

        //
        //  If there is a match, and there is a returning token, return it
        //
        else if (Token != YY_NULL) {
            return Token;
        }
    }
}


void yyerror (char *error) 
{
    // the exception should not be raised here for the following reason
    //  the error recovery mechanism cannot be used to probe where the input
    //  is failing the grammar
    // so the exception should be pushed to either under error rules or after yyparse
    // returns a nonzero value
    // RaiseException(LL_SYNTAX, 0, 0, NULL);
}

BOOL ScanClear(PWCHAR pChar, __int64 *pBytesProcessed)
{
    WCHAR c;
    BOOL fNextChar = TRUE;
    DWORD dwCharSize = (g_fUnicode ? sizeof(WCHAR) : sizeof(CHAR));

    if (!GetNextCharRaw(&c)) {
        return FALSE;
    }
    (*pBytesProcessed) += dwCharSize;
    
    if (fNewFile == FALSE) {
        if (g_fUnicode) {
            fNewFile = TRUE;
            if (c == UNICODE_MARK) {
                if (!GetNextCharRaw(&c)) {
                    return FALSE;
                }
                (*pBytesProcessed) += dwCharSize;
            }
        }
    }

    //
    // Comment
    // <CLEAR>^#[^\n\r]+[\n\r]?
    //
    if (fNewLine && (c == '#')) {

        //
        // We have got another character, it's not a newline anymore
        //
        fNewLine = FALSE;
        while (GetNextCharRaw(&c)) {
            (*pBytesProcessed) += dwCharSize;
            if (c == '\r') {
                if (!GetNextCharRaw(&c)) {
                    ERR_RIP(("\r is not followed by anything!\n"));
                    return FALSE;
                }
                (*pBytesProcessed) += dwCharSize;
            }
            if (c == '\n') {
                //
                // after a '\n', it's a newline
                //
                fNewLine = TRUE;
                //
                // Exit if we have reached the end
                //
                if (!GetNextCharRaw(&c)) {
                    LineGhosts++;
                    FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("ScanClear: Comment\n"));
                    return TRUE;
                };
                UnGetCharRaw(c);
                
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanClear: Comment\n"));
                LineGhosts++;
                return TRUE;
            }
        }
        
        //
        // Indicating a successful parse with no token returning
        //
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanClear: Comment\n"));
        LineGhosts++;
        return TRUE;
    }

    //
    // for cases where either a new line is not followed by a comment or
    // not a new line at all
    //
    else {

        //
        // [\n\r][^#]
        //  Insert the current line into the rgLineMap.
        //  So we allow the first ' ' after the inserted "version: 1\n"
        //    and the later [\n\r]' ' will be checked against in the code below
        //  Note -- due to the inserted "version: 1\n", we always put the current line
        //         into the rgLineMap at the very beginning of the line (of course,
        //         it has to be [\n\r][^ #] except for the ' ' right after the inserted
        //         "version: \n")
        //
        if (fNewLine) {

            if (!rgLineMap) {
                rgLineMap = (long *)MemAlloc_E(LINEMAP_INC*sizeof(long));
                cLineMax = MemSize(rgLineMap);
            } 
            else if ((LineClear%LINEMAP_INC)==0) {
                //
                // Chunk used up. LineClear is 'LineClear'
                //
                rgLineMap = (long *)MemRealloc_E(
                                        rgLineMap, 
                                        cLineMax+LINEMAP_INC*(DWORD)sizeof(long)
                                        );
                cLineMax = MemSize(rgLineMap);
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("\nChunk used up\n"));
            }
            
            //
            // the +1 is because our array starts at 0
            //
            rgLineMap[LineClear] = LineClear + LineGhosts + 1;
            
            //
            // 'LineClear' maps to 'LineClear+LineGhosts+1'
            // 
            LineClear++;
        }

        //
        // -- Now we start to consider the character read in. --
        //
        // If the character read in is Linefeed, we need to make sure it is not followed by
        // ' ' and for other situations we mark fNewLine to TRUE
        //
        if ((c == '\n') || (c == '\r')) {

            if (c == '\r') {
                if (!GetNextCharRaw(&c)) {
                    ERR_RIP(("\r is not followed by anything!\n"));
                    return FALSE;
                }
                (*pBytesProcessed) += dwCharSize;
            }

            //
            // It's a newline after linefeed
            //
            fNewLine = TRUE;

            //
            // Done if we have reached the end
            //
            if (!GetNextCharRaw(&c)) {
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanClear: LineFeed\n"));
                *pChar = L'\n';
                return TRUE;
            }
            (*pBytesProcessed) += dwCharSize;
            
            //
            // If it comes with a space
            // <CLEAR>[\n\r][ ] 
            // it is wrapped line.
            //
            if (c == ' ') {
                FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("\nLinewrap removed\n"));
                LineGhosts++;
                fNewLine = FALSE;
                return TRUE;
            }

            UnGetCharRaw(c);
            (*pBytesProcessed) -= dwCharSize;
     
            *pChar = L'\n';
            FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanClear: Multi-LineFeed\n"));
            return TRUE;
        }

        //
        // Other characters
        //
        else {
            //
            // After any other characters, it's not a newline anymore
            //
            fNewLine = FALSE;
            *pChar = c;
            return TRUE;
        }
    }
}

BOOL ScanNormal(DWORD *pToken)
{
    WCHAR c;
    *pToken = YY_NULL;

    if (!GetNextCharFiltered(&c)) {
        return FALSE;
    }

    if ((c == ' ') || (c == '\t')) {
        while (GetNextCharFiltered(&c)) {
            if ((c == ' ') || (c == '\t')) {
                continue;
            }
            else if (c == '\n') {
                UnGetCharFiltered(c);
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: Ignoring whitespace\n"));
                return TRUE;
            }
            else {
                UnGetCharFiltered(c);
                *pToken = MULTI_SPACE;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: MULTI_SPACE\n"));
                return TRUE;
            }
        }
        //
        // If we reaches end of file, we'll handle the '<NORMAL>[ \t]+$' case
        //
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanNormal: Ignoring whitespace\n"));
        return TRUE;
    }
    else if (c == '\n') {
        if (!GetNextCharExFiltered(&c,TRUE)) {
            //
            // We do not understand single '\n'
            //
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: don't understand single '\\n'.\n"));
            /*
            UnGetChar(c);
            return FALSE;                       
            */
            return TRUE;
        }
        if (c == '-') {
            //
            // <NORMAL>[\n\r]/"-"[ \t]*[\n\r]
            //
            while (GetNextCharExFiltered(&c,FALSE)) {
                if ((c == ' ') || (c == '\t')) {
                    continue;
                }
                else if (c == '\n') {
                    RollBack();
                    Line++; 
                    *pToken = SEPBYMINUS;
                    FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("ScanNormal: SEPBYMINUS\n"));
                    return TRUE;
                }
                else {
                    RollBack();
                    Line++; 
                    *pToken = SEP;
                    FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("ScanNormal: SEP\n"));
                    return TRUE;
                }
            }
            Line++; 
            RollBack();
            *pToken = SEP;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: SEP\n"));
            return TRUE;
        }
        else if ((c == 'c') || (c == 'C')) {
            //
            // <NORMAL>[\n\r]/"changetype:"[ \t]*("add"|"delete"|"modrdn"|"moddn"|"modify"|"ntdsSchemaadd"|"ntdsSchemadelete"|"ntdsSchemamodrdn"|"ntdsSchemamoddn"|"ntdsSchemamodify")[ \t]*[\n\r] {
            //
            if (!GetNextCharExFiltered(&c,FALSE)) {
                RollBack();
                Line++; 
                *pToken = SEP;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: SEP\n"));
                return TRUE;                        
            }
            if ((c == 'h') || (c == 'H')) {
                RollBack();
                Line++; 
                *pToken = SEPBYCHANGE;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: SEPBYCHANGE\n"));
                return TRUE;
            }
            else {
                RollBack();
                Line++; 
                *pToken = SEP;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: SEP\n"));
                return TRUE;
            }
        }
        else if (c == '\n') {
            DWORD dwLineCount = 2;
            //
            // <NORMAL>[\n\r]{2,}
            //
            while (GetNextCharFiltered(&c)) {
                if (c != '\n') {
                    UnGetCharFiltered(c);
                    break;
                }
                dwLineCount++;
            }
            Line += dwLineCount;
            *pToken = MULTI_SEP;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: MULTI_SEP\n"));
            return TRUE;
        }
        else {
            RollBack();
            Line++; 
            *pToken = SEP;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: SEP\n"));
            return TRUE;            
        }
    }
    UnGetCharFiltered(c);
    return FALSE;
}

BOOL ScanDigit(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharFiltered(&c)) {
        BAIL();
    }

    if (!IsDigit(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);

    while (GetNextCharFiltered(&c)) {
        if (!IsDigit(c)) {
            UnGetCharFiltered(c);
            *pToken = DIGITS;

            yylval.num = _wtoi(STR_VALUE()); 
            
            //
            // ERROR REPORTING BLOCK
            //
            RuleLast = RS_DIGITS;
            TokenExpect = RT_MANY;
        
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanDigit: DIGITS '%S'\n",STR_VALUE()));

            fReturn = TRUE;
            BAIL();
        }
        STR_ADDCHAR(c);
    }
error:
    STR_FREE();
    return fReturn;
}


BOOL ScanString64(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (!Is64Char(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }
    
    while (1) {
        int i;

        //
        // Adding in first character
        //
        STR_ADDCHAR(c);

        //
        // Looking at the rest 4 characters
        //
        for (i=0;i<3;i++)
        {
            //
            // If the character is not what we want, we roll back and exit
            //
            if ((!GetNextCharExFiltered(&c,FALSE)) || (!Is64Char(c))) {
                RollBack();
                BAIL();
            }
            STR_ADDCHAR(c);
        }

        //
        // Must be followed by not \x21-\x7E    
        //
        if (!GetNextCharExFiltered(&c,FALSE)) {
            RollBack();
            BAIL();
        }
        //
        // Terminate if we find a terminator
        //
        else if (Is64CharEnd(c)) {
            UnGetCharFiltered(c);
            *pToken = BASE64STRING;
            yylval.wstr = MemAllocStrW_E(STR_VALUE());
            
            RuleLast = RS_BASE64;
            TokenExpect = RT_MANY;
            
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanString64: BASE64STRING '%S'\n",STR_VALUE()));

            fReturn = TRUE;
            BAIL();
        }
    }
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanName(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (!IsNameChar(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);
    while (GetNextCharExFiltered(&c,FALSE)) {
        if (!IsNameChar(c)) {
            if (c != ':') {
                RollBack();
                BAIL();
            }
            else {
                UnGetCharFiltered(c);
                yylval.wstr = MemAllocStrW_E(STR_VALUE());
             
                RuleLast = RS_ATTRNAME;
                TokenExpect = RT_C_VALUE;
                *pToken = NAME;
                fReturn = TRUE;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanName: NAME '%S'\n",STR_VALUE()));
                BAIL();
            }
        }
        STR_ADDCHAR(c);
    }

    //
    // RollBack and fail out if we can't find the terminating ':'
    //
    RollBack();
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanNameNC(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (!IsNameChar(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);

    while (GetNextCharFiltered(&c)) {
        if (!IsNameChar(c)) {
            UnGetCharFiltered(c);
            yylval.wstr = MemAllocStrW_E(STR_VALUE());
         
            RuleLast = RS_ATTRNAMENC;
            TokenExpect = RT_C_VALUE;
            *pToken = NAMENC;
            fReturn = TRUE;

            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNameNC: NAMENC '%S'\n",STR_VALUE()));

            BAIL();
        }
            STR_ADDCHAR(c);
    }
    fReturn = TRUE;
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanVal(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();
    *pToken = YY_NULL;

    if (!GetNextCharFiltered(&c)) {
        fReturn = FALSE;
        BAIL();
    }

    //
    // Even if there is no value, it is valid
    //
    if (!IsValInit(c)) {
        fReturn = FALSE;
        BAIL();
    }

    STR_ADDCHAR(c);
    while (GetNextCharFiltered(&c)) {
        if (!IsVal(c)) {
            UnGetCharFiltered(c);
            fReturn = TRUE;
            BAIL();
        }
        STR_ADDCHAR(c);
    }
error:
    if (fReturn) {
        yylval.wstr = MemAllocStrW_E(STR_VALUE());
        
        RuleLast = RS_SAFE;
        TokenExpect = RT_MANY;
        
        *pToken = VALUE;                                           
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanVal: VALUE '%S'\n",STR_VALUE()));
    }
    STR_FREE();
    return fReturn;
}

BOOL ScanUrlMachine(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharFiltered(&c)) {
        BAIL();
    }

    if (!IsURLChar(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);
    while (GetNextCharFiltered(&c)) {
        if (!IsURLChar(c)) {
            UnGetCharFiltered(c);
            yylval.wstr = MemAllocStrW_E(STR_VALUE());
         
            *pToken = MACHINENAME;
            fReturn = TRUE;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanUrlMachine: MACHINENAME '%S'\n",STR_VALUE()));
            BAIL();
        }
        STR_ADDCHAR(c);
    }
    fReturn = TRUE;
    FEATURE_DEBUG(Lexer,
                  FLAG_VERBOSE,
                  ("ScanUrlMachine: MACHINENAME\n"));
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanChangeType(DWORD *pToken)
{
    PWSTR pszToken;
    BOOL fReturn = FALSE;

    if (!GetToken(&pszToken)) {
        return FALSE;
    }
    if (_wcsicmp(pszToken,L"changetype:") == 0) {
        RuleLast = RS_CHANGET;
        TokenExpect = RT_ADM;
        *pToken = T_CHANGETYPE;
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanChangeType: T_CHANGETYPE\n"));
        fReturn = TRUE;
    }
    else {
        RollBack();
    }
    if (pszToken) {
        MemFree(pszToken);
    }
    return fReturn;
}

BOOL ScanType(DWORD *pToken)
{
    PWSTR pszToken = NULL;
    BOOL fReturn = FALSE;

    if (!GetToken(&pszToken)) {
        return FALSE;
    }
    if (wcscmp(pszToken,L":") == 0) {
        RuleLast = RS_C;
        TokenExpect = RT_VALUE;
        *pToken = SINGLECOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"version:") == 0) {
        RuleLast=RS_VERSION;
        TokenExpect=RT_DIGITS;
        *pToken = VERSION;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"dn:") == 0) {
        RuleLast=RS_DN;
        TokenExpect=RT_VALUE;
        *pToken = DNCOLON;
        fReturn = TRUE;
        g_dwBeginLine = Line;
    }
    else if (_wcsicmp(pszToken,L"dn::") == 0) {
        RuleLast = RS_DND;
        TokenExpect = RT_BASE64;
        *pToken = DNDCOLON;
        fReturn = TRUE;
        g_dwBeginLine = Line;
    }
    else if (wcscmp(pszToken,L"::") == 0) {
        RuleLast = RS_DC;
        TokenExpect = RT_BASE64;
        *pToken = DOUBLECOLON;
        fReturn = TRUE;
    }
    else if (wcscmp(pszToken,L":<") == 0) {
        RuleLast = RS_URLC;
        TokenExpect = RT_URL;
        *pToken = URLCOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"modrdn") == 0) {
        yylval.num = 0;
        
        RuleLast = RS_MDN;
        TokenExpect = RT_NDN;
        *pToken = MODRDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemamodrdn") == 0) {
        yylval.num = 1;
        RuleLast = RS_MDN;
        TokenExpect = RT_NDN;
        *pToken = NTDSMODRDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"moddn") == 0) {
        RuleLast = RS_MDN;
        TokenExpect = RT_NDN;
        *pToken = MODDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newrdn:") == 0) {
        RuleLast = RS_NRDNC;
        TokenExpect = RT_VALUE;
        *pToken = NEWRDNCOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newrdn::") == 0) {
        RuleLast = RS_NRDNDC;
        TokenExpect = RT_BASE64;
        *pToken = NEWRDNDCOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"deleteoldrdn:") == 0) {
        RuleLast = RS_DORDN;
        TokenExpect = RT_DIGITS;
        *pToken = DELETEOLDRDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newsuperior:") == 0) {
        RuleLast = RS_NEWSUP;
        TokenExpect = RT_VALUE;
        *pToken = NEWSUPERIORC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newsuperior::") == 0) {
        RuleLast = RS_NEWSUPD;
        TokenExpect = RT_BASE64;
        *pToken = NEWSUPERIORDC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"delete:") == 0) {
        RuleLast = RS_DELETEC;
        TokenExpect = RT_ATTRNAMENC;
        *pToken = DELETEC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"replace:") == 0) {
        RuleLast = RS_REPLACEC;
        TokenExpect = RT_ATTRNAMENC;
        *pToken = REPLACEC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"add") == 0) {
        yylval.num = 0;
        RuleLast = RS_C_ADD;
        TokenExpect = RT_ATTRNAME;
        *pToken = ADD;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemaadd") == 0) {
        yylval.num = 1;
            
        RuleLast = RS_C_ADD;
        TokenExpect = RT_ATTRNAME;
        
        *pToken = NTDSADD;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"delete") == 0) {
        yylval.num = 0;
            
        RuleLast = RS_C_DELETE;
        TokenExpect = RT_CH_OR_SEP;
        
        *pToken = MYDELETE;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemadelete") == 0) {
        yylval.num = 1;
            
        RuleLast = RS_C_DELETE;
        TokenExpect = RT_CH_OR_SEP;
        
        *pToken = NTDSMYDELETE;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"add:") == 0) {
        RuleLast = RS_ADDC;
        TokenExpect = RT_ATTRNAMENC;
        
        *pToken = ADDC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"-") == 0) {
        RuleLast = RS_MINUS;
        TokenExpect = RT_CH_OR_SEP;
        
        *pToken = MINUS;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"modify") == 0) {
        yylval.num = 0;
        
        RuleLast = RS_C_MODIFY;
        TokenExpect = RT_ACDCRC;
        
        *pToken = MODIFY;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemamodify") == 0) {
        yylval.num = 1;
        
        RuleLast = RS_C_MODIFY;
        TokenExpect = RT_ACDCRC;

        *pToken = NTDSMODIFY;
        fReturn = TRUE;
    }
    if (fReturn) {
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanType: %S\n",pszToken));
    }
    else {
        RollBack();
    }
    if (pszToken) {
        MemFree(pszToken);
    }
    return fReturn;
}

BOOL GetToken(PWSTR *pszToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    BOOL fFirstColon = FALSE;
    STR_INIT();
    
    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (c == ' ' || c == '\n' || c == '\t') {
        UnGetCharFiltered(c);
        BAIL();
    }

    do {
        if (c == ' ' || c == '\n' || c == '\t') {
            UnGetCharExFiltered(c);
            *pszToken = MemAllocStrW_E(STR_VALUE());
            fReturn = TRUE;
            BAIL();
        }
        if (fFirstColon) {
            //
            // If we have hit the first colon already, and we hit another colon
            // or '<', we'll add them to the string and exit
            //
            if ((c == ':') || (c == '<')) {
                STR_ADDCHAR(c);
                break;
            }
            //
            // If we have hit another random char, it is the start of another
            // token already and thus we'll put it back 
            //
            else {
                UnGetCharExFiltered(c);
                break;          
            }
        }
        if (c == ':') {
            fFirstColon = TRUE;
        }
        STR_ADDCHAR(c);
    } while (GetNextCharExFiltered(&c,FALSE));
    *pszToken = MemAllocStrW_E(STR_VALUE());
    fReturn = TRUE;
    
error:
    STR_FREE();
    return fReturn;
}

BOOL IsDigit(WCHAR c)
{
    if ((c >= '0') && (c <= '9')) {
        return TRUE;
    }
    return FALSE;
}

BOOL Is64Char(WCHAR c) 
{
    if (c >= 'A' && c <= 'Z') {
        return TRUE;
    }
    if (c >= 'a' && c <= 'z') {
        return TRUE;
    }
    if (c >= '0' && c <= '9') {
        return TRUE;
    }
    if (c == '+' || c == '=' || c == '/') {
        return TRUE;
    }
    return FALSE;
}
    
BOOL Is64CharEnd(WCHAR c)
{
    if (!(c >= 0x21 && c <= 0x7e)) {
        return TRUE;
    }
    return FALSE;
}

BOOL IsNameChar(WCHAR c) 
{
    if (!((c >= 0 && c <= 0x1f) || 
          (c >= 0x7f && c <= 0xff) ||
          (c == ':'))) {
        return TRUE;        
    }
    return FALSE;
}

BOOL IsURLChar(WCHAR c) 
{
    if (!((c == '\n') ||
          (c == '/')  ||
          (c == ' ')  ||
          (c == 0x00))) {
        return TRUE;
    }
    return FALSE;
}

BOOL IsVal(WCHAR c) 
{
    if (c >= 0x20 && c <= 0xffff) {
        return TRUE;
    }
    return FALSE;
}

BOOL IsValInit(WCHAR c) 
{
    if (!((c >= 0x00 && c <=0x1f) ||
          (c == ':' || c == '<' || c == ' '))) {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\ldifutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldifutil.h

ABSTRACT:

     Utilities for LDIF library

REVISION HISTORY:

--*/
#ifndef _LDIFUTIL_H
#define _LDIFUTIL_H

#define HIGER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

RTL_GENERIC_COMPARE_RESULTS
NtiComp( PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct );
RTL_GENERIC_COMPARE_RESULTS
NtiCompW( PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct );
PVOID NtiAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize );
VOID NtiFree ( RTL_GENERIC_TABLE *Table, PVOID Buffer );

/*
DWORD SubStr(LPSTR szInput,
             LPSTR szFrom,
             LPSTR szTo,
             LPSTR *pszOutput);
*/

DWORD SubStrW(PWSTR szInput,
              PWSTR szFrom,
              PWSTR szTo,
              PWSTR *pszOutput);

wchar_t * __cdecl wcsistr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        );

void
ConvertUnicodeToUTF8(
    PWSTR pszUnicode,
    DWORD dwLen,
    PBYTE *ppbValue,
    DWORD *pdwLen
    );

void
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *ppszUnicode,
    DWORD *pdwLen
    );

BOOLEAN IsUTF8String(
    PCSTR pSrcStr,
    int cchSrc);

ULONG LDAPAPI ldif_ldap_add_sW(
    LDAP *ld,
    PWCHAR dn,
    LDAPModW *attrs[],
    BOOL fLazyCommit
    );

ULONG LDAPAPI ldif_ldap_delete_sW(
    LDAP *ld,
    const PWCHAR dn,
    BOOL fLazyCommit
    );

ULONG LDAPAPI ldif_ldap_modify_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *mods[],
    BOOL fLazyCommit
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\ldifldap.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ldifldap.c

Abstract:

    This file implements the support code for the ldif parser

Environment:

    User mode

Revision History:

    07/17/99 -t-romany-
        Created it

    05/12/99 -felixw-
        Rewrite + unicode support

--*/
#include <precomp.h>
#include "samrestrict.h"
#include "ntldap.h"

//
// Global to/from strings
//
PWSTR g_szImportTo = NULL;
PWSTR g_szImportFrom = NULL;
PWSTR g_szExportTo = NULL;
PWSTR g_szExportFrom = NULL;

PWSTR g_szFileFlagR = NULL;         // Flag for reading files

PWSTR g_szPrimaryGroup = L"primaryGroupID";
PSTR  g_szDefaultGroup = "513";

PWSTR g_rgszOmit[] = { L"replPropertyMetaData",
                       NULL };

PWSTR g_rgszAttrList[] = { L"ldapDisplayName",
                           L"linkid",
                           NULL };

PWSTR g_rgszSchemaList[] = { L"schemaNamingContext",
                             L"defaultNamingContext",
                             L"supportedControl",
                             NULL };

PWSTR g_rgszControlsList[] = { L"supportedControl",
                               NULL };


struct change_list *g_pChangeCur = NULL;
struct change_list *g_pChangeStart = NULL;

//
// Used to build up the list of attribute value specs
//
struct l_list   *g_pListStart     = NULL;
struct l_list   *g_pListCur       = NULL;
DWORD           g_dwListElem      = 0;

//
// Various variables for file manipulations
//
FILE        *g_pFileIn                    = NULL;

ULONG               g_nBacklinkCount     = 0;
int                 g_nClassLast         = LOC_NOTSET;
PRTL_GENERIC_TABLE  g_pOmitTable         = NULL;
HASHCACHESTRING     *g_pBacklinkHashTable = NULL;


LDIF_Error 
LDIF_InitializeImport(
    LDAP *pLdap,
    PWSTR szFilename, 
    PWSTR szFrom, 
    PWSTR szTo,
    BOOL *pfLazyCommitAvail) 
{
    WCHAR       szTempPathname[MAX_PATH]    = L"";
    LDIF_Error    error;

    BOOL fLazyCommitAvail = FALSE;
    LDAPMessage     *pSearchMessage = NULL;
    LDAPMessage     *pMessage = NULL;
    struct berelement *pBerElement = NULL;
    PWSTR *rgszVal = NULL;
    PWSTR szAttribute = NULL;
    ULONG LdapError;
    ULONG msgnum;


    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    //
    // Setting up global replacement strings
    //
    g_szImportFrom = szFrom;
    g_szImportTo = szTo;

    __try {


        //
        // Test lazy commit availability.
        //

        if (pfLazyCommitAvail) {
            
            msgnum = ldap_searchW(pLdap,
                                  NULL,
                                  LDAP_SCOPE_BASE,
                                  L"(objectClass=*)",
                                  g_rgszControlsList,
                                  0);

            LdapError = LdapResult(pLdap, msgnum, &pSearchMessage);
        
            if ( LdapError != LDAP_SUCCESS ) {
                //
                // RootDSE search fails
                // pfLazyCommitAvail will be FALSE as well
                //
                fLazyCommitAvail = FALSE;
            }
            else {

                for ( pMessage = ldap_first_entry( pLdap,
                                                   pSearchMessage );
                      pMessage != NULL;
                      pMessage = ldap_next_entry( pLdap,
                                                     pMessage ) ) {
                    for (   szAttribute = ldap_first_attributeW( pLdap, pMessage, &pBerElement );
                            szAttribute != NULL;
                            szAttribute = ldap_next_attributeW( pLdap, pMessage, pBerElement ) ) {

                            if (_wcsicmp(L"supportedControl",szAttribute) == 0) {
                                DWORD i = 0;
                                rgszVal = ldap_get_valuesW( pLdap, pMessage, szAttribute );

                                while (rgszVal[i]) {
                                    if (wcscmp(rgszVal[i],LDAP_SERVER_LAZY_COMMIT_OID_W) == 0) {
                                        fLazyCommitAvail = TRUE;
                                        break;
                                    }
                                    i++;
                                }

                                ldap_value_freeW(rgszVal);
                                rgszVal = NULL;
                            }
                           
                            szAttribute = NULL;
                    }

                    pBerElement = NULL;
                }

                if (pSearchMessage) {
                    ldap_msgfree(pSearchMessage);
                    pSearchMessage = NULL;
                }
            }

            *pfLazyCommitAvail = fLazyCommitAvail;
        }



        //
        // Initialize filetype to non known
        //
        FileType = F_NONE;  

        //
        // If user has not turned on the unicode flag, open file to check 
        // whether it is a unicode file
        //
        if (g_fUnicode == FALSE) {
            FILE *pFileIn;
            WCHAR wChar;
            if ((pFileIn = _wfopen(szFilename, L"rb")) == NULL) {
                ERR(("Failed opening file %S\n",szFilename));
                RaiseException(LL_FILE_ERROR, 0, 0, NULL);
            }
            wChar = fgetwc(pFileIn);
            if (wChar == WEOF) {
                fclose(pFileIn);
                ERR(("Failed getting first character of file %S\n",szFilename));
                RaiseException(LL_FILE_ERROR, 0, 0, NULL);
            }
            if (wChar == UNICODE_MARK) {
                g_fUnicode = TRUE;
            };
            fclose(pFileIn);
        }

        //
        // Setting up global file read\write flags
        //
        g_szFileFlagR = L"rb";
    
        if ((g_pFileIn = _wfopen(szFilename, g_szFileFlagR)) == NULL) {
            ERR(("Failed opening file %S\n",szFilename));
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }

        if (!(GetTempPath(MAX_PATH, szTempPathname))) {
            DWORD WinError = GetLastError();
            ERR(("Failed getting tempory path: %d\n",WinError));
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }

        if (!(GetTempFileName(szTempPathname, L"ldif", 0, g_szTempUrlfilename))) {
            DWORD WinError = GetLastError();
            ERR(("Failed getting tempory filename: %d\n",WinError));
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }


        yyout = stdout;
        yyin = g_pFileIn;

        LexerInit(szFilename);


    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
        LDIF_CleanUp();
    }

    return error;
}

LDIF_Error 
LDIF_InitializeExport(
    LDAP* pLdap,
    PWSTR *rgszOmit,
    DWORD dwFlag,
    PWSTR *ppszNamingContext,
    PWSTR szFrom,
    PWSTR szTo,
    BOOL *pfPagingAvail,
    BOOL *pfSAMAvail) 
{
    LDIF_Error        error;
    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    //
    // Setting up global replacement strings
    //
    g_szExportFrom = szFrom;
    g_szExportTo = szTo;

    __try {
        samTablesCreate();
        CreateOmitBacklinkTable(pLdap,
                                rgszOmit,
                                dwFlag,
                                ppszNamingContext,
                                pfPagingAvail,
                                pfSAMAvail);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
    }

    return error;
}


//+---------------------------------------------------------------------------
// Function:    GenereateModFromAttr
//
// Synopsis:
//   The function below takes the attribute name and the attribute value, and 
//   an indication of whether its a text value or a binary to be BERval'd 
//   (ValueSize == length of buffer)
//   and returns an LDAPMod pointer representing the attribute modification.
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
LDAPModW *
GenereateModFromAttr(
    PWSTR szType, 
    PBYTE pbValue, 
    long ValueSize) 
{
    LDAPModW_Ext *pModTmp;
    PWSTR szOutput = NULL;
    PWSTR szValueW = NULL;
    DWORD dwSize = 0;
    PBYTE pbUTF8 = NULL;

    pModTmp = (LDAPModW_Ext*)MemAlloc_E(sizeof(LDAPModW_Ext));
    pModTmp->mod_type = MemAllocStrW_E(szType);

    if (ValueSize==-1) {
        pModTmp->mod_bvalues=
            (struct berval **)MemAlloc_E(2*sizeof(struct berval *));

        (pModTmp->mod_bvalues)[0]=
            (struct berval *)MemAlloc_E(sizeof(struct berval));

        pModTmp->mod_op = BINARY;
        pModTmp->fString = TRUE;
        szValueW = MemAllocStrW_E((PWSTR)pbValue);

        //
        // The parser will pass in a static "" string to represent a null
        // string. In that case, we don't need to free it.
        //
        if (*((PWSTR)pbValue))
            MemFree(pbValue);

        if (g_szImportFrom) {
            SubStrW(szValueW,
                    g_szImportFrom,
                    g_szImportTo,
                    &szOutput);
            if (szOutput == NULL) {
                szOutput = szValueW;
                szValueW = NULL;
            }
        }
        else {
            szOutput = szValueW;
            szValueW = NULL;
        }

        ConvertUnicodeToUTF8(szOutput,
                             wcslen(szOutput),
                             &pbUTF8,
                             &dwSize);

        ((pModTmp->mod_bvalues)[0])->bv_val = pbUTF8;
        ((pModTmp->mod_bvalues)[0])->bv_len = dwSize;
        (pModTmp->mod_bvalues)[1] = NULL;
    }
    else {
        pModTmp->fString = FALSE;
        pModTmp->mod_bvalues=
            (struct berval **)MemAlloc_E(2*sizeof(struct berval *));

        (pModTmp->mod_bvalues)[0]=
            (struct berval *)MemAlloc_E(sizeof(struct berval));

        pModTmp->mod_op = BINARY;
        ((pModTmp->mod_bvalues)[0])->bv_val = pbValue;
        ((pModTmp->mod_bvalues)[0])->bv_len = ValueSize;
        (pModTmp->mod_bvalues)[1] = NULL;
    }

    //
    // Clearing out
    //
    if (szValueW) {
        MemFree(szValueW);
    }
    if (szOutput) {
        MemFree(szOutput);
    }
    return (PLDAPModW)pModTmp;
}


void 
AddModToSpecList(
    LDAPModW *pMod
    )
{
    if (g_pListCur==NULL) {
        g_pListCur = (struct l_list *)MemAlloc_E(sizeof(struct l_list));
        g_pListCur->mod = pMod;
        g_pListCur->next = NULL;
        g_pListStart = g_pListCur;
        g_dwListElem++;
    }
    else {
        g_pListCur->next = (struct l_list *)MemAlloc_E(sizeof(struct l_list));
        g_pListCur = g_pListCur->next;
        g_pListCur->mod = pMod;
        g_pListCur->next = NULL;
        g_dwListElem++;
    }
}


//+---------------------------------------------------------------------------
// Function:    GenerateModFromList
//
// Synopsis:
//   This function takes the current linked list of elements and converts
//   it to to an LDAPMod** array which can passed to an LDAP API call.
//   All the elements of the linked list, other than those that will
//   be necessary for the new structure will be freed, making memory available
//   for the next attrval list. Note: the mod_op field will not be assigned here.
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
LDAPModW** 
GenerateModFromList(
    int nMode
    ) 
{
    LDAPModW **ppModTmp = NULL;
    LDAPModW **ppModReturn = NULL;
    struct l_list *pListNext = NULL;
    struct name_entry *pNameEntry = NULL;
    DWORD dwElements, i;
    PRTL_GENERIC_TABLE pTable = NULL;
    PNAME_MAP pNameMap = NULL;


    if (nMode==PACK) {
        //
        // an exception will be generated if the below fails
        //
        pTable = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
        RtlInitializeGenericTable(pTable,
                                  NtiCompW, NtiAlloc, NtiFree, NULL);

        //
        // If we've been told to pack, we must do many, many things
        //
        pNameEntry = (struct name_entry *)
                        MemAlloc_E(g_dwListElem*sizeof(struct name_entry));

        //
        // setup the name table
        //
        if (NameTableProcess(pNameEntry,
                        g_dwListElem,
                        SETUP,
                        g_pListStart->mod->mod_op,
                        g_pListStart->mod,
                        pTable)) {
            //
            // Note that NameTableProcess only returns 1 if it runs into memory
            // problems. Since, in the release version (without the DEVELOP
            // flag), those would generate exceptions, control would never
            // even get here, so this perror and its friends in this
            // function would never actually be reached.
            //
            ERR_RIP(("Failed setting up nametable!\n"));
        }

        //
        // count how many of each name we have
        //
        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            if (NameTableProcess(pNameEntry,
                             g_dwListElem,
                             COUNT,
                             g_pListCur->mod->mod_op,
                             g_pListCur->mod,
                             pTable)) {
                ERR_RIP(("Failed counting nametable!\n"));
            }
            pListNext =g_pListCur->next;
            g_pListCur = pListNext;
        }

        //
        // Lets allocate memory for each value now
        // Note: this can obviously be done without iterating over the start
        // list because all the necessary information is already in the name
        // table, but doing it this way is more consistent with the overall
        // scheme of things. (albeit a bit more expensive, however LDAP
        // accesses are orders of magnitude slower than any memory
        // machinations, so it doesn't even matter)
        //

        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            if (NameTableProcess(pNameEntry,
                             g_dwListElem,
                             ALLOC,
                             g_pListCur->mod->mod_op,
                             g_pListCur->mod,
                             pTable)) {
                ERR_RIP(("Failed allocating nametable!\n"));
            }
            pListNext = g_pListCur->next;
            g_pListCur = pListNext;
        }

        //
        // And finally, we place each value in its rightful place
        //
        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            if (NameTableProcess(pNameEntry,
                             g_dwListElem,
                             PLACE,
                             g_pListCur->mod->mod_op,
                             g_pListCur->mod,
                             pTable)) {
                ERR_RIP(("Failed placing nametable!\n"));
            }
            pListNext = g_pListCur->next;
            g_pListCur = pListNext;
        }

        //
        // Let's get rid of the name to index RTL table. Note that the pointers
        // in the Nti actually pointed to strings in our original list,
        // which we free down below.
        //

        for (pNameMap = RtlEnumerateGenericTable(pTable, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pTable, TRUE)) {
            RtlDeleteElementGenericTable(pTable, pNameMap);
        }

        if (RtlIsGenericTableEmpty(pTable)==FALSE) {
            ERR_RIP(("Table is empty!\n"));
            RaiseException(LL_INTERNAL_PARSER, 0, 0, NULL);
        }

        MemFree(pTable);

        //
        // At this point, all the values have been moved over to the name
        // table, and the name table has everything we need to build a new
        // LDAPMod array. The only remaining problem are the allocated names
        // and arrays in the linked list.
        // Lets first free the linked list (and the names in the contained
        // LDAPMod structs).
        //
        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            MemFree(g_pListCur->mod->mod_type);

            //
            // the actual values are being pointed to from the table now
            //
            if (g_pListCur->mod->mod_op==REGULAR) {
                MemFree(g_pListCur->mod->mod_values);
            }
            else {
                MemFree(g_pListCur->mod->mod_bvalues);
            }
            MemFree(g_pListCur->mod);
            pListNext = g_pListCur->next;
            MemFree(g_pListCur);
            g_pListCur = pListNext;
        }

        //
        // Now that all the old data is gone, lets go through the nametable
        // generating the LDAPMod** array we're going to return
        //

        //
        // but first we must count how many actual elements we have
        //
        dwElements = 0;
        while((dwElements<g_dwListElem) && (pNameEntry[dwElements].count!=0) )
            dwElements++;

        //
        // allocate this much plus one for the NULL
        //
        ppModReturn = (LDAPModW **)MemAlloc_E((dwElements+1)*sizeof(LDAPModW *));
        ppModTmp = ppModReturn;

        for(i=0; i<dwElements; i++) {
            (*ppModTmp) = (LDAPModW*)pNameEntry[i].mod;
            ppModTmp++;
        }
        (*ppModTmp) = NULL;

        MemFree(pNameEntry);

    }
    else if (nMode==EMPTY) {
        //
        // allocate just one item for the NULL
        //
        ppModReturn = (LDAPModW **)MemAlloc_E(sizeof(LDAPModW *));
        ppModTmp = ppModReturn;
        (*ppModTmp) = NULL;
    }
    else {

        ppModReturn = (LDAPModW **)MemAlloc_E((g_dwListElem+1)*sizeof(LDAPModW *));
        ppModTmp = ppModReturn;

        //
        // Walk the list and assign the values
        //
        g_pListCur = g_pListStart;

        while(g_pListCur!=NULL) {
            (*ppModTmp) = g_pListCur->mod;
            ppModTmp++;
            pListNext = g_pListCur->next;
            MemFree(g_pListCur);
            g_pListCur = pListNext;
        }

        (*ppModTmp) = NULL;
    }

    //
    // reset the stuff for the next list
    //
    g_dwListElem = 0;
    g_pListCur = NULL;
    g_pListStart = NULL;

    return ppModReturn;
}


//+---------------------------------------------------------------------------
// Function:  FreeAllMods
//
// Synopsis:
//      This function takes an LDAPMod ** and frees all memory associated
//      with it
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
FreeAllMods(
    LDAPModW** ppModIn
    ) 
{
    PWSTR           *rgszValues = NULL;
    struct berval   **rgpBerval = NULL;
    LDAPModW        **ppMod     = NULL;

    ppMod = ppModIn;

    if (ppModIn!=NULL) {
        while((*ppModIn)!=NULL) {

            if ( (*ppModIn)->mod_op != (((*ppModIn)->mod_op)|LDAP_MOD_BVALUES )) {

                //
                // Its a regular value, so we must free an array of strings
                //
                // Note: the comparison checked whether ORing the value with
                // LDAP_MOD_BVALUES changes it. If it does, then it wasn't ORed
                // before and thus its a regular value. If it doesn't change it,
                // then it was OR'ed before and is thus a Bvalue
                //

                rgszValues = (*ppModIn)->mod_values;

                if (rgszValues!=NULL) {

                    while ((*rgszValues)!=NULL) {
                        MemFree (*rgszValues);
                        rgszValues++;
                    }

                    MemFree((*ppModIn)->mod_values);
                }
            }
            else {

                //
                // its a bvalue
                //
                rgpBerval = (*ppModIn)->mod_bvalues;

                if (rgpBerval!=NULL) {
                    while ((*rgpBerval)!=NULL) {
                        MemFree ((*rgpBerval)->bv_val);   //free the byte blob
                        MemFree (*rgpBerval);             //free the struct
                        rgpBerval++;
                    }
                    MemFree((*ppModIn)->mod_bvalues);
                }
            }

            MemFree((*ppModIn)->mod_type);
            MemFree(*ppModIn);

            ppModIn++;
        }
        MemFree(ppMod);
    }
}

void free_mod(
    LDAPModW* pMod
    ) 
{
    struct berval **rgpBerval = NULL;

    if (pMod!=NULL) {
        rgpBerval = pMod->mod_bvalues;
        if (rgpBerval!=NULL) {
            while ((*rgpBerval)!=NULL) {
                MemFree ((*rgpBerval)->bv_val);   //free the byte blob
                MemFree (*rgpBerval);             //free the struct
                rgpBerval++;
            }
            MemFree(pMod->mod_bvalues);
        }

        MemFree(pMod->mod_type);
        MemFree(pMod);
    }
}

//+---------------------------------------------------------------------------
// Function: SetModOps
//
// Synopsis:
//      The function below walks through a modifications list and sets the
//      mod_op fields to the indicated value
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
SetModOps(
    LDAPModW** ppMod, 
    int op
    ) 
{
    while((*ppMod)!=NULL) {
        (*ppMod)->mod_op = (*ppMod)->mod_op|op;
        ppMod++;
    }
}


//+---------------------------------------------------------------------------
// Function:    NameTableProcess
//
// Synopsis:
//
//      This function takes an LDAPMod and a pointer to a name table and
//      performs the specified table operation on it. It returns 0 on success
//      and non-zero on error. See inside the function for further information.
//
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int NameTableProcess(
            struct name_entry rgNameEntry[],
            long nTableSize,
            int op,
            int ber,
            LDAPModW *pModIn,
            PRTL_GENERIC_TABLE pTable
            )
{
    long        i,j;
    NAME_MAPW   Elem;
    PNAME_MAPW  pElemTemp;
    BOOLEAN     fNewElement;
    PWSTR       szName;

    szName = pModIn->mod_type;

    //
    // First, lets create the actual Element to use with our indexing table
    //
    Elem.szName = szName;
    Elem.index = 0;

    //
    // try to find it in our indexing table
    //
    pElemTemp = RtlLookupElementGenericTable(pTable, &Elem);

    //
    // if it was found, get the index into our primary name table
    // if it wasn't get the next available index and create the new entry
    //
    if (pElemTemp) {
        i = pElemTemp->index;
    }
    else {
        i = RtlNumberGenericTableElements(pTable);
        Elem.index = i;
        RtlInsertElementGenericTable(pTable,
                                     &Elem,
                                     sizeof(NAME_MAP),
                                     &fNewElement);
        if (fNewElement==FALSE) {
            // "Re-insertion of indexing entry
            RaiseException(LL_INTERNAL_PARSER, 0, 0, NULL);
        }
    }

    switch(op) {

        case SETUP:
            //
            // The name in the LDAPMod struct given will be ignored.
            // This is a call to set up the table of names
            //
            for (i = 0; i<nTableSize; i++) {
                rgNameEntry[i].count = 0;
            }
            break;

        case COUNT:
            //
            // Here is what we do here:
            // If the count is 0, that means we're at a new name. So lets set it
            // up and leave. If the count is not, lets increment.
            //
            if (rgNameEntry[i].count==0) {
                //
                // Since we're using an LDAPMod struct to keep track of names
                // and stuff, we have to allocate one
                ///
                rgNameEntry[i].mod = (LDAPModW_Ext *)MemAlloc_E(sizeof(LDAPModW_Ext));
                rgNameEntry[i].mod->mod_type = MemAllocStrW_E(szName);

                //
                // Use the mod_op field of the struct to flag whether memory for
                // the values has yet been alloc'd
                //
                rgNameEntry[i].mod->mod_op = NOT_ALLOCATED;
                rgNameEntry[i].count = 1;
                return 0;
            }
            else {
                //
                // Another instance of a name we have
                //
                rgNameEntry[i].count++;
                return 0;
            }
            break;

        case ALLOC:
            //
            // For the name given, we allocate the memory needed
            // for all the values.
            // If the same name is given twice, the computer will
            // explode.
            // (note: the above was a joke.
            // Once the memory has been allocated once,
            // all remaiing mentions of the name will be ignored).
            //
            if (rgNameEntry[i].mod->mod_op==NOT_ALLOCATED) {
                if (ber==REGULAR) {

                    rgNameEntry[i].mod->mod_values =
                        (PWSTR*)MemAlloc_E((rgNameEntry[i].count+1)*sizeof(PWSTR));

                    for (j=0; j<(rgNameEntry[i].count+1); j++) {
                        (rgNameEntry[i].mod->mod_values)[j]=NULL;
                    }

                    rgNameEntry[i].next_val = rgNameEntry[i].mod->mod_values;
                    rgNameEntry[i].mod->mod_op = ALLOCATED;
                }
                else {

                    rgNameEntry[i].mod->mod_bvalues=
                        (struct berval **)MemAlloc_E((rgNameEntry[i].count+
                               1)*sizeof(struct berval *));

                    for (j=0; j<(rgNameEntry[i].count+1); j++) {
                        (rgNameEntry[i].mod->mod_bvalues)[j]=NULL;
                    }

                    rgNameEntry[i].next_bval=rgNameEntry[i].mod->mod_bvalues;
                    rgNameEntry[i].mod->mod_op=ALLOCATED_B;
                }
            }
            else {
                //
                // Check for more than one type in the multiple values of
                // a single attribute. Explained in ldifext.h
                //
                if ( ((rgNameEntry[i].mod->mod_op==ALLOCATED_B)
                        &&(ber==REGULAR)) ||
                    ((rgNameEntry[i].mod->mod_op==ALLOCATED)
                        &&(ber==BINARY)) ) {
                    RaiseException(LL_MULTI_TYPE, 0, 0, NULL);
                }
            }
            return 0;
            break;

        case PLACE:
        {
            LDAPModW_Ext *pExt = (LDAPModW_Ext*)pModIn;
            rgNameEntry[i].mod->fString = pExt->fString;

            //
            // Now that we've counted and allocated memory for values, We can
            // place them. Note that we're actually Just passing around pointers
            // without reallocing the memory.
            //
            if (ber==REGULAR) {
                //
                // Now that we're done using the mod_op for the sinister
                // purposes of allocating, we can set it to the proper value for
                // the type. We set it to 0 if its a regular value and we OR it
                // with LDAP_MOD_BVALUES if its a bval. The SetModOps function
                // will then add its own thing by also OR'ing. Note that this
                // implies that one cannot specifiy multiple values of both
                // types in one LDIF record. I am aware that doing it here is
                // somewhat redundant, as every multi-value will set mod_op,
                // however it costs next to nothing and is convinient.
                ///
                rgNameEntry[i].mod->mod_op = 0;

                //
                // And now place the value
                //
                *(rgNameEntry[i].next_val) = (pModIn->mod_values)[0];
                (rgNameEntry[i].next_val)++;
            }
            else {
                rgNameEntry[i].mod->mod_op = LDAP_MOD_BVALUES;
                *(rgNameEntry[i].next_bval) = (pModIn->mod_bvalues)[0];
                (rgNameEntry[i].next_bval)++;
            }
            break;
        }
    }

    return 0;
}

void 
ChangeListAdd(
    struct change_list *pList
    ) 
{
    if (g_pChangeCur==NULL) {
        g_pChangeCur = pList;
        g_pChangeStart = pList;
        g_pChangeCur->next = NULL;
    }
    else {
        g_pChangeCur->next = pList;
        g_pChangeCur = pList;
        g_pChangeCur->next = NULL;
    }
}


void 
ProcessException (
    DWORD exception, 
    LDIF_Error *pError
    )
{
    if (exception==STATUS_NO_MEMORY) {
        pError->error_code=LL_MEMORY_ERROR;
    }
    else if ((exception==LL_SYNTAX) || (exception==LL_MISSING_MOD_SPEC_TERMINATOR) ||
             (exception==LL_MULTI_TYPE) ||
             (exception==LL_EXTRA) || (exception==LL_INTERNAL_PARSER) ||
             (exception==LL_FTYPE) || (exception==LL_URL)) {
        pError->token_start = cLast;

        //
        // Pass ownership of the buffer to the error blob
        //
        pError->szTokenLast = g_pszLastToken;
        g_pszLastToken = NULL;

        pError->error_code = exception;
        if (Line > 0) {
            //
            // An extern from yylex()
            // rgLineMap is only initialized when we reach the second
            // line following a newline.  So if it isn't initialized,
            // we must still be on the first line of the file.
            //
            pError->line_number = rgLineMap ? rgLineMap[Line-1] : 1;
        }
        //
        // the array was built without the version: 1
        // we have to readjust...
        //
        pError->RuleLastBig = RuleLastBig;
        pError->RuleLast = RuleLast;
        pError->RuleExpect = RuleExpect;
        pError->TokenExpect = TokenExpect;
    }
    else {
        pError->error_code = exception;
    }
}

void 
LDIF_CleanUp() 
{
    fEOF = FALSE;
    FileType = F_NONE;

    samTablesDestroy();

    LexerFree();

    //
    // Normally, g_pObject & g_pListStart get cleaned up
    // as we finish parsing a record.  If they're non-NULL,
    // we must have hit an error while parsing, and we clean
    // them up now.
    //
    if (g_pObject.pszDN) {
        MemFree(g_pObject.pszDN);
        g_pObject.pszDN = NULL;
    }

    if (g_pListStart) {
        struct l_list *pListNext;
        struct l_list *pListCurElem = NULL;
        pListCurElem = g_pListStart;

        while(pListCurElem!=NULL) {
            free_mod(pListCurElem->mod);
            pListNext = pListCurElem->next;
            MemFree(pListCurElem);
            pListCurElem = pListNext;
        }

        g_pListStart = NULL;
        g_pListCur = NULL;
        g_dwListElem = 0;
    }

    if (g_pFileIn) {
        fclose(g_pFileIn);
        g_pFileIn = NULL;
    }

    if (g_pFileUrlTemp) {
        fclose(g_pFileUrlTemp);
        g_pFileUrlTemp = NULL;
    }

#ifndef LEAVE_TEMP_FILES
    if (g_szTempUrlfilename[0]) {
        DeleteFile(g_szTempUrlfilename);
        swprintf(g_szTempUrlfilename, L"");
    }
#endif

    if (rgLineMap) {
        MemFree(rgLineMap);
        rgLineMap = NULL;
    }

    LineClear = 0;
    Line = 0;
    LineGhosts = 0;

    if (g_pszLastToken) {
        MemFree(g_pszLastToken);
        g_pszLastToken = NULL;
    }
}

LDIF_Error 
LDIF_Parse(
    LDIF_Record *pRecord
    ) 
{

    LDIF_Error        error = {0};
    int             nReturnCode;

    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    __try {
        //
        // Unfortunately, we can't do this through an exception from yywrap.
        // yywrap needs to exit peacefully for yyparse to complete succesfully.
        //
        if (fEOF) {
            //
            // I thought of raising an exception here, but then that
            // would call LDIF_CleanUp and kill the heap, which would trash the last
            // returned entry. So I just set the error and leave.
            //
            error.error_code = LL_EOF;
            return error;
        }

        //
        // Set up for changes
        //
        g_pChangeStart = NULL;
        g_pChangeCur = NULL;

        //
        // Return the next entry
        //
        nReturnCode = yyparse();
        if (nReturnCode == 1)
            RaiseException(LL_SYNTAX, 0, 0, NULL);

        //
        // Note that an exception may have been raised here from yyparse or
        // yylex. Now lets set EOF if we hit it, so user knows not to call
        // ldif_parse again
        //
        if (fEOF) {
            error.error_code = LL_EOF;
        }

        if (nReturnCode==LDIF_REC) {
            pRecord->fIsChangeRecord = FALSE;
            pRecord->content = g_pObject.ppMod;
        }
        else {
            pRecord->fIsChangeRecord = TRUE;
            pRecord->changes = g_pChangeStart;
        }

        if (g_szImportFrom) {
            pRecord->dn = NULL;
            SubStrW(g_pObject.pszDN,
                   g_szImportFrom,
                   g_szImportTo,
                   &pRecord->dn);
            if (pRecord->dn) {
                if (g_pObject.pszDN) {
                    MemFree(g_pObject.pszDN);
                    g_pObject.pszDN = NULL;
                }
            }
            else {
                if (g_pObject.pszDN) {
                    pRecord->dn = MemAllocStrW_E(g_pObject.pszDN);
                    MemFree(g_pObject.pszDN);
                    g_pObject.pszDN = NULL;
                }
                else {
                    pRecord->dn = NULL;
                }
            }
        }
        else {
            if (g_pObject.pszDN) {
                pRecord->dn = MemAllocStrW_E(g_pObject.pszDN);
                MemFree(g_pObject.pszDN);
                g_pObject.pszDN = NULL;
            }
            else {
                pRecord->dn = NULL;
            }
        }

        //error.line_number=rgLineMap[Line-1];
        error.line_begin=rgLineMap[g_dwBeginLine-1];

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
    }

    return error;
}


LDIF_Error 
LDIF_LoadRecord(
    LDAP *pLdap, 
    LDIF_Record *pRecoard, 
    int nActive, 
    BOOL fLazyCommit,
    BOOLEAN fCallTerminateIfFail
    ) 
{
    struct change_list  *pListCurrent;
    int                 LdapError;
    LDIF_Error            LdifError;
    PWSTR               pszDN = NULL;

    LdifError.error_code    = LL_SUCCESS;
    LdifError.szTokenLast = NULL;

    //
    // mattrim Oct-30-2000
    // Previously, fCallTerminateIfFail was used to determine whether to
    // call LDIF_Cleanup if loading a record failed.  The following code
    // was in the exception handler to do this:
    //
    //    //
    //    // the err was set by the call before the exception occurred
    //    //
    //    if (fCallTerminateIfFail) {
    //        LDIF_Cleanup();
    //    }
    //
    // I've changed the LDIF library to put the responsibility for calling
    // LDIF_Cleanup on the user of the libbrary.
    //
    UNREFERENCED_PARAMETER(fCallTerminateIfFail);

    __try {

        if (pRecoard->fIsChangeRecord==FALSE) {
            if (nActive==1) {
                if ((LdapError=ldif_ldap_add_sW(pLdap, pRecoard->dn, 
                            pRecoard->content, fLazyCommit)) !=LDAP_SUCCESS) {
                    ERR(("ldif_ldapadd returns %d\n",LdapError));
                    RaiseException(LL_LDAP, 0, 0, NULL);
                }
            }
        }
        else {
            pListCurrent = pRecoard->changes;
            while(pListCurrent!=NULL) {
                if (pListCurrent->dn_mem) {
                    pszDN = MemAllocStrW_E(pListCurrent->dn_mem);
                }

                switch(pListCurrent->operation) {

                case CHANGE_ADD:
                    if (nActive==1) {
                        if ((LdapError=ldif_ldap_add_sW(pLdap, pRecoard->dn,
                                   pListCurrent->mods_mem, fLazyCommit)) != 
                             LDAP_SUCCESS) {
                            ERR(("ldif_ldapadd returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_DEL:
                    if (nActive==1) {
                        if ((LdapError=ldif_ldap_delete_sW(pLdap, pRecoard->dn,
                                fLazyCommit)) !=LDAP_SUCCESS) {
                            ERR(("ldif_ldapdelete returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_DN:
                    if (nActive==1) {
                        ULONG msgnum = ldap_modrdn2W(pLdap,
                                                       pRecoard->dn,
                                                       pszDN,
                                                       pListCurrent->deleteold);

                        LdapError = LdapResult(pLdap, msgnum, NULL);
                        
                        if (LdapError!=LDAP_SUCCESS) {
                           ERR(("ldapmodrdn returns %d\n",LdapError));
                           RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_MOD:
                    if (nActive==1) {
                        if ((LdapError=ldif_ldap_modify_sW(pLdap,
                                                pRecoard->dn,
                                                pListCurrent->mods_mem,
                                                fLazyCommit))
                                                !=LDAP_SUCCESS) {
                            ERR(("ldif_ldapmodify returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSADD:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_add_sW(pLdap,
                                                  pRecoard->dn,
                                                  pListCurrent->mods_mem))!=LDAP_SUCCESS) {
                            ERR(("ldapadd returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSDEL:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_delete_sW(pLdap,
                                                     pRecoard->dn))
                                                        !=LDAP_SUCCESS) {
                            ERR(("ldapdelete returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSDN:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_modrdn2_sW(pLdap,
                                                      pRecoard->dn,
                                                      pszDN,
                                                      pListCurrent->deleteold))
                                                        !=LDAP_SUCCESS) {
                           ERR(("ldapmod returns %d\n",LdapError));
                           RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSMOD:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_modify_sW(pLdap,
                                                     pRecoard->dn,
                                                     pListCurrent->mods_mem))
                                                        !=LDAP_SUCCESS) {
                        ERR(("ldapmod returns %d\n",LdapError));
                        RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;
                }

                pListCurrent = pListCurrent->next;

                if (pszDN) {
                    MemFree(pszDN);
                    pszDN = NULL;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        ProcessException(GetExceptionCode(), &LdifError);

        if (pszDN) {
            MemFree(pszDN);
            pszDN = NULL;
        }
        LdifError.ldap_err = LdapError;
        
    }

    return LdifError;
}


LDIF_Error LDIF_ParseFree(
    LDIF_Record *pRecord
    ) 
{

    struct change_list  *pListCurrent;
    struct change_list  *pListStart;
    LDIF_Error LdifError;

    LdifError.error_code = LL_SUCCESS;
    LdifError.szTokenLast = NULL;

    __try {

        if (pRecord->fIsChangeRecord==FALSE) {
            if (pRecord->content) {
                FreeAllMods(pRecord->content);
                pRecord->content = NULL;
            }
            if (pRecord->dn) {
                MemFree(pRecord->dn);
                pRecord->dn = NULL;
            }
        }
        else if (pRecord->fIsChangeRecord==TRUE) {
            //
            // Walk the changes list
            //
            pListStart=pRecord->changes;
            pListCurrent=pListStart;
            while(pListCurrent!=NULL) {
                //
                // first order of business is to process the change specified
                // and free change specific memory (the stuff in the union)
                //
                switch(pListCurrent->operation) {
                    case CHANGE_ADD:
                    case CHANGE_NTDSADD:
                        if (pListCurrent->mods_mem) {
                            FreeAllMods(pListCurrent->mods_mem);
                            pListCurrent->mods_mem = NULL;
                        }
                        break;

                    case CHANGE_DN:
                    case CHANGE_NTDSDN:
                        if (pListCurrent->dn_mem) {
                            MemFree(pListCurrent->dn_mem);
                            pListCurrent->dn_mem = NULL;
                        }
                        break;
                    case CHANGE_MOD:
                    case CHANGE_NTDSMOD:
                        if (pListCurrent->mods_mem) {
                            FreeAllMods(pListCurrent->mods_mem);
                            pListCurrent->mods_mem = NULL;
                        }
                        break;
                }
                //
                // now that the union memory has been freed, lets move and kill
                // this node
                //
                pListStart=pListCurrent;

                //
                // I am aware this is not necessary on the first el.
                //
                pListCurrent=pListCurrent->next;
                MemFree(pListStart);
            }

            //
            // reset the start, the current was reset by the last loop pass
            //
            pListStart = NULL;
            pRecord->changes = NULL;
            if (pRecord->dn) {
                MemFree(pRecord->dn);
                pRecord->dn = NULL;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &LdifError);
    }

    return LdifError;

}

LDIF_Error 
LDIF_GenerateEntry(
    LDAP        *pLdap,
    LDAPMessage *pMessage,
    PWSTR       **prgReturn,
    BOOLEAN     fSamLogic,
    BOOLEAN     fIgnoreBinary,
    PWSTR       **pppszAttrsWithRange,
    BOOL        fAttrsWithRange)
{
    PWSTR szDN = NULL;
    PWSTR szDNW = NULL;
    PWSTR szDNFinal = NULL;
    PWSTR szTemp = NULL;
    PWSTR szAttribute = NULL;
    PWSTR *rgszAttributes = NULL;
    PWSTR *rgszResult = NULL;
    WCHAR szTrailer[] = L"\r\n";
    WCHAR szRegular[] = L": ";
    WCHAR szB64[] = L":: ";
    WCHAR szWrapper[] = L"\r\n ";
    WCHAR szDNCommonStart[] = L"dn: ";
    WCHAR szDNB64Start[] = L"dn:: ";
    PWSTR szDNStart = NULL, szTmpDN = NULL;

    struct berelement *pBerElement;
    struct berval     **rgpVals;

    DWORD dwB64 = wcslen(szB64);
    DWORD dwTrailer = wcslen(szTrailer);
    DWORD dwRegular = wcslen(szRegular);
    DWORD dwWrapper = wcslen(szWrapper);
    DWORD dwAttrname, dwAttrNoRange;
    DWORD dwTemp;
    DWORD dwLeft;

    DWORD dwCount;
    DWORD j;
    DWORD dwEveryAttr;
    DWORD dwManyAttr;
    DWORD dwValCount;
    DWORD dwTotalStrings;
    DWORD iNextString;
    DWORD dwStrPos;
    long lSets78;

    LDIF_Error            error;
    PNAME_MAP           pNtiPtr;
    NAME_MAP            NtiElem;
    PNAME_MAP           pNtiElemTemp;

    BOOLEAN             bWrapMarker;
    DWORD               iCheckAttr;
    BOOLEAN             bSamSkip;
    BOOLEAN             bNewElem;
    BOOLEAN             bBase64;

    BOOLEAN             bBackLink = FALSE;
    BOOLEAN             bBase64DN = FALSE;
    PWSTR               szCur;

    PWSTR szReplacedAttrW = NULL;
    PWSTR szTempW         = NULL;
    PWSTR szAttributeW    = NULL;
    PWSTR szAttrNoRange   = NULL;
    PWSTR *rgszValW       = NULL;
    PWSTR *rgszVal        = NULL;

    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;
    error.the_modify = -1;

    __try {

        //
        // Getting the DN
        //
        szDNW = ldap_get_dnW( pLdap,
                              pMessage );

        //
        // This is a special case, we sub the DN before trying to convert to
        // B64
        //
        if (g_szExportFrom) {
            PWSTR szOutput;

            SubStrW(szDNW,
                    g_szExportFrom,
                    g_szExportTo,
                    &szDNFinal);
        }
        if (szDNFinal == NULL) {
            szDNFinal = MemAllocStrW_E(szDNW);
        }

        //
        // In ANSI mode, unicode DNs have to be displayed as B64 format
        // Check DN to see if it is unicode, if it is unicode, we'll export as
        // B64.
        //
        if (g_fUnicode == FALSE) {
            szCur = szDNFinal;
            while (*szCur) {
                if (((*szCur)<0x20) ||
                    ((*szCur)>0xFF)) {
                    //
                    // This string contains non-ANSI value, use B64 format
                    //
                    bBase64DN = TRUE;
                    break;
                }
                szCur++;
            }
        }

        if (bBase64DN) {
            DWORD dwSize;
            PBYTE pbUTF8;

            ConvertUnicodeToUTF8(szDNFinal,
                                 wcslen(szDNFinal),
                                 &pbUTF8,
                                 &dwSize);

            szDN = base64encode(pbUTF8,
                                dwSize);
            dwSize = wcslen(szDN);

            MemFree(pbUTF8);
            szDNStart = szDNB64Start;
        }
        else {
            szDN = MemAllocStrW_E(szDNFinal);
            szDNStart = szDNCommonStart;
        }

        //
        // Allocating RETURN STRING. Calculate the number of strings needed to
        // be returned in total by looking at all the attributes
        //
        iCheckAttr = 0;
        dwTotalStrings = 0;
        pBerElement = NULL;
        dwManyAttr = 0;

        for (   szAttribute = ldap_first_attribute( pLdap,
                                                    pMessage,
                                                    &pBerElement );
                szAttribute != NULL;
                szAttribute = ldap_next_attribute( pLdap,
                                                   pMessage,
                                                   pBerElement ) ) {
            PWSTR szTmpAttr =  NULL;

            dwManyAttr++;
            rgszVal = ldap_get_values( pLdap, pMessage, szAttribute);

            // make sure that the comparison is only with the attribute name
            // and not with any range specifiers follwing the attribute name.
            szTmpAttr = StripRangeFromAttr(szAttribute);
         
            if (!_wcsicmp(L"objectClass",szTmpAttr)) {
                if (!iCheckAttr) {
                    iCheckAttr = samCheckObject(rgszVal);
                }
            }

            dwValCount = ldap_count_values(rgszVal);

            //
            // Allocate Extra Space if attribute is backlinks
            //
            if (fSamLogic) {
                if (SCGetAttByName(wcslen(szTmpAttr),
                                   szTmpAttr) == TRUE) {
                    dwTotalStrings += (dwValCount * 5);
                }
            }
            else if(fAttrsWithRange)
            // if there are attributes with range specifiers, then we need
            // 2 strings per attribute - one for "add <attr>: ..." and one
            // for the '-' at the end
                dwTotalStrings += (dwValCount * 2);

            if(szTmpAttr)
                MemFree(szTmpAttr);

            dwTotalStrings+=dwValCount;
            ldap_value_free(rgszVal);
            rgszVal = NULL;
        }

        dwTotalStrings+=10;  // for miscellaneous stuff
        rgszResult=(PWSTR*)MemAlloc_E(dwTotalStrings*sizeof(PWSTR));


        iNextString=0;
        pBerElement=NULL;

        // create a temporary string containing the DN for this entry
        szTmpDN = (PWSTR)MemAlloc_E((wcslen(szDN) +
                                wcslen(szDNStart)+dwTrailer+1)*sizeof(WCHAR));
        memcpy(szTmpDN, szDNStart, wcslen(szDNStart) * sizeof(WCHAR));
        dwStrPos=wcslen(szDNStart);
        memcpy(szTmpDN+dwStrPos, szDN, wcslen(szDN) * sizeof(WCHAR));
        dwStrPos+=wcslen(szDN);
        memcpy(szTmpDN+dwStrPos, szTrailer, (dwTrailer+1) * sizeof(WCHAR));
        MemFree(szDN);
        szDN = NULL;
        

        //
        // Setting up Entry. If we are here because of attributes with range, 
        // then we want to set up a modify entry in the export file (done 
        // later). We should setup an add entry only if we are not here due
        // to an attribute with a range specifier.
        //
        if(FALSE == fAttrsWithRange)
        {
            rgszResult[iNextString]=(PWSTR)MemAllocStrW_E(szTmpDN);
            iNextString++;

            rgszResult[iNextString]=MemAllocStrW_E(L"changetype: add\r\n");
            iNextString++; 
        }

        //
        // Put the attributes into a sortable array
        //
        rgszAttributes=(PWSTR*)MemAlloc_E(dwManyAttr*sizeof(PWSTR));
        dwEveryAttr = 0;
        for ( szAttribute = ldap_first_attribute(pLdap, pMessage, &pBerElement);
              szAttribute != NULL;
              szAttribute = ldap_next_attribute(pLdap, pMessage, pBerElement)) {
              rgszAttributes[dwEveryAttr++]=MemAllocStrW_E(szAttribute);
        }

        if (fSamLogic) {
            qsort((void *)rgszAttributes,
                  (size_t)dwManyAttr,
                  sizeof(PWSTR),
                  LoadedCompare);
        }

        for (dwEveryAttr=0; dwEveryAttr < dwManyAttr; dwEveryAttr++) {

            int i;
            bBackLink = FALSE;
            szAttribute = rgszAttributes[dwEveryAttr];
            dwAttrname = wcslen(szAttribute);
            // free string if previous iteration of for loop did 'continue'
            if(szAttrNoRange)
            {
                MemFree(szAttrNoRange);
                szAttrNoRange = NULL;
            }
            szAttrNoRange = StripRangeFromAttr(szAttribute);
            dwAttrNoRange = wcslen(szAttrNoRange);
            rgpVals = ldap_get_values_len( pLdap, pMessage, szAttribute );
            dwValCount = ldap_count_values_len(rgpVals);

            //
            // if values contain bytes outside our permissible range of
            // printables, all values of this attribute will be base64 encoded.
            //
            bBase64 = FALSE;
            for (i=0; rgpVals[i]!=NULL; i++) {
                if (g_fUnicode) {
                    if (!IsUTF8String(rgpVals[i]->bv_val,
                                      rgpVals[i]->bv_len)) {
                        bBase64 = TRUE;
                        break;
                    }
                    else {
                        //
                        // If it is a UTF8 unicode string, we'll convert it to
                        // unicode and test whether all values are > 0x20, if
                        // they are not, we display them as base64
                        //
                        DWORD dwLen = 0;
                        PWSTR pszUnicode = NULL;
                        DWORD l = 0;

                        ConvertUTF8ToUnicode(
                            rgpVals[i]->bv_val,
                            rgpVals[i]->bv_len,
                            &pszUnicode,
                            &dwLen
                            );
    
                        if (pszUnicode) {
                            while (l<(dwLen-1)) {
                                if (pszUnicode[l] < 0x20) {
                                    bBase64 = TRUE;
                                    break;
                                }
                                l++;
                            }

                            if (!bBase64 && dwLen > 1) {
                                //
                                // If the value starts with a prohibited
                                // initial character (SPACE, :, <), or ends
                                // with a space, must base-64 encode
                                // (clauses 4, 8 of LDIF standard)
                                //
                                if ( (pszUnicode[0] == 0x20) ||     // init. space
                                     (pszUnicode[0] == 0x3A) ||     // init. :
                                     (pszUnicode[0] == 0x3C) ||     // init. <
                                     (pszUnicode[dwLen-2] == 0x20) )// final space
                                {
                                    bBase64 = TRUE;
                                }
                            }
                            
                            MemFree(pszUnicode);
                            pszUnicode = NULL;
                        }
                    }
                }
                else {
                    for (j=0; j<rgpVals[i]->bv_len; j++) {
                        if (!g_fUnicode) {
                            if (((rgpVals[i]->bv_val)[j]<0x20)
                                    ||((rgpVals[i]->bv_val)[j]>0x7E)) {
                                bBase64 = TRUE;
                                break;
                            }
                        }
                    }

                    if (!bBase64 && rgpVals[i]->bv_len > 0) {
                        //
                        // If the value starts with a prohibited
                        // initial character (SPACE, :, <), or ends
                        // with a space, must base-64 encode
                        // (clauses 4, 8 of LDIF standard)
                        //
                        if ( ((rgpVals[i]->bv_val)[0] == 0x20) ||   // init. space
                             ((rgpVals[i]->bv_val)[0] == 0x3A) ||   // init. :
                             ((rgpVals[i]->bv_val)[0] == 0x3C) ||   // init. <
                             ((rgpVals[i]->bv_val)[rgpVals[i]->bv_len - 1] == 0x20) ) // final space
                        {
                            bBase64 = TRUE;
                        }
                    }
                }
                if (bBase64)
                    break;
            }

            //
            // omit if its on our sam lists
            //
            bSamSkip = FALSE;
            if (iCheckAttr) {
                bSamSkip = samCheckAttr(szAttrNoRange, iCheckAttr);
            }

            //
            // omit if its on our user list.
            //
            NtiElem.szName = szAttrNoRange;
            NtiElem.index = 0;
            pNtiElemTemp = RtlLookupElementGenericTable(g_pOmitTable,
                                                        &NtiElem);


            //
            // Do the S_MEM special action, if it is a backlink, will be last
            //
            if (fSamLogic) {
                if (SCGetAttByName(wcslen(szAttrNoRange),
                                   szAttrNoRange
                                   ) == TRUE) {
                    if (_wcsicmp(szAttrNoRange,g_szPrimaryGroup) == 0) {
                        if ((rgpVals[0]->bv_len == strlen(g_szDefaultGroup)) && 
                            (memcmp(rgpVals[0]->bv_val,
                                   g_szDefaultGroup,
                                   strlen(g_szDefaultGroup)*sizeof(CHAR)) == 0)
                            ) {
                            //
                            // If the primarygroup value is the same as default,
                            // we just ignore it when the object is actually
                            // being created, the default value will be put in
                            //
                            bBackLink = FALSE;
                            bSamSkip = TRUE;
                        }
                        else {
                            //
                            // If the value is not default, we will append it
                            // (treat it as backlink). It cannot accompany the
                            // rest of the object because this operation will
                            // fail if the group does not exist yet
                            //
                            bBackLink = TRUE;
                        }
                    }
                    else {
                        bBackLink = TRUE;
                    }
                }
            }

            //
            // don't write if its on the sam prohibited list
            //
            if (fSamLogic && bSamSkip) {
                ldap_value_free_len(rgpVals);            
                continue;
            }

            //
            // don't write if its on the omit list
            //
            if (pNtiElemTemp) {
                ldap_value_free_len(rgpVals);            
                continue;
            }

            if (fSamLogic && 
                ((_wcsicmp(L"objectGUID", szAttrNoRange) == 0) ||
                 (_wcsicmp(L"isCriticalSystemObject", szAttrNoRange) == 0))
               ) {
                ldap_value_free_len(rgpVals);               
                continue;
            }

            if (bBackLink && (error.the_modify == -1)) {
                error.the_modify = iNextString+1;
            }

            if (fIgnoreBinary && bBase64) {
                ldap_value_free_len(rgpVals);
                continue;
            }

            if((FALSE == bBackLink) && fAttrsWithRange && (0 == dwEveryAttr))
            {
                rgszResult[iNextString]=(PWSTR)MemAllocStrW_E(szTmpDN);
                iNextString++;

                rgszResult[iNextString] = MemAllocStrW_E(
                                               L"changetype: modify\r\n");
                iNextString++;
            }

            //
            // In unicode mode, if the string is UTF8 encode, we still have to
            // test whether it has any invalid values. If it does, we'll have
            // to use b64 format
            //
            if (g_fUnicode && !bBase64) {
                DWORD l;
                ASSERT(szAttributeW == NULL && rgszValW == NULL);
                szAttributeW = MemAllocStrW_E(szAttribute);
                rgszValW = ldap_get_valuesW( pLdap, pMessage, szAttributeW);
                for (l=0; rgszValW[l]!=NULL; l++) {
                    PWSTR szCurrent = rgszValW[l];
                    while (*szCurrent) {
                        if (*szCurrent < 32) {
                            bBase64 = TRUE;
                            goto processvalue;
                        }
                        szCurrent++;
                    }
                }
            }

processvalue:
            if (bBase64) {

                //
                // Binary Value
                //

                for (i=0; rgpVals[i]!=NULL; i++) {
                    if (bBackLink) {
                        WCHAR szBuffer[256];
                        // start a new entry
                        rgszResult[iNextString++]=MemAllocStrW_E(L"\r\n");
                        //copy the DN
                        rgszResult[iNextString++]=MemAllocStrW_E(szTmpDN);
                        rgszResult[iNextString++]=MemAllocStrW_E(L"changetype: modify\r\n");
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }
                    else if(fAttrsWithRange) {
                        WCHAR szBuffer[256];
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }

                    szTemp = base64encode((PBYTE)rgpVals[i]->bv_val,
                                          rgpVals[i]->bv_len);
                    dwTemp = wcslen(szTemp);

                    //
                    // break into sets, 78 to make room for wrapping newline and
                    // space
                    //
                    lSets78=dwTemp/78;
                    dwLeft=dwTemp%78;

                    //
                    // if we the length of our name plus the length of
                    // the value exceeds 80, we need to put in a wrap.
                    //
                    bWrapMarker=0;
                    if ((lSets78==0) &&
                        ((dwAttrNoRange+dwB64+dwTemp+dwTrailer)>80)) {
                        bWrapMarker=1;
                        dwTemp+=dwWrapper;
                    } else if (lSets78>0) {
                        bWrapMarker=1;
                        dwTemp= dwWrapper         // Initial wrapper
                                + (lSets78*(78+dwWrapper)) // Each line with wrapper
                                + dwLeft;         // last line
                    }

                    rgszResult[iNextString]=(PWSTR)MemAlloc_E(
                                    (dwAttrNoRange+dwB64+dwTemp+dwTrailer+1)*sizeof(WCHAR));
                    memcpy(rgszResult[iNextString],
                           szAttrNoRange,
                           dwAttrNoRange * sizeof(WCHAR));
                    dwStrPos=dwAttrNoRange;

                    // if this attribute has a range associated with it, then 
                    // we may have to make another search request to fetch the
                    // remaining values. Store off the range values for the
                    // next search request, if required.
                    if(dwAttrNoRange != dwAttrname) // range present
                        GetNewRange(szAttribute, dwAttrNoRange, szAttrNoRange,
                            dwManyAttr, pppszAttrsWithRange);

                    memcpy(rgszResult[iNextString]+dwStrPos,
                           szB64,
                           dwB64*sizeof(WCHAR));
                    dwStrPos+=dwB64;

                    if (bWrapMarker) {
                        memcpy(rgszResult[iNextString]+dwStrPos,
                                szWrapper,
                                dwWrapper * sizeof(WCHAR));
                        dwStrPos+=dwWrapper;
                    }

                    if (lSets78>0) {
                        dwCount=0;
                        while (lSets78>0) {
                            memcpy(rgszResult[iNextString]+dwStrPos,
                                                szTemp+(dwCount*78), 78 * sizeof(WCHAR));
                            dwStrPos+=78;
                            dwCount++;
                            lSets78--;
                            //
                            // Don't put in wrapper if last line and no spaces left
                            //
                            if (lSets78 !=0 || dwLeft != 0) {
                                    memcpy(rgszResult[iNextString]+dwStrPos,
                                           szWrapper, 
                                           dwWrapper * sizeof(WCHAR));
                                    dwStrPos+=dwWrapper;
                            }
                        }
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szTemp+(dwCount*78), 
                               dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;
                    } else {
                        memcpy(rgszResult[iNextString]+dwStrPos, szTemp, dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;
                    }

                    memcpy(rgszResult[iNextString]+dwStrPos,
                           szTrailer, 
                           (dwTrailer+1) * sizeof(WCHAR));

                    iNextString++;
                    MemFree(szTemp);
                    szTemp = NULL;

                    if (bBackLink || fAttrsWithRange) {
                        rgszResult[iNextString++]=MemAllocStrW_E(L"-\r\n");
                    }
                }
            }
            else {

                //
                // Get the values if we haven't got them yet
                //
                if (rgszValW == NULL) {
                    ASSERT(szAttributeW == NULL);
                    szAttributeW = MemAllocStrW_E(szAttribute);
                    rgszValW = ldap_get_valuesW( pLdap, pMessage, szAttributeW);
                }

                //
                // String Value
                //
                for (i=0; rgpVals[i]!=NULL; i++) {
                    if (bBackLink) {
                        WCHAR szBuffer[256];
                        rgszResult[iNextString++]=MemAllocStrW_E(L"\r\n");
                        rgszResult[iNextString++]=MemAllocStrW_E(szTmpDN); //copy the DN
                        rgszResult[iNextString++]=MemAllocStrW_E(L"changetype: modify\r\n");
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }
                    else if(fAttrsWithRange) {
                        WCHAR szBuffer[256];
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }

                    ASSERT(szReplacedAttrW == NULL);
                    ASSERT(szTemp == NULL);

                    szTempW = rgszValW[i];
                    if (g_szExportFrom) {
                        SubStrW(rgszValW[i],
                                g_szExportFrom,
                                g_szExportTo,
                                &szReplacedAttrW);
                    }
                    if (szReplacedAttrW != NULL) {
                        szTempW = szReplacedAttrW;
                    }
                    szTemp = MemAllocStrW_E(szTempW);

                    dwTemp = wcslen(szTemp);

                    //
                    // break into sets, 78 to make room for wrapping newline and space
                    //
                    lSets78=dwTemp/78;
                    dwLeft=dwTemp%78;

                    //
                    // if the length of our name plus the length
                    // of the value exceeds 80, need to put in a wrap.
                    //
                    bWrapMarker = FALSE;
                    if ((lSets78==0) &&
                        ((dwAttrNoRange+dwRegular+dwTemp+dwTrailer)>80)) {
                        bWrapMarker = TRUE;
                        dwTemp+=dwWrapper;              // The initial wrapper
                    }
                    else if (lSets78>0) {
                        bWrapMarker = TRUE;
                        dwTemp= dwWrapper       // Initial wrapper
                                + (lSets78*(78+dwWrapper))  // Each line with wrapper
                                + dwLeft;       // last line
                    }

                    rgszResult[iNextString]=(PWSTR)
                                MemAlloc_E((dwAttrNoRange+dwRegular+dwTemp+dwTrailer+1)
                                                                    *sizeof(WCHAR));
                    memcpy(rgszResult[iNextString], szAttrNoRange, dwAttrNoRange * sizeof(WCHAR));
                    dwStrPos=dwAttrNoRange;

                    // if this attribute has a range associated with it, then
                    // we may have to make another search request to fetch the
                    // remaining values. Store off the range values for the
                    // next search request, if required.
                    if(dwAttrNoRange != dwAttrname) // range present
                        GetNewRange(szAttribute, dwAttrNoRange, szAttrNoRange,
                            dwManyAttr, pppszAttrsWithRange);

                    memcpy(rgszResult[iNextString]+dwStrPos, szRegular, dwRegular * sizeof(WCHAR));
                    dwStrPos+=dwRegular;

                    if (bWrapMarker) {
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szWrapper,
                               dwWrapper * sizeof(WCHAR));
                        dwStrPos+=dwWrapper;
                    }

                    if (lSets78>0) {
                        dwCount=0;
                        while (lSets78>0) {
                            memcpy(rgszResult[iNextString]+dwStrPos,
                                   szTemp+(dwCount*78),
                                   78 * sizeof(WCHAR));
                            dwStrPos+=78;
                            dwCount++;
                            lSets78--;
                            //
                            // Don't put in wrapper if last line and no spaces left
                            //
                            if (lSets78 !=0 || dwLeft != 0) {
                                memcpy(rgszResult[iNextString]+dwStrPos,
                                       szWrapper,
                                       dwWrapper * sizeof(WCHAR));
                                dwStrPos+=dwWrapper;
                            }

                        }
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szTemp+(dwCount*78),
                               dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;

                    } else {
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szTemp,
                               dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;
                    }

                    memcpy(rgszResult[iNextString]+dwStrPos,
                           szTrailer,
                           (dwTrailer+1) * sizeof(WCHAR));
                    iNextString++;
                    // don't need to free temp because its part of vals
                    if (bBackLink || fAttrsWithRange) {
                        rgszResult[iNextString++]=MemAllocStrW_E(L"-\r\n");
                    }
                    if (szReplacedAttrW) {
                        MemFree(szReplacedAttrW);
                        szReplacedAttrW = NULL;
                    }
                    if (szTemp) {
                        MemFree(szTemp);
                        szTemp = NULL;
                    }
                }
            }
            if (szAttributeW) {
                MemFree(szAttributeW);
                szAttributeW = NULL;
            }
            if(szAttrNoRange) {
                MemFree(szAttrNoRange);
                szAttrNoRange = NULL;
            }
            if (rgszValW) {
                ldap_value_freeW(rgszValW);
                rgszValW = NULL;
            }
            ldap_value_free_len(rgpVals);
        }

        // ldap_memfree((PWSTR)pBerElement);
        pBerElement=NULL;

        *prgReturn = rgszResult;
        rgszResult[iNextString] = NULL;

        for (dwEveryAttr=0; dwEveryAttr < dwManyAttr; dwEveryAttr++) {
            MemFree(rgszAttributes[dwEveryAttr]);
        }
        MemFree(rgszAttributes);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
    }
    
    if (szDNW) {
        ldap_memfreeW(szDNW);
    }
    if (szDN) {
        MemFree(szDN);
    }
    if (szDNFinal) {
        MemFree(szDNFinal);
    }
    if (szReplacedAttrW) {
        MemFree(szReplacedAttrW);
        szReplacedAttrW = NULL;
    }
    if (szTemp) {
        MemFree(szTemp);
        szTemp = NULL;
    }
    if (szAttributeW) {
        MemFree(szAttributeW);
        szAttributeW = NULL;
    }
    if(szAttrNoRange) {
        MemFree(szAttrNoRange);
        szAttrNoRange = NULL;
    }
    if(szTmpDN) {
        MemFree(szTmpDN);
        szTmpDN = NULL;
    }
    if (rgszValW) {
        ldap_value_freeW(rgszValW);
        rgszValW = NULL;
    }
    if (rgszVal) {
        ldap_value_freeW(rgszVal);
        rgszVal = NULL;
    }
    return error;
}


LDIF_Error 
LDIF_FreeStrs(
    PWSTR* pszFree
    ) 
{
    long i = 0;
    LDIF_Error error;

    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    if (pszFree) {
        while(pszFree[i]) {
            MemFree(pszFree[i]);
            i++;
        }
        MemFree(pszFree);
    }

    return error;
}


//+---------------------------------------------------------------------------
// Function:    samTablesCreate
//
// Synopsis:
//    The goal of this routine is to set up the tables necessary for the SAM
//    exclusions. These tables are generated form the arrays found in
//    samrestrict.h, which are PAINFULLY hand generated from src\dsamain\src\mappings.c
//    The pointers to the tables are also declared in samrestrict.h.
//    There are 6 tables that the lookup functions will need. One if for samCheckObject()
//    to check whether the objectClass in LDIF_GenerateEntry() is one under our watch.
//    The remaining 5 are for each of the objects so that samCheckAttr() can find out
//    whether the attribute we want to add is on the prohibited list. Called from LL_init()
//
// Arguments:
//    None. We access the tables and variables in samrestrict.h
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
samTablesCreate() 
{
    long i;
    PNAME_MAP   NtiPtr;
    NAME_MAP    NtiElem;
    PNAME_MAP   PElemTemp;
    BOOLEAN     NewElem;

    // note that an exception will be generated if the below fails
    pSamObjects = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pSamObjects, NtiComp, NtiAlloc, NtiFree, NULL);


    i = 0;
    while(SamObjects[i]) {
        NtiElem.szName=SamObjects[i];
        //
        // The index information is important here, because it wil be returned
        // by samCheckObject() if the object is found and passed to
        // samCheckAttr() so it knows which table to look at
        //
        NtiElem.index = i+1;
        RtlInsertElementGenericTable(pSamObjects,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    //
    // Then create the tables for each object. This will be used by
    // samCheckAttr()
    //
    pServerAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pServerAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(samServer[i]) {
        NtiElem.szName=samServer[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pServerAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pDomainAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pDomainAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(domain[i]) {
        NtiElem.szName=domain[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pDomainAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pGroupAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(group[i]) {
        NtiElem.szName=group[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pGroupAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pLocalGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pLocalGroupAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(localgroup[i]) {
        NtiElem.szName=localgroup[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pLocalGroupAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pUserAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pUserAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(user[i]) {
        NtiElem.szName=user[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pUserAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pSpecial = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pSpecial, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(special[i]) {
        NtiElem.szName=special[i];
        NtiElem.index=actions[i];  //The what-to-do
        if (NtiElem.index==0) {
            // Special table and action table mismatch
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        RtlInsertElementGenericTable(pSpecial,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            // Re-insertion of indexing entry!
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }
}


//+---------------------------------------------------------------------------
// Function:    samTablesDestroy
//
// Synopsis:
//    Destroy the tables created by samTablesCreate()
//    called from LDIF_CleanUp().
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
samTablesDestroy() 
{
     PNAME_MAP   pNameMap;

     if (pSamObjects) {
        for (pNameMap = RtlEnumerateGenericTable(pSamObjects, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pSamObjects, TRUE))
            {
                RtlDeleteElementGenericTable(pSamObjects, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pSamObjects)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pSamObjects);
        pSamObjects=NULL;
     }

     if (pServerAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pServerAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pServerAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pServerAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pServerAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pServerAttrs);
        pServerAttrs=NULL;
     }

     if (pDomainAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pDomainAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pDomainAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pDomainAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pDomainAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pDomainAttrs);
        pDomainAttrs=NULL;
     }

     if (pGroupAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pGroupAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pGroupAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pGroupAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pGroupAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pGroupAttrs);
        pGroupAttrs=NULL;
     }

     if (pLocalGroupAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pLocalGroupAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pLocalGroupAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pLocalGroupAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pLocalGroupAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pLocalGroupAttrs);
        pLocalGroupAttrs=NULL;
     }

     if (pUserAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pUserAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pUserAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pUserAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pUserAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pUserAttrs);
        pUserAttrs=NULL;
     }

     if (pSpecial) {
        for (pNameMap = RtlEnumerateGenericTable(pSpecial, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pSpecial, TRUE))
            {
            //printf("Deleting %s.\n",pNameMap->name);
                RtlDeleteElementGenericTable(pSpecial, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pSpecial)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pSpecial);
        pSpecial=NULL;
     }

    //
    // Removing RTL Table and attributes .
    // Pointers in NTI points to strings in orginal list and need not be freed.
    //
    if (g_pOmitTable) {
        for (pNameMap = RtlEnumerateGenericTable(g_pOmitTable, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(g_pOmitTable, TRUE)) {
            PWSTR szLinkDN;
            szLinkDN = pNameMap->szName;
            RtlDeleteElementGenericTable(g_pOmitTable, pNameMap);
            MemFree(szLinkDN);
        }
        if (RtlIsGenericTableEmpty(g_pOmitTable)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        MemFree(g_pOmitTable);
        g_pOmitTable = NULL;
    }

    if (g_pBacklinkHashTable) {
        UINT i;
        for (i=0;i<g_nBacklinkCount;i++) {
            if (g_pBacklinkHashTable[i].bUsed) {
                MemFree(g_pBacklinkHashTable[i].value);
            }
        }
        MemFree(g_pBacklinkHashTable);
        g_pBacklinkHashTable = NULL;
    }
}

//+---------------------------------------------------------------------------
// Function:    samCheckObject
//
// Synopsis:
//  samCheckObject() - this function will be called
//  from LDIF_GenerateEntry() to determine whether the
//  object we are looking at is on our sam watch list.
//
// Arguments:
//  class - a value of the objectClass attribute.
//          This function will be called
//          on every value of objectClass received to
//          determine whether this object or any of its
//          ancestors are on our watch list.
//
// Returns:
//          0 if the object was not found
//          or 1-5 indicating which table samCheckAttr()
//          should look at it. This number was set by samTablesCreate()
//          in the index member of the table entry.
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int 
samCheckObject(
    PWSTR *rgszVal
    )
{
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMap;
    int i = 0;

    NameMap.index = 0;

    //
    // Find the last item
    //
    while (rgszVal[i]!=NULL) {
        i++;
    }
    i--;

    //
    // Search from end to beginning to speed up common objects such as group
    // and users
    //
    while (i>=0) {
        NameMap.szName = rgszVal[i];

        pNameMap = RtlLookupElementGenericTable(pSamObjects, &NameMap);
    
        if (pNameMap) 
            return pNameMap->index;

        i--;
    }
    return 0;
}


//+---------------------------------------------------------------------------
// Function:    samCheckAttr
//
// Synopsis:
//      Given the number of the table to look at and
//      an attribute name, this function will figure out
//      if the attribute is on the "no-no" list. This function
//      gets the number returned by samCheckObject();
//
// Arguments:
//      attribute: the name of the attrbiute to look up
//      table:     the number of the table to look at
//
// Returns:
//      TRUE  - this attrbiute is prohibited
//      FALSE - this attribute is allowed
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
BOOLEAN 
samCheckAttr(
    PWSTR szAttribute, 
    int TableType
    ) 
{
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMap = NULL;

    NameMap.szName = szAttribute;
    NameMap.index = 0;

    switch(TableType) {
        case 1:
            pNameMap = RtlLookupElementGenericTable(pServerAttrs, &NameMap);
            break;
        case 2:
            pNameMap = RtlLookupElementGenericTable(pDomainAttrs, &NameMap);
            break;
        case 3:
            pNameMap = RtlLookupElementGenericTable(pGroupAttrs, &NameMap);
            break;
        case 4:
            pNameMap = RtlLookupElementGenericTable(pLocalGroupAttrs, &NameMap);
            break;
        case 5:
            pNameMap = RtlLookupElementGenericTable(pUserAttrs, &NameMap);
            break;
        default:
            RaiseException(LL_INTERNAL, 0, 0, NULL);
    }

    if (pNameMap) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
// Function:    LoadedCompare
//
// Synopsis:    This function will be used with qsort to sink member attributes
//              down to the end of the attributes list so that we may easily
//              separate them into a changetype: modify.
//
// Arguments:
//              const void *arg1  - A pointer to an element in our array
//              const void *arg2  - Same
//
// Returns:     Result of comparison. (0, <0, >0)
//
// Modifies:      -
//
// History:    22-7-97   t-RomanY Created.
//
//----------------------------------------------------------------------------
int __cdecl 
LoadedCompare(
    const void *pArg1, 
    const void *pArg2
    ) 
{
    int nIsMember1;
    int nIsMember2;
    int return_val;

    PWSTR pszElem1 = StripRangeFromAttr(*(PWSTR *)pArg1);
    PWSTR pszElem2 = StripRangeFromAttr(*(PWSTR *)pArg2);

    nIsMember1 = SCGetAttByName(wcslen(pszElem1),
                                 pszElem1);
    nIsMember2 = SCGetAttByName(wcslen(pszElem2),
                                 pszElem2);

    //
    // beginning case is that they are both members
    //
    if (nIsMember1&&nIsMember2) {
        
        return_val = 0;   // equal
    }

    else if (nIsMember1) {
        return_val =  1;   // greater
    }

    else if (nIsMember2) {
        return_val = -1;  // lesser
    }

    //
    // If neither are members, we just compare
    //
    else
        return_val = _wcsicmp(pszElem1, pszElem2);

    if(pszElem1)
        MemFree(pszElem1);
    if(pszElem2)
        MemFree(pszElem2);

    return return_val;
}

__inline ULONG 
SCNameHash(
    ULONG size, 
    PWSTR pVal, 
    ULONG count
    )
{
    ULONG val=0;
    while(size--) {
        //
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        //
        val += (*pVal | 0x20);
        pVal++;
    }
    return (val % count);
}

int
SCGetAttByName(
    ULONG ulSize,
    PWSTR pVal
    )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero if exist, 0 otherwise.

--*/
{
    ULONG i;

    if (!g_pBacklinkHashTable) {
        return FALSE;
    }

    i=SCNameHash(ulSize,pVal,g_nBacklinkCount);
    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }


    while (g_pBacklinkHashTable[i].bUsed &&            // this hash spot refers to an object,
          (g_pBacklinkHashTable[i].length != ulSize || // but the size is wrong
           _wcsicmp(g_pBacklinkHashTable[i].value,pVal))) // or the value is wrong
    {
        i++;
        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }

    return (g_pBacklinkHashTable[i].bUsed);
}

int
SCInsert(
    ULONG ulSize,
    PWSTR pVal
    )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns TRUE if successfull, return 0 if duplicate

--*/
{
    ULONG i = SCNameHash(ulSize,pVal,g_nBacklinkCount);

    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }

    while (g_pBacklinkHashTable[i].bUsed)
    {
        if ((g_pBacklinkHashTable[i].length == ulSize) &&
            (_wcsicmp(g_pBacklinkHashTable[i].value,pVal) == 0)) {
            return FALSE;
        }

        i++;
        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }
    
    g_pBacklinkHashTable[i].length = ulSize;
    g_pBacklinkHashTable[i].value = MemAllocStrW_E(pVal);
    if (!g_pBacklinkHashTable[i].value) {
        return FALSE;
    }    
    g_pBacklinkHashTable[i].bUsed = TRUE;
    return TRUE;
}

void 
CreateOmitBacklinkTable(
    LDAP *pLdap,
    PWSTR *rgszOmit,
    DWORD dwFlag,
    PWSTR *ppszNamingContext,
    BOOL *pfPagingAvail,
    BOOL *pfSAMAvail)
{
    HRESULT hr = S_OK;
    LDAPMessage     *pSearchMessage = NULL;
    LDAPMessage     *pMessage = NULL;
    struct berelement *pBerElement = NULL;

    PWSTR *rgszVal = NULL;
    PWSTR *rgszValW = NULL;
    PWSTR szAttribute = NULL;
    PWSTR szAttributeW = NULL;

    PWSTR szTemp = NULL;
    PWSTR szDN = NULL;
    PWSTR szLinkCN = NULL;

    PWSTR szSchemaPath = NULL;

    ULONG i;
    ULONG nCount = 0;
    ULONG iLinkID = 0;

    NAME_MAP NtiElem;
    BOOLEAN bNewElem;
    BOOLEAN bNamingContext = (BOOLEAN)(dwFlag & LL_INIT_NAMINGCONTEXT);
    BOOLEAN bBacklink = (BOOLEAN)(dwFlag & LL_INIT_BACKLINK);
    BOOL fSAMAvail = FALSE;
    BOOL fPagingAvail = FALSE;

    ULONG LdapError;
    ULONG msgnum;

    //
    // Generating OMIT table
    //
    g_pOmitTable = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(g_pOmitTable,
                              NtiComp,
                              NtiAlloc,
                              NtiFree,
                              NULL);

    if (rgszOmit) {
        i = 0;
        while(rgszOmit[i]) {
            NtiElem.szName = MemAllocStrW_E(rgszOmit[i]);
            NtiElem.index = 0;
            RtlInsertElementGenericTable(g_pOmitTable,
                                         &NtiElem,
                                         sizeof(NAME_MAP),
                                         &bNewElem);
            if (!bNewElem) {
                RaiseException(LL_DUPLICATE, 0, 0, NULL);
            }
            i++;
        }
    }

    //
    // We search rootdse either we search for backlinks, need to get the 
    // base context, or if we need to check whether paging is available or not
    //
    if (bBacklink || bNamingContext || pfPagingAvail) {
        
        msgnum = ldap_searchW(pLdap,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              g_rgszSchemaList,
                              0);

        LdapError = LdapResult(pLdap, msgnum, &pSearchMessage);
    
        if ( LdapError != LDAP_SUCCESS ) {
            //
            // RootDSE search fails
            // pfPagingAvail will be FALSE as well
            //
            if (ppszNamingContext)
                *ppszNamingContext = NULL;
            BAIL();         
        }

        for ( pMessage = ldap_first_entry( pLdap,
                                           pSearchMessage );
              pMessage != NULL;
              pMessage = ldap_next_entry( pLdap,
                                             pMessage ) ) {
            for (   szAttribute = ldap_first_attributeW( pLdap, pMessage, &pBerElement );
                    szAttribute != NULL;
                    szAttribute = ldap_next_attributeW( pLdap, pMessage, pBerElement ) ) {

                    rgszVal = ldap_get_valuesW( pLdap, pMessage, szAttribute );
                    if (_wcsicmp(L"schemaNamingContext",szAttribute) == 0) {
                        szSchemaPath = MemAllocStrW_E(rgszVal[0]);

                    }
                    else if (_wcsicmp(L"defaultNamingContext",szAttribute) == 0) {
                        *ppszNamingContext = MemAllocStrW_E(rgszVal[0]);
                    }
                    else if (_wcsicmp(L"supportedControl",szAttribute) == 0) {
                        DWORD i = 0;
                        while (rgszVal[i]) {
                            if (wcscmp(rgszVal[i],LDAP_PAGED_RESULT_OID_STRING_W) == 0) {
                                fPagingAvail = TRUE;
                                break;
                            }
                            i++;
                        }
                    }
                    else {
                        RaiseException(LL_INITFAIL, 0, 0, NULL);
                    }
                    ldap_value_freeW(rgszVal);
                    rgszVal = NULL;
            }
        }

        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }
    }

    if (bBacklink) {
        //
        // We are taking all attributes that are linked attributes, and any
        // attribute of DN types as backlinked attributes
        //
        msgnum = ldap_searchW(pLdap,
                                szSchemaPath,
                                LDAP_SCOPE_ONELEVEL,
                                L"(&(objectClass= attributeSchema)(|(linkid=*)(attributeSyntax=2.5.5.1)))",
                                g_rgszAttrList,
                                0);

        LdapError = LdapResult(pLdap, msgnum, &pSearchMessage);
        
        if ( LdapError != LDAP_SUCCESS ) {
            //
            // we'll bail, saying sam support is not available
            //
            BAIL();         
        }
        MemFree(szSchemaPath);
        szSchemaPath = NULL;

        nCount = ldap_count_entries(pLdap,
                                    pSearchMessage);

        g_nBacklinkCount = nCount * 2;
        if (nCount == 0) {
            g_pBacklinkHashTable = NULL;
        }
        else {
            g_pBacklinkHashTable = MemAlloc_E(g_nBacklinkCount * sizeof(HASHCACHESTRING));
            memset(g_pBacklinkHashTable,0,g_nBacklinkCount * sizeof(HASHCACHESTRING));
        }

        //
        // Always insert Primary Group. It is always a backlink. It always refer to some
        // other group
        //
        if (SCInsert(wcslen(g_szPrimaryGroup),
                     g_szPrimaryGroup) == FALSE) {
            RaiseException(LL_INITFAIL, 0, 0, NULL);
        }

        for ( pMessage = ldap_first_entry( pLdap,
                                           pSearchMessage );
              pMessage != NULL;
              pMessage = ldap_next_entry( pLdap,
                                          pMessage ) ) {
            BOOLEAN bLinkIDPresent = FALSE;
            for (   szAttributeW = ldap_first_attribute( pLdap, pMessage, &pBerElement );
                    szAttributeW != NULL;
                    szAttributeW = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
                rgszValW = ldap_get_values( pLdap, pMessage, szAttributeW );
                if (!_wcsicmp(L"ldapdisplayname",szAttributeW)) {
                    szLinkCN = MemAllocStrW_E(rgszValW[0]);
                }
                else {
                    szTemp = MemAllocStrW_E(rgszValW[0]);

                    iLinkID = _wtoi(szTemp);
                    MemFree(szTemp);
                    bLinkIDPresent = TRUE;
                }
                ldap_value_free(rgszValW);
            }
            //
            // If it is not a linked ID (and thus a DN type attribute) or if it
            // is the source linked ID (source linked ID are even while
            // targets are odd)
            //
            if (((!bLinkIDPresent) || ((iLinkID % 2) == 0))) {
                //
                // Ignore 'distinguishname and objectcategory' because they are
                // DN attributes that exist in every object
                //
                if ((_wcsicmp(szLinkCN, L"objectCategory") == 0) ||
                    (_wcsicmp(szLinkCN, L"distinguishedName") == 0)) {
                    MemFree(szLinkCN);
                    continue;
                }

                //
                // Insert into Backlink Hash
                //
                if (SCInsert(wcslen(szLinkCN),
                             szLinkCN) == FALSE) {
                    RaiseException(LL_INITFAIL, 0, 0, NULL);
                }
                MemFree(szLinkCN);
            }
            else {
                //
                // Insert into our Omit Table
                //
                NtiElem.szName = szLinkCN;
                NtiElem.index = 0;
                RtlInsertElementGenericTable(g_pOmitTable,
                                             &NtiElem,
                                             sizeof(NAME_MAP),
                                             &bNewElem);
                if (!bNewElem) {
                    RaiseException(LL_INITFAIL, 0, 0, NULL);
                }
            }
        }

        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
        }
        i = 0;
        while(g_rgszOmit[i]) {
            NtiElem.szName = MemAllocStrW_E(g_rgszOmit[i]);
            NtiElem.index = 0;
            RtlInsertElementGenericTable(g_pOmitTable,
                                         &NtiElem,
                                         sizeof(NAME_MAP),
                                         &bNewElem);
            i++;
        }
        fSAMAvail = TRUE;
    }

error:
    if (szSchemaPath) {
        MemFree(szSchemaPath);
        szSchemaPath = NULL;
    }
    if (pfPagingAvail) {
        *pfPagingAvail = fPagingAvail;
    }
    if (pfSAMAvail) {
        *pfSAMAvail = fSAMAvail;
    }
    
    return;
}

//--------------------------------------------------------------------------
// GetNewRange
//
// This function checks if the server returned a multivalued attribute with
// a range specifier. In this case, it may be required to fetch the
// remaining values of the attribute in a separate search request. To specify
// the end of the range, the server uses * as the upper limit in the range
// it returns. If the server returns range0-999 as the range, the next client
// request will contain 1000-*, where * specifies the end of the range.
//
//---------------------------------------------------------------------------
void GetNewRange(PWSTR szAttribute, DWORD dwAttrNoRange,
                 PWSTR szAttrNoRange, DWORD dwNumAttr, 
                 PWSTR **pppszAttrsWithRange)
{
    PWSTR szNewRangeAttr = NULL;
    int iUpperLimit, iLowerLimit, iRangeIndex, i = 0;
    WCHAR hyphen, cTmp;

    int SpaceToAlloc = 0;

    // make sure the attribute returned by the server has a range specifier
    if( (szAttribute[dwAttrNoRange] != L';') || 
        (_wcsnicmp(&szAttribute[dwAttrNoRange+1],L"range=", wcslen(L"range="))) ) 
        return;

    // get the upper and lower limits of the range returned by the server
    iRangeIndex = dwAttrNoRange+1+wcslen(L"range="); 
    swscanf(&szAttribute[iRangeIndex], L"%d %c %c", &iLowerLimit, &hyphen, 
                                                                  &cTmp);
    if(hyphen != L'-')
        return;

    if(cTmp == L'*')
    // end of values for this attribute
        return;
    else if((cTmp < L'0') || (cTmp > L'9'))
    // bad upper limit
        return;
    else // read the upper limit
        swscanf(&szAttribute[iRangeIndex], L"%d %c %d", &iLowerLimit, &hyphen,
                                                        &iUpperLimit);

    // 100 chars to hold the "range=..." string
    SpaceToAlloc = (dwAttrNoRange + 100) * sizeof(WCHAR);

    szNewRangeAttr = MemAlloc_E(SpaceToAlloc);
    wsprintf(szNewRangeAttr, L"%s;Range=%d-*", szAttrNoRange, iUpperLimit+1);

    // make sure that this attribute is not already marked for another
    // search request. This can happen, if object X returned a range for this
    // attribute and then object Y also returned a range for the same attr.
    if(*pppszAttrsWithRange)
    {
        while((*pppszAttrsWithRange)[i])
        {
            if(!_wcsicmp(szNewRangeAttr, (*pppszAttrsWithRange)[i]))
            // this attr has already been marked for another search request
            {
                MemFree(szNewRangeAttr);
                return;
            }
            
            i++;
        }
    }

    // the attribute is not already marked for another search

    if(NULL == (*pppszAttrsWithRange))
        // allocate space for attribute + NULL terminator 
        *pppszAttrsWithRange = (PWSTR *) MemAlloc_E(2 * sizeof(PWSTR));
    else
        *pppszAttrsWithRange = MemRealloc_E(*pppszAttrsWithRange, 
                                          (i + 2) * sizeof(PWSTR));

    (*pppszAttrsWithRange)[i] = szNewRangeAttr;
    (*pppszAttrsWithRange)[i+1] = NULL;

    return;
}

//----------------------------------------------------------------------------
// StripRangeFromAttr
//
// This function strip off the range specifier from an attribute name and
// returns just teh attribute name in a newly allocated string. For example, if
// "member;0-999" is passed to this function, it returns "member".
//
//----------------------------------------------------------------------------
PWSTR StripRangeFromAttr(PWSTR szAttribute)
{
    PWSTR szNoRangeAttr = NULL;
    DWORD dwAttrLen = wcslen(szAttribute), i;

    szNoRangeAttr = MemAlloc_E((wcslen(szAttribute)+1) * sizeof(WCHAR));

    for(i = 0; i <= dwAttrLen; i++)
        if( (szAttribute[i] == L';') && 
            (!_wcsnicmp(&szAttribute[i+1], L"range=", wcslen(L"range="))) 
          )
        // found the range specifier. 
            szNoRangeAttr[i] = L'\0';
        else
            szNoRangeAttr[i] = szAttribute[i];

    return szNoRangeAttr;
}

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\lexeru.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lexeru.h

Abstract:

    Unicode Lexer Header file

Environment:

    User mode

Revision History:

    04/29/99 -felixw-
        Created it

--*/
#ifndef __LEXERU_H__
#define __LEXERU_H__

extern FILE *yyin;                     // Input file stream
extern FILE *yyout;                    // Output file stream for first phase (CLEAR)

extern void    yyerror(char *);
extern int     yylex();

//
// used to determine whether we've passed limit. 
// must be one less than COUNT_CHUNK
//
#define LINEMAP_INC 1000
#define YY_NULL 0

typedef struct _STACK {
    DWORD dwSize;
    PWSTR rgcStack;
    DWORD dwIndex;              // Current index to stack
} STACK;

//
// Define the stack functions
//
#define MAXVAL 65535
#define INC     256


//
// Define the dynamic string macros. This should be implemented as a String
// Class if lexer is implemented in C.
//
#define STR_INIT()                                          \
            PWSTR pszString = NULL;                         \
            DWORD cSize = INC;                              \
            DWORD cCurrent = 0;                             \
            pszString = MemAlloc_E(INC*sizeof(WCHAR));      \
            memset(pszString, 0, INC*sizeof(WCHAR));

#define STR_ADDCHAR(c)                                                         \
            if ((cCurrent+2) >= cSize) {                                       \
                pszString = MemRealloc_E(pszString,(INC+cSize)*sizeof(WCHAR));   \
                memset(pszString + cSize,                    \
                       0,                                                      \
                       INC*sizeof(WCHAR));                             \
                cSize+=INC;                                                    \
            }                                                                  \
            pszString[cCurrent++] = c;

#define STR_VALUE()  pszString

#define STR_FREE()                      \
            MemFree(pszString);         \
            pszString = NULL;

//
// Stack Functions
//
void Push(STACK *pStack,WCHAR c);
BOOL Pop(STACK *pStack,WCHAR *pChar);
void Clear(STACK *pStack);

void LexerInit(PWSTR szInputFileName);
void LexerFree();

//
// Special file stream functions using the stack
//
BOOL GetNextCharExFiltered(WCHAR *pChar, BOOL fStart);
void UnGetCharExFiltered(WCHAR c) ;

void RollBack();

//
// File stream functions
//   Filtered = goes through the comment preprocessor
//   Raw = direct access
//
BOOL GetNextCharFiltered(WCHAR *pChar);
void UnGetCharFiltered(WCHAR c);
BOOL GetNextCharRaw(WCHAR *pChar);
void UnGetCharRaw(WCHAR c);

BOOL GetToken(PWSTR *pszToken);

//
// Comment preprocessing functions
//
BOOL ScanClear(PWCHAR pChar, __int64 *pBytesProcessed);
WCHAR GetFilteredWC(void);
BOOL GetTrimmedFileSize(PWSTR szFilename, __int64 *pTrimmedSize);

//
// Character validation functions
//
BOOL IsDigit(WCHAR c);
BOOL Is64Char(WCHAR c); 
BOOL Is64CharEnd(WCHAR c);
BOOL IsNameChar(WCHAR c);
BOOL IsURLChar(WCHAR c);
BOOL IsVal(WCHAR c);
BOOL IsValInit(WCHAR c);

//
// Scanning function for individual mode
//
BOOL ScanNormal(DWORD *pToken);
BOOL ScanDigit(DWORD *pToken);
BOOL ScanString64(DWORD *pToken);
BOOL ScanName(DWORD *pToken);
BOOL ScanNameNC(DWORD *pToken);
BOOL ScanVal(DWORD *pToken);
BOOL ScanUrlMachine(DWORD *pToken);
BOOL ScanChangeType(DWORD *pToken);
BOOL ScanType(DWORD *pToken);

/*
    Comment Preprocessing Architecture Notes

    Originally, LDIFDE used a two-pass parser.  The first pass would
    remove comments and paste together line continuations, and write the
    results to a temporary file.  The second pass would read this 
    preprocessed file and parse it to import entries into the directory.
    GetNextChar and UnGetChar were used in both passes to directly
    read from the file.

    In the new architecture, the first pass of the parser, ScanClear,
    has been transformed into a filter that sits between the actual
    parser (what used to be the second pass) and the raw input file.
    The parser uses GetNextCharFiltered/UnGetCharFiltered to read
    characters through the filter.  The filter in turn uses GetNextCharRaw/
    UnGetCharRaw to directly read the file.  GetNextCharFiltered uses
    GetFilteredWC to interface with the filter (ScanClear).

    GetFilteredWC, along with its helper function GetTrimmedFileSize,
    is responsible for emulating two behaviors of the original
    two-pass parser.  First, while the LDIF grammar requires that the file
    begin with "version: 1" without any leading white spaces, LDIFDE has
    traditionally permitted the omission of the version spec and the inclusion
    of leading white spaces.  It did this by prepending a version spec to
    the start of the start of the temp file.  We simulate this for the parser
    by injecting a version spec line into the stream at the start of the file.

    Second, LDIFDE has been lax about allowing extra white space at the end of the
    file.  It did this by trimming off any trailing white space in the temp file.
    We simulate this by calculating what the size of the "trimmed" file would be
    and injecting EOF at that point in the stream.

*/


#endif // ifndef __LEXERU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header for library

Environment:

    User mode

Revision History:

    04/29/99 -felixw-
        Created it

--*/
#ifndef _PRECOMP_H
#define _PRECOMP_H

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>

//
// CRunTime Includes
//
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

//
// LDAP Includes
//
#include <winldap.h>
#include "tchar.h"

//
// LDIFDE specific includes
//
#include "ldifext.h"
#include "ldifldap.h"
#include "memory.h"
#include "ldifutil.h"
#include "async.h"

#include "lexeru.h"
#include "base64.h"
#include "dsldap.h"
#include "globals.h"

#endif // _PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\ldifutil.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldifutil.c

ABSTRACT:

     Utilities for LDIF library

REVISION HISTORY:

--*/
#include <precomp.h>

PVOID NtiAlloc( 
    RTL_GENERIC_TABLE *Table, 
    CLONG ByteSize 
    )
{
    return(MemAlloc_E(ByteSize));
}

VOID NtiFree ( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    MemFree(Buffer);
}


RTL_GENERIC_COMPARE_RESULTS
NtiComp( PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct ) 
{
    PNAME_MAP NameMap1 = (PNAME_MAP) FirstStruct;
    PNAME_MAP NameMap2 = (PNAME_MAP) SecondStruct;
  
    PWSTR Name1 = NameMap1->szName;
    PWSTR Name2 = NameMap2->szName;
    
    int diff;

    diff = _wcsicmp(Name1, Name2);

    if (diff<0) {
        return GenericLessThan;
    } 
    else if (diff==0) {
        return GenericEqual;
    } 
    else {
        return GenericGreaterThan;
    }
}

RTL_GENERIC_COMPARE_RESULTS
NtiCompW(PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct ) 
{
    PNAME_MAPW NameMap1 = (PNAME_MAPW) FirstStruct;
    PNAME_MAPW NameMap2 = (PNAME_MAPW) SecondStruct;
  
    PWSTR Name1 = NameMap1->szName;
    PWSTR Name2 = NameMap2->szName;
    
    int diff;

    diff = _wcsicmp(Name1, Name2);

    if (diff<0) {
        return GenericLessThan;
    } 
    else if (diff==0) {
        return GenericEqual;
    } 
    else {
        return GenericGreaterThan;
    }
}

/*
//+---------------------------------------------------------------------------
// Function:  SubStr
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            S_OK with szOutput = NULL;
//            This function raises an exception when there are memory errors
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD SubStr(LPSTR szInput,
             LPSTR szFrom,
             LPSTR szTo,
             LPSTR *pszOutput)
{
    DWORD dwErr = 0;
    LPSTR szOutput = NULL;
    LPSTR szLast = NULL;
    LPSTR szReturn = NULL;
    DWORD cchToCopy = 0;        // count of number of char to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    if (!szFrom || !szTo) {
        *pszOutput = NULL;
        return E_FAIL;
    }

    if (!szInput) {
        *pszOutput = NULL;
        return S_OK;
    }

    cchFrom    = strlen(szFrom);
    cchTo      = strlen(szTo);
    cchInput   = strlen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = strstr(szInput,
                      szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return S_OK;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = strstr(szOutput,
                          szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (LPSTR)MemAlloc_E(sizeof(char) * cchReturn);
    if (!szReturn) {
        dwErr = 1;
        goto error;
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = strstr(szInput,
                      szFrom);
    cchToCopy = (ULONG)(szOutput - szInput);
    strncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    strcat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = strstr(szInput,
                      szFrom);
    while (szOutput) {
        cchToCopy = (ULONG)(szOutput - szInput);
        strncat(szReturn,
                szInput,
                cchToCopy);
        strcat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = strstr(szInput,
                          szFrom);
    }

    strcat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (dwErr);
} 
*/            

//+---------------------------------------------------------------------------
// Function:  SubStrW
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            S_OK with szOutput = NULL;
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD SubStrW(PWSTR szInput,
              PWSTR szFrom,
              PWSTR szTo,
              PWSTR *pszOutput)
{
    DWORD dwErr = 0;
    PWSTR szOutput = NULL;
    PWSTR szLast = NULL;
    PWSTR szReturn = NULL;
    DWORD cchToCopy = 0;        // count of number of char to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    if (!szFrom || !szTo) {
        *pszOutput = NULL;
        return E_FAIL;
    }

    if (!szInput) {
        *pszOutput = NULL;
        return S_OK;
    }

    cchFrom    = wcslen(szFrom);
    cchTo      = wcslen(szTo);
    cchInput   = wcslen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = wcsistr(szInput,
                       szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return S_OK;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = wcsistr(szOutput,
                           szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (PWSTR)MemAlloc(sizeof(WCHAR) * cchReturn);
    if (!szReturn) {
        dwErr = 1;
        goto error;
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = wcsistr(szInput,
                       szFrom);
    cchToCopy = (ULONG)(szOutput - szInput);
    wcsncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    wcscat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = wcsistr(szInput,
                       szFrom);
    while (szOutput) {
        cchToCopy = (ULONG)(szOutput - szInput);
        wcsncat(szReturn,
                szInput,
                cchToCopy);
        wcscat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = wcsistr(szInput,
                           szFrom);
    }

    wcscat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (dwErr);
};



//
// Case-insensitive version of wcsstr.
// Based off the Visual C++ 6.0 CRT
// sources.
//
wchar_t * __cdecl wcsistr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;
        wchar_t cs1, cs2;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                cs1 = *s1;
                cs2 = *s2;

                if (iswupper(cs1))
                    cs1 = towlower(cs1);

                if (iswupper(cs2))
                    cs2 = towlower(cs2);


                while ( *s1 && *s2 && !(cs1-cs2) ) {

                    s1++, s2++;

                    cs1 = *s1;
                    cs2 = *s2;

                    if (iswupper(cs1))
                        cs1 = towlower(cs1);

                    if (iswupper(cs2))
                        cs2 = towlower(cs2);
                }

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}



void
ConvertUnicodeToUTF8(
    PWSTR pszUnicode,
    DWORD dwLen,
    BYTE  **ppbValue,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode.
    This function raises an exception when memory error occurs.

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    PBYTE pbValue = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the UTF8 String
    //
    pbValue = (PBYTE)MemAlloc_E((dwLen + 1) * 3 * sizeof(BYTE));

    nReturn = LdapUnicodeToUTF8(pszUnicode,
                                dwLen,
                                pbValue,
                                (dwLen + 1) * 3 * sizeof(BYTE));
    //
    // NULL terminate it
    //

    pbValue[nReturn] = '\0';

    *ppbValue = pbValue;
    *pdwLen = nReturn;
}

void
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *ppszUnicode,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    PWSTR pszUnicode = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the Unicode String
    //
    pszUnicode = (PWSTR)MemAlloc_E((dwLen + 1) * sizeof(WCHAR));

    nReturn = LdapUTF8ToUnicode((PSTR)pVal,
                                dwLen,
                                pszUnicode,
                                dwLen + 1);

    //
    // NULL terminate it
    //

    pszUnicode[nReturn] = '\0';

    *ppszUnicode = pszUnicode;
    *pdwLen = (nReturn + 1);//* sizeof(WCHAR);
}

BOOLEAN IsUTF8String(
    PCSTR pSrcStr,
    int cchSrc)

/*++

Routine Description:

    Given a string, this function checks whether it is a valid UTF8 String. 
    For details about the UTF8 format, please refer to rfc2279.

Arguments:
    pSrcStr - input string
    cchSrc - number of bytes    

Return Value:

    Whether this is a UTF8 string or not

--*/

{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    PCSTR pUTF8 = pSrcStr;
    char UTF8;


    while (cchSrc--)
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //

            //
            // If we are expecting trailing bytes, this is probably an invalid
            // utf8 string
            //
            if (nTB > 0) {
                return FALSE;
            }
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;
            }
            else {
                //
                // Found a trail byte with no leading byte
                //
                return FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                return FALSE;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                if (nTB>3) {
                    return FALSE;
                }
                //
                //  decrement the number of bytes to follow.
                //
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    // We are still expecting trailing bytes, but we can't find any
    //
    if (nTB > 0) {
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
// The following functions are used for importing an entry. Depending on
// whether the command specified lazy commit or not, the appropriate ldap API
// function is called. 
//
//---------------------------------------------------------------------------
ULONG LDAPAPI ldif_ldap_add_sW( 
    LDAP *ld, 
    PWCHAR dn, 
    LDAPModW *attrs[], 
    BOOL fLazyCommit
    )
{
    ULONG msgnum;
    ULONG Ldap_err;
    
    if (fLazyCommit) {
        Ldap_err = ldap_add_extW(ld, dn, attrs, g_ppwLazyCommitControl, NULL, &msgnum);

        if (Ldap_err == LDAP_SUCCESS) {
            Ldap_err = LdapResult(ld, msgnum, NULL);
        }
    }
    else {
        msgnum = ldap_addW(ld, dn, attrs);

        Ldap_err = LdapResult(ld, msgnum, NULL);
    }

    return Ldap_err;
}

ULONG LDAPAPI ldif_ldap_delete_sW(
    LDAP *ld,
    const PWCHAR dn,
    BOOL fLazyCommit
    )
{
    ULONG msgnum;
    ULONG Ldap_err;
    
    if (fLazyCommit) {
        Ldap_err = ldap_delete_extW(ld, dn, g_ppwLazyCommitControl, NULL, &msgnum);

        if (Ldap_err == LDAP_SUCCESS) {
            Ldap_err = LdapResult(ld, msgnum, NULL);
        }
    }
    else {
        msgnum = ldap_deleteW(ld, dn);

        Ldap_err = LdapResult(ld, msgnum, NULL);
    }

    return Ldap_err;

}

ULONG LDAPAPI ldif_ldap_modify_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *mods[],
    BOOL fLazyCommit
    )
{
    ULONG msgnum;
    ULONG Ldap_err;
    
    if (fLazyCommit) {
        Ldap_err = ldap_modify_extW(ld, dn, mods, g_ppwLazyCommitControl, NULL, &msgnum);

        if (Ldap_err == LDAP_SUCCESS) {
            Ldap_err = LdapResult(ld, msgnum, NULL);
        }
    }
    else {
        msgnum = ldap_modifyW(ld, dn, mods);

        Ldap_err = LdapResult(ld, msgnum, NULL);
    }

    return Ldap_err;


}


//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ldifds\ldifldap\parser.c ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
#line 2 "ldif.y"

/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.y

ABSTRACT:

    The yacc grammar for LDIF.

DETAILS:
    
    To generate the sources for lexer.c and parser.c,
    run nmake -f makefile.parse.
    
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/


#include <precomp.h>
#include <urlmon.h>
#include <io.h>

/**/
/* I really don't want to do another linked list contraption for mod_specs, */
/* expecially considering that we don't need to do any preprocessing other than */
/* combine them into an LDAPmod**. So I am going to use realloc. */
/**/
#define CHUNK 100        
LDAPModW        **g_ppModSpec     = NULL; 
LDAPModW        **g_ppModSpecNext = NULL;
long            g_cModSpecUsedup  = 0;        /* how many we have used up*/
size_t          g_nModSpecSize    = 0;        /* how big the buffer is*/
long            g_cModSpec        = 0;        /* no. of mod spec allocated*/


DEFINE_FEATURE_FLAGS(Parser, 0);

#define DBGPRNT(x)  FEATURE_DEBUG(Parser,FLAG_FNTRACE,(x))
#define YYDEBUG 0

#line 56 "ldif.y"
typedef union {
    int                 num;
    PWSTR               wstr;
    LDAPModW            *mod;
    struct change_list  *change;
} YYSTYPE;
#line 71 "y_tab.c"
#define SEP 257
#define MULTI_SEP 258
#define MULTI_SPACE 259
#define CHANGE 260
#define VERSION 261
#define DNCOLON 262
#define DNDCOLON 263
#define LINEWRAP 264
#define NEWRDNDCOLON 265
#define MODESWITCH 266
#define SINGLECOLON 267
#define DOUBLECOLON 268
#define URLCOLON 269
#define FILESCHEME 270
#define T_CHANGETYPE 271
#define NEWRDNCOLON 272
#define DELETEOLDRDN 273
#define NEWSUPERIORC 274
#define NEWSUPERIORDC 275
#define ADDC 276
#define MINUS 277
#define SEPBYMINUS 278
#define DELETEC 279
#define REPLACEC 280
#define STRING 281
#define SEPBYCHANGE 282
#define NAME 283
#define VALUE 284
#define BASE64STRING 285
#define MACHINENAME 286
#define NAMENC 287
#define DIGITS 288
#define ADD 289
#define MODIFY 290
#define MODDN 291
#define MODRDN 292
#define MYDELETE 293
#define NTDSADD 294
#define NTDSMODIFY 295
#define NTDSMODRDN 296
#define NTDSMYDELETE 297
#define NTDSMODDN 298
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,   27,   27,   27,   28,   28,   28,   29,   36,
   31,   31,   32,   32,   38,   39,   26,   26,   26,   40,
   40,   41,   41,    1,    1,    1,    1,   43,   46,   44,
   34,   45,   37,   33,   47,   17,   17,   19,   19,   18,
   18,   20,   20,   21,   21,   11,   11,   11,   11,    9,
    9,   14,   13,   13,   12,   12,   12,   12,   23,   22,
    6,    7,   15,    8,    8,   10,   48,   48,    4,    4,
    4,    2,    2,    3,    5,   16,   16,   16,   16,   42,
   42,   30,   30,   35,   35,   24,   25,
};
short yylen[] = {                                         2,
    1,    1,    3,    5,    1,    3,    5,    1,    5,    3,
    1,    3,    1,    3,    3,    3,    5,    5,    3,    1,
    3,    1,    3,    9,    9,    9,    5,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    9,
    7,    7,    1,    3,    5,    5,    5,    5,    7,    7,
    5,    5,    7,    5,    5,    9,    1,    3,    1,    1,
    1,   13,   10,   12,   12,    0,    2,    1,    3,    1,
    1,    1,    1,    0,    1,    3,    3,
};
short yydefred[] = {                                      0,
   34,    0,    0,    1,    2,    0,    0,    0,    0,   11,
   13,    0,    0,   82,   83,    0,    0,    0,    0,    0,
    0,   28,   20,    0,    0,   35,   46,   48,   22,    0,
   49,   47,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   12,    0,   14,   31,    0,    0,    0,   80,   81,
    0,    0,    0,    0,    0,    0,    0,    0,   85,    0,
    0,    0,   21,    0,   54,    0,    0,    0,    0,    0,
    0,   23,    0,    0,    0,   33,    9,    0,   30,   17,
    0,   32,   18,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   56,    0,   58,    0,    0,   55,
   57,    0,   10,   86,   87,    0,    0,    0,    0,    0,
    0,    0,    0,   36,   40,   44,   42,   38,   37,   41,
   43,   39,   45,    0,    0,    0,    0,    0,    0,    0,
    0,   64,   65,    0,   62,   61,    0,    0,   52,   59,
   60,    0,    0,    0,    0,    0,    0,   24,   25,   26,
    0,    0,   69,   70,   67,   71,    0,    0,    0,    0,
    0,    0,    0,   63,    0,    0,    0,   68,    0,    0,
    0,   29,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   78,    0,    0,    0,    0,    0,    0,    0,
   73,    0,    0,   79,    0,    0,    0,    0,    0,   74,
   75,   72,
};
short yydgoto[] = {                                       2,
   23,  163,  164,  165,  166,   67,   68,   65,   27,   28,
   29,   30,   31,   32,  105,  194,  134,  135,  136,  137,
  138,   33,   34,   80,   83,    3,    4,    5,    6,   16,
    7,    8,  106,   46,   60,   77,   78,   10,   11,   24,
   35,   51,   25,   81,   84,  183,   36,  168,
};
short yysindex[] = {                                   -207,
    0,    0, -241,    0,    0, -240, -230, -161, -205,    0,
    0, -165, -164,    0,    0, -207, -207, -207, -163, -163,
 -163,    0,    0, -227, -252,    0,    0,    0,    0, -152,
    0,    0, -151, -150, -174, -162, -240, -230, -161, -136,
 -212,    0, -160,    0,    0, -131, -131, -131,    0,    0,
 -165, -207, -207, -207, -207, -164, -163, -207,    0, -137,
 -135, -134,    0, -184,    0, -202, -127, -124, -238, -123,
 -121,    0, -131, -230, -161,    0,    0, -149,    0,    0,
 -146,    0,    0, -148, -163, -163, -163, -163, -163, -207,
 -207, -163, -163, -207, -207, -207, -163, -163, -163, -131,
 -131, -131, -131, -131,    0, -133,    0, -131, -131,    0,
    0, -178,    0,    0,    0, -135, -134, -135, -135, -134,
 -163, -134, -135,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -163, -163, -163, -163, -163, -140, -139,
 -132,    0,    0, -131,    0,    0, -227, -112,    0,    0,
    0, -163, -163, -163, -137, -165, -207,    0,    0,    0,
 -141, -227,    0,    0,    0,    0, -211, -109, -163, -163,
 -163, -163, -207,    0, -131, -131, -131,    0, -117, -117,
 -117,    0, -130, -125, -118, -163, -163, -163, -227, -237,
 -237, -165,    0, -128, -165, -122, -242, -207, -235, -207,
    0, -207, -126,    0, -114, -113, -163, -163, -163,    0,
    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,  153,  154,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    4,    0,    0,    0,    0,    0,    2,
    0,    0,    0,    0,    5,    0,    0,  155,  170,    0,
    0,    0,    0,    0,    0,  -95, -234,  -95,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  -95,  172,  173,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
  -95,  -95,  -95,  -95,    0,    0,    0,  -95,  -95,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  -95,    0,    0,    6,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    7,    0,    0,    0,    0,    0,    3,    0,    0,
    0,    0,    0,    0,  -95,  -95,  -95,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -104,
 -104,    0,    0,    0,    0,    0,    0,    0, -100,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
short yygindex[] = {                                      0,
  128,    0,    0,    9,    0,  125,  129,    0,    0,    0,
  127,    0,    0,    0,  -24,   -6,    0,    0,    0,    0,
    0,    0,    0,  -90,  -85,   62,    0,    0,  171,  149,
   -5,   -4,    8,  -11,   -9,    0,   33,  174,  175, -143,
    0, -147,    0,  -20,   72,  -91,    0,    0,
};
#define YYTABLESIZE 285
short yytable[] = {                                     156,
   27,   53,   66,   15,   16,   51,   50,    9,   47,   48,
   38,   39,  162,  201,   49,   12,   14,   15,  193,   49,
  204,   49,   19,    9,   41,   41,   92,   17,  142,   49,
   52,   84,  146,   93,  143,  202,  145,   61,   62,   50,
   13,  192,  195,  195,   50,   73,   50,   19,  197,   20,
   21,  199,   74,   75,   50,   19,   20,   21,    1,   64,
   66,   69,   69,   96,  170,   41,  107,  171,  172,  110,
  111,   88,   89,  100,  101,  102,  103,  104,   40,   43,
  108,  109,   85,   86,   87,  113,  114,  115,  184,  185,
  116,  117,  118,  119,  120,  139,   18,  141,  122,  123,
   22,   26,   45,  112,   53,   54,   55,   56,   57,  144,
  124,  125,  126,  127,  128,  129,  130,  131,  132,  133,
   12,   13,  147,  148,  149,  150,  151,   59,   76,   90,
   79,   82,   91,   94,  155,   95,   99,   98,   97,  121,
  158,  159,  160,  152,  157,  153,  169,  173,  182,  198,
  207,  154,    5,    8,    3,  200,  186,  174,  175,  176,
  177,  187,  208,  209,  167,  179,  180,  181,  188,    6,
   84,    4,    7,   76,  189,  190,  191,   77,   63,   70,
  167,  178,   72,   71,  196,   58,   37,  161,  140,    0,
   42,    0,   44,    0,    0,  210,  211,  212,    0,    0,
    0,    0,    0,    0,    0,  203,    0,  205,    0,  206,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   27,   27,   27,   53,
   66,   15,   16,   51,   50,    0,   84,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   27,    0,
    0,    0,   27,   53,   66,
};
short yycheck[] = {                                     147,
    0,    0,    0,    0,    0,    0,    0,    0,   20,   21,
   16,   16,  156,  256,  257,  257,  257,  258,  256,  257,
  256,  257,  257,   16,   17,   18,  265,  258,  119,  257,
  283,  266,  123,  272,  120,  278,  122,   47,   48,  282,
  282,  189,  190,  191,  282,   57,  282,  282,  192,  262,
  263,  195,   58,   58,  282,  261,  262,  263,  266,   52,
   53,   54,   55,   73,  276,   58,   91,  279,  280,   94,
   95,  274,  275,   85,   86,   87,   88,   89,   17,   18,
   92,   93,  267,  268,  269,   97,   98,   99,  180,  181,
  100,  101,  102,  103,  104,  116,  258,  118,  108,  109,
  266,  266,  266,   96,  257,  257,  257,  282,  271,  121,
  289,  290,  291,  292,  293,  294,  295,  296,  297,  298,
  257,  282,  134,  135,  136,  137,  138,  259,  266,  257,
  266,  266,  257,  257,  144,  257,  285,  284,  288,  273,
  152,  153,  154,  284,  257,  285,  288,  257,  266,  278,
  277,  284,    0,    0,    0,  278,  287,  169,  170,  171,
  172,  287,  277,  277,  157,  175,  176,  177,  287,    0,
  266,    0,    0,  278,  186,  187,  188,  278,   51,   55,
  173,  173,   56,   55,  191,   37,   16,  155,  117,   -1,
   17,   -1,   18,   -1,   -1,  207,  208,  209,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  198,   -1,  200,   -1,  202,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  256,  257,  258,  258,
  258,  258,  258,  258,  258,   -1,  266,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,   -1,
   -1,   -1,  282,  282,  282,
};
#define YYFINAL 2
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 298
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"SEP","MULTI_SEP","MULTI_SPACE",
"CHANGE","VERSION","DNCOLON","DNDCOLON","LINEWRAP","NEWRDNDCOLON","MODESWITCH",
"SINGLECOLON","DOUBLECOLON","URLCOLON","FILESCHEME","T_CHANGETYPE",
"NEWRDNCOLON","DELETEOLDRDN","NEWSUPERIORC","NEWSUPERIORDC","ADDC","MINUS",
"SEPBYMINUS","DELETEC","REPLACEC","STRING","SEPBYCHANGE","NAME","VALUE",
"BASE64STRING","MACHINENAME","NAMENC","DIGITS","ADD","MODIFY","MODDN","MODRDN",
"MYDELETE","NTDSADD","NTDSMODIFY","NTDSMODRDN","NTDSMYDELETE","NTDSMODDN",
};
char *yyrule[] = {
"$accept : ldif_file",
"ldif_file : ldif_content",
"ldif_file : ldif_changes",
"ldif_content : version_spec any_sep ldif_record_list",
"ldif_content : version_spec any_sep version_spec any_sep ldif_record_list",
"ldif_content : ldif_record_list",
"ldif_changes : version_spec any_sep ldif_change_record_list",
"ldif_changes : version_spec any_sep version_spec any_sep ldif_change_record_list",
"ldif_changes : ldif_change_record_list",
"version_spec : M_type VERSION M_normal any_space version_number",
"version_number : M_digitread DIGITS M_normal",
"ldif_record_list : ldif_record",
"ldif_record_list : ldif_record_list MULTI_SEP ldif_record",
"ldif_change_record_list : ldif_change_record",
"ldif_change_record_list : ldif_change_record_list MULTI_SEP ldif_change_record",
"ldif_record : dn_spec SEP attrval_spec_list",
"ldif_change_record : dn_spec SEPBYCHANGE changerecord_list",
"dn_spec : M_type DNCOLON M_normal any_space dn",
"dn_spec : M_type DNDCOLON M_normal any_space base64_dn",
"dn_spec : M_type DNCOLON M_normal",
"attrval_spec_list : attrval_spec",
"attrval_spec_list : attrval_spec_list sep attrval_spec",
"changerecord_list : changerecord",
"changerecord_list : changerecord_list SEPBYCHANGE changerecord",
"attrval_spec : M_name_read NAME M_type SINGLECOLON M_normal any_space M_safeval VALUE M_normal",
"attrval_spec : M_name_read NAME M_type DOUBLECOLON M_normal any_space M_string64 BASE64STRING M_normal",
"attrval_spec : M_name_read NAME M_type URLCOLON M_normal any_space M_safeval VALUE M_normal",
"attrval_spec : M_name_read NAME M_type SINGLECOLON M_normal",
"M_name_read : MODESWITCH",
"M_name_readnc : MODESWITCH",
"M_safeval : MODESWITCH",
"M_normal : MODESWITCH",
"M_string64 : MODESWITCH",
"M_digitread : MODESWITCH",
"M_type : MODESWITCH",
"M_changetype : MODESWITCH",
"add_token : ADD",
"add_token : NTDSADD",
"delete_token : MYDELETE",
"delete_token : NTDSMYDELETE",
"modify_token : MODIFY",
"modify_token : NTDSMODIFY",
"modrdn_token : MODRDN",
"modrdn_token : NTDSMODRDN",
"moddn_token : MODDN",
"moddn_token : NTDSMODDN",
"changerecord : change_add",
"changerecord : change_delete",
"changerecord : change_modify",
"changerecord : change_moddn",
"change_add : M_changetype T_CHANGETYPE M_normal any_space M_type add_token M_normal sep attrval_spec_list",
"change_add : M_changetype T_CHANGETYPE M_normal any_space M_type add_token M_normal",
"change_delete : M_changetype T_CHANGETYPE M_normal any_space M_type delete_token M_normal",
"change_moddn : chdn_normal",
"change_moddn : chdn_normal SEP new_superior",
"chdn_normal : modrdn SEP newrdncolon SEP deleteoldrdn",
"chdn_normal : moddn SEP newrdncolon SEP deleteoldrdn",
"chdn_normal : modrdn SEP newrdndcolon SEP deleteoldrdn",
"chdn_normal : moddn SEP newrdndcolon SEP deleteoldrdn",
"modrdn : M_changetype T_CHANGETYPE M_normal any_space M_type modrdn_token M_normal",
"moddn : M_changetype T_CHANGETYPE M_normal any_space M_type moddn_token M_normal",
"newrdncolon : M_type NEWRDNCOLON M_normal any_space dn",
"newrdndcolon : M_type NEWRDNDCOLON M_normal any_space base64_dn",
"deleteoldrdn : M_type DELETEOLDRDN M_normal any_space M_digitread DIGITS M_normal",
"new_superior : M_type NEWSUPERIORC M_normal any_space dn",
"new_superior : M_type NEWSUPERIORDC M_normal any_space base64_dn",
"change_modify : M_changetype T_CHANGETYPE M_normal any_space M_type modify_token M_normal SEP mod_spec_list",
"mod_spec_list : mod_spec",
"mod_spec_list : mod_spec_list SEP mod_spec",
"mod_spec : mod_add_spec",
"mod_spec : mod_delete_spec",
"mod_spec : mod_replace_spec",
"mod_add_spec : M_type ADDC M_normal any_space M_name_readnc NAMENC M_normal sep attrval_spec_list SEPBYMINUS M_type MINUS M_normal",
"mod_add_spec : M_type ADDC M_normal any_space M_name_readnc NAMENC M_normal sep attrval_spec_list error",
"mod_delete_spec : M_type DELETEC M_normal any_space M_name_readnc NAMENC M_normal maybe_attrval_spec_list SEPBYMINUS M_type MINUS M_normal",
"mod_replace_spec : M_type REPLACEC M_normal any_space M_name_readnc NAMENC M_normal maybe_attrval_spec_list SEPBYMINUS M_type MINUS M_normal",
"maybe_attrval_spec_list :",
"maybe_attrval_spec_list : sep attrval_spec_list",
"maybe_attrval_spec_list : error",
"maybe_attrval_spec_list : sep attrval_spec_list error",
"sep : SEP",
"sep : SEPBYCHANGE",
"any_sep : SEP",
"any_sep : MULTI_SEP",
"any_space :",
"any_space : MULTI_SPACE",
"dn : M_safeval VALUE M_normal",
"base64_dn : M_string64 BASE64STRING M_normal",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#line 1253 "ldif.y"



#line 424 "y_tab.c"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    //extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif

    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif

    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 85 "ldif.y"
{ DBGPRNT("ldif_Content\n"); }
break;
case 2:
#line 86 "ldif.y"
{ DBGPRNT("ldif_Changes\n"); }
break;
case 3:
#line 90 "ldif.y"
{ 
                    DBGPRNT("ldif_record_list\n"); 
                }
break;
case 4:
#line 94 "ldif.y"
{
                    DBGPRNT("v/ldif_record_list\n"); 
                }
break;
case 5:
#line 98 "ldif.y"
{ 
                    DBGPRNT("ldif_record_list\n"); 
                }
break;
case 6:
#line 104 "ldif.y"
{ 
                    DBGPRNT("ldif_change_record_list\n"); 
                }
break;
case 7:
#line 108 "ldif.y"
{ 
                    DBGPRNT("v/ldif_change_record_list\n");
                }
break;
case 8:
#line 112 "ldif.y"
{ 
                    DBGPRNT("ldif_change_record_list\n");
                }
break;
case 9:
#line 118 "ldif.y"
{ 
                    RuleLastBig=R_VERSION;
                    RuleExpect=RE_REC_OR_CHANGE;
                    TokenExpect=RT_DN;
                    DBGPRNT("Version spec\n");
                }
break;
case 10:
#line 126 "ldif.y"
{ 
                    RuleLast=RS_VERNUM;
                    RuleExpect=RE_REC_OR_CHANGE;
                    TokenExpect=RT_DN;
                    DBGPRNT("Version number\n"); 
                }
break;
case 15:
#line 152 "ldif.y"
{ 
                                
                            /**/
                            /* first action here is to take the linked list of */
                            /* attributes that was built up in attrval_spec_list */
                            /* and turn it into an LDAPModW **mods array. */
                            /* Everything having to do with the */
                            /* attrval_spec_list that is not necessary for the */
                            /* new array will be either destroyed or cleared*/
                            /**/
                            g_pObject.ppMod = GenerateModFromList(PACK);

                            SetModOps(g_pObject.ppMod, 
                                        LDAP_MOD_ADD);
                            
                            /**/
                            /* now assign the dn*/
                            /**/
                            g_pObject.pszDN = yyvsp[-2].wstr;
                            
                            DBGPRNT("\nldif_record\n"); 
                            
                            RuleLastBig=R_REC;
                            RuleExpect=RE_REC;
                            TokenExpect=RT_DN;
                            
                            if (FileType==F_NONE) {
                                FileType = F_REC;
                            } 
                            else if (FileType==F_CHANGE) {
                                RaiseException(LL_FTYPE, 0, 0, NULL);
                            }
                            return LDIF_REC;
                        }
break;
case 16:
#line 189 "ldif.y"
{ 
                            /**/
                            /* By the time we've parsed to here we've got a dn */
                            /* and a changes_list pointed to by changes_start. */
                            /* We're going to return to the caller the fact that */
                            /* what we're gving back is a changes list and not */
                            /* the regular g_pObject.ppMod. The client is */
                            /* responsible for walking down the list */
                            /* start_changes, using it, and, freeing the memory*/
                            /**/
                            g_pObject.pszDN = yyvsp[-2].wstr;
                            
                            DBGPRNT("\nldif_change_record\n"); 
                            
                            RuleLastBig = R_CHANGE;
                            RuleExpect = RE_CHANGE;
                            TokenExpect = RT_DN;
                            
                            if (FileType == F_NONE) {
                                FileType = F_CHANGE;
                            } 
                            else if (FileType == F_REC) {
                                RaiseException(LL_FTYPE, 0, 0, NULL);
                            }   
                            return LDIF_CHANGE;
                        }
break;
case 17:
#line 218 "ldif.y"
{ 
                            yyval.wstr = yyvsp[0].wstr; 
                            RuleLastBig=R_DN;
                            RuleExpect=RE_ENTRY;
                            TokenExpect=RT_ATTR_OR_CHANGE;
                        }
break;
case 18:
#line 225 "ldif.y"
{ 
                            yyval.wstr = yyvsp[0].wstr; 
                            RuleLastBig=R_DN;
                            RuleExpect=RE_ENTRY;
                            TokenExpect=RT_ATTR_OR_CHANGE;
                        }
break;
case 19:
#line 232 "ldif.y"
{ 
                            yyval.wstr = NULL; 
                            RuleLastBig=R_DN;
                            RuleExpect=RE_ENTRY;
                            TokenExpect=RT_ATTR_OR_CHANGE;
                        }
break;
case 20:
#line 247 "ldif.y"
{ 
                            RuleLastBig=R_AVS;
                            RuleExpect=RE_AVS_OR_END;
                            TokenExpect=RT_ATTR_MIN_SEP;
                         