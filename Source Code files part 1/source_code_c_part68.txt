t wchar_t *propertyNameArg ) : propertyValue ( NULL ) ,  
																		qualifierPosition ( NULL ) , 
																		tagged ( FALSE ) ,
																		m_IsNull ( TRUE ) ,
																		m_isKey ( FALSE ) ,
																		m_isVirtualKey ( FALSE ) ,
																		m_isReadable ( FALSE ) ,
																		m_isWritable ( FALSE ) ,
																		m_keyOrder ( 0 ) ,
																		m_TextualConvention ( 0 ) ,
																		m_Handle ( 0 ) ,
																		propertyName ( NULL )

{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: WbemSnmpProperty ( const wchar_t *propertyNameArg (%s) )" ,
		propertyNameArg
	) ;
) 

	propertyValue = new SnmpNullType ;
	propertyName = new wchar_t [ wcslen ( propertyNameArg ) + 1 ] ;
	wcscpy ( propertyName , propertyNameArg ) ;
}

WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ) :	propertyValue ( NULL ) , 
																		qualifierPosition ( NULL ) , 
																		tagged ( FALSE ) ,
																		m_IsNull ( TRUE ) ,
																		m_isKey ( FALSE ) ,
																		m_isVirtualKey ( FALSE ) ,
																		m_isReadable ( FALSE ) ,
																		m_isWritable ( FALSE ) ,
																		m_TextualConvention ( 0 ) ,
																		m_Handle ( 0 ) ,
																		propertyName ( NULL )
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ( (%s),(%s)) )" ,
			copy.propertyName ,
			t_StringValue 
		) ; 
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ( (%s),(NULL))" ,
			copy.propertyName 
		) ; 
	}
	
	delete [] t_StringValue ;
) 

	m_isReadable = copy.m_isReadable ;
	m_isWritable = copy.m_isWritable ;
	m_isKey = copy.m_isKey ;
	m_isVirtualKey = copy.m_isVirtualKey ;
	m_IsNull = copy.m_IsNull ;
	tagged = copy.tagged ;
	m_keyOrder = copy.m_keyOrder ;
	m_TextualConvention = copy.m_TextualConvention ;
	m_Handle = copy.m_Handle ;

	if ( copy.propertyValue )
	{
		propertyValue = copy.propertyValue->Copy () ;
	}

	if ( copy.propertyName )
	{
		propertyName = new wchar_t [ wcslen ( copy.propertyName ) + 1 ] ;
		wcscpy ( propertyName , copy.propertyName ) ;
	}

	POSITION position = copy.qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		copy.qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		WbemSnmpQualifier *copyQualifier = new WbemSnmpQualifier ( *qualifier ) ;
		qualifierMap [ copyQualifier->GetName () ] = copyQualifier ;
	}
}

WbemSnmpProperty :: ~WbemSnmpProperty () 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: ~WbemSnmpProperty ( ((%s),(%s)) )" ,
			propertyName ? propertyName : L"!!NULL!!",
			t_StringValue 
		) ; 
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: ~WbemSnmpProperty ( ((%s),(NULL)) )" ,
			propertyName ? propertyName : L"!!NULL!!"
		) ; 
	}
	
	delete [] t_StringValue ;
) 

	delete [] propertyName ;
	delete propertyValue ;

	POSITION position = qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		delete qualifier ;
	}

	qualifierMap.RemoveAll () ;
}

void WbemSnmpProperty :: SetTag ( BOOL tag )
{
	tagged = tag ;
}

BOOL WbemSnmpProperty :: GetTag ()
{
	return tagged ;
}

BOOL WbemSnmpProperty :: IsNull ()
{
	if ( propertyValue )
		return propertyValue->IsNull () ;
	else
		return TRUE ;
}

BOOL WbemSnmpProperty :: IsKey () 
{ 
	return m_isKey ; 
}

BOOL WbemSnmpProperty :: IsVirtualKey () 
{ 
	return m_isVirtualKey ; 
}

void WbemSnmpProperty :: SetKey ( BOOL a_isKey )
{
	m_isKey = a_isKey ; 
}

void WbemSnmpProperty :: SetVirtualKey ( BOOL a_isVirtualKey ) 
{
	m_isVirtualKey = a_isVirtualKey ; 
}

BOOL WbemSnmpProperty :: IsWritable () 
{ 
	return m_isWritable ; 
}

BOOL WbemSnmpProperty :: IsReadable () 
{ 
	return m_isReadable ; 
}

ULONG WbemSnmpProperty :: GetKeyOrder () 
{ 
	return m_keyOrder ; 
}

void WbemSnmpProperty :: SetWritable ( BOOL a_isWritable )
{
	m_isWritable = a_isWritable ; 
}

void WbemSnmpProperty :: SetReadable ( BOOL a_isReadable ) 
{
	m_isReadable = a_isReadable ; 
}

void WbemSnmpProperty :: SetKeyOrder ( ULONG a_keyOrder ) 
{
	m_keyOrder = a_keyOrder ;
}

void WbemSnmpProperty :: SetTextualConvention ( ULONG a_TextualConvention ) 
{
	m_TextualConvention = a_TextualConvention ; 
}

ULONG WbemSnmpProperty :: GetTextualConvention () 
{
	return m_TextualConvention ; 
}

CIMTYPE WbemSnmpProperty :: GetCimType () 
{
	CIMTYPE t_Type = VT_EMPTY ;

	cimTypeMap.Lookup ( m_TextualConvention , t_Type ) ;

	return t_Type ;
}

long WbemSnmpProperty :: GetHandle ()
{
	return m_Handle ;
}

void WbemSnmpProperty :: SetHandle ( long a_Handle ) 
{
	m_Handle = a_Handle ;
}

BOOL WbemSnmpProperty :: SetValue ( const VARIANT &variant , const CIMTYPE & type , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const VARIANT &variant )" ) ) 

	SnmpInstanceType *value = NULL ;
	if ( type == CIM_EMPTY )
	{
		value = new SnmpNullType ;
	}
	else
	{
		WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
		if ( qualifier )
		{	
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
			wchar_t *textualConvention = displayString->GetValue () ;
			if ( textualConvention )
			{ 
				ULONG qualifierIndex ;
				if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
				{
					switch ( qualifierIndex )
					{
						case WBEM_INDEX_TYPE_INTEGER:
						case WBEM_INDEX_TYPE_INTEGER32:
						{		
							if ( type == CIM_SINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpIntegerType ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIntegerType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER:
						case WBEM_INDEX_TYPE_COUNTER32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpCounterType ( variant.lVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpCounterType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER64:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpCounter64Type ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpCounter64Type ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_UNSIGNED32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpUInteger32Type ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpUInteger32Type ;
								}
							}
						}
						break;

						case WBEM_INDEX_TYPE_GAUGE:
						case WBEM_INDEX_TYPE_GAUGE32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpGaugeType ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpGaugeType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OCTETSTRING:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthOctetStringType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthOctetStringType ( fixed ) ;
										}
									}
									else
									{
// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpOctetStringType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{											
												value = new SnmpOctetStringType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpOctetStringType ( variant.bstrVal , NULL ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpOctetStringType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpObjectIdentifierType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpObjectIdentifierType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NULL:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_NULL )
								{
									value = new SnmpNullType ;
								}
								else if ( variant.vt == VT_BSTR )
								{
									value = new SnmpNullType ;
								}
							}
						}
						break;

						case WBEM_INDEX_TYPE_IPADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpIpAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIpAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_TIMETICKS:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpTimeTicksType ( variant.lVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpTimeTicksType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OPAQUE:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthOpaqueType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthOpaqueType ( fixed ) ;
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpOpaqueType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{
												value = new SnmpOpaqueType ( rangeValues ) ;
												
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpOpaqueType ( variant.bstrVal , NULL ) ;
										}
										else
										{
											value = new SnmpOpaqueType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NETWORKADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpNetworkAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpNetworkAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DISPLAYSTRING:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthDisplayStringType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthDisplayStringType ( fixed ) ;
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpDisplayStringType ( variant.bstrVal , rangeValues ) ;
											}
											else
											{
												value = new SnmpDisplayStringType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpDisplayStringType ( variant.bstrVal , NULL ) ;
										}
										else
										{
											value = new SnmpDisplayStringType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_MACADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpMacAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpMacAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_PHYSADDRESS:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthPhysAddressType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthPhysAddressType ( fixed ) ;	
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpPhysAddressType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{
												value = new SnmpPhysAddressType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpPhysAddressType ( variant.bstrVal , NULL ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpPhysAddressType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *enumerationValues = string->GetStringValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpEnumeratedType ( enumerationValues , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpEnumeratedType ( enumerationValues ) ;
										}

										delete [] enumerationValues ;
									}
								}
							}
						}	
						break ;

						case WBEM_INDEX_TYPE_BITS:
						{
							if ( type == ( CIM_STRING | CIM_FLAG_ARRAY ) )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *bitStringValues = string->GetStringValue () ;

										if ( variant.vt == ( VT_BSTR | VT_ARRAY ) )
										{
											if ( SafeArrayGetDim ( variant.parray ) == 1 )
											{
												LONG dimension = 1 ; 
												LONG lower ;
												SafeArrayGetLBound ( variant.parray , dimension , & lower ) ;
												LONG upper ;
												SafeArrayGetUBound ( variant.parray , dimension , & upper ) ;
												LONG count = ( upper - lower ) + 1 ;

												wchar_t **array = new wchar_t * [ count ] ;

												for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
												{
													BSTR element ;
													SafeArrayGetElement ( variant.parray , &elementIndex , & element ) ;

													array [ elementIndex - lower ] = element ;
												}

												value = new SnmpBitStringType ( bitStringValues , ( const wchar_t ** ) array , count ) ;

												for ( elementIndex = 0 ; elementIndex < count ; elementIndex ++ )
												{
													SysFreeString ( array [ elementIndex ] ) ;
												}

												delete [] array ;
											}
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpBitStringType ( bitStringValues ) ;
										}

										delete [] bitStringValues ;
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DATETIME:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpDateTimeType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpDateTimeType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpOSIAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpOSIAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpUDPAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpUDPAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpIPXAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIPXAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ROWSTATUS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpRowStatusType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpRowStatusType ;
								}
							}
						}
						break ;

						default:
						{
						}
						break ;

					}
				}
			}

			delete [] textualConvention ;
		}
	}

	BOOL status = TRUE ;

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( const wchar_t *valueString , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const wchar_t *valueString )" ) ) 

	SnmpInstanceType *value = NULL ;
	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{
						value = new SnmpIntegerType ( valueString , NULL ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						value = new SnmpCounterType ( valueString ) ;
					}
					break ;


					case WBEM_INDEX_TYPE_COUNTER64:
					{
						value = new SnmpCounter64Type ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						value = new SnmpUInteger32Type ( valueString , NULL ) ;
					}
					break;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					{
						value = new SnmpGaugeType ( valueString , NULL ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthOctetStringType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}
						}	
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpOctetStringType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpOctetStringType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						value = new SnmpObjectIdentifierType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
						value = new SnmpNullType ;
					}
					break ;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						value = new SnmpIpAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						value = new SnmpTimeTicksType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthOpaqueType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpOpaqueType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpOpaqueType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						value = new SnmpNetworkAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthDisplayStringType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}	
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpDisplayStringType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpDisplayStringType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						value = new SnmpMacAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthPhysAddressType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}	
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpPhysAddressType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpPhysAddressType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *enumerationValues = string->GetStringValue () ;
								value = new SnmpEnumeratedType ( enumerationValues , valueString ) ;
								delete [] enumerationValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *bitStringValues = string->GetStringValue () ;

								value = new SnmpBitStringType ( bitStringValues , NULL , 0 ) ;

								delete [] bitStringValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:
					{
						value = new SnmpDateTimeType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						value = new SnmpOSIAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						value = new SnmpUDPAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						value = new SnmpIPXAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						value = new SnmpRowStatusType ( valueString ) ;
					}
					break ;

					default:
					{
					}
					break ;

				}
			}
		}

		delete [] textualConvention ;
	}

	BOOL status = TRUE ;

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( const SnmpInstanceType *value , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpInstanceType *value )" ) ) 

	BOOL status = FALSE ;
	BOOL validValue = FALSE ;

	if ( value ) 
	{
		WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
		if ( qualifier )
		{	
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
			wchar_t *textualConvention = displayString->GetValue () ;
			if ( textualConvention )
			{ 
				ULONG qualifierIndex ;
				if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
				{
					switch ( qualifierIndex )
					{
						case WBEM_INDEX_TYPE_INTEGER:
						case WBEM_INDEX_TYPE_INTEGER32:
						{
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER:
						case WBEM_INDEX_TYPE_COUNTER32:
						{
							if ( typeid ( *value ) == typeid ( SnmpCounterType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER64:
						{
							if ( typeid ( *value ) == typeid ( SnmpCounter64Type ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_UNSIGNED32:
						{
							if ( typeid ( *value ) == typeid ( SnmpUInteger32Type ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}						
						}
						break;

						case WBEM_INDEX_TYPE_GAUGE:
						case WBEM_INDEX_TYPE_GAUGE32:
						{
							if ( typeid ( *value ) == typeid ( SnmpGaugeType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OCTETSTRING:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthOctetStringType ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										validValue = TRUE ;

										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthOctetStringType *octetString = ( SnmpFixedLengthOctetStringType * ) value ;
										LONG octetStringFixed = octetString->GetValueLength () ;
										if ( fixed == octetStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpOctetStringType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
						{
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NULL:
						{
							if ( typeid ( *value ) == typeid ( SnmpNullType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_IPADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpIpAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_TIMETICKS:
						{
							if ( typeid ( *value ) == typeid ( SnmpTimeTicksType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OPAQUE:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthOpaqueType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthOpaqueType *opaque = ( SnmpFixedLengthOpaqueType * ) value ;
										LONG opaqueFixed = opaque->GetValueLength () ;
										if ( fixed == opaqueFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpOpaqueType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NETWORKADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpNetworkAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DISPLAYSTRING:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthDisplayStringType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthDisplayStringType *displayString = ( SnmpFixedLengthDisplayStringType * ) value ;
										LONG displayStringFixed = displayString->GetValueLength () ;
										if ( fixed == displayStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_MACADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpMacAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_PHYSADDRESS:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthPhysAddressType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthPhysAddressType *displayString = ( SnmpFixedLengthPhysAddressType * ) value ;
										LONG displayStringFixed = displayString->GetValueLength () ;
										if ( fixed == displayStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpPhysAddressType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
						{
							if ( typeid ( *value ) == typeid ( SnmpEnumeratedType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_BITS:
						{
							if ( typeid ( *value ) == typeid ( SnmpBitStringType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DATETIME:
						{
							if ( typeid ( *value ) == typeid ( SnmpDateTimeType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpOSIAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpUDPAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpIPXAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ROWSTATUS:
						{
							if ( typeid ( *value ) == typeid ( SnmpRowStatusType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						default:
						{
						}
						break ;

					}
				}

				if ( validValue )
				{
					switch ( check )
					{
						case SetValueRegardlessReturnCheck:
						{
							if ( value->IsValid () ) 
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
							}
							else
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
								status = FALSE ;
							}
						}
						break ;

						case SetValueRegardlessDontReturnCheck:
						{
							delete propertyValue ;
							propertyValue = value->Copy () ;
						}
						break ;

						case DontSetValueReturnCheck:
						{
							if ( value->IsValid () ) 
							{
							}
							else
							{
								status = FALSE ;
							}

						}
						break ;

						case SetValueIfCheckOk:
						{
							if ( value->IsValid () ) 
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
							}
							else
							{
								status = FALSE ;
							}
						}
						break ;
					}
				}
				else
				{
					status = FALSE ;
				}
			}

			delete [] textualConvention ;
		}
	}

	return status ;

}

BOOL WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{
						if ( ! valueArg )
						{
							value = new SnmpIntegerType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							value = new SnmpIntegerType ( *integer , NULL ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpCounterType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
						{
							SnmpCounter *counter = ( SnmpCounter * ) valueArg ;
							value = new SnmpCounterType ( *counter ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER64:
					{
						if ( ! valueArg )
						{
							value = new SnmpCounter64Type ;
						}
						else
						{
							SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
							value = new SnmpCounter64Type ( *counter ) ;
						}

						status = TRUE ;
					}
					break ;

					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						if ( ! valueArg )
						{
							value = new SnmpUInteger32Type ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpUInteger32 ) )
						{
							SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
							value = new SnmpUInteger32Type ( *ui_integer32 , NULL ) ;

							status = TRUE ;
						}
					}
					break;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					{
						if ( ! valueArg )
						{
							value = new SnmpGaugeType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
						{
							SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
							value = new SnmpGaugeType ( *gauge , NULL ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthOctetStringType ( fixed ) ;
									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthOctetStringType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg ) 
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOctetStringType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOctetStringType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg ) 
								{
									value = new SnmpOctetStringType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpOctetStringType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpObjectIdentifierType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
						{
							SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
							value = new SnmpObjectIdentifierType ( *objectIdentifier ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
						if ( ! valueArg )
						{
							value = new SnmpNullType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpNull ) ) 
						{
							value = new SnmpNullType ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpIpAddressType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
						{
							SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
							value = new SnmpIpAddressType ( *ipAddress ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						if ( ! valueArg )
						{	
							value = new SnmpTimeTicksType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
						{
							SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
							value = new SnmpTimeTicksType ( *timeTicks ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthOpaqueType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;

									value = new SnmpFixedLengthOpaqueType ( fixed , *opaque ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOpaqueType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOpaqueType ( *opaque , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpOpaqueType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) ) 
								{
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
									value = new SnmpOpaqueType ( *opaque , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpNetworkAddressType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
						{
							SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
							value = new SnmpNetworkAddressType ( *ipAddress ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthDisplayStringType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthDisplayStringType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpDisplayStringType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpDisplayStringType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpDisplayStringType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpDisplayStringType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpMacAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpMacAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthPhysAddressType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthPhysAddressType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpPhysAddressType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpPhysAddressType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpPhysAddressType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpPhysAddressType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						if ( ! valueArg )
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *enumerationValues = string->GetStringValue () ;
									value = new SnmpEnumeratedType ( enumerationValues ) ;
									delete [] enumerationValues ;
									status = TRUE ;
								}
							}
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *enumerationValues = string->GetStringValue () ;
									value = new SnmpEnumeratedType ( enumerationValues , integer->GetValue () ) ;
									delete [] enumerationValues ;
									status = TRUE ;
								}
							}
						}		
					}
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						if ( ! valueArg )
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *bitStringValues = string->GetStringValue () ;

									value = new SnmpBitStringType ( bitStringValues ) ;
									status = TRUE ;

									delete [] bitStringValues ;
								}
							}
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *bitStringValues = string->GetStringValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpBitStringType ( bitStringValues , *octetString ) ;
									status = TRUE ;

									delete [] bitStringValues ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:					
					{
						if ( ! valueArg )
						{
							value = new SnmpDateTimeType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpDateTimeType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpOSIAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpOSIAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpUDPAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpUDPAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpIPXAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpIPXAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						if ( ! valueArg )
						{
							value = new SnmpRowStatusType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							value = new SnmpRowStatusType ( *integer ) ;
							status = TRUE ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			delete [] textualConvention ;
		}
	}

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;

}

HRESULT SetStringProp ( IWbemClassObject *a_Object , BSTR propertyName , VARIANT &t_Variant ) 
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER;
	
	if ( a_Object )
	{
		t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
	}

	return t_Result ;
}

HRESULT SetProp ( IWbemClassObject *a_Object , BSTR propertyName , VARIANT &t_Variant ) 
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER;
	
	if ( a_Object )
	{
		t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
	}

	return t_Result ;
}

#if 0

BOOL WbemSnmpProperty :: SetDWORD ( BOOL a_Status , IWbemObjectAccess *a_Object , DWORD a_Value , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WriteDWORD (

					GetHandle (),
					a_Value
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WriteDWORD (

				GetHandle (),
				a_Value
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WriteDWORD (

					GetHandle (),
					a_Value
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetNULL ( BOOL a_Status , IWbemObjectAccess *a_Object , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					0 ,
					NULL
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				0 ,
				NULL
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					0 ,
					NULL
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetSTRING ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t *t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				t_Value ,
				t_ValueLength
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetSTRINGARRAY ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t **t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				t_Value ,
				t_ValueLength
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( IWbemObjectAccess *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	switch ( GetTextualConvention () )
	{
		case WBEM_INDEX_TYPE_INTEGER:
		case WBEM_INDEX_TYPE_INTEGER32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)integer->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER:
		case WBEM_INDEX_TYPE_COUNTER32:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
			{
				SnmpCounter *counter = ( SnmpCounter * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)counter->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER64:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
				SnmpCounter64Type t_Counter ( *counter ) ;
				wchar_t *value = t_Counter.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_UNSIGNED32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpUInteger32 ) )
			{
				SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)ui_integer32->GetValue () , check ) ;
			}
		}
		break;

		case WBEM_INDEX_TYPE_GAUGE:
		case WBEM_INDEX_TYPE_GAUGE32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
			{
				SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)gauge->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OCTETSTRING:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthOctetStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOctetStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpOctetStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
				else
				{
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
			{
				SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
				SnmpObjectIdentifierType objectIdentifierType ( *objectIdentifier ) ;
				wchar_t *value = objectIdentifierType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NULL:
		{
			status = SetNull ( status , a_Object , check ) ;
		}
		break ;

		case WBEM_INDEX_TYPE_IPADDRESS:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpIpAddressType ipAddressType ( *ipAddress ) ;

				wchar_t *value = ipAddressType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_TIMETICKS:
		{
			if ( ! valueArg )
			{	
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
			{
				SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)timeTicks->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OPAQUE:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpFixedLengthOpaqueType opaqueType ( fixed , *opaque ) ;
							wchar_t *value = opaqueType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOpaqueType opaqueType ( *opaque , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = opaqueType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpOpaqueType opaqueType ( *opaque , NULL ) ;

							wchar_t *value = opaqueType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NETWORKADDRESS:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpNetworkAddressType ipAddressType ( *ipAddress ) ;
				wchar_t *value = ipAddressType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DISPLAYSTRING:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthDisplayStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpDisplayStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpDisplayStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_MACADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpMacAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_PHYSADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthPhysAddressType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpPhysAddressType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;

								status = TRUE ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpPhysAddressType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;

			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *enumerationValues = string->GetStringValue () ;
						SnmpEnumeratedType integerType ( enumerationValues , integer->GetValue () ) ;
						delete [] enumerationValues ;

						wchar_t *value = integerType.GetStringValue () ;
						status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
						delete [] value ;
					}
				}
			}		
		}
		break ;

		case WBEM_INDEX_TYPE_BITS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *bitStringValues = string->GetStringValue () ;

						SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
						SnmpBitStringType octetStringType ( bitStringValues , *octetString ) ;
						delete [] bitStringValues ;

						wchar_t **array ;
						LONG count = octetStringType.GetValue ( array ) ;

						SAFEARRAY *safeArray ;
						SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
						safeArrayBounds[0].lLbound = 0 ;
						safeArrayBounds[0].cElements = count ;

						safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

						for ( LONG index = 0 ; index < count ; index ++ )
						{
							BSTR element = SysAllocString ( array [ index ] ) ;
							SafeArrayPutElement ( safeArray , & index , element ) ;
							SysFreeString ( element ) ;
							delete [] ( array [ index ] ) ;
						}

						delete [] array ;

						t_Variant.vt = t_VarType = VT_ARRAY | VT_BSTR ;
						t_Variant.parray = safeArray ; 

						status = TRUE ;
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DATETIME:					
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpDateTimeType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpOSIAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;				
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpUDPAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpIPXAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ROWSTATUS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				SnmpRowStatusType integerType ( *integer ) ;

				wchar_t *value = integerType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	return status ;
}

#endif

BOOL WbemSnmpProperty :: SetValue ( IWbemClassObject *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	VARTYPE t_VarType = VT_NULL ;

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	if ( a_Object )
	{
		switch ( GetTextualConvention () )
		{
			case WBEM_INDEX_TYPE_INTEGER:
			case WBEM_INDEX_TYPE_INTEGER32:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_I4 ;
					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
					if ( qualifier ) 
					{
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
						{
							SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
							wchar_t *rangeValues = string->GetStringValue () ;
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							SnmpIntegerType integerType ( *integer , rangeValues ) ;
							delete [] rangeValues ;

							t_Variant.vt = t_VarType = VT_I4 ;
							t_Variant.lVal = integer->GetValue () ;

							status = integerType.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
						t_Variant.vt = t_VarType = VT_I4 ;
						t_Variant.lVal = integer->GetValue () ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_COUNTER:
			case WBEM_INDEX_TYPE_COUNTER32:
			{
				if ( ! valueArg ) 
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_I4 ;
					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
				{
					SnmpCounter *counter = ( SnmpCounter * ) valueArg ;

					t_Variant.vt = VT_I4 ;
					t_VarType = VT_UI4 ;
					t_Variant.lVal = counter->GetValue () ;

					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_COUNTER64:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;
					status = TRUE ;
				}
				else
				{
					SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
					SnmpCounter64Type t_Counter ( *counter ) ;
					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = t_Counter.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_UNSIGNED32:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_UI4 ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpUInteger32 ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
					if ( qualifier ) 
					{
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
						{
							SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
							wchar_t *rangeValues = string->GetStringValue () ;
							SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
							SnmpUInteger32Type ui_integer32Type ( *ui_integer32 , rangeValues ) ;
							delete [] rangeValues ;

							t_Variant.vt = VT_I4 ;
							t_VarType = VT_UI4 ;
							t_Variant.lVal = ui_integer32->GetValue () ;

							status = ui_integer32Type.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
						SnmpUInteger32Type ui_integer32Type ( *ui_integer32 , NULL ) ;
						t_Variant.vt = VT_I4 ;
						t_VarType = VT_UI4 ;
						t_Variant.lVal = ui_integer32->GetValue () ;

						status = TRUE ;
					}
				}
			}
			break;

			case WBEM_INDEX_TYPE_GAUGE:
			case WBEM_INDEX_TYPE_GAUGE32:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_UI4 ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
					if ( qualifier ) 
					{
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
						{
							SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
							wchar_t *rangeValues = string->GetStringValue () ;
							SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
							SnmpGaugeType gaugeType ( *gauge , rangeValues ) ;
							delete [] rangeValues ;

							t_Variant.vt = VT_I4 ;
							t_VarType = VT_UI4 ;
							t_Variant.lVal = gauge->GetValue () ;

							status = gaugeType.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
						SnmpGaugeType gaugeType ( *gauge , NULL ) ;
						t_Variant.vt = VT_I4 ;
						t_VarType = VT_UI4 ;
						t_Variant.lVal = gauge->GetValue () ;

						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_OCTETSTRING:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else
				{
					if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpFixedLengthOctetStringType octetStringType ( fixed , *octetString ) ;

								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									SnmpOctetStringType octetStringType ( *octetString , rangeValues ) ;
									delete [] rangeValues ;

									wchar_t *value = octetStringType.GetStringValue () ;
									t_Variant.bstrVal = SysAllocString ( value ) ;
									t_Variant.vt = t_VarType = VT_BSTR ;
									delete [] value ;

									status = octetStringType.SnmpInstanceType :: IsValid () ;
								}
								else
								{
								}
							}
							else 
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpOctetStringType octetStringType ( *octetString , NULL ) ;

								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
						}
					}
					else
					{
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
			{
				if ( ! valueArg ) 
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
				{
					SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
					SnmpObjectIdentifierType objectIdentifierType ( *objectIdentifier ) ;
					wchar_t *value = objectIdentifierType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					t_Variant.vt = t_VarType = VT_BSTR ;
					delete [] value ;

					status = objectIdentifierType.IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_NULL:
			{
				t_Variant.vt = t_VarType = VT_NULL ;
				status = TRUE ;
			}
			break ;

			case WBEM_INDEX_TYPE_IPADDRESS:
			{
				if ( ! valueArg ) 
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
				{
					SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
					SnmpIpAddressType ipAddressType ( *ipAddress ) ;

					wchar_t *value = ipAddressType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					t_Variant.vt = t_VarType = VT_BSTR ;
					delete [] value ;

					status = ipAddressType.IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_TIMETICKS:
			{
				if ( ! valueArg )
				{	
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_UI4 ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
				{
					SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
					SnmpTimeTicksType timeTicksType ( *timeTicks ) ;
					t_Variant.vt = VT_I4 ;
					t_VarType = VT_UI4 ;
					t_Variant.lVal = timeTicksType.GetValue () ;

					status = timeTicksType.IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_OPAQUE:
			{
				if ( ! valueArg ) 
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else
				{
					if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpFixedLengthOpaqueType opaqueType ( fixed , *opaque ) ;
								wchar_t *value = opaqueType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;

								delete [] value ;

								status = opaqueType.SnmpInstanceType :: IsValid () ;
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									SnmpOpaqueType opaqueType ( *opaque , rangeValues ) ;
									delete [] rangeValues ;

									wchar_t *value = opaqueType.GetStringValue () ;
									t_Variant.bstrVal = SysAllocString ( value ) ;
									t_Variant.vt = t_VarType = VT_BSTR ;

									delete [] value ;

									status = opaqueType.SnmpInstanceType :: IsValid () ;
								}
								else
								{
								}
							}
							else
							{
								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpOpaqueType opaqueType ( *opaque , NULL ) ;

								wchar_t *value = opaqueType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;

								delete [] value ;

								status = opaqueType.SnmpInstanceType :: IsValid () ;
							}
						}
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_NETWORKADDRESS:
			{
				if ( ! valueArg ) 
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
				{
					SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
					SnmpNetworkAddressType ipAddressType ( *ipAddress ) ;
					wchar_t *value = ipAddressType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					t_Variant.vt = t_VarType = VT_BSTR ;
					delete [] value ;

					status = ipAddressType.IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_DISPLAYSTRING:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;
					status = TRUE ;
				}
				else
				{
					if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpFixedLengthDisplayStringType octetStringType ( fixed , *octetString ) ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									SnmpDisplayStringType octetStringType ( *octetString , rangeValues ) ;
									delete [] rangeValues ;

									t_Variant.vt = t_VarType = VT_BSTR ;
									wchar_t *value = octetStringType.GetStringValue () ;
									t_Variant.bstrVal = SysAllocString ( value ) ;
									delete [] value ;

									status = octetStringType.SnmpInstanceType :: IsValid () ;
								}
								else
								{
								}
							}
							else
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType octetStringType ( *octetString , NULL ) ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
						}
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_MACADDRESS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
					SnmpMacAddressType octetStringType ( *octetString ) ;

					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = octetStringType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = octetStringType.SnmpInstanceType :: IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_PHYSADDRESS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;
					status = TRUE ;
				}
				else
				{
					if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpFixedLengthPhysAddressType octetStringType ( fixed , *octetString ) ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									SnmpPhysAddressType octetStringType ( *octetString , rangeValues ) ;
									delete [] rangeValues ;

									t_Variant.vt = t_VarType = VT_BSTR ;
									wchar_t *value = octetStringType.GetStringValue () ;
									t_Variant.bstrVal = SysAllocString ( value ) ;
									delete [] value ;

									status = octetStringType.SnmpInstanceType :: IsValid () ;
								}
								else
								{
								}
							}
							else
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpPhysAddressType octetStringType ( *octetString , NULL ) ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
						}
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;
					status = TRUE ;

				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
				{
					SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
						{
							SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
							wchar_t *enumerationValues = string->GetStringValue () ;
							SnmpEnumeratedType integerType ( enumerationValues , integer->GetValue () ) ;
							delete [] enumerationValues ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = integerType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = integerType.SnmpInstanceType :: IsValid () ;
						}
					}
				}		
			}
			break ;

			case WBEM_INDEX_TYPE_BITS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
						{
							SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
							wchar_t *bitStringValues = string->GetStringValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpBitStringType octetStringType ( bitStringValues , *octetString ) ;
							delete [] bitStringValues ;

							wchar_t **array ;
							LONG count = octetStringType.GetValue ( array ) ;

							SAFEARRAY *safeArray ;
							SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
							safeArrayBounds[0].lLbound = 0 ;
							safeArrayBounds[0].cElements = count ;

							safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

							for ( LONG index = 0 ; index < count ; index ++ )
							{
								BSTR element = SysAllocString ( array [ index ] ) ;
								SafeArrayPutElement ( safeArray , & index , element ) ;
								SysFreeString ( element ) ;
								delete [] ( array [ index ] ) ;
							}

							delete [] array ;

							t_Variant.vt = t_VarType = VT_ARRAY | VT_BSTR ;
							t_Variant.parray = safeArray ; 

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
			break ;

			case WBEM_INDEX_TYPE_DATETIME:					
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
					SnmpDateTimeType octetStringType ( *octetString ) ;

					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = octetStringType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = octetStringType.SnmpInstanceType :: IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
					SnmpOSIAddressType octetStringType ( *octetString ) ;

					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = octetStringType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = octetStringType.SnmpInstanceType :: IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
					SnmpUDPAddressType octetStringType ( *octetString ) ;

					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = octetStringType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = octetStringType.SnmpInstanceType :: IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
					SnmpIPXAddressType octetStringType ( *octetString ) ;

					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = octetStringType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = octetStringType.SnmpInstanceType :: IsValid () ;
				}
			}
			break ;

			case WBEM_INDEX_TYPE_ROWSTATUS:
			{
				if ( ! valueArg )
				{
					t_Variant.vt = VT_NULL ;
					t_VarType = VT_BSTR ;

					status = TRUE ;
				}
				else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
				{
					SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
					SnmpRowStatusType integerType ( *integer ) ;

					t_Variant.vt = t_VarType = VT_BSTR ;
					wchar_t *value = integerType.GetStringValue () ;
					t_Variant.bstrVal = SysAllocString ( value ) ;
					delete [] value ;

					status = integerType.SnmpInstanceType :: IsValid () ;
				}
			}
			break ;

			default:
			{
			}
			break ;
		}

		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
#if 0
				switch ( GetTextualConvention () )
				{
					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						HRESULT t_Result = SetStringProp ( a_Object , propertyName , t_Variant ) ;
						if ( FAILED ( t_Result ) )
						{
							status = FALSE ;
						}
					}
					break ;

					default:
					{
						HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
						if ( FAILED ( t_Result ) )
						{
							status = FALSE ;
						}
					}
					break ;
				}
#else
				HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
				if ( FAILED ( t_Result ) )
				{
					status = FALSE ;
				}
#endif
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
#if 1 
				HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
#else
				HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
#endif

				status = SUCCEEDED ( t_Result ) ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( status ) 
				{
#if 1 
					HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
#else
					HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
#endif
					status = SUCCEEDED ( t_Result ) ;
				}
			}
			break ;
		}
	}

	VariantClear ( & t_Variant ) ;

	return status ;

}

BOOL WbemSnmpProperty :: Encode ( const VARIANT &variant , SnmpObjectIdentifier &a_Encode )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: Encode ( const VARIANT &variant )" ) ) 

	BOOL t_Status = FALSE ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{		
						if ( variant.vt == VT_I4 )
						{
							SnmpIntegerType t_Integer ( variant.lVal , NULL ) ;
							a_Encode = t_Integer.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpCounterType t_Counter ( variant.lVal ) ;
							a_Encode = t_Counter.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER64:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpCounter64Type t_Counter ( variant.bstrVal ) ;
							a_Encode = t_Counter.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpUInteger32Type t_UIInteger32 ( variant.lVal , NULL ) ;
							a_Encode = t_UIInteger32.Encode ( a_Encode ) ;
						}
					}
					break;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpGaugeType t_Gauge ( variant.lVal , NULL ) ;
							a_Encode = t_Gauge.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthOctetStringType t_Octet ( fixed , variant.bstrVal ) ;
									a_Encode = t_Octet.Encode ( a_Encode ) ;
								}
							}
							else
							{
// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpOctetStringType t_Octet ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_Octet.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpOctetStringType t_Octet ( variant.bstrVal , NULL ) ;
									a_Encode = t_Octet.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpObjectIdentifierType t_ObjectIdentifier ( variant.bstrVal ) ;
							a_Encode = t_ObjectIdentifier.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
					}
					break;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpIpAddressType t_IpAddress ( variant.bstrVal ) ;
							a_Encode = t_IpAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpTimeTicksType t_TimeTicks ( variant.lVal ) ;
							a_Encode = t_TimeTicks.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthOpaqueType t_Opaque ( fixed , variant.bstrVal ) ;
									a_Encode = t_Opaque.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpOpaqueType t_Opaque ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_Opaque.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpOpaqueType t_Opaque ( variant.bstrVal , NULL ) ;
									a_Encode = t_Opaque.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpNetworkAddressType t_NetworkAddress ( variant.bstrVal ) ;
							a_Encode = t_NetworkAddress.Encode ( a_Encode ) ;

						}
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthDisplayStringType t_DisplayString ( fixed , variant.bstrVal ) ;
									a_Encode = t_DisplayString.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpDisplayStringType t_DisplayString ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_DisplayString.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpDisplayStringType t_DisplayString ( variant.bstrVal , NULL ) ;
									a_Encode = t_DisplayString.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpMacAddressType t_MacAddress ( variant.bstrVal ) ;
							a_Encode = t_MacAddress.Encode ( a_Encode ) ;

						}
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthPhysAddressType t_PhysAddress ( fixed , variant.bstrVal ) ;
									a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpPhysAddressType t_PhysAddress ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpPhysAddressType t_PhysAddress ( variant.bstrVal , NULL ) ;
									a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *enumerationValues = string->GetStringValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpEnumeratedType t_Enumeration ( enumerationValues , variant.bstrVal ) ;
									a_Encode = t_Enumeration.Encode ( a_Encode ) ;
;								}

								delete [] enumerationValues ;
							}
						}
					}	
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *bitStringValues = string->GetStringValue () ;

								if ( variant.vt == ( VT_BSTR | VT_ARRAY ) )
								{
									if ( SafeArrayGetDim ( variant.parray ) == 1 )
									{
										LONG dimension = 1 ; 
										LONG lower ;
										SafeArrayGetLBound ( variant.parray , dimension , & lower ) ;
										LONG upper ;
										SafeArrayGetUBound ( variant.parray , dimension , & upper ) ;
										LONG count = ( upper - lower ) + 1 ;

										wchar_t **array = new wchar_t * [ count ] ;

										for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
										{
											BSTR element ;
											SafeArrayGetElement ( variant.parray , &elementIndex , & element ) ;

											array [ elementIndex - lower ] = element ;
										}

										SnmpBitStringType t_BitString ( bitStringValues , ( const wchar_t ** ) array , count ) ;
										a_Encode = t_BitString.Encode ( a_Encode ) ;

										for ( elementIndex = 0 ; elementIndex < count ; elementIndex ++ )
										{
											SysFreeString ( array [ elementIndex ] ) ;
										}

										delete [] array ;
									}
								}

								delete [] bitStringValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpDateTimeType t_DateTime ( variant.bstrVal ) ;
							a_Encode = t_DateTime.SnmpOctetStringType :: Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpOSIAddressType t_OSIAddress ( variant.bstrVal ) ;
							a_Encode = t_OSIAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpUDPAddressType t_UDPAddress ( variant.bstrVal ) ;
							a_Encode = t_UDPAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpIPXAddressType t_IPXAddress ( variant.bstrVal ) ;
							a_Encode = t_IPXAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpRowStatusType t_RowStatus ( variant.bstrVal ) ;
							a_Encode = t_RowStatus.Encode ( a_Encode ) ;
						}
					}
					break ;

					default:
					{
					}
					break ;

				}
			}
		}

		delete [] textualConvention ;
	}

	return t_Status ;

}
wchar_t *WbemSnmpProperty :: GetName () const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,L"WbemSnmpProperty :: GetName ( (%s) )" ,
		propertyName 
	) 
) 

	return propertyName ;
}

SnmpInstanceType *WbemSnmpProperty :: GetValue () const 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: GetValue ( (%s),(%s) )" ,
			propertyName ,
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: GetValue ( (%s),(NULL) )" ,
			propertyName 
		) ;
	}	

	delete [] t_StringValue ;
) 

	return propertyValue ;
}

BOOL WbemSnmpProperty :: GetValue ( VARIANT &variant , CIMTYPE& cimType ) const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: GetValue ( VARIANT &variant )" ) ) 

	BOOL status = FALSE ;

	if ( propertyValue )
	{
		if ( typeid ( *propertyValue ) == typeid ( SnmpIntegerType ) )
		{
			SnmpIntegerType *integer = ( SnmpIntegerType * ) propertyValue ;
			if ( integer->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = integer->GetValue () ;
			}

			cimType = CIM_SINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpCounterType ) )
		{
			SnmpCounterType *counter = ( SnmpCounterType * ) propertyValue ;
			if ( counter->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = counter->GetValue () ;
			}
			
			cimType = CIM_UINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpCounter64Type ) )
		{
			SnmpCounter64Type *counter = ( SnmpCounter64Type * ) propertyValue ;
			if ( counter->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = counter->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpGaugeType ) )
		{
			SnmpGaugeType *gauge = ( SnmpGaugeType * ) propertyValue ;
			if ( gauge->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = gauge->GetValue () ;
			}

			cimType = CIM_UINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthOctetStringType ) )
		{
			SnmpFixedLengthOctetStringType *octetString = ( SnmpFixedLengthOctetStringType * ) propertyValue ;
			if ( octetString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = octetString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOctetStringType ) ) 
		{
			SnmpOctetStringType *octetString = ( SnmpOctetStringType * ) propertyValue ;
			if ( octetString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = octetString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpObjectIdentifierType ) ) 
		{
			SnmpObjectIdentifierType *objectIdentifier = ( SnmpObjectIdentifierType * ) propertyValue ;
			if ( objectIdentifier->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = objectIdentifier->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpNullType ) ) 
		{
			variant.vt = VT_NULL ;
			cimType = CIM_EMPTY;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpIpAddressType ) ) 
		{
			SnmpIpAddressType *ipAddress = ( SnmpIpAddressType * ) propertyValue ;
			if ( ipAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}			
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = ipAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpTimeTicksType ) ) 
		{
			SnmpTimeTicksType *timeTicks = ( SnmpTimeTicksType * ) propertyValue ;
			if ( timeTicks->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = timeTicks->GetValue () ;
			}

			cimType = CIM_SINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthOpaqueType ) )
		{
			SnmpFixedLengthOpaqueType *opaque = ( SnmpFixedLengthOpaqueType * ) propertyValue ;
			if ( opaque->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = opaque->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOpaqueType ) ) 
		{
			SnmpOpaqueType *opaque = ( SnmpOpaqueType * ) propertyValue ;
			if ( opaque->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = opaque->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpNetworkAddressType ) ) 
		{
			SnmpNetworkAddressType *networkAddress = ( SnmpNetworkAddressType * ) propertyValue ;
			if ( networkAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = networkAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthDisplayStringType ) )
		{
			SnmpFixedLengthDisplayStringType *displayString = ( SnmpFixedLengthDisplayStringType * ) propertyValue ;
			if ( displayString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = displayString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpDisplayStringType ) ) 
		{
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) propertyValue ;
			if ( displayString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = displayString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpMacAddressType ) ) 
		{
			SnmpMacAddressType *macAddress = ( SnmpMacAddressType * ) propertyValue ;
			if ( macAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = macAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}
				
			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpPhysAddressType ) ) 
		{
			SnmpPhysAddressType *physAddress = ( SnmpPhysAddressType * ) propertyValue ;
			if ( physAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = physAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpEnumeratedType ) ) 
		{
			SnmpEnumeratedType *enumeration = ( SnmpEnumeratedType * ) propertyValue ;
			if ( enumeration->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = enumeration->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpBitStringType ) ) 
		{
			SnmpBitStringType *bitString = ( SnmpBitStringType * ) propertyValue ;
			if ( bitString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				wchar_t **array ;
				LONG count = bitString->GetValue ( array ) ;

				SAFEARRAY *safeArray ;
				SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
				safeArrayBounds[0].lLbound = 0 ;
				safeArrayBounds[0].cElements = count ;

				safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

				for ( LONG index = 0 ; index < count ; index ++ )
				{
					BSTR element = SysAllocString ( array [ index ] ) ;
					SafeArrayPutElement ( safeArray , & index , element ) ;
					SysFreeString ( element ) ;
					delete [] ( array [ index ] ) ;
				}

				delete [] array ;

				variant.vt = VT_ARRAY | VT_BSTR ;
				variant.parray = safeArray ; 
			}
			
			cimType = CIM_STRING | CIM_FLAG_ARRAY;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpDateTimeType ) ) 
		{
			SnmpDateTimeType *dateTime = ( SnmpDateTimeType * ) propertyValue ;
			if ( dateTime->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = dateTime->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOSIAddressType ) ) 
		{
			SnmpOSIAddressType *osiAddress = ( SnmpOSIAddressType * ) propertyValue ;
			if ( osiAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = osiAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpUDPAddressType ) ) 
		{
			SnmpUDPAddressType *udpAddress = ( SnmpUDPAddressType * ) propertyValue ;
			if ( udpAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = udpAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpIPXAddressType ) ) 
		{
			SnmpIPXAddressType *ipxAddress = ( SnmpIPXAddressType * ) propertyValue ;
			if ( ipxAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{		
				variant.vt = VT_BSTR ;
				wchar_t *value = ipxAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpRowStatusType ) ) 
		{
			SnmpRowStatusType *rowStatus = ( SnmpRowStatusType * ) propertyValue ;
			if ( rowStatus->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{		
				variant.vt = VT_BSTR ;
				wchar_t *value = rowStatus->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
	}

	return status ;
}

VARTYPE WbemSnmpProperty :: GetValueVariantType () const
{
	VARTYPE varType = VT_NULL ;

	if ( propertyValue && ! ( propertyValue->IsNull () ) )
	{
		varType = GetValueVariantEncodedType () ;
	}
	else
	{
		VT_NULL ;
	}

	return varType ;
}

VARTYPE WbemSnmpProperty :: GetValueVariantEncodedType () const
{
	VARTYPE varType = VT_NULL ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			if ( _wcsicmp ( textualConvention , WBEM_TYPE_INTEGER ) == 0 )
			{
				varType = VT_I4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_INTEGER32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER64 ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_GAUGE ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_GAUGE32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_UNSIGNED32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OCTETSTRING ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OBJECTIDENTIFIER ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_NULL ) == 0 )
			{
				varType = VT_NULL ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_IPADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_TIMETICKS ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OPAQUE ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_NETWORKADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_DISPLAYSTRING ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_MACADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_PHYSADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_ENUMERATEDINTEGER ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_BITS ) == 0 )
			{
				varType = VT_BSTR | VT_ARRAY ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_DATETIME ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPOSIADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPIPXADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPUDPADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_ROWSTATUS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENCODING ) ;
				if ( qualifier )
				{	
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
					wchar_t *encoding = displayString->GetValue () ;
					if ( encoding )
					{ 
						if ( _wcsicmp ( encoding , WBEM_TYPE_INTEGER ) == 0 )
						{
							varType = VT_I4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_INTEGER32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER64 ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_GAUGE ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_GAUGE ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_UNSIGNED32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OCTETSTRING ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OBJECTIDENTIFIER ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_NULL ) == 0 )
						{
							varType = VT_NULL ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_IPADDRESS ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_TIMETICKS ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OPAQUE ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_NETWORKADDRESS ) == 0 )
						{
							varType = VT_BSTR ;
						}
					}

					delete [] encoding ;
				}
			}

			delete [] textualConvention ;
		}
	}

	return varType ;
}

BOOL WbemSnmpProperty :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{ 
	return FALSE  ; 
} 

BOOL WbemSnmpProperty :: AddQualifier ( WbemSnmpQualifier *a_qualifier )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: AddQualifier ( (%s) )" ,
		a_qualifier->GetName ()
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( a_qualifier->GetName () , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( a_qualifier->GetName () , qualifier ) )
		{
			delete a_qualifier;
		}
		else
		{
			qualifierMap [ a_qualifier->GetName () ] = a_qualifier ;
		}
	}
	else
	{
		delete a_qualifier;
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: AddQualifier ( wchar_t *qualifierName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: AddQualifier ( (%s) )" ,
		qualifierName
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( qualifierName , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
		{
		}
		else
		{
			qualifier = new WbemSnmpQualifier ( qualifierName , NULL ) ;
			qualifierMap [ qualifier->GetName () ] = qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

ULONG WbemSnmpProperty :: GetQualifierCount () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: GetQualifierCount" ) )

	return qualifierMap.GetCount () ;
}

void WbemSnmpProperty :: ResetQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: ResetQualifier" ) )

	qualifierPosition = qualifierMap.GetStartPosition () ;
}

WbemSnmpQualifier *WbemSnmpProperty :: NextQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: NextQualifier" ) )

	wchar_t *qualifierKey ;
	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierPosition )
	{
		qualifierMap.GetNextAssoc ( qualifierPosition , qualifierKey , qualifier ) ;
	}

	return qualifier ;
}

WbemSnmpQualifier *WbemSnmpProperty :: FindQualifier ( wchar_t *qualifierName ) const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: FindQualifier (%s)" ,
		qualifierName
	) 
)

	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
	{
	}

	return qualifier ;
}

WbemSnmpClassObject :: WbemSnmpClassObject ( 

	const wchar_t *classNameArg ,
	const BOOL isClass 

) : className ( NULL ),
	qualifierPosition ( NULL ) , 
	propertyPosition ( NULL ) , 
	keyedPropertyPosition ( 1 ) , 
	m_isClass ( isClass ) , 
	m_isKeyed ( FALSE ) , 
	m_isSingleton ( FALSE ) , 
	m_isVirtual ( FALSE ) , 
	m_isReadable ( FALSE ) ,
	m_isWritable ( FALSE ) ,
	m_numberOfAccessible ( 0 )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

	className = new wchar_t [ wcslen ( classNameArg ) + 1 ] ;
	wcscpy ( className , classNameArg ) ;
}

WbemSnmpClassObject :: WbemSnmpClassObject () :	className ( NULL ) , 
													qualifierPosition ( NULL ) , 
													propertyPosition ( NULL ) , 
													keyedPropertyPosition ( 1 ) ,
													m_isClass ( TRUE ) ,
													m_isKeyed ( FALSE ) ,
													m_isSingleton ( FALSE ) ,
													m_isVirtual ( FALSE ) ,
													m_isReadable ( FALSE ) ,
													m_isWritable ( FALSE ) ,
													m_numberOfAccessible ( 0 )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

}

WbemSnmpClassObject :: WbemSnmpClassObject ( 

	const WbemSnmpClassObject & copy 

) :	className ( NULL ) , 
	qualifierPosition ( NULL ) , 
	propertyPosition ( NULL ) , 
	keyedPropertyPosition ( 1 ) ,
	m_isClass ( copy.m_isClass ) ,
	m_isKeyed ( copy.m_isKeyed ) ,
	m_isSingleton ( copy.m_isSingleton ) ,
	m_isVirtual ( copy.m_isVirtual ) ,
	m_isReadable ( copy.m_isReadable ) ,
	m_isWritable ( copy.m_isWritable ) ,
	m_numberOfAccessible ( copy.m_numberOfAccessible )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

	if ( copy.className ) 
	{
		className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
		wcscpy ( className , copy.className ) ;
	}

	POSITION position = copy.propertyMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *propertyName ;
		WbemSnmpProperty *property ;
		copy.propertyMap.GetNextAssoc ( position , propertyName , property ) ;
		
		WbemSnmpProperty *copyProperty = new WbemSnmpProperty ( *property ) ;
		propertyMap [ copyProperty->GetName () ] = copyProperty ;
	}

	position = copy.qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		copy.qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		WbemSnmpQualifier *copyQualifier = new WbemSnmpQualifier ( *qualifier ) ;
		qualifierMap [ copyQualifier->GetName () ] = copyQualifier ;
	}

	position = copy.keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *keyProperty = copy.keyedPropertyList.GetNext ( position ) ;
		WbemSnmpProperty *property ;
		if ( propertyMap.Lookup ( keyProperty->GetName () , property ) )
		{
			keyedPropertyList.AddTail ( property ) ;
		}
	}
}

WbemSnmpClassObject :: ~WbemSnmpClassObject ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ~WbemSnmpClassObject ()" ) )

	delete [] className ;

	keyedPropertyList.RemoveAll () ;

	POSITION position = propertyMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *propertyName ;
		WbemSnmpProperty *property ;
		propertyMap.GetNextAssoc ( position , propertyName , property ) ;
		
		delete property ;
	}

	propertyMap.RemoveAll () ;

	position = qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		delete qualifier ;
	}

	qualifierMap.RemoveAll () ;
}

void WbemSnmpClassObject :: SetKeyed ( BOOL a_isKeyed )
{
	m_isKeyed = a_isKeyed ;
}

BOOL WbemSnmpClassObject :: IsKeyed ()
{
	return m_isKeyed ;
}

void WbemSnmpClassObject :: SetSingleton ( BOOL a_isSingleton )
{
	m_isSingleton = a_isSingleton ;
}

BOOL WbemSnmpClassObject :: IsSingleton ()
{
	return m_isSingleton ;
}

void WbemSnmpClassObject :: SetVirtual ( BOOL a_isVirtual )
{
	m_isVirtual = a_isVirtual ;
}

BOOL WbemSnmpClassObject :: IsVirtual ()
{
	return m_isVirtual ;
}

BOOL WbemSnmpClassObject :: IsWritable () 
{ 
	return m_isWritable ; 
}

BOOL WbemSnmpClassObject :: IsReadable () 
{ 
	return m_isReadable ; 
}

ULONG WbemSnmpClassObject :: GetNumberOfAccessible ()
{
	return m_numberOfAccessible ;
} 

void WbemSnmpClassObject :: SetWritable ( BOOL a_isWritable )
{
	m_isWritable = a_isWritable ; 
}

void WbemSnmpClassObject :: SetReadable ( BOOL a_isReadable ) 
{
	m_isReadable = a_isReadable ; 
}

void WbemSnmpClassObject :: SetNumberOfAccessible ( ULONG a_numberOfAccessible )
{
	m_numberOfAccessible = a_numberOfAccessible ;
}

wchar_t *WbemSnmpClassObject :: GetClassName () const
{
	return className ;
}

BOOL WbemSnmpClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{ 
	return FALSE ; 
} 

void WbemSnmpClassObject :: AddKeyedProperty ( WbemSnmpProperty *snmpProperty ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddKeyedProperty ( (%s) )" ,
		snmpProperty->GetName ()
	) ;
)

	WbemSnmpProperty *t_snmpProperty = FindProperty ( snmpProperty->GetName () ) ;
	if ( t_snmpProperty ) 
	{
		keyedPropertyList.AddTail ( snmpProperty ) ;
	}
}

BOOL WbemSnmpClassObject :: AddKeyedProperty ( wchar_t *propertyName ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddKeyedProperty ( (%s) )" ,
		propertyName
	) ;
)

	WbemSnmpProperty *snmpProperty = FindProperty ( propertyName ) ;
	if ( snmpProperty ) 
	{
		AddKeyedProperty ( snmpProperty ) ;
	}

	return snmpProperty ? TRUE : FALSE ;
}

ULONG WbemSnmpClassObject :: GetKeyPropertyCount ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetKeyPropertyCount" ) )

	return keyedPropertyList.GetCount () ;
}

void WbemSnmpClassObject :: ResetKeyProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetKeyProperty" ) )

	keyedPropertyPosition = 1 ;
}

WbemSnmpProperty *WbemSnmpClassObject :: NextKeyProperty () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextKeyProperty" ) )

	WbemSnmpProperty *property = NULL ;
	POSITION position = keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *value = keyedPropertyList.GetNext ( position ) ;
		WbemSnmpQualifier *qualifier ;
		if ( qualifier = value->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) ) 
		{
			SnmpInstanceType *typeValue = qualifier->GetValue () ;
			if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integer = ( SnmpIntegerType * ) qualifier->GetValue () ;
				if ( integer->GetValue () == keyedPropertyPosition )
				{
					property = value ;
					break ;
				}
			}
			else
			{
// Problem Here

			}
		}
		else
		{
// Problem Here
		}
	}

	keyedPropertyPosition ++ ;

	return property ;
}

WbemSnmpProperty *WbemSnmpClassObject :: FindKeyProperty ( wchar_t *propertyName ) const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: FindKeyProperty ( (%s)" ,
		propertyName
	) ;
)

	WbemSnmpProperty *property = NULL ;
	POSITION position = keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *value = keyedPropertyList.GetNext ( position ) ;
		if ( _wcsicmp ( value->GetName () , propertyName ) == 0 )
		{
			property = value ;
			break ;
		}
	}

	return property ;
}

ULONG WbemSnmpClassObject :: GetPropertyCount () 
{
	return propertyMap.GetCount () ;
}

BOOL WbemSnmpClassObject :: AddProperty ( WbemSnmpProperty *property )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddProperty ( (%s) )" ,
		property->GetName () 
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *propertyValue ;
	if ( propertyMap.Lookup ( property->GetName () , propertyValue ) ) 
	{
		delete property;
	}
	else
	{
		propertyMap [ property->GetName () ] = property ;
	}

	return TRUE ;
}

BOOL WbemSnmpClassObject :: AddProperty ( wchar_t *propertyName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddProperty ( (%s) )" ,
		propertyName
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *property ;
	if ( propertyMap.Lookup ( propertyName , property ) ) 
	{
	}
	else
	{
		property = new WbemSnmpProperty ( propertyName ) ;
		propertyMap [ property->GetName () ] = property ;
	}

	return TRUE ;
}

void WbemSnmpClassObject :: DeleteProperty ( wchar_t *propertyName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: DeleteProperty ( (%s) )" ,
		propertyName
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *property ;
	if ( propertyMap.Lookup ( propertyName , property ) ) 
	{
		propertyMap.RemoveKey ( propertyName ) ;
		POSITION keyPosition = keyedPropertyList.Find ( property ) ;
		if ( keyPosition )
		{
			keyedPropertyList.RemoveAt ( keyPosition ) ;
		}
		else
		{
// Problem Here
		}

		delete property ;
	}
}

void WbemSnmpClassObject :: ResetProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetProperty ()" ) )

	propertyPosition = propertyMap.GetStartPosition () ;
}

WbemSnmpProperty *WbemSnmpClassObject :: NextProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextProperty ()" ) )

	wchar_t *propertyKey ;
	WbemSnmpProperty *property = NULL ;
	if ( propertyPosition )
	{
		propertyMap.GetNextAssoc ( propertyPosition , propertyKey , property ) ;
	}

	return property ;
}

WbemSnmpProperty *WbemSnmpClassObject :: GetCurrentProperty ()
{
	wchar_t *propertyKey ;
	WbemSnmpProperty *property = NULL ;
	if ( propertyPosition )
	{
		propertyMap.GetCurrentAssoc ( propertyPosition , propertyKey , property ) ;
	}

	return property ;	
}

BOOL WbemSnmpClassObject :: GotoProperty ( WbemSnmpProperty *property ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextProperty ()" ) )

	ResetProperty () ;

	WbemSnmpProperty *t_Property ;
	while ( t_Property = NextProperty () )
	{
		if ( t_Property == property )
		{
			return TRUE ;
		}
	}

	return FALSE ;
}

WbemSnmpProperty *WbemSnmpClassObject :: FindProperty ( wchar_t *propertyName ) const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: FindProperty (%s) " ,
		propertyName
	) ;
)

	WbemSnmpProperty *property = NULL ;
	if ( propertyMap.Lookup ( propertyName , property ) )
	{
	}

	return property ;
}

ULONG WbemSnmpClassObject :: GetQualifierCount () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetQualifierCount ()" ) )

	return qualifierMap.GetCount () ;
}

BOOL WbemSnmpClassObject :: AddQualifier ( WbemSnmpQualifier *a_qualifier )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddQualifier ( (%s) )" ,
		a_qualifier->GetName ()
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( a_qualifier->GetName () , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( a_qualifier->GetName () , qualifier ) )
		{
			delete a_qualifier;
		}
		else
		{
			qualifierMap [ a_qualifier->GetName () ] = a_qualifier ;
		}
	}
	else
	{
		delete a_qualifier;
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpClassObject :: AddQualifier ( wchar_t *qualifierName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddQualifier ( (%s) )" ,
		qualifierName
	) ;
)


	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( qualifierName , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
		{
		}
		else
		{
			qualifier = new WbemSnmpQualifier ( qualifierName , NULL ) ;
			qualifierMap [ qualifier->GetName () ] = qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

void WbemSnmpClassObject :: ResetQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetQualifier" ) )

	qualifierPosition = qualifierMap.GetStartPosition () ;
}

WbemSnmpQualifier *WbemSnmpClassObject :: NextQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextQualifier" ) )

	wchar_t *qualifierKey ;
	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierPosition )
	{
		qualifierMap.GetNextAssoc ( qualifierPosition , qualifierKey , qualifier ) ;
	}

	return qualifier ;
}

WbemSnmpQualifier *WbemSnmpClassObject :: FindQualifier ( wchar_t *qualifierName ) const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: FindQualifier ( (%s) )",
		qualifierName
	) ;
)

	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
	{
	}

	return qualifier ;
}

BOOL WbemSnmpClassObject :: Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,
		L"BOOL WbemSnmpClassObject :: Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) ;
)

	BOOL result = SetMosClassObject ( a_errorObject , mosClassObject , rigorous ) ;

	return result ;
}

BOOL WbemSnmpClassObject :: SetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) 
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	
	VARIANT variant ;
	VariantInit ( & variant ) ;

	t_WBEM_result = mosClassObject->Get ( WBEM_PROPERTY_GENUS , 0 , &variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_WBEM_result ) )
	{
		m_isClass = ( ( variant.lVal ) == WBEM_GENUS_CLASS ) ? TRUE : FALSE ;

		t_WBEM_result = mosClassObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
		if ( SUCCEEDED ( t_WBEM_result ) )
		{
			className = new wchar_t [ wcslen ( variant.bstrVal ) + 1 ] ;
			wcscpy ( className , variant.bstrVal ) ;

			IWbemQualifierSet *classQualifierObject ;
			if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
			{
				status = SetMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
				if ( status )
				{
					status = SetMosClassObjectProperties ( a_errorObject , mosClassObject , rigorous ) ;
				}

				classQualifierObject->Release () ;
			}
			else
			{
/*
 *	Failed to get qualifier set. WBEM error
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;
			}
		}
		else
		{
/*
 *	Failed to get __Class property. WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to get __Class property" ) ;
		}
	}
	else
	{
/*
 * Failed to get __Genus property. WBEM error
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get __Genus property" ) ;
	}


/*
 *
 */

	if ( status )
	{
		if ( IsKeyed () )
		{
// Iterate through keys checking order is as expected

			ULONG keyPropertyCount = 0 ;

			ULONG keyOrder = 1 ;
			while ( keyOrder <= GetKeyPropertyCount () )
			{
				WbemSnmpProperty *property ;
				ResetProperty () ;
				while ( status && ( property = NextProperty () ) )
				{
					if ( property->IsKey () )
					{
						if ( keyOrder != property->GetKeyOrder () )
						{
						}
						else 
						{
	// Key order good
							keyPropertyCount ++ ;
							break ;
						}
					}
				}

				keyOrder ++ ;
			}

			if ( keyPropertyCount != GetKeyPropertyCount () )
			{
// Invalid key ordering
				status = FALSE ;

				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Class specified invalid key ordering" ) ;
			}
		}
		else
		{
// Class has no key properties 
		}
	}

	if ( status )
	{
		ULONG t_numberOfVirtuals = 0 ;
		if ( IsKeyed () && IsVirtual () )
		{
			WbemSnmpProperty *property ;
			ResetProperty () ;
			while ( property = NextProperty () )
			{
				if ( property->IsVirtualKey () )
				{
					t_numberOfVirtuals ++ ;
				}
			}
		}

		m_numberOfAccessible = GetPropertyCount () - t_numberOfVirtuals ;

		if ( m_numberOfAccessible == 0 )
		{
	// All properties are keyed,virtual

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain atleast one property which is not a virtual key or inaccessible" ) ;
		}
	}

	VariantClear ( & variant ) ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	
	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;

	classQualifierObject->BeginEnumeration ( 0 ) ;
	while ( classQualifierObject->Next ( 0 , & qualifierName , & variant , 	& qualifierFlavour ) == WBEM_NO_ERROR )
	{
		AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED  ) ;

				wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for class qualifier: " ) ;
				wchar_t *stringBuffer = UnicodeStringAppend ( temp , qualifierName ) ;
				delete [] temp ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}

			if ( qualifier = FindQualifier ( WBEM_QUALIFIER_SINGLETON ) )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
					SetSingleton ( integer->GetValue () ) ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for class qualifier: singleton" ) ;
				}
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}

	classQualifierObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	BSTR propertyName = NULL ;
	
	CIMTYPE cimType;
	mosClassObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
	while ( status && ( mosClassObject->Next ( 0 , &propertyName , &variant , &cimType , NULL ) == WBEM_NO_ERROR ) )
	{
		IWbemQualifierSet *propertyQualifierSet ;
		if ( ( t_WBEM_result = mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierSet ) ) == WBEM_NO_ERROR ) 
		{
			VARIANT textualConventionVariant ;
			VariantInit ( &textualConventionVariant ) ;

			LONG flag;
			if ( SUCCEEDED ( propertyQualifierSet->Get ( WBEM_QUALIFIER_TEXTUAL_CONVENTION , 0 , &textualConventionVariant , &flag ) ) )
			{
				AddProperty ( propertyName ) ;
				WbemSnmpProperty *property = FindProperty ( propertyName ) ;
				if ( property )
				{
					status = SetMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierSet ) ;
					if ( status )
					{
						WbemSnmpQualifier *qualifier ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									AddKeyedProperty ( propertyName ) ;
									property->SetKey () ;
									SetKeyed () ;

									if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) )
									{
										SnmpInstanceType *value = qualifier->GetValue () ;
										if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
										{
											SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
											property->SetKeyOrder ( integer->GetValue () ) ;
										}
										else
										{
											wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
											wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: key_order") ;
											delete [] prefix ;
											a_errorObject.SetMessage ( stringBuffer ) ;
											delete [] stringBuffer ; 

											status = FALSE ;
											a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
											a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										}
									}
									else
									{
// Keyed property contains no key order

										wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
										wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' is defined as a key but contains no key_order qualifier") ;
										delete [] prefix ;
										a_errorObject.SetMessage ( stringBuffer ) ;
										delete [] stringBuffer ; 

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									}
								}

								if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_VIRTUAL_KEY ) )
								{
									SnmpInstanceType *value = qualifier->GetValue () ;
									if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
										if ( integer->GetValue () )
										{
											property->SetVirtualKey () ;
											SetVirtual () ;
										}
									}							
									else
									{
										wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
										wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: virtual_key") ;
										delete [] prefix ;
										a_errorObject.SetMessage ( stringBuffer ) ;
										delete [] stringBuffer ; 

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									}
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: key") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}
						
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_READ ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									property->SetReadable () ;
									SetReadable () ;
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: read") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_WRITE ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									property->SetWritable () ;
									SetWritable () ;
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: write") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( ! property->IsVirtualKey () )
						{
							// Check Object Identifier Present

							if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ) 
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
								{
								}
								else
								{
// Problem Here
									wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
									wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: object_identifier") ;
									delete [] prefix ;
									a_errorObject.SetMessage ( stringBuffer ) ;
									delete [] stringBuffer ; 

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								}
							}
							else
							{
// No Object Identifier present
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' must specify valid qualifier for: object_identifier" ) ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
								wchar_t *string = displayString->GetValue () ;

								ULONG stringItem ;
								if ( textualConventionMap.Lookup ( string , stringItem ) )
								{
									property->SetTextualConvention ( stringItem ) ;
								}

								delete [] string ;

							}							
						}

						if ( rigorous )
						{
							if ( property->SetValue ( variant , cimType , SetValueIfCheckOk ) )
							{
								IWbemObjectAccess *t_Access = NULL ;
								HRESULT result = mosClassObject->QueryInterface (

									IID_IWbemObjectAccess ,
									(void**)&t_Access 
								) ;

								if ( SUCCEEDED ( result ) )
								{
									long t_Handle ;

									
									HRESULT result = t_Access->GetPropertyHandle (

										propertyName ,
										NULL ,
										& t_Handle 
									);

									if ( SUCCEEDED ( result ) )
									{
										property->SetHandle ( t_Handle ) ;
									}

	
									t_Access->Release () ;
								}
							}
							else
							{
/*
 *	Property Expected Type and property Value Type were not the same
 */

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

								wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
								delete [] temp ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

							}
						}
						else
						{
							if ( property->SetValue ( variant , cimType , SetValueRegardlessDontReturnCheck ) )
							{
							}
							else
							{
/*
 *	Property Expected Type and property Value Type were not the same. Should not happen.
 */

								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for property value" ) ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 


								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
							}
						}
					}
				}
				else
				{
				}
			}

			VariantClear ( & textualConventionVariant ) ;

			propertyQualifierSet->Release () ;

		}
		else
		{
/*
 * Failed to get qualifier set . WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Failed to get qualifier set for: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}

		SysFreeString ( propertyName ) ;

		VariantClear ( & variant ) ;
	}

	mosClassObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
	DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObjectPropertyQualifiers (WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;
	propertyQualifierSet->BeginEnumeration ( 0 ) ;
	while ( status && ( propertyQualifierSet->Next ( 0 , & qualifierName , & variant , & qualifierFlavour ) == WBEM_NO_ERROR ) )
	{
		snmpProperty->AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = snmpProperty->FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

				wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , snmpProperty->GetName () ) ;
				wchar_t *suffix = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: ") ;
				delete [] prefix ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , qualifierName ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 

			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}
	
	propertyQualifierSet->EndEnumeration () ;
	
	return status ;
}

BOOL WbemSnmpClassObject :: Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )"
	) ;
)
	BOOL result = MergeMosClassObject ( a_errorObject , mosClassObject , rigorous ) ;

	return result ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObject (WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )"
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	
	IWbemQualifierSet *classQualifierObject ;
	if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
	{
		status = MergeMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
		if ( status )
		{
			status = MergeMosClassObjectProperties ( a_errorObject , mosClassObject , rigorous ) ;
		}

		classQualifierObject->Release () ;
	}
	else
	{
/*
 *	Failed to get qualifier set. WBEM error
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;
	}

/*
 *
 */

	if ( status )
	{
		if ( IsKeyed () )
		{
// Iterate through keys checking order is as expected

			ULONG keyPropertyCount = 0 ;

			ULONG keyOrder = 1 ;
			while ( keyOrder <= GetKeyPropertyCount () )
			{
				WbemSnmpProperty *property ;
				ResetProperty () ;
				while ( status && ( property = NextProperty () ) )
				{
					if ( property->IsKey () )
					{
						if ( keyOrder != property->GetKeyOrder () )
						{
						}
						else 
						{
	// Key order good
							keyPropertyCount ++ ;
							break ;
						}
					}
				}

				keyOrder ++ ;
			}

			if ( keyPropertyCount != GetKeyPropertyCount () )
			{
// Invalid key ordering
				status = FALSE ;

				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Class specified invalid key ordering" ) ;
			}
		}
		else
		{
// Class has no key properties 
		}
	}

	if ( status )
	{
		ULONG t_numberOfVirtuals = 0 ;
		if ( IsKeyed () && IsVirtual () )
		{
			WbemSnmpProperty *property ;
			ResetProperty () ;
			while ( property = NextProperty () )
			{
				if ( property->IsVirtualKey () )
				{
					t_numberOfVirtuals ++ ;
				}
			}
		}

		m_numberOfAccessible = GetPropertyCount () - t_numberOfVirtuals ;

		if ( m_numberOfAccessible == 0 )
		{
// All properties are keyed,virtual

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain atleast one property which is not a virtual key or inaccessible" ) ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectProperties (WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	
	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;

	classQualifierObject->BeginEnumeration ( 0 ) ;
	while ( classQualifierObject->Next ( 0 , & qualifierName , & variant , & qualifierFlavour) == WBEM_NO_ERROR )
	{
		AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED  ) ;

				wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for class qualifier: " ) ;
				wchar_t *stringBuffer = UnicodeStringAppend ( temp , qualifierName ) ;
				delete [] temp ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}

	classQualifierObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectProperties" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	BSTR propertyName = NULL ;
	
	CIMTYPE cimType ;
	mosClassObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
	while ( status && ( mosClassObject->Next ( 0 , &propertyName , &variant , &cimType , NULL ) == WBEM_NO_ERROR ) )
	{
		IWbemQualifierSet *propertyQualifierSet ;
		if ( ( t_WBEM_result = mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierSet ) ) == WBEM_NO_ERROR ) 
		{
			WbemSnmpProperty *property = FindProperty ( propertyName ) ;
			if ( property )
			{
				status = MergeMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierSet ) ;
				if ( status )
				{
					WbemSnmpQualifier *qualifier ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								if ( ! FindKeyProperty ( propertyName ) )
								{
									AddKeyedProperty ( propertyName ) ;
								}

								property->SetKey () ;
								SetKeyed () ;

								if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) )
								{
									SnmpInstanceType *value = qualifier->GetValue () ;
									if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
										property->SetKeyOrder ( integer->GetValue () ) ;
									}
									else
									{
										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Type mismatch for qualifier: key_order" ) ;
									}
								}
								else
								{
		// Keyed property contains no key order

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Property is defined as a key but contains no key_order qualifier" ) ;
								}
							}

							if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_VIRTUAL_KEY ) )
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
									if ( integer->GetValue () )
									{
										property->SetVirtualKey () ;
										SetVirtual () ;
									}
								}							
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Type mismatch for qualifier: virtual_key" ) ;
								}
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: key" ) ;
						}
					}
					
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_READ ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								property->SetReadable () ;
								SetReadable () ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: read" ) ;
						}

					}

					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_WRITE ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								property->SetWritable () ;
								SetWritable () ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: write" ) ;
						}

					}

					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_SINGLETON ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							SetSingleton ( integer->GetValue () ) ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: singleton" ) ;
						}
					}

					if ( ! property->IsVirtualKey () )
					{
						// Check Object Identifier Present

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ) 
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
							}
							else
							{
		// Problem Here
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type mismatch for qualifier: object_identifier" ) ;
							}
						}
						else
						{
		// No Object Identifier present
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Property must specify valid qualifier for: object_identifier" ) ;
						}
					}

					if ( rigorous )
					{
						if ( property->SetValue ( variant , cimType , SetValueIfCheckOk ) )
						{
						}
						else
						{
/*
*	Property Expected Type and property Value Type were not the same
*/

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

							wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
							wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
							delete [] temp ;
							a_errorObject.SetMessage ( stringBuffer ) ;
							delete [] stringBuffer ; 

						}
					}
					else
					{
						if ( property->SetValue ( variant , cimType , SetValueRegardlessDontReturnCheck ) )
						{
						}
						else
						{
/*
*	Property Expected Type and property Value Type were not the same. Should not happen.
*/

							wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
							wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for property value" ) ;
							delete [] prefix ;
							a_errorObject.SetMessage ( stringBuffer ) ;
							delete [] stringBuffer ; 


							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
						}
					}
				}
			}
			else
			{
			}

			propertyQualifierSet->Release () ;

		}
		else
		{
/*
 * Failed to get qualifier set . WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Failed to get qualifier set for: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}

		SysFreeString ( propertyName ) ;

		VariantClear ( & variant ) ;
	}

	mosClassObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;
	propertyQualifierSet->BeginEnumeration ( 0 ) ;
	while ( status && ( propertyQualifierSet->Next ( 0 , & qualifierName , & variant , & qualifierFlavour ) == WBEM_NO_ERROR ) )
	{
		if (_wcsicmp(qualifierName, WBEM_QUALIFIER_TYPE_MISMATCH) == 0)
		{
			continue;
		}

		snmpProperty->AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = snmpProperty->FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

				wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , snmpProperty->GetName () ) ;
				wchar_t *suffix = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: ") ;
				delete [] prefix ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , qualifierName ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}
	
	propertyQualifierSet->EndEnumeration () ;
	
	return status ;
}

BOOL WbemSnmpClassObject :: Get ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: Get" ) )

	BOOL status = GetMosClassObject ( a_errorObject , mosClassObject ) ;

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObject" ) )

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemQualifierSet *classQualifierObject ;
	if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
	{
		status = GetMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
		if ( status )
		{
			status = GetMosClassObjectProperties ( a_errorObject , mosClassObject ) ;
		}
		else
		{
		}

		classQualifierObject->Release () ;
	}
	else
	{
/*
 *	Couldn't get object qualifier set.
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;

	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectQualifiers" ) )

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier ;
	ResetQualifier () ;
	while ( status && ( qualifier = NextQualifier () ) )
	{
		if ( qualifier->IsPropagatable () )
		{
			wchar_t *qualifierName = qualifier->GetName () ;

			if ( qualifier->GetValue ( variant ) )
			{
				t_WBEM_result = classQualifierObject->Put ( qualifierName , &variant , WBEM_CLASS_PROPAGATION ) ;
				if ( SUCCEEDED ( t_WBEM_result ) )
				{
				}
				else
				{
	/*
	 *	Failed to set qualifier value. Should not happen.
	 */
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetMessage ( L"Failed to set class qualifier value" ) ;

				}
			}
			else
			{
	/*
	 *	Failed to get qualifier value. Should not happen.
	 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to get class qualifier value" ) ;
			}

			VariantClear ( & variant ) ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectProperties" ) )

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		wchar_t *propertyName = property->GetName () ;

		IWbemQualifierSet *propertyQualifierObject ;
		if ( SUCCEEDED ( mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierObject ) ) )
		{
			status = GetMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierObject ) ;
			if ( status )
			{
				CIMTYPE cimType ;
				if ( property->GetValue ( variant , cimType ) )
				{
					if ( IsClass () )
					{
						if ( property->IsNull () )
						{
							t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , cimType ) ;
						}
						else
						{
							t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , 0 ) ;
						}
					}
					else
					{
						t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , 0 ) ;
					}

					if ( SUCCEEDED ( t_WBEM_result ) )
					{
					}
					else
					{
/*
 *	Failed to set property value. Should not happen.
 */

						
						wchar_t *prefix = UnicodeStringAppend ( L"Failed to set property value for property \'" , propertyName ) ;
						wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
						delete [] prefix ;
						a_errorObject.SetMessage ( stringBuffer ) ;
						delete [] stringBuffer ; 

						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
						a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
					}
				}
				else
				{
		/*
		 *	Failed to get property value. Should not happen.
		 */

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Failed to get property value for property \'" , propertyName ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					a_errorObject.SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}

				VariantClear ( & variant ) ;
			}

			propertyQualifierObject->Release () ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectPropertyQualifiers" ) )

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier ;
	snmpProperty->ResetQualifier () ;
	while ( status && ( qualifier = snmpProperty->NextQualifier () ) )
	{
		if ( qualifier->IsPropagatable () )
		{
			wchar_t *qualifierName = qualifier->GetName () ;

			if ( qualifier->GetValue ( variant ) )
			{
				t_WBEM_result = ( WBEMSTATUS ) propertyQualifierSet->Put ( qualifierName , &variant , WBEM_CLASS_PROPAGATION ) ;
				if ( SUCCEEDED ( t_WBEM_result ) )
				{
				}
				else
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Failed to set property qualifier \'" , qualifierName ) ;
					wchar_t *middle = UnicodeStringAppend ( prefix , L"\' for property \'" ) ;
					delete [] prefix ;
					wchar_t *suffix = UnicodeStringAppend ( middle , snmpProperty->GetName () ) ;
					delete [] middle ;
					wchar_t *stringBuffer = UnicodeStringAppend ( suffix , L"\'" ) ;
					delete [] suffix ;
					a_errorObject.SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				}
			}
			else
			{

				wchar_t *prefix = UnicodeStringAppend ( L"Failed to get property qualifier \'" , qualifierName ) ;
				wchar_t *middle = UnicodeStringAppend ( prefix , L"\' for property \'" ) ;
				delete [] prefix ;
				wchar_t *suffix = UnicodeStringAppend ( middle , snmpProperty->GetName () ) ;
				delete [] middle ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , L"\'" ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 


				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			}

			VariantClear ( & variant ) ;
		}
	}

	return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "snmpget.h"
#include "snmpset.h"

SetOperation :: SetOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpSetResponseEventObject *eventObjectArg 

) :	SnmpSetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 

{
}

SetOperation :: ~SetOperation ()
{
	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void SetOperation :: ReceiveResponse () 
{
// Inform creator all is done

	eventObject->ReceiveComplete () ;
}

void SetOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;
}

#pragma warning (disable:4065)

void SetOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported No Such Name for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

// Invalid property requested

					property->AddQualifier ( WBEM_QUALIFIER_NOT_AVAILABLE ) ;
					WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_NOT_AVAILABLE ) ;
					if ( qualifier )
					{
						SnmpIntegerType integer ( 1 , NULL ) ;
						if ( qualifier->SetValue ( &integer ) )
						{
						}
						else
						{
// Problem Here
						}
					}
					else
					{
// Problem Here
					}
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					property->SetTag ( FALSE ) ;
					eventObject->SnmpTooBig () ;
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void SetOperation :: FrameTooBig () 
{
	eventObject->SnmpTooBig () ;
	CancelRequest () ;
}

void SetOperation :: FrameOverRun () 
{
	eventObject->SnmpTooBig () ;

#if 0
	eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
	eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
	eventObject->GetErrorObject ().SetMessage ( L"Set Request could not fit into single SNMP PDU" ) ;
#endif

	CancelRequest () ;
}

void SetOperation :: Send ( const ULONG &a_NumberToSend )
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;

	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	SnmpSetClassObject *snmpObject = ( SnmpSetClassObject * ) eventObject->GetSnmpClassObject () ;
	if ( snmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( snmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetKeyProperty () ;
			while ( property = snmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}	
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		if ( ! m_PropertyContainer )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetProperty () ;
			while ( property = snmpObject->NextProperty () )
			{
				if ( snmpObject->IsWritable ( property ) )
				{
					BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
					t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

					if ( t_Status )
					{
						if ( property->IsVirtualKey () == FALSE )
						{
							m_PropertyContainerLength ++ ;
						}
					}
				}
			}

			m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;
		}


// Add Variable binding to Variable binding list

		ULONG t_Count = 0 ;

/*
 * First add row status property
 */

		WbemSnmpProperty *property ;
		snmpObject->ResetProperty () ;
		while ( property = snmpObject->NextProperty () ) 
		{
			if ( ( typeid ( *property->GetValue () ) == typeid ( SnmpRowStatusType ) ) & ( ! property->GetTag () ) )
			{
				property->SetTag ( TRUE ) ;

				WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
				if ( qualifier )
				{
					SnmpInstanceType *value = qualifier->GetValue () ;
					if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
					{
						SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
						SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
						SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

						SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

// Create queue of properties which have duplicate object identifiers

						m_PropertyContainer [ t_Count ] = property ;

						const SnmpValue *snmpValue = property->GetValue()->GetValueEncoding () ;
						SnmpVarBind varBind ( requestIdentifier , *snmpValue ) ;
						varBindList.Add ( varBind ) ;

						t_Count ++ ;
					}
				}
			}
		}

		snmpObject->ResetProperty () ;
		while ( ( property = snmpObject->NextProperty () ) && ( a_NumberToSend == 0xffffffff ) || ( ( a_NumberToSend != 0xffffffff ) && ( t_Count < a_NumberToSend ) ) )
		{
			if ( ! property->GetTag () )
			{
				BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						if ( snmpObject->IsWritable ( property ) )
						{
							//now that we've checked that it is writable set it and mark it set
							property->SetTag ( TRUE ) ;
							WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
							if ( qualifier )
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
								{
									SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
									SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
									SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

									SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

// Create queue of properties which have duplicate object identifiers

									m_PropertyContainer [ t_Count ] = property ;

									const SnmpValue *snmpValue = property->GetValue()->GetValueEncoding () ;
									SnmpVarBind varBind ( requestIdentifier , *snmpValue ) ;
									varBindList.Add ( varBind ) ;

									t_Count ++ ;
								}
								else
								{
// Problem Here
								}
							}
							else
							{
// Problem Here
							}
						}
					}
				}
			}
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
// Problem Here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\storage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include <provexpt.h>
#include <cordefs.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <notify.h>
#include <snmplog.h>
#include <autoptr.h>

extern ISmirDatabase* g_pNotifyInt;
extern CCorrCacheNotify *gp_notify;

CCorrGroupArray::CCorrGroupArray()
{
	SetSize(0, 10000);
}

int _cdecl compare( const void *arg1, const void *arg2 )
{
	CCorrObjectID tmp1;
	(*(CCorrGroupIdItem**)arg1)->GetGroupID(tmp1);
	CCorrObjectID tmp2;
	(*(CCorrGroupIdItem**)arg2)->GetGroupID(tmp2);

	switch (tmp1.CompareWith(tmp2))
	{
		case ECorrAreEqual:
		break;

		case ECorrFirstLess:
		return -1;

		case ECorrFirstGreater:
		return 1;
	}

	return 0;
}

void CCorrGroupArray::Sort()
{
	if (GetSize())
	{
		//CObject** temp = GetData();
		qsort((void *)GetData(), (size_t)GetSize(),
				sizeof( CCorrGroupIdItem * ), compare );
	}

	FreeExtra();
}


//============================================================================
//  CCorrGroupArray::~CCorrGroupArray
//
//  This is the CCorrGroupArray class's only desstructor. If there are any items in
//	the queue they are deleted.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupArray::~CCorrGroupArray()
{
	for (int x = 0; x < GetSize(); x++)
	{
		CCorrGroupIdItem * item = GetAt(x);
		delete item;
	}

	RemoveAll();
}


//============================================================================
//  CCorrGroupIdItem::CCorrGroupIdItem
//
//  This is the CCorrGroupIdItem class's only constructor. This class is derived from
//	the CObject class. This is so the MFC template storage classes can be
//	used. It is used to store a CString value in a list.
//
//
//  Parameters:
//
//      CString * str  	A pointer to the CString object to be stored.
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupIdItem::CCorrGroupIdItem(IN const CCorrObjectID& ID, IN ISmirGroupHandle*	grpH)
				: m_groupId(ID)
{
	m_index = 0;

	if (grpH)
	{
		m_groupHandles.AddHead(grpH);
	}
}


void CCorrGroupIdItem::GetGroupID(OUT CCorrObjectID& ID) const
{
	m_groupId.ExtractOID(ID);
}


void CCorrGroupIdItem::DebugOutputItem(CString* msg) const
{
	CString debugstr;
	CCorrObjectID tmp;
	m_groupId.ExtractOID(tmp);
	tmp.GetString(debugstr);

	if (!debugstr.GetLength())
	{
		debugstr = L"Error retrieving Group Object OID";
	}

	if (msg)
	{
		debugstr += L"\t\t:\t";
		debugstr += *msg;
	}

	debugstr += L"\n";
DebugMacro6(
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		debugstr);
)

}


//============================================================================
//  CCorrGroupIdItem::~CCorrGroupIdItem
//
//  This is the CCorrGroupIdItem class's only destructor. It frees the memory used
//	to store the CString members.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupIdItem::~CCorrGroupIdItem()
{
	while (!m_groupHandles.IsEmpty())
	{
		(m_groupHandles.RemoveHead())->Release();
	}
}


CCorrObjectID::CCorrObjectID(IN const CCorrObjectID& ID) : m_Ids(NULL)
{
	m_length = ID.m_length;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ID.m_Ids, m_length*sizeof(UINT));
	}
}


CCorrObjectID::CCorrObjectID(IN const char* str) : m_Ids(NULL)
{
	m_length = 0;

	if (NULL != str)
	{
	    size_t InputLen = strlen(str);
	    if (InputLen > MAX_OID_STRING) return; //string is too long.
	    
		char temp[MAX_OID_STRING + 1];
		strcpy(temp, str);

		BOOL bad = FALSE;
		char* temp1 = temp;
		UINT temp2[MAX_OID_LENGTH];
		CString dot(".");

		if (dot.GetAt(0) == temp[0])
		{
			temp1++;
		}

		istrstream istr(temp1);
		char d;

		istr >> temp2[0];
		m_length++;

  		if (istr.bad() || istr.fail())
		{
			bad = TRUE;
		}

		while(!istr.eof() && !bad)
		{
			istr >> d;

  			if (istr.bad() || istr.fail())
			{
				bad = TRUE;
			}

			if (d != dot.GetAt(0))
			{
				bad = TRUE;
			}

			if (m_length < MAX_OID_LENGTH)
			{
				istr >> temp2[m_length++];

				if (istr.bad() || istr.fail())
				{
					bad = TRUE;
				}

			}
			else
			{
				bad = TRUE;
			}
		}

		if (!bad)
		{
			m_Ids = new UINT[m_length];
			memcpy(m_Ids, temp2, m_length*sizeof(UINT));
		}
		else
		{
			m_length = 0;
		}
	}
}

CCorrObjectID::CCorrObjectID(IN const UINT* ids, IN const UINT len) : m_Ids(NULL)
{
	if (len <= MAX_OID_LENGTH)
	{
		m_length = len;
	}
	else
	{
		m_length = 0;
	}

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ids, m_length*sizeof(UINT));
	}
}


void CCorrObjectID::Set(IN const UINT* ids, IN const UINT len)
{
	if (m_length)
	{
		delete [] m_Ids;
	}

	if (len <= MAX_OID_LENGTH)
	{
		m_length = len;
	}
	else
	{
		m_length = 0;
	}

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}
}

char* CCorrObjectID::GetString() const
{
	char * ret = NULL;

	if (m_length)
	{
		ret = new char[BYTES_PER_FIELD*m_length];
		ostrstream s(ret, BYTES_PER_FIELD*m_length);
		s << m_Ids[0];
		UINT i = 1;
		char dot = '.';

		while (i < m_length)
		{
			s << dot << m_Ids[i++];
		}

		s << ends;
	}

	return ret;
}

#define AVERAGE_OID_LENGTH 20
wchar_t* CCorrObjectID::GetWideString() const
{
    wchar_t *returnValue = NULL ;

    ULONG totalLength = 0 ;
    ULONG reallocLength = AVERAGE_OID_LENGTH ;
    wchar_t *reallocArray = new wchar_t [ reallocLength ] ;
    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

	wmilib::auto_ptr<WCHAR> t_ReallocWrap ( reallocArray );
    
    ULONG objectIdentifierLength = m_length ;     
    ULONG index = 0 ;
    while ( index < objectIdentifierLength ) 
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( m_Ids [ index ] , stringValue , 10 );
        ULONG stringLength = wcslen ( stringValue ) ;

        if ( ( totalLength + stringLength + 1 ) >= reallocLength )
        {
            ULONG t_Max = max( stringLength + 1 , AVERAGE_OID_LENGTH ) ;
            reallocLength = reallocLength + t_Max ;
            wchar_t *t_newReallocArray = new wchar_t [ reallocLength ] ;
	    CopyMemory ( t_newReallocArray , t_ReallocWrap.get () , totalLength * sizeof ( wchar_t ) ) ;
		t_ReallocWrap.reset ( t_newReallocArray ) ;
        }

        wcscpy ( & ( t_ReallocWrap.get () [ totalLength ] ) , stringValue ) ;
        totalLength = totalLength + stringLength ;

        index ++ ;
        if ( index < objectIdentifierLength )
        {
            if ( ( totalLength + 1 + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
		wchar_t *t_newReallocArray = new wchar_t [ reallocLength ] ;
	    	CopyMemory ( t_newReallocArray , t_ReallocWrap.get () , totalLength * sizeof ( wchar_t ) ) ;
		t_ReallocWrap.reset ( t_newReallocArray ) ;
            }

            wcscpy ( & ( t_ReallocWrap.get ()[ totalLength ] ) , L"." ) ;
            totalLength ++ ;
        }
    }

    returnValue = new wchar_t [ totalLength + 1 ] ;
    if ( objectIdentifierLength )
    {
        wcscpy ( returnValue , t_ReallocWrap.get () ) ;
    }
    else
    {
        returnValue [ 0 ] = 0 ;
    }

    return returnValue ;
}

void CCorrObjectID::GetString(CString& str) const
{
	wchar_t* oid = GetWideString();

	try
	{
		str = oid;
	}
	catch(...)
	{
		delete [] oid;
		throw;
	}

	delete [] oid;
}

ECorrCompResult CCorrObjectID::CompareWith(IN const CCorrObjectID& second) const
{
	if (0 == m_length)
	{
		if (0 == second.m_length)
		{
			return ECorrAreEqual;
		}
		else
		{
			return ECorrFirstLess;
		}
	}

	if (0 == second.m_length)
	{
		return ECorrFirstGreater;
	}

	ECorrCompResult res = ECorrAreEqual;

	if (m_length <= second.m_length)
	{
		for (UINT i = 0; i < m_length; i++)
		{
			if (m_Ids[i] != second.m_Ids[i])
			{
				if (m_Ids[i] < second.m_Ids[i])
				{
					return ECorrFirstLess;
				}
				else
				{
					return ECorrFirstGreater;
				}
			}
		}

		if (m_length < second.m_length)
		{
			res = ECorrFirstLess;
		}
	}
	else
	{
		for (UINT i = 0; i < second.m_length; i++)
		{
			if (m_Ids[i] != second.m_Ids[i])
			{
				if (m_Ids[i] < second.m_Ids[i])
				{
					return ECorrFirstLess;
				}
				else
				{
					return ECorrFirstGreater;
				}
			}
		}

		res = ECorrFirstGreater;
	}

	return res;
}


BOOL CCorrObjectID::IsSubRange(IN const CCorrObjectID& child) const
{
	if (m_length >= child.m_length)
	{
		return FALSE;
	}

	for (UINT i=0; i<m_length; i++)
	{
		if (m_Ids[i] != child.m_Ids[i])
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL CCorrObjectID::operator ==(IN const CCorrObjectID& second) const
{
	if (ECorrAreEqual == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator !=(IN const CCorrObjectID& second) const
{
	if (ECorrAreEqual == CompareWith(second))
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

BOOL CCorrObjectID::operator <(IN const CCorrObjectID& second) const
{
	if (ECorrFirstLess == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator >(IN const CCorrObjectID& second) const
{
	if (ECorrFirstGreater == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator <=(IN const CCorrObjectID& second) const
{
	ECorrCompResult res = CompareWith(second);

	if ((ECorrAreEqual == res) || (ECorrFirstLess == res))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


BOOL CCorrObjectID::operator >=(IN const CCorrObjectID& second) const
{
	ECorrCompResult res = CompareWith(second);

	if ((ECorrAreEqual == res) || (ECorrFirstGreater == res))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CCorrObjectID& CCorrObjectID::operator =(IN const CCorrObjectID& ID)
{
	if (m_length)
	{
		delete [] m_Ids;
	}

	m_length = ID.m_length;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ID.m_Ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator +=(IN const CCorrObjectID& ID)
{
	if((m_length + ID.m_length) > MAX_OID_LENGTH)
	{
		if(m_length)
		{
			delete [] m_Ids;
			m_Ids = NULL;
		}

		m_length = 0;
	}
	else
	{
		if (ID.m_length)
		{
			UINT* newIds = new UINT[m_length + ID.m_length];

			if(m_length)
			{
				memcpy(newIds, m_Ids, m_length*sizeof(UINT));
				delete [] m_Ids;
				m_Ids = NULL;
			}

			memcpy(&(newIds[m_length]), ID.m_Ids, ID.m_length*sizeof(UINT));
			m_Ids = newIds;
			m_length += ID.m_length;
		}
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator ++()
{
	if (m_length)
	{
		m_Ids[m_length - 1]++;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator --()
{
	if (m_length)
	{
		m_Ids[m_length - 1]--;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator -=(IN const UINT sub)
{
	if (sub && (m_length > sub))
	{
		m_length -= sub;
		UINT* newIds = new UINT[m_length];
		memcpy(newIds, m_Ids, m_length*sizeof(UINT));
		delete [] m_Ids;
		m_Ids = newIds;
	}
	else if (sub == m_length)
	{
		m_length = 0;
		delete [] m_Ids;
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator /=(IN const UINT sub)
{
	if (sub && (m_length > sub))
	{
		m_length -= sub;
		UINT* newIds = new UINT[m_length];
		memcpy(newIds, &(m_Ids[sub]), m_length*sizeof(UINT));
		delete [] m_Ids;
		m_Ids = newIds;
	}
	else if (sub == m_length)
	{
		m_length = 0;
		delete [] m_Ids;
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID::~CCorrObjectID()
{
	if (m_length)
	{
		delete [] m_Ids;
	}
}




//============================================================================
//  CCorrRangeTableItem::CCorrRangeTableItem
//
//  This is the CCorrRangeTableItem class's only constructor. This class is derived from
//	the CObject class. This is so the MFC template storage classes can be
//	used. It is used to store a CString value in a list.
//
//
//  Parameters:
//
//      CString * str  	A pointer to the CString object to be stored.
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeTableItem::CCorrRangeTableItem(IN const CCorrObjectID& startID,
										 IN const CCorrObjectID& endID,
										 IN CCorrGroupIdItem*	grpID)
{
	m_groupId = grpID;
	CCorrObjectID temp;
	m_groupId->GetGroupID(temp);
	CCorrObjectID startRange = startID;
	startRange /= temp.GetLength();
	CCorrObjectID endRange = endID;
	endRange /= (temp.GetLength() - 1);
	m_startRange.Set(startRange);
	m_endRange.Set(endRange);
}


//============================================================================
//  CCorrRangeTableItem::~CCorrRangeTableItem
//
//  This is the CCorrRangeTableItem class's only destructor. It frees the memory used
//	to store the CString members.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeTableItem::~CCorrRangeTableItem()
{

}


BOOL CCorrRangeTableItem::GetStartRange(OUT CCorrObjectID& start) const
{
	if (!m_groupId)
		return FALSE;

	m_groupId->GetGroupID(start);
	CCorrObjectID tmp;
	m_startRange.ExtractOID(tmp);
	start += tmp;
	return TRUE;
}


BOOL CCorrRangeTableItem::GetEndRange(OUT CCorrObjectID& end) const
{
	if (!m_groupId)
		return FALSE;

	m_groupId->GetGroupID(end);
	end -= 1;
	CCorrObjectID tmp;
	m_endRange.ExtractOID(tmp);
	end += tmp;
	return TRUE;
}

CCorrRangeTableItem::ECorrRangeResult CCorrRangeTableItem::
									IsInRange(IN const CCorrObjectID& ID) const
{
	CCorrObjectID a;

	GetStartRange(a);

	if (ID == a)
	{
		return ECorrEqualToStart;
	}

	if (ID < a)
	{
		return ECorrBeforeStart;
	}

	CCorrObjectID b;
	GetEndRange(b);

	if (ID == b)
	{
		return ECorrEqualToEnd;
	}

	if (ID > b)
	{
		return ECorrAfterEnd;
	}

	return ECorrInRange;
}


void CCorrRangeTableItem::DebugOutputRange() const
{
DebugMacro6(
	if (m_groupId)
	{
		CString debugstr;
		CCorrObjectID tmp;
		m_groupId->GetGroupID(tmp);
		tmp.GetString(debugstr);
		CString out1;
		CCorrObjectID start;
		GetStartRange(start);
		start.GetString(out1);
		CString out2;
		CCorrObjectID end;
		GetEndRange(end);
		end.GetString(out2);
		debugstr += "\t\t:\t\t";
		debugstr += out1;
		debugstr += "\t\t:\t\t";
		debugstr += out2;
		debugstr += "\t\tGroup : Start : End\n";
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			debugstr);
	}
	else
	{
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			L"Attempt to output empty RangeTableItem\n");
	}
)
}


//============================================================================
//  CCorrRangeList::~CCorrRangeList
//
//  This is the CCorrRangeList class's only desstructor. If there are any items in
//	the queue they are deleted.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeList::~CCorrRangeList()
{
	while(!IsEmpty())
	{
		CCorrRangeTableItem * item = RemoveHead();
		delete item;
	}
}


//============================================================================
//  CCorrRangeList::Add
//
//  This public method is called to add a CCorrRangeTableItem into this CCorrRangeList. The
//	CCorrRangeTableItem is not added if it is already present in the list. If this is the
//	case a pointer to the matching item in the list is returned.
//
//
//  Parameters:
//
//		CCorrRangeTableItem * newItem	A pointer to the CCorrRangeTableItem to be added.
//
//  Returns:
//
//      CCorrRangeTableItem *			A pointer to the item if is in the list. NULL if
//							the item was not found and was added.
//
//============================================================================

BOOL CCorrRangeList::Add(IN CCorrRangeTableItem* newItem)
{
	AddTail(newItem); //empty or all items smaller
	return TRUE;
}


BOOL CCorrRangeList::GetLastEndOID(OUT CCorrObjectID& end) const
{
	if (IsEmpty())
	{
		return FALSE;
	}

	return (GetTail()->GetEndRange(end));
}


CCorrGroupMask::CCorrGroupMask(IN const TCorrMaskLength sze) : m_mask(NULL)
{
	m_size = sze;

	if (m_size)
	{
		TCorrMaskLength x = m_size / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);

		if (m_size % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE))
		{
			x++;
		}

		m_mask = new TCorrMaskUnit[x];
		ZeroMemory((PVOID)m_mask, (DWORD)(sizeof(TCorrMaskUnit)*x));
	}
}

BOOL CCorrGroupMask::IsBitSet(IN const TCorrMaskLength bit)const
{
	TCorrMaskLength x = bit / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
	TCorrMaskLength val = bit % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);

	return (((m_mask[x] >> val) & 1) == 1);
}

void CCorrGroupMask::SetBit(IN const TCorrMaskLength bit, IN const BOOL On)
{
	BOOL IsBit = IsBitSet(bit);

	if ((IsBit && On) || (!IsBit && !On))
	{
		return;
	}
	else
	{
		TCorrMaskLength x = bit / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
		TCorrMaskLength val = bit % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
		TCorrMaskLength maskval = 1;
		maskval <<= val;

		if (On)
		{
			m_mask[x] += maskval;
		}
		else
		{
			m_mask[x] -= maskval;
		}
	}
}

CCorrGroupMask::~CCorrGroupMask()
{
	if (m_mask)
	{
		delete [] m_mask;
	}
}

CCorrCache::CCorrCache( ISmirInterrogator *a_ISmirInterrogator ) : m_Groups (NULL)
{
	m_ValidCache = TRUE;
	m_Ref_Count = 0;
	m_size = 0;
	BuildCacheAndSetNotify( a_ISmirInterrogator );

	if (m_groupTable.GetSize())
	{
		m_Groups = new CCorrGroupMask(m_size);
		BuildRangeTable();
	}
}

CCorrCache::~CCorrCache()
{
	if (m_Groups)
	{
		delete m_Groups;
	}
}

void CCorrCache::InvalidateCache()
{
	m_Lock.Lock();

	if (!m_Ref_Count)
	{
		delete this;
	}
	else
	{
		m_ValidCache = FALSE;
		m_Lock.Unlock();
	}
}

BOOL CCorrCache::BuildCacheAndSetNotify( ISmirInterrogator *a_ISmirInterrogator )
{
	LPUNKNOWN pInterrogativeInt = NULL;

//	===============================================================
//	The following relies on the current thread having been
//	initialised for OLE (i.e. by the use of CoInitialize)
//	===============================================================

	HRESULT hr = S_OK ;

	if ( a_ISmirInterrogator )
	{
		hr = a_ISmirInterrogator->QueryInterface (

			IID_ISMIR_Interrogative, (void**)&pInterrogativeInt
		);
	}
	else
	{
		hr = CoCreateInstance (CLSID_SMIR_Database,
						NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						IID_ISMIR_Interrogative, (void**)&pInterrogativeInt);
	}

	if (NULL == pInterrogativeInt)
	{
		return FALSE;
	}

	IEnumGroup  *pTEnumSmirGroup = NULL;

	//enum all groups
	hr = ((ISmirInterrogator*)pInterrogativeInt)->EnumGroups(&pTEnumSmirGroup, NULL);

	//now use the enumerator
	if(NULL == pTEnumSmirGroup)
	{
		pInterrogativeInt->Release();
		return FALSE;
	}

	ISmirGroupHandle *phModule=NULL;

DebugMacro6(
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			L"CCorrCache::BuildCacheAndSetNotify - Accessing SMIR Getting Groups\n");
)


	for(int iCount=0; S_OK == pTEnumSmirGroup->Next(1, &phModule, NULL); iCount++)
	{
		//DO SOMETHING WITH THE GROUP HANDLE

		//eg get the name
		BSTR szName=NULL;
		char buff[1024];
		LPSTR pbuff = buff;
		int lbuff = sizeof(buff);
		phModule->GetGroupOID(&szName);

		if (FALSE == WideCharToMultiByte(CP_ACP, 0,
						szName, -1, pbuff, lbuff, NULL, NULL))
		{
			DWORD lasterr = GetLastError();
			SysFreeString(szName);
			phModule->Release();
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"CCorrCache::BuildCacheAndSetNotify - Error bad BSTR conversion\n");
)
			continue;
		}

		SysFreeString(szName);
		CCorrObjectID grpId(buff);
		CCorrObjectID zero;

		if (zero != grpId)
		{
			CCorrGroupIdItem* groupId = new CCorrGroupIdItem(grpId, phModule);
			m_groupTable.Add(groupId);
			m_size++;
		}

DebugMacro6(
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			L"%s\n", buff);
)
	}

DebugMacro6(
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		L"CCorrCache::BuildCacheAndSetNotify - Finished accessing SMIR Getting Groups\n");
)
	pTEnumSmirGroup->Release();

	if (NULL == g_pNotifyInt)
	{
		hr = pInterrogativeInt->QueryInterface(IID_ISMIR_Database,
			(void **) &g_pNotifyInt);

		if(SUCCEEDED(hr))
		{
			if( gp_notify== NULL)
			{
				DWORD dw;
				gp_notify = new CCorrCacheNotify();
				gp_notify->AddRef();
				hr = g_pNotifyInt->AddNotify(gp_notify, &dw);

				if(SUCCEEDED(hr))
				{
					gp_notify->SetCookie(dw);
				}
			}
		}
	}
	else
	{
		if( gp_notify== NULL)
		{
			DWORD dw;
			gp_notify = new CCorrCacheNotify();
			gp_notify->AddRef();
			hr = g_pNotifyInt->AddNotify(gp_notify, &dw);

			if(SUCCEEDED(hr))
			{
				gp_notify->SetCookie(dw);
			}
		}
	}

	pInterrogativeInt->Release();

	if ((NULL == gp_notify) || (0 == gp_notify->GetCookie()))
	{
		return FALSE;
	}

	return TRUE;
}

#pragma warning (disable:4018)

BOOL CCorrCache::BuildRangeTable()
{
	UINT pos = 0;
	TCorrMaskLength posIndex = 0;
	TCorrMaskLength nextIndex = 1;
	m_groupTable.Sort();

DebugMacro6(
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		L"CCorrCache::BuildRangeTable - Printing sorted group table...\n");

	for (int x = 0; x < m_groupTable.GetSize(); x++)
	{
		CCorrGroupIdItem * i = m_groupTable.GetAt(x);
		i->DebugOutputItem();
	}

	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		L"CCorrCache::BuildRangeTable - Finished printing sorted group table...\n");
)

	while (pos < m_groupTable.GetSize())
	{
		UINT nextpos = pos + 1;
		DoGroupEntry(&pos, &nextpos, &posIndex, &nextIndex);
		pos = nextpos;
		posIndex = nextIndex++;
	}

	return TRUE;
}

#pragma warning (default:4018)

#pragma warning (disable:4018)

void CCorrCache::DoGroupEntry(UINT* current, UINT* next,
							 TCorrMaskLength* cIndex, TCorrMaskLength* nIndex)
{
	CCorrGroupIdItem* alpha = m_groupTable.GetAt(*current);
	CCorrObjectID a;
	alpha->GetGroupID(a);
	CCorrObjectID End(a);
	++End;

	if (*next < m_groupTable.GetSize())
	{
		CCorrGroupIdItem* beta = m_groupTable.GetAt(*next);
		CCorrObjectID b;
		beta->GetGroupID(b);

		//check for duplicates
		while ((a == b) && (*next < m_groupTable.GetSize()))
		{
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"Deleting duplicate non MIB2 group... ");
			beta->DebugOutputItem();
)

			//add the group handles to the one not being deleted
			while (!beta->m_groupHandles.IsEmpty())
			{
				alpha->m_groupHandles.AddTail(beta->m_groupHandles.RemoveHead());
			}

			m_groupTable.RemoveAt(*next);
			delete beta;
			beta = m_groupTable.GetAt(*next);
			beta->GetGroupID(b);
		}

		//after checking for duplicates, check we still meet the initial condition
		if (*next < m_groupTable.GetSize())
		{

			//if the next item is not a child of this
			if ((a.GetLength() >= b.GetLength()) || (!a.IsSubRange(b)))
			{
				CCorrObjectID c;
				CCorrRangeTableItem* newEntry;

				if (!m_rangeTable.GetLastEndOID(c) || !a.IsSubRange(c))
				{
					//add whole of a-range to rangetable
					newEntry = new CCorrRangeTableItem(a, End, alpha);
				}
				else
				{
					//add from c to end of a-range to rangetable
					newEntry = new CCorrRangeTableItem(c, End, alpha);
				}

				newEntry->DebugOutputRange();

				m_rangeTable.Add(newEntry);
				alpha->SetIndex(*cIndex);
				m_Groups->SetBit(*cIndex);
			}
			else //the next item is a child so add a subrange and do the child - recurse!
			{
				CCorrObjectID c;
				CCorrRangeTableItem* newEntry;

				if (!m_rangeTable.GetLastEndOID(c) || !a.IsSubRange(c))
				{
					//add start of a-range to start of b to rangetable
					newEntry = new CCorrRangeTableItem(a, b, alpha);
				}
				else
				{
					//add from c to start of b to rangetable
					newEntry = new CCorrRangeTableItem(c, b, alpha);
				}

				newEntry->DebugOutputRange();

				m_rangeTable.Add(newEntry);
				UINT temp = (*next)++;
				TCorrMaskLength tempIndex = (*nIndex)++;
				DoGroupEntry(&temp, next, &tempIndex, nIndex);

				if (*next >= m_groupTable.GetSize())
				{
					m_rangeTable.GetLastEndOID(c);
					////add from c to end of a-range to rangetable
					newEntry = new CCorrRangeTableItem(c, End, alpha);
					m_rangeTable.Add(newEntry);
					alpha->SetIndex(*cIndex);
					m_Groups->SetBit(*cIndex);
					newEntry->DebugOutputRange();
				}

				//while the new next one(s) is a child add it first - recurse AGAIN!
				while(!m_Groups->IsBitSet(*cIndex))
				{
					DoGroupEntry(current, next, cIndex, nIndex);
				}
			}
		}
	}

	//if this is the last item then add it.
	if (*current == m_groupTable.GetUpperBound())
	{
		//add whole of a-range to rangetable
		CCorrRangeTableItem* newEntry = new CCorrRangeTableItem(a, End, alpha);
		m_rangeTable.Add(newEntry);
		alpha->SetIndex(*cIndex);
		m_Groups->SetBit(*cIndex);
		newEntry->DebugOutputRange();
	}
}

#pragma warning (default:4018)

void CCorrCache::AddRef()
{
	m_Lock.Lock();
	m_Ref_Count++;
	m_Lock.Unlock();
}

void CCorrCache::DecRef()
{
	m_Lock.Lock();

	if (m_Ref_Count)
		m_Ref_Count--;

	if (!m_Ref_Count && !m_ValidCache)
	{
		delete this;
		return;
	}

	m_Lock.Unlock();

}



CCorrEncodedOID::CCorrEncodedOID(IN const CCorrObjectID& src_oid) : m_ids(NULL), m_length(0), m_chopped(0)
{
	Set(src_oid);
}

void CCorrEncodedOID::Set(IN const CCorrObjectID& src_oid)
{
	m_chopped = 0;
	UINT x = 0;
	UINT oidlength = src_oid.GetLength();

	if (oidlength > MAX_OID_LENGTH)
	{
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"CCorrEncodedOID::Set: Truncating OID from %d to %d components", oidlength, MAX_OID_LENGTH);
)
		oidlength = MAX_OID_LENGTH;
	}

	if (oidlength)
	{
		UCHAR buff[MAX_OID_LENGTH*MAX_BYTES_PER_FIELD];
		const UINT* oid_ids = src_oid.GetIds();

		for (UINT i = 0; i < oidlength; i++)
		{
			UINT val = oid_ids[i];

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT28)
			{
				buff[x++] = (UCHAR) (BIT7 + ((val & HI4BITS) >> 28));
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT21)
			{
				buff[x++] = BIT7 + ((val & HIMID7BITS) >> 21);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT14)
			{
				buff[x++] = BIT7 + ((val & MID7BITS) >> 14);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT7)
			{
				buff[x++] = BIT7 + ((val & LOMID7BITS) >> 7);
			}

			//get the next seven bits and store in byte
			buff[x++] = (val & LO7BITS);
		}

		//Remove the standard 1.3.6.1 if necessary...
		if ((1 == buff[0]) && (3 == buff[1]) &&
			(6 == buff[2]) && (1 == buff[3]))
		{
			m_chopped = 1;
			m_ids = new UCHAR[x-4];
			m_length = x-4;
			memcpy(m_ids, &buff[4], m_length*sizeof(UCHAR));
		}
		else
		{
			m_ids = new UCHAR[x];
			m_length = x;
			memcpy(m_ids, buff, m_length*sizeof(UCHAR));
		}
	}
	else
	{
		m_ids = NULL;
	}
}


void CCorrEncodedOID::ExtractOID(OUT CCorrObjectID& src_oid) const
{
	if (m_length)
	{
		UINT buff[MAX_OID_LENGTH];
		UINT x = 0;

		//Add the standard 1.3.6.1 if necessary...
		if (m_chopped == 1)
		{
			buff[0] = 1;
			buff[1] = 3;
			buff[2] = 6;
			buff[3] = 1;
			x = 4;
		}

		for (UINT i = 0; (i < m_length) && (x < MAX_OID_LENGTH); i++)
		{
			//extract the value of the byte
			buff[x] = m_ids[i] & LO7BITS;

			//are there more bytes for this UINT
			while ((i < m_length) && (m_ids[i] & 128))
			{
				//shift the value by a "byte" and extract tbe next byte.
				buff[x] = buff[x] << 7;
				buff[x] += m_ids[++i] & LO7BITS;
			}

			x++;

			if ((x == MAX_OID_LENGTH) && (i < m_length))
			{
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"CCorrEncodedOID::ExtractOID: Truncating OID %d components - SHOULD NEVER HAPPEN", MAX_OID_LENGTH);
)
			}
		}

		src_oid.Set(buff, x);
	}
	else
	{
		src_oid.Set(NULL, 0);
	}

}


CCorrEncodedOID::~CCorrEncodedOID()
{
	delete [] m_ids;
}

CCorrCacheWrapper::CCorrCacheWrapper(IN CCorrCache* cachePtr) : m_lockit(NULL)
{
	m_lockit = new CCriticalSection();
	m_CachePtr = cachePtr;
}

CCorrCache* CCorrCacheWrapper::GetCache()
{
	m_lockit->Lock();
	return m_CachePtr;
}

CCorrCacheWrapper::~CCorrCacheWrapper()
{
	delete m_lockit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\classfac.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPProvClassFactory_H
#define _SNMPProvClassFactory_H

class CClasProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CClasProvClassFactory () ;
    ~CClasProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CPropProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CPropProvClassFactory () ;
    ~CPropProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CSNMPEventProviderClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CSNMPEventProviderClassFactory () ;
    ~CSNMPEventProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP LockServer ( BOOL ) ;
};

class CSNMPEncapEventProviderClassFactory : public CSNMPEventProviderClassFactory
{
public:

	//IClassFactory member
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

class CSNMPRefEventProviderClassFactory : public CSNMPEventProviderClassFactory
{
public:

	//IClassFactory member
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

#endif // _SNMPProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\clasprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: Sample Mini Server for Ole MS 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPClassProvider_H_
#define _SNMPClassProvider_H_

extern CRITICAL_SECTION s_ProviderCriticalSection ;

class SnmpClassDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClassDefaultThreadObject ( const char *threadName = NULL ) : SnmpThreadObject ( threadName ) {} ;
	~SnmpClassDefaultThreadObject () {} ;

	void Initialise () ;
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpClasProv : public IWbemServices , public IWbemProviderInit
{
private:

	LONG m_referenceCount ;         //Object reference count

private:

	BOOL initialised ;
	IWbemServices *propertyProvider ;
	IWbemServices *server ;
	IWbemServices *parentServer ;
	IWbemProviderInitSink *m_InitSink ;
	char *ipAddressString ;
	char *ipAddressValue ;

	wchar_t *thisNamespace ;
	WbemNamespacePath namespacePath ;

	CCriticalSection m_notificationLock;
	CCriticalSection m_snmpNotificationLock;
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_snmpNotificationClassObject ;
	BOOL m_getNotifyCalled ;
	BOOL m_getSnmpNotifyCalled ;
 
private:

	HRESULT SetServer ( IWbemServices *serverArg ) ;
	HRESULT SetParentServer ( IWbemServices *parentServerArg ) ;

	BOOL AttachParentServer ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR ObjectPath,
		IWbemContext *pCtx
	) ;

	BOOL ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject ) ;

protected:

public:

	CImpClasProv () ;
    ~CImpClasProv () ;

	void SetProvider ( IWbemServices *provider ) ;
	IWbemServices *GetParentServer () ;
	IWbemServices *GetServer () ;
	WbemNamespacePath *GetNamespacePath () ;
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	char *GetIpAddressString () { return ipAddressString ; }
	char *GetIpAddressValue () { return ipAddressValue ; }

	BOOL FetchSnmpNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL FetchNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	static BOOL s_Initialised ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

public:

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
		);
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\corafx.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORAFX
#define _SNMPCORR_CORAFX 




// corafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <snmpstd.h>
#include <snmpcoll.h>
#include <snmptempl.h>
#include <fstream.h>		// File Streams
#include <snmpmt.h>			// MFC Critical Sections

//#include <afx.h>
#include <strstrea.h>
#endif //_SNMPCORR_CORAFX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\cordefs.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORDEFS
#define _SNMPCORR_CORDEFS

#define BITS_PER_BYTE		8
#define BYTES_PER_FIELD		18
#define FIELD_SEPARATOR		'.'
#define EOS					'\0'
#define CORRELATOR_KEY		L"Software\\Microsoft\\WBEM\\Providers\\SNMP\\Correlator"
#define CORRELATOR_VALUE	L"MaxVarBinds"
#define VARBIND_COUNT		6
#define MIB2				"RFC1213-MIB"
#define MAX_MODULE_LENGTH	1024
#define MAX_OID_STRING		2310 //xxx. to a max of 128 components 18*128 plus a little extra
#define MAX_OID_LENGTH		128
#define MAX_BYTES_PER_FIELD 5
#define BIT28				268435456	// 1 << 28
#define BIT21				2097152		// 1 << 21
#define BIT14				16384		// 1 << 14
#define BIT7				128			// 1 << 7
#define HI4BITS				4026531840	// 15 << 28
#define HIMID7BITS			266338304	// 127 << 21
#define MID7BITS			2080768		// 127 << 14
#define LOMID7BITS			16256		// 127 << 7
#define LO7BITS				127


#endif //_SNMPCORR_CORDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\cormap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORMAP
#define _SNMPCORR_CORMAP


class CCorrelatorMap : public CMap< DWORD_PTR, DWORD_PTR, CCorrelator*, CCorrelator* >
{
private:

	CCriticalSection	m_MapLock;
	UINT HashKey(DWORD_PTR key) { return (UINT)key; }


public:

	void Register(CCorrelator *key);
	void UnRegister(CCorrelator *key);
	~CCorrelatorMap();


};


#endif //_SNMPCORR_CORSTORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtdefs.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTDEFS_H
#define _SNMP_EVT_PROV_EVTDEFS_H

//common strings
#define WBEMS_CLASS_PROP		L"__CLASS"
#define EVENT_ADDR_PROP		L"AgentAddress"
#define EVENT_TADDR_PROP	L"AgentTransportAddress"
#define EVENT_TRANS_PROP	L"AgentTransportProtocol"
#define EVENT_TIME_PROP		L"TimeStamp"
#define EVENT_SOID_PROP		L"Identification"
#define EVENT_COMM_PROP		L"Community"
#define EVENT_VBL_PROP		L"VarBindList"
#define EVENT_VBINDEX_QUAL	L"VarBindIndex"
#define ASN_OPAQUE			(CString(L"OPAQUE"))
#define ASN_NULL			(CString(L"NULL VALUE"))
#define ASN_INTEGER			(CString(L"INTEGER"))
#define ASN_TIME			(CString(L"TimeTicks"))
#define ASN_GUAGE			(CString(L"Guage"))
#define ASN_COUNTER			(CString(L"Counter"))
#define ASN_OID				(CString(L"OBJECT IDENTIFIER"))
#define ASN_ADDR			(CString(L"IpAddress"))
#define ASN_OCTET			(CString(L"OCTET STRING"))
#define ASN_UINT32			(CString(L"Unsigned32"))
#define ASN_COUNTER64		(CString(L"Counter64"))
#define ASN_NSI				(CString(L"noSuchInstance"))
#define ASN_EOMV			(CString(L"endOfMibView"))
#define ASN_NSO				(CString(L"noSuchObject"))
#define SNMP_ENT_OID		(SnmpObjectIdentifier("1.3.6.1.6.3.1.1.4.3.0"))
#define SNMP_TRAP_OID		(SnmpObjectIdentifier("1.3.6.1.6.3.1.1.4.1.0"))
#define SNMP_SYS_UP_OID		(SnmpObjectIdentifier("1.3.6.1.2.1.1.3.0"))
#define VB_ENCODING_PROP1	L"Encoding"
#define VB_OBJID_PROP2		L"ObjectIdentifier"
#define VB_VALUE_PROP3		L"Value"
#define VB_CLASS_PATH		L"SnmpVarBind"

#define MAPPER_CLASS_EVENTCLASSPROP	L"EventClassName"

#define THREAD_REG_KEY		L"Software\\Microsoft\\WBEM\\Providers\\SNMP\\Events"
#define THREAD_MARKS_VAL	L"StrobeCount"
#define THREAD_MARKS_MAX	60
#define THREAD_MARKS_DEF	1
#define THREAD_INTERVAL		1000*60 //a minute
#define THREAD_NAME			"SnmpEvtProv_Timer"

//Encapsulated strings
#define MAPPER_CLASS_PATH_PREFIX	L"NotificationMapper.SnmpTrapOID=\""
#define V2CLASS_NAME				L"SnmpV2Notification"
#define V1CLASS_NAME				L"SnmpV1Notification"

//Referent strings
#define EXTMAPPER_CLASS_PATH_PREFIX	L"ExtendedNotificationMapper.SnmpTrapOID=\""
#define V2EXTCLASS_NAME				L"SnmpV2ExtendedNotification"
#define V1EXTCLASS_NAME				L"SnmpV1ExtendedNotification"
#define EVENT_CIMTYPE_QUAL			L"CIMTYPE"
#define OBJECT_STR					L"object:"
#define OBJECT_STR_LEN				7
#define WHITE_SPACE_CHARS			L" \t\r\n"
#define FIXED_LENGTH_ATTRIBUTE		L"fixed_length"
#define KEY_ATTRIBUTE				L"key"
#define KEY_ORDER_ATTRIBUTE			L"key_order"
#define TEXT_CNVN_ATTRIBUTE			L"textual_convention"
#define OID_ATTRIBUTE				L"object_identifier"
#define TEXT_CNVN_INTEGER_VAL		L"INTEGER"
#define TEXT_CNVN_IP_ADDR_VAL		L"IpAddress"
#define TEXT_CNVN_OID_VAL			L"OBJECTIDENTIFIER"
#define TEXT_CNVN_OCTSTR_VAL		L"OCTETSTRING"

#endif //_SNMP_EVT_PROV_EVTDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtencap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTENCAP_H
#define _SNMP_EVT_PROV_EVTENCAP_H

class CEncapMapper : public CMapToEvent
{
private:

	BOOL GetSpecificClass();
	const wchar_t*	GetV1Class() { return V1CLASS_NAME; }
	const wchar_t*	GetV2Class() { return V2CLASS_NAME; }
	WbemSnmpClassObject* m_WbemSnmpObj;
	BOOL SetAndGetProperty(WbemSnmpProperty *hmmSnmpProp, VARIANT *pvValue);

public:

	CEncapMapper();

	HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);
	
	void GenerateInstance(IWbemClassObject** ppInst);
	void ResetData();

	~CEncapMapper();

};


#endif //_SNMP_EVT_PROV_EVTENCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\corrsnmp.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORRSNMP
#define _SNMPCORR_CORRSNMP 

#include "snmpcl.h"

class CCorrResult
{
public:

	SnmpObjectIdentifier m_In;
	CCorrObjectID m_Out;
	SnmpErrorReport m_report;

	CCorrResult();
	~CCorrResult();
	void	DebugOutputSNMPResult() const;

};


class  CCorrNextId : public SnmpGetNextOperation
{
private:
	
	void ReceiveResponse();
	
	char *GetString(IN const SnmpObjectIdentifier &id);

	// the following two methods from SnmpGetNextOperation are 
	// over-ridden.

	void ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error);

	void ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error);

protected:

	CCorrResult	*m_Results;
	UINT		m_ResultsCnt;
	UINT		m_NextResult;

	// this is a callback through which the CCorrNextId class returns the next_id
	// the callee must make a copy of the "next_id"
	// the Correlator_Info may take a value Local_Error
	virtual void ReceiveNextId(OUT const SnmpErrorReport &error,
			    			   OUT const CCorrObjectID &next_id) = 0;

	BOOL GetNextResult();

public:

	// constructor - creates an operation and passes the snmp_session to it
	CCorrNextId(IN SnmpSession &snmp_session);

	// frees the m_object_id_string if required
	~CCorrNextId();

	// in case of an error encountered while the method executes, 
	// ReceiveNextId(LocalError, NULL) will be called synchronously
	// otherwise, an asynchronous call to ReceiveNextId provides the next_id	
	void GetNextId(IN const CCorrObjectID const *object_ids, IN UINT len);

	void *operator()(void) const
	{
		return SnmpGetNextOperation::operator()();
	}
};



#endif // _SNMPCORR_CORRSNMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\creclass.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

class SnmpClassEventObject ;
class SnmpCorrelation : public CCorrelator
{
private:
protected:

	SnmpSession *m_session ;
	SnmpClassEventObject *m_eventObject ;

public:

#ifdef CORRELATOR_INIT
	SnmpCorrelation ( SnmpSession &session , SnmpClassEventObject *eventObject ) ;
#else //CORRELATOR_INIT
	SnmpCorrelation ( SnmpSession &session , SnmpClassEventObject *eventObject , ISmirInterrogator *a_ISmirInterrogator ) ;
#endif //CORRELATOR_INIT
	~SnmpCorrelation () ;

	void Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phModule , IN const char* objectId = NULL ) ;
	void Finished ( IN const BOOL Complete ) ;
} ;

class SnmpClassEventObject : public SnmpTaskObject
{
private:
protected:

	BOOL m_inCallstack ;
	BOOL m_correlate ;
	BOOL m_synchronousComplete ;
	ULONG m_GroupsReceived ;
	WbemSnmpErrorObject m_errorObject ;
	CImpClasProv *m_provider ;
	IWbemClassObject *m_namespaceObject ;
	SnmpCorrelation *m_correlator ;
	IWbemContext *m_Context ;
	ISmirInterrogator *m_Interrogator ;

	BOOL GetAgentTransport ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentTransport ) ;
	BOOL GetAgentVersion ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentVersion ) ;
	BOOL GetAgentAddress ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentAddress ) ;
	BOOL GetAgentReadCommunityName ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentRetryCount ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryCount ) ;
	BOOL GetAgentRetryTimeout( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryTimeout ) ;
	BOOL GetAgentMaxVarBindsPerPdu ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentVarBindsPerPdu ) ;
	BOOL GetAgentFlowControlWindowSize ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentFlowControlWindowSize ) ;
	BOOL GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetTransportInformation ( WbemSnmpErrorObject &a_errorObject , SnmpSession *&session ) ;

	BOOL GetClass ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject **classObject , BSTR a_Class ) ;
	virtual BOOL GetNotifyStatusObject ( IWbemClassObject **notifyObject ) ;
	virtual BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

public:

	SnmpClassEventObject ( CImpClasProv *provider , IWbemContext *a_Context ) ;
	~SnmpClassEventObject () ;

	WbemSnmpErrorObject &GetErrorObject () { return m_errorObject ; }

	virtual void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) = 0 ;
	virtual void ReceiveClass ( IN IWbemClassObject *classObject ) = 0 ;
	virtual void ReceiveError ( IN const SnmpErrorReport &errorReport ) = 0 ;
	virtual void ReceiveComplete () = 0 ;

} ;

class SnmpClassGetEventObject : public SnmpClassEventObject
{
private:
protected:

	BOOL m_Received ;
	wchar_t *m_Class ;
	IWbemClassObject *m_classObject ;

	BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

public:

	SnmpClassGetEventObject ( CImpClasProv *provider , BSTR Class , IWbemContext *a_Context ) ;
	~SnmpClassGetEventObject () ;

	void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) ;

	BOOL ProcessClass ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL ProcessCorrelatedClass ( WbemSnmpErrorObject &a_errorObject ) ;

	IWbemClassObject *GetClassObject () { m_classObject->AddRef () ; return m_classObject ; }

} ;

class SnmpClassGetAsyncEventObject : public SnmpClassGetEventObject
{
private:

	IWbemObjectSink *m_notificationHandler ;

protected:
public:

	SnmpClassGetAsyncEventObject ( CImpClasProv *provider , BSTR Class , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpClassGetAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void ReceiveClass ( IWbemClassObject *classObject ) ;
	void ReceiveError ( IN const SnmpErrorReport &errorReport ) ;
} ;

class SnmpClassEnumEventObject : public SnmpClassEventObject 
{
private:
protected:

	wchar_t *m_Parent ;
	ULONG m_Flags ;

	BOOL ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class ) ;
	BOOL GetEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpClassEnumEventObject ( CImpClasProv *provider , wchar_t *Parent , ULONG flags , IWbemContext *a_Context ) ;
	~SnmpClassEnumEventObject () ;

	void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) ;

	BOOL ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpClassEnumAsyncEventObject : public SnmpClassEnumEventObject
{
private:

	IWbemObjectSink *m_notificationHandler ;

protected:
public:

	SnmpClassEnumAsyncEventObject ( CImpClasProv *provider , wchar_t *Parent , ULONG flags , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpClassEnumAsyncEventObject () ;

	void Process () ;
	void ReceiveClass ( IWbemClassObject *classObject ) ;
	void ReceiveError ( IN const SnmpErrorReport &errorReport ) ;
	void ReceiveComplete () ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\correlat.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORELAT
#define _SNMPCORR_CORELAT 

#include <corafx.h>
#include <cordefs.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>



//=================================================================================
//
//	class CCorrelator_Info
//
//	This class is used to return information about the correlation. An instance
//	of this class is passed as a parameter in the CCorrelator::Correlated call
//	back method. This class is derived from SnmpErrorReport. If there is an SNMP
//	error during correlation then this class will indicate an SNMP error and the
//	SnmpErrorReport methods can be used to determine what the error was. If there
//	is not an SNMP error the SnmpErrorReport methods will indicate success. However
//	there may still be a correlation error, so GetInfo should be called first to
//	see the nature of the correlation result.
//
//=================================================================================

class CCorrelator_Info : public 	SnmpErrorReport
{
public:


//	The following enumeration gives the error codes that the correlation
//	process can return. This is public so that we can see what's returned!
//	======================================================================

enum ECorrelationInfo
{	
	ECorrSuccess = 0,	//No errors occurred
	ECorrSnmpError,		//An SNMP session error, read the SnmpErrorReport
	ECorrInvalidGroup,	//An Invalid group has been found
	ECorrEmptySMIR,		//The SMIR contains no groups
	ECorrBadSession,	//The SNMP Session passed is invalid
	ECorrNoSuchGroup,	//The group passed is not in the SMIR (one shot correlation)
	ECorrGetNextError,	//Unexpected value returned from the SNMP operation
	ECorrSomeError		//Never used - place holder for further error codes.
};


private:
	
	
	//	Private Members
	//	===============

	ECorrelationInfo m_info; //Correlation error indication


public:
	

	//	Public Constructor
	//	==================

	CCorrelator_Info(IN const ECorrelationInfo& i, IN const SnmpErrorReport& snmpi) 
		: SnmpErrorReport(snmpi) { m_info = i;	}

	
	//	Public Methods
	//	==============

	//	Returns the error code for this object
	ECorrelationInfo	GetInfo() const { return m_info; }

	//	Sets the error code for this object 
	void				SetInfo(IN const ECorrelationInfo& info) { m_info = info; }

};

//=================================================================================
//
//	class CCorrelator
//
//	This class is used to correlate an agent on the network. It is derived from an
//	SnmpOperation class. It's constructor takes one parameter, an SnmpSession. This
//	parameter is used to create the SnmpOperation parent class and the correlation
//	will be performed in the context of this session. To perform correlation derive
//	from this class and override the Correlated method. The Correlated method will
//	be called asynchronously when a group has been found to be supported by the
//	agent. To start the correlation procedure off after creating a CCorrelator
//	object you have to call the Start method. This takes an optional parameter, if
//	the parameter is specified then a single shot correlation is performed for the
//	object id passed as the parameter (as a string). If the parameter is not used
//	then all the groups supported by the agent that exist in the SMIR will be
//	returned.
//
//=================================================================================

class CCorrelator : public CCorrNextId
{
private:


	//	Private Members
	//	===============

	BOOL					m_inProg;		//Is correlation in progress
	CCorrCache*				m_pCache;		//Pointer to the global cache
	POSITION				m_rangePos;		//The current position in the range list
	CCorrRangeTableItem*	m_pItem;		//Pointer to the current range list item
	CCorrGroupMask*			m_Groups;		//A mask used to indicate groups found
	BOOL					m_NoEntries;	//Is the SMIR empty
	CCorrObjectID*			m_group_OID;	//Single correlation group id
	UINT					m_VarBindCnt;	//Max number of VarBinds per GetNext op

	//	Private Methods
	//	===============

	void		Initialise();
	void		Reset();
	BOOL		ProcessOID(IN const SnmpErrorReport& error, IN const CCorrObjectID& OID);
	void		ReceiveNextId(IN const SnmpErrorReport &error,
								IN const CCorrObjectID &next_id);
	void		ReadRegistry();
	void		GetNextOIDs();
	BOOL		IsItemFromGroup() const;
	void		ScanAndSkipResults();

protected:

	//	Protected Constructor
	//	=====================

#ifdef CORRELATOR_INIT
	CCorrelator(IN SnmpSession &session);
#else //CORRELATOR_INIT
	CCorrelator(IN SnmpSession &session, IN ISmirInterrogator *a_ISmirInterrogator);
#endif //CORRELATOR_INIT


	//	Protected Methods
	//	=================

	//Call backs
	virtual void	Correlated(IN const CCorrelator_Info &info, IN ISmirGroupHandle *phModule,
								IN const char* objectId = NULL) = 0;
	virtual void	Finished(IN const BOOL Complete) = 0;


public:


	//	Public Methods
	//	==============

	BOOL	Start(IN const char* groupId = NULL);
	void	DestroyCorrelator();
	static void	TerminateCorrelator(ISmirDatabase** a_ppNotifyInt, CCorrCacheNotify** a_ppnotify);
	static void StartUp(ISmirInterrogator *a_ISmirInterrogator = NULL );

	//	Public Destructor
	//	=================

	virtual	~CCorrelator();
};


#endif //_SNMPCORR_CORELAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtmap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTMAP_H
#define _SNMP_EVT_PROV_EVTMAP_H

class CWbemServerWrap;

typedef enum tag_NameElementType
    {	MYWBEM_NAME_ELEMENT_TYPE_PROPERTY	= 0,
		MYWBEM_NAME_ELEMENT_TYPE_INDEX	= 1
    }	MYWBEM_NAME_ELEMENT_TYPE;

typedef union tag_NameElementUnion
    {
		WCHAR* m_wszPropertyName;
		long m_lArrayIndex;
    }	MYWBEM_NAME_ELEMENT_UNION;

typedef struct  tag_NameElement
    {
		short m_nType;
		MYWBEM_NAME_ELEMENT_UNION Element;
    }	MYWBEM_NAME_ELEMENT;

typedef struct  _tag_WbemPropertyName
    {
		long m_lNumElements;
		MYWBEM_NAME_ELEMENT __RPC_FAR *m_aElements;
    }	WBEM_PROPERTY_NAME;

struct VarBindObjectStruct
{
	BOOL fDone;
	SnmpVarBind* pVarBind;
};

struct VarBindObjectArrayStruct
{
	VarBindObjectStruct* vbs;
	UINT length;

	VarBindObjectArrayStruct(VarBindObjectStruct* a_vbs, UINT a_length) : vbs(a_vbs), length(a_length) {}
};


class CMapToEvent
{
protected:

	CString				m_addr;				//sending address
	CString				m_ctxt;				//sending context
	CString				m_oid;				//snmptrap OID
	CString				m_transport;		//the transport protocol
	CString				m_class;			//the event class name
	IWbemClassObject	*m_object;			//the actual event instance which has been "spawned"
	CWbemServerWrap		*m_nspace;			//the namespace we are working in
	IWbemClassObject	*m_vbdefn;			//the snmpvarbind class object
	BOOL				m_btriedGeneric;	//indicates if the generic class has been tried
	BOOL				m_btryGeneric;		//indicates that the generic class should be tried
	BOOL				m_bCheckedVersion;	//indicates whether the version has been determined
	BOOL				m_bSNMPv1;			//indicates the SNMP version
	VarBindObjectArrayStruct	m_vbs;		//the varbinds

	CMapToEvent();
	
	//sets the m_class variable. if btryGeneric is set gets the generic class.
	//if m_btryGeneric is not set and a generic class is returned m_btriedGeneric
	//must be set to true.
	virtual BOOL GetClass();

	virtual BOOL GetSpecificClass() = 0;
	virtual const wchar_t* GetV1Class() = 0;
	virtual const wchar_t* GetV2Class() = 0;

	void GetClassInstance(IWbemClassObject** ppObj);

	virtual HRESULT GetStandardProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	virtual HRESULT GetPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	virtual HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue) = 0;

	virtual HRESULT GetVBProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	BOOL IsSNMPv1();

	IWbemClassObject*	GetVBClassDefn();
	IWbemClassObject*	GetVBClassObjectByIndex(UINT index);
	BOOL				GetVBPropValueByIndex(UINT index, CString& type, VARIANT& vval);
	BOOL				GetVBPropOIDByIndex(UINT index, VARIANT& vOid);

public:

	enum EMappingType
	{
		REFERENT_MAPPER = 0,
		ENCAPSULATED_MAPPER = 1
	};

	virtual void ResetData();

	virtual void GenerateInstance(IWbemClassObject** ppInst) = 0;

	BOOL TriedGeneric() { return m_btriedGeneric; }

	void SetTryGeneric();

	void SetData(const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* transport,
					SnmpVarBindList& vbList,
					CWbemServerWrap* nspace);

	virtual ~CMapToEvent();
};


#endif //_SNMP_EVT_PROV_EVTMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\corstore.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORSTORE
#define _SNMPCORR_CORSTORE 

class CCorrelator;

typedef ULONG TCorrMaskLength;
typedef ULONG TCorrMaskUnit;

enum ECorrCompResult
{
	ECorrAreEqual = 0,
	ECorrFirstLess,
	ECorrFirstGreater,
	ECorrNotEqual
};

class CCorrGroupMask
{

private:

	TCorrMaskLength	m_size;
	TCorrMaskUnit*	m_mask;

public:

			CCorrGroupMask(IN const TCorrMaskLength sze);
	BOOL	IsBitSet(IN const TCorrMaskLength bit) const;
	void	SetBit(IN const TCorrMaskLength bit, IN const BOOL On = TRUE);
			~CCorrGroupMask();
};

class CCorrObjectID
{

private:

	UINT	m_length;
	UINT*	m_Ids;

public:

	//Creates a CCorrObjectID from dotted string
				CCorrObjectID(IN const char* str);

	//Creates a copy of an existing CCorrObjectID
				CCorrObjectID(IN const CCorrObjectID& ID);

	//Creates a CCorrObjectID from an array of UINTS and a length
	//also defaults to constructing an empty CCorrObjectID
				CCorrObjectID(IN const UINT* ids = NULL,
					IN const UINT len = 0);

	ECorrCompResult	CompareWith(IN const CCorrObjectID& second) const;
	BOOL			IsSubRange(IN const CCorrObjectID& child) const;
	wchar_t*		GetWideString()const; //a newly allocated wchar_t* is returned caller must delete []!!
	char*			GetString()const; //a newly allocated char* is returned caller must delete []!!
	void			GetString(CString& str) const;
	UINT			GetLength() const { return m_length; }
	const UINT*		GetIds() const { return m_Ids; }
	void			Set(IN const UINT* ids = NULL, IN const UINT len = 0);
	
	//Deletes any memory used for Ids
				virtual ~CCorrObjectID();

//boolean operators
	BOOL			operator ==(IN const CCorrObjectID& second) const;
	BOOL			operator !=(IN const CCorrObjectID& second) const;
	BOOL			operator <=(IN const CCorrObjectID& second) const;
	BOOL			operator >=(IN const CCorrObjectID& second) const;
	BOOL			operator >(IN const CCorrObjectID& second) const;
	BOOL			operator <(IN const CCorrObjectID& second) const;
//assignment operators
	CCorrObjectID&	operator =(IN const CCorrObjectID& ID);
	CCorrObjectID&	operator +=(IN const CCorrObjectID& ID);
//unary
	CCorrObjectID&	operator ++();
	CCorrObjectID&	operator --();
	CCorrObjectID&	operator -=(IN const UINT sub);
	CCorrObjectID&	operator /=(IN const UINT sub);
};


class CCorrEncodedOID
{

private:

	UINT	m_length;
	UCHAR*	m_ids;
	UCHAR	m_chopped;

public:

	CCorrEncodedOID(IN const CCorrObjectID& src_oid);
	CCorrEncodedOID() : m_ids(NULL), m_length(0), m_chopped(0) {}
	void ExtractOID(OUT CCorrObjectID& oid) const;
	void Set(IN const CCorrObjectID& src_oid);

	~CCorrEncodedOID();
};


class CCorrGroupIdItem : public CObject
{

private:

	CCorrEncodedOID		m_groupId;
	TCorrMaskLength		m_index;

public:
							CCorrGroupIdItem(IN const CCorrObjectID& ID,
												IN ISmirGroupHandle* grpH); 
	void					GetGroupID(OUT CCorrObjectID& ID) const;
	void					SetIndex(IN const TCorrMaskLength i) { m_index = i; }
	const TCorrMaskLength&	GetIndex()const { return m_index; }
	virtual					~CCorrGroupIdItem(); 

	CList<ISmirGroupHandle*, ISmirGroupHandle*> m_groupHandles;

	void					DebugOutputItem(CString* msg = NULL) const;

};


class CCorrRangeTableItem : public CObject
{

private:

	CCorrEncodedOID		m_startRange;
	CCorrEncodedOID		m_endRange;
	CCorrGroupIdItem*	m_groupId;


public:
	
enum ECorrRangeResult
{
	ECorrInRange = 0,
	ECorrBeforeStart,
	ECorrAfterEnd,
	ECorrEqualToStart,
	ECorrEqualToEnd
};


						CCorrRangeTableItem(IN const CCorrObjectID& startID,
											IN const CCorrObjectID& endID,
											IN CCorrGroupIdItem* grpID); 
	BOOL				GetStartRange(OUT CCorrObjectID& start) const;
	BOOL				GetEndRange(OUT CCorrObjectID& end) const;
	CCorrGroupIdItem*	GetGroupIdPtr() { return m_groupId; }
	ECorrRangeResult	IsInRange(IN const CCorrObjectID& ID) const;
	virtual				~CCorrRangeTableItem();

	void				DebugOutputRange() const;

};


class CCorrGroupArray : public CTypedPtrArray< CObArray, CCorrGroupIdItem* >
{

public:

			CCorrGroupArray();

	void	Sort();

			~CCorrGroupArray();
};

class CCorrRangeList : public CTypedPtrList< CObList, CCorrRangeTableItem* >
{

public:


	BOOL					Add(IN CCorrRangeTableItem* newItem);
	BOOL					GetLastEndOID(OUT CCorrObjectID& end) const;

							~CCorrRangeList();
};


class CCorrCache
{

private:

	CCriticalSection	m_Lock;
	DWORD				m_Ref_Count;
	BOOL				m_ValidCache;
	CCorrRangeList		m_rangeTable;
	CCorrGroupArray		m_groupTable;
	CCorrGroupMask*		m_Groups;
	TCorrMaskLength		m_size;


	BOOL		BuildCacheAndSetNotify( ISmirInterrogator *a_ISmirInterrogator );
	BOOL		BuildRangeTable();
	//the last two parameters are defunct now we're using a CObArray!!
	//get rid of them.
	void		DoGroupEntry(UINT* current, UINT* next,
								TCorrMaskLength* cIndex, TCorrMaskLength* nIndex);


public:

							CCorrCache( ISmirInterrogator *p_ISmirInterrogator = NULL );

	TCorrMaskLength&		GetSize() { return m_size; }
	void					AddRef();
	void					DecRef();
	POSITION				GetHeadRangeTable() { return m_rangeTable.GetHeadPosition(); }
	CCorrRangeTableItem*	GetNextRangeTable(POSITION* rPos)
													{ return m_rangeTable.GetNext(*rPos); }
	void					InvalidateCache();

							~CCorrCache();

};

class CCorrCacheWrapper
{

private:

	CCorrCache* m_CachePtr;
	CCriticalSection* m_lockit;


public:

	CCorrCacheWrapper(IN CCorrCache* cachePtr = NULL);
	~CCorrCacheWrapper();

	CCorrCache* GetCache();
	void SetCache(IN CCorrCache* cachePtr){ m_CachePtr = cachePtr; }
	void ReleaseCache() { m_lockit->Unlock(); }
};


#endif //_SNMPCORR_CORSTORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtprov.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTPROV_H
#define _SNMP_EVT_PROV_EVTPROV_H

template <> inline BOOL AFXAPI CompareElements<CString, LPCWSTR>(const CString* pElement1, const LPCWSTR* pElement2)
{
	//return TRUE if equal
	return (pElement1->CompareNoCase(*pElement2) == 0);
}

template <> inline UINT AFXAPI HashKey <LPCWSTR> (LPCWSTR key)
{
	CString tmp(key);
	tmp.MakeUpper();
	return HashKeyLPCWSTR((const WCHAR*)tmp);
}

class CWbemServerWrap
{
private:

	LONG m_ref;
	IWbemServices *m_Serv;
	CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*> m_ClassMap;

public:

		CWbemServerWrap(IWbemServices *pServ);
	
	ULONG	AddRef();
	ULONG	Release();

	IWbemServices*	GetServer() { return m_Serv; }
	HRESULT			GetObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj);
	HRESULT			GetMapperObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj);

		~CWbemServerWrap();
};


class CTrapEventProvider : public IWbemEventProvider, public IWbemProviderInit
{

private:

	CWbemServerWrap*			m_pNamespace;
	IWbemObjectSink*			m_pEventSink;
	CEventProviderThread*	m_thrd;
	LONG					m_ref;
	
	//copy constuctor not defined so not allowed!
	CTrapEventProvider(CTrapEventProvider&);
	void operator=(const CTrapEventProvider&);


public:

	DWORD			m_MapType;

		CTrapEventProvider(DWORD mapperType, CEventProviderThread* thrd);

	CWbemServerWrap*	GetNamespace();
	IWbemObjectSink*	GetEventSink();
    void				AddRefAll();
    void				ReleaseAll();

		~CTrapEventProvider();

	//interface methods
	//==================
    STDMETHODIMP ProvideEvents(
                IWbemObjectSink* pSink,
                LONG lFlags
            );

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);

};

#endif //_SNMP_EVT_PROV_EVTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\notify.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_NOTIFY
#define _SNMPCORR_NOTIFY

class CBaseCorrCacheNotify : public ISMIRNotify
{

    private:
        ULONG	m_cRef;     //Reference count
		DWORD	m_dwCookie;	//Returned by ADVISE used for UNADVISE
	protected:
		CRITICAL_SECTION m_CriticalSection;
		BOOL	m_DoWork;


    public:
				CBaseCorrCacheNotify();
        virtual	~CBaseCorrCacheNotify();

        //IUnknown members
        STDMETHODIMP			QueryInterface(REFIID, void **);
        STDMETHODIMP_(DWORD)	AddRef();
        STDMETHODIMP_(DWORD)	Release();

		void SetCookie(DWORD c)	{ m_dwCookie = c; }
		void Detach();
		DWORD GetCookie()		{ return m_dwCookie; }
};

class CCorrCacheNotify : public CBaseCorrCacheNotify
{
        STDMETHODIMP			ChangeNotify();
};

class CEventCacheNotify : public CBaseCorrCacheNotify
{
        STDMETHODIMP			ChangeNotify();
};

#endif //_SNMPCORR_NOTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propdel.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPDEL_H
#define __PROPDEL_H

class DeleteInstanceAsyncEventObject : public SnmpSetResponseEventObject 
{
private:

	SnmpSession *session ;
	SetOperation *operation ;

	ULONG m_State ;
	IWbemObjectSink *m_NotificationHandler ;
	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	SnmpSetClassObject snmpObject ;

protected:

	void ProcessComplete () ;
	BOOL Delete ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL DeleteInstance ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	DeleteInstanceAsyncEventObject ( 

		CImpPropProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void SnmpTooBig () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
} ;

#endif // __PROPDEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtreft.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTREFT_H
#define _SNMP_EVT_PROV_EVTREFT_H

struct CIMTypeStruct
{
	BOOL fObject;
	CString strType;
};


class CReferentMapper : public CMapToEvent
{
private:

	BOOL			GetSpecificClass();
	const wchar_t*	GetV1Class() { return V1EXTCLASS_NAME; }
	const wchar_t*	GetV2Class() { return V2EXTCLASS_NAME; }
	HRESULT			GetTypeAndIndexQuals(const wchar_t* prop,
											CIMTypeStruct& type,
											ULONG& index);

	HRESULT			CreateEmbeddedProperty(IWbemClassObject** ppObj,
											ULONG index,
											const wchar_t* propertyName,
											const wchar_t* className);

public:

	CReferentMapper();

	HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);
	
	void GenerateInstance(IWbemClassObject** ppInst);
	void ResetData();

	~CReferentMapper();

};


#endif //_SNMP_EVT_PROV_EVTREFT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propget.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPGET_H
#define __PROPGET_H

class SnmpGetResponseEventObject : public SnmpResponseEventObject
{
private:
protected:

	SnmpSession *session ;
	GetOperation *operation ;

	IWbemClassObject *classObject ;
	IWbemClassObject *instanceObject ;
	SnmpGetClassObject snmpObject ;
	BOOL processComplete ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpGetResponseEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context ) ;
	~SnmpGetResponseEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	IWbemClassObject *GetClassObject () { return classObject ; }
	IWbemClassObject *GetInstanceObject () { return instanceObject ; }
} ;

class SnmpGetEventObject : public SnmpGetResponseEventObject
{
private:
protected:

	wchar_t *objectPath ;
	
	BOOL GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class ) ;
	BOOL DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property , KeyRef *a_KeyReference ) ;
	BOOL SetClassKeySpecKey ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL DispatchClassKeySpec ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchObjectPath ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL ParseObjectPath ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpGetEventObject ( CImpPropProv *provider , wchar_t *ObjectPath , IWbemContext *a_Context ) ;
	~SnmpGetEventObject () ;

} ;

class SnmpGetAsyncEventObject : public SnmpGetEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpGetAsyncEventObject ( CImpPropProv *provider , wchar_t *ObjectPath , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpGetAsyncEventObject () ;

	void Process () ;

	void ReceiveComplete () ;
} ;

#endif // __PROPGET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtthrd.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTTHRD_H
#define _SNMP_EVT_PROV_EVTTHRD_H

#include <windows.h>
#include <provexpt.h>

class CTrapEventProvider;
class CEventProviderThread;
class CMapToEvent;

struct SCacheEntry
{
public:
	IWbemClassObject* m_Class;
	DWORD m_Marker;

	SCacheEntry(IWbemClassObject *a_Class)
	{
		m_Class = a_Class;
		m_Marker = 0;
	}
};

template <> inline void AFXAPI  DestructElements<SCacheEntry*> (SCacheEntry** ptr_e, int x)
{
	//x is always one for a CMap!
	if ( (ptr_e != NULL) && (*ptr_e != NULL) )
	{
		if ((*ptr_e)->m_Class != NULL)
		{
			(*ptr_e)->m_Class->Release();
		}

		delete *ptr_e;
	}
}



class MySnmpV1Security : public SnmpV1Security
{
public:
	MySnmpV1Security(const SnmpV1Security& sec) : SnmpV1Security(sec){}
	const char* GetName()const {return GetCommunityName();}
};


class CControlObjectMap : public CMap< UINT, UINT, CTrapEventProvider*, CTrapEventProvider* >
{
private:

	UINT HashKey(UINT key) { return key; }
	CCriticalSection m_Lock;

public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

					
class CTrapListener : public SnmpTrapReceiver
{

private:

	CEventProviderThread*	m_pParent;
	LONG					m_Ref;


public:

			CTrapListener(CEventProviderThread* parentptr);
	
	void	Receive(SnmpTransportAddress &sender_addr,
						SnmpSecurity &security_context,
						SnmpVarBindList &vbList);
	void	Destroy();

			~CTrapListener() {}
};

class CTrapData
{
private:
	LONG m_Ref;

public:

	char			m_static_sender_addr [ 32 ] ;
	char			*m_sender_addr;

	char			*m_security_context;
	char			m_static_security_context [ 32 ] ;

	char			*m_trap_oid;
	char			m_static_trap_oid [ 32 ] ;

	char			*m_transport;
	char			m_static_transport [ 32 ] ;

	SnmpVarBindList	m_variable_bindings;

		CTrapData (const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* trnsp,
					SnmpVarBindList& vbList);
	LONG AddRef();
	LONG Release();

		~CTrapData();

};

class CTrapProcessTaskObject : public SnmpTaskObject
{
private:

	CTrapData			*m_trap_data;
	CTrapEventProvider	*m_Cntrl;

protected:
public:

	CTrapProcessTaskObject (CTrapData *pTData, CTrapEventProvider* pCntrl) ;

	~CTrapProcessTaskObject();

	void Process () ;
	void ProcessEncapsulated () ;
	void ProcessReferent () ;

} ;

class CEventProviderWorkerThread;

class TimerRegistryTaskObject : public SnmpTaskObject
{
private:

	HKEY m_LogKey ;
	CEventProviderWorkerThread *m_parent;

protected:
public:

	TimerRegistryTaskObject (CEventProviderWorkerThread *parent) ;
	~TimerRegistryTaskObject () ;

	void Process () ;
	void ReadRegistry();

	void SetRegistryNotification () ;
} ;

class CWbemServerWrap ;
class CEventProviderWorkerThread : public SnmpThreadObject
{
private:

	void Initialise();
	void Uninitialise();
	void TimedOut();
	
	DWORD m_TimeOut;
	DWORD m_MaxMarks;
	TimerRegistryTaskObject *m_RegTaskObject;
	ISmirDatabase *m_pNotifyInt;
	CEventCacheNotify *m_notify;
	CMap<DWORD, DWORD,
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>*,
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>*> m_Classes;

	CWbemServerWrap *m_pSmirNamespace ;

public:

		CEventProviderWorkerThread();

	void AddClassesToCache(DWORD_PTR key, CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* item);
	void RemoveClassesFromCache(DWORD_PTR key);
	void SetMaxMarks(DWORD dwM);
	void Clear();
	
	CWbemServerWrap *GetServerWrap () { return m_pSmirNamespace ; } ;
	void CreateServerWrap () ;
	void GetDeleteNotifyParams(ISmirDatabase** a_ppNotifyInt, CEventCacheNotify** a_ppNotify);

		~CEventProviderWorkerThread();

};

class CEventProviderThread
{
private:

	CTrapListener*					m_Ear;
	CControlObjectMap				m_ControlObjects;

public:

	CEventProviderThread() : m_Ear(NULL) {}

	BOOL Register(CTrapEventProvider* prov);
	void UnRegister(CTrapEventProvider* prov);

	virtual void	ProcessTrap(const char* sender_addr,
						const char* security_Context,
						const char* snmpTrapOid,
						const char* trnsp,
						SnmpVarBindList& vbList);

};



#endif //_SNMP_EVT_PROV_EVTTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propinst.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPINST_H
#define __PROPINST_H

class SnmpInstanceClassObject : public SnmpClassObject
{
private:

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:

public:

	SnmpInstanceClassObject ( SnmpResponseEventObject *parentOperation ) ;
	SnmpInstanceClassObject ( const SnmpInstanceClassObject & snmpInstanceClassObject ) ;
	~SnmpInstanceClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;

} ;

class SnmpInstanceResponseEventObject : public SnmpResponseEventObject 
{
private:
protected:

	SnmpSession *session ;
	AutoRetrieveOperation *operation ;

	IWbemClassObject *classObject ;
	IWbemClassObject *instanceObject ;
#if 0
	IWbemObjectAccess *instanceAccessObject ;
#endif
	SnmpInstanceClassObject snmpObject ;

	PartitionSet *m_PartitionSet ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpInstanceResponseEventObject ( CImpPropProv *provider , IWbemContext *a_Context ) ;
	~SnmpInstanceResponseEventObject () ;

	IWbemClassObject *GetClassObject () { return classObject ; }
	IWbemClassObject *GetInstanceObject () { return instanceObject ; }
#if 0
	IWbemObjectAccess *GetInstanceAccessObject () { return instanceAccessObject ; }
#endif

	PartitionSet *GetPartitionSet () { return m_PartitionSet ; }

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	SnmpClassObject *GetSnmpRequestClassObject () { return & snmpObject ; }

	virtual void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) = 0 ;
	virtual void ReceiveRow ( IWbemClassObject *snmpObject ) {}
} ;

class SnmpInstanceEventObject : public SnmpInstanceResponseEventObject
{
private:
protected:

	wchar_t *Class ;

public:

	SnmpInstanceEventObject ( CImpPropProv *provider , BSTR Class , IWbemContext *a_Context ) ;
	~SnmpInstanceEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }

	BOOL Instantiate ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpInstanceAsyncEventObject : public SnmpInstanceEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpInstanceAsyncEventObject ( CImpPropProv *provider , BSTR Class , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpInstanceAsyncEventObject () ;

	void Process () ;
	void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) ;
	void ReceiveRow ( IWbemClassObject *snmpObject ) ;
	void ReceiveComplete () ;
} ;

#endif // __PROPINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\guids.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

// {1F517A23-B29C-11cf-8C8D-00AA00A4086C}
DEFINE_GUID(CLSID_CPropProvClassFactory, 
0x1f517a23, 0xb29c, 0x11cf, 0x8c, 0x8d, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {70426720-F78F-11cf-9151-00AA00A4086C}
DEFINE_GUID(CLSID_CClasProvClassFactory,
0x70426720, 0xf78f, 0x11cf, 0x91, 0x51, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {9D5BED16-0765-11d1-AB2C-00C04FD9159E}
DEFINE_GUID(CLSID_CSNMPReftEventProviderClassFactory, 
0x9d5bed16, 0x765, 0x11d1, 0xab, 0x2c, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

// {19C813AC-FEE7-11d0-AB22-00C04FD9159E}
DEFINE_GUID(CLSID_CSNMPEncapEventProviderClassFactory, 
0x19c813ac, 0xfee7, 0x11d0, 0xab, 0x22, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propprov.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPPropertyProvider_H_
#define _SNMPPropertyProvider_H_

extern CRITICAL_SECTION s_ProviderCriticalSection ;

class SnmpInstanceDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpInstanceDefaultThreadObject ( const char *threadName = NULL ) : SnmpThreadObject ( threadName ) {} ;
	~SnmpInstanceDefaultThreadObject () {} ;

	void Initialise () ;
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpPropProv : public IWbemServices , public IWbemProviderInit
{
private:

	BOOL initialised ;
	LONG m_referenceCount ;         //Object reference count

	CCriticalSection criticalSection ;

	WbemNamespacePath namespacePath ;
	wchar_t *thisNamespace ;

	IWbemServices *server ;
	IWbemServices *parentServer ;
	IWbemProviderInitSink *m_InitSink ;
	char *ipAddressString ;
	char *ipAddressValue ;

	wchar_t *m_localeId ;

	BOOL m_getNotifyCalled ;
	BOOL m_getSnmpNotifyCalled ;
	CCriticalSection m_notificationLock;
	CCriticalSection m_snmpNotificationLock;
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_snmpNotificationClassObject ;

private:
	
	HRESULT SetServer ( IWbemServices *serverArg );
	HRESULT SetParentServer ( IWbemServices *parentServerArg ) ;

	BOOL AttachParentServer ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR Namespace, 
		IWbemContext *pCtx
	) ;

	BOOL ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject ) ;

protected:
public:

	CImpPropProv () ;
    ~CImpPropProv () ;

	static BOOL s_Initialised ;

	// Implementation

	IWbemServices *GetServer () ;
	IWbemServices *GetParentServer () ;
	WbemNamespacePath *GetNamespacePath () { return & namespacePath ; }
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	void SetLocaleId ( wchar_t *localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	char *GetIpAddressString () { return ipAddressString ; }
	char *GetIpAddressValue () { return ipAddressValue ; }

	BOOL FetchSnmpNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL FetchNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize(

			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
			);        

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\resource.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propset.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPSET_H
#define __PROPSET_H

class SnmpSetClassObject : public SnmpClassObject
{
private:

	BOOL m_RowStatusSpecified ;
	BOOL m_RowStatusPresent ;

	wchar_t **m_WritableSet ; 
	ULONG m_WritableSetCount ;

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:
public:

	SnmpSetClassObject ( SnmpResponseEventObject *parentOperation ) ;

	~SnmpSetClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL RowStatusSpecified () { return m_RowStatusSpecified ; }
	BOOL RowStatusPresent () { return m_RowStatusPresent ; }

	ULONG NumberOfWritable () ;

	BOOL IsWritable ( WbemSnmpProperty *a_Property ) ;

	void SetWritableSet ( 

		wchar_t **a_WritableSet ,
		ULONG a_WritableSetCount 
	) ;
} ;

class SnmpSetResponseEventObject : public SnmpResponseEventObject 
{
private:
protected:

/*
 * State variables for event based processing.
 */

	ULONG state ;
	ULONG m_VarBindsLeftBeforeTooBig ;
	BOOL m_SnmpTooBig ;

	long m_lflags ;
	IWbemClassObject *classObject ;
	SnmpSetClassObject snmpObject ;
	BOOL processComplete ;

	SnmpSession *session ;
	SetOperation *operation ;
	SetQueryOperation *m_QueryOperation ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject , const ULONG &a_NumberToSend = 0xffffffff ) ;

public:

	SnmpSetResponseEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context , long lflags ) ;
	~SnmpSetResponseEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	IWbemClassObject *GetClassObject () { return classObject ; }
} ;

class SnmpUpdateEventObject : public SnmpSetResponseEventObject
{
private:
protected:

	BOOL Create_Only () ;
	BOOL Update_Only () ;
	BOOL Create_Or_Update () ;

	BOOL Send_Variable_Binding_List ( 

		SnmpSetClassObject &a_SnmpSetClassObject ,
		ULONG a_NumberToSend 
	) ;

	BOOL Send_Variable_Binding_List ( 

		SnmpSetClassObject &a_SnmpSetClassObject , 
		ULONG a_NumberToSend ,
		SnmpRowStatusType :: SnmpRowStatusEnum a_SnmpRowStatusEnum
	) ;

	BOOL CheckForRowExistence ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL Update ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpUpdateEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context , long lflags ) ;
	~SnmpUpdateEventObject () ;
} ;

class SnmpUpdateAsyncEventObject : public SnmpUpdateEventObject
{
private:

	IWbemObjectSink *notificationHandler ;

protected:

	void SetComplete () ;

public:

	SnmpUpdateAsyncEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemObjectSink *notify , IWbemContext *a_Context , long lflags ) ;
	~SnmpUpdateAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void SnmpTooBig () ;
} ;


#endif // __PROPSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propsnmp.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPSNMP_H
#define __PROPSNMP_H

class SnmpV1OverIp ;
class GetOperation ;
class SetOperation ;
class RefreshOperation ;
class SetQueryOperation ;
class AutoRetrieveOperation ;
class SnmpResponseEventObject ;

#define SYTEM_PROPERTY_START_CHARACTER	L'_'

class SnmpClassObject : public WbemSnmpClassObject
{
private:
protected:

	BOOL m_accessible ;
	ULONG snmpVersion ;
	SnmpResponseEventObject *m_parentOperation ;

public:

	SnmpClassObject ( SnmpResponseEventObject *parentOperation ) ;
	SnmpClassObject ( const SnmpClassObject &a_SnmpClassObject ) ;
	~SnmpClassObject () ;

	ULONG GetSnmpVersion () { return snmpVersion ; } 

} ;

class SnmpGetClassObject : public SnmpClassObject
{
private:

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:
public:

	SnmpGetClassObject ( SnmpResponseEventObject *m_parentOperation ) ;
	~SnmpGetClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpResponseEventObject : public SnmpTaskObject
{
private:

	LONG m_ReferenceCount ;

protected:

	//HRESULT completionCode ;
	WbemSnmpErrorObject m_errorObject ;
	CImpPropProv *provider ;
	IWbemClassObject *m_namespaceObject ;
	IWbemContext *m_Context ;
	ULONG m_agentVersion ;

	BOOL GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL GetAgentTransport ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentTransport ) ;
	BOOL GetAgentAddress ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentAddress ) ;
	BOOL GetAgentReadCommunityName ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentWriteCommunityName ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentRetryCount ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryCount ) ;
	BOOL GetAgentRetryTimeout( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryTimeout ) ;
	BOOL GetAgentMaxVarBindsPerPdu ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentVarBindsPerPdu ) ;
	BOOL GetAgentFlowControlWindowSize ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentFlowControlWindowSize ) ;

	BOOL GetNotifyStatusObject ( IWbemClassObject **notifyObject ) ;
	BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

	BOOL HasNonNullKeys ( IWbemClassObject *a_Obj ) ;

public:

	SnmpResponseEventObject ( CImpPropProv *provider , IWbemContext *a_Context ) ;
	~SnmpResponseEventObject () ;

	//HRESULT GetCompletionCode () { return completionCode ; }
	WbemSnmpErrorObject &GetErrorObject () { return m_errorObject ; }
	ULONG SetAgentVersion ( WbemSnmpErrorObject &a_errorObject ) ;

	virtual SnmpClassObject *GetSnmpClassObject () = 0 ;
	virtual SnmpClassObject *GetSnmpRequestClassObject () { return NULL ; }

	virtual void ReceiveComplete () = 0 ;
	virtual void SnmpTooBig () {} ;

    ULONG AddRef () ;
    ULONG Release () ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpget.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

class GetOperation : public SnmpGetOperation
{
private:

	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpGetResponseEventObject *eventObject ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	GetOperation (IN SnmpSession &session , IN SnmpGetResponseEventObject *eventObject ) ;
	~GetOperation () ;

	void Send () ;

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpqset.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

class SetQueryOperation : public SnmpGetOperation
{
private:

	BOOL rowReceived ;

	SnmpSession *session ;

	SnmpSetResponseEventObject *eventObject ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

public:

	SetQueryOperation  (IN SnmpSession &session,	IN SnmpSetResponseEventObject *eventObjectArg ) ;
	~SetQueryOperation  () ;

	void Send () ;
	
	ULONG GetRowReceived () { return rowReceived ; }

	void DestroyOperation () { SnmpGetOperation :: DestroyOperation () ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpnext.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef __SNMPNEXT_H
#define __SNMPNEXT_H

class PropertyDefinition
{
private:
protected:
public:

	WbemSnmpProperty *m_Property ;

	ULONG m_KeyCount ;
	SnmpObjectIdentifier **m_ObjectIdentifierComponent ;
	SnmpObjectIdentifier **m_ObjectIdentifierStart ;
	SnmpObjectIdentifier **m_ObjectIdentifierEnd ;
	ULONG *m_PartitionIndex ;
	PartitionSet **m_KeyPartition ;

public:

	PropertyDefinition () 
	{
		m_KeyCount = 0 ;
		m_Property = NULL ;
		m_ObjectIdentifierStart = NULL ;
		m_ObjectIdentifierEnd = NULL ;
		m_KeyPartition = NULL ;
		m_PartitionIndex = NULL ;
		m_ObjectIdentifierComponent = NULL ;
	}

	~PropertyDefinition () 
	{
		for ( ULONG t_Index = 1 ; t_Index <= m_KeyCount ; t_Index ++ )
		{
			if ( m_ObjectIdentifierStart ) 
				delete m_ObjectIdentifierStart [ t_Index ] ;

			if ( m_ObjectIdentifierEnd ) 
				delete m_ObjectIdentifierEnd [ t_Index ] ;

			if ( m_ObjectIdentifierComponent )
			delete m_ObjectIdentifierComponent [ t_Index ] ;
		}

		delete [] m_ObjectIdentifierStart ;
		delete [] m_ObjectIdentifierEnd ;
		delete [] m_ObjectIdentifierComponent ;

		delete [] m_KeyPartition ;
		delete [] m_PartitionIndex ;
 	}
} ;

class AutoRetrieveOperation : public SnmpAutoRetrieveOperation
{
private:

	PropertyDefinition *m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	BOOL virtuals ;
	BOOL virtualsInitialised ;
	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;
	ULONG rowsReceived ;
	ULONG rowVarBindsReceived ;

	SnmpSession *session ;

	SnmpInstanceResponseEventObject *eventObject ;
	IWbemClassObject *snmpObject ;

	LONG EvaluateInitialVarBind ( 

		ULONG a_PropertyIndex ,
		SnmpObjectIdentifier &a_CurrentIdentifier ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateSubsequentVarBind ( 

		ULONG a_PropertyIndex ,
		IN ULONG &a_CurrentIndex ,
		SnmpObjectIdentifier &a_CurrentIdentifier ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateVarBind ( 

		ULONG a_PropertyIndex ,
		SnmpObjectIdentifier &a_StartIdentifier 
	) ;

	LONG EvaluateResponse (

		ULONG a_PropertyIndex ,
		IN ULONG &a_CurrentIndex ,
		SnmpObjectIdentifier &a_AdvanceIdentifier 
	) ;

protected:

	void ReceiveResponse () ;

	void ReceiveRowResponse () ;

	void ReceiveRowVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	LONG EvaluateNextRequest (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN SnmpVarBind &sendVarBind
) ;


	void FrameTooBig() ;
	void FrameOverRun() ;

public:

	AutoRetrieveOperation (IN SnmpSession &session,	IN SnmpInstanceResponseEventObject *eventObjectArg ) ;
	~AutoRetrieveOperation () ;

	void Send () ;
	
	void DestroyOperation () { SnmpAutoRetrieveOperation :: DestroyOperation () ; }
};

#endif // __SNMPNEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propquery.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPQUERY_H
#define __PROPQUERY_H

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#include <provtree.h>
#include <provdnf.h>

class SnmpQueryEventObject : public SnmpInstanceResponseEventObject , public QueryPreprocessor
{
protected:

	WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 
	) ;

	QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareCaseInsensitiveString ( 

		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand ,
		bool a_Class = false 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand ,
		bool a_Class = false 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	void GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container ) ;

	SnmpInstanceClassObject *requestObject ;
	wchar_t *Query ;
	wchar_t *QueryFormat ;
	wchar_t *Class ;

#ifdef POST_FILTERING_RECEIVED_ROW
	BOOL Compare ( 

		const LONG & op1 , 
		const LONG & op2 , 
		const DWORD & op1Func ,
		const DWORD & op2Func ,
		const int & operatorType 
	) ;

	BOOL Compare ( 

		const wchar_t * & op1 , 
		const wchar_t * & op2 , 
		const DWORD & op1Func ,
		const DWORD & op2Func ,
		const int & operatorType 
	) ;

	BOOL Compare ( 

		const SAFEARRAY * & op1 , 
		const SAFEARRAY * & op2 , 
		const DWORD & op1Func ,
		const DWORD & op2Func ,
		const int & operatorType 
	) ;


	BOOL ExpressionCompare ( SnmpInstanceClassObject *snmpObject , SQL_LEVEL_1_TOKEN *propertyValue ) ;
	BOOL RecursivePostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject , int &index ) ;
	BOOL PostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject ) ;
#endif //POST_FILTERING_RECEIVED_ROW

	BOOL CheckWhereCondition ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ,	SQL_LEVEL_1_TOKEN *token ) ;
	BOOL PreEvaluate ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL IsSystemProperty (const wchar_t *propertyName ) ;

private:

	SQL_LEVEL_1_RPN_EXPRESSION *rpnExpression ;
	SQL1_Parser parser ;
	CTextLexSource source ;


public:

	SnmpQueryEventObject ( CImpPropProv *provider , BSTR QueryFormat , BSTR Query , IWbemContext *a_Context ) ;
	~SnmpQueryEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	SnmpClassObject *GetSnmpRequestClassObject  () { return requestObject ; }

	BOOL Instantiate ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpQueryAsyncEventObject : public SnmpQueryEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpQueryAsyncEventObject ( CImpPropProv *provider , BSTR QueryFormat , BSTR Query , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpQueryAsyncEventObject () ;

	void Process () ;
	void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) ;
	void ReceiveRow ( IWbemClassObject *snmpObject ) ;
	void ReceiveComplete () ;
} ;

#endif // __PROPQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpobj.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include <windows.h>
#include <provexpt.h>

#define WBEM_NAMESPACE_EQUALS L"__Namespace=\""
#define WBEM_NAMESPACE_QUOTE L"\""

#define WBEM_CLASS_NAMESPACE			L"__Namespace"
#define WBEM_CLASS_NOTIFYSTATUS		L"__NotifyStatus"
#define WBEM_CLASS_EXTENDEDSTATUS		L"__ExtendedStatus"
#define WBEM_CLASS_SNMPNOTIFYSTATUS	L"SnmpNotifyStatus"
#define WBEM_CLASS_SNMPMACRO			L"SnmpMacro"
#define WBEM_CLASS_SNMPOBJECTTYPE	L"SnmpObjectType"
#define WBEM_CLASS_EXTRINSICEVENT	L"__ExtrinsicEvent"
#define WBEM_CLASS_SNMPNOTIFICATION L"SnmpNotification"
#define WBEM_CLASS_SNMPEXTENDEDNOTIFICATION L"SnmpExtendedNotification"
#define WBEM_CLASS_SNMPVARBIND L"SnmpVarBind"
#define WBEM_CLASS_NULL	L""

#define WBEM_PROPERTY_CLASS		L"__class"
#define WBEM_PROPERTY_SUPERCLASS	L"__superclass"
#define WBEM_PROPERTY_KEY			L"__key"
#define WBEM_PROPERTY_GENUS		L"__genus"
#define WBEM_PROPERTY_DYNASTY		L"__dynasty"
#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_SNMPSTATUSCODE   L"SnmpStatusCode"
#define WBEM_PROPERTY_SNMPSTATUSMESSAGE   L"Description"

#define WBEM_QUALIFIER_DYNAMIC						L"dynamic"
#define WBEM_QUALIFIER_PROVIDER						L"provider"
#define WBEM_QUALIFIER_KEY							L"key"
#define WBEM_QUALIFIER_KEY_ORDER					L"key_order"
#define WBEM_QUALIFIER_READ							L"read"
#define WBEM_QUALIFIER_WRITE						L"write"
#define WBEM_QUALIFIER_AGENTSNMPVERSION				L"AgentSNMPVersion"
#define WBEM_QUALIFIER_AGENTTRANSPORT				L"AgentTransport"
#define WBEM_QUALIFIER_AGENTADDRESS					L"AgentAddress"
#define WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME		L"AgentReadCommunityName"
#define WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME		L"AgentWriteCommunityName"
#define WBEM_QUALIFIER_AGENTRETRYCOUNT				L"AgentRetryCount"
#define WBEM_QUALIFIER_AGENTRETRYTIMEOUT			L"AgentRetryTimeout"
#define WBEM_QUALIFIER_AGENTVARBINDSPERPDU			L"AgentVarBindsPerPdu"
#define WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE	L"AgentFlowControlWindowSize"
#define WBEM_QUALIFIER_TYPE				L"type"
#define WBEM_QUALIFIER_NAME				L"name"
#define WBEM_QUALIFIER_DESCRIPTION			L"description"
#define WBEM_QUALIFIER_DYNASTY				L"dynasty"
#define WBEM_QUALIFIER_MODULE_NAME			L"module_name"
#define WBEM_QUALIFIER_GROUP_OBJECTID		L"group_objectid"
#define WBEM_QUALIFIER_VIRTUAL_KEY			L"virtual_key"
#define WBEM_QUALIFIER_OBJECT_IDENTIFIER	L"object_identifier"
#define WBEM_QUALIFIER_TEXTUAL_CONVENTION	L"textual_convention"
#define WBEM_QUALIFIER_ENCODING			L"encoding"
#define WBEM_QUALIFIER_SYNTAX				L"syntax"
#define WBEM_QUALIFIER_ENUMERATION			L"enumeration"
#define WBEM_QUALIFIER_BITS				L"bits"
#define WBEM_QUALIFIER_FIXED_LENGTH		L"fixed_length"
#define WBEM_QUALIFIER_VARIABLE_VALUE		L"variable_value"
#define WBEM_QUALIFIER_VARIABLE_LENGTH		L"variable_length"
#define WBEM_QUALIFIER_DISPLAY_HINT		L"display_hint"
#define WBEM_QUALIFIER_TYPE_MISMATCH		L"type_mismatch"
#define WBEM_QUALIFIER_VALUE_MISMATCH		L"value_mismatch"
#define WBEM_QUALIFIER_NOT_AVAILABLE		L"not_available"
#define WBEM_QUALIFIER_SINGLETON 		L"singleton"
#define WBEM_QUALIFIER_TABLECLASS		L"TableClass"
#define WBEM_QUALIFIER_KEYTYPES			L"KeyTypes"
#define WBEM_QUALIFIER_KEYVALUES			L"KeyValues"
#define WBEM_QUALIFIER_VARBINDINDEX		L"VarBindIndex"
#define WBEM_QUALIFIER_ROWSTATUS					L"rowstatus"

#define WBEM_INDEX_QUALIFIER_KEY							1
#define WBEM_INDEX_QUALIFIER_KEY_ORDER						2
#define WBEM_INDEX_QUALIFIER_READ							3
#define WBEM_INDEX_QUALIFIER_WRITE							4
#define WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION				5
#define WBEM_INDEX_QUALIFIER_AGENTTRANSPORT				6
#define WBEM_INDEX_QUALIFIER_AGENTADDRESS					7
#define WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME		8
#define WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME		9
#define WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT				10
#define WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT				11
#define WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU			12	
#define WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE	13	
#define WBEM_INDEX_QUALIFIER_TYPE							14
#define WBEM_INDEX_QUALIFIER_NAME							15
#define WBEM_INDEX_QUALIFIER_DESCRIPTION					16
#define WBEM_INDEX_QUALIFIER_DYNASTY						17
#define WBEM_INDEX_QUALIFIER_MODULE_NAME					18
#define WBEM_INDEX_QUALIFIER_GROUP_OBJECTID				19
#define WBEM_INDEX_QUALIFIER_VIRTUAL_KEY					20
#define WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER				21
#define WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION			22
#define WBEM_INDEX_QUALIFIER_ENCODING						23
#define WBEM_INDEX_QUALIFIER_SYNTAX						24
#define WBEM_INDEX_QUALIFIER_ENUMERATION					25
#define WBEM_INDEX_QUALIFIER_BITS							26
#define WBEM_INDEX_QUALIFIER_FIXED_LENGTH					27
#define WBEM_INDEX_QUALIFIER_VARIABLE_VALUE				28
#define WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH				29
#define WBEM_INDEX_QUALIFIER_DISPLAY_HINT					30
#define WBEM_INDEX_QUALIFIER_TYPE_MISMATCH					31
#define WBEM_INDEX_QUALIFIER_VALUE_MISMATCH					32
#define WBEM_INDEX_QUALIFIER_NOT_AVAILABLE					33
#define WBEM_INDEX_QUALIFIER_SINGLETON					34
#define WBEM_INDEX_QUALIFIER_TABLECLASS					35
#define WBEM_INDEX_QUALIFIER_KEYTYPES					36
#define WBEM_INDEX_QUALIFIER_KEYVALUES					37
#define WBEM_INDEX_QUALIFIER_VARBINDINDEX					38
#define WBEM_INDEX_QUALIFIER_ROWSTATUS					39

#define WBEM_TYPE_NULL					L"NULL"
#define WBEM_TYPE_INTEGER				L"INTEGER"
#define WBEM_TYPE_INTEGER32				L"INTEGER32"
#define WBEM_TYPE_COUNTER				L"Counter"
#define WBEM_TYPE_GAUGE				L"Gauge"
#define WBEM_TYPE_TIMETICKS			L"TimeTicks"
#define WBEM_TYPE_UNSIGNED32			L"UNSIGNED32"
#define WBEM_TYPE_COUNTER32			L"Counter32"
#define WBEM_TYPE_COUNTER64			L"Counter64"
#define WBEM_TYPE_GAUGE32				L"Gauge32"
#define WBEM_TYPE_OCTETSTRING			L"OCTETSTRING"
#define WBEM_TYPE_OPAQUE				L"Opaque"
#define WBEM_TYPE_IPADDRESS			L"IpAddress"
#define WBEM_TYPE_NETWORKADDRESS		L"NetworkAddress"
#define WBEM_TYPE_OBJECTIDENTIFIER		L"OBJECTIDENTIFIER"
#define WBEM_TYPE_DISPLAYSTRING		L"DisplayString"
#define WBEM_TYPE_MACADDRESS			L"MacAddress"
#define WBEM_TYPE_PHYSADDRESS			L"PhysAddress" 
#define WBEM_TYPE_ENUMERATEDINTEGER	L"EnumeratedInteger"
#define WBEM_TYPE_BITS					L"BITS"
#define WBEM_TYPE_DATETIME				L"DateAndTime"
#define WBEM_TYPE_SNMPOSIADDRESS		L"SnmpOSIAddress"
#define WBEM_TYPE_SNMPUDPADDRESS		L"SnmpUDPAddress"
#define WBEM_TYPE_SNMPIPXADDRESS		L"SnmpIPXAddress"
#define WBEM_TYPE_ROWSTATUS		L"RowStatus"


#define WBEM_INDEX_TYPE_NULL				1
#define WBEM_INDEX_TYPE_INTEGER			2
#define WBEM_INDEX_TYPE_INTEGER32			3
#define WBEM_INDEX_TYPE_COUNTER			4
#define WBEM_INDEX_TYPE_GAUGE				5
#define WBEM_INDEX_TYPE_TIMETICKS			6
#define WBEM_INDEX_TYPE_OCTETSTRING		7
#define WBEM_INDEX_TYPE_OPAQUE				8
#define WBEM_INDEX_TYPE_IPADDRESS			9
#define WBEM_INDEX_TYPE_NETWORKADDRESS		10
#define WBEM_INDEX_TYPE_OBJECTIDENTIFIER	11
#define WBEM_INDEX_TYPE_DISPLAYSTRING		12
#define WBEM_INDEX_TYPE_MACADDRESS			13
#define WBEM_INDEX_TYPE_PHYSADDRESS		14
#define WBEM_INDEX_TYPE_ENUMERATEDINTEGER	15
#define WBEM_INDEX_TYPE_UNSIGNED32			16
#define WBEM_INDEX_TYPE_COUNTER32			17
#define WBEM_INDEX_TYPE_COUNTER64			18
#define WBEM_INDEX_TYPE_GAUGE32			19
#define WBEM_INDEX_TYPE_BITS				20
#define WBEM_INDEX_TYPE_DATETIME			21
#define WBEM_INDEX_TYPE_SNMPOSIADDRESS		22
#define WBEM_INDEX_TYPE_SNMPUDPADDRESS		23
#define WBEM_INDEX_TYPE_SNMPIPXADDRESS		24
#define WBEM_INDEX_TYPE_ROWSTATUS		25

#define WBEM_AGENTSNMPVERSION_DBCS_V1	"1"		
#define WBEM_AGENTSNMPVERSION_DBCS_V2C	"2C"		
#define WBEM_AGENTIPTRANSPORT_DBCS		"IP"
#define WBEM_AGENTIPXTRANSPORT_DBCS		"IPX"

#define WBEM_AGENTSNMPVERSION_V1	L"1"		
#define WBEM_AGENTSNMPVERSION_V2C	L"2C"		
#define WBEM_AGENTIPTRANSPORT		L"IP"
#define WBEM_AGENTIPXTRANSPORT		L"IPX"
#define WBEM_AGENTCOMMUNITYNAME  L"public"

#define WBEM_GENUS_INSTANCE		2
#define WBEM_GENUS_CLASS			1

#define WBEM_CLASS_NOCORRELATE 0x1000
#define WBEM_CLASS_CORRELATE_CONTEXT_PROP L"Correlate"

#define WBEM_QUERY_LANGUAGE_WQL			L"WQL"

#define WBEM_ERROR_CRITICAL_ERROR		WBEM_E_PROVIDER_FAILURE
#define WBEM_SNMP_ERROR_CRITICAL_ERROR	WBEM_SNMP_E_PROVIDER_FAILURE

#define WBEM_CLASS_PROPAGATION	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

typedef 
enum tag_WBEMSNMPSTATUS
{

	WBEM_SNMP_NO_ERROR							= 0,
	WBEM_SNMP_S_NO_ERROR							= 0,
	WBEM_SNMP_S_NO_MORE_DATA						= 0x40001,
	WBEM_SNMP_S_ALREADY_EXISTS					= WBEM_SNMP_S_NO_MORE_DATA + 1,
	WBEM_SNMP_S_NOT_FOUND						= WBEM_SNMP_S_ALREADY_EXISTS + 1,
	WBEM_SNMP_S_RESET_TO_DEFAULT					= WBEM_SNMP_S_NOT_FOUND + 1,
	WBEM_SNMP_E_FAILED							= 0x80041001,
	WBEM_SNMP_E_NOT_FOUND						= WBEM_SNMP_E_FAILED + 1,
	WBEM_SNMP_E_ACCESS_DENIED					= WBEM_SNMP_E_NOT_FOUND + 1,
	WBEM_SNMP_E_PROVIDER_FAILURE					= WBEM_SNMP_E_ACCESS_DENIED + 1,
	WBEM_SNMP_E_TYPE_MISMATCH					= WBEM_SNMP_E_PROVIDER_FAILURE + 1,
	WBEM_SNMP_E_OUT_OF_MEMORY					= WBEM_SNMP_E_TYPE_MISMATCH + 1,
	WBEM_SNMP_E_INVALID_CONTEXT					= WBEM_SNMP_E_OUT_OF_MEMORY + 1,
	WBEM_SNMP_E_INVALID_PARAMETER				= WBEM_SNMP_E_INVALID_CONTEXT + 1,
	WBEM_SNMP_E_NOT_AVAILABLE					= WBEM_SNMP_E_INVALID_PARAMETER + 1,
	WBEM_SNMP_E_CRITICAL_ERROR					= WBEM_SNMP_E_NOT_AVAILABLE + 1,
	WBEM_SNMP_E_INVALID_STREAM					= WBEM_SNMP_E_CRITICAL_ERROR + 1,
	WBEM_SNMP_E_NOT_SUPPORTED					= WBEM_SNMP_E_INVALID_STREAM + 1,
	WBEM_SNMP_E_INVALID_SUPERCLASS				= WBEM_SNMP_E_NOT_SUPPORTED + 1,
	WBEM_SNMP_E_INVALID_NAMESPACE				= WBEM_SNMP_E_INVALID_SUPERCLASS + 1,
	WBEM_SNMP_E_INVALID_OBJECT					= WBEM_SNMP_E_INVALID_NAMESPACE + 1,
	WBEM_SNMP_E_INVALID_CLASS					= WBEM_SNMP_E_INVALID_OBJECT + 1,
	WBEM_SNMP_E_PROVIDER_NOT_FOUND				= WBEM_SNMP_E_INVALID_CLASS + 1,
	WBEM_SNMP_E_INVALID_PROVIDER_REGISTRATION	= WBEM_SNMP_E_PROVIDER_NOT_FOUND + 1,
	WBEM_SNMP_E_PROVIDER_LOAD_FAILURE			= WBEM_SNMP_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_SNMP_E_INITIALIZATION_FAILURE			= WBEM_SNMP_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_SNMP_E_TRANSPORT_FAILURE				= WBEM_SNMP_E_INITIALIZATION_FAILURE + 1,
	WBEM_SNMP_E_INVALID_OPERATION				= WBEM_SNMP_E_TRANSPORT_FAILURE + 1,
	WBEM_SNMP_E_INVALID_QUERY					= WBEM_SNMP_E_INVALID_OPERATION + 1,
	WBEM_SNMP_E_INVALID_QUERY_TYPE				= WBEM_SNMP_E_INVALID_QUERY + 1,
	WBEM_SNMP_E_ALREADY_EXISTS					= WBEM_SNMP_E_INVALID_QUERY_TYPE + 1,
	WBEM_SNMP_E_OVERRIDE_NOT_ALLOWED				= WBEM_SNMP_E_ALREADY_EXISTS + 1,
	WBEM_SNMP_E_PROPAGATED_QUALIFIER				= WBEM_SNMP_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_SNMP_E_UNEXPECTED						= WBEM_SNMP_E_PROPAGATED_QUALIFIER + 1,
	WBEM_SNMP_E_ILLEGAL_OPERATION				= WBEM_SNMP_E_UNEXPECTED + 1,
	WBEM_SNMP_E_CANNOT_BE_KEY					= WBEM_SNMP_E_ILLEGAL_OPERATION + 1,
	WBEM_SNMP_E_INCOMPLETE_CLASS					= WBEM_SNMP_E_CANNOT_BE_KEY + 1,
	WBEM_SNMP_E_INVALID_SYNTAX					= WBEM_SNMP_E_INCOMPLETE_CLASS + 1,
	WBEM_SNMP_E_NONDECORATED_OBJECT				= WBEM_SNMP_E_INVALID_SYNTAX + 1,
	WBEM_SNMP_E_READ_ONLY						= WBEM_SNMP_E_NONDECORATED_OBJECT + 1,
	WBEM_SNMP_E_PROVIDER_NOT_CAPABLE				= WBEM_SNMP_E_READ_ONLY + 1,
	WBEM_SNMP_E_CLASS_HAS_CHILDREN				= WBEM_SNMP_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_SNMP_E_CLASS_HAS_INSTANCES				= WBEM_SNMP_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_SNMP_E_INVALID_PROPERTY					= WBEM_SNMP_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_SNMP_E_INVALID_QUALIFIER				= WBEM_SNMP_E_INVALID_PROPERTY + 1 ,
	WBEM_SNMP_E_INVALID_PATH						= WBEM_SNMP_E_INVALID_QUALIFIER + 1 ,
	WBEM_SNMP_E_INVALID_PATHKEYPARAMETER			= WBEM_SNMP_E_INVALID_PATH + 1 ,
	WBEM_SNMP_E_MISSINGPATHKEYPARAMETER 			= WBEM_SNMP_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_SNMP_E_INVALID_KEYORDERING				= WBEM_SNMP_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER		= WBEM_SNMP_E_INVALID_KEYORDERING + 1 ,
	WBEM_SNMP_E_MISSINGKEY						= WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_SNMP_E_INVALID_TRANSPORT				= WBEM_SNMP_E_MISSINGKEY + 1 ,
	WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT			= WBEM_SNMP_E_INVALID_TRANSPORT + 1 ,
	WBEM_SNMP_E_TRANSPORT_ERROR					= WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_SNMP_E_TRANSPORT_NO_RESPONSE			= WBEM_SNMP_E_TRANSPORT_ERROR + 1 ,
	WBEM_SNMP_E_NOWRITABLEPROPERTIES				= WBEM_SNMP_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_SNMP_E_NOREADABLEPROPERTIES				= WBEM_SNMP_E_NOWRITABLEPROPERTIES + 1 

} WBEMSNMPSTATUS;

enum WbemPropertyValueCheck
{
	SetValueRegardlessReturnCheck = 0 ,
	SetValueRegardlessDontReturnCheck ,
	SetValueIfCheckOk ,
	DontSetValueReturnCheck
} ;

#if 0
#if _MSC_VER >= 1100
template <> __declspec ( dllexport ) UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
__declspec ( dllexport ) UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> __declspec ( dllexport ) BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 ) ;
#else
__declspec ( dllexport ) BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif
#endif 

class __declspec ( dllexport ) WbemSnmpErrorObject 
{
private:

	wchar_t *m_snmpErrorMessage ;
	WBEMSNMPSTATUS m_snmpErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemSnmpErrorObject () : m_snmpErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_snmpErrorStatus ( WBEM_SNMP_NO_ERROR ) {} ;
	virtual ~WbemSnmpErrorObject () { delete [] m_snmpErrorMessage ; } ;

	void SetStatus ( WBEMSNMPSTATUS a_snmpErrorStatus )
	{
		m_snmpErrorStatus = a_snmpErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_snmpErrorMessage )
	{
		DebugMacro1 ( 

			if ( a_snmpErrorMessage )
			{
				SnmpDebugLog :: s_SnmpDebugLog->Write ( 

					L"\r\nWbemSnmpErrorObject :: SetMessage ( (%s) )" , a_snmpErrorMessage 
				) ; 
			}
		)

		delete [] m_snmpErrorMessage ;
		m_snmpErrorMessage = UnicodeStringDuplicate ( a_snmpErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_snmpErrorMessage ; } ;
	WBEMSNMPSTATUS GetStatus () { return m_snmpErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;

class __declspec ( dllexport ) WbemSnmpQualifier 
{
private:

	wchar_t *qualifierName ;
	SnmpInstanceType *typeValue ;

protected:
public:

	WbemSnmpQualifier ( const WbemSnmpQualifier &copy ) ;

	WbemSnmpQualifier (

		const wchar_t *qualifierName ,
		const SnmpInstanceType *typeValue 
	) ;

	virtual ~WbemSnmpQualifier () ;

	BOOL IsPropagatable () const ;

	wchar_t *GetName () const ;

	SnmpInstanceType *GetValue () const ;
	BOOL GetValue ( VARIANT &variant ) const ;
	VARTYPE GetValueVariantType () const ;

	BOOL SetValue ( const VARIANT &variant ) ;
	BOOL SetValue ( const SnmpInstanceType *value ) ;
	BOOL SetValue ( const wchar_t *value ) ;
	BOOL SetValue ( IWbemQualifierSet *a_Qualifier , const SnmpInstanceType &value ) ;
} ;

class __declspec ( dllexport ) WbemSnmpProperty 
{
private:

/* 
 * Qualifier Information
 */

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpQualifier *,WbemSnmpQualifier *

	> qualifierMap ;

	POSITION qualifierPosition ;

/* 
 * Property Information
 */

	BOOL m_isWritable ;
	BOOL m_isReadable ;
	BOOL m_isKey ;
	BOOL m_isVirtualKey ;
	BOOL m_IsNull ;
	BOOL tagged ;

	ULONG m_keyOrder ;
	ULONG m_TextualConvention ;

	wchar_t *propertyName ;
	SnmpInstanceType *propertyValue ;

	long m_Handle ;

protected:
public:

	WbemSnmpProperty ( const wchar_t *propertyName ) ;
	WbemSnmpProperty ( const WbemSnmpProperty &copy ) ;
	virtual ~WbemSnmpProperty () ;

	void SetTag ( BOOL tag = TRUE ) ;
	BOOL GetTag () ;

	BOOL IsKey () ;
	BOOL IsVirtualKey () ;
	BOOL IsWritable () ;
	BOOL IsReadable () ;
	ULONG GetKeyOrder () ;
	ULONG GetTextualConvention () ;
	CIMTYPE GetCimType () ;

	long GetHandle () ;

	void SetKey ( BOOL a_isKey = TRUE ) ;
	void SetKeyOrder ( ULONG a_keyOrder ) ;
	void SetVirtualKey ( BOOL a_isVirtualKey = TRUE ) ;
	void SetReadable ( BOOL a_isReadable = TRUE ) ;
	void SetWritable ( BOOL a_isWritable = TRUE ) ;
	void SetTextualConvention ( ULONG a_TextualConvention ) ;
	void SetHandle ( long a_Handle ) ;

	wchar_t *GetName () const ;

	BOOL IsNull () ;
	BOOL IsSNMPV1Type () { return propertyValue->IsSNMPV1Type () ; }
	BOOL IsSNMPV2CType () { return propertyValue->IsSNMPV2CType () ; }

	SnmpInstanceType *GetValue () const ;
	BOOL GetValue ( VARIANT &variant , CIMTYPE &type ) const ;
	VARTYPE GetValueVariantType () const ;
	VARTYPE GetValueVariantEncodedType () const ;

	BOOL SetValue ( const VARIANT &variant , const CIMTYPE &type , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const wchar_t *value , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const SnmpInstanceType *propertyValue , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetValue ( const SnmpValue *propertyValue , WbemPropertyValueCheck check = SetValueIfCheckOk  ) ;
	BOOL SetValue ( IWbemClassObject *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;

	BOOL Encode ( const VARIANT &a_EncodeValue , SnmpObjectIdentifier &a_Encode ) ;

#if 0
	BOOL SetValue ( IWbemObjectAccess *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check = SetValueIfCheckOk ) ;
	BOOL SetDWORD ( BOOL a_Status , IWbemObjectAccess *a_Object , DWORD a_Value , WbemPropertyValueCheck check ) ;
	BOOL SetNULL ( BOOL a_Status , IWbemObjectAccess *a_Object , WbemPropertyValueCheck check ) ;
	BOOL SetSTRING ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t *t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check ) ;

#endif

	ULONG GetQualifierCount () ;
	BOOL AddQualifier ( wchar_t *qualifierName ) ;
	BOOL AddQualifier ( WbemSnmpQualifier *qualifier ) ;
	void ResetQualifier () ;
	WbemSnmpQualifier *NextQualifier () ;
	WbemSnmpQualifier *FindQualifier ( wchar_t *qualifierName ) const ;

	virtual BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class __declspec ( dllexport ) WbemSnmpClassObject 
{
private:

/* 
 * Object Information
 */

	BOOL m_isClass ;
	BOOL m_isKeyed ;
	BOOL m_isSingleton ;
	BOOL m_isVirtual ;
	BOOL m_isReadable ;
	BOOL m_isWritable ;
	ULONG m_numberOfAccessible ;

	wchar_t *className ;

/*
 * Qualifier Information
 */

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpQualifier *,WbemSnmpQualifier *

	> qualifierMap ;

	POSITION qualifierPosition ;

/*
 * Property Information
 */

	SnmpList <WbemSnmpProperty *,WbemSnmpProperty *> keyedPropertyList ;

	LONG keyedPropertyPosition ;

	SnmpMap <

		wchar_t *,wchar_t *,
		WbemSnmpProperty *,WbemSnmpProperty *

	> propertyMap ;

	POSITION propertyPosition ;

private:

	BOOL SetMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL SetMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL SetMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL SetMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	BOOL  GetMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject 
	) ;

	BOOL GetMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL MergeMosClassObject ( 

		WbemSnmpErrorObject &a_errorObject , 
		IWbemClassObject *mosClassObject , 
		BOOL rigorous 
	) ;

	BOOL GetMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject 
	) ;

	BOOL GetMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	BOOL MergeMosClassObjectQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemQualifierSet *classQualifierObject 
	) ;

	BOOL MergeMosClassObjectProperties ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemClassObject *mosClassObject ,
		BOOL rigorous = TRUE
	) ;

	BOOL MergeMosClassObjectPropertyQualifiers ( 

		WbemSnmpErrorObject &a_errorObject ,
		WbemSnmpProperty *snmpProperty , 
		IWbemQualifierSet *propertyQualifierSet 
	) ;	

	void AddKeyedProperty ( WbemSnmpProperty *snmpProperty ) ;

protected:
public:

	WbemSnmpClassObject () ;
	WbemSnmpClassObject ( const WbemSnmpClassObject &copy ) ;
	WbemSnmpClassObject ( const wchar_t *className , const BOOL isClass = TRUE ) ;
	virtual ~WbemSnmpClassObject () ;

	BOOL IsReadable () ;
	void SetReadable ( BOOL a_isReadable = TRUE ) ;

	BOOL IsWritable () ;
	void SetWritable ( BOOL a_isWritable = TRUE ) ;

	BOOL IsKeyed () ;
	void SetKeyed ( BOOL a_isKeyed = TRUE ) ;

	BOOL IsVirtual () ;
	void SetVirtual ( BOOL a_isVirtual = TRUE ) ;

	BOOL IsSingleton () ;
	void SetSingleton ( BOOL a_isSingleton = TRUE ) ;

	ULONG GetNumberOfAccessible () ;
	void SetNumberOfAccessible ( ULONG m_numberOfAccessible ) ;

	void SetIsClass ( const BOOL isClass ) { m_isClass = isClass ; }

	BOOL IsClass () { return m_isClass ; }

	wchar_t *GetClassName () const ;

	ULONG GetPropertyCount () ;
	BOOL AddProperty ( wchar_t *propertyName ) ;
	BOOL AddProperty ( WbemSnmpProperty *property ) ;
	void ResetProperty () ;
	void DeleteProperty ( wchar_t *propertyName ) ;
	WbemSnmpProperty *NextProperty () ;
	WbemSnmpProperty *GetCurrentProperty () ;
	BOOL GotoProperty ( WbemSnmpProperty *property );
	

	WbemSnmpProperty *FindProperty ( wchar_t *propertyName ) const ;

	BOOL AddKeyedProperty ( wchar_t *propertyName ) ;
	ULONG GetKeyPropertyCount () ;
	void ResetKeyProperty () ;
	WbemSnmpProperty *NextKeyProperty () ;
	WbemSnmpProperty *FindKeyProperty ( wchar_t *propertyName ) const ;

	ULONG GetQualifierCount () ;
	BOOL AddQualifier ( wchar_t *qualifierName ) ;
	BOOL AddQualifier ( WbemSnmpQualifier *qualifier ) ;
	void ResetQualifier () ;
	WbemSnmpQualifier *NextQualifier () ;
	WbemSnmpQualifier *FindQualifier ( wchar_t *qualifierName ) const ;

	BOOL Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous = TRUE ) ;
	BOOL Get ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) ;
	BOOL Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous = TRUE ) ;

	virtual BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\bstring.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\classfac.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"
#include "evtcons.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif
//initialise the statics
LONG CModHandleClassFactory::locksInProgress = 0;
LONG CGroupHandleClassFactory::locksInProgress = 0;
LONG CClassHandleClassFactory::locksInProgress = 0;
LONG CNotificationClassHandleClassFactory::locksInProgress = 0;
LONG CExtNotificationClassHandleClassFactory::locksInProgress = 0;
LONG CSMIRClassFactory::locksInProgress = 0;

LONG CSMIRClassFactory::objectsInProgress = 0;
LONG CModHandleClassFactory::objectsInProgress = 0;
LONG CGroupHandleClassFactory::objectsInProgress = 0;
LONG CClassHandleClassFactory::objectsInProgress = 0;
LONG CNotificationClassHandleClassFactory::objectsInProgress = 0;
LONG CExtNotificationClassHandleClassFactory::objectsInProgress = 0;


CSMIRClassFactory :: CSMIRClassFactory (CLSID m_clsid) 
				:CSMIRGenericClassFactory(m_clsid) 
{
	bConstructed=300;
}

//***************************************************************************
//
// CSMIRClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CSMIRClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CSMIRClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CSMIRClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}
CSMIRClassFactory :: ~CSMIRClassFactory ( void ) 
{

};

//***************************************************************************
//
// CSMIRClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSMIRClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;

	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_Interrogative==riid)||
			(IID_ISMIR_Administrative==riid)||
				(IID_ISMIR_Database == riid) ||
					(IID_ISMIRWbemConfiguration == riid) ||
						(IID_ISMIR_Notify == riid)||
							(IID_IConnectionPointContainer==riid)||
								(IID_IUnknown==riid))
	{
		/*OK the interrogative, administrative and notify interfaces
		 *are contained in the smir interface so just create the smir
		 */
		try
		{
			lObj = (LPUNKNOWN)(new CSmir);
		}
		catch (...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}

//***************************************************************************
//
// CModHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CModHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CGroupHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CModHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}



//***************************************************************************
//
// CModHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CModHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_ModHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirModuleHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}

//***************************************************************************
//
// CClassHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CClassHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CGroupHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClassHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CClassHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClassHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_ClassHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirClassHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}



//***************************************************************************
//
// CGroupHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CGroupHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}

//***************************************************************************
//
// CGroupHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CGroupHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CGroupHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CGroupHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
								LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_GroupHandle==riid)||
					(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirGroupHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}

//***************************************************************************
//
// CSMIRClassFactory::CSMIRClassFactory
// CSMIRClassFactory::~CSMIRClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CSMIRGenericClassFactory :: CSMIRGenericClassFactory (CLSID iid)
{
	m_referenceCount=0;
}

CSMIRGenericClassFactory::~CSMIRGenericClassFactory ()
{
}
STDMETHODIMP_(ULONG) CSMIRGenericClassFactory :: AddRef ()
{
	/*criticalSection.Lock();
	m_referenceCount++;
	criticalSection.Unlock();
	*/
	InterlockedIncrement(&m_referenceCount);
	return m_referenceCount;
}

STDMETHODIMP_(ULONG) CSMIRGenericClassFactory :: Release ()
{
	//if ((--m_referenceCount)==0)
	long ret;
	if ((ret=InterlockedDecrement(&m_referenceCount))==0)
	{
		delete this;
		return 0;
	}
	else
	{
		return ret;
	}
}


//****************************NotificationClass stuff*****************

//***************************************************************************
//
// CNotificationClassHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CNotificationClassHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CNotificationClassHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CNotificationClassHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CNotificationClassHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CNotificationClassHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter,
								REFIID riid, LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_NotificationClassHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirNotificationClassHandle;
		}
		catch(...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}


//***************************************************************************
//
// CExtNotificationClassHandleClassFactory::QueryInterface
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CExtNotificationClassHandleClassFactory::QueryInterface (REFIID iid , PVOID FAR *iplpv) 
{
	*iplpv=NULL;

	if ((iid==IID_IUnknown)||(iid==IID_IClassFactory))
	{
		*iplpv=(LPVOID) this;
		((LPUNKNOWN)*iplpv)->AddRef();

		return ResultFromScode (S_OK);
	}

	return ResultFromScode (E_NOINTERFACE);
}
//***************************************************************************
//
// CExtNotificationClassHandleClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CExtNotificationClassHandleClassFactory :: LockServer (BOOL fLock)
{
/* 
 * Place code in critical section
 */
	if (fLock)
	{
		locksInProgress ++;
	}
	else
	{
		if(locksInProgress)
			locksInProgress --;
	}
	return S_OK;
}

//***************************************************************************
//
// CExtNotificationClassHandleClassFactory::CreateInstance
//
// Purpose: Instantiates a SMIR object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         S_OK if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CExtNotificationClassHandleClassFactory :: CreateInstance (LPUNKNOWN pUnkOuter,
								REFIID riid, LPVOID FAR * ppvObject)
{
	HRESULT status=S_OK;
	LPUNKNOWN lObj=NULL;

	*ppvObject= NULL;
	//dont support aggregation
	if (pUnkOuter)
	{
		return ResultFromScode(CLASS_E_NOAGGREGATION);
	}

	//create the correct interface
	if((IID_ISMIR_ExtNotificationClassHandle==riid)||
			(IID_IUnknown==riid))
	{
		try
		{
			lObj=(LPUNKNOWN) new CSmirExtNotificationClassHandle;
		}
		catch (...)
		{
			lObj = NULL;
		}
	}
	else
	{
		return ResultFromScode (E_NOINTERFACE);
	}

	if (NULL==lObj)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	status=lObj->QueryInterface (riid , ppvObject);
	if (FAILED (status))
	{
		delete lObj;
	}
			
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpset.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

class SetOperation : public SnmpSetOperation
{
private:

	WbemSnmpProperty **m_PropertyContainer ;
	ULONG m_PropertyContainerLength ;

	SnmpSetResponseEventObject *eventObject ;

	ULONG varBindsReceived ;
	ULONG erroredVarBindsReceived ;

	SnmpSession *session ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

public:

	SetOperation (IN SnmpSession &session , IN SnmpSetResponseEventObject *eventObject ) ;
	~SetOperation () ;

	void Send ( const ULONG &a_NumberToSend = 0xffffffff ) ;

	void DestroyOperation () { SnmpSetOperation :: DestroyOperation () ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\csmir.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define __UNICODE

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"
#include "enum.h"

#include <textdef.h>
#include <helper.h>
#include "bstring.h"
#include <scopeguard.h>
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

extern CRITICAL_SECTION g_CriticalSection ;
	

/*
 * CSmir:: Constructor and destructor
 *
 * Purpose:
 *	Standard constructor and destructor for CSmir object
 *	There should only ever be one CSmir object because it holds the 
 *	connection point object and controlls the access to the database. 
 *  When the database changes it flaggs the chamce using the conenction
 *  point object. If you have more than one CSmir object you will miss
 *  database changes. The class factory handles all of this.
 * Parameters: None
 *
 * Return Value: None
 */

#pragma warning (disable:4355)

CSmir :: CSmir ()
		:m_Interrogator(this), m_Administrator(this),
		m_Configuration(this)
{
	//init reference count
	m_cRef=0;
	//increase the reference count in the class factory
	CSMIRClassFactory::objectsInProgress++;
}

#pragma warning (default:4355)

CSmir :: ~CSmir ()
{
	//decrease the reference count in the class factory
	CSMIRClassFactory::objectsInProgress--;
}

/*
 * CSmir::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the IUnknown, 
 *  ISmirDatabase, ISmirInterrogator, and ISmirAdministrator interfaces.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmir::QueryInterface(IN REFIID riid, OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*this lock is to protect the caller from changing his own
		 *parameter (ppv) whilst I am using it. This is unlikely and
		 *he deserves what he gets if he does it but it is still worth 
		 *the effort.
		 */
		criticalSection.Lock () ;
		//Always NULL the out-parameters
		*ppv=NULL;

		/*
		 * IUnknown comes from CSmir.  Note that here we do not need
		 * to explicitly typecast the object pointer into an interface
		 * pointer because the vtables are identical.  If we had
		 * additional virtual member functions in the object, we would
		 * have to cast in order to set the right vtable.  
		 */

		/*CLSID_ISMIR_Database serves very little purpose but it does provide
		 *an entry point from which you can ittetate the other interfaces; it
		 *makes sense to create an CLSID_ISMIR_Database instance and move to the 
		 *other interfaces rather than picking one of the other interfaces as the
		 *entry point.
		 */

		if ((IID_IUnknown==riid)||(IID_ISMIR_Database == riid))
			*ppv=this;

		//Other interfaces come from contained classes
		if (IID_ISMIR_Interrogative==riid)
			*ppv=&m_Interrogator;

		if (IID_ISMIR_Administrative==riid)
			*ppv=&m_Administrator;

		if((IID_IConnectionPointContainer == riid)||(IID_ISMIR_Notify == riid))
			*ppv = sm_ConnectionObjects;

		if(IID_ISMIRWbemConfiguration == riid)
			*ppv = &m_Configuration;

		if (NULL==*ppv)
		{
			criticalSection.Unlock () ;
			return E_NOINTERFACE;
		}

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		criticalSection.Unlock () ;
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmir ::AddRef
 * CSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmir::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*The CSmir object is a shared resource (as long as there is at leasr 
		 *one connection object) so I must protect the reference count.
		 */
		//increase the reference
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmir::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
		{
			return ret;
		}

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

/*
 * CSmir::AddNotify
 * CSmir::DeleteNotify
 *
 * Purpose:
 *	These methods provide the hooks into the notification interface.
 *	The caller implements the ISMIRNotify and passes ti to AddNotify, AddNotify
 *	marshals the connection point interface and calls Advise to add the 
 *	callers ISMIRNotify to the collection of objects to notify when the SMIR
 *	changes. DeleteNotify does the opposite.
 *
 * Parameters:
 *  pNotifySink       The caller's ISMIRNotify implementation
 *  pRichTea,lRichTea Cookie used to identify the caller's 
 *					  ISMIRNotify (generated by CSmir)
 *
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure, E_NOINTERFACE if the
 *                  interface is not supported, E_INVALIDARG if the parameters
 *					are invalid
 */

STDMETHODIMP CSmir :: AddNotify(IN ISMIRNotify *pNotifySink, OUT DWORD *pRichTea)
{
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection ( & g_CriticalSection );
		ScopeGuard t_1 = MakeGuard ( LeaveCriticalSection , &g_CriticalSection ) ;

		if (sm_ConnectionObjects == NULL)
		{
			sm_ConnectionObjects = new CSmirConnObject(this);
			sm_ConnectionObjects->AddRef ();
		}

		t_1.Dismiss () ;
		LeaveCriticalSection ( & g_CriticalSection );

		/*make sure that I don't get deleted whilst doing this. I should not have
		 *to do this since it can only happen if the caller releases the interface 
		 *whilst making the call.
		 */
		if (NULL == pNotifySink)
		{
			return WBEM_E_FAILED;
		}
		/*I do not need a lock for this piece of code; having found the interface someone
		 *could release it from beneath me but the FindConnectionPoint causes an addref
		 *so I can rely on m_ConnectionObjects to keep his own house in order.
		 */
		IConnectionPoint *pCP = NULL ;
		SCODE hr = sm_ConnectionObjects->FindConnectionPoint(IID_ISMIR_Notify, &pCP);

		if ((S_OK != hr)||(NULL == pCP))
		{
			return WBEM_E_FAILED;
		}

		hr = ((CSmirNotifyCP*)(pCP))->Advise(this, pNotifySink, pRichTea);
		pCP->Release();
		if (S_OK != hr)
		{
			return WBEM_E_FAILED;
		}

		return ((S_OK == hr)?S_OK:WBEM_E_FAILED);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDMETHODIMP CSmir :: DeleteNotify(IN DWORD lRichTea)
{
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection ( & g_CriticalSection ) ;
		ScopeGuard t_1 = MakeGuard ( LeaveCriticalSection , &g_CriticalSection ) ;

		if (sm_ConnectionObjects == NULL)
		{
			return WBEM_E_FAILED;
		}

		t_1.Dismiss () ;
		LeaveCriticalSection ( & g_CriticalSection );

		/*I don't need to lock the SMIR object until the unadvise but it 
		 *is safer and future proof if I do it here.
		 */
		SCODE hr=S_OK;
		/*I do not need a lock for this piece of code; having found the interface someone
		 *could release it from beneath me but the FindConnectionPoint causes an addref
		 *so I can rely on m_ConnectionObjects to keep his own house in order.
		 */
		IConnectionPoint *pCP = NULL;
		hr=sm_ConnectionObjects->FindConnectionPoint(IID_ISMIR_Notify, &pCP);

		if (hr != S_OK||(NULL == pCP))
		{
			return  CONNECT_E_NOCONNECTION;
		}

		hr=((CSmirNotifyCP*)(pCP))->Unadvise(this, lRichTea);
		pCP->Release();

		return ((S_OK == hr)?S_OK:CONNECT_E_NOCONNECTION==hr?E_INVALIDARG:WBEM_E_FAILED);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


/*CSmirInterrogator interface implementation
 * Constructor/destructor
 * CSmirInterrogator::QueryInterface
 * CSmirInterrogator::AddRef
 * CSmirInterrogator::Release
 *
 * IUnknown members that delegate to m_pSmir
 */

CSmirInterrogator :: CSmirInterrogator ( CSmir *pSmir ) : m_cRef ( 1 ) , m_pSmir ( pSmir ) 
{
}

STDMETHODIMP CSmirInterrogator::QueryInterface(IN REFIID riid, OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return m_pSmir->QueryInterface(riid, ppv);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirInterrogator::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * We maintain an "interface reference count" for debugging
		 * purposes, because the client of an object should match
		 * AddRef and Release calls through each interface pointer.
		 */
		++m_cRef;
		return m_pSmir->AddRef();
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirInterrogator::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * m_cRef is again only for debugging.  It doesn't affect
		 * CSmirInterrogator although the call to m_pSmir->Release does.
		 */
		--m_cRef;
		return m_pSmir->Release();
		//do not do anything after this release because you may have been deleted
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}


/* Interface implementations for the enumerator access methods
 *
 * CSmirInterrogator::EnumModules
 * CSmirInterrogator::EnumGroups
 * CSmirInterrogator::EnumClasses
 *
 * Parameters:
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 *
 */

SCODE CSmirInterrogator::EnumModules(OUT IEnumModule **ppEnumSmirMod)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppEnumSmirMod)
			return E_INVALIDARG;
		PENUMSMIRMOD pTmpEnumSmirMod = new CEnumSmirMod ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirMod)
		{
			return E_OUTOFMEMORY;
		}

		pTmpEnumSmirMod->QueryInterface(IID_ISMIR_ModuleEnumerator,(void**)ppEnumSmirMod);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator:: EnumGroups (OUT IEnumGroup **ppEnumSmirGroup, 
											IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirGroup)
			return E_INVALIDARG;
		PENUMSMIRGROUP pTmpEnumSmirGroup = new CEnumSmirGroup( m_pSmir , hModule);
		if(NULL == pTmpEnumSmirGroup)
		{
			return E_OUTOFMEMORY;
		}
		//we have an enumerator so  get the interface to pass back
		pTmpEnumSmirGroup->QueryInterface(IID_ISMIR_GroupEnumerator,(void**)ppEnumSmirGroup);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumAllClasses (OUT IEnumClass **ppEnumSmirclass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;

		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumClassesInGroup (OUT IEnumClass **ppEnumSmirclass, 
										 IN ISmirGroupHandle *hGroup)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass(m_pSmir , NULL,hGroup);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumClassesInModule (OUT IEnumClass **ppEnumSmirclass, 
										 IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass(m_pSmir , NULL, hModule);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppEnumSmirclass);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: GetWBEMClass(OUT IWbemClassObject **ppClass, IN BSTR pszClassName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if((NULL == pszClassName)||(NULL == ppClass))
			return E_INVALIDARG;

		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE res= CSmirAccess :: GetContext (m_pSmir , &moContext);
		res= CSmirAccess :: Open(m_pSmir , &moServ);

		if ((S_FALSE==res)||(NULL == (void*)moServ))
		{
			if ( moContext )
				moContext->Release () ;

			//we have a problem the SMIR is not there and cannot be created
			return WBEM_E_FAILED;
		}

		CBString t_BStr ( pszClassName ) ;
		res = moServ->GetObject(t_BStr.GetString (),RESERVED_WBEM_FLAG, moContext,ppClass,NULL);
		if ( moContext )
			moContext->Release () ;
		moServ->Release();
		if ((S_FALSE==res)||(NULL == *ppClass))
		{
			return WBEM_E_FAILED;
		}
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumAllNotificationClasses(IEnumNotificationClass **ppEnumSmirclass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;

		PENUMNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumNotificationClass ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumNotificationClass,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumAllExtNotificationClasses(IEnumExtNotificationClass **ppEnumSmirclass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;

		PENUMEXTNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumExtNotificationClass ( m_pSmir ) ;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumExtNotificationClass,(void**)ppEnumSmirclass);
		
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumNotificationClassesInModule(IEnumNotificationClass **ppEnumSmirclass,
														   ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumNotificationClass( m_pSmir , NULL, hModule);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumNotificationClass,(void**)ppEnumSmirclass);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirInterrogator :: EnumExtNotificationClassesInModule(IEnumExtNotificationClass **ppEnumSmirclass,
															  ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppEnumSmirclass)
			return E_INVALIDARG;
		PENUMEXTNOTIFICATIONCLASS pTmpEnumSmirClass = new CEnumExtNotificationClass( m_pSmir , NULL, hModule);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return E_OUTOFMEMORY;
		}
		pTmpEnumSmirClass->QueryInterface(IID_ISMIR_EnumExtNotificationClass,(void**)ppEnumSmirclass);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirAdministrator::QueryInterface
 * CSmirAdministrator::AddRef
 * CSmirAdministrator::Release
 *
 * IUnknown members that delegate to m_pSmir
 */

CSmirAdministrator :: CSmirAdministrator ( CSmir *pSmir ) : m_cRef ( 1 ) , m_pSmir ( pSmir ) 
{
}

STDMETHODIMP CSmirAdministrator::QueryInterface(IN REFIID riid,
												OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return m_pSmir->QueryInterface(riid, ppv);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirAdministrator::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * We maintain an "interface reference count" for debugging
		 * purposes, because the client of an object should match
		 * AddRef and Release calls through each interface pointer.
		 */
		++m_cRef;
		return m_pSmir->AddRef();
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirAdministrator::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		/*
		 * m_cRef is again only for debugging.  It doesn't affect
		 * CObject2 although the call to m_pObj->Release does.
		 */
		--m_cRef;
		return m_pSmir->Release();
		//do not do anything after this release because you may have been deleted
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

SCODE CSmirAdministrator :: GetSerialiseHandle(ISmirSerialiseHandle **hSerialise,BOOL bClassDefinitionsOnly)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise)
		{
			return E_INVALIDARG;
		}
		CSmirSerialiseHandle *pSerialise = new CSmirSerialiseHandle(bClassDefinitionsOnly);
		//we have an enumerator so  get the interface to pass back
		if(NULL == pSerialise)
		{
			return E_OUTOFMEMORY;
		}

		pSerialise->QueryInterface(IID_ISMIR_SerialiseHandle,(void**)hSerialise);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirAdministrator::AddModule
 * Purpose:			Creates the module namespace in the SMIR
 * Parameters:
 *	ISmirModHandle*	A module handle interface obtained through ISmirModHandle and
 *					filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: AddModuleToSerialise(ISmirModHandle *hModule,
												ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hModule)
		{
			return E_INVALIDARG;
		}
		if((*((CSmirModuleHandle*)hModule))!=NULL)
		{
			*((CSmirModuleHandle*)hModule)>>hSerialise;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddClassToSerialise(ISmirGroupHandle  *hGroup, 
												ISmirClassHandle *hClass,
												ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hClass || NULL == hGroup)
		{
			return E_INVALIDARG;
		}
		BSTR szGroupName=NULL;
		BSTR szModuleName=NULL;
		hGroup->GetName(&szGroupName);
		hGroup->GetModuleName(&szModuleName);

		hClass->SetGroupName(szGroupName);
		hClass->SetModuleName(szModuleName);

		SysFreeString(szModuleName);
		SysFreeString(szGroupName);

		if(*((CSmirClassHandle*)hClass)!=NULL )
		{
			//it is a valid handle so serialise it
			*((CSmirClassHandle*)hClass)>>hSerialise;
			return S_OK;
		}
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddGroupToSerialise(ISmirModHandle *hModule, 
												ISmirGroupHandle  *hGroup,
												ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hGroup|| NULL == hModule)
		{
			return E_INVALIDARG;
		}
		BSTR szModuleName=NULL;
		
		hModule->GetName(&szModuleName);
		
		hGroup->SetModuleName(szModuleName);
		//clean up
		SysFreeString(szModuleName);

		if(*((CSmirGroupHandle*)hGroup)!=NULL)
		{
			//do the serialise
			*((CSmirGroupHandle*)hGroup)>>hSerialise;
			return S_OK;
		}

		//either the modfule or group name were not set so it is an error
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddModule(IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == hModule)
		{
			return E_INVALIDARG;
		}
		if(S_OK==((CSmirModuleHandle*)hModule)->AddToDB(m_pSmir))
		{
			//notify people of the change
			return S_OK ;
		}
		return WBEM_E_FAILED ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
/*
 * CSmirAdministrator::DeleteModule
 * Purpose:			Delete the module namespace from the SMIR
 * Parameters:
 *	ISmirModHandle*	A module handle interface obtained through ISmirModHandle and
 *					filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: DeleteModule(IN ISmirModHandle *hModule)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the arguments
		if(NULL == hModule)
		{
			return E_INVALIDARG;
		}
		if(S_OK==((CSmirModuleHandle *)hModule)->DeleteFromDB(m_pSmir))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
/*
 * CSmirAdministrator::DeleteAllModules
 * Purpose:			Delete the SMIR
 * Parameters:
 *	ISmirModHandle*	A module handle interface obtained through ISmirModHandle and
 *					filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: DeleteAllModules()
{
	SetStructuredExceptionHandler seh;

	try
	{
		//enumerate all modules and delete them...
		IEnumModule *pEnumSmirMod = NULL;
		SCODE result = m_pSmir->m_Interrogator.EnumModules(&pEnumSmirMod);
		
		if((S_OK != result)||(NULL == pEnumSmirMod))
		{
			//no modules
			return WBEM_NO_ERROR;
		}

		ISmirModHandle *phModule = NULL ;

		for(int iCount=0;S_OK==pEnumSmirMod->Next(1, &phModule, NULL);iCount++)
		{
			//we have the module so delete it...
			if (FAILED(DeleteModule(phModule)))
			{
				result = WBEM_E_FAILED;
			}

			phModule->Release();
		}

		pEnumSmirMod->Release();
		return result;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirAdministrator::AddGroup
 * Purpose:			Delete the group namespace from the SMIR
 * Parameters:
 *	ISmirModHandle*		A module handle interface
 *	ISmirGroupHandle*	A group handle interface obtained through ISmirModHandle and
 *					    filled in by the called
 * Return Value:
 *  SCODE         S_OK on success, WBEM_E_FAILED of failure
 */

SCODE CSmirAdministrator :: AddGroup(IN ISmirModHandle *hModule, 
									 IN ISmirGroupHandle *hGroup)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the args
		if((NULL == hModule)||(NULL == hGroup))
		{
			//MyTraceEvent.Generate(__FILE__,__LINE__, "E_INVALIDARG");
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirGroupHandle *)hGroup)->AddToDB(m_pSmir,hModule))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: DeleteGroup(IN ISmirGroupHandle *hGroup)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//fill in the path etc
		if(NULL ==hGroup)
		{
			return E_INVALIDARG;
		}
			
		if ( FAILED( ((CSmirGroupHandle*)hGroup)->DeleteFromDB(m_pSmir) ) )
		{
			return WBEM_E_FAILED;
		}
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddClass(IN ISmirGroupHandle *hGroup, 
									 IN ISmirClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hGroup)||(NULL == hClass)||
				(NULL == ((CSmirClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirClassHandle*)hClass)->AddToDB(m_pSmir,hGroup))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: DeleteClass(IN ISmirClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hClass)||(NULL == ((CSmirClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		//Let the class do it's own work
		((CSmirClassHandle*)hClass)->DeleteFromDB( m_pSmir);
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddNotificationClass(ISmirNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameter
		if((NULL == hClass) ||
			((CSmirNotificationClassHandle*)NULL == *((CSmirNotificationClassHandle*)hClass)))

		{
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirNotificationClassHandle*)hClass)->AddToDB(m_pSmir))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
		//release the handles via the garbage collector
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddExtNotificationClass(ISmirExtNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameter
		if((NULL == hClass)	|| 
			((CSmirExtNotificationClassHandle*)NULL == *((CSmirExtNotificationClassHandle*)hClass)))
		{
			return E_INVALIDARG;
		}

		if(S_OK==((CSmirExtNotificationClassHandle*)hClass)->AddToDB(m_pSmir))
		{
			return S_OK;
		}
		return WBEM_E_FAILED;
		//release the handles via the garbage collector
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CSmirAdministrator :: DeleteNotificationClass(ISmirNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hClass)||(NULL == ((CSmirNotificationClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		//Let the class do it's own work
		((CSmirNotificationClassHandle*)hClass)->DeleteFromDB(m_pSmir);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: DeleteExtNotificationClass(ISmirExtNotificationClassHandle *hClass)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//check the parameters
		if((NULL == hClass)||(NULL == ((CSmirExtNotificationClassHandle*)hClass)->m_pIMosClass))
		{
			return E_INVALIDARG;
		}

		//Let the class do it's own work
		((CSmirExtNotificationClassHandle*)hClass)->DeleteFromDB(m_pSmir);

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddNotificationClassToSerialise(ISmirNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hClass)
		{
			return E_INVALIDARG;
		}
		if(*((CSmirNotificationClassHandle*)hClass) !=NULL )
		{
			//it is a valid handle so serialise it
			*((CSmirNotificationClassHandle*)hClass)>>hSerialise;
			return S_OK;
		}
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: AddExtNotificationClassToSerialise(ISmirExtNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL ==hSerialise || NULL == hClass)
		{
			return E_INVALIDARG;
		}
		if(*((CSmirExtNotificationClassHandle*)hClass) !=NULL )
		{
			//it is a valid handle so serialise it
			*((CSmirExtNotificationClassHandle*)hClass)>>hSerialise;
			return S_OK;
		}
		return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: CreateWBEMClass(

	BSTR pszClassName, 
	ISmirClassHandle **pHandle
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pHandle) 
			return E_INVALIDARG;

		*pHandle = NULL ;

		//open the smir name space
		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE result= CSmirAccess :: GetContext (m_pSmir, &moContext);
		result= CSmirAccess :: Open(m_pSmir,&moServ);
		if(FAILED(result)||(NULL == moServ))
		{
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED ;
		}

		IWbemClassObject *baseClass = NULL ;
		//OK we have the namespace so create the class
		CBString t_BStr ( HMOM_SNMPOBJECTTYPE_STRING ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,
									moContext,&baseClass,NULL);

		//finished with this
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		if (FAILED(result)||(NULL==baseClass))
		{
			return WBEM_E_FAILED;
		}

		IWbemClassObject *t_MosClass = NULL ;

		result = baseClass->SpawnDerivedClass (0 , &t_MosClass);
		baseClass->Release () ;

		if ( ! SUCCEEDED ( result ) )
		{
			return WBEM_E_FAILED;
		}

		//name the class __CLASS Class

		VARIANT v;
		VariantInit(&v);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(pszClassName);

		result = t_MosClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		ISmirClassHandle *classHandle = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_ClassHandle , 
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_ClassHandle,
			(PPVOID)&classHandle
		);

		if ( SUCCEEDED ( result ) )
		{
			classHandle->SetWBEMClass ( t_MosClass ) ;
			*pHandle = classHandle ;
			t_MosClass->Release();
		}
		else
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		return S_OK ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: CreateWBEMNotificationClass(

	BSTR pszClassName,
	ISmirNotificationClassHandle **pHandle
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pHandle) 
			return E_INVALIDARG;

		*pHandle = NULL ;

		//open the smir name space
		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE result= CSmirAccess :: GetContext (m_pSmir , &moContext);
		result= CSmirAccess :: Open(m_pSmir, &moServ);
		if(FAILED(result)||(NULL == moServ))
		{
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED ;
		}

		IWbemClassObject *baseClass = NULL ;
		//OK we have the namespace so create the class
		CBString t_BStr ( NOTIFICATION_CLASS_NAME ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,
									moContext,&baseClass, NULL);

		//finished with this

		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		if (FAILED(result)||(NULL==baseClass))
		{
			return WBEM_E_FAILED;
		}

		IWbemClassObject *t_MosClass = NULL ;
		result = baseClass->SpawnDerivedClass (0 , &t_MosClass);
		baseClass->Release () ;

		if ( ! SUCCEEDED ( result ) )
		{
			return WBEM_E_FAILED;
		}

		//name the class __CLASS Class

		VARIANT v;
		VariantInit(&v);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(pszClassName);

		result = t_MosClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		ISmirNotificationClassHandle *classHandle = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_NotificationClassHandle , 
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_NotificationClassHandle,
			(PPVOID)&classHandle
		);

		if ( SUCCEEDED ( result ) )
		{
			classHandle->SetWBEMNotificationClass ( t_MosClass ) ;
			t_MosClass->Release();
			*pHandle = classHandle ;
		}
		else
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirAdministrator :: CreateWBEMExtNotificationClass (

	BSTR pszClassName,
	ISmirExtNotificationClassHandle **pHandle
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pHandle) 
			return E_INVALIDARG;

		*pHandle = NULL ;

		//open the smir name space
		IWbemServices *	moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE result= CSmirAccess :: GetContext (m_pSmir , &moContext);
		result= CSmirAccess :: Open(m_pSmir ,&moServ);
		if(FAILED(result)||(NULL == moServ))
		{
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED ;
		}

		IWbemClassObject *baseClass = NULL ;
		//OK we have the namespace so create the class
		CBString t_BStr ( HMOM_SNMPEXTNOTIFICATIONTYPE_STRING ) ;
		result = moServ->GetObject(t_BStr.GetString () , RESERVED_WBEM_FLAG,
									moContext,&baseClass, NULL);

		//finished with this

		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		if (FAILED(result)||(NULL==baseClass))
		{
			return WBEM_E_FAILED;
		}

		IWbemClassObject *t_MosClass = NULL ;

		result = baseClass->SpawnDerivedClass (0 , &t_MosClass );
		baseClass->Release () ;

		if ( ! SUCCEEDED ( result ) )
		{
			return WBEM_E_FAILED;
		}

		//name the class __CLASS Class

		VARIANT v;
		VariantInit(&v);

		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(pszClassName);

		result = t_MosClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		ISmirExtNotificationClassHandle *classHandle = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_ExtNotificationClassHandle , 
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_ExtNotificationClassHandle,
			(PPVOID)&classHandle
		);

		if ( SUCCEEDED ( result ) )
		{
			classHandle->SetWBEMExtNotificationClass ( t_MosClass ) ;
			t_MosClass->Release();
			*pHandle = classHandle ;
		}
		else
		{
			t_MosClass->Release();
			return WBEM_E_FAILED;
		}

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirSerialiseHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirSerialiseHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_SerialiseHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}



/*
 * CSmirSerialiseHandle::AddRef
 * CSmirSerialiseHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirSerialiseHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirSerialiseHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirSerialiseHandle :: CSmirSerialiseHandle(BOOL bClassDefinitionsOnly)
{
	m_cRef=0;
	//I have two variables so that I can expand this at a later date
	m_bMOFPragmas = m_bMOFAssociations = !bClassDefinitionsOnly;

	m_serialiseString=QUALIFIER_PROPAGATION;

	//start in the root\default namespace
	if (TRUE == m_bMOFPragmas)
		m_serialiseString+=CString(ROOT_DEFAULT_NAMESPACE_PRAGMA);
	/**************************************************************************
	 *	        		create the SMIR namespace class
	 **************************************************************************/
	if(TRUE == m_bMOFAssociations)
	{
		/******************then create an instance*********************************/

		m_serialiseString+=SMIR_CLASS_DEFINITION;
		m_serialiseString+=SMIR_INSTANCE_DEFINITION;
	}
	//go to the SMIR namespace
	if (TRUE == m_bMOFPragmas)
		m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);


	/******************create the SnmpMacro class******************************/

	m_serialiseString+=SNMPMACRO_CLASS_START;
	//end the class definition
	m_serialiseString+=END_OF_CLASS;

	/******************create the SnmpObjectType class*************************/

	m_serialiseString+=SNMPOBJECTTYPE_CLASS_START;
	//end the class definition
	m_serialiseString+=END_OF_CLASS;

	/******************create the SnmpNotifyStatus class*************************/

	m_serialiseString+=SNMPNOTIFYSTATUS_CLASS_START;
	//end the class definition
	m_serialiseString+=END_OF_CLASS;
	
	/****************if asked for, create the SMIR specific stuff****************/
	if(TRUE == m_bMOFAssociations)
	{
		/******************create the SnmpNotification class*********************/

		m_serialiseString+=SNMPNOTIFICATION_CLASS_START;
		
		//add the properties
		m_serialiseString+=TIMESTAMP_QUALS_TYPE;
		m_serialiseString+=CString(TIMESTAMP_PROP);
		m_serialiseString+=END_OF_PROPERTY;
		
		m_serialiseString+=TRAPOID_QUALS_TYPE;
		m_serialiseString+=CString(TRAPOID_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_ADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_ADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_TADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_TADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=TRANSPORT_QUALS_TYPE;
		m_serialiseString+=CString(TRANSPORT_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=COMMUNITY_QUALS_TYPE;
		m_serialiseString+=CString(COMMUNITY_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;


		/******************create the SnmpExtendedNotification class*************/
		
		m_serialiseString+=SNMPEXTNOTIFICATION_CLASS_START;

		//add the properties
		m_serialiseString+=TIMESTAMP_QUALS_TYPE;
		m_serialiseString+=CString(TIMESTAMP_PROP);
		m_serialiseString+=END_OF_PROPERTY;
		
		m_serialiseString+=TRAPOID_QUALS_TYPE;
		m_serialiseString+=CString(TRAPOID_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_ADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_ADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=SENDER_TADDR_QUALS_TYPE;
		m_serialiseString+=CString(SENDER_TADDR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=TRANSPORT_QUALS_TYPE;
		m_serialiseString+=CString(TRANSPORT_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=COMMUNITY_QUALS_TYPE;
		m_serialiseString+=CString(COMMUNITY_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;

		/******************create the NotificationMapper class*********************/

		m_serialiseString+=NOTIFICATIONMAPPER_CLASS_START;

		//add the two properies..
		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;

		/******************create the ExtendedNotificationMapper class*************/

		m_serialiseString+=EXTNOTIFICATIONMAPPER_CLASS_START;

		//add the two properies..
		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;


		/******************create the module class*****************************/

		m_serialiseString+=MODULE_CLASS_START;
		//add the properties

		//give the instance a name
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_NAME_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;

		//add the module oid property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_OID_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the module identity
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_ID_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the organisation property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_ORG_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;

		//add the contact info property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_CONTACT_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the Description property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_DESCRIPTION_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the revision property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_REVISION_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the last update property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_LAST_UPDATE_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the snmp version property
		m_serialiseString+=READONLY_LONG;
		m_serialiseString+=CString(MODULE_SNMP_VERSION_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;
		
		//add the module imports as an property
		m_serialiseString+=READONLY_STRING;
		m_serialiseString+=CString(MODULE_IMPORTS_PROPERTY);
		m_serialiseString+=END_OF_PROPERTY;

		//end the class definition
		m_serialiseString+=END_OF_CLASS;

#if 0
		//each module will create it's own instance
		/**************************************************************************
		 *	        		create the SMIR Associator class
         *[assoc]
		 *class SmirToClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] ClassName;
		 *[read] SmirName;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_ASSOC_CLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_ASSOC_SMIR_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

#endif

		/**************************************************************************
		 *	        		create the Module Associator class
         *[assoc]
		 *class SmirToClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] ClassName;
		 *[read] SmirName;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;
		/**************************************************************************
		 *	        		create the Group Associator class
         *[assoc]
		 *class SmirToClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] ClassName;
		 *[read] SmirName;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_GROUP_ASSOC_CLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_GROUP_ASSOC_GROUP_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

		/**************************************************************************
		 *	        		create the Notification/Module Associator class
         *[assoc]
		 *class ModToNotificationClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] SmirClass;
		 *[read] SmirModule;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_NCLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

		/**************************************************************************
		 *	        	create the ExtNotification/Module Associator class
         *[assoc]
		 *class ModToExtNotificationClassAssociator
		 *{
		 *[read, key] AssocName;
		 *[read] SmirClass;
		 *[read] SmirModule;
		 *};
		 *
		 **************************************************************************/

		m_serialiseString+=ASSOC_QUALIFIER;
		m_serialiseString+=CString(CLASS_STRING);
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_EXTNCLASS_NAME);
		m_serialiseString+=CString(NEWLINE_STR);
		m_serialiseString+=CString(OPEN_BRACE_STR);
		m_serialiseString+=CString(NEWLINE_STR);

		m_serialiseString+=READ_ONLY_KEY_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_NAME_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_X_ASSOC_CLASS_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=READ_ONLY_REF_STRING;
		m_serialiseString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
		m_serialiseString+=END_OF_PROPERTY;

		m_serialiseString+=END_OF_CLASS;

	}
}

SCODE CSmirSerialiseHandle :: GetText(BSTR *pszText)
{
	SetStructuredExceptionHandler seh;

	try
	{
		*pszText  = m_serialiseString.AllocSysString();

		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CSmirWbemConfiguration :: CSmirWbemConfiguration ( CSmir *a_Smir ) : 

	m_Smir ( a_Smir ) ,
	m_ReferenceCount ( 1 ) ,
	m_Context ( NULL ) ,
	m_Service ( NULL ) 
{
    InterlockedIncrement ( & CSMIRClassFactory::objectsInProgress ) ;
}

CSmirWbemConfiguration :: ~CSmirWbemConfiguration ()
{
	InterlockedDecrement ( & CSMIRClassFactory :: objectsInProgress ) ;

	if ( m_Context )
		m_Context->Release () ;

	if ( m_Service )
		m_Service->Release () ;
}

HRESULT CSmirWbemConfiguration :: QueryInterface(IN REFIID iid,OUT PPVOID iplpv)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return m_Smir->QueryInterface(iid, iplpv);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirWbemConfiguration :: AddRef()
{
	SetStructuredExceptionHandler seh;

	try
	{
		InterlockedIncrement ( & m_ReferenceCount ) ; 
		return m_Smir->AddRef () ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirWbemConfiguration :: Release()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
		}
		return m_Smir->Release () ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

HRESULT CSmirWbemConfiguration :: Authenticate (

	BSTR Server,
	BSTR User,
    BSTR Password,
    BSTR Locale,
    long lSecurityFlags,                 
    BSTR Authority ,
	BOOL InProc
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		IWbemLocator *t_Locator = NULL ;


		HRESULT t_Result = CoCreateInstance (

			CLSID_WbemLocator ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_IUnknown ,
			( void ** ) & t_Locator
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_Unknown = NULL ;

			if ( Server )
			{
				CString t_BStr = CString ( BACKSLASH_STR ) ;
				t_BStr += CString ( BACKSLASH_STR ) ;
				t_BStr += CString ( Server ) ;
				t_BStr += CString ( BACKSLASH_STR ) ;
				t_BStr += CString ( SMIR_NAMESPACE ) ;

				BSTR t_Str = SysAllocString ( t_BStr.GetBuffer ( 0 ) ) ;

				t_Result = t_Locator->ConnectServer (

					t_Str ,
					Password,				// Password
					User,					// User
					Locale,					// Locale id
					lSecurityFlags,			// Flags
					Authority,				// Authority
					NULL,					// Context
					&t_Unknown 
				);

				SysFreeString ( t_Str ) ;
			}
			else
			{
				CString t_BStr = CString ( SMIR_NAMESPACE ) ;
				LPCTSTR t_Str = SysAllocString ( t_BStr.GetBuffer ( 0 ) ) ;

				t_Result = t_Locator->ConnectServer (

					t_Str ,
					Password,				// Password
					User,					// User
					Locale,					// Locale id
					lSecurityFlags,			// Flags
					Authority,				// Authority
					NULL,					// Context
					&t_Unknown 
				);

				SysFreeString ( t_Str ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Service )
				{
					m_Service->Release () ;
				}

				t_Result = t_Unknown->QueryInterface (

					IID_IWbemServices ,
					( void **) & m_Service
				) ;

				t_Unknown->Release () ;
			}

			t_Locator->Release () ;
		}

		return t_Result ;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}


HRESULT CSmirWbemConfiguration :: Impersonate ( ISMIRWbemConfiguration *a_Configuration )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( m_Context ) 
			m_Context->Release () ;

		if ( m_Service )
			m_Service->Release () ;

		CSmirWbemConfiguration *t_Configuration = ( CSmirWbemConfiguration * ) a_Configuration ;

		m_Context = t_Configuration->m_Context ;
		m_Service = t_Configuration->m_Service ;

		if ( m_Context ) 
			m_Context->AddRef () ;

		if ( m_Service )
			m_Service->AddRef () ;

		return S_OK ;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemConfiguration :: SetContext ( IWbemContext *a_Context )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( m_Context )
		{
			m_Context->Release () ;
		}

		m_Context = a_Context ;

		if ( m_Context )
		{
			m_Context->AddRef () ;
		}

		return S_OK ;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemConfiguration :: GetContext ( IWbemContext **a_Context )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( a_Context && m_Context )
		{
			m_Context->AddRef () ;

			*a_Context = m_Context ;
			return S_OK ;
		}
		else
		{
			if (a_Context)
			{
				*a_Context = NULL ;
			}

			return WBEM_E_FAILED ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemConfiguration :: GetServices ( IWbemServices **a_Service )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( a_Service && m_Service )
		{
			m_Service->AddRef () ;
			*a_Service = m_Service ;
			return S_OK ;
		}
		else
		{
			*a_Service = NULL ;
			return WBEM_E_FAILED ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\enum.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include "enum.h"
#include "textdef.h"
#include "helper.h"
#include "bstring.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

CEnumSmirMod :: CEnumSmirMod( CSmir *a_Smir )
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir - create it if you can't open it
	IWbemServices * moServ = NULL ;	
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem
		if ( moContext )
			moContext->Release () ;
		return;
	}

	//I have now opened the smir namespace so look at the module namespaces
	IEnumWbemClassObject *pEnum = NULL ;

	//enumerate all of the namespaces that have a __CLASS of MODULE
	CBString t_BStr (MODULE_NAMESPACE_NAME);
	SCODE sRes = moServ->CreateInstanceEnum(t_BStr.GetString (), 
			RESERVED_WBEM_FLAG,moContext, &pEnum);

	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//we have another problem or we have no modules to enumerate
		return;
	}

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned;

	//OK we have some so loop over the namespaces
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirModHandle *pTModule = NULL ;

		SCODE result = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ModHandle,
									IID_ISMIR_ModHandle,(PVOID *)&pTModule);

		if (FAILED(result)||(NULL == pTModule))
		{
			//problem!
			pSmirMosClassObject->Release();
			pEnum->Release();
			//add some trace
			break;
		}

		/*things are looking good; we have the handle to the instance so get the info
		 *some of there properties may be blank so be defensive (SysAllocStrig does 
		 *most of this for us)
		 */
		
		//extract the properties		
		*((CSmirModuleHandle*)pTModule) << pSmirMosClassObject;

		pSmirMosClassObject->Release();
		pSmirMosClassObject=NULL;
		m_IHandleArray.Add(pTModule);		
	}

	pEnum->Release();
	/*as soon as this returns the caller (me) will addref and pass the 
	 *interface back to the [real] caller. => I will have to guard against
	 *someone releasing the interface whilst I'm using it.
	 */
}

CEnumSmirMod :: CEnumSmirMod(IEnumModule *pSmirMod)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	if (NULL == pSmirMod)
	{
		return;
	}

	ULONG uCount=1; 
    ISmirModHandle *pModule = NULL ;
    ULONG puReturned = 0;

	//OK loop over the module namespaces
	
	for(pSmirMod->Reset();S_OK==pSmirMod->Next(uCount,&pModule,&puReturned);)
	{
		ISmirModHandle *pTModule = NULL ;
		SCODE result = pModule->QueryInterface(IID_ISMIR_ModHandle,(void**)&pTModule );
		pModule->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to the array
		 */
		m_IHandleArray.Add(pTModule);		
	}
}

CEnumSmirMod :: ~CEnumSmirMod ()
{
	/*let the EnumObjectArray empty the module array and delete the 
	 *modules I created
	 */
}
/*
 * CEnumSmirMod::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumSmirMod::QueryInterface(IN REFIID riid, 
										  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ModuleEnumerator==riid)
			*ppv=this;

		if (NULL==*ppv)
		{
			return ResultFromScode(E_NOINTERFACE);
		}
		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CEnumSmirMod::Clone(IN IEnumModule  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ModIndex = m_Index;
		PENUMSMIRMOD pTmpEnumSmirMod = new CEnumSmirMod(this);
		m_Index = ModIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirMod)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		pTmpEnumSmirMod->QueryInterface(IID_ISMIR_ModuleEnumerator,(void**)ppenum);

		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}



/*
 * CEnumSmirGroup::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */
STDMETHODIMP CEnumSmirGroup::QueryInterface(IN REFIID riid, 
											OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_GroupEnumerator==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CEnumSmirGroup::Clone(OUT IEnumGroup  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == ppenum)
			return E_INVALIDARG;
		int GroupIndex = m_Index;
		PENUMSMIRGROUP pTmpEnumSmirGroup = new CEnumSmirGroup(this);
		m_Index = GroupIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirGroup)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		pTmpEnumSmirGroup->QueryInterface(IID_ISMIR_GroupEnumerator,(void**)ppenum);

		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CEnumSmirGroup :: ~CEnumSmirGroup ()
{
	/*let the EnumObjectArray empty the module array and delete the 
	 *modules I created
	 */
}

CEnumSmirGroup :: CEnumSmirGroup ( 

	IN CSmir *a_Smir , 
	IN ISmirModHandle *hModule
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//fill in the path etc
	if(NULL!=hModule)
	{
		IWbemServices * moServ = NULL ;
		IWbemContext *moContext = NULL ;
		SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
		res= CSmirAccess :: Open(a_Smir,&moServ,hModule);
		if ((S_FALSE==res)||(NULL == (void*)moServ))
		{
			if ( moContext )
				moContext->Release () ;

			//we have a problem
			return;
		}

		//I have now opened the module namespace so look at the group namespaces

		IEnumWbemClassObject *pEnum = NULL ;
		CBString t_BStr (GROUP_NAMESPACE_NAME);
		SCODE sRes = moServ->CreateInstanceEnum (

			t_BStr.GetString (), 
			RESERVED_WBEM_FLAG, 
			moContext,
			&pEnum
		);

		if ( moContext )
			moContext->Release () ;
		moServ->Release();

		if (FAILED(sRes)||(NULL == pEnum))
		{
			//there are no instances
			return;
		}

		ULONG uCount=1; 
		ULONG puReturned = 0 ;
		IWbemClassObject *pSmirMosClassObject = NULL ;

		pEnum->Reset();
		while(S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned))
		{
			ISmirGroupHandle *pTGroup = NULL ;

			SCODE result = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_GroupHandle,
													IID_ISMIR_GroupHandle, (PVOID *)&pTGroup);

			if (FAILED(result)||(NULL == pTGroup))
			{
				//we have a problem
				pSmirMosClassObject->Release();
				break;
			}
			//save the module name
			BSTR szModuleName = NULL ;
			hModule->GetName(&szModuleName);
			pTGroup->SetModuleName(szModuleName);
			SysFreeString(szModuleName);
			
			//extract the properties
			*((CSmirGroupHandle*)pTGroup) << pSmirMosClassObject;
			//release this resource here because we are in a loop
			pSmirMosClassObject->Release();
			m_IHandleArray.Add(pTGroup);		
		}

		pEnum->Release();
	}
	else
	{
		//open the smir and enumerate the modules
		ISmirInterrogator *pInterrogativeInt = NULL ;

		SCODE result = a_Smir->QueryInterface ( 

			IID_ISMIR_Interrogative, 
			( void ** ) &pInterrogativeInt
		) ;

		if (S_OK != result)
		{
			if(NULL != pInterrogativeInt)
				pInterrogativeInt->Release();
			return ;
		}

		IEnumModule *pEnumSmirMod = NULL ;
		//ok now let's use the interrogative interface
		result = pInterrogativeInt->EnumModules(&pEnumSmirMod);
		//now use the enumerator
		if((S_OK != result)||(NULL == pEnumSmirMod))
		{
			pInterrogativeInt->Release();
			//no modules
			return;
		}

		ISmirModHandle *phModule = NULL ;
		for(int iCount=0;S_OK==pEnumSmirMod->Next(1, &phModule, NULL);iCount++)
		{
			//we have the module so get the groups via the enumerator
			IEnumGroup *pEnumSmirGroup = NULL ;
			result = pInterrogativeInt->EnumGroups(&pEnumSmirGroup,phModule);
			//now use the enumerator
			if((S_OK == result)&&(pEnumSmirGroup))
			{
				ISmirGroupHandle *phGroup = NULL ;
				for(int iCount=0;S_OK==pEnumSmirGroup->Next(1, &phGroup, NULL);iCount++)
				{
					m_IHandleArray.Add(phGroup);		
				}
			}
			phModule->Release();
			pEnumSmirGroup->Release();
		}
		pEnumSmirMod->Release();
		pInterrogativeInt->Release();
	}
}

CEnumSmirGroup :: CEnumSmirGroup(IN IEnumGroup *pSmirGroup)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	if(NULL == pSmirGroup)
	{
		//bad args
		return;
	}

	ULONG uCount=1; 
    ISmirGroupHandle *pGroup = NULL ;
    ULONG puReturned;
	//OK loop over the group namespaces
	for(pSmirGroup->Reset();S_OK==pSmirGroup->Next(uCount,&pGroup,&puReturned);)
	{
		ISmirGroupHandle *pTGroup =NULL ;
		SCODE result = pGroup->QueryInterface(IID_ISMIR_ModHandle,(void**)&pTGroup );
		pGroup->Release();

		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTGroup);		
	}
}

/*
 * CEnumSmirClass::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumSmirClass :: QueryInterface(IN REFIID riid, 
											  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ClassEnumerator==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP CEnumSmirClass::Clone(IEnumClass  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ClassIndex = m_Index;
		PENUMSMIRCLASS pTmpEnumSmirClass = new CEnumSmirClass(this);
		m_Index = ClassIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumSmirClass)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		if(NOERROR == pTmpEnumSmirClass->QueryInterface(IID_ISMIR_ClassEnumerator,(void**)ppenum))
			return S_OK;

		return E_UNEXPECTED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

}

CEnumSmirClass :: CEnumSmirClass(IEnumClass *pSmirClass)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	ULONG uCount=1; 
    ISmirClassHandle *pClass = NULL ;
    ULONG puReturned;

	//OK loop through the enumerator
	
	for(pSmirClass->Reset();S_OK==pSmirClass->Next(uCount,&pClass,&puReturned);)
	{
		ISmirClassHandle *pTClass = NULL ;
		SCODE result = pClass->QueryInterface(IID_ISMIR_ClassHandle,(void**)&pTClass );
		pClass->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTClass);		
	}
}

/*enumerate all of the classes in the smir
 */

CEnumSmirClass :: CEnumSmirClass(

	CSmir *a_Smir ,
	ISmirDatabase *pSmir, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir
	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem
		return;
	}

	IEnumWbemClassObject *pEnum = NULL ;
	CBString t_Bstr(HMOM_SNMPOBJECTTYPE_STRING);
	SCODE sRes = moServ->CreateClassEnum (

		t_Bstr.GetString(),
		WBEM_FLAG_SHALLOW, 
		moContext, 
		&pEnum
	);

	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	//we have some classes so add them to the enumerator
	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0 ;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirClassHandle *pTClass = NULL ;

		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ClassHandle,
										IID_ISMIR_ClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			pSmirMosClassObject->Release();
			return;
		}

		pTClass->SetWBEMClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		
		//if this is an async enumeration signal the connectable object

		pSmirMosClassObject->Release();
	}
	pEnum->Release();
}

CEnumSmirClass :: CEnumSmirClass(

	CSmir *a_Smir ,
	ISmirDatabase *pSmir, 
	ISmirGroupHandle *hGroup, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	if(((CSmirGroupHandle*)hGroup)==NULL)
	{
		return;
	}

	//open the smir
	IWbemServices *moServ = NULL ;	//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ,hGroup,CSmirAccess::eModule);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem
		return;
	}

	BSTR szTmpGroupName = NULL ;				//the group name
	BSTR szTmpModuleName = NULL ;			//the module name

	hGroup->GetName(&szTmpGroupName);			//the group name
	hGroup->GetModuleName(&szTmpModuleName);	//the module name

	/*query for 
	 *associators of {\\.\root\default\SMIR\<module>:Group="<group>"}
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(BACKSLASH_STR)
					+CString(szTmpModuleName)
					+CString(COLON_STR)
					+CString(GROUP_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpGroupName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					);
	BSTR  szQuery = sQuery.AllocSysString();

	IEnumWbemClassObject *pEnum = NULL ;
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		0, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		SysFreeString(szTmpGroupName);
		SysFreeString(szTmpModuleName);
		return ;
	}

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirClassHandle *pTClass = NULL ;
		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ClassHandle,
										IID_ISMIR_ClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpGroupName);
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModuleName(szTmpModuleName);

		//save the group name
		pTClass->SetGroupName(szTmpGroupName);

		pTClass->SetWBEMClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		
		//if this is an async enumeration signal the connectable object
		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	SysFreeString(szTmpGroupName);
	pEnum->Release();
}

CEnumSmirClass :: CEnumSmirClass(

	CSmir *a_Smir ,
	ISmirDatabase *pSmir,
	ISmirModHandle *hModule, 
	DWORD dwCookie
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = 0;

	BSTR szTmpModuleName = NULL;
	hModule->GetName(&szTmpModuleName);

	/*query for 
	*associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"} where AssocClass=ModuleToClassAssociator
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(COLON_STR)
					+CString(MODULE_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpModuleName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					+CString(SMIR_ASSOC_QUERY_STR3)
					+CString(EQUALS_STR)
					+CString(SMIR_MODULE_ASSOC_CLASS_NAME)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		RESERVED_WBEM_FLAG, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		SysFreeString(szTmpModuleName);
		return ;
	}

	VARIANT pVal;
	VariantInit(&pVal);

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		BSTR szTmpGroupName = NULL;				//the group name (set when we find it)
		//find the group that this class belongs to (could be more than one group)

		//...

		//ok we have a class in the correct module so add it to the enumeration
		ISmirClassHandle *pTClass = NULL ;
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ClassHandle,
										IID_ISMIR_ClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModuleName(szTmpModuleName);

		pTClass->SetWBEMClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	pEnum->Release();
}

/*
 * CEnumSmir::Next
 * CEnumSmir::Skip
 * CEnumSmir::Reset
 *
 * Enumerator methods.  
 */

#pragma warning (disable:4018)

SCODE CEnumSmirMod::Next(IN ULONG celt, 
						   OUT ISmirModHandle **phModule, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
				//what is the next module in the SMIR namespace

				//allocate the handle and save it
				ISmirModHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

				//this could throw an exception but it would be the caller's fault
				if(NULL != hTmpModule)
				{
					phModule[iLoop] = hTmpModule;
					//don't forget that I have a handle to this
					phModule[iLoop]->AddRef();
					if (NULL != pceltFetched)
						(*pceltFetched)++;
				}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumSmirMod::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumSmirMod::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}

/*
 * CEnumSmir::AddRef
 * CEnumSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumSmirMod::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumSmirMod::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

/*
 * CEnumSmir::Next
 * CEnumSmir::Skip
 * CEnumSmir::Reset
 *
 * Enumerator methods.  
 */

#pragma warning (disable:4018)

SCODE CEnumSmirGroup::Next(IN ULONG celt, 
						   OUT ISmirGroupHandle **phModule, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next module in the SMIR namespace

					//allocate the handle and save it
					ISmirGroupHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phModule[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phModule[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumSmirGroup::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumSmirGroup::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}
/*
 * CEnumSmir::AddRef
 * CEnumSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumSmirGroup::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumSmirGroup::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}
/*
 * CEnumSmir::Next
 * CEnumSmir::Skip
 * CEnumSmir::Reset
 *
 * Enumerator methods.  
 */

#pragma warning (disable:4018)

SCODE CEnumSmirClass::Next(IN ULONG celt, 
						   OUT ISmirClassHandle **phModule, 
						   OUT ULONG * pceltFetched)
{	
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next module in the SMIR namespace

					//allocate the handle and save it
					ISmirClassHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phModule[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phModule[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumSmirClass::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumSmirClass::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}
/*
 * CEnumSmir::AddRef
 * CEnumSmir::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumSmirClass::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumSmirClass::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}


//Notification Enum Classes

/*
 * CEnumNotificationClass::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumNotificationClass :: QueryInterface(IN REFIID riid, 
											  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_EnumNotificationClass==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CEnumNotificationClass::Clone(IEnumNotificationClass  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ClassIndex = m_Index;
		PENUMNOTIFICATIONCLASS pTmpEnumNotificationClass = new CEnumNotificationClass(this);
		m_Index = ClassIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumNotificationClass)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		if(NOERROR == pTmpEnumNotificationClass->QueryInterface(IID_ISMIR_EnumNotificationClass,(void**)ppenum))
			return S_OK;

		return E_UNEXPECTED;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CEnumNotificationClass :: CEnumNotificationClass(IEnumNotificationClass *pSmirClass)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	ULONG uCount=1; 
    ISmirNotificationClassHandle *pClass = NULL ;
    ULONG puReturned;

	//OK loop through the enumerator
	
	for(pSmirClass->Reset();S_OK==pSmirClass->Next(uCount,&pClass,&puReturned);)
	{
		ISmirNotificationClassHandle *pTClass = NULL ;
		SCODE result = pClass->QueryInterface(IID_ISMIR_NotificationClassHandle,(void**)&pTClass );
		pClass->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTClass);		
	}
}

/*enumerate all of the classes in the smir
 */

CEnumNotificationClass :: CEnumNotificationClass (

	CSmir *a_Smir , 
	ISmirDatabase *pSmir, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir
	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem
		return;
	}

	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = NULL;
	CBString t_Bstr(HMOM_SNMPNOTIFICATIONTYPE_STRING);
	SCODE sRes = moServ->CreateClassEnum (

		t_Bstr.GetString(),
		WBEM_FLAG_SHALLOW, 
		moContext, 
		&pEnum
	);

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	//we have some classes so add them to the enumerator
	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirNotificationClassHandle *pTClass;

		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_NotificationClassHandle,
										IID_ISMIR_NotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			pSmirMosClassObject->Release();
			return;
		}

		pTClass->SetWBEMNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		
		//if this is an async enumeration signal the connectable object

		pSmirMosClassObject->Release();
	}
	pEnum->Release();
}


CEnumNotificationClass :: CEnumNotificationClass (

	IN CSmir *a_Smir , 
	ISmirDatabase *pSmir,
	ISmirModHandle *hModule, 
	DWORD dwCookie
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	//I have now opened the smir namespace so look at the classes
	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		return ;
	}

	IEnumWbemClassObject *pEnum = NULL ;
	BSTR szTmpModuleName = NULL ;
	hModule->GetName(&szTmpModuleName);

	/*query for 
	*associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"} where AssocClass=ModToNotificationClassAssoc
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(COLON_STR)
					+CString(MODULE_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpModuleName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					+CString(SMIR_ASSOC_QUERY_STR3)
					+CString(EQUALS_STR)
					+CString(SMIR_MODULE_ASSOC_NCLASS_NAME)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		RESERVED_WBEM_FLAG, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	VARIANT pVal;
	VariantInit(&pVal);

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	HRESULT enumResult = S_OK;
	for(pEnum->Reset();S_OK==(enumResult = pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned));)
	{
		BSTR szTmpGroupName = NULL;				//the group name (set when we find it)
		//find the group that this class belongs to (could be more than one group)

		//...

		//ok we have a class in the correct module so add it to the enumeration
		ISmirNotificationClassHandle *pTClass = NULL ;
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_NotificationClassHandle,
										IID_ISMIR_NotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModule(szTmpModuleName);

		pTClass->SetWBEMNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	pEnum->Release();
}


/*
 * CEnumNotificationClass::Next
 * CEnumNotificationClass::Skip
 * CEnumNotificationClass::Reset
 *  
 */

#pragma warning (disable:4018)

SCODE CEnumNotificationClass::Next(IN ULONG celt, 
						   OUT ISmirNotificationClassHandle **phClass, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next class

					//allocate the handle and save it
					ISmirNotificationClassHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phClass[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phClass[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumNotificationClass::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumNotificationClass::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}

/*
 * CEnumNotificationClass::AddRef
 * CEnumNotificationClass::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumNotificationClass::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}

}

ULONG CEnumNotificationClass::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
	    return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}

}


//ExtNotification Enum Classes

/*
 * CEnumExtNotificationClass::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknowninterface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CEnumExtNotificationClass :: QueryInterface(IN REFIID riid, 
											  OUT PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_EnumExtNotificationClass==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CEnumExtNotificationClass::Clone(IEnumExtNotificationClass  **ppenum)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL == ppenum)
			return E_INVALIDARG;

		int ClassIndex = m_Index;
		PENUMEXTNOTIFICATIONCLASS pTmpEnumNotificationClass = new CEnumExtNotificationClass(this);
		m_Index = ClassIndex;
		//we have an enumerator so  get the interface to pass back
		if(NULL == pTmpEnumNotificationClass)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}

		if(NOERROR == pTmpEnumNotificationClass->QueryInterface(IID_ISMIR_EnumExtNotificationClass,(void**)ppenum))
			return S_OK;

		return E_UNEXPECTED;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}

}

CEnumExtNotificationClass :: CEnumExtNotificationClass(IEnumExtNotificationClass *pSmirClass)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	ULONG uCount=1; 
    ISmirExtNotificationClassHandle *pClass = NULL ;
    ULONG puReturned;

	//OK loop through the enumerator
	
	for(pSmirClass->Reset();S_OK==pSmirClass->Next(uCount,&pClass,&puReturned);)
	{
		ISmirExtNotificationClassHandle *pTClass = NULL ;
		SCODE result = pClass->QueryInterface(IID_ISMIR_ExtNotificationClassHandle,(void**)&pTClass );
		pClass->Release();
		if(S_OK != result)
		{
			//this is not going to happen! I know which interface it is.
			return ;
		}
		/*things are looking good; we have the handle to the instance so 
		 *add it to out array
		 */
		m_IHandleArray.Add(pTClass);		
	}
}

/*enumerate all of the classes in the smir
 */

CEnumExtNotificationClass :: CEnumExtNotificationClass(

	CSmir *a_Smir , 
	ISmirDatabase *pSmir, 
	DWORD dwCookie
)
{
	//zero the reference count
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	//open the smir
	IWbemServices *moServ = NULL ;		//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(moServ == NULL))
	{
		//we have a problem
		if ( moContext )
			moContext->Release () ;
		return;
	}

	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = NULL ;
	CBString t_Bstr(HMOM_SNMPEXTNOTIFICATIONTYPE_STRING);
	SCODE sRes = moServ->CreateClassEnum (

		t_Bstr.GetString(),
		WBEM_FLAG_SHALLOW, 
		moContext,
		&pEnum
	);

	if ( moContext )
		moContext->Release () ;
	moServ->Release();
	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	//we have some classes so add them to the enumerator
	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned;

	//loop over the classes
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		ISmirExtNotificationClassHandle *pTClass = NULL ;

		//got one so wrap it to go
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ExtNotificationClassHandle,
										IID_ISMIR_ExtNotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			pSmirMosClassObject->Release();
			return;
		}

		pTClass->SetWBEMExtNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	pEnum->Release();
}

CEnumExtNotificationClass :: CEnumExtNotificationClass (

	CSmir *a_Smir , 
	ISmirDatabase *pSmir,
	ISmirModHandle *hModule, 
	DWORD dwCookie
)
{
	m_cRef=0;
	//set the index to the first element
	m_Index=0;

	IWbemServices *moServ = NULL ;	//pointer to the provider
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		return ;
	}

	//I have now opened the smir namespace so look at the classes
	IEnumWbemClassObject *pEnum = NULL ;
	BSTR szTmpModuleName = NULL;
	hModule->GetName(&szTmpModuleName);

	/*query for 
	*associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"} where AssocClass=ModToExtNotificationClassAssoc
	 */
	CString sQuery(CString(SMIR_ASSOC_QUERY_STR1)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(COLON_STR)
					+CString(MODULE_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(szTmpModuleName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					+CString(SMIR_ASSOC_QUERY_STR3)
					+CString(EQUALS_STR)
					+CString(SMIR_MODULE_ASSOC_EXTNCLASS_NAME)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery (

		t_QueryFormat.GetString (), 
		szQuery,
		RESERVED_WBEM_FLAG, 
		moContext,
		&pEnum
	);

	SysFreeString(szQuery);
	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//problem or we have no classes to enumerate
		return ;
	}

	VARIANT pVal;
	VariantInit(&pVal);

	ULONG uCount=1; 
	IWbemClassObject *pSmirMosClassObject = NULL ;
	ULONG puReturned = 0;

	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pSmirMosClassObject,&puReturned);)
	{
		BSTR szTmpGroupName = NULL;				//the group name (set when we find it)
		//find the group that this class belongs to (could be more than one group)

		//...

		//ok we have a class in the correct module so add it to the enumeration
		ISmirExtNotificationClassHandle *pTClass = NULL ;
		res = g_pClassFactoryHelper->CreateInstance(CLSID_SMIR_ExtNotificationClassHandle,
										IID_ISMIR_ExtNotificationClassHandle, (PVOID *)&pTClass);
		if (FAILED(res))
		{
			//we have a problem
			SysFreeString(szTmpModuleName);
			pSmirMosClassObject->Release();
			return;
		}
		//save the module name
		pTClass->SetModule(szTmpModuleName);

		pTClass->SetWBEMExtNotificationClass(pSmirMosClassObject);

		//drop it in the enumeration array
		m_IHandleArray.Add(pTClass);		

		pSmirMosClassObject->Release();
	}
	SysFreeString(szTmpModuleName);
	pEnum->Release();
}

/*
 * CEnumNotificationClass::Next
 * CEnumNotificationClass::Skip
 * CEnumNotificationClass::Reset
 *  
 */

#pragma warning (disable:4018)

SCODE CEnumExtNotificationClass::Next(IN ULONG celt, 
						   OUT ISmirExtNotificationClassHandle **phClass, 
						   OUT ULONG * pceltFetched)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL!=pceltFetched)
			*pceltFetched=0;
		if(celt>0)
		{
			//check that the arguments make sense
			if ((celt > 1)&&(NULL == pceltFetched))
				return ResultFromScode(S_FALSE);

			//get the number of elements in the zero based array
			int iSize = m_IHandleArray.GetSize();
			//get all of the elements requested or until we hit the end of the array
			int iLoop;
			for(iLoop=0; (iLoop<celt)&&(m_Index<iSize);iLoop++,m_Index++)
			{
					//what is the next class

					//allocate the handle and save it
					ISmirExtNotificationClassHandle* hTmpModule = m_IHandleArray.GetAt(m_Index);

					//this could throw an exception but it would be the caller's fault
					if(NULL != hTmpModule)
					{
						phClass[iLoop] = hTmpModule;
						//don't forget that I have a handle to this
						phClass[iLoop]->AddRef();
						if (NULL != pceltFetched)
							(*pceltFetched)++;
					}
			}
			//return based on the number requested
			return (iLoop==(celt-1))? ResultFromScode(S_FALSE): ResultFromScode(S_OK);
		}
		//he asked for 0 and that is what he got
		return ResultFromScode(S_OK);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (disable:4018)

SCODE CEnumExtNotificationClass::Skip(IN ULONG celt)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((m_Index+celt)<m_IHandleArray.GetSize())
		{
			m_Index += celt;
			return ResultFromScode(S_OK);
		}
		else
		{
			return ResultFromScode(S_FALSE);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

#pragma warning (default:4018)

SCODE CEnumExtNotificationClass::Reset(void)
{
	m_Index=0;
	return ResultFromScode(S_OK);
}
/*
 * CEnumNotificationClass::AddRef
 * CEnumNotificationClass::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CEnumExtNotificationClass::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CEnumExtNotificationClass::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\handles.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"

#include <textdef.h>
#include <helper.h>
#include "bstring.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif


// A function to escape newlines, tabs etc. from a property value
static BSTR EscapeSpecialCharacters(BSTR strInputString)
{
	// Escape all the quotes - This code taken from winmgmt\common\var.cpp
	// =====================

	int nStrLen = wcslen(strInputString);
	LPWSTR wszValue = new WCHAR[nStrLen*2+10];
	LPWSTR pwc = wszValue;
	for(int i = 0; i < (int)nStrLen; i++)
	{    
		switch(strInputString[i])
		{
			case L'\n':
				*(pwc++) = L'\\';
				*(pwc++) = L'n';
				break;
			case L'\t':
				*(pwc++) = L'\\';
				*(pwc++) = L't';
				break;
			case L'"':
			case L'\\':
				*(pwc++) = L'\\';
				*(pwc++) = strInputString[i];
				break;
			default:
				*(pwc++) = strInputString[i];
				break;
		}
	}
	*pwc = 0;
	BSTR retValue = SysAllocString(wszValue);
	delete [] wszValue;
	return retValue;
}


/*
 * CSmirModuleHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirModuleHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ModHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}



/*
 * CSmirModuleHandle::AddRef
 * CSmirModuleHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirModuleHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		////CMOEvent_Trace MyTraceEvent(SMIR_STR);  

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirModuleHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirModuleHandle :: CSmirModuleHandle()
:	m_lSnmp_version(DEFAULT_SNMP_VERSION), m_szLastUpdate(NULL),
	m_szModuleOid(NULL), m_szName(NULL),
	m_szModuleId(NULL), m_szOrganisation(NULL),
	m_szContactInfo(NULL), m_szDescription(NULL),
	m_szRevision(NULL), m_szModImports(NULL)
{
	//start off as a handel to nothing
	//init reference count
	m_cRef=0;
	CModHandleClassFactory::objectsInProgress++;
}

/*
 * CSmirGroupHandle::void* operator
 * validate handle
 */

CSmirModuleHandle::operator void*()
{
	if(NULL!=m_szName)
		return this;
	return NULL;
}

/**************************************************************************************
 *Methods not exposed by the ISmirModHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

STDMETHODIMP CSmirModuleHandle::DeleteFromDB ( CSmir *a_Smir )
{
	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		return WBEM_E_FAILED;
	}

	//delete all of the classes in this module

	ISmirInterrogator *pInterrogativeInt = NULL ;
	res = g_pClassFactoryHelper->CreateInstance(

		CLSID_SMIR_Database,
		IID_ISMIR_Interrogative,
		(PVOID *)&pInterrogativeInt
	);

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_Configuration = NULL ;
	res = pInterrogativeInt->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_Configuration 
	) ;

	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_CopyConfiguration = NULL ;
	res = a_Smir->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_CopyConfiguration 
	) ;

	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		t_Configuration->Release () ;
		pInterrogativeInt->Release();
		return S_OK ;
	}

	t_Configuration->Impersonate ( t_CopyConfiguration ) ;

	if ( ! SUCCEEDED ( res ) )
	{
		if ( moContext )
			moContext->Release () ;

		t_Configuration->Release () ;
		t_CopyConfiguration->Release () ;
		pInterrogativeInt->Release();

		return S_OK ;
	}

	t_Configuration->Release () ;
	t_CopyConfiguration->Release () ;

	IEnumClass  *pTEnumSmirClass = NULL ;
	res = pInterrogativeInt->EnumClassesInModule(&pTEnumSmirClass,this);

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	//now use the enumerator
	//loop over the classes and remove them
	ISmirClassHandle *phClass = NULL ;
	for(int iCount=0;S_OK==pTEnumSmirClass->Next(1, &phClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirClassHandle*)phClass)->DeleteFromDB(a_Smir);
		phClass->Release();
	}

	pTEnumSmirClass->Release();

	IEnumNotificationClass  *pTEnumNotificationClass = NULL ;
	res = pInterrogativeInt->EnumNotificationClassesInModule(&pTEnumNotificationClass,this);

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	//now use the enumerator
	//loop over the classes and remove them
	ISmirNotificationClassHandle *phNClass = NULL ;
	for(iCount=0;S_OK==pTEnumNotificationClass->Next(1, &phNClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirNotificationClassHandle*)phNClass)->DeleteFromDB(a_Smir);
		phNClass->Release();
	}

	pTEnumNotificationClass->Release();

	IEnumExtNotificationClass  *pTEnumExtNotificationClass = NULL ;
	res = pInterrogativeInt->EnumExtNotificationClassesInModule(&pTEnumExtNotificationClass,this);
	
	//not needed anymore...
	pInterrogativeInt->Release();

	if(S_OK!=res)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	//now use the enumerator
	//loop over the classes and remove them
	ISmirExtNotificationClassHandle *phExtNClass = NULL ;
	for(iCount=0;S_OK==pTEnumExtNotificationClass->Next(1, &phExtNClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirExtNotificationClassHandle*)phExtNClass)->DeleteFromDB(a_Smir);
		phExtNClass->Release();
	}

	pTEnumExtNotificationClass->Release();
	
	/********************Now delete the module********************/

	//create a buffer big enough
	wchar_t *pTstring = new wchar_t[wcslen(MODULE_NAMESPACE_NAME)+wcslen(EQUALS_STR)
							+wcslen(m_szName)+2+1];
	if(NULL == pTstring)
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return E_OUTOFMEMORY;
	}

	wcscpy(pTstring, MODULE_NAMESPACE_NAME);
	wcscat(pTstring,EQUALS_STR);
	wcscat(pTstring,QUOTE_STR);
	// module =

	wcscat(pTstring,m_szName);
	wcscat(pTstring,QUOTE_STR);
	// module = <module>

	CBString t_Str (pTstring);
	SCODE result = moServ->DeleteInstance(t_Str.GetString (),RESERVED_WBEM_FLAG, moContext,NULL );

	//clean up
	delete [] pTstring;

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	if (FAILED(result))
	{
		//problem!
		return WBEM_E_FAILED;
	}
	return S_OK;
}

STDMETHODIMP CSmirModuleHandle::AddToDB( CSmir *a_Smir )
{
	/*open the smir name space this will addref it so it cannot be removed
	 *whilst we are using it
	 */
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ);

	if ((S_FALSE==result)||(NULL == (void*)moServ))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem the SMIR is not there and cannot be created
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pModClass = NULL ;
	CBString t_BStr ( MODULE_NAMESPACE_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString () , RESERVED_WBEM_FLAG,moContext,
								&pModClass,NULL);

	if (!SUCCEEDED(result))
	{
		/*OK we have the smir namespace so create the module namespace
		 *first create a class...
		 */


		IWbemClassObject *pNewClass = NULL ;
		CBString t_BStr ( OLEMS_NAMESPACE_CLASS ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,moContext,
									&pNewClass,NULL);

		if ((FAILED(result))||(NULL==pNewClass))
		{
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		// Spawn derived class

		IWbemClassObject *pNewDerivedClass = NULL ;
		result = pNewClass->SpawnDerivedClass ( 0 , &pNewDerivedClass ) ;
		if ((FAILED(result))||(NULL==pNewDerivedClass))
		{
			moServ->Release();
			pNewClass->Release () ;
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		pNewClass->Release () ;

		VARIANT v;
		VariantInit(&v);

		//I now have a new class so Give it a name
		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(MODULE_NAMESPACE_NAME);

		result = pNewDerivedClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			pNewDerivedClass->Release();
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		result = PutClassProperties(pNewDerivedClass) ;
		if (FAILED(result))
		{
			pNewDerivedClass->Release();
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}
		
		//now commit the changes
		result = moServ->PutClass(pNewDerivedClass, RESERVED_WBEM_FLAG,moContext,NULL);
		pNewDerivedClass->Release();
		if (FAILED(result))
		{
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

		//get an object

		t_BStr = MODULE_NAMESPACE_NAME ;
		result = moServ->GetObject(t_BStr.GetString (), 0, 
										moContext,&pModClass,NULL );
		if (FAILED(result))
		{
			moServ->Release();
			if ( moContext )
				moContext->Release () ;

			return WBEM_E_FAILED;
		}

	}

	//and create an instance of the module namespace

	// Spawn instance of class

	IWbemClassObject *pNewInstance = NULL ;
	result = pModClass->SpawnInstance ( 0 , &pNewInstance ) ;
	if ((FAILED(result))||(NULL==pNewInstance))
	{
		moServ->Release();
		if ( moContext )
			moContext->Release () ;

		pModClass->Release () ;
		return WBEM_E_FAILED;
	}

	pModClass->Release () ;

	//fill in the instance
	*this >> pNewInstance;

	//and commit it to the namespace
	result = moServ->PutInstance(pNewInstance, RESERVED_WBEM_FLAG, moContext,NULL );
	pNewInstance->Release();
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;
		moServ->Release();

		return WBEM_E_FAILED;
	}

	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(result))
	{
		return WBEM_E_FAILED;
	}

	return S_OK;
}

const CSmirModuleHandle& CSmirModuleHandle :: operator <<(IWbemClassObject *pSmirMosClassObject)
{
	//get the name
	VARIANT v;
	VariantInit(&v);
	pSmirMosClassObject->Get(MODULE_NAME_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetName(V_BSTR(&v));
	}

	VariantClear(&v);
	 
	//get the object id
	pSmirMosClassObject->Get(MODULE_OID_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetModuleOID(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the object imports
	pSmirMosClassObject->Get(MODULE_IMPORTS_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetModuleImports(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the object id
	pSmirMosClassObject->Get(MODULE_ID_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetModuleIdentity(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the organisation
	pSmirMosClassObject->Get(MODULE_ORG_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetOrganisation(V_BSTR(&v));
	}

	VariantClear(&v);
	
	//get the contact
	pSmirMosClassObject->Get(MODULE_CONTACT_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetContactInfo(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the description
	pSmirMosClassObject->Get(MODULE_DESCRIPTION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetDescription(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the revision
	pSmirMosClassObject->Get(MODULE_REVISION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetRevision(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the version
	pSmirMosClassObject->Get(MODULE_SNMP_VERSION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_I4)
	{
		SetSnmpVersion(V_I4(&v));
	}
	//get the last update value
	pSmirMosClassObject->Get(MODULE_LAST_UPDATE_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetLastUpdate(V_BSTR(&v));
	}
	VariantClear(&v);
	return *this;
}

const CSmirModuleHandle& CSmirModuleHandle :: operator >>(IWbemClassObject *pInst)
{
	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	SCODE result;
	if(NULL != m_szName)
	{
		V_BSTR(&v)=SysAllocString(m_szName);

		result = pInst->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	else
	{
		//must have a name
		return *this;
	}
	//add the module oid property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szModuleOid)
	{
		V_BSTR(&v)=SysAllocString(m_szModuleOid);
		result = pInst->Put(MODULE_OID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the module identity
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szModuleId)
	{
		V_BSTR(&v)=SysAllocString(m_szModuleId);
		result = pInst->Put(MODULE_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the organisation property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szOrganisation)
	{
		V_BSTR(&v)=SysAllocString(m_szOrganisation);
		result = pInst->Put(MODULE_ORG_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the contact info property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szContactInfo)
	{
		V_BSTR(&v)=SysAllocString(m_szContactInfo);
		result = pInst->Put(MODULE_CONTACT_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}	
	//add the Description property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szDescription)
	{
		V_BSTR(&v)=SysAllocString(m_szDescription);
		result = pInst->Put(MODULE_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}

	//add the revision property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szRevision)
	{
		V_BSTR(&v)=SysAllocString(m_szRevision);
		result = pInst->Put(MODULE_REVISION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the last update property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szLastUpdate)
	{
		V_BSTR(&v)=SysAllocString(m_szLastUpdate);
		result = pInst->Put(MODULE_LAST_UPDATE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the snmp version property
	V_VT(&v) = VT_I4;
	V_I4(&v)=m_lSnmp_version;

	result = pInst->Put(MODULE_SNMP_VERSION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return *this;
	}

	//add the module identity as an property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szModImports)
	{
		V_BSTR(&v)=SysAllocString(m_szModImports);
	
		result = pInst->Put(MODULE_IMPORTS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	return *this;
}

HRESULT CSmirModuleHandle :: PutClassProperties (IWbemClassObject *pClass)
{
	HRESULT result;

	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");

	result = pClass->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the module oid property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_OID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the module identity
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the organisation property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_ORG_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the contact info property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_CONTACT_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the Description property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the revision property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_REVISION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the last update property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_LAST_UPDATE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the snmp version property
	V_VT(&v) = VT_I4;
	V_I4(&v)=0;
	result = pClass->Put(MODULE_SNMP_VERSION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the module identity as an property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");

	result = pClass->Put(MODULE_IMPORTS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	return result ;
}

const CSmirModuleHandle& CSmirModuleHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if(NULL!=pSHandle)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		CString szTmpString;
		//start in the SMIR namepspace
		if(TRUE==bMOFPragmas)
			szTmpString=CString(SMIR_NAMESPACE_PRAGMA);
		
		if (TRUE == bMOFAssociations)
		{
			//create an instance of the module namespac
			szTmpString+=MODULE_INSTANCE_START;
			//add the properties

			//give the instance a name
			szTmpString+=CString(MODULE_NAME_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szName);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//add the module oid property
			szTmpString+=CString(MODULE_OID_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szModuleOid);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the module identity
			szTmpString+=CString(MODULE_ID_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szModuleId);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the organisation property
			szTmpString+=CString(MODULE_ORG_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strOrganisation = EscapeSpecialCharacters(m_szOrganisation);
			szTmpString+=CString(strOrganisation);
			SysFreeString(strOrganisation);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//add the contact info property
			szTmpString+=CString(MODULE_CONTACT_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strContactInfo = EscapeSpecialCharacters(m_szContactInfo);
			szTmpString+=CString(strContactInfo);
			SysFreeString(strContactInfo);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the Description property
			szTmpString+=CString(MODULE_DESCRIPTION_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strDescription= EscapeSpecialCharacters(m_szDescription);
			szTmpString+=CString(strDescription);
			SysFreeString(strDescription);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the revision property
			szTmpString+=CString(MODULE_REVISION_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			BSTR strRevision = EscapeSpecialCharacters(m_szRevision);
			szTmpString+=CString(strRevision);
			SysFreeString(strRevision);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the last update property
			szTmpString+=CString(MODULE_LAST_UPDATE_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szLastUpdate);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//add the snmp version property
			szTmpString+=CString(MODULE_SNMP_VERSION_PROPERTY);
			szTmpString+=CString(EQUALS_STR);
			wchar_t szVersion[17];
			_itow(m_lSnmp_version,szVersion,2);
			szTmpString+=CString(szVersion);
			szTmpString+=END_OF_PROPERTY;
			
			//add the module imports as an property
			szTmpString+=CString(MODULE_IMPORTS_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szModImports);
			szTmpString+=END_OF_PROPERTY_VALUE;

			szTmpString+=END_OF_CLASS;
		}
		/*******create the group class***********/
		//add the group class to the module namespace
		if(TRUE==bMOFPragmas)
		{
			szTmpString+=CString(START_OF_SMIR_NAMESPACE_PRAGMA);
			szTmpString+=CString(m_szName);
			szTmpString+=CString(END_OF_NAMESPACE_PRAGMA);
		}
		if (TRUE == bMOFAssociations)
		{
			szTmpString+=GROUP_CLASS_START;
			
			//add the properties
			//give the instance a name
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_NAME_PROPERTY);
			szTmpString+=END_OF_PROPERTY;

			//give the instance a group id
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_ID_PROPERTY);
			szTmpString+=END_OF_PROPERTY;
			
			//give the instance a status
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_STATUS_PROPERTY);
			szTmpString+=END_OF_PROPERTY;
			
			//give the instance a description
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(GROUP_DESCRIPTION_PROPERTY);
			szTmpString+=END_OF_PROPERTY;

			//give the instance a reference
			szTmpString+=READONLY_STRING;
			szTmpString+=CString(MODULE_REFERENCE_PROPERTY);
			szTmpString+=END_OF_PROPERTY;

			szTmpString+=END_OF_CLASS;
		}

		//and add the string to the serialise handle
		((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(szTmpString);

		//each group will create it's own instance

	}

	return *this;
}

SCODE CSmirModuleHandle :: GetName(BSTR *pszName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(pszName!=NULL)
		{
			*pszName=SysAllocString(m_szName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetModuleOID(BSTR *pszModuleOid)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszModuleOid)
		{
			*pszModuleOid=SysAllocString(m_szModuleOid);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetModuleIdentity(BSTR *pszModuleId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszModuleId)
		{
			*pszModuleId=SysAllocString(m_szModuleId);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetLastUpdate(BSTR *pszLastUpdate)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszLastUpdate)
		{
			*pszLastUpdate=SysAllocString(m_szLastUpdate);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetOrganisation(BSTR *pszOrganisation)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszOrganisation)
		{
			*pszOrganisation=SysAllocString(m_szOrganisation);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetContactInfo(BSTR *pszContactInfo)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszContactInfo)
		{
			*pszContactInfo=SysAllocString(m_szContactInfo);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetDescription(BSTR *pszDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszDescription)
		{
			*pszDescription=SysAllocString(m_szDescription);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetRevision(BSTR *pszRevision)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pszRevision)
		{
			*pszRevision=SysAllocString(m_szRevision);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetSnmpVersion(ULONG *plSnmp_version)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != plSnmp_version)
		{
			*plSnmp_version=m_lSnmp_version;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: GetModuleImports (BSTR* ppszModImports)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != ppszModImports)
		{
			*ppszModImports=SysAllocString(m_szModImports);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetName(BSTR pszName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szName,&pszName);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetModuleOID(BSTR pszModuleOid)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleOid,&pszModuleOid);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetModuleIdentity(BSTR pszModuleId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleId,&pszModuleId);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetLastUpdate(BSTR pszLastUpdate)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szLastUpdate,&pszLastUpdate);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetOrganisation(BSTR pszOrganisation)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szOrganisation,&pszOrganisation);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetContactInfo(BSTR pszContactInfo)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szContactInfo,&pszContactInfo);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetDescription(BSTR pszDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szDescription,&pszDescription);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetRevision(BSTR pszRevision)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szRevision,&pszRevision);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetSnmpVersion(ULONG plSnmp_version)
{
	SetStructuredExceptionHandler seh;

	try
	{
		m_lSnmp_version=plSnmp_version;
		return S_OK;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirModuleHandle :: SetModuleImports (BSTR pszModImports)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModImports,&pszModImports);	
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CSmirModuleHandle :: ~ CSmirModuleHandle()
{
	SysFreeString(m_szModuleOid);
	SysFreeString(m_szName);
	SysFreeString(m_szModuleId);
	SysFreeString(m_szOrganisation);
	SysFreeString(m_szContactInfo);
	SysFreeString(m_szDescription);
	SysFreeString(m_szRevision);
	SysFreeString(m_szModImports);
	SysFreeString(m_szLastUpdate);

	CModHandleClassFactory::objectsInProgress--;
}

/*Group handle methods
 */
/*
 * CSmirGroupHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirGroupHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_GroupHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirModuleHandle::AddRef
 * CSmirModuleHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirGroupHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirGroupHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirGroupHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirGroupHandle :: CSmirGroupHandle()
:	m_szModuleName(NULL), m_szName(NULL),
	m_szGroupId(NULL), m_szDescription(NULL),
	m_szReference(NULL),m_szStatus(NULL)
{
	//init the reference count
	m_cRef=0;
	//start off as a handel to nothing

	//inc the factory count
	CGroupHandleClassFactory::objectsInProgress++;
}

CSmirGroupHandle :: ~ CSmirGroupHandle()
{
	SysFreeString(m_szModuleName);
	SysFreeString(m_szName);
	SysFreeString(m_szGroupId);
	SysFreeString(m_szDescription);
	SysFreeString(m_szReference);
	SysFreeString(m_szStatus);
	CGroupHandleClassFactory::objectsInProgress--;
}

/*
 * CSmirGroupHandle::void* operator
 * validate handle
 */

CSmirGroupHandle::operator void*()
{
	if((NULL!=m_szModuleName)&&(NULL!=m_szName))
		return this;
	return NULL;
}

/**************************************************************************************
 *Methods not exposed by the ISmirGroupHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

STDMETHODIMP CSmirGroupHandle::AddToDB( CSmir *a_Smir , ISmirModHandle *hModule)
{
	//save the module name
	BSTR szTmpStr;
	hModule->GetName(&szTmpStr);
	SetModuleName(szTmpStr);
	SysFreeString(szTmpStr);

	//open the module namespace
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ,hModule);
	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}

	//get an object
	IWbemClassObject *pGrpClass = NULL ;
	CBString t_BStr ( GROUP_NAMESPACE_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pGrpClass,NULL );

	if ( !SUCCEEDED(result) )
	{	
		//OK we have the module namespace so create the group class
		IWbemClassObject *pNewClass = NULL ;
		CBString t_BStr ( OLEMS_NAMESPACE_CLASS ) ;
		result = moServ->GetObject(t_BStr.GetString (), RESERVED_WBEM_FLAG,
									moContext, &pNewClass,NULL);

		if ((FAILED(result))||(NULL==pNewClass))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}

		// Spawn derived class

		IWbemClassObject *pNewDerivedClass = NULL ;
		result = pNewClass->SpawnDerivedClass ( 0 , &pNewDerivedClass ) ;
		pNewClass->Release();

		if ((FAILED(result))||(NULL==pNewDerivedClass))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}

		VARIANT v;
		VariantInit(&v);

		//OK I have a new class so give it a name
		V_VT(&v) = VT_BSTR;
		V_BSTR(&v)=SysAllocString(GROUP_NAMESPACE_NAME);

		result = pNewDerivedClass->Put(OLEMS_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pNewDerivedClass->Release();
			return WBEM_E_FAILED;
		}
		
		result = PutClassProperties(pNewDerivedClass) ;
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			pNewDerivedClass->Release();
			moServ->Release();
			return WBEM_E_FAILED;
		}

		//now commit the changes
		result = moServ->PutClass(pNewDerivedClass, RESERVED_WBEM_FLAG, moContext, NULL);
		pNewDerivedClass->Release();
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}

		//and create an instance of the group namespace
		//get an object

		//get an object
		t_BStr = GROUP_NAMESPACE_NAME ;
		result = moServ->GetObject(t_BStr.GetString (), 0, 
										moContext, &pGrpClass,NULL );
		if (FAILED(result))
		{
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			return WBEM_E_FAILED;
		}
	}

	// Spawn instance of class

	IWbemClassObject *pNewInstance ;
	result = pGrpClass->SpawnInstance ( 0 , &pNewInstance ) ;
	if ((FAILED(result))||(NULL==pNewInstance))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pGrpClass->Release () ;
		return WBEM_E_FAILED;
	}

	pGrpClass->Release () ;

	//fill in the instance
	*this >> pNewInstance;


	//and commit it to the namespace
	result = moServ->PutInstance(pNewInstance, RESERVED_WBEM_FLAG,moContext, NULL);
	pNewInstance->Release();

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;
		moServ->Release();

		return WBEM_E_FAILED;
	}

	if ( moContext )
		moContext->Release () ;
	moServ->Release();

	if (FAILED(result))
	{
		return WBEM_E_FAILED;
	}

	return S_OK;
}

STDMETHODIMP CSmirGroupHandle::DeleteFromDB ( CSmir *a_Smir )
{
	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == (void*)moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	/******************delete all of the classes in this group***********************/

	IEnumClass  *pTEnumSmirClass = NULL ;
	ISmirInterrogator *pInterrogativeInt = NULL ;
	SCODE result = g_pClassFactoryHelper->CreateInstance (

		CLSID_SMIR_Database,
		IID_ISMIR_Interrogative,
		(PVOID *)&pInterrogativeInt
	);

	if ( ! SUCCEEDED ( result ) )
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_Configuration = NULL ;
	result = pInterrogativeInt->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_Configuration 
	) ;

	if ( ! SUCCEEDED ( result ) )
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}

	ISMIRWbemConfiguration *t_CopyConfiguration = NULL ;
	result = pInterrogativeInt->QueryInterface ( 

		IID_ISMIRWbemConfiguration , 
		( void ** ) &t_CopyConfiguration 
	) ;

	if ( ! SUCCEEDED ( result ) )
	{
		t_Configuration->Release () ;
		pInterrogativeInt->Release();
	}

	t_Configuration->Impersonate ( t_CopyConfiguration ) ;

	if ( ! SUCCEEDED ( result ) )
	{
		t_Configuration->Release () ;
		t_CopyConfiguration->Release () ;
		pInterrogativeInt->Release();
	}

	t_Configuration->Release () ;
	t_CopyConfiguration->Release () ;

	res = pInterrogativeInt->EnumClassesInGroup (&pTEnumSmirClass,this);
	//now use the enumerator
	if(FAILED(res))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInterrogativeInt->Release();
		return S_OK;
	}
	//loop over the classes and remove them
	ISmirClassHandle *phClass=NULL;
	for(int iCount=0;S_OK==pTEnumSmirClass->Next(1, &phClass, NULL);iCount++)
	{
		/*got one so remove it. Don't check the return because there is nothing 
		 *I can do about it.
		 */
		((CSmirClassHandle*)phClass)->DeleteClassFromGroup(a_Smir);
		phClass->Release();
	}
	pTEnumSmirClass->Release();
	pInterrogativeInt->Release();
	/************************* delete the associations******************************/
	//delete everthing that is associated with the group using 
	//references of {\\.\root\default\SMIR:<group>}
	IEnumWbemClassObject *pEnum = NULL ;

	CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
					+CString(OPEN_BRACE_STR)
					+CString(SMIR_NAMESPACE_FROM_ROOT)
					+CString(BACKSLASH_STR)
					+CString(m_szModuleName)
					+CString(COLON_STR)
					+CString(GROUP_NAMESPACE_NAME)
					+CString(EQUALS_STR)
					+CString(QUOTE_STR)
					+CString(m_szName)
					+CString(QUOTE_STR)
					+CString(CLOSE_BRACE_STR)
					);
	BSTR  szQuery = sQuery.AllocSysString();
	CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
	SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery,
									RESERVED_WBEM_FLAG, moContext, &pEnum);
	SysFreeString(szQuery);

	if (FAILED(sRes)||(NULL==pEnum))
	{
		//all groups that contain classes are associated so this may not be a problem
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return S_OK;
	}

	ULONG uCount=1; 
	IWbemClassObject *pAssocMosClass = NULL ;
	ULONG puReturned;

	//loop over the associations
	VARIANT assocClass;
	VariantInit(&assocClass);
	VARIANT assocName;
	VariantInit(&assocName);
	for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
	{
		pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
		pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
		pAssocMosClass->Release();

		CString instString(

			CString(V_BSTR(&assocClass))
			+CString(EQUALS_STR)
			+CString(QUOTE_STR)
			+CString(V_BSTR(&assocName))
			+CString(QUOTE_STR)
		);

		VariantClear(&assocName);
		VariantClear(&assocClass);

		BSTR instBString = instString.AllocSysString();
		moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
		SysFreeString(instBString);
	}

	pEnum->Release();
	moServ->Release();
	
	/*************************now delete the group******************************/
	//open the module name space
	res= CSmirAccess :: Open(a_Smir,&moServ, this,CSmirAccess::eModule);
	if ((S_FALSE==res)||(NULL == (void*)moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	//OK we have the module namespace so delete the group

	//build the object path
	wchar_t *pTString = new wchar_t[wcslen(GROUP_NAMESPACE_NAME)+wcslen(EQUALS_STR)+
																wcslen(m_szName)+2+1];
	if(NULL == pTString)
	{
		//free the string we got from hGroup
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return E_OUTOFMEMORY;
	}

	wcscpy(pTString, GROUP_NAMESPACE_NAME);
	wcscat(pTString,EQUALS_STR);
	wcscat(pTString,QUOTE_STR);
	// GROUP =

	wcscat(pTString,m_szName);
	wcscat(pTString,QUOTE_STR);
	// GROUP = <group name>


	CBString t_Str (pTString);
	result = moServ->DeleteInstance(t_Str.GetString (), RESERVED_WBEM_FLAG, moContext,NULL);
	moServ->Release();
	if ( moContext )
		moContext->Release () ;

	delete [] pTString;
	
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}
	return S_OK;
}

const CSmirGroupHandle& CSmirGroupHandle :: operator <<(IWbemClassObject *pSmirMosClassObject)
{
	//get the name
	VARIANT v;
	VariantInit(&v);
	pSmirMosClassObject->Get(GROUP_NAME_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetName(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the group id
	pSmirMosClassObject->Get(GROUP_ID_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetGroupOID(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the status
	pSmirMosClassObject->Get(GROUP_STATUS_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetStatus(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the description
	pSmirMosClassObject->Get(GROUP_DESCRIPTION_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetDescription(V_BSTR(&v));
	}
	VariantClear(&v);

	//get the reference
	pSmirMosClassObject->Get(MODULE_REFERENCE_PROPERTY, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		SetReference(V_BSTR(&v));
	}
	VariantClear(&v);

	return *this;
}

const CSmirGroupHandle& CSmirGroupHandle :: operator >>(IWbemClassObject *pInst)
{
	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	SCODE result;
	if(NULL != m_szName)
	{
		V_BSTR(&v)=SysAllocString(m_szName);
	
		result = pInst->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	else
	{
		return *this;
	}
	//add the group oid property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szGroupId)
	{
		V_BSTR(&v)=SysAllocString(m_szGroupId);
		result = pInst->Put(GROUP_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the status property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szStatus)
	{
		V_BSTR(&v)=SysAllocString(m_szStatus);
		result = pInst->Put(GROUP_STATUS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the Description property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szDescription)
	{
		V_BSTR(&v)=SysAllocString(m_szDescription);
		result = pInst->Put(GROUP_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the reference property
	V_VT(&v) = VT_BSTR;
	if(NULL != m_szReference)
	{
		V_BSTR(&v)=SysAllocString(m_szReference);
		result = pInst->Put(MODULE_REFERENCE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
		VariantClear(&v);
		if (FAILED(result))
		{
			FormatProviderErrorMsg(__FILE__,__LINE__,result);
			return *this;
		}
	}
	//add the references to the classes

	//and return
	return *this;
}

HRESULT CSmirGroupHandle :: PutClassProperties (IWbemClassObject *pClass)
{
	VARIANT v;
	VariantInit(&v);

	//give the instance a name
	V_VT(&v) = VT_BSTR;
	HRESULT result;

	V_BSTR(&v)=SysAllocString(L"");
	
	result = pClass->Put(OLEMS_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the group oid property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(GROUP_ID_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the status property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(GROUP_STATUS_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}

	//add the Description property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(GROUP_DESCRIPTION_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result;
	}

	//add the reference property
	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=SysAllocString(L"");
	result = pClass->Put(MODULE_REFERENCE_PROPERTY,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return result ;
	}
	//add the references to the classes

	return result ;
}

const CSmirGroupHandle& CSmirGroupHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if(NULL!=pSHandle)
	{
		CString szTmpString;
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		//start in the group namepspace
		if(TRUE==bMOFPragmas)
		{
			szTmpString=CString(START_OF_SMIR_NAMESPACE_PRAGMA);
			szTmpString+=CString(m_szModuleName);
			szTmpString+=CString(END_OF_NAMESPACE_PRAGMA);
		}
		if(TRUE==bMOFAssociations)
		{
			//create an instance of the group namespace
			szTmpString+=GROUP_INSTANCE_START;

			//add the properties

			//give the instance a name
			szTmpString+=CString(GROUP_NAME_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szName);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//give the instance a group id
			szTmpString+=CString(GROUP_ID_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szGroupId);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//give the instance a status
			szTmpString+=CString(GROUP_STATUS_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szStatus);
			szTmpString+=END_OF_PROPERTY_VALUE;
			
			//give the instance a description
			szTmpString+=CString(GROUP_DESCRIPTION_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szDescription);
			szTmpString+=END_OF_PROPERTY_VALUE;

			//give the instance a reference
			szTmpString+=CString(MODULE_REFERENCE_PROPERTY);
			szTmpString+=START_OF_PROPERTY_VALUE;
			szTmpString+=CString(m_szReference);
			szTmpString+=END_OF_PROPERTY_VALUE;

			szTmpString+=CString(END_OF_CLASS);
		}

		//and add the string to the serialise handle
		((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(szTmpString);
		//each class will create it's self

	}

	return *this;
}

SCODE CSmirGroupHandle :: GetModuleName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szModuleName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetGroupOID(BSTR *szGroupId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szGroupId)
		{
			*szGroupId = SysAllocString(m_szGroupId);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetStatus(BSTR *szStatus)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szStatus)
		{
			*szStatus = SysAllocString(m_szStatus);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetDescription(BSTR *szDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szDescription)
		{
			*szDescription = SysAllocString(m_szDescription);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: GetReference(BSTR *szReference)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szReference)
		{
			*szReference = SysAllocString(m_szReference);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle ::  SetModuleName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle ::  SetName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetGroupOID(BSTR szGroupId)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szGroupId,&szGroupId);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetStatus(BSTR szStatus)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szStatus,&szStatus);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetDescription(BSTR szDescription)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szDescription,&szDescription);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirGroupHandle :: SetReference(BSTR szReference)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szReference,&szReference);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*Class handle methods
 */
/*
 * CSmirClassHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirClassHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ClassHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirModuleHandle::AddRef
 * CSmirModuleHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirClassHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirClassHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirClassHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirClassHandle :: CSmirClassHandle()
: m_pIMosClass(NULL), m_szModuleName(NULL), m_szGroupName(NULL)
{
	CClassHandleClassFactory::objectsInProgress++;

	//init the reference count
	m_cRef=0;
}

CSmirClassHandle :: ~ CSmirClassHandle()
{
	if (NULL != m_pIMosClass)
		m_pIMosClass->Release();
	SysFreeString(m_szModuleName);
	SysFreeString(m_szGroupName);
	CClassHandleClassFactory::objectsInProgress--;
}

/*
 * CSmirModuleHandle::void* operator
 * validate handle
 */

CSmirClassHandle::operator void*()
{
	if((NULL!=m_szModuleName)&&(NULL!=m_szGroupName)&&(NULL!=m_pIMosClass))
		return this;
	return NULL;
}

SCODE CSmirClassHandle :: SetWBEMClass(IWbemClassObject *pObj)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pObj)
		{
			m_pIMosClass = pObj;
			m_pIMosClass->AddRef () ;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle :: GetWBEMClass (

	IWbemClassObject **pObj
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pObj) 
			return E_INVALIDARG;

		//if the class already exists return it

		if(m_pIMosClass != NULL)
		{
			m_pIMosClass->AddRef();
			*pObj=m_pIMosClass;
			return S_OK;
		}
		else
		{
			*pObj= NULL ;
			return WBEM_E_FAILED ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle ::  SetModuleName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle :: GetModuleName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szModuleName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle ::  SetGroupName(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szGroupName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirClassHandle :: GetGroupName(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			*szName=SysAllocString(m_szGroupName);
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/**************************************************************************************
 *Methods not exposed by the ISmirClassHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

SCODE CSmirClassHandle ::  AddToDB(CSmir *a_Smir,ISmirGroupHandle *hGroup)
{
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default name space
	result= CSmirAccess :: Open(a_Smir,&moServ);
	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		//if we cant open the namespace the group handle must be invalid
		return WBEM_E_FAILED;
	}
	//now commit the changes
	result = moServ->PutClass(m_pIMosClass, RESERVED_WBEM_FLAG, moContext,NULL);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return E_UNEXPECTED;
	}

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	//add the associations
	BSTR szGroupName = NULL ;
	BSTR szModuleName = NULL ;
	hGroup->GetName(&szGroupName);
	hGroup->GetModuleName(&szModuleName);

#if 0
	CSMIRToClassAssociator :: Associate(a_Smir,this);
#endif
	CGroupToClassAssociator	:: Associate(a_Smir,szModuleName, szGroupName, this);
	CModuleToClassAssociator :: Associate(a_Smir,szModuleName, this);
	SysFreeString(szGroupName);
	SysFreeString(szModuleName);
	return S_OK;
}

SCODE CSmirClassHandle ::  DeleteClassFromGroup( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMClass(&pIMosClass);
	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}

	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (NULL, &moContext);
	//SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	res= CSmirAccess :: Open(a_Smir,&moServ);
	if (FAILED(res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		pIMosClass->Release();
		return WBEM_E_FAILED;
	}
	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = NULL;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(V_BSTR(&v))
						+CString(CLOSE_BRACE_STR)
						+CString(SPACE_STR)
						+CString(SMIR_ASSOC_QUERY_STR4)
						+CString(EQUALS_STR)
						+CString(SMIR_GROUP_ASSOC_CLASS_NAME)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
							RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned;

		//loop over the associations to see how many there are
		int iAssociations=0;
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			iAssociations++;
			if(iAssociations>1)
			{
				break;
			}
		}
		if(1 == iAssociations)
		{
			//nly one so delete it
			moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
		}
		pEnum->Release();
	}
	//clean up
	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

SCODE CSmirClassHandle ::  DeleteFromDB ( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMClass(&pIMosClass);
	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}
	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (a_Smir, &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);
	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		pIMosClass->Release();
		return WBEM_E_FAILED;
	}
	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);
	if (V_VT(&v) == VT_BSTR)
	{
		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = NULL ;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(V_BSTR(&v))
						+CString(CLOSE_BRACE_STR)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned = 0;

		//loop over the associations
		VARIANT assocClass;
		VariantInit(&assocClass);
		VARIANT assocName;
		VariantInit(&assocName);
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
			pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
			CString instString(  

				CString(V_BSTR(&assocClass))
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(V_BSTR(&assocName))
				+CString(QUOTE_STR)
			);

			VariantClear(&assocName);
			VariantClear(&assocClass);

			BSTR instBString = instString.AllocSysString();
			moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
			
			SysFreeString(instBString);
			pAssocMosClass->Release();
		}
		pEnum->Release();
		//and delete it
		moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
	}
	//clean up
	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

const CSmirClassHandle& CSmirClassHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if (m_pIMosClass)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		VARIANT v;
		VariantInit(&v);
		m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);
		if (V_VT(&v) == VT_BSTR)
		{
			BSTR pszClassMof=NULL;
			HRESULT result = m_pIMosClass->GetObjectText(WBEM_FLAG_NO_FLAVORS, &pszClassMof);
			if (SUCCEEDED (result))
			{

				if(TRUE==bMOFPragmas)
				{
					//start in the SMIR namespace
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);
				}

				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(pszClassMof);
				SysFreeString(pszClassMof);

				if(TRUE==bMOFAssociations)
				{
					/*******************create the Module associations*************************/
					//instance of <assoc> \n{\n
					CString szTmpString =INSTANCE_START;
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Module="<Group>"";
					szTmpString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(MODULE_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;

					/*******************create the Group associations*************************/
					//instance of <assoc> \n{\n
					szTmpString+=INSTANCE_START;
					szTmpString+=CString(SMIR_GROUP_ASSOC_CLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=CString(SMIR_GROUP_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Group="<Group>"";
					szTmpString+=CString(SMIR_GROUP_ASSOC_GROUP_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(L"\\\\");
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(GROUP_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szGroupName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&v));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=szTmpString;
				}
			}
		}
		VariantClear(&v);
	}
	return *this;
}

/*NotificationClass handle methods
 */
/*
 * CSmirNotificationClassHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirNotificationClassHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_NotificationClassHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirNotificationClassHandle::AddRef
 * CSmirNotificationClassHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirNotificationClassHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirClassHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

ULONG CSmirNotificationClassHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

CSmirNotificationClassHandle :: CSmirNotificationClassHandle()
:	m_pIMosClass(NULL), m_szModuleName(NULL)
{
	CNotificationClassHandleClassFactory::objectsInProgress++;

	//init the reference count
	m_cRef=0;
}

CSmirNotificationClassHandle :: ~CSmirNotificationClassHandle()
{
	if (NULL != m_pIMosClass)
		m_pIMosClass->Release();
	SysFreeString(m_szModuleName);
	CNotificationClassHandleClassFactory::objectsInProgress--;
}


/*
 * CSmirModuleHandle::void* operator
 * validate handle
 */

CSmirNotificationClassHandle::operator void*()
{
	if((NULL!=m_szModuleName) && (NULL!=m_pIMosClass))
		return this;
	return NULL;
}

SCODE CSmirNotificationClassHandle :: GetWBEMNotificationClass(

	IWbemClassObject **pObj
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pObj) 
			return E_INVALIDARG;

		//if the class already exists return it

		if(m_pIMosClass)
		{
			m_pIMosClass->AddRef();
			*pObj=m_pIMosClass;
			return S_OK;
		}
		else
		{
			*pObj=NULL ;
			return WBEM_E_FAILED;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CSmirNotificationClassHandle :: SetWBEMNotificationClass(IWbemClassObject *pObj)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pObj)
		{
			m_pIMosClass = pObj;
			m_pIMosClass->AddRef () ;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirNotificationClassHandle ::  SetModule(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirNotificationClassHandle :: GetModule(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			if (NULL == m_szModuleName)
			{
				*szName = NULL;
			}
			else
			{
				*szName=SysAllocString(m_szModuleName);
			}

			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


/**************************************************************************************
 *Methods not exposed by the ISmirClassHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

SCODE CSmirNotificationClassHandle ::  AddToDB(CSmir *a_Smir)
{
	BSTR szModuleName = NULL ;
	GetModule(&szModuleName);

	if (NULL == szModuleName)
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,E_INVALIDARG);
		return WBEM_E_FAILED;
	}
	
	//open the root\default name space

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ);

	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}

	//now commit the changes
	result = moServ->PutClass(m_pIMosClass, RESERVED_WBEM_FLAG, moContext,NULL);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return E_UNEXPECTED;
	}

	if ( moContext )
		moContext->Release () ;

	moServ->Release();

	//add the associations
	CModuleToNotificationClassAssociator :: Associate(a_Smir,szModuleName, this);
	SysFreeString(szModuleName);
	CNotificationMapper :: Map(a_Smir,m_pIMosClass, SNMP_NOTIFICATION_CLASS);

	return S_OK;
}


SCODE CSmirNotificationClassHandle ::  DeleteFromDB ( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMNotificationClass(&pIMosClass);

	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}

	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (a_Smir, &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);

	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		if ( moContext )
			moContext->Release () ;

		pIMosClass->Release();
		return WBEM_E_FAILED;
	}

	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);

	if (V_VT(&v) == VT_BSTR)
	{
		CString classnamestr(V_BSTR(&v));

		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = 0;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+classnamestr
						+CString(CLOSE_BRACE_STR)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned = 0;

		//loop over the associations
		VARIANT assocClass;
		VariantInit(&assocClass);
		VARIANT assocName;
		VariantInit(&assocName);
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
			pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
			CString instString(CString(V_BSTR(&assocClass))
								+CString(EQUALS_STR)
								+CString(V_BSTR(&assocName))
									);
			VariantClear(&assocName);
			VariantClear(&assocClass);

			BSTR instBString = instString.AllocSysString();
			moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
			
			SysFreeString(instBString);
			pAssocMosClass->Release();
		}
		pEnum->Release();
		pEnum = NULL;

		//now get the mapper instance and delete that too.
		sQuery = CString(SQL_QUERY_STR1) +
					CString(SMIR_NOTIFICATION_MAPPER) +
					CString(SQL_QUERY_STR2) +
					CString(SMIR_NOTIFICATION_CLASS_PROP) +
					CString(EQUALS_STR) +
					CString(QUOTE_STR) +
					classnamestr +
					CString(QUOTE_STR);

		BSTR  szQuery2 = sQuery.AllocSysString();
		t_QueryFormat = SMIR_ASSOC_QUERY2_TYPE ;
		sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery2, 

									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery2);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		uCount=1; 
		pAssocMosClass = NULL;
		puReturned = 0;
		VariantClear(&assocClass);

		//loop over the associations and delete them
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			sRes = pAssocMosClass->Get(OLEMS_PATH_PROP, RESERVED_WBEM_FLAG,
										&assocClass, NULL, NULL);
			pAssocMosClass->Release();

			if (FAILED(sRes) && (VT_BSTR == assocClass.vt))
			{
				CString instString(V_BSTR(&assocClass));
				VariantClear(&assocClass);
				BSTR instBString = instString.AllocSysString();
				moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
				SysFreeString(instBString);
			}
		}

		pEnum->Release();
		
		//now delete the class
		moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
	}

	//clean up
	moServ->Release();
	if ( moContext )
		moContext->Release () ;

	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

const CSmirNotificationClassHandle& CSmirNotificationClassHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if (m_pIMosClass)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		VARIANT vclass;
		VariantInit(&vclass);
		VARIANT vtrapoid;
		VariantInit(&vtrapoid);

		m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &vclass,NULL,NULL);
		m_pIMosClass->Get(TRAPOID_PROP, RESERVED_WBEM_FLAG, &vtrapoid,NULL,NULL);

		if ((V_VT(&vclass) == VT_BSTR) && (V_VT(&vtrapoid) == VT_BSTR))
		{
			BSTR pszClassMof = NULL ;
			m_pIMosClass->GetObjectText(WBEM_FLAG_NO_FLAVORS, &pszClassMof);
			if (pszClassMof)
			{

				if(TRUE==bMOFPragmas)
				{
					//start in the SMIR namespace
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);
				}

				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(pszClassMof);
				SysFreeString(pszClassMof);

				/*******************create the TrapNotificationMapper*************************/
				//instance of TrapNotificationMapper \n{\n
				CString tmpString=INSTANCE_START;
				tmpString+=CString(SMIR_NOTIFICATION_MAPPER);
				tmpString+=NL_BRACE_NL_STR;

				//SnmpTrapOID
				tmpString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vtrapoid));
				tmpString+=END_OF_PROPERTY_VALUE;

				//Eventclass
				tmpString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vclass));
				tmpString+=END_OF_PROPERTY_VALUE;
			
				tmpString+=END_OF_CLASS;
				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=tmpString;

				if(TRUE==bMOFAssociations)
				{
					/*******************create the SMIR associations*************************/
					/*******************create the Module associations***********************/
					//instance of <assoc> \n{\n
					CString szTmpString=INSTANCE_START;
					szTmpString+=CString(SMIR_MODULE_ASSOC_NCLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Module="<Group>"";
					szTmpString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(MODULE_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=szTmpString;
				}
			}
		}
		VariantClear(&vclass);
		VariantClear(&vtrapoid);
	}
	return *this;
}



/*ExtNotificationClass handle methods
 */
/*
 * CSmirExtNotificationClassHandle::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirExtNotificationClassHandle::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv=this;

		if (IID_ISMIR_ExtNotificationClassHandle==riid)
			*ppv=this;

		if (NULL==*ppv)
			return ResultFromScode(E_NOINTERFACE);

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirExtNotificationClassHandle::AddRef
 * CSmirExtNotificationClassHandle::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirExtNotificationClassHandle::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
   		//CMOEvent_Trace MyTraceEvent(SMIR_STR);  
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirClassHandle::AddRef( %ld", m_cRef);

		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirExtNotificationClassHandle::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;
		if (0!=(ret=InterlockedDecrement(&m_cRef)))
			return ret;

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirExtNotificationClassHandle :: CSmirExtNotificationClassHandle()
:	m_pIMosClass (NULL), m_szModuleName(NULL)
{
	CExtNotificationClassHandleClassFactory::objectsInProgress++;

	//init the reference count
	m_cRef=0;
}

CSmirExtNotificationClassHandle :: ~CSmirExtNotificationClassHandle()
{
	if (NULL != m_pIMosClass)
		m_pIMosClass->Release();
	SysFreeString(m_szModuleName);
	CExtNotificationClassHandleClassFactory::objectsInProgress--;
}


/*
 * CSmirModuleHandle::void* operator
 * validate handle
 */

CSmirExtNotificationClassHandle::operator void*()
{
	if((NULL!=m_szModuleName) && (NULL!=m_pIMosClass))
		return this;
	return NULL;
}

SCODE CSmirExtNotificationClassHandle :: GetWBEMExtNotificationClass (

	IWbemClassObject **pObj
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (NULL == pObj) 
			return E_INVALIDARG;

		//if the class already exists return it

		if(m_pIMosClass)
		{
			m_pIMosClass->AddRef();
			*pObj=m_pIMosClass;
			return S_OK;
		}
		else
		{
			*pObj=NULL;
			return WBEM_E_FAILED;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


SCODE CSmirExtNotificationClassHandle :: SetWBEMExtNotificationClass(IWbemClassObject *pObj)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != pObj)
		{
			m_pIMosClass = pObj;
			m_pIMosClass->AddRef () ;
			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirExtNotificationClassHandle ::  SetModule(BSTR szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return CopyBSTR(&m_szModuleName,&szName);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

SCODE CSmirExtNotificationClassHandle :: GetModule(BSTR *szName)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if(NULL != szName)
		{
			if (NULL == m_szModuleName)
			{
				*szName = NULL;
			}
			else
			{
				*szName=SysAllocString(m_szModuleName);
			}

			return S_OK;
		}
		else
			return E_INVALIDARG;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


/**************************************************************************************
 *Methods not exposed by the ISmirClassHandle interface.
 *Used to encapsulate functionality.
 **************************************************************************************/

SCODE CSmirExtNotificationClassHandle ::  AddToDB ( CSmir *a_Smir )
{
	BSTR szModuleName = NULL ;
	GetModule(&szModuleName);

	if (NULL == szModuleName)
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,E_INVALIDARG);
		return WBEM_E_FAILED;
	}
	
	//open the root\default name space

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	result= CSmirAccess :: Open(a_Smir,&moServ);
	if (FAILED(result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return WBEM_E_FAILED;
	}

	//now commit the changes
	result = moServ->PutClass(m_pIMosClass, RESERVED_WBEM_FLAG, moContext,NULL);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release () ;
		return E_UNEXPECTED;
	}

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	if (FAILED(result))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,result);
		return E_UNEXPECTED;
	}

	//add the associations
	CModuleToExtNotificationClassAssociator :: Associate(a_Smir,szModuleName, this);
	SysFreeString(szModuleName);
	CNotificationMapper :: Map(a_Smir,m_pIMosClass, SNMP_EXT_NOTIFICATION_CLASS);

	return S_OK;
}

SCODE CSmirExtNotificationClassHandle ::  DeleteFromDB ( CSmir *a_Smir )
{
	//get the class
	IWbemClassObject *pIMosClass = NULL ;
	SCODE res = GetWBEMExtNotificationClass(&pIMosClass);

	if (FAILED(res))
	{
		//nothing to delete
		return S_OK;
	}

	//open the smir name space
	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	res= CSmirAccess :: GetContext (a_Smir , &moContext);
	res= CSmirAccess :: Open(a_Smir,&moServ);

	if ((S_FALSE==res)||(NULL == moServ))
	{
		//we have a problem the SMIR is not there and cannot be created
		pIMosClass->Release();
		return WBEM_E_FAILED;
	}

	//get the class name
	VARIANT v;
	VariantInit(&v);
	pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v,NULL,NULL);

	if (V_VT(&v) == VT_BSTR)
	{
		CString classnamestr(V_BSTR(&v));

		//delete everthing that is associated with the class using 
		//references of {\\.\root\default\SMIR:<class>}
		IEnumWbemClassObject *pEnum = NULL ;

		CString sQuery(CString(SMIR_ASSOC_QUERY_STR2)
						+CString(OPEN_BRACE_STR)
						+CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+classnamestr
						+CString(CLOSE_BRACE_STR)
						);
		BSTR  szQuery = sQuery.AllocSysString();
		CBString t_QueryFormat (SMIR_ASSOC_QUERY1_TYPE);
		SCODE sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		ULONG uCount=1; 
		IWbemClassObject *pAssocMosClass = NULL ;
		ULONG puReturned = 0;

		//loop over the associations
		VARIANT assocClass;
		VariantInit(&assocClass);
		VARIANT assocName;
		VariantInit(&assocName);
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			pAssocMosClass->Get(SMIR_X_ASSOC_NAME_PROP, RESERVED_WBEM_FLAG, &assocName,NULL,NULL);
			pAssocMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &assocClass,NULL,NULL);
			CString instString(CString(V_BSTR(&assocClass))
								+CString(EQUALS_STR)
								+CString(V_BSTR(&assocName))
									);
			VariantClear(&assocName);
			VariantClear(&assocClass);

			BSTR instBString = instString.AllocSysString();
			moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
			
			SysFreeString(instBString);
			pAssocMosClass->Release();
		}
		pEnum->Release();
		pEnum = NULL;

		//now get the mapper instance and delete that too.
		sQuery = CString(SQL_QUERY_STR1) +
					CString(SMIR_EXT_NOTIFICATION_MAPPER) +
					CString(SQL_QUERY_STR2) +
					CString(SMIR_NOTIFICATION_CLASS_PROP) +
					CString(EQUALS_STR) +
					CString(QUOTE_STR) +
					classnamestr +
					CString(QUOTE_STR);

		BSTR  szQuery2 = sQuery.AllocSysString();
		t_QueryFormat = SMIR_ASSOC_QUERY2_TYPE;
		sRes = moServ->ExecQuery(t_QueryFormat.GetString (), szQuery2, 
									RESERVED_WBEM_FLAG,moContext, &pEnum);
		SysFreeString(szQuery2);

		if (FAILED(sRes)||(NULL==pEnum))
		{
			//all classes are associated so this is a problem
			if ( moContext )
				moContext->Release () ;

			moServ->Release();
			pIMosClass->Release();
			return WBEM_E_FAILED;
		}

		uCount=1; 
		pAssocMosClass = NULL;
		puReturned = 0;
		VariantClear(&assocClass);

		//loop over the associations and delete them
		for(pEnum->Reset();S_OK==pEnum->Next(-1,uCount,&pAssocMosClass,&puReturned);)
		{
			sRes = pAssocMosClass->Get(OLEMS_PATH_PROP, RESERVED_WBEM_FLAG,
										&assocClass, NULL, NULL);
			pAssocMosClass->Release();

			if (FAILED(sRes) && (VT_BSTR == assocClass.vt))
			{
				CString instString(V_BSTR(&assocClass));
				VariantClear(&assocClass);
				BSTR instBString = instString.AllocSysString();
				moServ->DeleteInstance(instBString, RESERVED_WBEM_FLAG, moContext,NULL);
				SysFreeString(instBString);
			}
		}

		pEnum->Release();
		
		//now delete the class
		moServ->DeleteClass(V_BSTR(&v),RESERVED_WBEM_FLAG, moContext,NULL);
	}

	//clean up

	if ( moContext )
		moContext->Release () ;

	moServ->Release();
	pIMosClass->Release();
	VariantClear(&v);
	return S_OK;
}

const CSmirExtNotificationClassHandle& CSmirExtNotificationClassHandle :: operator >>(ISmirSerialiseHandle *pSHandle)
{
	if (m_pIMosClass)
	{
		BOOL bMOFPragmas=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFPragmas();
		BOOL bMOFAssociations=((CSmirSerialiseHandle*) pSHandle)->ReturnMOFAssociations();

		VARIANT vclass;
		VariantInit(&vclass);
		VARIANT vtrapoid;
		VariantInit(&vtrapoid);

		m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &vclass,NULL,NULL);
		m_pIMosClass->Get(TRAPOID_PROP, RESERVED_WBEM_FLAG, &vtrapoid,NULL,NULL);

		if ((V_VT(&vclass) == VT_BSTR) && (V_VT(&vtrapoid) == VT_BSTR))
		{
			BSTR pszClassMof = NULL ;
			m_pIMosClass->GetObjectText(WBEM_FLAG_NO_FLAVORS, &pszClassMof);
			if (pszClassMof)
			{

				if(TRUE==bMOFPragmas)
				{
					//start in the SMIR namespace
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(SMIR_NAMESPACE_PRAGMA);
				}

				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=CString(pszClassMof);
				SysFreeString(pszClassMof);

				/*******************create the ExtNotificationMapper*************************/
				//instance of ExtNotificationMapper \n{\n
				CString tmpString=INSTANCE_START;
				tmpString+=CString(SMIR_EXT_NOTIFICATION_MAPPER);
				tmpString+=NL_BRACE_NL_STR;

				//SnmpTrapOID
				tmpString+=CString(SMIR_NOTIFICATION_TRAP_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vtrapoid));
				tmpString+=END_OF_PROPERTY_VALUE;

				//Eventclass
				tmpString+=CString(SMIR_NOTIFICATION_CLASS_PROP);
				tmpString+=START_OF_PROPERTY_VALUE;
				tmpString+=CString(V_BSTR(&vclass));
				tmpString+=END_OF_PROPERTY_VALUE;
			
				tmpString+=END_OF_CLASS;
				((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=tmpString;

				if(TRUE==bMOFAssociations)
				{
					/*******************create the SMIR associations*************************/
					/*******************create the Module associations***********************/
					//instance of <assoc> \n{\n
					CString szTmpString=INSTANCE_START;
					szTmpString+=CString(SMIR_MODULE_ASSOC_EXTNCLASS_NAME);
					szTmpString+=NL_BRACE_NL_STR;

					//association name
					//<assoc name>=\"<name>SMIRAssociation\";\n
					szTmpString+=CString(SMIR_X_ASSOC_NAME_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//smir name
					//SmirGroup="\\\\.\\root\\default\\SMIR\\<module>:Module="<Group>"";
					szTmpString+=CString(SMIR_MODULE_ASSOC_MODULE_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(MODULE_NAMESPACE_NAME);
					szTmpString+=CString(DOT_STR);
					szTmpString+=CString(OLEMS_NAME_PROP);
					szTmpString+=CString(EQUALS_STR);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=CString(m_szModuleName);
					szTmpString+=CString(ESCAPED_QUOTE_STR);
					szTmpString+=END_OF_PROPERTY_VALUE;

					//class name
					//SmirClass="\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213-MIB_udpTable";
					szTmpString+=CString(SMIR_X_ASSOC_CLASS_PROP);
					szTmpString+=START_OF_PROPERTY_VALUE;
					szTmpString+=CString(SMIR_NAMESPACE_STR);
					szTmpString+=CString(COLON_STR);
					szTmpString+=CString(V_BSTR(&vclass));
					szTmpString+=END_OF_PROPERTY_VALUE;

				
					szTmpString+=END_OF_CLASS;
					((CSmirSerialiseHandle*)pSHandle)->m_serialiseString+=szTmpString;
				}
			}
		}
		VariantClear(&vclass);
		VariantClear(&vtrapoid);
	}
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\cthread.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*
 * CTHREAD.CPP
 *
 * Implemenations of the derived thread classed used in notification.
 */
#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include <textdef.h>
#include "enum.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

SCODE CNotifyThread :: Process()
{
	BOOL bEvent = FALSE;
	while(TRUE)
	{
		DWORD dwResult = Wait(SMIR_CHANGE_INTERVAL);

		if(WAIT_EVENT_0 == dwResult)
		{
			bEvent = TRUE;
		}
		else if(WAIT_EVENT_TERMINATED == dwResult)
		{
			return SMIR_THREAD_EXIT;
		}
		else if( (dwResult == WAIT_TIMEOUT) && bEvent)
		{
			bEvent = FALSE;
			IConnectionPoint *pNotifyCP;
			CSmir::sm_ConnectionObjects->FindConnectionPoint(IID_ISMIR_Notify, &pNotifyCP);
			((CSmirNotifyCP*)pNotifyCP)->TriggerEvent();
			pNotifyCP->Release();
			SetEvent(m_doneEvt);
			break;
		}
	}

	return SMIR_THREAD_EXIT;
}

CNotifyThread :: CNotifyThread(HANDLE* evtsarray, ULONG arraylen):CThread()
{
	//addref the smir for this thread
	m_doneEvt = evtsarray[arraylen-1];
	
	//add the events
	for (ULONG i = 0; i < (arraylen - 1); i++)
	{
		AddEvent(evtsarray[i]);
	}
}

CNotifyThread :: ~CNotifyThread()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\evtcons.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "handles.h"
#include "classfac.h"

#include <textdef.h>
#include <helper.h>
#include "bstring.h"

#include "evtcons.h"

#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif
 


/*
 * CSmirWbemEventConsumer::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown interface.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  SCODE         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirWbemEventConsumer::QueryInterface(REFIID riid, PPVOID ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		//Always NULL the out-parameters
		*ppv=NULL;

		//are we being asked for an interface we support?
		if ((IID_IUnknown == riid)  || 
			(IID_IWbemObjectSink == riid) || 
			(IID_ISMIR_WbemEventConsumer == riid) )
		{
			*ppv=this;
			((LPUNKNOWN)*ppv)->AddRef();
			return NOERROR;
		}

		//we don't support the interface being asked for...
		return ResultFromScode(E_NOINTERFACE);
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

/*
 * CSmirWbemEventConsumer::AddRef
 * CSmirWbemEventConsumer::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

ULONG CSmirWbemEventConsumer::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement(&m_cRef);
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

ULONG CSmirWbemEventConsumer::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;

		if ( 0 != (ret = InterlockedDecrement(&m_cRef)) )
		{
			return ret;
		}

		delete this;
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

CSmirWbemEventConsumer::CSmirWbemEventConsumer(CSmir* psmir) : m_hEvents (NULL), m_Serv(NULL)
{
	CSMIRClassFactory::objectsInProgress++;
	//init the reference count
	m_cRef=0;
	m_callbackThread = NULL;
	
	if (NULL == psmir)
	{
		m_hEvents = NULL;
		return;
	}

	//Create the event
	m_hEvents = new HANDLE[SMIR_EVT_COUNT];

	for (int x = 0; x < SMIR_EVT_COUNT; x++)
	{
		m_hEvents[x] = NULL;
	}

	m_hEvents[SMIR_CHANGE_EVT] = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_hEvents[SMIR_THREAD_EVT] = CreateEvent(NULL, FALSE, TRUE, NULL);
}

CSmirWbemEventConsumer :: ~CSmirWbemEventConsumer()
{
	//close the change event handle
	if(NULL != m_hEvents)
	{
		if ((NULL != m_callbackThread) && (NULL != m_hEvents[SMIR_THREAD_EVT]) && 
			(WAIT_OBJECT_0 != WaitForSingleObject(m_hEvents[SMIR_THREAD_EVT], 0)) )
		{
			m_callbackThread->Release();
		}

		for (ULONG i = 0; i < SMIR_EVT_COUNT; i++)
		{
			if (NULL != m_hEvents[i])
			{
				CloseHandle(m_hEvents[i]);
			}
		}

		delete [] m_hEvents;
	}

	if (NULL != m_Serv)
	{
		m_Serv->Release();
		m_Serv = NULL;
	}

	CSMIRClassFactory::objectsInProgress--;
}

HRESULT CSmirWbemEventConsumer::Indicate(IN long lObjectCount, IN IWbemClassObject **ppObjArray)
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ((NULL != m_hEvents) && (NULL != m_hEvents[SMIR_THREAD_EVT]))
		{
			//if thread is dead start a thread to watch for further change events
			if (WAIT_OBJECT_0 == WaitForSingleObject(m_hEvents[SMIR_THREAD_EVT], 0)) 
			{
				m_callbackThread = new CNotifyThread(m_hEvents, SMIR_EVT_COUNT);
				m_callbackThread->AddRef();
				DWORD dwThreadHandle = m_callbackThread->Start();
				if (WBEM_E_FAILED == dwThreadHandle)
				{
					m_callbackThread->Release();
					m_callbackThread = NULL;
				}

			}
			else
			{
				//set change event to restart timer
				SetEvent(m_hEvents[SMIR_CHANGE_EVT]);
			}
		}

		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CSmirWbemEventConsumer::SetStatus(IN long lFlags, IN long lParam, IN BSTR strParam,
										IN IWbemClassObject *pObjParam)
{
	return NOERROR;
}

HRESULT CSmirWbemEventConsumer::Register(CSmir* psmir)
{
	if (NULL == m_hEvents)
	{
		return WBEM_E_FAILED;
	}

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	HRESULT result= CSmirAccess :: GetContext (psmir , &moContext);
	result = CSmirAccess :: Open(psmir,&moServ);
	if ((S_FALSE==result)||(NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		//we have a problem the SMIR is not there and cannot be created
		return WBEM_E_FAILED;
	}

	BSTR t_bstrQueryType = SysAllocString(FILTER_QUERYTYPE_VAL);
	BSTR t_bstrQuery = SysAllocString(FILTER_QUERY_VAL);
	result = moServ->ExecNotificationQueryAsync( 
								t_bstrQueryType,	// [in] BSTR QueryLanguage,
								t_bstrQuery,		// [in] BSTR Query,
								0,					// [in] long lFlags,
								moContext,			// [in] IWbemContext *pCtx,
								this);				// [in] IWbemObjectSink *pResponseHandler
	SysFreeString(t_bstrQueryType);
	SysFreeString(t_bstrQuery);

	if ( moContext )
		moContext->Release () ;
	
	//keep this around for unregister...
	m_Serv = moServ;
	
	return result;
}

HRESULT CSmirWbemEventConsumer::GetUnRegisterParams(IWbemServices** ppServ)
{
	HRESULT retVal = WBEM_E_FAILED;

	if (m_Serv)
	{
		*ppServ = m_Serv;
		m_Serv = NULL;
		retVal = S_OK;
	}

	return retVal;
}


HRESULT CSmirWbemEventConsumer::UnRegister(CSmir* psmir, IWbemServices* pServ)
{
	if (NULL == m_hEvents)
	{
		return WBEM_E_FAILED;
	}

	return pServ->CancelAsyncCall(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <windows.h>
#include <provexpt.h>
#include <ocidl.h>
#include <olectl.h>
#include <objbase.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <wchar.h>
#include <process.h> 
#include <wbemidl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\helper.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include <helper.h>
#include "handles.h"
#include "classfac.h"
#include <textdef.h>
#include "bstring.h"
#include "evtcons.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif
#include <cominit.h>

extern BOOL g_initialised ;

//BSTR Helpers
SCODE CopyBSTR(BSTR *pDst, BSTR *pSrc)
{
	if(*pDst)
		SysFreeString(*pDst);
	if(*pSrc)
	{
		*pDst = SysAllocString(*pSrc);
		return S_OK;
	}
	else
		return E_INVALIDARG;
}
// {74864DA1-0630-11d0-A5B6-00AA00680C3F}
//DEFINE_GUID(CLSID_MosGateway, 
//0x74864da1, 0x630, 0x11d0, 0xa5, 0xb6, 0x0, 0xaa, 0x0, 0x68, 0xc, 0x3f);

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey,  wchar_t* pszValueName, wchar_t* pszValue);

SmirClassFactoryHelper :: SmirClassFactoryHelper()
:	pGroupHandleClassFactory(NULL), pClassHandleClassFactory(NULL),
	pModHandleClassFactory(NULL), pSMIRClassFactory(NULL),
	pNotificationClassHandleClassFactory(NULL), pExtNotificationClassHandleClassFactory(NULL)
{
}

SmirClassFactoryHelper :: ~SmirClassFactoryHelper()
{
	if(NULL != pGroupHandleClassFactory)
		pGroupHandleClassFactory->Release();
	if(NULL != pClassHandleClassFactory)
		pClassHandleClassFactory->Release();
	if(NULL != pModHandleClassFactory)
		pModHandleClassFactory->Release();
	if(NULL != pNotificationClassHandleClassFactory)
		pNotificationClassHandleClassFactory->Release();
	if(NULL != pExtNotificationClassHandleClassFactory)
		pExtNotificationClassHandleClassFactory->Release();
	if(NULL != pSMIRClassFactory )
	{
		pSMIRClassFactory->Release();
	}
}

SCODE SmirClassFactoryHelper :: CreateInstance(REFCLSID rclsid,REFIID riid, LPVOID * ppv)
{
	CSMIRGenericClassFactory *ppClassFactory = NULL ;
	SCODE result = S_OK;
	*ppv=NULL;
	
	if((CLSID_SMIR_Database==rclsid)||
				(IID_IConnectionPointContainer==rclsid))
	{
		ppClassFactory = new CSMIRClassFactory(rclsid);
	}
	else if(CLSID_SMIR_ModHandle == rclsid)
	{
		ppClassFactory = new CModHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_GroupHandle == rclsid)
	{
		ppClassFactory = new CGroupHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_ClassHandle == rclsid)
	{
		ppClassFactory = new CClassHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_NotificationClassHandle == rclsid)
	{
		ppClassFactory = new CNotificationClassHandleClassFactory(rclsid);
	}
	else if(CLSID_SMIR_ExtNotificationClassHandle == rclsid)
	{
		ppClassFactory = new CExtNotificationClassHandleClassFactory(rclsid);
	}

	ppClassFactory->AddRef();
	result = ppClassFactory->CreateInstance (NULL ,riid ,ppv);
	ppClassFactory->Release();

	if((S_OK != result)||(*ppv == NULL))
	{
		return result;
	}
	return result;
}

/* CSmirAccess
 *A simple class to open and create the smir - extended to opan any namespace
 */

void CSmirAccess :: ShutDown ()
{
	if (CSmir::sm_ConnectionObjects != NULL)
	{
		CSmir::sm_ConnectionObjects->Release ();
		CSmir::sm_ConnectionObjects = NULL ;
	}

	if(NULL != g_pClassFactoryHelper)
	{
		delete g_pClassFactoryHelper;
		g_pClassFactoryHelper = NULL;
	}
	
	//SMIR requires re-initialization!
	g_initialised = FALSE ;
}

STDMETHODIMP CSmirAccess :: Init ()
{
	return S_OK;
}

STDMETHODIMP CSmirAccess :: Open (

	CSmir *a_Smir , 
	IWbemServices **server, 
	BSTR ObjectPath, 
	BOOL relativeToSMIR
)
{
	IWbemServices *returnedServ = NULL ;
	*server=NULL;

	if (relativeToSMIR && (ObjectPath == NULL))
	{
		return WBEM_E_FAILED;
	}

	if(FAILED(Connect(a_Smir, &returnedServ, ObjectPath, relativeToSMIR)))
	{
		return WBEM_E_FAILED;
	}
	*server = returnedServ;
	return S_OK;
}

STDMETHODIMP CSmirAccess :: Open(

	CSmir *a_Smir , 
	IWbemServices **server, 
	ISmirClassHandle *hClass, 
	eOpenType eType
)
{
	if(NULL == server)
		return WBEM_E_FAILED;

	SCODE returnCode=S_OK;

	BSTR szTModstr = NULL;
	BSTR szTGroupstr = NULL;
	hClass->GetModuleName(&szTModstr);
	hClass->GetGroupName(&szTGroupstr);

	wchar_t *pTGroupNSString = NULL ;
	if(eType == eGroup)
	{
		hClass->GetGroupName(&szTGroupstr);
		pTGroupNSString = new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+wcslen(BACKSLASH_STR)+wcslen(szTGroupstr)+1];
	}
	else
	{
		hClass->GetGroupName(&szTGroupstr);
		pTGroupNSString = new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+1];
	}

	if(NULL != pTGroupNSString)
	{
		wcscpy(pTGroupNSString,szTModstr);
		//<module name>
		if(eType == eGroup)
		{	
			wcscat(pTGroupNSString,BACKSLASH_STR);
			wcscat(pTGroupNSString,szTGroupstr);
			// <module name>\<group name>
		}

		CBString t_Str ( pTGroupNSString ) ;
		SCODE result= CSmirAccess :: Open(

			a_Smir, 
			server, 
			t_Str.GetString (), 
			TRUE
		);

		delete [] pTGroupNSString;
		
		if ((FAILED(result))||(NULL == server))
		{
			//if we can't open the namespace the group handle must be invalid
			returnCode =  result;
		}
	}
	else
	{
		returnCode= E_OUTOFMEMORY;
	}

	if(FAILED(returnCode))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,returnCode);
		returnCode = (returnCode==E_OUTOFMEMORY?E_OUTOFMEMORY:WBEM_E_FAILED);
	}

	//free the string we got from hGroup
	SysFreeString(szTModstr);
	SysFreeString(szTGroupstr);

	return returnCode;
}

STDMETHODIMP CSmirAccess :: Open(

	CSmir *a_Smir , 
	IWbemServices **server, 
	ISmirGroupHandle *hGroup, 
	eOpenType eType
)
{
	if(NULL == server)
		return WBEM_E_FAILED;

	SCODE returnCode=S_OK;

	BSTR szTModstr=NULL;
	BSTR szTGroupstr=NULL;
	hGroup->GetModuleName(&szTModstr);

	wchar_t *pTGroupNSString = NULL;
	if(eType == eGroup)
	{
		hGroup->GetName(&szTGroupstr);
		pTGroupNSString =new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+wcslen(BACKSLASH_STR)+wcslen(szTGroupstr)+1];
	}
	else
	{
		pTGroupNSString =new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)
				+wcslen(szTModstr)+1];
	}

	if(NULL != pTGroupNSString)
	{
		wcscpy(pTGroupNSString,szTModstr);
		// <module name>
		if(eType == eGroup)
		{
			wcscat(pTGroupNSString,BACKSLASH_STR);
			wcscat(pTGroupNSString,szTGroupstr);
		}
		// <module name>\<group name>

		CBString t_BStr ( pTGroupNSString ) ;

		SCODE result= CSmirAccess :: Open (

			a_Smir, 
			server, 
			t_BStr.GetString (), 
			TRUE
		);

		delete [] pTGroupNSString;
		
		if ((FAILED(result))||(NULL == server))
		{
			//if we can't open the namespace the group handle must be invalid
			returnCode = result;
		}
	}
	else
	{
		returnCode = E_OUTOFMEMORY;
	}

	if(FAILED(returnCode))
	{
		FormatProviderErrorMsg(__FILE__,__LINE__,returnCode);
		returnCode = (returnCode==E_OUTOFMEMORY?E_OUTOFMEMORY:WBEM_E_FAILED);
	}

	//free the strings we got from hModule and hGroup
	SysFreeString(szTModstr);
	SysFreeString(szTGroupstr);

	return returnCode;
}

STDMETHODIMP CSmirAccess :: Open (

	CSmir *a_Smir , 
	IWbemServices **server, 
	ISmirModHandle *hMod
)
{
	if(NULL == server)
		return WBEM_E_FAILED;
	
	SCODE returnCode=S_OK;

	//open the module name space
	//build the object path
	BSTR szTstr=NULL;
	hMod->GetName(&szTstr);
	wchar_t *pTstring = new wchar_t[wcslen(SMIR_NAMESPACE)+wcslen(BACKSLASH_STR)+wcslen(szTstr)+1];

	if(NULL != pTstring)
	{
		wcscpy(pTstring,szTstr);
		// <module name>

		CBString t_BStr ( pTstring ) ;
		SCODE res = CSmirAccess :: Open (

			a_Smir, 
			server,
			t_BStr.GetString (), 
			TRUE
		);

		//clean up
		delete [] pTstring;
		
		if (FAILED(res)||(NULL == server))
		{
			returnCode = res;
		}
	}
	else
	{
		returnCode =  E_OUTOFMEMORY;
	}

	//free the string we got from hGroup
	SysFreeString(szTstr);

	if(FAILED(returnCode))
	{
		returnCode = (returnCode==E_OUTOFMEMORY?E_OUTOFMEMORY:WBEM_E_FAILED);
	}

	return S_OK;
}

STDMETHODIMP CSmirAccess :: Connect (

	IN CSmir *a_Smir , 
	OUT IWbemServices **a_Server, 
	IN BSTR a_Namespace , 
	IN BOOL a_RelativeToSMIR
)
{
	//I only have one point of failure so don't use the garbage collector
	*a_Server = NULL;

	//open the  namespace (default is the smir)

	HRESULT t_Result;

	ISMIRWbemConfiguration *t_Configuration = NULL ;
	IWbemServices *t_Service = NULL ;
	IWbemContext *t_Context = NULL;

	t_Result = a_Smir->QueryInterface (

		IID_ISMIRWbemConfiguration ,
		( void **) & t_Configuration
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Configuration->GetContext ( & t_Context ) ;
		t_Result = t_Configuration->GetServices ( & t_Service ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = WbemSetProxyBlanket(t_Service,
				RPC_C_AUTHN_DEFAULT,
				RPC_C_AUTHZ_DEFAULT,
				COLE_DEFAULT_PRINCIPAL,
				RPC_C_AUTHN_LEVEL_DEFAULT,
				RPC_C_IMP_LEVEL_DEFAULT,
				NULL,
				EOAC_DYNAMIC_CLOAKING);

			if ( FAILED ( t_Result ) && t_Result != E_NOINTERFACE )
			{
				t_Service->Release();
				t_Service = NULL;
			}
			else
			{
				t_Result = S_OK ;
			}
		}
		else
		{
			t_Result = t_Configuration->Authenticate (

				NULL,
				NULL,
				NULL,
				NULL,
				0 ,
				NULL ,
				TRUE
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Configuration->GetServices ( & t_Service ) ;
				
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = WbemSetProxyBlanket(t_Service,
						RPC_C_AUTHN_DEFAULT,
						RPC_C_AUTHZ_DEFAULT,
						COLE_DEFAULT_PRINCIPAL,
						RPC_C_AUTHN_LEVEL_DEFAULT,
						RPC_C_IMP_LEVEL_DEFAULT,
						NULL,
						EOAC_DYNAMIC_CLOAKING);

					if ( FAILED ( t_Result ) && t_Result != E_NOINTERFACE )
					{
						t_Service->Release();
						t_Service = NULL;
					}
					else
					{
						t_Result = S_OK ;
					}
				}
			}
		}

		t_Configuration->Release () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if( a_Namespace != NULL )
		{
			CBString t_BStr ( a_Namespace )  ;

			if ( a_RelativeToSMIR )
			{
				t_Result = t_Service->OpenNamespace (

					t_BStr.GetString (), 
					0,
					t_Context, 
					a_Server, 
					NULL
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = WbemSetProxyBlanket(*a_Server,
						RPC_C_AUTHN_DEFAULT,
						RPC_C_AUTHZ_DEFAULT,
						COLE_DEFAULT_PRINCIPAL,
						RPC_C_AUTHN_LEVEL_DEFAULT,
						RPC_C_IMP_LEVEL_DEFAULT,
						NULL,
						EOAC_DYNAMIC_CLOAKING);

					if ( FAILED ( t_Result )  && t_Result != E_NOINTERFACE )
					{
						(*a_Server)->Release();
						(*a_Server) = NULL;
					}
					else
					{
						t_Result = S_OK ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}

			t_Service->Release () ;
		}
		else
		{
			*a_Server = t_Service ;
		}
	}

	if ( t_Context )
		t_Context->Release();
 
	return t_Result ;
}

STDMETHODIMP CSmirAccess :: GetContext (

	IN CSmir *a_Smir , 
	OUT IWbemContext **a_Context
)
{
	//I only have one point of failure so don't use the garbage collector
	*a_Context = NULL;

	//open the  namespace (default is the smir)

	HRESULT t_Result;

	ISMIRWbemConfiguration *t_Configuration = NULL ;

	t_Result = a_Smir->QueryInterface (

		IID_ISMIRWbemConfiguration ,
		( void **) & t_Configuration
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Configuration->GetContext ( a_Context ) ;
		t_Configuration->Release () ;
	}

	return t_Result ;
}

void FormatProviderErrorMsg(char*file, int line, SCODE errorCode)
{
	//use the strings
	switch (errorCode)
	{
		case WBEM_NO_ERROR:
		break;
		case WBEM_S_NO_MORE_DATA:
		break;
		case WBEM_E_FAILED:
		break;
		case WBEM_E_NOT_FOUND:
		break;
		case WBEM_E_ACCESS_DENIED:
		break;
		case WBEM_E_PROVIDER_FAILURE:
		break;
		case WBEM_E_TYPE_MISMATCH:
		break;
		case WBEM_E_OUT_OF_MEMORY:
		break;
		case WBEM_E_INVALID_CONTEXT:
		break;
		case WBEM_E_INVALID_PARAMETER:
		break;
		case WBEM_E_NOT_AVAILABLE:
		break;
		case WBEM_E_CRITICAL_ERROR:
		break;
		case WBEM_E_INVALID_STREAM:
		break;
		case WBEM_E_NOT_SUPPORTED:
		break;
		case WBEM_E_INVALID_SUPERCLASS:
		break;
		case WBEM_E_INVALID_NAMESPACE:
		break;
		case WBEM_E_INVALID_OBJECT:
		break;
		case WBEM_E_INVALID_CLASS:
		break;
		case WBEM_E_PROVIDER_NOT_FOUND:
		break;
		case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		break;
		case WBEM_E_PROVIDER_LOAD_FAILURE:
		break;
		case WBEM_E_INITIALIZATION_FAILURE:
		break;
		case WBEM_E_INVALID_OPERATION:
		break;
		case WBEM_E_INVALID_QUERY:
		break;
		case WBEM_E_INVALID_QUERY_TYPE:
		break;
		case E_INVALIDARG:
		break;
		case E_UNEXPECTED:
		break;
		case E_OUTOFMEMORY:
		break;
		default:
		break;
	}
}

SCODE CGroupToClassAssociator :: Associate (

	CSmir *a_Smir,
	BSTR szModuleName, 
	BSTR szGroupName, 
	ISmirClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName)||(NULL==szGroupName))
		return WBEM_E_FAILED;

	IWbemServices *moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_GROUP_ASSOC_CLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
													RESERVED_WBEM_FLAG,  &v,NULL,NULL);
	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	CString associationClassName(CString(szClassName)
						+CString(SMIR_GROUP_ASSOC_CLASS_NAME_POSTFIX));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		SysFreeString(szClassName);
		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	//don't need this anymore
	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a group property**********************************/
	//get the fully qualified class name
	//group = "\\\\.\\root\\default\\SMIR\\RFC1213_MIB:Group=\"atV1ObjectGroup\"";
	CString groupPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(BACKSLASH_STR)
				+CString(szModuleName)
				+CString(COLON_STR)
				+CString(GROUP_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szGroupName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=groupPath.AllocSysString();
	result = pInst->Put(SMIR_GROUP_ASSOC_GROUP_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it
	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR\RFC1316-MIB:Group="charV1ObjectGroup"}
	 *or
	 *associators of {\\.\root\default\SMIR\RFC1213-MIB:Group="atV1ObjectGroup"}
		 */
	return S_OK;
}

SCODE CModuleToClassAssociator :: Associate (

	CSmir *a_Smir,
	BSTR szModuleName, 
	ISmirClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName))
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_MODULE_ASSOC_CLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
												RESERVED_WBEM_FLAG,  &v,NULL,NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX));

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		SysFreeString(szClassName);
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a group property**********************************/
	//get the fully qualified class name
	//group = "\\\\.\\root\\default\\SMIR:Module=\"RFC1213_MIB\"";
	CString groupPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(COLON_STR)
				+CString(MODULE_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szModuleName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=groupPath.AllocSysString();
	result = pInst->Put(SMIR_MODULE_ASSOC_MODULE_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"}
	     */
	return S_OK;
}

SCODE CModuleToNotificationClassAssociator :: Associate (

	CSmir *a_Smir,
	BSTR szModuleName, 
	ISmirNotificationClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName))
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_MODULE_ASSOC_NCLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirNotificationClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
												RESERVED_WBEM_FLAG,  &v,NULL,NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX));

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		SysFreeString(szClassName);
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a module property**********************************/
	//get the fully qualified class name
	//module = "\\\\.\\root\\default\\SMIR:Module=\"RFC1213_MIB\"";
	CString modPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(COLON_STR)
				+CString(MODULE_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szModuleName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=modPath.AllocSysString();
	result = pInst->Put(SMIR_MODULE_ASSOC_MODULE_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);
	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"}
	     */
	return S_OK;
}

SCODE CModuleToExtNotificationClassAssociator :: Associate(

	CSmir *a_Smir,
	BSTR szModuleName, 
	ISmirExtNotificationClassHandle *hClass
)
{
	if ((NULL == hClass)||(NULL==szModuleName))
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL ;
	CBString t_BStr ( SMIR_MODULE_ASSOC_EXTNCLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString (), 0, 
									moContext,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = ((CSmirExtNotificationClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, 
												RESERVED_WBEM_FLAG,  &v,NULL,NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX));

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		SysFreeString(szClassName);
		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	SysFreeString(szClassName);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************give it a module property**********************************/
	//get the fully qualified class name
	//module = "\\\\.\\root\\default\\SMIR:Module=\"RFC1213_MIB\"";
	CString modPath(CString(SMIR_NAMESPACE_FROM_ROOT)
				+CString(COLON_STR)
				+CString(MODULE_NAMESPACE_NAME)
				+CString(DOT_STR)
				+CString(OLEMS_NAME_PROP)
				+CString(EQUALS_STR)
				+CString(QUOTE_STR)
				+CString(szModuleName)
				+CString(QUOTE_STR));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=modPath.AllocSysString();
	result = pInst->Put(SMIR_MODULE_ASSOC_MODULE_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR:Module="RFC1213_MIB"}
	     */
	return S_OK;
}

SCODE CSMIRToClassAssociator :: Associate (

	CSmir *a_Smir,
	ISmirClassHandle *hClass
)
{
	if (NULL == hClass)
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL ;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);
	//open the root\default\SMIR namespace
	CSmirAccess :: Open(a_Smir,&moServ);

	//get an object
	IWbemClassObject *pClass = NULL;
	CBString t_BStr ( SMIR_ASSOC_CLASS_NAME ) ;
	result = moServ->GetObject(t_BStr.GetString () , 0, 
									NULL,&pClass, NULL);

	if ((FAILED(result))||(NULL == pClass))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	//make an instance
	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//get the class name
	result  = ((CSmirClassHandle*)hClass)->m_pIMosClass->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG,  &v,NULL,NULL);
	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}

	BSTR szClassName = SysAllocString(V_BSTR(&v));
	VariantClear(&v);

	/****************give it a class property**********************************/
	//get the fully qualified class name
	//classes = "\\\\.\\root\\default\\SMIR:MS_SNMP_RFC1213_MIB_atTable";
	CString classPath(CString(SMIR_NAMESPACE_FROM_ROOT)
						+CString(COLON_STR)
						+CString(szClassName));

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=classPath.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a Name property**********************************/
	V_VT(&v) = VT_BSTR;
	CString associationClassName(CString(szClassName)
						+CString(SMIR_ASSOC_CLASS_NAME_POSTFIX));

	SysFreeString(szClassName);

	V_BSTR(&v)=associationClassName.AllocSysString();
	result = pInst->Put(SMIR_X_ASSOC_NAME_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	/****************give it a smir property**********************************/
	//get the fully qualified class name
	//smir = "\\\\.\\root\\default\\SMIR";
	CString smirPath(SMIR_CLASS_ASSOCIATION_ENDPOINT);

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v)=smirPath.AllocSysString();
	result = pInst->Put(SMIR_ASSOC_SMIR_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);
	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		pInst->Release();
		moServ->Release();
		return WBEM_E_FAILED;
	}
	
	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;
	pInst->Release();
	moServ->Release();
	/*the query to find the classes is
	 *associators of {\\.\root\default\SMIR\RFC1316-MIB:Group="charV1ObjectGroup"}
	 *or
	 *associators of {\\.\root\default\SMIR\RFC1213-MIB:Group="atV1ObjectGroup"}
		 */
	return S_OK;
}

SCODE CNotificationMapper :: Map (

	CSmir *a_Smir,
	IWbemClassObject *pObj, 
	enum NotificationMapperType type
)
{
	if (NULL == pObj)
		return WBEM_E_FAILED;

	IWbemServices *	moServ = NULL;
	IWbemContext *moContext = NULL ;
	SCODE result= CSmirAccess :: GetContext (a_Smir , &moContext);

	//open the root\default\SMIR namespace
	result = CSmirAccess :: Open(a_Smir,&moServ);

	if ((FAILED(result)) || (NULL == moServ))
	{
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	//get an object
	IWbemClassObject *pClass = NULL;

	if (SNMP_NOTIFICATION_CLASS == type)
	{
		CBString t_BStr ( SMIR_NOTIFICATION_MAPPER ) ;
		result = moServ->GetObject(t_BStr.GetString (), 0, moContext, &pClass, NULL); 
	}
	else if (SNMP_EXT_NOTIFICATION_CLASS == type)
	{
		CBString t_BStr ( SMIR_EXT_NOTIFICATION_MAPPER ) ;
		result = moServ->GetObject(t_BStr.GetString (), 0, moContext,&pClass, NULL); 
	}

	if ((FAILED(result))||(NULL == pClass))
	{
		moServ->Release();
		if ( moContext )
			moContext->Release () ;

		return WBEM_E_FAILED;
	}

	IWbemClassObject *pInst = NULL ;
	result = pClass->SpawnInstance ( 0 , &pInst ) ;
	pClass->Release ();

	if ((FAILED(result))||(NULL==pInst))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		return WBEM_E_FAILED;
	}

	VARIANT v;
	VariantInit(&v);

	//Get the class name
	result  = pObj->Get(OLEMS_CLASS_PROP, RESERVED_WBEM_FLAG, &v, NULL, NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}
	
	/****************Set the eventclass property********************************/
	result = pInst->Put(SMIR_NOTIFICATION_CLASS_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	//Get the trapoid
	result  = pObj->Get(TRAPOID_PROP, RESERVED_WBEM_FLAG, &v, NULL, NULL);

	if ((FAILED(result))|(V_VT(&v) != VT_BSTR))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	/****************Set the trapoid property********************************/
	result = pInst->Put(SMIR_NOTIFICATION_TRAP_PROP,RESERVED_WBEM_FLAG, &v,0);
	VariantClear(&v);

	if (FAILED(result))
	{
		if ( moContext )
			moContext->Release () ;

		moServ->Release();
		pInst->Release();
		return WBEM_E_FAILED;
	}

	//now save it

	result = moServ->PutInstance(pInst, RESERVED_WBEM_FLAG, moContext,NULL);

	if ( moContext )
		moContext->Release () ;

	pInst->Release();
	moServ->Release();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\maindll.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef INITGUID
#define INITGUID
#endif


#include <precomp.h>
#include <initguid.h>
#include "smir.h"
#include "csmir.h"
#include "handles.h"
#include "classfac.h"
#include "textdef.h"
#include "thread.h"
#include "helper.h"
#include <scopeguard.h>

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey,  wchar_t* pszValueName, wchar_t* pszValue);


//Globals Bah!

BOOL g_initialised = FALSE ;

//OK we need this one
HINSTANCE   g_hInst;
//and this is a thread safe speed up
SmirClassFactoryHelper *g_pClassFactoryHelper=NULL;
CSmirConnObject* CSmir::sm_ConnectionObjects = NULL;

CRITICAL_SECTION g_CriticalSection ;


//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

static bool g_csInitialized = false;
BOOL APIENTRY DllMain (HINSTANCE hInstance, ULONG ulReason , LPVOID pvReserved)
{
	BOOL status = TRUE;
	
	/*remember the instance handle to the dll so that we can use it in
	 *register dll
	 */
	g_hInst=hInstance;
	SetStructuredExceptionHandler seh;


	try
	{
		switch (ulReason)
		{
			case DLL_PROCESS_ATTACH:
			{
				g_csInitialized = InitializeCriticalSectionAndSpinCount ( & g_CriticalSection, 4000 ) != 0 ;
				DisableThreadLibraryCalls(hInstance);
				status = g_csInitialized == true;
			}
			break;
			case DLL_PROCESS_DETACH:
			{
				CThread :: ProcessDetach();
				if (g_csInitialized)
				{
					DeleteCriticalSection ( & g_CriticalSection ) ;
				}
				//release the helper

			}
			break;
			//if DisableThreadLibraryCalls() worked these will never be called
			case DLL_THREAD_DETACH:
			case DLL_THREAD_ATTACH:
			{
			}
			break;
			default:
			{
				status = FALSE;
			}
			break;
		}
	}
	catch(Structured_Exception e_SE)
	{
		status = FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		status = FALSE;
	}
	catch(...)
	{
		status = FALSE;
	}

    return status ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (REFCLSID rclsid , REFIID riid, void **ppv)
{
	HRESULT status = S_OK ;
	SetStructuredExceptionHandler seh;

	
	try
	{
		EnterCriticalSection ( & g_CriticalSection ) ;
		ON_BLOCK_EXIT(LeaveCriticalSection, &g_CriticalSection);	
		if ( !g_initialised )
		{
			/*I don't do anything in thread attach and
			 *detach so do give them to me
			 */
			//BOOL bCallsDisabled;
			//bCallsDisabled=DisableThreadLibraryCalls(hInstance);

			//initialise the helper
			if (S_OK != CSmirAccess :: Init())
			{
				status = FALSE;
			}
			else
			{
				//allocate the cached class factory
				if(NULL == g_pClassFactoryHelper)
					g_pClassFactoryHelper= new SmirClassFactoryHelper;
				status = TRUE ;
			}

			g_initialised = TRUE ;
		}

		CSMIRGenericClassFactory *lpClassFac = NULL;
		
		if((CLSID_SMIR_Database==rclsid)||
						(IID_IConnectionPointContainer ==rclsid))
		{
			lpClassFac = new CSMIRClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_ModHandle==rclsid)
		{
			lpClassFac = new CModHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_GroupHandle==rclsid)
		{
			lpClassFac = new CGroupHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_ClassHandle==rclsid)
		{
			lpClassFac = new CClassHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_NotificationClassHandle==rclsid)
		{
			lpClassFac = new CNotificationClassHandleClassFactory(rclsid) ;
		}
		else if(CLSID_SMIR_ExtNotificationClassHandle==rclsid)
		{
			lpClassFac = new CExtNotificationClassHandleClassFactory(rclsid) ;
		}
		else
		{
			//the caller has asked for an interface I don't support
			return(CLASS_E_CLASSNOTAVAILABLE);
		}

		if (NULL==lpClassFac)
		{
			return(E_OUTOFMEMORY);
		}

		status = lpClassFac->QueryInterface (riid , ppv) ;
		if (FAILED(status))
		{
			delete lpClassFac;
		}

	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be unloaded.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		EnterCriticalSection ( & g_CriticalSection ) ;
		ON_BLOCK_EXIT(LeaveCriticalSection, &g_CriticalSection);		

		BOOL unload = (0 == CSMIRClassFactory :: locksInProgress) && 
					  (0 == CSMIRClassFactory :: objectsInProgress) &&
					  (0 == CModHandleClassFactory :: locksInProgress) && 
					  (0 == CModHandleClassFactory :: objectsInProgress) &&
					  (0 == CGroupHandleClassFactory :: locksInProgress) && 
					  (0 == CGroupHandleClassFactory :: objectsInProgress) &&
					  (0 == CClassHandleClassFactory :: locksInProgress) && 
					  (0 == CClassHandleClassFactory :: objectsInProgress) &&
					  (0 == CNotificationClassHandleClassFactory :: locksInProgress) && 
					  (0 == CNotificationClassHandleClassFactory :: objectsInProgress) &&
					  (0 == CExtNotificationClassHandleClassFactory :: locksInProgress) && 
					  (0 == CExtNotificationClassHandleClassFactory :: objectsInProgress);

		if ( unload )
			CSmirAccess :: ShutDown();

		return ResultFromScode(unload?S_OK:S_FALSE);
	}
	catch(Structured_Exception e_SE)
	{
		return S_FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		return S_FALSE;
	}
	catch(...)
	{
		return S_FALSE;
	}
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllRegisterServer()
{
	SetStructuredExceptionHandler seh;

	try
	{
		wchar_t szID[NUMBER_OF_SMIR_INTERFACES][128];
		LPTSTR szModule[512];

		/*life would be easier if I could create a pointer to a reference
		 *but I can't so I have to hand create each root string before creating
		 *the registry entries.
		 */

		//Create some base key strings.
		
		//one for the interrogative interface
		int iRet = StringFromGUID2(CLSID_SMIR_Database,(wchar_t*)&szID[0], 128);
		
		//one for the module handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ModHandle, (wchar_t*)&szID[1], 128);

		//one for the group handle interface
		iRet = StringFromGUID2(CLSID_SMIR_GroupHandle, (wchar_t*)&szID[2], 128);

		//one for the class handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ClassHandle, (wchar_t*)&szID[3], 128);

		//one for the notificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_NotificationClassHandle, (wchar_t*)&szID[4], 128);

		//one for the extnotificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ExtNotificationClassHandle, (wchar_t*)&szID[5], 128);

		for (int i=0;i<NUMBER_OF_SMIR_INTERFACES;i++)
		{
			wchar_t szCLSID[128];
			wcscpy((wchar_t*)szCLSID, CLSID_STR);
			wcscat((wchar_t*)szCLSID,(wchar_t*)&szID[i]);

			//Create entries under CLSID
			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, NULL, NULL, SMIR_NAME_STR))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, NOT_INTERT_STR, NULL, NULL))
				return SELFREG_E_CLASS;

			GetModuleFileName(g_hInst, (wchar_t*)szModule
				, sizeof(szModule)/sizeof(wchar_t));
			
			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, INPROC32_STR, NULL,(wchar_t*) szModule))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue((wchar_t*)szCLSID, INPROC32_STR,
					THREADING_MODULE_STR, APARTMENT_STR))
				return SELFREG_E_CLASS;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		wchar_t szID[128];
		wchar_t szCLSID[NUMBER_OF_SMIR_INTERFACES][128];
		wchar_t szTemp[256];

		//one for the smir interface
		int iRet = StringFromGUID2(CLSID_SMIR_Database, szID, 128);
		wcscpy((wchar_t*)szCLSID[0], CLSID_STR);
		wcscat((wchar_t*)szCLSID[0], szID);
		
		//one for the module handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ModHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[1], CLSID_STR);
		wcscat((wchar_t*)szCLSID[1], szID);

		//one for the group handle interface
		iRet = StringFromGUID2(CLSID_SMIR_GroupHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[2], CLSID_STR);
		wcscat((wchar_t*)szCLSID[2], szID);

		//one for the class handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ClassHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[3], CLSID_STR);
		wcscat((wchar_t*)szCLSID[3],szID);

		//one for the notificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_NotificationClassHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[4], CLSID_STR);
		wcscat((wchar_t*)szCLSID[4], szID);

		//one for the extnotificationclass handle interface
		iRet = StringFromGUID2(CLSID_SMIR_ExtNotificationClassHandle, szID, 128);
		wcscpy((wchar_t*)szCLSID[5], CLSID_STR);
		wcscat((wchar_t*)szCLSID[5], szID);

		for (int i=0;i<NUMBER_OF_SMIR_INTERFACES;i++)
		{
			wsprintf(szTemp, REG_FORMAT_STR, (wchar_t*)&szCLSID[i], NOT_INTERT_STR);
			RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

			wsprintf(szTemp, REG_FORMAT_STR, (wchar_t*)&szCLSID[i], INPROC32_STR);
			RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

			RegDeleteKey(HKEY_LOCAL_MACHINE, (wchar_t*)&szCLSID[i]);
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

    return S_OK;
 }

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256] = { L'\0' };

	wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
		wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
	, szKey, 0, NULL, REG_OPTION_NON_VOLATILE
	, KEY_ALL_ACCESS, NULL, &hKey, NULL))
	return FALSE;

    if (NULL!=pszValue)
    {
	if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
        , (lstrlen(pszValue)+1)*sizeof(wchar_t))){
            RegCloseKey(hKey);
			return FALSE;
        }
    }
    RegCloseKey(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\thread.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*
 * THREAD.CPP
 *
 * Implemenation of thread wrapper class.
 */
#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include "thread.h"
#include <textdef.h>
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

ThreadMap <CThread*, CThread*, CThread*,CThread*> CThread :: m_ThreadMap ;
CThread :: CThread()
{
	m_cRef=1;
	bWaiting=FALSE;
	m_ulThreadHandle = NULL;
	m_hThreadStopEvent= NULL;
	if(NULL == (m_hThreadStopEvent = CreateEvent(NULL, FALSE, 
								FALSE, NULL)))
	{
		// WBEM_E_FAILED;
	}

	if(NULL == (m_hThreadSyncEvent = CreateEvent(NULL, FALSE, 
								FALSE, NULL)))
	{
		// WBEM_E_FAILED;
	}
	m_ThreadMap.SetAt(this,this);	
}
CThread::operator void*()
{
	if((NULL != m_hThreadStopEvent) && (NULL != m_hThreadStopEvent))
	{
		//the thread has been created
    	return this;
	}
	else
	{
		//the thread is invalid
    	return (void*)NULL;
	}

}
ULONG CThread :: Release()
{
    if (0!=--m_cRef)
	{
        return m_cRef;
	}
    delete this;
    return 0;
}
CThread:: ~CThread()
{
	//clean-up
	if(m_hThreadStopEvent)
	{
		CloseHandle(m_hThreadStopEvent);
	}
	if(m_hThreadSyncEvent)
	{
		CloseHandle(m_hThreadSyncEvent);
	}
	m_ThreadMap.RemoveKey(this);
}
void __cdecl GenericThreadProc(void *arglist)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT hr = CoInitialize(NULL);

		if (SUCCEEDED(hr))
		{
			try
			{
				CThread *pThreadObject = (CThread*) arglist;
				if(S_OK == hr)
				{
					hr = pThreadObject->Process();
					if(SMIR_THREAD_DELETED != hr)
					{
						pThreadObject->Exit();
					}
					//else the thread has just been deleted
				}
			}
			catch(...)
			{
				CoUninitialize();
				throw;
			}

			CoUninitialize();
		}
	}
	catch(Structured_Exception e_SE)
	{
		return;
	}
	catch(Heap_Exception e_HE)
	{
		return;
	}
	catch(...)
	{
		return;
	}
}

#pragma warning (disable:4018)

SCODE CThread :: Wait(DWORD timeout)
{
	//create an array of wait events
	int iNumberOfEvents = m_UserEvents.GetCount()+1;
	HANDLE *lpHandles = new HANDLE[iNumberOfEvents];
	POSITION  rNextPosition;
    UINT      iLoop=0;
	for(rNextPosition=m_UserEvents.GetStartPosition();
		(NULL!=rNextPosition)&&(iLoop<iNumberOfEvents);iLoop++)
	{
		HANDLE	  lKey =  0;
		HANDLE pItem = NULL;
		m_UserEvents.GetNextAssoc(rNextPosition, lKey, pItem );
		lpHandles[iLoop] = pItem;
	}

	lpHandles[iNumberOfEvents-1] = m_hThreadStopEvent;

	//signal to the exit code that we are waiting
	bWaiting =TRUE;
	//wait for an event to fire
	DWORD dwResult = WaitForMultipleObjects(iNumberOfEvents,
												lpHandles, FALSE, timeout);
	bWaiting =FALSE;
	delete [] lpHandles;

	if(dwResult == iNumberOfEvents-1)
	{
		//thread stopped
		return WAIT_EVENT_TERMINATED;
	}
	else if (( ( dwResult<(iNumberOfEvents-1) ) ) ||
			 (dwResult == WAIT_TIMEOUT) )
	{
		//a user event fired
		return dwResult;
	}
	else if ((WAIT_ABANDONED_0 >= dwResult)&&(dwResult<(WAIT_ABANDONED_0+iNumberOfEvents)))
	{
		//it gave up
		return (WAIT_EVENT_ABANDONED+(dwResult-WAIT_ABANDONED_0)-1);
	}
	//else the wait call failed
	return WAIT_EVENT_FAILED;
}

#pragma warning (default:4018)

SCODE CThread :: Start()
{
	//kick of the thread
	if(NULL == (void*)*this)
	{
		//creation failed
		return WBEM_E_FAILED;
	}
	if(NULL != m_ulThreadHandle)
	{
		//already running
		return THREAD_STARED;
	}
	if(-1==(m_ulThreadHandle = _beginthread (&GenericThreadProc, 0,((void*) this))))
	{
		//begin thread failed
		return WBEM_E_FAILED;
	}

	return S_OK;
}
SCODE CThread :: Stop ()
{
	if(NULL==(void*)(*this)||(-1 == m_ulThreadHandle))
	{
		return WBEM_E_FAILED;
	}
	//terminate the thread if someone is waiting for it
	if(bWaiting)
	{
		SetEvent(m_hThreadStopEvent);
		WaitForSingleObject(m_hThreadSyncEvent,INFINITE);
	}
	//else just exit
	return S_OK;
}
void CThread :: ProcessDetach()
{
	POSITION  rNextPosition;
    UINT      iLoop=0;
	for(rNextPosition=m_ThreadMap.GetStartPosition();
		NULL!=rNextPosition;iLoop++)
	{
		CThread	  *plKey =  0;
		CThread *pItem = NULL;
		m_ThreadMap.GetNextAssoc(rNextPosition, plKey, pItem );
		pItem->Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\smirevt.cpp ===
//***************************************************************************
//
//  File:	
//
//  Module: MS SNMP Provider
//
//  Purpose: 
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*
 * SMIREVT.CPP
 *
 * Implemenation of a connection point object for the SMIR notify mechanism.
 * The methods/objects in this file are accessed by the SMIR API; the API
 * provides a user friendly interface to ISMIRNotify.
 */
#include <precomp.h>
#include "csmir.h"
#include "smir.h"
#include "handles.h"
#include "classfac.h"
#include <textdef.h>
#include "evtcons.h"
#ifdef ICECAP_PROFILE
#include <icapexp.h>
#endif

// scope guard
#include <autoptr.h>

extern CRITICAL_SECTION g_CriticalSection ;


/**********************************************************************************
 * CSmirConnectionPoint
 *
 * Connectpoint implementation that supports the interface ISMIRNotify.
 *
 * CSmirConnObject::CSmirConnObject
 * CSmirConnObject::~CSmirConnObject
 ***********************************************************************************/
/*
 * CSmirConnectionPoint::CSmirConnectionPoint
 * CSmirConnectionPoint::~CSmirConnectionPoint
 *
 * Parameters (Constructor):
 *  pObj            PCSmirConnObject of the object we're in.  We can
 *                  query this for the IConnectionPointContainer
 *                  interface we might need.
 *  riid            REFIID of the interface we're supporting
 ***********************************************************************************/

CSmirConnectionPoint::CSmirConnectionPoint(PCSmirConnObject pObj, REFIID riid, CSmir *pSmir)
{
    m_cRef=0;
    m_iid=riid;
    /*
     * Our lifetime is controlled by the connectable object itself,
     * although other external clients will call AddRef and Release.
     * Since we're nested in the connectable object's lifetime,
     * there's no need to call AddRef on pObj.
     */
    m_pObj=pObj;
    m_dwCookieNext=100;       //Arbitrary starting cookie value
}

CSmirConnectionPoint::~CSmirConnectionPoint(void)
{
	DWORD	  lKey =  0;
	LPUNKNOWN pItem = NULL;
	POSITION  rNextPosition;
	for(rNextPosition=m_Connections.GetStartPosition();NULL!=rNextPosition;)
	{
		m_Connections.GetNextAssoc(rNextPosition, lKey, pItem );
		pItem->Release();
	}
	m_Connections.RemoveAll();

    return;
}

/*
 * CSmirConnectionPoint::QueryInterface
 * CSmirConnectionPoint::AddRef
 * CSmirConnectionPoint::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CSmirConnectionPoint.
 */

STDMETHODIMP CSmirConnectionPoint::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if ((IID_IUnknown == riid) || 
			(IID_IConnectionPoint == riid)|| 
				(IID_ISMIR_Notify == riid))
        *ppv=(LPVOID)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSmirConnectionPoint::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSmirConnectionPoint::Release(void)
{
	long ret;
    if (0!=(ret=InterlockedDecrement(&m_cRef)))
        return ret;

    delete this;
    return 0;
}

/*
 * CSmirConnectionPoint::GetConnectionInterface
 *
 * Purpose:
 *  Returns the IID of the outgoing interface supported through
 *  this connection point.
 *
 * Parameters:
 *  pIID            IID * in which to store the IID.
 */

STDMETHODIMP CSmirConnectionPoint::GetConnectionInterface(IID *pIID)
{
    if (NULL==pIID)
        return ResultFromScode(E_POINTER);

    *pIID=m_iid;
    return NOERROR;
}

/*
 * CSmirConnectionPoint::GetConnectionPointContainer
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPointContainer that
 *  is manageing this connection point.
 *
 * Parameters:
 *  ppCPC           IConnectionPointContainer ** in which to return
 *                  the pointer after calling AddRef.
 */

STDMETHODIMP CSmirConnectionPoint::GetConnectionPointContainer
    (IConnectionPointContainer **ppCPC)
 {
    return m_pObj->QueryInterface(IID_IConnectionPointContainer
        , (void **)ppCPC);
 }

/*
 * CSmirConnectionPoint::Advise
 *
 * Purpose:
 *  Provides this connection point with a notification sink to
 *  call whenever the appropriate outgoing function/event occurs.
 *
 * Parameters:
 *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection
 *                  point must QueryInterface on this pointer to obtain
 *                  the proper interface to call.  The connection
 *                  point must also insure that any pointer held has
 *                  a reference count (QueryInterface will do it).
 *  pdwCookie       DWORD * in which to store the connection key for
 *                  later calls to Unadvise.
 */

STDMETHODIMP CSmirConnectionPoint::Advise(LPUNKNOWN pUnkSink
    , DWORD *pdwCookie)
{
    *pdwCookie=0;
	if (NULL == pUnkSink)
		return E_POINTER;

	/*
     * Verify that the sink has the interface it's supposed
     * to.  We don't have to know what it is because we have
     * m_iid to describe it.  If this works, then we 
     * have a pointer with an AddRef that we can save.
     */
    IUnknown       *pSink = NULL ;
    if (FAILED(pUnkSink->QueryInterface(m_iid, (PPVOID)&pSink)))
    {
		return CONNECT_E_CANNOTCONNECT;
	}
    
    //We got the sink, now store it. 
	*pdwCookie = InterlockedIncrement(&m_dwCookieNext);

	m_Connections.SetAt(*pdwCookie,pSink);
	/*Add ref the smir to make sure that this stays in memory for the lifetime of the 
	 *sink. The release is in unadvise.
	 */
    return S_OK;
}

/*
 * CSmirConnectionPoint::Unadvise
 *
 * Purpose:
 *  Terminates the connection to the notification sink identified
 *  with dwCookie (that was returned from Advise).  The connection
 *  point has to Release any held pointers for that sink.
 *
 * Parameters:
 *  dwCookie        DWORD connection key from Advise.
 */

STDMETHODIMP CSmirConnectionPoint::Unadvise(DWORD dwCookie)
{
	//the only invalid cookie is 0
    if (0==dwCookie)
	{
		//MyTraceEvent.Generate(__FILE__,__LINE__, "CSmirConnectionPoint::Unadvise E_INVALIDARG");
        return E_UNEXPECTED;
	}
	LPUNKNOWN pSink = NULL;
	//stop anyone else unadvising with the same cookie
	criticalSection.Lock () ;
	if(TRUE == m_Connections.Lookup(dwCookie,pSink))
	{
		m_Connections.RemoveKey(dwCookie);
		//having removed the key the look up will fail so we can release the critical section
		criticalSection.Unlock () ;
		pSink->Release();
		/*release the smir. This could cause the smir to unload from memory! Do not do
		 *anything after this because we are (ultimatly) owned by the smir object
		 */

		return S_OK;
	}
	criticalSection.Unlock () ;
    return CONNECT_E_NOCONNECTION;
}
/*
 * CSmirConnectionPoint::EnumConnections
 *
 * Purpose:
 *  Creates and returns an enumerator object with the
 *  IEnumConnections interface that will enumerate the IUnknown
 *  pointers of each connected sink.
 *
 * Parameters:
 *  ppEnum          LPENUMCONNECTIONS in which to store the
 *                  IEnumConnections pointer.
 */

STDMETHODIMP CSmirConnectionPoint::EnumConnections(LPENUMCONNECTIONS *ppEnum)
{
    LPCONNECTDATA       pCD = NULL;
    PCEnumConnections   pEnum = NULL;

	//NULL the IN parameter
    *ppEnum=NULL;

	//check that we have some connections
    if (0 == m_Connections.GetCount())
        return ResultFromScode(OLE_E_NOCONNECTION);

    /*
     * Create the array of CONNECTDATA structures to give to the
     * enumerator.
     */
    pCD=new CONNECTDATA[(UINT)m_Connections.GetCount()];

    if (NULL==pCD)
        return ResultFromScode(E_OUTOFMEMORY);

	wmilib::auto_buffer<CONNECTDATA> pCD_Guard ( pCD ) ;

	DWORD	  lKey =  0;
	LPUNKNOWN pItem = NULL;
	POSITION  rNextPosition;
    UINT      j=0;
	for(rNextPosition=m_Connections.GetStartPosition();NULL!=rNextPosition;j++)
	{
		m_Connections.GetNextAssoc(rNextPosition, lKey, pItem );
        pCD[j].pUnk=pItem;
        pCD[j].dwCookie=lKey;
	}
    /*
     * If creation works, it makes a copy pCD, so we can
     * always delete it regardless of the outcome.
     */
    pEnum=new CEnumConnections(this, m_Connections.GetCount(), pCD);

    if (NULL==pEnum)
        return ResultFromScode(E_OUTOFMEMORY);

    //This does an AddRef for us.
    return pEnum->QueryInterface(IID_IEnumConnections, (PPVOID)ppEnum);
}

//Connection Enumerator follows

/*
 * CEnumConnections::CEnumConnections
 * CEnumConnections::~CEnumConnections
 *
 * Parameters (Constructor):
 *  pUnkRef         LPUNKNOWN to use for reference counting.
 *  cConn           ULONG number of connections in prgpConn
 *  prgConnData     LPCONNECTDATA to the array to enumerate.
 */

CEnumConnections::CEnumConnections(LPUNKNOWN pUnkRef, ULONG cConn
								   , LPCONNECTDATA prgConnData) : m_rgConnData ( NULL )
{
    UINT        i;

    m_cRef=0;
    m_pUnkRef=pUnkRef;

    m_iCur=0;
    m_cConn=cConn;

    /*
     * Copy the passed array.  We need to do this because a clone
     * has to have its own copy as well.
     */
    m_rgConnData=new CONNECTDATA[(UINT)cConn];

    if (NULL!=m_rgConnData)
    {
        for (i=0; i < cConn; i++)
        {
            m_rgConnData[i]=prgConnData[i];
            m_rgConnData[i].pUnk=prgConnData[i].pUnk;
            m_rgConnData[i].pUnk->AddRef();
        }
    }

    return;
}

CEnumConnections::~CEnumConnections(void)
{
    if (NULL!=m_rgConnData)
    {
        UINT        i;

        for (i=0; i < m_cConn; i++)
            m_rgConnData[i].pUnk->Release();

        delete [] m_rgConnData;
    }

    return;
}
/*
 * CEnumConnections::QueryInterface
 * CEnumConnections::AddRef
 * CEnumConnections::Release
 *
 * Purpose:
 *  IUnknown members for CEnumConnections object.
 */

STDMETHODIMP CEnumConnections::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumConnections==riid)
        *ppv=(LPVOID)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumConnections::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    m_pUnkRef->AddRef();
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumConnections::Release(void)
{
    m_pUnkRef->Release();

	long ret;
    if (0L!=(ret=InterlockedDecrement(&m_cRef)))
        return ret;

    delete this;
    return 0;
}

/*
 * CEnumConnections::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cConn           ULONG number of connections to return.
 *  pConnData       LPCONNECTDATA in which to store the returned
 *                  structures.
 *  pulEnum         ULONG * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumConnections::Next(ULONG cConn
    , LPCONNECTDATA pConnData, ULONG *pulEnum)
{
    ULONG               cReturn=0L;

    if (NULL==m_rgConnData)
        return ResultFromScode(S_FALSE);

    if (NULL==pulEnum)
    {
        if (1L!=cConn)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulEnum=0L;

    if (NULL==pConnData || m_iCur >= m_cConn)
        return ResultFromScode(S_FALSE);

    while (m_iCur < m_cConn && cConn > 0)
    {
        *pConnData++=m_rgConnData[m_iCur];
        m_rgConnData[m_iCur++].pUnk->AddRef();
        cReturn++;
        cConn--;
    }

    if (NULL!=pulEnum)
        *pulEnum=cReturn;

    return NOERROR;
}

STDMETHODIMP CEnumConnections::Skip(ULONG cSkip)
{
    if (((m_iCur+cSkip) >= m_cConn) || NULL==m_rgConnData)
        return ResultFromScode(S_FALSE);

    m_iCur+=cSkip;
    return NOERROR;
}

STDMETHODIMP CEnumConnections::Reset(void)
{
    m_iCur=0;
    return NOERROR;
}

STDMETHODIMP CEnumConnections::Clone(LPENUMCONNECTIONS *ppEnum)
{
    PCEnumConnections   pNew;

    *ppEnum=NULL;

    //Create the clone
    pNew=new CEnumConnections(m_pUnkRef, m_cConn, m_rgConnData);

    if (NULL==pNew)
        return ResultFromScode(E_OUTOFMEMORY);

    pNew->AddRef();
    pNew->m_iCur=m_iCur;

    *ppEnum=pNew;
    return NOERROR;
}

/**********************************************************************************
 * CSmirConnObject
 *
 * Connectable Object implementation that supports the 
 * interface ISMIRNotify.
 *
 * CSmirConnObject::CSmirConnObject
 * CSmirConnObject::~CSmirConnObject
 ***********************************************************************************/

CSmirConnObject::CSmirConnObject(CSmir *pSmir) : m_rgpConnPt ( NULL )
{
//	CSMIRClassFactory::objectsInProgress++;
    m_cRef=0;
	//create SMIR_NUMBER_OF_CONNECTION_POINTS connection points
	m_rgpConnPt = new CSmirConnectionPoint*[SMIR_NUMBER_OF_CONNECTION_POINTS];
	for(int iLoop=0;iLoop<SMIR_NUMBER_OF_CONNECTION_POINTS;iLoop++)
		m_rgpConnPt[iLoop] = NULL;

	try
	{
		Init(pSmir);
	}
	catch(...)
	{
		if (m_rgpConnPt)
		{
			//free the connection points
			for(int iLoop=0;iLoop<SMIR_NUMBER_OF_CONNECTION_POINTS;iLoop++)
			{   
				if (NULL!=m_rgpConnPt[iLoop])
				{
					//release all of the connected objects
					//while(m_rgpConnPt[iLoop]->Release());
					m_rgpConnPt[iLoop]->Release();
				}
			}
			//and delete the connection point
			delete[] m_rgpConnPt;
			m_rgpConnPt = NULL;
		}

		throw;
	}
}

CSmirConnObject::~CSmirConnObject(void)
{
	if (m_rgpConnPt)
	{
		//free the connection points
		for(int iLoop=0;iLoop<SMIR_NUMBER_OF_CONNECTION_POINTS;iLoop++)
		{   
			if (NULL!=m_rgpConnPt[iLoop])
			{
				//release all of the connected objects
				//while(m_rgpConnPt[iLoop]->Release());
				m_rgpConnPt[iLoop]->Release();
			}
		}
		//and delete the connection point
		delete[] m_rgpConnPt;
	}

//	CSMIRClassFactory::objectsInProgress--;
}

/*
 * CSmirConnObject::Init
 *
 * Purpose:
 *  Instantiates the interface implementations for this object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 * BOOL    TRUE if initialization succeeds, FALSE otherwise.
 */

BOOL CSmirConnObject::Init(CSmir *pSmir)
{
    //Create our connection points

	//the smir change CP
    m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT]=
									new CSmirNotifyCP(this, 
											IID_ISMIR_Notify, pSmir);
    
	if (NULL==m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT])
        return FALSE;

    m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT]->AddRef();

    return TRUE;
}
/*
 * CSmirConnObject::QueryInterface
 *
 * Purpose:
 *  Manages the interfaces for this object which supports the
 *  IUnknown, ISampleOne, and ISampleTwo interfaces.
 *
 * Parameters:
 *  riid            REFIID of the interface to return.
 *  ppv             PPVOID in which to store the pointer.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, E_NOINTERFACE if the
 *                  interface is not supported.
 */

STDMETHODIMP CSmirConnObject::QueryInterface(REFIID riid, PPVOID ppv)
{
	if (ppv)
		*ppv = NULL;
	else
		return E_INVALIDARG;

	if((IID_IConnectionPointContainer == riid)||(IID_ISMIR_Notify == riid))
		*ppv = this;
	else
		return E_NOINTERFACE;

	return S_OK;
}

/*
 * CSmirConnObject::AddRef
 * CSmirConnObject::Release
 *
 * Reference counting members.  When Release sees a zero count
 * the object destroys itself.
 */

DWORD CSmirConnObject::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

DWORD CSmirConnObject::Release(void)
{
	long ret;
    if (0!=(ret=InterlockedDecrement(&m_cRef)))
	{
        return ret;
	}

    delete this;
    return 0;
}

/*
 * CSmirConnObject::EnumConnectionPoints
 *
 * Purpose:
 *  Creates and returns an enumerator object with the
 *  IEnumConnectionPoints interface that will enumerate the
 *  individual connection points supported in this object.
 *
 * Parameters:
 *  ppEnum          LPENUMCONNECTIONPOINTS in which to store the
 *                  IEnumConnectionPoints pointer.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, E_OUTOFMEMORY on failure or
 *                  other error code.
 */

STDMETHODIMP CSmirConnObject :: EnumConnectionPoints
    (LPENUMCONNECTIONPOINTS *ppEnum)
{
    IConnectionPoint       **rgCP = NULL ;
    CEnumConnectionPoints  * pEnum = NULL ;

    *ppEnum=NULL;

    rgCP=(IConnectionPoint **)m_rgpConnPt;

    //Create the enumerator:  we  have two connection points
    pEnum=new CEnumConnectionPoints(this, SMIR_NUMBER_OF_CONNECTION_POINTS, rgCP);

    if (NULL==pEnum)
        return ResultFromScode(E_OUTOFMEMORY);

    pEnum->AddRef();
    *ppEnum=pEnum;
    return NOERROR;
}

/*
 * CSmirConnObject::FindConnectionPoint
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPoint for a given
 *  outgoing IID.
 *
 * Parameters:
 *  riid            REFIID of the outgoing interface for which
 *                  a connection point is desired.
 *  ppCP            IConnectionPoint ** in which to return
 *                  the pointer after calling AddRef.
 *
 * Return Value:
 *  HRESULT         NOERROR if the connection point is found,
 *                  E_NOINTERFACE if it's not supported.
 */

STDMETHODIMP CSmirConnObject::FindConnectionPoint(REFIID riid
    , IConnectionPoint **ppCP)
{
    *ppCP=NULL;
	HRESULT result;
    if (IID_ISMIR_Notify==riid)
    {
        result = m_rgpConnPt[SMIR_NOTIFY_CONNECTION_POINT]
								->QueryInterface(IID_IConnectionPoint, (PPVOID)ppCP);
		if (NULL != ppCP)
			return result;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//Connection Point Enumerator follows

/*
 * CEnumConnectionPoints::CEnumConnectionPoints
 * CEnumConnectionPoints::~CEnumConnectionPoints
 *
 * Parameters (Constructor):
 *  pUnkRef         LPUNKNOWN to use for reference counting.
 *  cPoints         ULONG number of connection points in prgpCP
 *  rgpCP           IConnectionPoint** to the array to enumerate.
 */

CEnumConnectionPoints::CEnumConnectionPoints(LPUNKNOWN pUnkRef
											 , ULONG cPoints, IConnectionPoint **rgpCP) : m_rgpCP ( NULL )
{
    UINT        i;

    m_cRef=0;
    m_pUnkRef=pUnkRef;

    m_iCur=0;
    m_cPoints=cPoints;
    m_rgpCP=new IConnectionPoint *[(UINT)cPoints];

    if (NULL!=m_rgpCP)
    {
        for (i=0; i < cPoints; i++)
        {
            m_rgpCP[i]=rgpCP[i];
            m_rgpCP[i]->AddRef();
        }
    }

    return;
}

CEnumConnectionPoints::~CEnumConnectionPoints(void)
{
    if (NULL!=m_rgpCP)
    {
        UINT        i;

        for (i=0; i < m_cPoints; i++)
            m_rgpCP[i]->Release();

        delete [] m_rgpCP;
    }

    return;
}

/*
 * CEnumConnectionPoints::QueryInterface
 * CEnumConnectionPoints::AddRef
 * CEnumConnectionPoints::Release
 *
 * Purpose:
 *  IUnknown members for CEnumConnectionPoints object.
 */

STDMETHODIMP CEnumConnectionPoints::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumConnectionPoints==riid)
        *ppv=(LPVOID)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumConnectionPoints::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    m_pUnkRef->AddRef();
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumConnectionPoints::Release(void)
{
    m_pUnkRef->Release();

	long ret;
    if (0L!=(ret=InterlockedDecrement(&m_cRef)))
        return ret;

    delete this;
    return 0;
}

/*
 * CEnumConnectionPoints::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cPoints         ULONG number of connection points to return.
 *  ppCP            IConnectionPoint** in which to store the returned
 *                  pointers.
 *  pulEnum         ULONG * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumConnectionPoints::Next(ULONG cPoints
    , IConnectionPoint **ppCP, ULONG *pulEnum)
{
    ULONG               cReturn=0L;

    if (NULL==m_rgpCP)
        return ResultFromScode(S_FALSE);

    if (NULL==ppCP)
        return ResultFromScode(E_POINTER);

    if (NULL==pulEnum)
    {
        if (1L!=cPoints)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulEnum=0L;

    if (NULL==*ppCP || m_iCur >= m_cPoints)
        return ResultFromScode(S_FALSE);

    while (m_iCur < m_cPoints && cPoints > 0)
    {
	    *ppCP=m_rgpCP[m_iCur++];

        if (NULL!=*ppCP)
            (*ppCP)->AddRef();

        ppCP++;
        cReturn++;
        cPoints--;
    }

    if (NULL!=pulEnum)
        *pulEnum=cReturn;

    return NOERROR;
}

STDMETHODIMP CEnumConnectionPoints::Skip(ULONG cSkip)
{
    if (((m_iCur+cSkip) >= m_cPoints) || NULL==m_rgpCP)
        return ResultFromScode(S_FALSE);

    m_iCur+=cSkip;
    return NOERROR;
}


STDMETHODIMP CEnumConnectionPoints::Reset(void)
{
    m_iCur=0;
    return NOERROR;
}

STDMETHODIMP CEnumConnectionPoints::Clone
    (LPENUMCONNECTIONPOINTS *ppEnum)
{
    PCEnumConnectionPoints   pNew = NULL ;

    *ppEnum=NULL;

    //Create the clone
    pNew=new CEnumConnectionPoints(m_pUnkRef, m_cPoints, m_rgpCP);

    if (NULL==pNew)
        return ResultFromScode(E_OUTOFMEMORY);

    pNew->AddRef();
    pNew->m_iCur=m_iCur;

    *ppEnum=pNew;
    return NOERROR;
}
/*
 * CSmirEnumClassCP/CSmirNotifyCP::
 *
 * Purpose:
 *  Provides the notify connection point advise, unadvise constructor and destructor.
 *
 * Parameters:
 *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection
 *                  point must QueryInterface on this pointer to obtain
 *                  the proper interface to call.  The connection
 *                  point must also insure that any pointer held has
 *                  a reference count (QueryInterface will do it).
 *  pdwCookie       DWORD * in which to store the connection key for
 *                  later calls to Unadvise.
 */

CSmirNotifyCP :: CSmirNotifyCP(PCSmirConnObject pCO, REFIID riid, CSmir *pSmir):
						CSmirConnectionPoint(pCO,riid,pSmir), m_evtConsumer (NULL)
{
//	CSMIRClassFactory::objectsInProgress++;
	m_bRegistered = FALSE;
	m_evtConsumer = new CSmirWbemEventConsumer(pSmir);
	void* tmp = NULL;
	
	if (FAILED(m_evtConsumer->QueryInterface(IID_ISMIR_WbemEventConsumer, &tmp)))
	{
		delete m_evtConsumer;
		m_evtConsumer = NULL;
	}
}

CSmirNotifyCP :: ~CSmirNotifyCP()
{
	if (NULL != m_evtConsumer)
	{	
		m_evtConsumer->Release();
	}
//	CSMIRClassFactory::objectsInProgress--;
}

/*
 * CSmirConnObject::TriggerEvent
 *
 * Purpose:
 *  Functions to make each connection point generate calls
 *  to any connected sinks.  Since these functions are specific
 *  to IDuckEvents, they only deal with the connection point
 *  for that one interface
 *
 * Parameters:
 *  iEvent          UINT of the event to trigger, either
 *                  EVENT_QUACK, EVENT_FLAP, or EVENT_PADDLE.
 *
 * Return Value:
 *  BOOL            TRUE events are triggered, FALSE if there
 *                  are no connected sinks.
 */

BOOL CSmirNotifyCP::TriggerEvent()
{
    IEnumConnections   *pEnum = NULL ;
    CONNECTDATA         cd ;

	if (FAILED(EnumConnections(&pEnum)))
		return FALSE;

	while (NOERROR == pEnum->Next(1, &cd, NULL))
	{
		//a promise fulfilled - Andrew Sinclair just in case anyone thinks otherwise!
		ISMIRNotify *pJudith;

		if (SUCCEEDED(cd.pUnk->QueryInterface(IID_ISMIR_Notify, (PPVOID)&pJudith)))
		{
			pJudith->ChangeNotify();
			pJudith->Release();
		}

		cd.pUnk->Release();
	}

	pEnum->Release();

	return TRUE;
}

STDMETHODIMP CSmirNotifyCP::Advise(CSmir* pSmir, LPUNKNOWN pUnkSink
    , DWORD *pdwCookie)
{
	if (NULL == m_evtConsumer)
	{
		return WBEM_E_FAILED;
	}

	//if this is the first person to connect
	if(m_Connections.IsEmpty())
	{
		//register for WBEM Events for Smir Namespace changes
		if (SUCCEEDED(m_evtConsumer->Register(pSmir)))
		{
			m_bRegistered = TRUE;
		}
	}

	return CSmirConnectionPoint::Advise(pUnkSink, pdwCookie);
}

STDMETHODIMP CSmirNotifyCP::Unadvise(CSmir* pSmir, DWORD dwCookie)
{
	EnterCriticalSection ( & g_CriticalSection ) ;

	HRESULT hr = CSmirConnectionPoint::Unadvise(dwCookie);
	IWbemServices *t_pServ = NULL;

	if(S_OK== hr)
	{
		//if this is the last connection unregister for WBEM Events
		if(m_Connections.IsEmpty())
		{
			if (NULL == m_evtConsumer)
			{
				return WBEM_E_FAILED;
			}
			else if (m_bRegistered)
			{
				hr = m_evtConsumer->GetUnRegisterParams(&t_pServ);
			}
		}
	}

	LeaveCriticalSection ( & g_CriticalSection ) ;

	if (SUCCEEDED(hr) && (t_pServ != NULL))
	{
		hr = m_evtConsumer->UnRegister(pSmir, t_pServ);
		t_pServ->Release();
		t_pServ = NULL;

		//guarantees only one query at a time with the event consumer (sink)....
		EnterCriticalSection ( & g_CriticalSection ) ;
		m_bRegistered = FALSE;
		LeaveCriticalSection ( & g_CriticalSection ) ;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\classfac.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPSMIRClassFactory_H
#define _SNMPSMIRClassFactory_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for the interogative and administrative interfaces
class CSMIRGenericClassFactory : public IClassFactory
{
private:
	CCriticalSection	criticalSection ;
    long m_referenceCount ;
public:

    CSMIRGenericClassFactory (CLSID m_clsid) ;
    virtual ~CSMIRGenericClassFactory ( void ) ;

	//IUnknown members
	virtual STDMETHODIMP QueryInterface (IN  REFIID , OUT LPVOID FAR * )PURE;
    STDMETHODIMP_( ULONG ) AddRef (void);
    STDMETHODIMP_( ULONG ) Release (void) ;

	//IClassFactory members
    virtual STDMETHODIMP CreateInstance ( IN LPUNKNOWN , IN REFIID , OUT LPVOID FAR * )PURE;
    virtual STDMETHODIMP LockServer (IN BOOL )PURE;
};

class CSMIRClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG objectsInProgress ;
	static LONG locksInProgress ;
	BOOL		  bConstructed;

    CSMIRClassFactory (CLSID m_clsid);
    virtual ~CSMIRClassFactory ( void );

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID , OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( IN LPUNKNOWN , IN REFIID , OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};
/////////////////////////////////////////////////////////////////////////
// These classes are the class factories for the handle interfaces

class CModHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
   	static LONG objectsInProgress ;
	CModHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){} ;
    virtual ~CModHandleClassFactory ( void ){} ;

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};
class CClassHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
	static LONG objectsInProgress ;
    CClassHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CClassHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN  REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};
class CGroupHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
    static LONG objectsInProgress ;
	CGroupHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CGroupHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};



//****************************NotificationClass stuff*****************

class CNotificationClassHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
    static LONG objectsInProgress ;
	CNotificationClassHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CNotificationClassHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};


class CExtNotificationClassHandleClassFactory : public CSMIRGenericClassFactory
{
public:
	static LONG locksInProgress ;
    static LONG objectsInProgress ;
	CExtNotificationClassHandleClassFactory (CLSID m_clsid) :CSMIRGenericClassFactory(m_clsid){};
    virtual ~CExtNotificationClassHandleClassFactory ( void ) {};

	//IUnknown members

	STDMETHODIMP QueryInterface (IN  REFIID ,OUT LPVOID FAR * ) ;

	//IClassFactory members

    STDMETHODIMP CreateInstance (IN LPUNKNOWN ,IN REFIID ,OUT LPVOID FAR * ) ;
    STDMETHODIMP LockServer (IN BOOL ) ;
};

#endif // _SNMPSMIRClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\csmir.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _CSMIR_H_
#define _CSMIR_H_

class CSmir;
class CSmirConnObject;


#include "smir.h"
#include "csmirdef.h"
#include "thread.h"
#include "cthread.h"
#include "smirevt.h"

class CSmirWbemConfiguration ; 
class CSmirAdministrator;
class CGroupToClassAssociator;
class CModuleToClassAssociator;
class CXToClassAssociator;
class CSMIRToClassAssociator;
class CSmirNotificationClassHandle;
class CSmirExtNotificationClassHandle;

class CSmirSerialiseHandle : public ISmirSerialiseHandle
{
private:
	friend CSmirAdministrator;
	friend CSmirGroupHandle;
	friend CSmirModuleHandle;
	friend CSmirClassHandle;
	friend CSmirNotificationClassHandle;
	friend CSmirExtNotificationClassHandle;
	CString m_serialiseString;
	LONG	m_cRef;
	BOOL	m_bMOFPragmas;
	BOOL	m_bMOFAssociations;

public:
	//IUnknown members
    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP GetText (OUT BSTR *);

	CSmirSerialiseHandle(BOOL bClassDefinitionsOnly);
	virtual ~CSmirSerialiseHandle(){}

private:
		//private copy constructors to prevent bcopy
		CSmirSerialiseHandle(CSmirSerialiseHandle&);
		const CSmirSerialiseHandle& operator=(CSmirSerialiseHandle &);
		BOOL ReturnMOFPragmas(){return m_bMOFPragmas;};
		BOOL ReturnMOFAssociations(){return m_bMOFAssociations;};
};

class CSmirInterrogator : public ISmirInterrogator
{
private:
	LONG	m_cRef;
	CSmir	*m_pSmir;
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
		CMutex				criticalSection(FALSE,SMIR_CSMIR_INTERROGATOR_MUTEX) ;
#else
		CCriticalSection	criticalSection ;
#endif
public:

	CSmirInterrogator () ;

	//IUnknown members
    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// interrogative interface
	STDMETHODIMP EnumModules (OUT IEnumModule **ppEnumSmirMod);
	STDMETHODIMP EnumGroups  (OUT IEnumGroup **ppEnumSmirGroup, IN ISmirModHandle *hModule);
	STDMETHODIMP EnumAllClasses (OUT IEnumClass **ppEnumSmirclass);
	STDMETHODIMP EnumClassesInGroup (OUT IEnumClass **ppEnumSmirclass, IN ISmirGroupHandle *hGroup);
	STDMETHODIMP EnumClassesInModule (OUT IEnumClass **ppEnumSmirclass, IN ISmirModHandle *hModule);
	STDMETHODIMP GetWBEMClass	 (OUT IWbemClassObject **pObj, IN BSTR pszClassName);

	STDMETHODIMP EnumAllNotificationClasses(IEnumNotificationClass **ppEnumSmirclass);
	STDMETHODIMP EnumAllExtNotificationClasses(IEnumExtNotificationClass **ppEnumSmirclass);
	STDMETHODIMP EnumNotificationClassesInModule(IEnumNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule);
	STDMETHODIMP EnumExtNotificationClassesInModule(IEnumExtNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule);

	CSmirInterrogator(CSmir *pSmir);
	virtual ~CSmirInterrogator(){}
private:
		//private copy constructors to prevent bcopy
		CSmirInterrogator(CSmirInterrogator&);
		const CSmirInterrogator& operator=(CSmirInterrogator &);
};

class CSmirAdministrator : public ISmirAdministrator
{
private:
	LONG	m_cRef;
	CSmir	*m_pSmir;
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
		CMutex				criticalSection(FALSE,SMIR_CSMIR_ADMINISTRATOR_MUTEX) ;
#else
		CCriticalSection	criticalSection ;
#endif
public:

	CSmirAdministrator () ;

	//IUnknown members
    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP CreateWBEMClass(IN BSTR pszClassName, OUT ISmirClassHandle **pHandle); 
	STDMETHODIMP CreateWBEMNotificationClass ( IN BSTR pszClassName, OUT ISmirNotificationClassHandle **pHandle ) ;
	STDMETHODIMP CreateWBEMExtNotificationClass ( IN BSTR pszClassName, OUT ISmirExtNotificationClassHandle **pHandle ) ;

	//administrative  interface
	STDMETHODIMP AddModule(IN ISmirModHandle *hModule);
	STDMETHODIMP DeleteModule(IN ISmirModHandle *hModule);
	STDMETHODIMP DeleteAllModules();
	STDMETHODIMP AddGroup(IN ISmirModHandle *hModule, IN ISmirGroupHandle *hGroup);
	STDMETHODIMP DeleteGroup(ISmirGroupHandle *hGroup);
	STDMETHODIMP AddClass(IN ISmirGroupHandle *hGroup, IN ISmirClassHandle *hClass);
	STDMETHODIMP DeleteClass(IN ISmirClassHandle *hClass);

	STDMETHODIMP GetSerialiseHandle(ISmirSerialiseHandle **hSerialise, BOOL bClassDefinitionsOnly);
	STDMETHODIMP AddModuleToSerialise(ISmirModHandle *hModule,ISmirSerialiseHandle *hSerialise);
	STDMETHODIMP AddGroupToSerialise(ISmirModHandle *hModule, ISmirGroupHandle *hGroup,ISmirSerialiseHandle *hSerialise);
	STDMETHODIMP AddClassToSerialise(ISmirGroupHandle *hGroup, ISmirClassHandle  *hClass,ISmirSerialiseHandle *hSerialise);

	STDMETHODIMP AddNotificationClass(ISmirNotificationClassHandle *hClass);
	STDMETHODIMP AddExtNotificationClass(ISmirExtNotificationClassHandle *hClass);
	STDMETHODIMP DeleteNotificationClass(ISmirNotificationClassHandle *hClass); 
	STDMETHODIMP DeleteExtNotificationClass(ISmirExtNotificationClassHandle *hClass);
	STDMETHODIMP AddNotificationClassToSerialise(ISmirNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise);
	STDMETHODIMP AddExtNotificationClassToSerialise(ISmirExtNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise);


	CSmirAdministrator(CSmir *pSmir) ;
	virtual ~CSmirAdministrator(){}
private:
		//private copy constructors to prevent bcopy
		CSmirAdministrator(CSmirAdministrator&);
		const CSmirAdministrator& operator=(CSmirAdministrator &);
};

class CSmirWbemConfiguration : public ISMIRWbemConfiguration
{
private:

	LONG m_ReferenceCount ;

	CSmir *m_Smir ;	
	IWbemContext *m_Context ;
	IWbemServices *m_Service ;

protected:
public:

	CSmirWbemConfiguration ( CSmir *a_Smir ) ;
	~CSmirWbemConfiguration () ;

	//IUnknown methods
	//=================

	STDMETHODIMP			QueryInterface(IN REFIID riid,OUT PPVOID ppv);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

    STDMETHODIMP Authenticate (

		BSTR Server,
		BSTR User,
        BSTR Password,
        BSTR Locale,
        long lSecurityFlags,                 
        BSTR Authority ,
		BOOL InProc

	) ;

	STDMETHODIMP Impersonate ( ISMIRWbemConfiguration *a_Configuration ) ;

    STDMETHODIMP SetContext ( IWbemContext *a_Context ) ;

	STDMETHODIMP GetContext ( IWbemContext **a_Context ) ;
	STDMETHODIMP GetServices ( IWbemServices **a_Service ) ;
} ;

class CSmir : public ISmirDatabase
{
	private:
		friend CSmirInterrogator;
		friend CSmirAdministrator;
		friend CSmirConnObject;

#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
		CMutex				criticalSection(FALSE,SMIR_CSMIR_MUTEX) ;
#else
		CCriticalSection	criticalSection ;
#endif
		LONG				m_cRef;
		CSmirInterrogator   m_Interrogator;
		CSmirAdministrator  m_Administrator;
		CSmirWbemConfiguration m_Configuration ;

	public:
		static CSmirConnObject*		sm_ConnectionObjects;
		//IUnknown members
	    STDMETHODIMP         QueryInterface(IN REFIID, OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();
		
		STDMETHODIMP	AddNotify(IN ISMIRNotify *hNotify, OUT DWORD *);
		STDMETHODIMP	DeleteNotify(IN DWORD);

		CSmir();
		virtual ~CSmir();
private:
		//private copy constructors to prevent bcopy
		CSmir(CSmir&);
		const CSmir& operator=(CSmir &);
};
//structure used to pass arguments to the async class enumerator function
typedef struct 
{
   CSmirConnObject *ConnectionObjects;
   ISmirModHandle *hModule;
   ISmirGroupHandle *hGroup;
   IConnectionPoint  *pCP;
   DWORD dwCookie;
} EnumClassAsyncArgStruct;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\bstring.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\csmirdef.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _CSMIRDEF_H_
#define _CSMIRDEF_H_

//missing #defs
#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

#ifndef DllImport
#define DllImport	__declspec( dllimport )
#endif
#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif

//forward declarations and typedefs

//main access classes
class CSmir;
class CSmirAdministrator;
class CSmirInterogator;


//enumerator classes
class CEnumSmirMod;
typedef CEnumSmirMod *PENUMSMIRMOD;
class CEnumSmirGroup;
typedef CEnumSmirGroup *PENUMSMIRGROUP;
class CEnumSmirClass;
typedef CEnumSmirClass * PENUMSMIRCLASS;
class CEnumNotificationClass;
typedef CEnumNotificationClass * PENUMNOTIFICATIONCLASS;
class CEnumExtNotificationClass;
typedef CEnumExtNotificationClass * PENUMEXTNOTIFICATIONCLASS;

//handle classes
class CSmirModuleHandle ;
typedef CSmirModuleHandle *HSMIRMODULE;
class CSmirGroupHandle ;
typedef CSmirGroupHandle *HSMIRGROUP;
class CSmirClassHandle;
typedef CSmirClassHandle *HSMIRCLASS;

class CSMIRClassFactory;
class CModHandleClassFactory;
class CGroupHandleClassFactory;
class CClassHandleClassFactory;
class CNotificationClassHandleClassFactory;
class CExtNotificationClassHandleClassFactory;

class CSmirConnObject;

//simple defines
//number of SMIR classes to register
#define NUMBER_OF_SMIR_INTERFACES			6

//connection point defines
#define SMIR_CHANGE_EVENT					1
#define SMIR_SIGNALED_CHANGE_EVENT			2

//wait between successive smir changes
#define SMIR_CHANGE_INTERVAL				10000 //in milliseconds

#define DEFAULT_SNMP_VERSION				1

//Event return values
#define SMIR_THREAD_DELETED					100
#define SMIR_THREAD_EXIT					(SMIR_THREAD_DELETED+1)


//WBEM_DEFINES
#define RESERVED_WBEM_FLAG							0

// WBEM constants

#define WBEM_CLASS_PROPAGATION WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\evtcons.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _EVTCONS_H_
#define _EVTCONS_H_

#define SMIR_EVT_COUNT	2
#define SMIR_CHANGE_EVT 0
#define SMIR_THREAD_EVT	1

class CSmirWbemEventConsumer : public ISMIRWbemEventConsumer
{
private:

	LONG			m_cRef;
	HANDLE			*m_hEvents;
	CNotifyThread	*m_callbackThread;
	IWbemServices	*m_Serv;

	//private copy constructors to prevent bcopy
	CSmirWbemEventConsumer(CSmirWbemEventConsumer&);
	const CSmirWbemEventConsumer& operator=(CSmirWbemEventConsumer &);


public:

	//Implementation
	//===============

		CSmirWbemEventConsumer(CSmir* psmir);

	HRESULT	Register(CSmir* psmir);
	HRESULT	UnRegister(CSmir* psmir, IWbemServices* pServ);
	HRESULT GetUnRegisterParams(IWbemServices** ppServ);

		~CSmirWbemEventConsumer();


	//IUnknown methods
	//=================

	STDMETHODIMP			QueryInterface(IN REFIID riid,OUT PPVOID ppv);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();
   

	//IWbemObjectSink methods
	//=======================

	STDMETHODIMP_(HRESULT)	Indicate(	IN long lObjectCount,
										IN IWbemClassObject **ppObjArray
										);

	STDMETHODIMP_(HRESULT)	SetStatus(	IN long lFlags,
										IN long lParam,
										IN BSTR strParam,
										IN IWbemClassObject *pObjParam
										);
};


#endif //_EVTCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\cthread.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

class CNotifyThread : public CThread
{
	private:
		HANDLE	 m_doneEvt;
	public:
		CNotifyThread(HANDLE* evtsarray, ULONG arraylen);
		virtual ~CNotifyThread();
		SCODE Process();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\smir.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SMIR_H_
#define _SMIR_H_

struct ISmirInterrogator ;
struct ISmirAdministrator ;

/***************************** handles *************************************/
// {5009ab90-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_ModHandle, 
0x5009ab90, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

// {5009ab91-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ModHandle, 
0x5009ab91, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISmirModHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, GetName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetModuleOID)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetModuleIdentity)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetLastUpdate)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetOrganisation)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetContactInfo)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetDescription)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetRevision)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetSnmpVersion)(THIS_ ULONG *)PURE;
	STDMETHOD_(SCODE, GetModuleImports)(THIS_ BSTR*)PURE;

	STDMETHOD_(SCODE, SetName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetModuleOID)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetModuleIdentity)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetLastUpdate)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetOrganisation)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetContactInfo)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetDescription)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetRevision)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetSnmpVersion)(THIS_ ULONG)PURE;
	STDMETHOD_(SCODE, SetModuleImports)(THIS_ BSTR)PURE;

};

// {5009ab92-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_GroupHandle, 
0x5009ab92, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

// {5009ab93-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_GroupHandle, 
0x5009ab93, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
DECLARE_INTERFACE_(ISmirGroupHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//STDMETHOD_(HSMIRMODULE) GetParentHandle();
	STDMETHOD_(SCODE, GetModuleName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetGroupOID)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetStatus)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetDescription)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetReference)(THIS_ BSTR *)PURE;

	STDMETHOD_(SCODE, SetModuleName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetGroupOID)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetStatus)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetDescription)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetReference)(THIS_ BSTR)PURE;
};

enum NotificationMapperType
{
	SNMP_NOTIFICATION_CLASS = 0,
	SNMP_EXT_NOTIFICATION_CLASS
};

enum SmirBaseClass
{
	SMIR_OBJECTTYPE_OBJECT ,
	SMIR_NOTIFICATIONTYPE_OBJECT
} ;
 
// {5009ab94-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_ClassHandle, 
0x5009ab94, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

// {5009ab95-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ClassHandle, 
0x5009ab50, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
DECLARE_INTERFACE_(ISmirClassHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, GetModuleName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetGroupName)(THIS_ BSTR *)PURE;
	STDMETHOD_(SCODE, GetWBEMClass)(IWbemClassObject **pObj)PURE;
	STDMETHOD_(SCODE, SetModuleName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetGroupName)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, SetWBEMClass)(THIS_ IWbemClassObject *pObj)PURE;
};

/**********************  Notification classes  ***************************/

// {b11b26ac-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(CLSID_SMIR_NotificationClassHandle,
0xb11b26ac, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

// {b11b26ad-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_NotificationClassHandle,
0xb11b26ad, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(ISmirNotificationClassHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID*)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, SetModule)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, GetModule)(THIS_ BSTR*)PURE;
	STDMETHOD_(SCODE, GetWBEMNotificationClass)(IWbemClassObject **pObj)PURE;
	STDMETHOD_(SCODE, SetWBEMNotificationClass)(THIS_ IWbemClassObject *pObj)PURE;
};


// {b11b26ae-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(CLSID_SMIR_ExtNotificationClassHandle,
0xb11b26ae, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

// {b11b26af-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_ExtNotificationClassHandle,
0xb11b26af, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(ISmirExtNotificationClassHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID*)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, SetModule)(THIS_ BSTR)PURE;
	STDMETHOD_(SCODE, GetModule)(THIS_ BSTR*)PURE;
	STDMETHOD_(SCODE, GetWBEMExtNotificationClass)(IWbemClassObject **pObj)PURE;
	STDMETHOD_(SCODE, SetWBEMExtNotificationClass)(THIS_ IWbemClassObject *pObj)PURE;
}; 

/**********************  Enumerator interfaces  **************************/

// {5009ab96-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ModuleEnumerator, 
0x5009ab96, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(IEnumModule,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//enum interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirModHandle **phClass, ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumModule  **ppenum)PURE;
};
// {5009ab97-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_GroupEnumerator, 
0x5009ab97, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(IEnumGroup,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//enum interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirGroupHandle **phClass, ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumGroup  **ppenum)PURE;
};
// {5009ab98-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_ClassEnumerator, 
0x5009ab98, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(IEnumClass,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	//enum interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirClassHandle **phClass, ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumClass  **ppenum)PURE;
};

/************************* Notification class enumerators *****************/

// {b11b26b0-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_EnumNotificationClass,
0xb11b26b0, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(IEnumNotificationClass, IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG, AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG, Release)(THIS_)PURE;

	// Enumerator interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirNotificationClassHandle **phClass,
					ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumNotificationClass **ppenum)PURE;
}; 


// {b11b26b1-a791-11d0-aaea-00a024e8ad1c}
DEFINE_GUID(IID_ISMIR_EnumExtNotificationClass,
0xb11b26b1, 0xa791, 0x11d0, 0xaa, 0xea, 0x0, 0xa0, 0x24, 0xe8, 0xad, 0x1c);

DECLARE_INTERFACE_(IEnumExtNotificationClass, IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG, AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG, Release)(THIS_)PURE;

	// Enumerator interface
	STDMETHOD_(SCODE, Next)(THIS_ ULONG celt, ISmirExtNotificationClassHandle **phClass,
					ULONG * pceltFetched)PURE;
	STDMETHOD_(SCODE, Skip)(THIS_ ULONG celt)PURE;
	STDMETHOD_(SCODE, Reset)(THIS_)PURE;
	STDMETHOD_(SCODE, Clone)(THIS_ IEnumExtNotificationClass **ppenum)PURE;
}; 

// {5009ab9e-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_Notify, 
0x5009ab9e, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISMIRNotify, IUnknown)
{

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    //ISMIRNotify members
    STDMETHOD(ChangeNotify)(THIS) PURE;
};

/************************  SMIR database class  *****************************/
// {5009ab9b-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(CLSID_SMIR_Database, 
0x5009ab9b, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

/************************  SMIR interfaces  *****************************/
DEFINE_GUID(IID_ISMIR_Database, 
0x5009ab9b, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISmirDatabase,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, AddNotify)(THIS_ ISMIRNotify *hNotify, DWORD *)PURE;
	STDMETHOD_(SCODE, DeleteNotify)(THIS_ DWORD)PURE;
};

// {5009ab9c-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_Interrogative, 
0x5009ab9c, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
 
DECLARE_INTERFACE_(ISmirInterrogator,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	// interrogative interface
	STDMETHOD_(SCODE, EnumModules) (THIS_ IEnumModule **ppEnumSmirMod) PURE;
	STDMETHOD_(SCODE, EnumGroups)  (THIS_ IEnumGroup **ppEnumSmirGroup, ISmirModHandle *hMudule) PURE;
	STDMETHOD_(SCODE, EnumAllClasses) (THIS_ IEnumClass **ppEnumSmirclass) PURE;
	STDMETHOD_(SCODE, EnumClassesInGroup) (THIS_ IEnumClass **ppEnumSmirclass, ISmirGroupHandle *hGroup) PURE;
	STDMETHOD_(SCODE, EnumClassesInModule) (THIS_ IEnumClass **ppEnumSmirclass, ISmirModHandle *hModule) PURE;
	STDMETHOD_(SCODE, GetWBEMClass)	   (THIS_ OUT IWbemClassObject **pObj, IN BSTR pszClassName)PURE;

	STDMETHOD_(SCODE, EnumAllNotificationClasses)(THIS_ IEnumNotificationClass **ppEnumSmirclass) PURE;
	STDMETHOD_(SCODE, EnumAllExtNotificationClasses)(THIS_ IEnumExtNotificationClass **ppEnumSmirclass) PURE;
	STDMETHOD_(SCODE, EnumNotificationClassesInModule)(THIS_ IEnumNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule) PURE;
	STDMETHOD_(SCODE, EnumExtNotificationClassesInModule)(THIS_ IEnumExtNotificationClass **ppEnumSmirclass, ISmirModHandle *hModule) PURE;
};

// {5009ab9e-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_SerialiseHandle, 
0x5009ab9e, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);
DECLARE_INTERFACE_(ISmirSerialiseHandle,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, GetText)(THIS_ BSTR *)PURE;
};

// {5009ab9d-f9ee-11cf-aec1-00aa00bdd7d1}
DEFINE_GUID(IID_ISMIR_Administrative, 
0x5009ab9d, 0xf9ee, 0x11cf, 0xae, 0xc1, 0x0, 0xaa, 0x0, 0xbd, 0xd7, 0xd1);

DECLARE_INTERFACE_(ISmirAdministrator,IUnknown)
{
	//IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *)PURE;
    STDMETHOD_(ULONG,AddRef)(THIS_)PURE;
    STDMETHOD_(ULONG,Release)(THIS_)PURE;

	STDMETHOD_(SCODE, CreateWBEMClass)(THIS_ BSTR pszClassName, ISmirClassHandle **pHandle)PURE;
	STDMETHOD_(SCODE, CreateWBEMNotificationClass)(THIS_ BSTR pszClassName, ISmirNotificationClassHandle **pHandle)PURE;
	STDMETHOD_(SCODE, CreateWBEMExtNotificationClass)(THIS_ BSTR pszClassName, ISmirExtNotificationClassHandle **pHandle)PURE;

	STDMETHOD_(SCODE, AddModule)(THIS_ ISmirModHandle *hModule)PURE;
	STDMETHOD_(SCODE, DeleteModule)(THIS_ ISmirModHandle *hModule)PURE;
	STDMETHOD_(SCODE, DeleteAllModules)(THIS_)PURE;
	STDMETHOD_(SCODE, AddGroup)(THIS_ ISmirModHandle *hModule, ISmirGroupHandle *hGroup)PURE;
	STDMETHOD_(SCODE, DeleteGroup)(THIS_ ISmirGroupHandle *hGroup)PURE;
	STDMETHOD_(SCODE, AddClass)(THIS_ ISmirGroupHandle *hGroup, ISmirClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, DeleteClass)(THIS_ ISmirClassHandle *hClass)PURE;

	STDMETHOD_(SCODE, GetSerialiseHandle)(THIS_ ISmirSerialiseHandle **hSerialise, BOOL bClassDefinitionsOnly)PURE;
	STDMETHOD_(SCODE, AddModuleToSerialise)(THIS_ ISmirModHandle *hModule,ISmirSerialiseHandle *hSerialise)PURE;
	STDMETHOD_(SCODE, AddGroupToSerialise)(THIS_ ISmirModHandle *hModule, ISmirGroupHandle *hGroup,ISmirSerialiseHandle *hSerialise)PURE;
	STDMETHOD_(SCODE, AddClassToSerialise)(THIS_ ISmirGroupHandle *hGroup, ISmirClassHandle *hClass,ISmirSerialiseHandle *hSerialise)PURE;

	STDMETHOD_(SCODE, AddNotificationClass)(THIS_ ISmirNotificationClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, AddExtNotificationClass)(THIS_ ISmirExtNotificationClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, DeleteNotificationClass)(THIS_ ISmirNotificationClassHandle *hClass)PURE; 
	STDMETHOD_(SCODE, DeleteExtNotificationClass)(THIS_ ISmirExtNotificationClassHandle *hClass)PURE;
	STDMETHOD_(SCODE, AddNotificationClassToSerialise)(THIS_ ISmirNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)PURE;
	STDMETHOD_(SCODE, AddExtNotificationClassToSerialise)(THIS_ ISmirExtNotificationClassHandle *hClass, ISmirSerialiseHandle *hSerialise)PURE;
};
/***************************** handles *************************************/

// {83D18EC0-F167-11d0-AB13-0000F81E8E2C}
DEFINE_GUID(IID_ISMIR_WbemEventConsumer, 
0x83d18ec0, 0xf167, 0x11d0, 0xab, 0x13, 0x0, 0x0, 0xf8, 0x1e, 0x8e, 0x2c);

//supports IID_ISMIR_WbemEventConsumer, IID_IWbemObjectSink and IID_IUnknown
DECLARE_INTERFACE_(ISMIRWbemEventConsumer, IWbemObjectSink)
{
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* IMosNotify methods */
    STDMETHOD_(HRESULT, Indicate)(THIS_ long lObjectCount, IWbemClassObject **ppObjArray) PURE;
    STDMETHOD_(HRESULT, SetStatus)(THIS_ long lFlags, long lParam, BSTR strParam, IWbemClassObject *pObjParam) PURE;
};

// {63BA5C10-5A47-11d1-931B-00AA00A4086C}
DEFINE_GUID(IID_ISMIRWbemConfiguration, 
0x63ba5c10, 0x5a47, 0x11d1, 0x93, 0x1b, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

DECLARE_INTERFACE_(ISMIRWbemConfiguration, IUnknown)
{
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD_(HRESULT, Authenticate)(THIS_ 

		BSTR Server,
		BSTR User,
        BSTR Password,
        BSTR Locale,
        long lSecurityFlags,                 
        BSTR Authority ,
		BOOL InProc

	) PURE;

	STDMETHOD_(HRESULT, Impersonate)(THIS_ ISMIRWbemConfiguration *a_Configuration) PURE;

    STDMETHOD_(HRESULT, SetContext)(THIS_ IWbemContext *a_Context ) PURE;
    STDMETHOD_(HRESULT, GetContext)(THIS_ IWbemContext **a_Context ) PURE;
	STDMETHOD_(HRESULT, GetServices)(THIS_ IWbemServices **a_Services ) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\handles.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _HANDLES_H_
#define _HANDLES_H_
class CSmirModuleHandle : public ISmirModHandle
{
	private:
		friend CSmirAdministrator;
		friend CEnumSmirMod;
		friend CModHandleClassFactory;


		//reference count
		LONG		m_cRef;

		//member variables
		BSTR		m_szModuleOid;
		BSTR		m_szName;
		BSTR		m_szModuleId;
		BSTR		m_szOrganisation;
		BSTR		m_szContactInfo;
		BSTR		m_szDescription;
		BSTR		m_szRevision;
		BSTR		m_szModImports;
		ULONG		m_lSnmp_version;
		BSTR		m_szLastUpdate;

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE) GetName(OUT BSTR *pszName);
		STDMETHODIMP_(SCODE) GetModuleOID(OUT BSTR *pszModuleOid);
		STDMETHODIMP_(SCODE) GetModuleIdentity(OUT BSTR *pszModuleId);
		STDMETHODIMP_(SCODE) GetLastUpdate(OUT BSTR *plLastUpdate);
		STDMETHODIMP_(SCODE) GetOrganisation(OUT BSTR *pszOrganisation);
		STDMETHODIMP_(SCODE) GetContactInfo(OUT BSTR *pszContactInfo);
		STDMETHODIMP_(SCODE) GetDescription(OUT BSTR *pszDescription);
		STDMETHODIMP_(SCODE) GetRevision(OUT BSTR *pszRevision);
		STDMETHODIMP_(SCODE) GetSnmpVersion(OUT ULONG *plSnmp_version);
		STDMETHODIMP_(SCODE) GetModuleImports (BSTR*);

		STDMETHODIMP_(SCODE) SetName(IN BSTR pszName);
		STDMETHODIMP_(SCODE) SetModuleOID(IN BSTR pszModuleOid);
		STDMETHODIMP_(SCODE) SetModuleIdentity(OUT BSTR pszModuleId);
		STDMETHODIMP_(SCODE) SetLastUpdate(IN BSTR plLastUpdate);
		STDMETHODIMP_(SCODE) SetOrganisation(IN BSTR pszOrganisation);
		STDMETHODIMP_(SCODE) SetContactInfo(IN BSTR pszContactInfo);
		STDMETHODIMP_(SCODE) SetDescription(IN BSTR pszDescription);
		STDMETHODIMP_(SCODE) SetRevision(IN BSTR pszRevision);
		STDMETHODIMP_(SCODE) SetSnmpVersion(IN ULONG plSnmp_version);
		STDMETHODIMP_(SCODE) SetModuleImports (IN BSTR);

		//Class members
		CSmirModuleHandle();
		virtual ~ CSmirModuleHandle();
		const CSmirModuleHandle& operator>>(IWbemClassObject *pInst);
		const CSmirModuleHandle& operator<<(IWbemClassObject *pInst);
		const CSmirModuleHandle& operator>>(ISmirSerialiseHandle *pInst);
		HRESULT PutClassProperties (IWbemClassObject *pClass) ;
		operator void*();
		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir );
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );
	private:
		//private copy constructors to prevent bcopy
		CSmirModuleHandle(CSmirModuleHandle&);
		const CSmirModuleHandle& operator=(CSmirModuleHandle &);
};
class CSmirGroupHandle : public ISmirGroupHandle
{
	private:
		friend  CSmirAdministrator;
		friend  CEnumSmirGroup;
		friend  CGroupHandleClassFactory;
		
		//reference count
		LONG	m_cRef;

		BSTR	m_szModuleName;
		BSTR	m_szName;
		BSTR	m_szGroupId;
		BSTR	m_szDescription;
		BSTR	m_szReference;
		BSTR	m_szStatus;	

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE)  GetModuleName(OUT BSTR *pszName);
		STDMETHODIMP_ (SCODE) GetName(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetGroupOID(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetStatus(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetDescription(OUT BSTR *);
		STDMETHODIMP_ (SCODE) GetReference(OUT BSTR *);

		STDMETHODIMP_(SCODE)  SetModuleName(IN BSTR pszName);
		STDMETHODIMP_ (SCODE) SetName(IN BSTR );
		STDMETHODIMP_ (SCODE) SetGroupOID(IN BSTR );
		STDMETHODIMP_ (SCODE) SetStatus(IN BSTR );
		STDMETHODIMP_ (SCODE) SetDescription(IN BSTR );
		STDMETHODIMP_ (SCODE) SetReference(IN BSTR );

		//Class members
		const CSmirGroupHandle& operator>>(IWbemClassObject *pInst);
		const CSmirGroupHandle& operator<<(IWbemClassObject *pInst);
		const CSmirGroupHandle& operator>>(ISmirSerialiseHandle *pInst);
		HRESULT PutClassProperties (IWbemClassObject *pClass) ;
		operator void* ();
		CSmirGroupHandle();
		virtual ~ CSmirGroupHandle();
		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir , ISmirModHandle *hModule);
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );
	private:
		//private copy constructors to prevent bcopy
		CSmirGroupHandle(CSmirGroupHandle&);
		const CSmirGroupHandle& operator=(CSmirGroupHandle &);
};

class CSmirClassHandle : public ISmirClassHandle
{
	private:
		friend  CSmirAdministrator;
		friend  CEnumSmirClass;
		friend  CClassHandleClassFactory;
		friend  CModuleToClassAssociator;
		friend  CGroupToClassAssociator;
		friend  CSMIRToClassAssociator;

		//reference count
		LONG	m_cRef;
		IWbemClassObject *m_pIMosClass;
		BSTR	 m_szModuleName;
		BSTR	 m_szGroupName;

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE) GetModuleName(OUT BSTR *pszName);
		STDMETHODIMP_(SCODE) GetGroupName(OUT BSTR *pszName);
		STDMETHODIMP_(SCODE) SetModuleName(OUT BSTR pszName);
		STDMETHODIMP_(SCODE) SetGroupName(OUT BSTR pszName);
		STDMETHODIMP_(SCODE) GetWBEMClass(OUT IWbemClassObject **pObj);
		STDMETHODIMP_(SCODE) SetWBEMClass(IN IWbemClassObject *pObj);

		//Class members
		const CSmirClassHandle& operator>>(ISmirSerialiseHandle *pInst);
		operator void* ();

		CSmirClassHandle();
		virtual ~ CSmirClassHandle();

		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir , ISmirGroupHandle *hGroup);
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );
		STDMETHODIMP_(SCODE)  DeleteClassFromGroup( CSmir *a_Smir );
	private:
		//private copy constructors to prevent bcopy
		CSmirClassHandle(CSmirClassHandle&);
		const CSmirClassHandle& operator=(CSmirClassHandle &);
};

class CModuleToNotificationClassAssociator;
class CModuleToExtNotificationClassAssociator;

class CSmirNotificationClassHandle : public ISmirNotificationClassHandle
{
	private:
		friend  CSmirAdministrator;
		//friend  CEnumNotificationClass;
		friend  CNotificationClassHandleClassFactory;
		friend  CModuleToNotificationClassAssociator;

		//reference count
		LONG	m_cRef;
		IWbemClassObject *m_pIMosClass;
		BSTR	 m_szModuleName;

	public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();
		STDMETHODIMP_(SCODE) SetModule(THIS_ BSTR);
		STDMETHODIMP_(SCODE) GetModule(THIS_ BSTR*);

		STDMETHODIMP_(SCODE) GetWBEMNotificationClass (THIS_ OUT IWbemClassObject **pObj	);
		STDMETHODIMP_(SCODE) SetWBEMNotificationClass(THIS_ IWbemClassObject *pObj);

		//Class members
		const CSmirNotificationClassHandle& operator>>(ISmirSerialiseHandle *pInst);
		operator void* ();

		CSmirNotificationClassHandle();
		virtual ~CSmirNotificationClassHandle();

		STDMETHODIMP_(SCODE) AddToDB( CSmir *a_Smir );
		STDMETHODIMP_(SCODE) DeleteFromDB( CSmir *a_Smir );

	private:
		//private copy constructors to prevent bcopy
		CSmirNotificationClassHandle(CSmirNotificationClassHandle&);
		const CSmirNotificationClassHandle& operator=(CSmirNotificationClassHandle &);
}; 


class CSmirExtNotificationClassHandle : public ISmirExtNotificationClassHandle
{
	private:
		friend  CSmirAdministrator;
		//friend  CEnumExtNotificationClass;
		friend  CExtNotificationClassHandleClassFactory;
		friend  CModuleToExtNotificationClassAssociator;

		//reference count
		LONG	m_cRef;
		IWbemClassObject *m_pIMosClass;
		BSTR	 m_szModuleName;

	public:
	//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		STDMETHODIMP_(SCODE) SetModule(THIS_ BSTR);
		STDMETHODIMP_(SCODE) GetModule(THIS_ BSTR*);

		STDMETHODIMP_(SCODE) GetWBEMExtNotificationClass(OUT IWbemClassObject **pObj);
		STDMETHODIMP_(SCODE) SetWBEMExtNotificationClass(THIS_ IWbemClassObject *pObj);

		//Class members
		const CSmirExtNotificationClassHandle& operator>>(ISmirSerialiseHandle *pInst);
		operator void* ();

		CSmirExtNotificationClassHandle();
		virtual ~CSmirExtNotificationClassHandle();

		STDMETHODIMP_(SCODE) AddToDB ( CSmir *a_Smir );
		STDMETHODIMP_(SCODE) DeleteFromDB ( CSmir *a_Smir );

	private:
		//private copy constructors to prevent bcopy
		CSmirExtNotificationClassHandle(CSmirExtNotificationClassHandle&);
		const CSmirExtNotificationClassHandle& operator=(CSmirExtNotificationClassHandle &);

}; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\helper.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _HELPER_H_
#define _HELPER_H_

/*helper classes
*/

class SmirClassFactoryHelper;
extern SmirClassFactoryHelper *g_pClassFactoryHelper;

HRESULT CopyBSTR(BSTR *pDst, BSTR *pSrc);
void FormatProviderErrorMsg(char*,int,HRESULT);

class CNotificationMapper
{
public:

	CNotificationMapper(){}
	~CNotificationMapper(){}
	static STDMETHODIMP Map(CSmir *a_Smir,IWbemClassObject *pObj, enum NotificationMapperType type);

private:
		//private copy constructors to prevent bcopy
		CNotificationMapper(CNotificationMapper&);
		const CNotificationMapper& operator=(CNotificationMapper &);
};

class CXToClassAssociator
{
public:

	CXToClassAssociator(){}
	~CXToClassAssociator(){}

private:

		//private copy constructors to prevent bcopy
		CXToClassAssociator(CXToClassAssociator&);
		const CXToClassAssociator& operator=(CXToClassAssociator &);
};

class CGroupToClassAssociator : public CXToClassAssociator
{
public:

	CGroupToClassAssociator(){}
	~CGroupToClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, BSTR szGroup, ISmirClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CGroupToClassAssociator(CXToClassAssociator&);
	const CGroupToClassAssociator& operator=(CGroupToClassAssociator &);
};

class CModuleToClassAssociator : public CXToClassAssociator
{
public:

	CModuleToClassAssociator(){}
	~CModuleToClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, ISmirClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CModuleToClassAssociator(CXToClassAssociator&);
	const CModuleToClassAssociator& operator=(CModuleToClassAssociator &);
};

class CModuleToNotificationClassAssociator : public CXToClassAssociator
{
public:

	CModuleToNotificationClassAssociator(){}
	~CModuleToNotificationClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, ISmirNotificationClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CModuleToNotificationClassAssociator(CXToClassAssociator&);
	const CModuleToNotificationClassAssociator& operator=(CModuleToNotificationClassAssociator &);
};

class CModuleToExtNotificationClassAssociator : public CXToClassAssociator
{
public:

	CModuleToExtNotificationClassAssociator(){}
	~CModuleToExtNotificationClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,BSTR szModule, ISmirExtNotificationClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CModuleToExtNotificationClassAssociator(CXToClassAssociator&);
	const CModuleToExtNotificationClassAssociator& operator=(CModuleToExtNotificationClassAssociator &);
};

class CSMIRToClassAssociator : public CXToClassAssociator
{
public:

	CSMIRToClassAssociator(){}
	~CSMIRToClassAssociator(){}
	static STDMETHODIMP Associate(CSmir *a_Smir,ISmirClassHandle *hClass);

private:

	//private copy constructors to prevent bcopy
	CSMIRToClassAssociator(CSMIRToClassAssociator&);
	const CSMIRToClassAssociator& operator=(CSMIRToClassAssociator &);
};

class CSmirAccess
{
private:

	static STDMETHODIMP Connect (

		CSmir *a_Smir , 
		OUT IWbemServices **server, 
		IN BSTR ObjectPath, 
		IN BOOL relativeToSMIR
	);

public:

	enum eOpenType {

		eModule=1,
		eGroup
	};

	//undefined constructor and destructor
	//so object should never be instantiated

	CSmirAccess();
	virtual ~CSmirAccess();
	
	static STDMETHODIMP Init();
	static void ShutDown();

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		BSTR ObjectPath=NULL, 
		BOOL relativeToSMIR = FALSE
	);

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		ISmirClassHandle *hClass,
		eOpenType eType=eGroup
	);

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		ISmirGroupHandle *hGroup,
		eOpenType eType=eGroup
	);

	static STDMETHODIMP Open (

		CSmir *a_Smir , 
		IWbemServices **server, 
		ISmirModHandle *hMod
	);

	static STDMETHODIMP GetContext (

		CSmir *a_Smir , 
		IWbemContext **a_Context
	) ;
};

class SmirClassFactoryHelper
{
private:

		CGroupHandleClassFactory *pGroupHandleClassFactory;
		CClassHandleClassFactory *pClassHandleClassFactory;
		CNotificationClassHandleClassFactory *pNotificationClassHandleClassFactory;
		CExtNotificationClassHandleClassFactory *pExtNotificationClassHandleClassFactory;
		CModHandleClassFactory   *pModHandleClassFactory;
		CSMIRClassFactory		 *pSMIRClassFactory;

public:

		SmirClassFactoryHelper();
		virtual ~SmirClassFactoryHelper();
		HRESULT CreateInstance(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\smirevt.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SMIREVT_H_
#define _SMIREVT_H_

//Number of connection points 
#define SMIR_NUMBER_OF_CONNECTION_POINTS		1
#define SMIR_NOTIFY_CONNECTION_POINT			0

class	CSmirConnectionPoint;
class	CSmirWbemEventConsumer;
class	CSmirConnObject;
typedef CSmirConnObject *PCSmirConnObject;

class	CEnumConnections;
typedef CEnumConnections *PCEnumConnections;

class	CEnumConnectionPoints;
typedef CEnumConnectionPoints *PCEnumConnectionPoints;

/*
 * Each connection is saved so that we can enumerate, delete, and trigger
 * This template provides the container for the connections and cookies
 */

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class ConnectionMap : public CObject
{
private:

	BOOL m_bThreadSafe ;
#ifdef NOT_IMPLEMENTED_AS_CLSCTX_INPROC_SERVER
	CMutex * m_criticalLock ;
#else
	CCriticalSection * m_criticalLock ;
#endif
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> m_cmap ;

protected:
public:

	ConnectionMap ( BOOL threadSafe = FALSE ) ;
	virtual ~ConnectionMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ConnectionMap ( BOOL threadSafeArg ) 
: m_bThreadSafe ( threadSafeArg ) , m_criticalLock ( NULL )
{
	if ( m_bThreadSafe )
	{
		m_criticalLock = new CCriticalSection ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~ConnectionMap () 
{
	if ( m_bThreadSafe )
	{
		delete m_criticalLock ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		int count = m_cmap.GetCount () ;
		m_criticalLock->Unlock () ;
		return count ;
	}
	else
	{
		return m_cmap.GetCount () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		BOOL isEmpty = m_cmap.IsEmpty () ;
		m_criticalLock->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return m_cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		BOOL lookup = m_cmap.Lookup ( key , rValue ) ;
		m_criticalLock->Unlock () ;
		return lookup ;
	}
	else
	{
		return m_cmap.Lookup ( key , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		VALUE &value = m_cmap.operator [] ( key ) ;
		m_criticalLock->Unlock () ;
		return value ;
	}
	else
	{
		return m_cmap.operator [] ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		m_cmap.SetAt ( key , newValue ) ;
		m_criticalLock->Unlock () ;
	}
	else
	{
		m_cmap.SetAt ( key , newValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		BOOL removeKey = m_cmap.RemoveKey ( key ) ;
		m_criticalLock->Unlock () ;
		return removeKey ;
	}
	else
	{
		return m_cmap.RemoveKey ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		m_cmap.RemoveAll () ;
		m_criticalLock->Unlock () ;
	}
	else
	{
		m_cmap.RemoveAll () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		POSITION position = m_cmap.GetStartPosition () ;
		m_criticalLock->Unlock () ;
		return position ;
	}
	else
	{
		return m_cmap.GetStartPosition () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ConnectionMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	if ( m_bThreadSafe )
	{
		m_criticalLock->Lock () ;
		m_cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
		m_criticalLock->Unlock () ;
	}
	else
	{
		m_cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
}
/*
 * The connectable object implements IUnknown and
 * IConnectionPointContainer.  It is closely associated with
 * the connection point enumerator, CEnumConnectionPoints.
 */
class CSmirConnObject : public IConnectionPointContainer
{
    private:
        LONG       m_cRef;         //Object reference count

        //Array holding all the points we have.
        CSmirConnectionPoint **m_rgpConnPt;

    public:
        CSmirConnObject(CSmir *pSmir);
        virtual ~CSmirConnObject(void);

        BOOL Init(CSmir *pSmir);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(DWORD) AddRef(void);
        STDMETHODIMP_(DWORD) Release(void);

        //IConnectionPointContainer members
        STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **);
	    STDMETHODIMP FindConnectionPoint(REFIID, IConnectionPoint **);

        //Other members
//        BOOL TriggerEvent(UINT, SMIR_NOTIFY_TYPE);
//		BOOL TriggerEvent(long lObjectCount, ISmirClassHandle *phClass);
};
/*
 * The connectable object implements IUnknown and
 * IConnectionPointContainer.  It is closely associated with
 * the connection point enumerator, CEnumConnectionPoints.
 */
//Enumerator class for EnumConnectionPoints

class CEnumConnectionPoints : public IEnumConnectionPoints
{
    private:
        LONG           m_cRef;     //Object reference count
        LPUNKNOWN       m_pUnkRef;  //IUnknown for ref counting
        ULONG           m_iCur;     //Current element
        ULONG           m_cPoints;  //Number of conn points
        IConnectionPoint **m_rgpCP; //Source of conn points

    public:
        CEnumConnectionPoints(LPUNKNOWN, ULONG, IConnectionPoint **);
        virtual ~CEnumConnectionPoints(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumConnectionPoints members
        STDMETHODIMP Next(ULONG, IConnectionPoint **, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumConnectionPoints **);
};

/*
 * The connection point object iself is contained within the
 * connection point container, which is the connectable object.
 * It therefore manages a back pointer to that connectable object,
 * and implement IConnectionPoint.  This object has a few
 * member functions besides those in IConnectionPoint that are
 * used to fire the outgoing calls.
 */
class CSmirConnectionPoint : public IConnectionPoint
{
    private:
        LONG				m_cRef;     //Object reference count
        PCSmirConnObject	m_pObj;     //Containing object
        IID					m_iid;      //Our relevant interface
        LONG				m_dwCookieNext; //Counter
		CCriticalSection	criticalSection;

	protected:
        /*
         * For each connection we need to maintain
         * the sink pointer and the cookie assigned to it.
         */
		ConnectionMap <DWORD, DWORD, IUnknown *,IUnknown *> m_Connections ;

    public:
        CSmirConnectionPoint(PCSmirConnObject, REFIID, CSmir *pSmir);
        virtual ~CSmirConnectionPoint(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IConnectionPoint members
        STDMETHODIMP GetConnectionInterface(IID *);
        STDMETHODIMP GetConnectionPointContainer
            (IConnectionPointContainer **);
        STDMETHODIMP Advise(LPUNKNOWN, DWORD *);
        STDMETHODIMP Unadvise(DWORD);
        STDMETHODIMP EnumConnections(IEnumConnections **);
};

class CSmirNotifyCP : public CSmirConnectionPoint
{
	private:
		CSmirWbemEventConsumer	*m_evtConsumer;
		BOOL					m_bRegistered;

	public:
        STDMETHODIMP Advise(CSmir*,LPUNKNOWN, DWORD *);
        STDMETHODIMP Unadvise(CSmir*,DWORD);
		CSmirNotifyCP(PCSmirConnObject pCO, REFIID riid, CSmir *pSmir);
		~CSmirNotifyCP();
        BOOL TriggerEvent();
};
//Enumeration class for EnumConnections

class CEnumConnections : public IEnumConnections
    {
    private:
        LONG           m_cRef;     //Object reference count
        LPUNKNOWN       m_pUnkRef;  //IUnknown for ref counting
        ULONG           m_iCur;     //Current element
        ULONG           m_cConn;    //Number of connections
        LPCONNECTDATA   m_rgConnData; //Source of connections
    public:
        CEnumConnections(LPUNKNOWN, ULONG, LPCONNECTDATA);
        virtual ~CEnumConnections(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumConnections members
        STDMETHODIMP Next(ULONG, LPCONNECTDATA, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumConnections **);
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\enum.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _ENUM_H_
#define _ENUM_H_

/*InterfaceGarbageCollector makes it easier to use the  interface
 *by remembering to release them when you fall out of scope. The is 
 *useful when you are using an IMosProvider and have lots of points
 *of failure; you can just give up and let the wrapper clean up for 
 *you.
 */

template<class TYPE, class ARG_TYPE>
class EnumObjectArray : public CObject
{
private:

	BOOL threadSafe ;
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
	CMutex  *criticalSection ;
#else
	CCriticalSection  *criticalSection ;
#endif
	CArray <TYPE, ARG_TYPE> carray ;

protected:
public:

	EnumObjectArray ( BOOL threadSafe = FALSE ) ;
	virtual ~EnumObjectArray () ;

	int GetSize () const  ;
	int GetUpperBound() const ;

	void SetSize (int newSize, int nGrowBy=-1) ;

	//FreeExtra not implemented
	void RemoveAll () ;
	TYPE GetAt(int index) const;
	// Not implemented void SetAt(TYPE key, ARG_TYPE newValue) ;
	TYPE& ElementAt(int nIndex);
	//GetData not implemented
	//SetAtGrow not implemented
	int Add(ARG_TYPE newElement);
	//Append not implemented
	//Copy not implemented
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount=1);
	void RemoveAt(int nIndex,  int nCount= 1);
	TYPE& operator[](TYPE key) ;
} ;


template <class TYPE, class ARG_TYPE>
EnumObjectArray <TYPE, ARG_TYPE> :: EnumObjectArray ( BOOL threadSafeArg )
: threadSafe ( threadSafeArg ) , criticalSection ( NULL )
{
	if (threadSafeArg)
	{
#ifdef	IMPLEMENTED_AS_SEPERATE_PROCESS
	criticalSection = new CMutex(FALSE,SMIR_ENUMOBJECT_MUTEX);
#else
	criticalSection = new CCriticalSection;
#endif

	}
}

template<class TYPE, class ARG_TYPE>
EnumObjectArray <TYPE, ARG_TYPE> :: ~EnumObjectArray () 
{
	int iSize = GetSize();
	for(int iLoop=0; iLoop<iSize; iLoop++)
	{
		IUnknown *pTUnknown=(IUnknown *)GetAt(iLoop);
		if(NULL!=pTUnknown)
			pTUnknown->Release();
	}

	if (threadSafe)
	{
		delete criticalSection;
	}
}

template<class TYPE, class ARG_TYPE>
int EnumObjectArray <TYPE, ARG_TYPE> :: GetSize() const
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		int count = carray.GetSize () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.GetSize () ;
	}
}

template<class TYPE, class ARG_TYPE>
int EnumObjectArray <TYPE, ARG_TYPE> :: GetUpperBound() const
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		int count = carray.GetUpperBound () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.GetUpperBound () ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: SetSize(int newSize, int nGrowBy) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.SetSize (newSize, nGrowBy) ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.SetSize (newSize, nGrowBy) ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: RemoveAll()
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.RemoveAll () ;
	}
}


template<class TYPE, class ARG_TYPE>
TYPE EnumObjectArray <TYPE, ARG_TYPE> :: GetAt(int nIndex) const
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		TYPE count = carray.GetAt (nIndex) ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.GetAt(nIndex)  ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& EnumObjectArray <TYPE, ARG_TYPE> :: ElementAt(int nIndex) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		TYPE *count = carray.ElementAt (nIndex) ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return carray.ElementAt(nIndex)  ;
	}
}

template<class TYPE, class ARG_TYPE>
int EnumObjectArray <TYPE, ARG_TYPE> :: Add(ARG_TYPE newElement) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		int nIndex = carray.Add (newElement) ;
		criticalSection->Unlock () ;
		return nIndex ;
	}
	else
	{
		return carray.Add(newElement)  ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: InsertAt(int nIndex, ARG_TYPE newElement, int nCount) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.InsertAt (nIndex, newElement,  nCount) ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.InsertAt( nIndex, newElement, nCount)  ;
	}
}

template<class TYPE, class ARG_TYPE>
void EnumObjectArray <TYPE, ARG_TYPE> :: RemoveAt(int nIndex, int nCount) 
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		carray.RemoveAt (nIndex, nCount) ;
		criticalSection->Unlock () ;
	}
	else
	{
		carray.RemoveAt( nIndex, nCount)  ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& EnumObjectArray <TYPE,ARG_TYPE> :: operator[](TYPE key)
{
	if ( threadSafe )
	{
		criticalSection->Lock () ;
		VALUE &value = carray.operator [] ( key ) ;
		criticalSection->Unlock () ;
		return value ;
	}
	else
	{
		return carray.operator [] ( key ) ;
	}
}

class CEnumSmirMod : public IEnumModule
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirModHandle *, ISmirModHandle *> m_IHandleArray;

public:
		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirModHandle **phModule,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumModule  **ppenum);

		CEnumSmirMod( CSmir *a_Smir );
		CEnumSmirMod(IN IEnumModule *pSmirMod);
		virtual ~CEnumSmirMod();

private:

		//private copy constructors to prevent bcopy
		CEnumSmirMod(CEnumSmirMod&);
		const CEnumSmirMod& operator=(CEnumSmirMod &);
};

class CEnumSmirGroup : public IEnumGroup
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirGroupHandle *, ISmirGroupHandle *> m_IHandleArray;

public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirGroupHandle **phModule,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumGroup  **ppenum);

		CEnumSmirGroup( IN CSmir *a_Smir , IN ISmirModHandle *hModule=NULL);
		CEnumSmirGroup(IN IEnumGroup *pSmirGroup);
		virtual ~CEnumSmirGroup();

private:

		//private copy constructors to prevent bcopy
		CEnumSmirGroup(CEnumSmirGroup&);
		const CEnumSmirGroup& operator=(CEnumSmirGroup &);

};

class CEnumSmirClass : public IEnumClass
{
protected:

		//reference count

		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirClassHandle *, ISmirClassHandle *> m_IHandleArray;
public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirClassHandle **phModule,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumClass  **ppenum);

		CEnumSmirClass ( CSmir *a_Smir , IN ISmirDatabase *pSmir = NULL , DWORD dwCookie = 0 ) ;
		CEnumSmirClass ( CSmir *a_Smir , IN ISmirDatabase *pSmir , IN ISmirGroupHandle *hGroup , DWORD dwCookie = 0 ) ;
		CEnumSmirClass ( CSmir *a_Smir , IN ISmirDatabase *pSmir , IN ISmirModHandle *hModule , DWORD dwCookie = 0 ) ;
		CEnumSmirClass ( IN IEnumClass *pSmirClass ) ;
		virtual ~CEnumSmirClass(){};

private:

		//private copy constructors to prevent bcopy
		CEnumSmirClass(CEnumSmirClass&);
		const CEnumSmirClass& operator=(CEnumSmirClass &);
};


class CEnumNotificationClass : public IEnumNotificationClass
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirNotificationClassHandle *, ISmirNotificationClassHandle *> m_IHandleArray;

public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirNotificationClassHandle **phClass,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumNotificationClass  **ppenum);

		CEnumNotificationClass ( IN CSmir *a_Smir , IN ISmirDatabase *pSmir=NULL, DWORD dwCookie=0);
		CEnumNotificationClass ( IN CSmir *a_Smir , IN ISmirDatabase *pSmir, IN ISmirModHandle *hModule, DWORD dwCookie=0);
		CEnumNotificationClass ( IN IEnumNotificationClass *pSmirClass);
		virtual ~CEnumNotificationClass(){};

private:

		//private copy constructors to prevent bcopy
		CEnumNotificationClass(CEnumNotificationClass&);
		const CEnumNotificationClass& operator=(CEnumNotificationClass &);
};

class CEnumExtNotificationClass : public IEnumExtNotificationClass
{
protected:

		//reference count
		LONG	m_cRef;
		int		m_Index;
		EnumObjectArray <ISmirExtNotificationClassHandle *, ISmirExtNotificationClassHandle *> m_IHandleArray;

public:

		//IUnknown members
		STDMETHODIMP         QueryInterface(IN REFIID,OUT PPVOID);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		//enum members
		STDMETHODIMP Next(IN ULONG celt,OUT ISmirExtNotificationClassHandle **phClass,OUT ULONG * pceltFetched);
		STDMETHODIMP Skip(IN ULONG celt);
		STDMETHODIMP Reset();
		STDMETHODIMP Clone(OUT IEnumExtNotificationClass  **ppenum);

		CEnumExtNotificationClass( IN CSmir *a_Smir , IN ISmirDatabase *pSmir=NULL, DWORD dwCookie=0);
		CEnumExtNotificationClass( IN CSmir *a_Smir , IN ISmirDatabase *pSmir, IN ISmirModHandle *hModule, DWORD dwCookie=0);
		CEnumExtNotificationClass( IN IEnumExtNotificationClass *pSmirClass);
		virtual ~CEnumExtNotificationClass(){};

private:

		//private copy constructors to prevent bcopy
		CEnumExtNotificationClass(CEnumExtNotificationClass&);
		const CEnumExtNotificationClass& operator=(CEnumExtNotificationClass &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\precomp.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PRECOMP_H_
#define __PRECOMP_H_

#include <ole2.h>
#include <windows.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\textdef.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _TEXTDEF_H_
#define _TEXTDEF_H_
/*********************  HMOM strings  **************************/
#define HMOM_CLASS_PREFIX		L"__"
#define HMOM_CONNECT_USER		L""
#define HMOM_CONNECT_PASSWORD	L""
#define HMOM_EMPTY_STRING		L""
#define HMOM_SNMPMACRO_STRING			L"SnmpMacro"
#define HMOM_SNMPOBJECTTYPE_STRING		L"SnmpObjectType"
#define HMOM_CLASS_EXTENDEDSTATUS			L"__ExtendedStatus"
#define HMOM_CLASS_SNMPNOTIFYSTATUS		L"SnmpNotifyStatus"
#define HMOM_PROPERTY_SNMPSTATUSCODE	L"SnmpStatusCode"
#define HMOM_PROPERTY_SNMPSTATUSMESSAGE L"Description"
#define HMOM_SNMPNOTIFICATIONTYPE_STRING	L"SnmpNotification"
#define HMOM_SNMPEXTNOTIFICATIONTYPE_STRING	L"SnmpExtendedNotification"

//Strings used during self registeration
#define CLSID_STR			L"Software\\Classes\\CLSID\\"
#define REG_FORMAT_STR		L"%s\\%s"
#define NOT_INTERT_STR		L"NotInsertable"
#define INPROC32_STR		L"InprocServer32"
#define SMIR_NAME_STR		L"Microsoft WBEM SNMP Module Information Repository"
#define THREADING_MODULE_STR L"ThreadingModel"
#define APARTMENT_STR		L"Both"

//name space strings
#define OLEMS_NAMESPACE_CLASS	L"__namespace"
#define SMIR_NAMESPACE_NAME		L"SMIR"
#define OLEMS_ROOT_NAMESPACE	L"root\\snmp"
#define OLEMS_ROOT_NAMESPACE_FROM_ROOT	L"\\\\.\\root\\snmp"
#define SMIR_NAMESPACE_FROM_ROOT	L"\\\\.\\root\\snmp\\SMIR"
#define SMIR_CLASS_ASSOCIATION_ENDPOINT    L"\\\\.\\root\\snmp\\SMIR:SMIR=\"@\""
#define SMIR_NAMESPACE			L"root\\snmp\\SMIR"
#define MODULE_NAMESPACE_NAME	L"SNMP_MODULE"
#define GROUP_NAMESPACE_NAME	L"SNMP_GROUP"
#define SMIR_INSTANCE_NAME		L"SMIR"
#define CLASS_CLASS_NAME		L"CLASS"
#define OLEMS_CLASS_PROP		L"__CLASS"
#define OLEMS_PATH_PROP			L"__PATH"
#define OLEMS_GENUS_PROP		L"__GENUS"
#define OLEMS_SUPERCLASS_PROP	L"__SUPERCLASS"
#define OLEMS_NAME_PROP			L"Name"
#define DOT_STR					L"."
#define BACKSLASH_STR			L"\\"
#define EQUALS_STR				L"="
#define KEY_STR					L"Key"
#define QUOTE_STR				L"\""
#define COLON_STR				L":"
#define SEMICOLON_STR			L";"
#define REF_STR					L"ref"
#define SYNTAX_STR				L"syntax"
#define ASSOC_STR				L"assoc"
#define ABSTRACT_STR			L"abstract"
#define OPEN_BRACE_STR			L"{"
#define CLOSE_BRACE_STR			L"}"
#define SPACE_STR				L" "
#define NEWLINE_STR				L"\n"

//name space property strings
/*********************  module namespace **************************/
#define MODULE_NAME_PROPERTY			L"Name"
#define MODULE_OID_PROPERTY				L"Module_Oid"
#define MODULE_ID_PROPERTY				L"Module_Identity"
#define MODULE_ORG_PROPERTY				L"Organization"
#define MODULE_CONTACT_PROPERTY			L"Contact_Inf"
#define MODULE_DESCRIPTION_PROPERTY		L"Description"
#define MODULE_REVISION_PROPERTY		L"Revision"
#define MODULE_SNMP_VERSION_PROPERTY	L"Snmp_Version"
#define MODULE_LAST_UPDATE_PROPERTY		L"Last_Updated"
#define MODULE_IMPORTS_PROPERTY			L"Module_Imports"

/*********************  group namespace **************************/
#define GROUP_NAME_PROPERTY				L"Name"
#define GROUP_ID_PROPERTY				L"Group_Id"
#define GROUP_STATUS_PROPERTY			L"Status"
#define GROUP_DESCRIPTION_PROPERTY		L"Description"
#define MODULE_REFERENCE_PROPERTY		L"Reference"

/*********************  class namespace **************************/
//#define CLASS_NAME_PROPERTY				L"Name"


/*********************  Mutex strings   **************************/
#define SMIR_INTERFACE_GARBAGE_MAP_MUTEX	L"SMIR_InterfaceGarbageMap"
#define SMIR_CSMIR_MUTEX					L"SMIR_CSmir"
#define SMIR_CSMIR_INTERROGATOR_MUTEX		L"SMIR_CSmirInterogator"
#define SMIR_CSMIR_ADMINISTRATOR_MUTEX		L"SMIR_CSmirAdministrator"
#define SMIR_ENUMOBJECT_MUTEX				L"SMIR_EnumObjectArray"


/*********************  Association strings   **************************/
#define SMIR_ASSOC_QUERY1_TYPE				L"WQL"
#define SMIR_ASSOC_QUERY2_TYPE				L"WQL"

#define SMIR_ASSOC_CLASS_NAME					L"SmirToClassAssociator"
#define SMIR_ASSOC_CLASS_NAME_POSTFIX			L"SMIRAssociation"
#define SMIR_ASSOC_SMIR_PROP					L"SmirName"

#define SMIR_NOTIFICATION_MAPPER				L"NotificationMapper"
#define SMIR_EXT_NOTIFICATION_MAPPER			L"ExtendedNotificationMapper"
#define SMIR_NOTIFICATION_TRAP_PROP				L"SnmpTrapOID"
#define SMIR_NOTIFICATION_CLASS_PROP			L"EventClassName"

#define SMIR_MODULE_ASSOC_NCLASS_NAME			L"ModToNotificationClassAssociator"
#define SMIR_MODULE_ASSOC_EXTNCLASS_NAME		L"ModToExtNotificationClassAssociator"
#define SMIR_MODULE_ASSOC_CLASS_NAME			L"ModuleToClassAssociator"
#define SMIR_MODULE_ASSOC_CLASS_NAME_POSTFIX	L"SMIRModuleAssociation"
#define SMIR_MODULE_ASSOC_MODULE_PROP			L"SmirModule"

#define SMIR_GROUP_ASSOC_CLASS_NAME				L"GroupToClassAssociator"
#define SMIR_GROUP_ASSOC_CLASS_NAME_POSTFIX		L"SMIRGroupAssociation"
#define SMIR_GROUP_ASSOC_GROUP_PROP				L"SmirGroup"

#define SMIR_X_ASSOC_NAME_PROP					L"AssocName"
#define SMIR_X_ASSOC_CLASS_PROP					L"SmirClass"

//Strings for Notification and Extended Notification Base classes
#define EXTRINSIC_EVENT_CLASS_NAME				L"__ExtrinsicEvent"
#define NOTIFICATION_CLASS_NAME					L"SnmpNotification"
#define EXT_NOTIFICATION_CLASS_NAME				L"SnmpExtendedNotification"
#define TIMESTAMP_PROP							L"TimeStamp"
#define SENDER_ADDR_PROP						L"AgentAddress"
#define SENDER_TADDR_PROP						L"AgentTransportAddress"
#define TRANSPORT_PROP							L"AgentTransportProtocol"
#define TRAPOID_PROP							L"Identification"
#define COMMUNITY_PROP							L"Community"

//strings for Event registration
#define FILTER_QUERYTYPE_VAL					L"WQL"
#define FILTER_QUERY_VAL						L"SELECT * FROM __ClassOperationEvent"

/*query strings for getting the classes associated with a group are of the form
 *L"associators of {\\\\.\\root\\default\\SMIR\\<module>:Group=\"<group>\"}",
 */
#define SMIR_ASSOC_QUERY_STR1				L"associators of "
#define SMIR_ASSOC_QUERY_STR2				L"references of "
#define SMIR_ASSOC_QUERY_STR3				L" where AssocClass"
#define SMIR_ASSOC_QUERY_STR4				L" where ResultClass"

#define SQL_QUERY_STR1						L"select * from "
#define SQL_QUERY_STR2						L" where "


/***************************Serialise strings ************************************/
#define ROOT_DEFAULT_NAMESPACE_PRAGMA		L"#pragma namespace(\"\\\\\\\\.\\\\root\\\\snmp\")\n"
#define SMIR_NAMESPACE_PRAGMA				L"#pragma namespace(\"\\\\\\\\.\\\\root\\\\snmp\\\\SMIR\")\n"
#define START_OF_SMIR_NAMESPACE_PRAGMA		L"#pragma namespace(\"\\\\\\\\.\\\\root\\\\snmp\\\\SMIR\\\\"
#define END_OF_NAMESPACE_PRAGMA				L"\")\n"
#define OLEMS_ROOT_NAMESPACE_STR			L"\\\\\\\\.\\\\root\\\\snmp"
#define SMIR_NAMESPACE_STR					L"\\\\\\\\.\\\\root\\\\snmp\\\\SMIR"
#define READONLY_STRING						(CString(L"[read] string "))
#define WRITE_STRING						(CString(L"[write] string "))
#define WRITE_LONG							(CString(L"[write] sint32 "))
#define READ_ONLY_KEY_STRING				(CString(L"[read, key] string "))
#define READ_ONLY_REF_STRING				(CString(L"[read] object ref "))
#define READONLY_LONG						(CString(L"[read] sint32 "))
#define QUAL_FLAVOUR						(CString(L":ToInstance ToSubClass DisableOverride"))
#define TIMESTAMP_QUALS_TYPE				(CString(L"[textual_convention(\"TimeTicks\")")\
												+QUAL_FLAVOUR\
												+CString(L",encoding(\"TimeTicks\")")\
												+QUAL_FLAVOUR\
												+CString(L",object_syntax(\"TimeTicks\")")\
												+QUAL_FLAVOUR\
												+CString(L",read,object_identifier(\"1.3.6.1.2.1.1.3\")")\
												+QUAL_FLAVOUR\
												+CString(L",description(\"The time (in hundredths of a second) since the network management portion of the agent was last re-initialized.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] uint32 "))
#define TRAPOID_QUALS_TYPE					(CString(L"[textual_convention(\"OBJECTIDENTIFIER\")")\
												+QUAL_FLAVOUR\
												+CString(L", encoding(\"OBJECTIDENTIFIER\")")\
												+QUAL_FLAVOUR\
												+CString(L", object_syntax(\"OBJECTIDENTIFIER\")")\
												+QUAL_FLAVOUR\
												+CString(L", read, object_identifier(\"1.3.6.1.6.3.1.1.4.1\")")\
												+QUAL_FLAVOUR\
												+CString(L",description(\"The authoratative identification of this notification.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define SENDER_ADDR_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The network address of the entity that created this notification.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define SENDER_TADDR_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The network address of the entity that sent this notification. This may be a proxy for the original entity.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define TRANSPORT_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The transport protocol used by the sending entity.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))
#define COMMUNITY_QUALS_TYPE				(CString(L"[read, ")\
												+CString(L"description(\"The security context used to send this notification.\")")\
												+QUAL_FLAVOUR\
												+CString(L"] string "))												
#define ASSOC_QUALIFIER						(CString(L"[Association]")+CString(NEWLINE_STR))

#define QUALIFIER_PROPAGATION				(CString(L"\
qualifier write:ToInstance ToSubClass;\n\
qualifier read:ToInstance ToSubClass;\n\
qualifier provider:ToInstance ToSubClass;\n\
qualifier singleton:ToInstance ToSubClass;\n\
qualifier dynamic:ToInstance ToSubClass;\n\
qualifier textual_convention:ToInstance ToSubClass;\n\
qualifier object_identifier:ToInstance ToSubClass;\n\
qualifier varbindindex:ToInstance ToSubClass;\n\
qualifier encoding:ToInstance ToSubClass;\n\
qualifier object_syntax:ToInstance ToSubClass;\n\
qualifier status:ToInstance ToSubClass;\n\
qualifier fixed_length:ToInstance ToSubClass;\n\
qualifier variable_length:ToInstance ToSubClass;\n\
qualifier variable_value:ToInstance ToSubClass;\n\
qualifier bits:ToInstance ToSubClass;\n\
qualifier key_order:ToInstance ToSubClass;\n\
qualifier enumeration:ToInstance ToSubClass;\n\
qualifier bits:ToInstance ToSubClass;\n") + \
										CString(L"\
qualifier description:ToInstance ToSubClass;\n\
qualifier display_hint:ToInstance ToSubClass;\n\
qualifier defval:ToInstance ToSubClass;\n\
qualifier units:ToInstance ToSubClass;\n\
qualifier reference:ToInstance ToSubClass;\n\
qualifier virtual_key:ToInstance ToSubClass;\n\
qualifier rowstatus:ToInstance ToSubClass;\n\
qualifier module_name:ToInstance ToSubClass;\n\
qualifier module_imports:ToInstance ToSubClass;\n\
qualifier group_objectid:ToInstance ToSubClass;\n\n"))



#define INSTANCE_END						(CString(ESCAPED_QUOTE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR)\
											+CString(CLOSE_BRACE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR))

#define INSTANCE_START						(CString(L"instance of "))
#define END_OF_PROPERTY						(CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR))

#define NL_BRACE_NL_STR						(CString(NEWLINE_STR)\
											+CString(OPEN_BRACE_STR)\
											+CString(NEWLINE_STR))

#define END_OF_CLASS						(CString(CLOSE_BRACE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR)\
											+CString(NEWLINE_STR))

#define END_OF_INSTANCE						END_OF_CLASS

#define START_OF_PROPERTY_VALUE				(CString(EQUALS_STR)\
											+CString(QUOTE_STR))

#define END_OF_PROPERTY_VALUE				(CString(QUOTE_STR)\
											+CString(SEMICOLON_STR)\
											+CString(NEWLINE_STR))

#define	ESCAPED_QUOTE_STR					L"\\\""

#define ABSTRACT_CLASS_STRING				L"[abstract]\nclass "
#define CLASS_STRING						L"class "

#define SMIR_CLASS_DEFINITION					(CString(CLASS_STRING)\
												+CString(SMIR_INSTANCE_NAME)\
												+CString(COLON_STR)\
												+CString(OLEMS_NAMESPACE_CLASS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR)\
												+CString(READONLY_STRING)\
												+CString(OLEMS_NAME_PROP)\
												+CString(EQUALS_STR)\
												+CString(QUOTE_STR)\
												+CString(SMIR_INSTANCE_NAME)\
												+CString(END_OF_PROPERTY_VALUE)\
												+CString(END_OF_CLASS))

#define SMIR_INSTANCE_DEFINITION				(CString(INSTANCE_START)\
												+CString(SMIR_INSTANCE_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR)\
												+CString(END_OF_INSTANCE))


#define SNMPMACRO_CLASS_START					(CString(ABSTRACT_CLASS_STRING)\
												+CString(HMOM_SNMPMACRO_STRING)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define SNMPOBJECTTYPE_CLASS_START				(CString(ABSTRACT_CLASS_STRING)\
												+CString(HMOM_SNMPOBJECTTYPE_STRING)\
												+CString(COLON_STR)\
												+CString(HMOM_SNMPMACRO_STRING)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define SNMPNOTIFYSTATUS_CLASS_START			(CString(CLASS_STRING)\
												+CString(HMOM_CLASS_SNMPNOTIFYSTATUS)\
												+CString(COLON_STR)\
												+CString(HMOM_CLASS_EXTENDEDSTATUS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR)\
												+CString(WRITE_LONG)\
												+CString(HMOM_PROPERTY_SNMPSTATUSCODE)\
												+CString(SEMICOLON_STR)\
												+CString(NEWLINE_STR)\
												+CString(WRITE_STRING)\
												+CString(HMOM_PROPERTY_SNMPSTATUSMESSAGE)\
												+CString(SEMICOLON_STR)\
												+CString(NEWLINE_STR))

#define SNMPNOTIFICATION_CLASS_START			(CString(CLASS_STRING)\
												+CString(NOTIFICATION_CLASS_NAME)\
												+CString(COLON_STR)\
												+CString(EXTRINSIC_EVENT_CLASS_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define SNMPEXTNOTIFICATION_CLASS_START			(CString(CLASS_STRING)\
												+CString(EXT_NOTIFICATION_CLASS_NAME)\
												+CString(COLON_STR)\
												+CString(EXTRINSIC_EVENT_CLASS_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define NOTIFICATIONMAPPER_CLASS_START			(CString(CLASS_STRING)\
												+CString(SMIR_NOTIFICATION_MAPPER)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define EXTNOTIFICATIONMAPPER_CLASS_START		(CString(CLASS_STRING)\
												+CString(SMIR_EXT_NOTIFICATION_MAPPER)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define MODULE_CLASS_START						(CString(CLASS_STRING)\
												+CString(MODULE_NAMESPACE_NAME)\
												+CString(COLON_STR)\
												+CString(OLEMS_NAMESPACE_CLASS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define MODULE_INSTANCE_START					(CString(INSTANCE_START)\
												+CString(MODULE_NAMESPACE_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define GROUP_CLASS_START						(CString(CLASS_STRING)\
												+CString(GROUP_NAMESPACE_NAME)\
												+CString(COLON_STR)\
												+CString(OLEMS_NAMESPACE_CLASS)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#define GROUP_INSTANCE_START					(CString(INSTANCE_START)\
												+CString(GROUP_NAMESPACE_NAME)\
												+CString(NEWLINE_STR)\
												+CString(OPEN_BRACE_STR)\
												+CString(NEWLINE_STR))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\main.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <stdio.h>
#include "reg.h"

// Function pointer type used with LoadMofFiles entrypoint in wbemupgd.dll
typedef BOOL ( WINAPI *PFN_LOAD_MOF_FILES )(wchar_t* pComponentName, const char* rgpszMofFilename[]);

HRESULT SetSNMPBuildRegValue();

BOOL WINAPI DllMain( IN HINSTANCE	hModule, 
                     IN ULONG		ul_reason_for_call, 
                     LPVOID			lpReserved
					)
{
	return TRUE;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup to perform various setup tasks
//          (This is not the normal use of DllRegisterServer!)
//
// Return:  NOERROR
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    // load the MOF files for this component
    HRESULT hr = NOERROR;
    
    HINSTANCE hinstWbemupgd = LoadLibraryW(L"wbemupgd.dll");
    if (hinstWbemupgd)
    {
        PFN_LOAD_MOF_FILES pfnLoadMofFiles = (PFN_LOAD_MOF_FILES) GetProcAddress(hinstWbemupgd, "LoadMofFiles"); // no wide version of GetProcAddress
        if (pfnLoadMofFiles)
        {
            wchar_t*    wszComponentName = L"SNMP Provider";
            const char* rgpszMofFilename[] = 
            {
                "snmpsmir.mof",
                "snmpreg.mof",
                NULL
            };
        
            if (!pfnLoadMofFiles(wszComponentName, rgpszMofFilename))
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    
        FreeLibrary(hinstWbemupgd);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    if (SUCCEEDED(hr))
    {
        SetSNMPBuildRegValue();  // set SNMP build number in registry
    }

    return hr;
}

HRESULT SetSNMPBuildRegValue()
{
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != Registry::no_error)
	{
		return E_FAIL;
	}
	
	char* pszBuildNo = new char[10];

	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(GetVersionEx(&os))
	{
		sprintf(pszBuildNo, "%lu.0000", os.dwBuildNumber);
	}
	r.SetStr("SNMP Build", pszBuildNo);

	delete [] pszBuildNo;

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\smir\include\thread.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _THREAD_H_
#define _THREAD_H_


#define THREAD_STARED			100
#define WAIT_EVENT_0			WAIT_OBJECT_0
#define WAIT_EVENT_FAILED		(MAXIMUM_WAIT_OBJECTS+1)
#define WAIT_EVENT_ABANDONED	(MAXIMUM_WAIT_OBJECTS+2)
#define WAIT_EVENT_TERMINATED	(MAXIMUM_WAIT_OBJECTS+3)

typedef void (*PVOIDTHREADPROC)(void *);
/*
 * Each connection is saved so that we can enumerate, delete, and trigger
 * This template provides the container for the connections and cookies
 */
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class EventMap : public CObject
{
private:

	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> m_cmap ;

protected:
public:

	EventMap () ;
	virtual ~EventMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: EventMap ()  
{
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~EventMap () 
{
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	int count = m_cmap.GetCount () ;
	return count ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	return m_cmap.IsEmpty () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	return m_cmap.Lookup ( key , rValue ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	return m_cmap.operator [] ( key ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	m_cmap.SetAt ( key , newValue ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	return m_cmap.RemoveKey ( key ) ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
		m_cmap.RemoveAll () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	return m_cmap.GetStartPosition () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void EventMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	m_cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;

}
/*InterfaceGarbageCollector makes it easier to use the  interface
 *by remembering to release them when you fall out of scope. The is 
 *useful when you are using an IMosProvider and have lots of points
 *of failure; you can just give up and let the wrapper clean up for 
 *you.
 */
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class ThreadMap : public CObject
{
private:
	CCriticalSection * criticalSection ;
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> cmap ;
protected:
public:

	ThreadMap ();
	virtual ~ThreadMap () ;
	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ThreadMap () : 
								 criticalSection(NULL)
{
		criticalSection = new CCriticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~ThreadMap () 
{
	//this may be null
	delete criticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	criticalSection->Lock () ;
	int count = cmap.GetCount () ;
	criticalSection->Unlock () ;
	return count ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if (TRUE == m_bMakeThreadSafe)
	{
		criticalSection->Lock () ;
		BOOL isEmpty = cmap.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	criticalSection->Lock () ;
	BOOL lookup = cmap.Lookup ( key , rValue ) ;
	criticalSection->Unlock () ;
	return lookup ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	criticalSection->Lock () ;
	VALUE &value = cmap.operator [] ( key ) ;
	criticalSection->Unlock () ;
	return value ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	criticalSection->Lock () ;
	cmap.SetAt ( key , newValue ) ;
	criticalSection->Unlock () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	criticalSection->Lock () ;
	BOOL removeKey = cmap.RemoveKey ( key ) ;
	criticalSection->Unlock () ;
	return removeKey ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	criticalSection->Lock () ;
	cmap.RemoveAll () ;
	criticalSection->Unlock () ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	criticalSection->Lock () ;
	POSITION position = cmap.GetStartPosition () ;
	criticalSection->Unlock () ;
	return position ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ThreadMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	criticalSection->Lock () ;
	cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	criticalSection->Unlock () ;
}
class CThread 
{
	private:
	   BOOL				 bWaiting;
	   HANDLE			 m_hThreadStopEvent;
	   HANDLE			 m_hThreadSyncEvent;
  	   DWORD			 m_cRef;

	   EventMap <HANDLE, HANDLE, HANDLE,HANDLE> m_UserEvents ;
	   static ThreadMap <CThread*, CThread*, CThread*,CThread*> m_ThreadMap ;

    protected:
   	   uintptr_t			 m_ulThreadHandle;

	public:
		CThread();
		virtual ~CThread();
		SCODE Start();
		SCODE Stop();
		SCODE Wait(DWORD timeout = INFINITE);
		virtual SCODE Process(){return S_OK;};
		void AddEvent(HANDLE userEvent){m_UserEvents.SetAt(userEvent,userEvent);}
		void DeleteEvent(HANDLE userEvent){m_UserEvents.RemoveKey(userEvent);}
		void Exit(){SetEvent(m_hThreadSyncEvent);}
		ULONG AddRef(void){return ++m_cRef;}
		ULONG Release(void);
		operator void*();
		static void ProcessDetach();
 };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\reg.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "reg.h"
#include <stdio.h>

Registry::Registry(char *pszLocalMachineStartKey)
{
    hPrimaryKey	= 0;
    hSubkey = 0;
    m_nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey);
    hSubkey = hPrimaryKey;
}
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}
int Registry::Open(HKEY hStart, const char *pszStartKey)
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

	m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
									0, 0, 0,
									KEY_ALL_ACCESS, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}
char* Registry::GetMultiStr(const char *pszValueName, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return NULL;
	}
	if (dwSize == 0)
	{
		return NULL;
	}

	//allocate the buffer required
	char *pData = new char[dwSize];
	if (!pData)
	{
		dwSize = 0;
		return NULL;
	}
	
	//get the values
	m_nLastError = RegQueryValueEx(hSubkey, 
								   pszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return NULL;
	}

	return pData;
}

int Registry::SetMultiStr(const char *pszValueName, const char*pszValue, DWORD dwSize)
{
	m_nLastError = RegSetValueEx(hSubkey, 
								 pszValueName, 
								 0, 
								 REG_MULTI_SZ, 
								 LPBYTE(pszValue), 
								 dwSize);

    if (m_nLastError != 0)
		return failed;

    return no_error;
}

int Registry::GetStr(const char *pszValueName, char **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    char *p = new char[dwSize];
	if (!p)
		return failed;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		char tTemp;

		// Get the initial length
        DWORD nSize = ExpandEnvironmentStrings(p,&tTemp,1) + 1;
        TCHAR* pTemp = new TCHAR[nSize+1];
		if (!pTemp)
			return failed;

        if (!ExpandEnvironmentStrings(p,pTemp,nSize+1))
		{
			delete [] p;
			delete [] pTemp;
			return failed;
		}

        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}

int Registry::DeleteEntry(const char *pszValueName)
{
	m_nLastError = RegDeleteValue(  hSubkey, pszValueName);
	if (m_nLastError != 0)
	{
		return failed;
	}
	else
		return no_error;
}
int Registry::SetStr(char *pszValueName, char *pszValue)
{
	m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue),
        strlen(pszValue) + 1);

    if (m_nLastError != 0)
		return failed;
    return no_error;
}

int Registry::GetDWORD(TCHAR *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}

int Registry::SetDWORDStr(char *pszValueName, DWORD dwVal)
{
    char cTemp[30];
    sprintf(cTemp, "%d", dwVal);

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(cTemp),
		strlen(cTemp) + 1);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\snmpsetup\reg.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_REG_WBEM					"Software\\Microsoft\\WBEM"
#define WBEM_REG_WINMGMT				"Software\\Microsoft\\WBEM\\CIMOM"
#define WBEM_REG_AUTORECOVER			"Autorecover MOFs"
#define WBEM_REG_AUTORECOVER_EMPTY		"Autorecover MOFs (empty)"
#define WBEM_REG_AUTORECOVER_RECOVERED	"Autorecover MOFs (recovered)"
#define SYSTEM_SETUP_REG				"System\\Setup"

class Registry
{
    HKEY	hPrimaryKey;
    HKEY	hSubkey;
    int		m_nStatus;
	LONG	m_nLastError;
public:
    enum { no_error, failed };

	Registry(char *pszLocalMachineStartKey);
	~Registry();
	int Open(HKEY hStart, const char *pszStartKey);
	int GetStr(const char *pszValueName, char **pValue);
	char* GetMultiStr(const char *pszValueName, DWORD &dwSize);
	int SetMultiStr(const char *pszValueName, const char*pData, DWORD dwSize);
	int DeleteEntry(const char *pszValueName);
	int SetStr(char *pszValueName, char *pszValue);
    int GetDWORD(TCHAR *pszValueName, DWORD *pdwValue);
    int SetDWORDStr(char *pszValueName, DWORD dwValue);
	int GetStatus() { return m_nStatus;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the global dll functions

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <olectl.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <windows.h>
#include <stdio.h>
#include <provexpt.h>
#include <tchar.h>
#include <wbemidl.h>
#include <provcoll.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

//OK we need these globals
HINSTANCE   g_hInst = NULL;
ProvDebugLog* CViewProvServ::sm_debugLog = NULL;
IUnsecuredApartment* CViewProvServ::sm_UnsecApp = NULL;

CRITICAL_SECTION g_CriticalSection;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection(&g_CriticalSection);
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		g_hInst=hInstance;
		InitializeCriticalSection(&g_CriticalSection);
		DisableThreadLibraryCalls(hInstance);

		CViewProvServ::sm_debugLog = ProvDebugLog::GetProvDebugLog(LOG_VIEWPROV);
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
    }

    return status;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ;
	SetStructuredExceptionHandler seh;

	BOOL bEnteredCritSec = FALSE;

	BOOL bAllocate = FALSE;
	BOOL bDebugLog = FALSE;

	BOOL bClear = FALSE;

	try
	{
		EnterCriticalSection(&g_CriticalSection);
		bEnteredCritSec = TRUE;


		if ( rclsid == CLSID_CViewProviderClassFactory ) 
		{
			CViewProvClassFactory *lpunk = new CViewProvClassFactory;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;

				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
			}
		}
		else
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}

		LeaveCriticalSection(&g_CriticalSection);
		bEnteredCritSec = FALSE;
	}
	catch(Structured_Exception e_SE)
	{
		bClear = TRUE;
		status = E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		bClear = TRUE;
		status = E_OUTOFMEMORY;
	}
	catch(...)
	{
		bClear = TRUE;
		status = E_UNEXPECTED;
	}

	if ( bEnteredCritSec )
	{

		LeaveCriticalSection(&g_CriticalSection);
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	BOOL unload = FALSE;
	SetStructuredExceptionHandler seh;

	BOOL bEnteredCritSec = FALSE;

	try
	{
		EnterCriticalSection(&g_CriticalSection);
		bEnteredCritSec = TRUE;

		unload = (0 == CViewProvClassFactory :: locksInProgress)
						&& (0 == CViewProvClassFactory :: objectsInProgress);

		if (unload)
		{

			if (NULL != CViewProvServ::sm_UnsecApp)
			{
				CViewProvServ::sm_UnsecApp->Release();
				CViewProvServ::sm_UnsecApp = NULL;
			}
		}

		LeaveCriticalSection(&g_CriticalSection);
		bEnteredCritSec = FALSE;
	}
	catch(Structured_Exception e_SE)
	{
		unload = FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		unload = FALSE;
	}
	catch(...)
	{
		unload = FALSE;
	}

	if ( bEnteredCritSec )
	{
		LeaveCriticalSection(&g_CriticalSection);
	}

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

//Strings used during self registeration

#define REG_FORMAT2_STR			_T("%s%s")
#define REG_FORMAT3_STR			_T("%s%s\\%s")
#define VER_IND_STR				_T("VersionIndependentProgID")
#define NOT_INTERT_STR			_T("NotInsertable")
#define INPROC32_STR			_T("InprocServer32")
#define PROGID_STR				_T("ProgID")
#define THREADING_MODULE_STR	_T("ThreadingModel")
#define APARTMENT_STR			_T("Both")

#define CLSID_STR				_T("CLSID\\")

#define PROVIDER_NAME_STR		_T("Microsoft WBEM View Provider")
#define PROVIDER_STR			_T("WBEM.VIEW.PROVIDER")
#define PROVIDER_CVER_STR		_T("WBEM.VIEW.PROVIDER\\CurVer")
#define PROVIDER_CLSID_STR		_T("WBEM.VIEW.PROVIDER\\CLSID")
#define PROVIDER_VER_CLSID_STR	_T("WBEM.VIEW.PROVIDER.0\\CLSID")
#define PROVIDER_VER_STR		_T("WBEM.VIEW.PROVIDER.0")

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(TCHAR* pszKey, TCHAR* pszSubkey, TCHAR* pszValueName, TCHAR* pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

	_tcscpy(szKey, HKEYCLASSES);
    _tcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		_tcscat(szKey, _T("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);

    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer()
{
	SetStructuredExceptionHandler seh;

	try
	{
		TCHAR szModule[MAX_PATH + 1];
		GetModuleFileName(g_hInst,(TCHAR*)szModule, MAX_PATH + 1);
		TCHAR szProviderClassID[128];
		TCHAR szProviderCLSIDClassID[128];
#ifndef UNICODE
		wchar_t t_strGUID[128];

		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, t_strGUID, 128))
		{
			return SELFREG_E_CLASS;
		}

		if (0 == WideCharToMultiByte(CP_ACP,
							0,
							t_strGUID,
							-1,
							szProviderClassID,
							128,
							NULL,
							NULL))
		{
			return SELFREG_E_CLASS;
	}
#else
		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, szProviderClassID, 128))
		{
			return SELFREG_E_CLASS;
		}
#endif

		_tcscpy(szProviderCLSIDClassID,CLSID_STR);
		_tcscat(szProviderCLSIDClassID,szProviderClassID);

			//Create entries under CLSID
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
			return SELFREG_E_CLASS;
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
			return SELFREG_E_CLASS;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	HRESULT hr = S_OK;
	SetStructuredExceptionHandler seh;

	try
	{
		TCHAR szTemp[128];
		TCHAR szProviderClassID[128];
		TCHAR szProviderCLSIDClassID[128];
#ifndef UNICODE
		wchar_t t_strGUID[128];

		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, t_strGUID, 128))
		{
			return SELFREG_E_CLASS;
		}

		if (0 == WideCharToMultiByte(CP_ACP,
							0,
							t_strGUID,
							-1,
							szProviderClassID,
							128,
							NULL,
							NULL))
		{
			return SELFREG_E_CLASS;
		}
#else
		if (0 == StringFromGUID2(CLSID_CViewProviderClassFactory, szProviderClassID, 128))
		{
			return SELFREG_E_CLASS;
		}
#endif

		_tcscpy(szProviderCLSIDClassID,CLSID_STR);
		_tcscat(szProviderCLSIDClassID,szProviderClassID);

		//Delete entries under CLSID
		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, PROGID_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, VER_IND_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, NOT_INTERT_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, INPROC32_STR);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}

		_stprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szProviderCLSIDClassID);
		
		if (ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp))
		{
			hr = SELFREG_E_CLASS;
		}
	}
	catch(Structured_Exception e_SE)
	{
		hr = E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		hr = E_OUTOFMEMORY;
	}
	catch(...)
	{
		hr = E_UNEXPECTED;
	}

    return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//


#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


WMIPRECOMPSHARED=1
USE_RTTI=1
USE_NATIVE_EH=ASYNC

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=viewprov
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS= \
    $(FRAMEWORK_EXPT_LIB) \
	$(FRAMEWORK_THRD_LIB) \
	$(FRAMEWORK_MFC_LIB) \
	$(FRAMEWORK_PARSER_LIB) \
	$(UTILLIB_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\activeds.lib \
	$(SDK_LIB_PATH)\adsiid.lib   \
	$(SDK_LIB_PATH)\advapi32.lib

INCLUDES=$(INCLUDES); \
	..\include; \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
	$(UTILLIB_INC); \
	$(FRAMEWORK_THRD_INC); \
	$(WBEMCOMN_INC); \
	$(FRAMEWORK_PARSER_INC); \
	$(FRAMEWORK_MFC_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \

SOURCES=\
	..\viewprov.rc	\
	..\maindll.cpp	\
	..\vpcfac.cpp \
	..\vpserv.cpp \
	..\vpget.cpp \
	..\vpput.cpp \
	..\vpquery.cpp \
	..\vpmthd.cpp \
	..\vpquals.cpp \
	..\vptasks.cpp \
	..\vptasksu.cpp \
	..\vptasksh.cpp \
	..\vptasksj.cpp \
	..\vpsinks.cpp \
	..\vp_core_qengine.cpp


# Next, specify options for the compiler using C_DEFINES. 
#C_DEFINES=$(C_DEFINES) -DLOCAL_SERVER -D_WIN32_DCOM -DVP_BUILD_AS_EXE -DVP_PERFORMANT_JOINS
C_DEFINES=$(C_DEFINES) -DVP_PERFORMANT_JOINS
USE_MSVCRT=1
USE_VCCOM=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\viewprov.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpget.cpp ===
//***************************************************************************

//

//  VPGET.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the GetObject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>


GetObjectTaskObject::GetObjectTaskObject(CViewProvServ *a_Provider, 
	wchar_t *a_ObjectPath, ULONG a_Flag, IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *pCtx, IWbemServices* a_Serv, CWbemServerWrap *a_ServerWrap)
: WbemTaskObject (a_Provider, a_NotificationHandler, a_Flag, pCtx, a_Serv, a_ServerWrap),
	m_ObjectPath(NULL),
	m_ParsedObjectPath(NULL)
{
	m_ObjectPath = UnicodeStringDuplicate(a_ObjectPath);
}

GetObjectTaskObject::~GetObjectTaskObject ()
{
	BOOL t_Status = TRUE;

	if (m_bIndicate)
	{
		IWbemClassObject *t_NotifyStatus = NULL ;

		if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
		{
			t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		}

		if ( t_Status )
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
			
			if (t_NotifyStatus)
			{
				t_NotifyStatus->Release () ;
			}
		}
		else
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
		}
	}

	if (m_ObjectPath != NULL)
	{
		delete [] m_ObjectPath;
	}

	if (NULL != m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath;
	}

	if (m_StatusHandle != NULL)
	{
		CloseHandle(m_StatusHandle);
	}
}

BOOL GetObjectTaskObject::PerformGet(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst, const wchar_t* src, BOOL bAllprops)
{
	m_StatusHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
	
	if (m_StatusHandle == NULL)
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to create an Synchronization object" ) ;
		return FALSE;
	}

	BOOL retVal = PerformQueries(a_ErrorObject, bAllprops);
	BOOL bWait = TRUE;

	while (retVal && bWait)
	{
		DWORD dwWait = WbemWaitForSingleObject(m_StatusHandle, VP_QUERY_TIMEOUT);

		switch(dwWait)
		{
			case  WAIT_OBJECT_0:
			{
				retVal = ProcessResults(a_ErrorObject, pInst, src);
				bWait = FALSE;
			}
			break;

			case WAIT_TIMEOUT:
			{
				BOOL bCleanup = TRUE;

				if (m_ArrayLock.Lock())
				{
					if (m_ResultReceived)
					{
						m_ResultReceived = FALSE;
						bCleanup = FALSE;
					}

					m_ArrayLock.Unlock();
				}

				if (bCleanup)
				{
					CleanUpObjSinks(TRUE);
					a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed, or query timed out" ) ;
					retVal = FALSE;
					bWait = FALSE;
				}
			}
			break;

			default:
			{
				//Cancel outstanding requests and delete object sinks...
				//======================================================
				CleanUpObjSinks(TRUE);
				a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed" ) ;
				retVal = FALSE;
				bWait = FALSE;
			}
		}
	}

	return retVal;
}

BOOL GetObjectTaskObject::PerformQueries(WbemProvErrorObject &a_ErrorObject, BOOL bAllprops)
{
	//need enough tokens to handle association work-around serverpath or dotpath or relpath
	SQL_LEVEL_1_TOKEN* tokArray = new SQL_LEVEL_1_TOKEN[(m_ParsedObjectPath->m_dwNumKeys) * 6];
	m_iQueriesAsked++;
	m_ObjSinkArray.SetSize(0, m_NSpaceArray.GetSize());

	BOOL bStatusSet = FALSE;

	//m_NSpaceArray size is 1 for associations
	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		BOOL bContinue = TRUE;
		DWORD dwToks = 0;
		BOOL bFirst = TRUE;

		for (int i = 0; i < m_ParsedObjectPath->m_dwNumKeys; i++)
		{
			CPropertyQualifierItem* propItem;
			BOOL bFoundKey = FALSE;

			if (m_ParsedObjectPath->m_paKeys[i]->m_pName != NULL)
			{
				bFoundKey = m_PropertyMap.Lookup(m_ParsedObjectPath->m_paKeys[i]->m_pName, propItem);
			}
			else if (m_ParsedObjectPath->m_dwNumKeys == 1)
			{
				POSITION pos = m_PropertyMap.GetStartPosition();

				while (pos)
				{
					CStringW itmName;
					m_PropertyMap.GetNextAssoc(pos, itmName, propItem);
				
					if (propItem->IsKey())
					{
						bFoundKey = TRUE;
						break;
					}
				}
			}

			if (bFoundKey)
			{
				if (!propItem->m_SrcPropertyNames[x].IsEmpty())
				{
					tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
					tokArray[dwToks].nOperator = SQL_LEVEL_1_TOKEN::OP_EQUAL;
					tokArray[dwToks].pPropertyName = propItem->m_SrcPropertyNames[x].AllocSysString();
					
					if (m_bAssoc && (propItem->GetCimType() == CIM_REFERENCE))
					{
						bContinue = TransposeReference(propItem, m_ParsedObjectPath->m_paKeys[i]->m_vValue,
														&(tokArray[dwToks].vConstValue), FALSE, NULL);

						if (!bContinue)
						{
							break;
						}
						else
						{
							//add the extra tokens if neccessary
							//for the association work-around
							wchar_t *t_pChar = tokArray[dwToks].vConstValue.bstrVal;

							//must be \\server\namespace and not \\.\namespace or relpath
							if ( (*t_pChar == L'\\') && (*(t_pChar+1) == L'\\') && (*(t_pChar+2) != L'.') )
							{
								//add the dotted version
								tokArray[dwToks + 1] = tokArray[dwToks];
								dwToks++;
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 2;
								
								while (*t_pChar != L'\\')
								{
									t_pChar++;
								}

								--t_pChar;
								*t_pChar = L'.';
								--t_pChar;
								*t_pChar = L'\\';
								--t_pChar;
								*t_pChar = L'\\';
								BSTR t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;

								//add the relpath version
								tokArray[dwToks + 1] = tokArray[dwToks - 1];
								dwToks++;
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 4;
								
								while (*t_pChar != L':')
								{
									t_pChar++;
								}

								//exclude the ':'
								t_pChar++;
								t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
							}
						}
					}
					else
					{
						VariantInit(&(tokArray[dwToks].vConstValue));

                        if (FAILED(VariantCopy(&(tokArray[dwToks].vConstValue),
								&(m_ParsedObjectPath->m_paKeys[i]->m_vValue))))
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
					}

					//after every key add an AND
					//except if this is the first key && there is no where clause
					dwToks++;

					if ((!bFirst) || (m_SourceArray[x]->GetRPNExpression()->nNumTokens != 0))
					{
						tokArray[dwToks++].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;				
					}

					bFirst = FALSE;
				}
			}
		}

		if (bContinue)
		{
			CStringW queryStr = GetStringFromRPN(m_SourceArray[x]->GetRPNExpression(), dwToks, tokArray, bAllprops);
			CObjectSinkResults * objSnk = new CObjectSinkResults(this, x);
			objSnk->AddRef();
			m_ObjSinkArray.SetAtGrow(x, objSnk);
			CWbemServerWrap** nsPtrs = m_NSpaceArray[x]->GetServerPtrs();

			for (int m = 0; m < m_NSpaceArray[x]->GetCount(); m++)
			{
				if (nsPtrs[m] != NULL)
				{
					CViewProvObjectSink* pSnk = new CViewProvObjectSink(objSnk, nsPtrs[m], m);
					pSnk->AddRef();
					BSTR queryBStr = queryStr.AllocSysString();
					BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);
					IWbemObjectSink* pQuerySink = pSnk;
					IWbemContext * t_pCtx = m_Ctx;

					if (nsPtrs[m]->IsRemote())
					{
#if 0
#if (VER_PRODUCTMAJORVERSION < 0x5)
						pQuerySink = pSnk->Associate();
#endif
#endif
						t_pCtx = NULL; //don't use context for remote calls
					}

					IWbemServices *ptmpServ = nsPtrs[m]->GetServerOrProxy();

					if (ptmpServ)
					{
						if ( pQuerySink )
						{
							HRESULT t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);

							if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[m]->IsRemote())
							{
								if ( SUCCEEDED(UpdateConnection(&(nsPtrs[m]), &ptmpServ)) )
								{
									if (ptmpServ)
									{
										t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);
									}
								}
							}

							if (SUCCEEDED(t_hr))
							{
								if (m_ArrayLock.Lock())
								{
									m_iQueriesAsked++;
									m_ArrayLock.Unlock();
								}
								else
								{
									pSnk->DisAssociate();
								}
							}
							else
							{
								pSnk->DisAssociate();
							}
						}
						else
						{
							pSnk->DisAssociate();
						}

						if (ptmpServ)
						{
							nsPtrs[m]->ReturnServerOrProxy(ptmpServ);
						}
					}
					else
					{
						pSnk->DisAssociate();
					}

					pSnk->Release();
					SysFreeString(queryBStr);
					SysFreeString(queryLBStr);
				}
				else
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_NAMESPACE ) ;
					a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_NSpaceArray[x]->GetServerCreationError () ) ;
					a_ErrorObject.SetMessage ( L"Failed to send query, invalid or inaccessible namespace" ) ;

					bStatusSet = TRUE;
				}
			}
		}

		//clean up token array for next pass...
		for (int n = 0; n < dwToks; n++)
		{
			if (tokArray[n].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
			{
				VariantClear(&(tokArray[n].vConstValue));
				SysFreeString(tokArray[n].pPropertyName);
				tokArray[n].pPropertyName = NULL;
			}
		}
	}

	delete [] tokArray;

	if (m_ArrayLock.Lock())
	{
		m_iQueriesAsked--;

		if (m_iQueriesAsked != m_iQueriesAnswered)
		{
			//just in case this was triggerred while we had yet to ask some queries
			ResetEvent(m_StatusHandle);
		}
		else
		{
			//just in case this wasn't triggerred while we were asking queries
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}

	if (m_iQueriesAsked == 0)
	{
		for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
		{
			if (m_ObjSinkArray[x] != NULL)
			{
				m_ObjSinkArray[x]->Release();
			}
		}

		m_ObjSinkArray.RemoveAll();

		if ( ! bStatusSet )
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to send any queries, invalid namespaces" ) ;
		}
		return FALSE;
	}

	return TRUE;
}

BOOL GetObjectTaskObject::ProcessResults(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst, const wchar_t* src)
{
	BOOL retVal = TRUE;
	int arrayIndex;
	int indexCnt = 0;

	for (int x = 0; retVal && (x < m_ObjSinkArray.GetSize()); x++)
	{
		if ((m_ObjSinkArray[x] != NULL) && m_ObjSinkArray[x]->IsSet())
		{
			if (SUCCEEDED(m_ObjSinkArray[x]->GetResult()))
			{
				DWORD dwCount = m_ObjSinkArray[x]->m_ObjArray.GetSize();

				if (0 < dwCount)
				{
					arrayIndex = x;
					indexCnt++;
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_ObjSinkArray[x]->GetResult() ) ;
				a_ErrorObject.SetMessage ( L"Object path and Class qualifiers resulted in a failed query." ) ;
			}
		}
		else 
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Invalid source namespace path OR object path and Class qualifiers resulted in a failed query." ) ;
		}
	}

	if (retVal)
	{
		if (0 == indexCnt)
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"No source objects found to support view object path." ) ;
			CleanUpObjSinks();
		}
		else
		{
			if ((src != NULL) && (pInst != NULL))
			{
				DWORD *pdwIndices = NULL;
				DWORD dwIndxCount = GetIndexList(src, &pdwIndices);

				for (DWORD i = 0; i < dwIndxCount; i++)
				{
					if ((m_ObjSinkArray[pdwIndices[i]] != NULL) && SUCCEEDED(m_ObjSinkArray[pdwIndices[i]]->GetResult())
						&& m_ObjSinkArray[pdwIndices[i]]->m_ObjArray.GetSize() == 1)
					{
						if (*pInst == NULL)
						{
							m_ObjSinkArray[pdwIndices[i]]->m_ObjArray[0]->GetWrappedObject()->AddRef();
							*pInst = m_ObjSinkArray[pdwIndices[i]]->m_ObjArray[0]->GetWrappedObject();
						}
						else
						{
							(*pInst)->Release();
							*pInst = NULL;
						}
					}
				}

				if (dwIndxCount)
				{
					delete [] pdwIndices;
				}
			}

			if (m_JoinOnArray.IsValid())
			{
#ifdef VP_PERFORMANT_JOINS
				retVal = CreateAndIndicateJoinsPerf(a_ErrorObject, TRUE);
#else
				retVal = CreateAndIndicateJoins(a_ErrorObject, TRUE);
#endif

				if (!retVal && (a_ErrorObject.GetWbemStatus() == WBEM_NO_ERROR))
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_ErrorObject.SetMessage ( L"Failed to map source instance(s) to view instance." ) ;
				}

			}
			else //union
			{
				if ( (1 < indexCnt) || (m_ObjSinkArray[arrayIndex]->m_ObjArray.GetSize() > 1) )
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Ambiguous object path. Too many source instances returned." ) ;
					CleanUpObjSinks();
				}
				else
				{
					if ((src == NULL) && (pInst != NULL))
					{
						if ((m_ObjSinkArray[arrayIndex] != NULL) && SUCCEEDED(m_ObjSinkArray[arrayIndex]->GetResult())
							&& m_ObjSinkArray[arrayIndex]->m_ObjArray.GetSize())
						{
							m_ObjSinkArray[arrayIndex]->m_ObjArray[0]->GetWrappedObject()->AddRef();
							*pInst = m_ObjSinkArray[arrayIndex]->m_ObjArray[0]->GetWrappedObject();
						}
					}

					retVal =  CreateAndIndicateUnions(a_ErrorObject, arrayIndex);

					if (!retVal && (a_ErrorObject.GetWbemStatus() == WBEM_NO_ERROR))
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_ErrorObject.SetMessage ( L"Failed to map source instance(s) to view instance." ) ;
					}
				}
			}

			if (!retVal && (pInst != NULL) && (*pInst != NULL))
			{
				(*pInst)->Release();
				*pInst = NULL;
			}
		}
	}
	else
	{
		CleanUpObjSinks();
	}

	return retVal;
}

BOOL GetObjectTaskObject::GetSourceObject(const wchar_t* src, IWbemClassObject** pInst, BOOL bAllprops)
{
	//Have to test that object path is real and return
	//the IWbemClassObject for the source requested....
	//==================================================

	m_bIndicate = FALSE;
	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, m_ParsedObjectPath);

			if (t_Status)
			{
				if (m_bAssoc)
				{
					t_Status = FALSE;
				}
				else
				{
					t_Status = PerformGet(m_ErrorObject, pInst, src, bAllprops);
				}
			}
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL GetObjectTaskObject :: GetObject ()
{
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("GetObjectTaskObject :: GetObject\r\n")
		) ;
)

	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, m_ParsedObjectPath);

			if (t_Status)
			{
				t_Status = PerformGet(m_ErrorObject);
			}
		}
		else
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("GetObjectTaskObject :: GetObject:Class definition not found\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"GetObjectTaskObject :: GetObject:Unable to parse object path %s\r\n",
		m_ObjectPath
		) ;
)
	}

DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("leaving GetObjectTaskObject :: GetObject with %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpput.cpp ===
//***************************************************************************

//

//  VPPUT.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the PutInstance implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern BOOL CompareSimplePropertyValues(VARIANT* v1, VARIANT* v2, CIMTYPE ct);

PutInstanceTaskObject::PutInstanceTaskObject (CViewProvServ *a_Provider , IWbemClassObject *a_Inst , 
												ULONG a_Flag , IWbemObjectSink *a_NotificationHandler,
												IWbemContext *pCtx) 
:WbemTaskObject (a_Provider, a_NotificationHandler, a_Flag, pCtx)
{
	m_InstObject = a_Inst;

	if (m_InstObject != NULL)
	{
		m_InstObject->AddRef();

		if (WBEM_FLAG_CREATE_ONLY == (a_Flag & WBEM_FLAG_CREATE_ONLY))
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER );
			m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER );
			m_ErrorObject.SetMessage ( L"The provider does not support instance creation via PutInstanceAsync." );
		}
	}
	else
	{
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetMessage ( L"A non-null instance must be supplied as an argument" ) ;
	}
}


PutInstanceTaskObject::~PutInstanceTaskObject ()
{
	BOOL t_Status = TRUE;

	IWbemClassObject *t_NotifyStatus = NULL ;

	if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
	{
		t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	}

	if ( t_Status )
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
		
		if (t_NotifyStatus)
		{
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
	}

	if (m_InstObject != NULL)
	{
		m_InstObject->Release();
	}
}

BOOL PutInstanceTaskObject::PutInstance()
{
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance\r\n)")
		) ;
)
	if (FAILED(m_ErrorObject.GetWbemStatus()))
	{
		return FALSE;
	}

	VARIANT v;
	VariantInit (&v);
	BOOL t_Status = SUCCEEDED(m_InstObject->Get(WBEM_PROPERTY_CLASS, 0, &v, NULL, NULL));

	if (( t_Status ) && (VT_BSTR == v.vt))
	{
		t_Status = SetClass(v.bstrVal) ;

		if (t_Status)
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject);

			if (t_Status)
			{
				//only unions
				if (!m_bAssoc && !m_JoinOnArray.IsValid())
				{
					t_Status = PerformPut(m_ErrorObject);
				}
				else
				{
					m_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_SUPPORTED ) ;
					m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_ErrorObject.SetMessage ( L"Operation only supported for Union views" ) ;
				}
			}
		}
		else
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance:Dynamic NT Eventlog Provider does not support WRITE for this class\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_OBJECT ) ;
		m_ErrorObject.SetMessage ( L"Unable to obtain class name from object." ) ;
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance:Unable to obtain class name from object.\r\n")
		) ;
)
	}

	VariantClear(&v);
DebugOut4( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("PutInstanceTaskObject :: PutInstance:returning %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}

BOOL PutInstanceTaskObject::PerformPut(WbemProvErrorObject &a_ErrorObject)
{
	BOOL retVal = FALSE;
	VARIANT v;

	//Two step process, first get the instance being changed...
	if ( SUCCEEDED(m_InstObject->Get(WBEM_PROPERTY_RELPATH, 0, &v, NULL, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			IWbemClassObject* pSrcInst;
			BSTR refStr = MapFromView(v.bstrVal, NULL, &pSrcInst, TRUE);

			if (refStr != NULL)
			{
				//Second step...
				//map any property changes to the new instance and call PutInstance
				VARIANT vCls;

				if ( SUCCEEDED(pSrcInst->Get(WBEM_PROPERTY_CLASS, 0, &vCls, NULL, NULL)) )
				{
					if (vCls.vt == VT_BSTR)
					{
						int index;

						if (m_ClassToIndexMap.Lookup(vCls.bstrVal, index))
						{
							POSITION propPos = m_PropertyMap.GetStartPosition();
							retVal = TRUE;

							while ((propPos != NULL) && retVal)
							{
								VARIANT vProp;
								CIMTYPE ct;
								CStringW propName;
								CPropertyQualifierItem* propProps;
								m_PropertyMap.GetNextAssoc(propPos, propName, propProps);

								if (!propProps->m_SrcPropertyNames[index].IsEmpty())
								{
									if ( SUCCEEDED(m_InstObject->Get(propName, 0, &vProp, &ct, NULL)) )
									{
										VARIANT vSProp;

										if ( SUCCEEDED (pSrcInst->Get(propProps->m_SrcPropertyNames[index], 0, &vSProp, &ct, NULL)) )
										{
											if (!CompareSimplePropertyValues(&vProp, &vSProp, ct))
											{
												if ( FAILED(pSrcInst->Put(propProps->m_SrcPropertyNames[index], 0, &vProp, ct)) )
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
													a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
													a_ErrorObject.SetMessage ( L"Failed to Put property in source instance" ) ;
												}
											}

											VariantClear(&vSProp);
										}
										else
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
											a_ErrorObject.SetMessage ( L"Failed to Get property from source instance" ) ;
										}

										VariantClear(&vProp);
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Failed to get property from view instance" ) ;
									}
								}
							}

							if (retVal)
							{
								//which namespace do we put into, try them all until we succeed 
								CWbemServerWrap** pServs = m_NSpaceArray[index]->GetServerPtrs();
								HRESULT hr = WBEM_E_FAILED;

								for (UINT i = 0; i < m_NSpaceArray[index]->GetCount(); i++)
								{
									if (pServs[i] != NULL)
									{
										IWbemServices *ptmpServ = pServs[i]->GetServerOrProxy();

										if (ptmpServ)
										{
											hr = ptmpServ->PutInstance(pSrcInst, WBEM_FLAG_UPDATE_ONLY, m_Ctx, NULL);

											if ( FAILED(hr) && (HRESULT_FACILITY(hr) != FACILITY_ITF) && pServs[i]->IsRemote())
											{
												if ( SUCCEEDED(UpdateConnection(&(pServs[i]), &ptmpServ)) )
												{
													if (ptmpServ)
													{
														hr = ptmpServ->PutInstance(pSrcInst, WBEM_FLAG_UPDATE_ONLY, m_Ctx, NULL);
													}
												}
											}

											if (ptmpServ)
											{
												pServs[i]->ReturnServerOrProxy(ptmpServ);
											}

											if (SUCCEEDED (hr) )
											{
												break;
											}
										}
									}
								}

								if ( FAILED (hr) )
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
#ifdef VP_SINGLE_NAMESPACE_TRIED
									wchar_t buff[100];
									wsprintf(buff, L"PutInstance on source object failed with code: %lx", hr);
									a_ErrorObject.SetMessage ( buff ) ;
#else	//VP_SINGLE_NAMESPACE_TRIED
									a_ErrorObject.SetMessage ( L"PutInstance on source object failed" ) ;
#endif	//VP_SINGLE_NAMESPACE_TRIED
								}
							}
						}
						else
						{
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Source instance class not found in source list" ) ;
						}
					}
					else
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Source instance has non string __Class property" ) ;
					}

					VariantClear(&vCls);
				}
				else
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Source instance has no __Class property" ) ;
				}

				pSrcInst->Release();
				SysFreeString(refStr);
			}
			else
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Instance supplied could not be mapped to a single source instance" ) ;
			}
		}
		else
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
			a_ErrorObject.SetMessage ( L"Instance supplied has non string __RelPath property" ) ;
		}

		VariantClear(&v);
	}
	else
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		a_ErrorObject.SetMessage ( L"Instance supplied has no __RelPath property" ) ;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpcfac.cpp ===
//***************************************************************************

//

//  VPCFAC.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <vpserv.h>
#include <vpcfac.h>

extern CRITICAL_SECTION g_CriticalSection;

LONG CViewProvClassFactory :: objectsInProgress = 0 ;
LONG CViewProvClassFactory :: locksInProgress = 0 ;


//***************************************************************************
//
// CViewProvClassFactory::CViewProvClassFactory
// CViewProvClassFactory::~CViewProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CViewProvClassFactory::CViewProvClassFactory ()
{
	EnterCriticalSection(&g_CriticalSection);
	objectsInProgress++;
	LeaveCriticalSection(&g_CriticalSection);
	m_referenceCount = 0 ;
}

CViewProvClassFactory::~CViewProvClassFactory ()
{
	EnterCriticalSection(&g_CriticalSection);
	objectsInProgress--;
	LeaveCriticalSection(&g_CriticalSection);
}

//***************************************************************************
//
// CViewProvClassFactory::QueryInterface
// CViewProvClassFactory::AddRef
// CViewProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CViewProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CViewProvClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( &m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CViewProvClassFactory :: Release ()
{	
	SetStructuredExceptionHandler seh;
	LONG ref = 0;

	try
	{
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		ref = 0;
	}
	catch(Heap_Exception e_HE)
	{
		ref = 0;
	}
	catch(...)
	{
		ref = 0;
	}

	return ref ;
}

//***************************************************************************
//
// CViewProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CViewProvClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}

}

//***************************************************************************
//
// CViewProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CViewProvClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	HRESULT status = E_FAIL;

	SetStructuredExceptionHandler seh;

	try
	{
		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION;
		}
		else 
		{
			CViewProvServ* prov =  new CViewProvServ;
			status = prov->QueryInterface (riid, ppvObject);

			if (NOERROR != status)
			{
				delete prov;
			}
		}
	}
	catch(Structured_Exception e_SE)
	{
		status = E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		status = E_OUTOFMEMORY;
	}
	catch(...)
	{
		status = E_UNEXPECTED;
	}

	return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpquals.cpp ===
//***************************************************************************

//

//  VPQUALS.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the implementation of qualifier storage classes

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <malloc.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <wbemidl.h>
#include <stdio.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

CStringW GetStringFromRPNToken(SQL_LEVEL_1_TOKEN* pRPNToken)
{
    CStringW ret;

	if (NULL != pRPNToken->pPropertyName)
	{
		ret = L'('; 
		ret += pRPNToken->pPropertyName;

		switch(pRPNToken->nOperator)
		{
			case SQL_LEVEL_1_TOKEN::OP_EQUAL:
			{
				ret += L'=';
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
			{
				ret += L"<>";
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
			{
				ret += L">=";
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
			{
				ret += L"<=";
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
			{
				ret += L'<';
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
			{
				ret += L'>';
			}
			break;
			case SQL_LEVEL_1_TOKEN::OP_LIKE:
			{
				ret += L" like ";
			}
			break;
			default:
			{
				ret.Empty();
			}
		}

		if (!ret.IsEmpty())
		{
			switch (pRPNToken->vConstValue.vt)
			{
				case VT_NULL:
				{
					ret += L"null)";
				}
				break;
				case VT_BSTR:
				{
					if (pRPNToken->bConstIsStrNumeric)
					{
						ret += pRPNToken->vConstValue.bstrVal;
						ret += L')';
					}
					else
					{
						ret += L'\"';
						wchar_t* buff = new wchar_t[(wcslen(pRPNToken->vConstValue.bstrVal)*2) + 1];
						wchar_t* tmp = pRPNToken->vConstValue.bstrVal;
						wchar_t* tmpBuff = buff;

						while (*tmp != NULL)
						{
							if ((*tmp == L'\\') || (*tmp == L'"'))
							{
								*tmpBuff = L'\\';
								*tmpBuff++;
							}

							*tmpBuff = *tmp;
							*tmpBuff++;
							*tmp++;
						}

						*tmpBuff = 0;
						ret += buff;
						delete [] buff;
						ret += L"\")";
					}
				}
				break;
				case VT_BOOL:
				{
					if (pRPNToken->vConstValue.boolVal == VARIANT_TRUE)
					{
						ret += L"TRUE)";
					}
					else
					{
						ret += L"FALSE)";
					}
				}
				break ;

				case VT_I4:
				{
					WCHAR tmpBuff[20];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%d", pRPNToken->vConstValue.lVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_I2:
				{
					WCHAR tmpBuff[20];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%d", (int)pRPNToken->vConstValue.iVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_UI1:
				{
					WCHAR tmpBuff[20];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%d", (int)pRPNToken->vConstValue.bVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_R4:
				{
					WCHAR tmpBuff[25];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%G", pRPNToken->vConstValue.fltVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				case VT_R8:
				{
					WCHAR tmpBuff[25];
					tmpBuff[0] = L'\0';

					if ( swprintf(tmpBuff, L"%lG", pRPNToken->vConstValue.dblVal) )
					{
						ret += tmpBuff;
						ret += ')';
					}
					else
					{
						ret.Empty();
					}
				}
				break;
				default:
				{
					ret.Empty();
				}
			}
		}
	}
    
	return ret;
}

CStringW GetStringFromRPN(SQL_LEVEL_1_RPN_EXPRESSION* pRPN, DWORD num_extra,
						 SQL_LEVEL_1_TOKEN* pExtraTokens, BOOL bAllprops)
{
	CStringW ret;

	if (NULL == pRPN)
	{
		return ret;
	}

	if (NULL != pRPN->bsClassName)
	{
		CStringW props;

		if ((bAllprops) || (0 == pRPN->nNumberOfProperties))
		{
			props = L'*';
		}
		else
		{
			props = pRPN->pbsRequestedPropertyNames[0];

			for (int x = 1; x < pRPN->nNumberOfProperties; x++)
			{
				props += L", ";
				props += pRPN->pbsRequestedPropertyNames[x];
			}

			props += L", ";
			props += WBEM_PROPERTY_PATH;
			props += L", ";
			props += WBEM_PROPERTY_SERVER;
		}

		ret = L"Select ";
		ret += props;
		ret += L" From ";
		ret += pRPN->bsClassName;

		if ((0 != pRPN->nNumTokens) || (0 != num_extra))
		{
			CStringW whereStr;
			CArray<CStringW, LPCWSTR> exprStack;

			//not likely to get more than five expressions in a row!
			//if we do, we'll grow the array!
			exprStack.SetSize(0, 5);
			DWORD stack_count = 0;

			for (int x = 0; x < (pRPN->nNumTokens + num_extra); x++)
			{
				SQL_LEVEL_1_TOKEN* pToken;

				if (x < pRPN->nNumTokens)
				{
					pToken = &(pRPN->pArrayOfTokens[x]);
				}
				else
				{
					pToken = &(pExtraTokens[x - pRPN->nNumTokens]);
				}

				if (SQL_LEVEL_1_TOKEN::OP_EXPRESSION == pToken->nTokenType)
				{
					if (whereStr.IsEmpty())
					{
						whereStr = GetStringFromRPNToken(pToken);

						if (whereStr.IsEmpty())
						{
							ret.Empty();
							break;
						}
					}
					else
					{
						exprStack.SetAtGrow(stack_count, GetStringFromRPNToken(pToken));

						if (exprStack[stack_count].IsEmpty())
						{
							ret.Empty();
							break;
						}

						stack_count++;
					}
				}
				else if (SQL_LEVEL_1_TOKEN::TOKEN_NOT == pToken->nTokenType)
				{
					CStringW tempStr(L"(Not ");
					
					if (stack_count > 0)
					{
						tempStr += exprStack[stack_count-1];
						tempStr += L')';
						exprStack.SetAt(stack_count-1, tempStr);
					}
					else if (!whereStr.IsEmpty())
					{
						tempStr += whereStr;
						tempStr += L')';
						whereStr = tempStr;
					}
					else
					{
						ret.Empty();
						break;
					}
				}
				else
				{
					CStringW opStr;
					
					if (SQL_LEVEL_1_TOKEN::TOKEN_AND == pToken->nTokenType)
					{
						opStr = L" And ";
					}
					else if (SQL_LEVEL_1_TOKEN::TOKEN_OR == pToken->nTokenType)
					{
						opStr = L" Or ";
					}
					else
					{
						ret.Empty();
						break;
					}

					CStringW tempStr(L'(');

					if (stack_count > 1)
					{
						tempStr += exprStack[stack_count-2];
						tempStr += opStr;
						tempStr += exprStack[stack_count-1];
						tempStr += L')';
						exprStack.SetAt(stack_count-2, tempStr);
						stack_count = stack_count--;
					}
					else if (stack_count == 1)
					{
						tempStr += whereStr;
						tempStr += opStr;
						tempStr += exprStack[0];
						tempStr += L')';
						whereStr = tempStr;
						stack_count = 0;
					}
					else
					{
						ret.Empty();
						whereStr.Empty();
						break;
					}
				}
			}

			exprStack.RemoveAll();

			if (whereStr.IsEmpty() || (stack_count != 0))
			{
				ret.Empty();
			}
			else
			{
				ret += L" Where ";
				ret += whereStr;
			}
		}
	}

	return ret;
}

CSourceQualifierItem::CSourceQualifierItem(wchar_t* qry, IWbemClassObject* obj)
: m_pClassObj(NULL), m_RPNExpr(NULL)
{
	m_isValid = FALSE;

	m_QueryStr = qry;

	if (NULL != qry)
	{
		CTextLexSource querySource(qry);
		SQL1_Parser sqlParser(&querySource);
		m_isValid = SQL1_Parser::SUCCESS == sqlParser.Parse(&m_RPNExpr);
	}

	m_pClassObj = obj;

	if (NULL != m_pClassObj)
	{
		m_pClassObj->AddRef();
	}
}

CSourceQualifierItem::~CSourceQualifierItem()
{
	if (NULL != m_RPNExpr)
	{
		delete m_RPNExpr;
	}

	if (NULL != m_pClassObj)
	{
		m_pClassObj->Release();
	}
}

void CSourceQualifierItem::SetClassObject(IWbemClassObject* pObj)
{
	if (NULL != m_pClassObj)
	{
		m_pClassObj->Release();
	}

	if (NULL != pObj)
	{
		pObj->AddRef();
	}

	m_pClassObj = pObj;
}

IWbemClassObject* CSourceQualifierItem::GetClassObject()
{
	if (NULL != m_pClassObj)
	{
		m_pClassObj->AddRef();
	}

	return m_pClassObj;
}

BSTR CSourceQualifierItem::GetClassName()
{
	if (NULL != m_RPNExpr)
	{
		return m_RPNExpr->bsClassName;
	}

	return NULL;
}

CNSpaceQualifierItem::CNSpaceQualifierItem(const wchar_t* ns_path) : 

	m_Valid (FALSE),
	m_ServObjs (NULL),
	m_NSPaths (NULL),
	m_Count (0),

	m_hrServError ( WBEM_S_NO_ERROR )

{
	if (NULL != ns_path)
	{
		Parse(ns_path);
	}
}

CNSpaceQualifierItem::~CNSpaceQualifierItem()
{
	if (NULL != m_ServObjs)
	{
		for (UINT x = 0; x < m_Count; x++)
		{
			if (NULL != m_ServObjs[x])
			{
				m_ServObjs[x]->Release();
			}
		}

		delete [] m_ServObjs;
	}

	if (m_NSPaths != NULL)
	{
		delete [] m_NSPaths;
	}
}

void CNSpaceQualifierItem::Parse(const wchar_t* ns_path)
{
	wchar_t* buff = _wcsdup(ns_path);

	if (buff == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	wchar_t* tmp = wcsstr(buff, NS_DELIMIT);
	CFreeBuff _1(buff);

	if (tmp == NULL)
	{
		m_NSPaths = new CStringW[1];
		m_NSPaths[0] = buff;
		m_NSPaths[0].TrimLeft();

		if (m_NSPaths[0].IsEmpty())
		{
			delete [] m_NSPaths;
			m_NSPaths = NULL;
		}
		else
		{
			m_Count = 1;
			m_Valid = TRUE;
			m_NSPaths[0].TrimRight();
		}
	}
	else
	{
		wchar_t** tmpbuff = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

		if (tmpbuff == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		CFreeBuff _2(tmpbuff);

		if (tmp != buff)
		{
			tmpbuff[0] = buff;
			m_Count++;
		}

		while (TRUE)
		{
			*tmp = L'\0';
			tmp = tmp + 2;
			
			if (*tmp != L'\0')
			{
				tmpbuff[m_Count] = tmp;
				tmp = wcsstr(tmpbuff[m_Count], NS_DELIMIT);
				m_Count++;

				if (tmp == NULL)
				{
					break;
				}
				
				if ( (m_Count > 0) && (0 == (m_Count%MAX_QUERIES)) )
				{
					UINT x = _msize(tmpbuff);
					wchar_t** tmp = (wchar_t**)realloc(tmpbuff, x+(MAX_QUERIES*sizeof(wchar_t*)));
					if (tmp == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}
					tmpbuff = tmp;
					_2.SetBuff(tmpbuff);

				}
			}
			else
			{
				break;
			}
		}

		if (m_Count > 0)
		{
			m_NSPaths = new CStringW[m_Count];

			for (UINT x=0; x < m_Count; x++)
			{
				m_NSPaths[x] = tmpbuff[x];
				m_NSPaths[x].TrimLeft();

				if (m_NSPaths[x].IsEmpty())
				{
					break;
				}
				else
				{
					m_NSPaths[x].TrimRight();
				}
			}

			if (!m_NSPaths[m_Count-1].IsEmpty())
			{
				m_Valid = TRUE;
			}
		}
	}
}

CJoinOnQualifierArray::CJoinOnQualifierArray()
{
	m_Count = 0;
	m_AClasses = NULL;
	m_AProps = NULL;
	m_BClasses = NULL;
	m_BProps = NULL;
	m_Ops = NULL;
	m_Buff = NULL;
	m_Valid = FALSE;
	m_bDone = NULL;
}

CJoinOnQualifierArray::~CJoinOnQualifierArray()
{
	if (NULL != m_AClasses)
	{
		free(m_AClasses);
	}

	if (NULL != m_BClasses)
	{
		free(m_BClasses);
	}

	if (NULL != m_AProps)
	{
		free(m_AProps);
	}

	if (NULL != m_BProps)
	{
		free(m_BProps);
	}

	if (NULL != m_Ops)
	{
		free(m_Ops);
	}

	if (NULL != m_Buff)
	{
		free(m_Buff);
	}

	if (NULL != m_bDone)
	{
		delete [] m_bDone;
	}

	m_AllClasses.RemoveAll();
}

BOOL CJoinOnQualifierArray::Set(const wchar_t* jStr)
{
	if (NULL != jStr)
	{
		Parse(jStr);
	}

	return m_Valid;
}

void CJoinOnQualifierArray::Parse(const wchar_t* qualStr)
{
	m_Buff = _wcsdup(qualStr);
	wchar_t* tmp = m_Buff;
	m_Valid = TRUE;
			    
	m_AClasses = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_AClasses == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_BClasses = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_BClasses == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_AProps = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_AProps == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_BProps = (wchar_t**)malloc(MAX_QUERIES*sizeof(wchar_t*));

	if (m_BProps == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_Ops = (UINT*)malloc(MAX_QUERIES*sizeof(UINT));

	if (m_Ops == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	while ((tmp != NULL) && (L'\0' != *tmp) && (m_Valid))
	{
		m_AClasses[m_Count] = GetClassStr(tmp);

		if ((NULL != m_AClasses[m_Count]) && (L'\0' != *(m_AClasses[m_Count])))
		{
			m_AllClasses.SetAt(m_AClasses[m_Count], 0);
			m_AProps[m_Count] = GetPropertyStrAndOperator(tmp, m_Ops[m_Count]);

			if ((NULL != m_AProps[m_Count]) && (L'\0' != *(m_AProps[m_Count])) && (0 != m_Ops[m_Count]))
			{
				m_BClasses[m_Count] = GetClassStr(tmp);

				if ((NULL != m_BClasses[m_Count]) && (L'\0' != *(m_BClasses[m_Count])))
				{
					m_AllClasses.SetAt(m_BClasses[m_Count], 0);
					m_BProps[m_Count] = GetPropertyStr(tmp);

					if ((NULL != m_BProps[m_Count]) && (L'\0' != *(m_BProps[m_Count])) && StripAnd(tmp))
					{
						m_Count++;

						if ((tmp != NULL) && (L'\0' != *tmp) && (m_Count > 0) && (0 == (m_Count%MAX_QUERIES)) )
						{
							UINT x = _msize(m_AClasses);
							realloc_throw(&m_AClasses, x+(MAX_QUERIES*sizeof(wchar_t*)));
							realloc_throw(&m_BClasses, x+(MAX_QUERIES*sizeof(wchar_t*)));
							realloc_throw(&m_AProps, x+(MAX_QUERIES*sizeof(wchar_t*)));
							realloc_throw(&m_BProps, x+(MAX_QUERIES*sizeof(wchar_t*)));
							x = _msize(m_Ops);
							realloc_throw(&m_Ops, x+(MAX_QUERIES*sizeof(UINT)));
						}
					}
					else
					{
						m_Valid = FALSE;
					}
				}
				else
				{
					m_Valid = FALSE;
				}
			}
			else
			{
				m_Valid = FALSE;
			}
		}
		else
		{
			m_Valid = FALSE;
		}
	}

	if (0 == m_Count)
	{
		m_Valid = FALSE;
	}

	if (!m_Valid)
	{
		if (NULL != m_AClasses)
		{
			free(m_AClasses);
			m_AClasses = NULL;
		}

		if (NULL != m_BClasses)
		{
			free(m_BClasses);
			m_BClasses = NULL;
		}

		if (NULL != m_AProps)
		{
			free(m_AProps);
			m_AProps = NULL;
		}

		if (NULL != m_BProps)
		{
			free(m_BProps);
			m_BProps = NULL;
		}

		if (NULL != m_Ops)
		{
			free(m_Ops);
			m_Ops = NULL;
		}

		if (NULL != m_Buff)
		{
			free(m_Buff);
			m_Buff = NULL;
		}
	}
	else
	{
		m_bDone = new BOOL[m_Count];
		memset((void *)m_bDone, 0, sizeof(BOOL)*m_Count);
	}
}

wchar_t* CJoinOnQualifierArray::SkipSpace(wchar_t*& src)
{
	while (iswspace(*src))
	{
		if (*src != L'\0')
		{
			*src = L'\0';
			src++;
		}
	}

	return ((*src == L'\0') ? NULL : src);
}

wchar_t* CJoinOnQualifierArray::SkipToSpecial(wchar_t*& src)
{
	while ((*src != L'.') && (*src != L'=') && (*src != L'!') && (*src != L'<')
		&& !iswspace(*src) && (*src != L'\0'))
	{
		src++;
	}

	return ((*src == L'\0') ? NULL : src);
}

wchar_t* CJoinOnQualifierArray::GetClassStr(wchar_t*& src)
{
	wchar_t* ret = SkipSpace(src);

	if (NULL != ret)
	{
		src = SkipToSpecial(src);

		if ((NULL != src) && (src != ret) && ((*src == L'.')))
		{
			*src = L'\0';
			src++;
		}
		else
		{
			ret = NULL;
		}
	}

	return ret;
}

wchar_t* CJoinOnQualifierArray::GetPropertyStrAndOperator(wchar_t*& src, UINT& op)
{
	wchar_t* ret = src;
	op =  NO_OPERATOR;

	src = SkipToSpecial(src);
	src = SkipSpace(src);

	if ((NULL != src) && (src != ret))
	{
		if (*src == L'=')
		{
			*src = L'\0';
			op = EQUALS_OPERATOR;
			src++;
		}
		else if (*src == L'!')
		{
			wchar_t* prev = src;
			src++;

			if (*src == L'=')
			{
				*prev = L'\0';
				op = NOT_EQUALS_OPERATOR;
				src++;
			}
			else
			{
				ret = NULL;
			}
		}
		else if (*src == L'<')
		{
			wchar_t* prev = src;
			src++;

			if (*src == L'>')
			{
				*prev = L'\0';
				op = NOT_EQUALS_OPERATOR;
				src++;
			}
			else
			{
				ret = NULL;
			}
		}
	}
	else
	{
		ret = NULL;
	}

	return ret;
}

wchar_t* CJoinOnQualifierArray::GetPropertyStr(wchar_t*& src)
{
	wchar_t* ret = src;
	src = SkipToSpecial(src);

	if (NULL != src)
	{
		if ( (src != ret) && iswspace(*src) )
		{
			if (*src != L'\0')
			{
				*src = L'\0';
				src++;
			}
		}
		else
		{
			ret = NULL;
		}
	}

	return ret;
}

BOOL CJoinOnQualifierArray::StripAnd(wchar_t*& src)
{

	if (NULL == src)
	{
		return TRUE;
	}

	src = SkipSpace(src);

	if (NULL == src)
	{
		return TRUE;
	}

	if ((*src == L'a') || (*src == L'A'))
	{
		src++;

		if ((*src == L'n') || (*src == L'N'))
		{
			src++;

			if ((*src == L'd') || (*src == L'D'))
			{
				src++;
				wchar_t* tmp = src;
				src = SkipSpace(src);

				if ((NULL != src) && (tmp != src))
				{
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

BOOL CJoinOnQualifierArray::ValidateJoin()
{
	if (!m_Valid)
	{
		return m_Valid;
	}

	CMap<CStringW, LPCWSTR, UINT, UINT> validatedClasses;
	CArray<CStringW, LPCWSTR> spareClasses;
	UINT x = 0;

	if (_wcsicmp(m_AClasses[x], m_BClasses[x]) == 0)
	{
		m_Valid = FALSE;
	}
	else
	{
		validatedClasses.SetAt(m_AClasses[x], 0);
		validatedClasses.SetAt(m_BClasses[x], 0);
		x++;
	}

	while ((m_Valid) && (x < m_Count))
	{
		if (_wcsicmp(m_AClasses[x], m_BClasses[x]) == 0)
		{
			m_Valid = FALSE;
		}
		else
		{
			UINT val;

			if (validatedClasses.Lookup(m_AClasses[x], val))
			{
				validatedClasses.SetAt(m_BClasses[x], 0);
			}
			else
			{
				if (validatedClasses.Lookup(m_BClasses[x], val))
				{
					validatedClasses.SetAt(m_AClasses[x], 0);
				}
				else
				{
					spareClasses.Add(m_AClasses[x]);
					spareClasses.Add(m_BClasses[x]);
				}
			}
		}

		x++;
	}

	while ( m_Valid && (0 != spareClasses.GetSize()) )
	{
		m_Valid = FALSE;
		
		for (int i = 0; i < spareClasses.GetSize(); i++)
		{
			UINT val;

			if (validatedClasses.Lookup(spareClasses[i], val))
			{
				if (0 == (i%2))
				{
					validatedClasses.SetAt(spareClasses[i+1], 0);
					spareClasses.RemoveAt(i, 2);
					i -= 1;
				}
				else
				{
					validatedClasses.SetAt(spareClasses[i-1], 0);
					spareClasses.RemoveAt(i-1, 2);
					i -= 2;
				}

				m_Valid = TRUE;
			}
		}
	}

	spareClasses.RemoveAll();
	validatedClasses.RemoveAll();

	return m_Valid;
}


CPropertyQualifierItem::CPropertyQualifierItem(const wchar_t* prop, BOOL bHD, BOOL bKy, CIMTYPE ct, CStringW rfto, BOOL bDt)
{
	if (NULL != prop)
	{
		m_ViewPropertyName = prop;
	}

	m_bDirect = bDt;
	m_HiddenDefault = bHD;
	m_bKey =  bKy;
	m_CimType =  ct;
	m_RefTo = rfto;
}

CPropertyQualifierItem::~CPropertyQualifierItem()
{
	m_SrcPropertyNames.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpmthd.cpp ===
//***************************************************************************

//

//  VPMTHD.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the PutInstance implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

ExecMethodTaskObject :: ExecMethodTaskObject (

		CViewProvServ *a_Provider , 
		wchar_t *a_ObjectPath ,
		wchar_t *a_MethodName,
		ULONG a_Flag ,
		IWbemClassObject *a_InParams ,		
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_Flag , pCtx ) ,
	m_InParamObject( a_InParams ), m_OutParamObject ( NULL ),
	m_ParsedObjectPath ( NULL ), m_ObjectPath(NULL), m_Method(NULL)
{

	if (m_InParamObject != NULL)
	{
		m_InParamObject->AddRef();
	}

	m_ObjectPath = UnicodeStringDuplicate(a_ObjectPath);
	m_Method = UnicodeStringDuplicate(a_MethodName);
}

ExecMethodTaskObject :: ~ExecMethodTaskObject () 
{
	if (m_OutParamObject != NULL)
	{
		if ( SUCCEEDED(m_ErrorObject.GetWbemStatus ()) )
		{
			HRESULT t_Result = m_NotificationHandler->Indicate(1, &m_OutParamObject);
		}

		m_OutParamObject->Release();
	}

	if (m_InParamObject != NULL)
	{
		m_InParamObject->Release();
	}

	delete [] m_ObjectPath ;
	delete [] m_Method ;

	if (NULL != m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath;
	}

	// Get Status object
	IWbemClassObject *t_NotifyStatus = NULL ;
	BOOL t_Status = TRUE;
	
	if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
	{
		t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	}

	if ( t_Status )
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
		
		if (t_NotifyStatus)
		{
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
	}

}

BOOL ExecMethodTaskObject :: ExecMethod ()
{
DebugOut8( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecMethodTaskObject :: ExecMethod\r\n")
		) ;
)

	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			IWbemQualifierSet* pQuals = NULL;
			BOOL bStatic = FALSE;

			//get the method qualifier set so we can determine
			//if the method is static...
			if ( SUCCEEDED(m_ClassObject->GetMethodQualifierSet(m_Method, &pQuals)) )
			{
				//get the MethodSources qualifier
				VARIANT v;
				VariantInit(&v);

				if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_STATIC, 0, &v, NULL)) )
				{
					if (v.vt == VT_BOOL)
					{
						bStatic = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
					}
					else
					{
						t_Status = FALSE;
						m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
						m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_ErrorObject.SetMessage ( L"Static method qualifier should be boolean." ) ;
					}
				}

				VariantClear(&v);
				pQuals->Release();
			}
			else
			{
				t_Status = FALSE;
				m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_ErrorObject.SetMessage ( L"Failed to get Method qualifiers" ) ;
			}

			if (t_Status)
			{
				t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, bStatic ? NULL : m_ParsedObjectPath);
			}

			if (t_Status)
			{
				//only unions
				if (m_bAssoc || m_JoinOnArray.IsValid())
				{
					t_Status = FALSE;
					m_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_SUPPORTED ) ;
					m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_ErrorObject.SetMessage ( L"Methods only supported for Union views" ) ;
				}
			}

			if (t_Status)
			{
				LONG t_index = 0;
				CStringW t_srcMethod;
				BOOL t_bStatic = FALSE;

				t_Status = CompareMethods(m_ErrorObject, t_index, t_srcMethod, t_bStatic);

				if (t_Status)
				{
					t_Status = PerformMethod(m_ErrorObject, t_index, t_srcMethod, t_bStatic);
				}
			}
		}
		else
		{
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut8( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecMethodTaskObject :: ExecMethod:Class definition not found\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
		m_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut8( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"ExecMethodTaskObject :: ExecMethod:Unable to parse object path %s\r\n",
		m_ObjectPath
		) ;
)
	}

DebugOut8( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("leaving ExecMethodTaskObject :: ExecMethod with %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}

//steps...
//1. Get the method signature and parse it's qualifiers
//2. Get the source method and it's signature
//3. Compare the signatures
//========================================================
BOOL ExecMethodTaskObject::CompareMethods(WbemProvErrorObject &a_ErrorObject, LONG &a_Index,
										  CStringW &a_SrcMethodName, BOOL &a_bStatic)
{
	BOOL retVal = FALSE;
	IWbemQualifierSet* pQuals = NULL;

	//get the method qualifier set so we can determine
	//what the source method for this view method is...
	if ( SUCCEEDED(m_ClassObject->GetMethodQualifierSet(m_Method, &pQuals)) )
	{
		//get the MethodSources qualifier
		VARIANT v;
		VariantInit(&v);

		if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_METHOD, 0, &v, NULL)) )
		{
			retVal = TRUE;

			if (v.vt == VT_BSTR)
			{
				if (m_SourceArray.GetSize() != 1)
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
					a_ErrorObject.SetMessage ( L"MethodSources qualifier should match ViewSources size." ) ;
				}
				else
				{
					a_SrcMethodName = v.bstrVal;
				}
			}
			else if (v.vt == (VT_BSTR | VT_ARRAY))
			{
				if (SafeArrayGetDim(v.parray) == 1)
				{
					LONG count = v.parray->rgsabound[0].cElements;
					BSTR HUGEP *pbstr;

					if (m_SourceArray.GetSize() != count)
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
						a_ErrorObject.SetMessage ( L"MethodSources qualifier should match ViewSources size." ) ;
					}
					else
					{
						if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
						{
							for (LONG x = 0; x < count; x++)
							{
								if ((pbstr[x] != NULL) && (*(pbstr[x]) != L'\0'))
								{
									//only one value should be present
									if (a_SrcMethodName.IsEmpty())
									{
										a_SrcMethodName = pbstr[x];
										a_Index = x;
									}
									else
									{
										a_SrcMethodName.Empty();
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
										a_ErrorObject.SetMessage ( L"MethodSources qualifier should have only one non-empty value." ) ;
										break;
									}
								}
							}

							SafeArrayUnaccessData(v.parray);
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
							a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
							a_ErrorObject.SetMessage (L"Failed to access MethodSources array.");
						}
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"MethodSources array qualifier has incorrect dimensions.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
				a_ErrorObject.SetMessage ( L"MethodSources qualifier has the wrong type." ) ;
			}

			if (retVal)
			{
				if (!a_SrcMethodName.IsEmpty())
				{
					IWbemClassObject* t_SrcObj = m_SourceArray[a_Index]->GetClassObject();

					if (t_SrcObj != NULL)
					{
						IWbemClassObject* pVInParam = NULL;
						IWbemClassObject* pVOutParam = NULL;
						IWbemClassObject* pSInParam = NULL;
						IWbemClassObject* pSOutParam = NULL;

						if ( SUCCEEDED(m_ClassObject->GetMethod(m_Method, 0, &pVInParam, &pVOutParam)) )
						{
							if ( SUCCEEDED(t_SrcObj->GetMethod(a_SrcMethodName, 0, &pSInParam, &pSOutParam)) )
							{
								//got all the info we need, now compare the signatures...
								if ( ((pVInParam == NULL) && (pSInParam != NULL)) ||
									((pVInParam != NULL) && (pSInParam == NULL)) ||
									((pVOutParam == NULL) && (pSOutParam != NULL)) ||
									((pVOutParam != NULL) && (pSOutParam == NULL)) )
								{
									//signature mismatch
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_SUPPORTED) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
									a_ErrorObject.SetMessage ( L"View method signature does not match source method signature." ) ;
								}
								else
								{
									if (pSInParam != NULL) //pVInParam is non-null
									{
										if (WBEM_S_DIFFERENT == pSInParam->CompareTo(WBEM_FLAG_IGNORE_OBJECT_SOURCE |
																					WBEM_FLAG_IGNORE_DEFAULT_VALUES |
																					WBEM_FLAG_IGNORE_FLAVOR, pVInParam))
										{
											//signature mismatch
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_SUPPORTED) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
											a_ErrorObject.SetMessage ( L"View method signature does not match source method signature." ) ;
										}
									}

									if (retVal && (pSOutParam != NULL)) //pVOutParam is non-null
									{
										if (WBEM_S_DIFFERENT == pSOutParam->CompareTo(WBEM_FLAG_IGNORE_OBJECT_SOURCE |
																					WBEM_FLAG_IGNORE_DEFAULT_VALUES |
																					WBEM_FLAG_IGNORE_FLAVOR, pVOutParam))
										{
											//signature mismatch
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_SUPPORTED) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
											a_ErrorObject.SetMessage ( L"View method signature does not match source method signature." ) ;
										}
									}

									//check to see that methods are both
									//static or both non-static
									if (retVal)
									{
										BOOL t_bViewStatic = FALSE;
										BOOL t_bSrcStatic = FALSE;
										VARIANT t_vStatic;
										VariantInit(&t_vStatic);
										
										if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_STATIC, 0, &t_vStatic, NULL)) )
										{
											if (t_vStatic.vt == VT_BOOL)
											{
												t_bViewStatic = (t_vStatic.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_TYPE_MISMATCH) ;
												a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
												a_ErrorObject.SetMessage ( L"Static qualifier on Method should be boolean" ) ;

											}
										}

										VariantClear(&t_vStatic);
										VariantInit(&t_vStatic);
										IWbemQualifierSet* t_SrcQuals = NULL;

										if ( SUCCEEDED(t_SrcObj->GetMethodQualifierSet(a_SrcMethodName, &t_SrcQuals)) )
										{
											if ( SUCCEEDED(t_SrcQuals->Get(VIEW_QUAL_STATIC, 0, &t_vStatic, NULL)) )
											{
												if (t_vStatic.vt == VT_BOOL)
												{
													t_bSrcStatic = (t_vStatic.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
												}
												else
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus (WBEM_PROV_E_TYPE_MISMATCH) ;
													a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
													a_ErrorObject.SetMessage ( L"Static qualifier on Method should be boolean" ) ;

												}
											}

											t_SrcQuals->Release();
										}
										
										VariantClear(&t_vStatic);

										if (retVal)
										{
											if ((t_bSrcStatic) && (t_bViewStatic))
											{
												a_bStatic = TRUE;
											}
											else if ((!t_bSrcStatic) && (!t_bViewStatic))
											{
												a_bStatic = FALSE;
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
												a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
												a_ErrorObject.SetMessage (L"Both source and view methods must be static or both non-static");
											}

										}
									}
								}
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
								a_ErrorObject.SetMessage ( L"Source method could not be found" ) ;
							}
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
							a_ErrorObject.SetMessage ( L"View method could not be found" ) ;
						}

						//release all the signature objects
						if (pVInParam != NULL)
						{
							pVInParam->Release();
						}

						if (pVOutParam != NULL)
						{
							if (retVal)
							{
								if ( FAILED(pVOutParam->SpawnInstance(0, &m_OutParamObject)) )
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_UNEXPECTED) ;
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Failed to spawn out parameter");
								}
							}

							pVOutParam->Release();
						}

						if (pSInParam != NULL)
						{
							pSInParam->Release();
						}

						if (pSOutParam != NULL)
						{
							pSOutParam->Release();
						}

						//release the source class object
						t_SrcObj->Release();
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
						a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
						a_ErrorObject.SetMessage (L"Source class not available");
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Source of method not specified in MethodSources qualifier");
				}
			}
		}
		else
		{
			a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
			a_ErrorObject.SetMessage ( L"MethodSource qualifier is missing" ) ;
		}

		VariantClear(&v);
		pQuals->Release();
	}
	else
	{
		a_ErrorObject.SetStatus (WBEM_PROV_E_NOT_FOUND) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_METHOD ) ;
		a_ErrorObject.SetMessage ( L"Method or Method qualifiers are missing" ) ;
	}

	return retVal;
}

//map the object path to the source instance and perform the method
//if static make sure that the object path supplied was a class path.
BOOL ExecMethodTaskObject::PerformMethod(WbemProvErrorObject &a_ErrorObject, LONG a_Index,
										 CStringW a_SrcMethodName, BOOL a_bStatic)
{
	BOOL retVal = FALSE;
	int index = 0;
	BSTR inst_path = NULL;

	if (a_bStatic)
	{
		//make sure we were passed the class path
		if (m_ParsedObjectPath->IsClass())
		{
			//get the class and make sure there is
			//only one namespace associated with it.
			if (m_NSpaceArray[a_Index]->GetCount() == 1)
			{
				retVal = TRUE;
				inst_path = SysAllocString(m_SourceArray[a_Index]->GetClassName());
			}
			else
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Could not resolve path to single namespace for source Static method." ) ;
			}
		}
		else
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
			a_ErrorObject.SetMessage ( L"Static method called with instance rather than class path" ) ;
		}
	}
	else
	{
		//get the source instance for the view instance
		IWbemClassObject* pSrcInst;
		inst_path = MapFromView(m_ObjectPath, NULL, &pSrcInst, TRUE);

		if (inst_path != NULL)
		{
			//get the index of the class
			VARIANT vCls;

			if ( SUCCEEDED(pSrcInst->Get(WBEM_PROPERTY_CLASS, 0, &vCls, NULL, NULL)) )
			{
				if (vCls.vt == VT_BSTR)
				{
					if (m_ClassToIndexMap.Lookup(vCls.bstrVal, index))
					{
						if (a_Index == index)
						{
							retVal = TRUE;
						}
						else
						{
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Object path passed resulted in a different class of object to that of the methodsource" ) ;
						}
					}
					else
					{
						VARIANT vSCls;
						VariantInit(&vSCls);

						if ( SUCCEEDED(pSrcInst->Get(WBEM_PROPERTY_DERIVATION, 0, &vSCls, NULL, NULL)) )
						{
							if (vSCls.vt == VT_BSTR)
							{
								if (m_ClassToIndexMap.Lookup(vSCls.bstrVal, index))
								{
									if (a_Index == index)
									{
										retVal = TRUE;
									}
									else
									{
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Source instance class not found in source list" ) ;
									}
								}
							}
							else if (vSCls.vt == (VT_ARRAY | VT_BSTR))
							{
								if (SafeArrayGetDim(vSCls.parray) == 1)
								{
									LONG count = vSCls.parray->rgsabound[0].cElements;
									BSTR HUGEP *pbstr;

									if ( SUCCEEDED(SafeArrayAccessData(vSCls.parray, (void HUGEP**)&pbstr)) )
									{
										for (LONG x = 0; x < count; x++)
										{
											if (m_ClassToIndexMap.Lookup(pbstr[x], index))
											{
												if (a_Index == index)
												{
													retVal = TRUE;
													break;
												}
											}
										}

										SafeArrayUnaccessData(vSCls.parray);

										if (!retVal)
										{
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
											a_ErrorObject.SetMessage ( L"Source instance class not found in source list" ) ;
										}
									}
									else
									{
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Failed to access __Derivation array.");
									}
								}
								else
								{
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"__Derivation array qualifier has incorrect dimensions.");
								}
							}
							else
							{
								a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Source instance has non string __Derivation property" ) ;
							}

							VariantClear(&vSCls);
						}
						else
						{
							a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Source instance has no __Derivation property" ) ;
						}
					}
				}
				else
				{
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Source instance has non string __Class property" ) ;
				}

				VariantClear(&vCls);
			}
			else
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Source instance has no __Class property" ) ;
			}

			pSrcInst->Release();
		}
		else
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Instance supplied could not be mapped to a single source instance" ) ;
		}
	}

	if (retVal)
	{
		//Execute the method and indicate the outparams...
		//also set the result and we're all done!
		//which namespace do we execmethod, try them all until we succeed 
		CWbemServerWrap** pServs = m_NSpaceArray[index]->GetServerPtrs();
		HRESULT hr = WBEM_E_FAILED;

		for (UINT i = 0; i < m_NSpaceArray[index]->GetCount(); i++)
		{
			if (pServs[i] != NULL)
			{
				IWbemClassObject *t_outparam = NULL;
				IWbemServices *ptmpServ = pServs[i]->GetServerOrProxy();

				if (ptmpServ)
				{
					BSTR t_MethName = a_SrcMethodName.AllocSysString();
					hr = ptmpServ->ExecMethod(inst_path, t_MethName, 0,
											m_Ctx, m_InParamObject,
											&t_outparam, NULL);

					if ( FAILED(hr) && (HRESULT_FACILITY(hr) != FACILITY_ITF) && pServs[i]->IsRemote())
					{
						if ( SUCCEEDED(UpdateConnection(&(pServs[i]), &ptmpServ)) )
						{
							if (ptmpServ)
							{
								hr = ptmpServ->ExecMethod(inst_path, t_MethName, 0,
											m_Ctx, m_InParamObject,
											&t_outparam, NULL);
							}
						}
					}

					SysFreeString(t_MethName);

					if (ptmpServ)
					{
						pServs[i]->ReturnServerOrProxy(ptmpServ);
					}
				}

				if (SUCCEEDED (hr) )
				{
					if (m_OutParamObject != NULL)
					{
						if (t_outparam != NULL)
						{
							//copy contents of the outparam to view outparam
							if ( SUCCEEDED(t_outparam->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)) )
							{
								BSTR t_propName = NULL;
								VARIANT t_propValue;
								VariantInit(&t_propValue);

								HRESULT t_hr = t_outparam->Next(0, &t_propName, &t_propValue, NULL, NULL);

								while (hr == WBEM_S_NO_ERROR)
								{
									//copy this property
									if (SUCCEEDED(hr = m_OutParamObject->Put(t_propName, 0, &t_propValue, NULL)))
									{
										//get the next property
										VariantClear(&t_propValue);
										VariantInit(&t_propValue);
										SysFreeString(t_propName);
										t_propName = NULL;
										hr = t_outparam->Next(0, &t_propName, &t_propValue, NULL, NULL);
									}
									else
									{
										break;
									}
								}

								VariantClear(&t_propValue);

								if (t_propName != NULL)
								{
									SysFreeString(t_propName);
								}

								if (FAILED(hr))
								{
									t_outparam->EndEnumeration();
									retVal = FALSE;
								}
							}
							else
							{
								retVal = FALSE;
							}
							
							if (!retVal)
							{
								m_OutParamObject->Release();
								m_OutParamObject = NULL;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Source method executed but the view provider failed to copy the out parameter object" ) ;
							}
						}
						else
						{
							m_OutParamObject->Release();
							m_OutParamObject = NULL;
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Source method executed without returning the out parameter object" ) ;
						}
					}

					if (t_outparam != NULL)
					{
						t_outparam->Release();
					}

					break;
				}
			}
		}

		if ( FAILED (hr) )
		{
			if (m_OutParamObject)
			{
				m_OutParamObject->Release();
				m_OutParamObject = NULL;
			}

			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
#ifdef VP_SINGLE_NAMESPACE_TRIED
			wchar_t buff[100];
			wsprintf(buff, L"ExecMethod with source object failed with code: %lx", hr);
			a_ErrorObject.SetMessage ( buff ) ;
#else	//VP_SINGLE_NAMESPACE_TRIED
			a_ErrorObject.SetMessage ( L"ExecMethod with source object failed" ) ;
#endif	//VP_SINGLE_NAMESPACE_TRIED
		}
	}

	if (inst_path != NULL)
	{
		SysFreeString(inst_path);
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpquery.cpp ===
//***************************************************************************

//

//  VPGET.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the ExecQuery implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>


//for association work-around
struct MY_SQL_LEVEL_1_TOKEN
{
	BOOL m_bSpecial;
	SQL_LEVEL_1_TOKEN m_Tok;

    MY_SQL_LEVEL_1_TOKEN() { m_bSpecial = FALSE; } 
    
	//assignment operators
	MY_SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src)
	{
		m_bSpecial = FALSE;
		this->m_Tok = Src;
		return *this;
	}

    MY_SQL_LEVEL_1_TOKEN& operator=(MY_SQL_LEVEL_1_TOKEN &Src)
	{
		*this = Src.m_Tok;
		m_bSpecial = Src.m_bSpecial;
		return *this;
	}

	//copy constructors match the operators
    MY_SQL_LEVEL_1_TOKEN(MY_SQL_LEVEL_1_TOKEN &Src) { *this = Src; }
    MY_SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src) { *this = Src; }
};

ExecQueryTaskObject::ExecQueryTaskObject(CViewProvServ *a_Provider , 
		BSTR a_QueryFormat, BSTR a_Query, ULONG a_Flag,
		IWbemObjectSink *a_NotificationHandler,	IWbemContext *pCtx
) 
: WbemTaskObject(a_Provider, a_NotificationHandler, a_Flag, pCtx),
 m_Query(NULL),
 m_QueryFormat(NULL),
 m_RPNExpression(NULL)
{
	m_Query = UnicodeStringDuplicate(a_Query);
	m_QueryFormat = UnicodeStringDuplicate(a_QueryFormat);
}

ExecQueryTaskObject::~ExecQueryTaskObject ()
{
	BOOL t_Status = TRUE;
	IWbemClassObject *t_NotifyStatus = NULL ;

	if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
	{
		t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
	}

	if ( t_Status )
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
		
		if (t_NotifyStatus)
		{
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
	}

	if (m_Query != NULL)
	{
		delete [] m_Query;
	}

	if (m_QueryFormat != NULL)
	{
		delete [] m_QueryFormat;
	}

	if (m_RPNExpression != NULL)
	{
		delete m_RPNExpression;
	}

	if (m_StatusHandle != NULL)
	{
		CloseHandle(m_StatusHandle);
	}
}

BOOL ExecQueryTaskObject::PerformQuery(WbemProvErrorObject &a_ErrorObject)
{
	BOOL retVal = FALSE;
	m_StatusHandle = CreateEvent(NULL, TRUE, FALSE, NULL); 
	retVal = PerformEnumQueries(a_ErrorObject);

	if (retVal)
	{
		BOOL bWait = TRUE;

		while (bWait)
		{
			DWORD dwWait = WbemWaitForSingleObject(m_StatusHandle, VP_QUERY_TIMEOUT);

			switch (dwWait)
			{
				case WAIT_OBJECT_0:
				{
					if (ResetEvent(m_StatusHandle))
					{
						m_ResultReceived = FALSE;
						retVal = PerformSelectQueries(a_ErrorObject, bWait);

						if (retVal)
						{
							if (bWait)
							{
								while (bWait)
								{
									dwWait = WbemWaitForSingleObject(m_StatusHandle, VP_QUERY_TIMEOUT);

									switch (dwWait)
									{
										case WAIT_OBJECT_0 :
										{
											retVal = ProcessResults(a_ErrorObject);
											bWait = FALSE;
										}
										break;

										case WAIT_TIMEOUT:
										{
											BOOL bCleanup = TRUE;

											if (m_ArrayLock.Lock())
											{
												if (m_ResultReceived)
												{
													m_ResultReceived = FALSE;
													bCleanup = FALSE;
												}

												m_ArrayLock.Unlock();
											}

											if (bCleanup)
											{
												CleanUpObjSinks(TRUE);
												a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
												a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed, or query timed out" ) ;
												retVal = FALSE;
												bWait = FALSE;
											}
										}
										break;

										default:
										{
											//Cancel outstanding requests and delete object sinks...
											//======================================================
											CleanUpObjSinks(TRUE);
											a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
											a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed" ) ;
											retVal = FALSE;
											bWait = FALSE;
										}
									}
								}
							}
							else
							{
								retVal = ProcessResults(a_ErrorObject);
							}
						}
						else
						{
							ProcessResults(a_ErrorObject);
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to perform source query(ies), a WIN32 API failed" ) ;
						ProcessResults(a_ErrorObject);
					}

					bWait = FALSE;
				}
				break;

				case WAIT_TIMEOUT:
				{
					BOOL bCleanup = TRUE;

					if (m_ArrayLock.Lock())
					{
						if (m_ResultReceived)
						{
							m_ResultReceived = FALSE;
							bCleanup = FALSE;
						}

						m_ArrayLock.Unlock();
					}

					if (bCleanup)
					{
						CleanUpObjSinks(TRUE);
						a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed, or query timed out" ) ;
						retVal = FALSE;
						bWait = FALSE;
					}
				}
				break;

				default:
				{
					//Cancel outstanding requests and delete object sinks...
					//======================================================
					CleanUpObjSinks(TRUE);
					a_ErrorObject.SetStatus ( WBEM_PROV_E_FAILED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Wait on a sychronization object failed" ) ;
					retVal = FALSE;
					bWait = FALSE;
				}
			}
		}
	}
	else
	{
		//no outstanding requests, just delete object sinks...
		//====================================================
		CleanUpObjSinks();
	}

	return retVal;
}

//The following function does 'simple' analysis of the current
//query and modifies the source queries accordingly...
//============================================================
void ExecQueryTaskObject::ModifySourceQueriesForUserQuery()
{
	MY_SQL_LEVEL_1_TOKEN* pExtraToks = new MY_SQL_LEVEL_1_TOKEN[m_RPNExpression->nNumTokens + 1];

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		DWORD dwToks = 0;
		BOOL bOptimize = TRUE;

		for (int i = 0; bOptimize && (i < m_RPNExpression->nNumTokens); i++)
		{
			switch (m_RPNExpression->pArrayOfTokens[i].nTokenType)
			{
				case SQL_LEVEL_1_TOKEN::TOKEN_AND:
				{
					pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_OR:
				{
					pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
				{
					pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
				}
				break;

				case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
				{
					CPropertyQualifierItem* propItem;

					if (m_PropertyMap.Lookup(m_RPNExpression->pArrayOfTokens[i].pPropertyName, propItem))
					{
						if (!propItem->m_SrcPropertyNames[x].IsEmpty())
						{
							//TransposeReference if necessary
							//=================================
							MY_SQL_LEVEL_1_TOKEN tmpToken = m_RPNExpression->pArrayOfTokens[i];
							BOOL bCont = TRUE;

							if (m_bAssoc && (propItem->GetCimType() == CIM_REFERENCE))
							{
								bCont = TransposeReference(propItem, m_RPNExpression->pArrayOfTokens[i].vConstValue,
																&(tmpToken.m_Tok.vConstValue), FALSE, NULL);

								if (bCont)
								{
									//mark the token as special
									//for the association work-around
									tmpToken.m_bSpecial = TRUE;
								}
							}

							if (bCont)
							{
								pExtraToks[dwToks] = tmpToken;
								SysFreeString(pExtraToks[dwToks].m_Tok.pPropertyName);
								pExtraToks[dwToks++].m_Tok.pPropertyName = propItem->m_SrcPropertyNames[x].AllocSysString();
							}
							else
							{
								//can't "simply" optimize this query!
								dwToks = 0;
								bOptimize = FALSE;
							}
						}
						else
						{
							//can't "simply" optimize this query!
							dwToks = 0;
							bOptimize = FALSE;
						}
					}
					else
					{
						//can't "simply" optimize this query!
						dwToks = 0;
						bOptimize = FALSE;
					}
				}
				break;

				default:
				{
				}
			}
		}

		if (dwToks != 0)
		{
			if (m_SourceArray[x]->GetRPNExpression()->nNumTokens > 0)
			{
				pExtraToks[dwToks++].m_Tok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
			}

			for (i = 0; i < dwToks; i++)
			{
				m_SourceArray[x]->GetRPNExpression()->AddToken(pExtraToks[i].m_Tok);

				if (pExtraToks[i].m_bSpecial)
				{
					//add the extra tokens if neccessary
					//for the association work-around
					wchar_t *t_pChar = pExtraToks[i].m_Tok.vConstValue.bstrVal;

					//must be \\server\namespace and not \\.\namespace or relpath
					if ( (*t_pChar == L'\\') && (*(t_pChar+1) == L'\\') && (*(t_pChar+2) != L'.') )
					{
						//add the dotted version
						SQL_LEVEL_1_TOKEN t_Tok = pExtraToks[i].m_Tok;
						t_pChar = t_Tok.vConstValue.bstrVal + 2;
						
						while (*t_pChar != L'\\')
						{
							t_pChar++;
						}

						--t_pChar;
						*t_pChar = L'.';
						--t_pChar;
						*t_pChar = L'\\';
						--t_pChar;
						*t_pChar = L'\\';
						BSTR t_strtmp = SysAllocString(t_pChar);
						VariantClear(&(t_Tok.vConstValue));
						VariantInit(&(t_Tok.vConstValue));
						t_Tok.vConstValue.vt = VT_BSTR;
						t_Tok.vConstValue.bstrVal = t_strtmp;
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_Tok);

						//add an Or token
						SQL_LEVEL_1_TOKEN t_OrTok;
						t_OrTok.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_OrTok);

						//add the relpath version
						t_pChar = t_Tok.vConstValue.bstrVal + 4;
						
						while (*t_pChar != L':')
						{
							t_pChar++;
						}

						//exclude the ':'
						t_pChar++;
						t_strtmp = SysAllocString(t_pChar);
						VariantClear(&(t_Tok.vConstValue));
						VariantInit(&(t_Tok.vConstValue));
						t_Tok.vConstValue.vt = VT_BSTR;
						t_Tok.vConstValue.bstrVal = t_strtmp;
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_Tok);

						//add the last OR
						m_SourceArray[x]->GetRPNExpression()->AddToken(t_OrTok);
					}
				}
			}
		}
	}

	delete [] pExtraToks;
}

//This function does 'simple' analysis of the join and modifies the
//unexecuted source queries accordingly for the results received so far...
//=========================================================================
void ExecQueryTaskObject::ModifySourceQueriesWithEnumResults()
{
	wchar_t** classA = m_JoinOnArray.GetAClasses();
	wchar_t** propsA = m_JoinOnArray.GetAProperties();
	wchar_t** classB = m_JoinOnArray.GetBClasses();
	wchar_t** propsB = m_JoinOnArray.GetBProperties();
	UINT* ops = m_JoinOnArray.GetOperators();
	int iEnum;	//the index of the enumerated class
	int iMod;	//the index of the source query to be modified

	for (int x = 0; x < m_JoinOnArray.GetCount(); x++)
	{
		BOOL bIsAEnum = m_EnumerateClasses.Lookup(classA[x], iEnum);
		BOOL bIsBEnum = m_EnumerateClasses.Lookup(classB[x], iEnum);
		wchar_t* propEnum;
		wchar_t* propMod;

		if ( (bIsAEnum && !bIsBEnum) || (!bIsAEnum && bIsBEnum) )
		{
			if (bIsAEnum) 
			{
				if (!m_ClassToIndexMap.Lookup(classA[x], iEnum))
				{
					//an error forget this case!
					continue;
				}
				else
				{
					if (!m_ClassToIndexMap.Lookup(classB[x], iMod))
					{
						//an error forget this case!
						continue;
					}
					else
					{
						propEnum = propsA[x];
						propMod = propsB[x];
					}
				}
			}
			else
			{
				if (!m_ClassToIndexMap.Lookup(classB[x], iEnum))
				{
					//an error forget this case!
					continue;
				}
				else
				{
					if (!m_ClassToIndexMap.Lookup(classA[x], iMod))
					{
						//an error forget this case!
						continue;
					}
					else
					{
						propEnum = propsB[x];
						propMod = propsA[x];
					}
				}
			}

			//don't transpose references as
			//they are already in source format.
			int m = 0;
			SQL_LEVEL_1_TOKEN opToken;
			opToken.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
			SQL_LEVEL_1_TOKEN token;
			token.nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
			token.pPropertyName = SysAllocString(propMod);

			if (ops[x] == CJoinOnQualifierArray::NOT_EQUALS_OPERATOR)
			{
				token.nOperator = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
			}
			else if (ops[x] == CJoinOnQualifierArray::EQUALS_OPERATOR)
			{
				token.nOperator = SQL_LEVEL_1_TOKEN::OP_EQUAL;
			}

			BOOL bAddAnd = m_SourceArray[iMod]->GetRPNExpression()->nNumTokens > 0;

			for (int n = 0; n < m_ObjSinkArray[iEnum]->m_ObjArray.GetSize(); n++)
			{
				VariantInit(&token.vConstValue);
				IWbemClassObject* pObj = m_ObjSinkArray[iEnum]->m_ObjArray[n]->GetWrappedObject();

				if ( SUCCEEDED(pObj->Get(propEnum, 0, &token.vConstValue, NULL, NULL)) )
				{
					m_SourceArray[iMod]->GetRPNExpression()->AddToken(token);
					m++;

					if (m > 1)
					{
						m_SourceArray[iMod]->GetRPNExpression()->AddToken(opToken);
					}
				}

				VariantClear(&token.vConstValue);
			}

			if ((bAddAnd) && (m != 0))
			{
				opToken.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
				m_SourceArray[iMod]->GetRPNExpression()->AddToken(opToken);
			}
		}
	}
}

BOOL ExecQueryTaskObject::PerformSelectQueries(WbemProvErrorObject &a_ErrorObject, BOOL &bWait)
{
	bWait = FALSE;

	BOOL bStatusSet = FALSE;

	if (!m_JoinOnArray.IsValid() ||	m_EnumerateClasses.IsEmpty())
	{
		return TRUE;
	}

	ModifySourceQueriesWithEnumResults();
	
	//reset number of queries asked and answered
	m_iQueriesAsked = 1;
	m_iQueriesAnswered = 0;

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		int dummyInt;

		if (!m_EnumerateClasses.Lookup(m_SourceArray[x]->GetClassName(), dummyInt))
		{
			CStringW queryStr = GetStringFromRPN(m_SourceArray[x]->GetRPNExpression(), 0, NULL);
			CWbemServerWrap** nsPtrs = m_NSpaceArray[x]->GetServerPtrs();

            if (queryStr.GetLength() > 0)
            {
			    for (int m = 0; m < m_NSpaceArray[x]->GetCount(); m++)
			    {
				    if (nsPtrs[m] != NULL)
				    {
					    CViewProvObjectSink* pSnk = new CViewProvObjectSink(m_ObjSinkArray[x], nsPtrs[m], m);
					    pSnk->AddRef();
					    BSTR queryBStr = queryStr.AllocSysString();
					    BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);
					    IWbemObjectSink* pQuerySink = pSnk;
					    IWbemContext * t_pCtx = m_Ctx;

					    if (nsPtrs[m]->IsRemote())
					    {
#if 0
#if _NT_TARGET_VERSION < 500
						    pQuerySink = pSnk->Associate();
#endif
#endif
						    t_pCtx = NULL; //don't use context for remote cimoms
					    }

					    IWbemServices *ptmpServ = nsPtrs[m]->GetServerOrProxy();

					    if (ptmpServ)
					    {
						    if ( pQuerySink )
						    {
							    HRESULT t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);

							    if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[m]->IsRemote())
							    {
								    if ( SUCCEEDED(UpdateConnection(&(nsPtrs[m]), &ptmpServ)) )
								    {
									    if (ptmpServ)
									    {
										    t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);
									    }
								    }
							    }

							    if (SUCCEEDED(t_hr))
							    {
								    if (m_ArrayLock.Lock())
								    {
									    m_iQueriesAsked++;
									    m_ArrayLock.Unlock();
								    }
								    else
								    {
									    pSnk->DisAssociate();
								    }
							    }
							    else
							    {
								    pSnk->DisAssociate();
							    }
						    }
						    else
						    {
							    pSnk->DisAssociate();
						    }

						    if (ptmpServ)
						    {
							    nsPtrs[m]->ReturnServerOrProxy(ptmpServ);
						    }
					    }
					    else
					    {
						    pSnk->DisAssociate();
					    }

					    SysFreeString(queryLBStr);
					    SysFreeString(queryBStr);
					    pSnk->Release();
				    }
					else
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_NAMESPACE ) ;
						a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_NSpaceArray[x]->GetServerCreationError () ) ;
						a_ErrorObject.SetMessage ( L"Failed to send query, invalid or inaccessible namespace" ) ;

						bStatusSet = TRUE;
					}
			    }
            }
		}
	}

	if (m_ArrayLock.Lock())
	{
		m_iQueriesAsked--;

		if (m_iQueriesAsked != m_iQueriesAnswered)
		{
			//just in case this was triggerred while we had yet to ask some queries
			ResetEvent(m_StatusHandle);
		}
		else
		{
			//just in case this wasn't triggerred while we were asking queries
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}

	if (m_iQueriesAsked == 0)
	{
		if ( ! bStatusSet )
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to perform source query(ies), invalid source namespace(s)" ) ;
		}
		return FALSE;
	}
	else
	{
		bWait = TRUE;
	}

	return TRUE;
}

BOOL ExecQueryTaskObject::PerformEnumQueries(WbemProvErrorObject &a_ErrorObject)
{
	m_iQueriesAsked++;
	ModifySourceQueriesForUserQuery();
	m_ObjSinkArray.SetSize(0, m_NSpaceArray.GetSize());

	BOOL bStatusSet = FALSE;

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		BOOL bDone = FALSE;
		int dummyInt;
		CObjectSinkResults * objSnk = new CObjectSinkResults(this, x);
		objSnk->AddRef();
		m_ObjSinkArray.SetAtGrow(x, objSnk);

		if (!m_JoinOnArray.IsValid() ||	m_EnumerateClasses.IsEmpty() ||
			m_EnumerateClasses.Lookup(m_SourceArray[x]->GetClassName(), dummyInt) )
		{
			CStringW queryStr = GetStringFromRPN(m_SourceArray[x]->GetRPNExpression(), 0, NULL);

            if (queryStr.GetLength() > 0)
            {
			    CWbemServerWrap** nsPtrs = m_NSpaceArray[x]->GetServerPtrs();

			    for (int m = 0; m < m_NSpaceArray[x]->GetCount(); m++)
			    {
				    if (nsPtrs[m] != NULL)
				    {
					    CViewProvObjectSink* pSnk = new CViewProvObjectSink(objSnk, nsPtrs[m], m);
					    pSnk->AddRef();
					    BSTR queryBStr = queryStr.AllocSysString();
					    BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);
					    IWbemObjectSink* pQuerySink = pSnk;
					    IWbemContext * t_pCtx = m_Ctx;

					    if (nsPtrs[m]->IsRemote())
					    {
#if 0
#if _NT_TARGET_VERSION < 500
						    pQuerySink = pSnk->Associate();
#endif
#endif
						    t_pCtx = NULL; //don't use context for remote cimoms
					    }

					    IWbemServices *ptmpServ = nsPtrs[m]->GetServerOrProxy();

					    if (ptmpServ)
					    {
						    if ( pQuerySink )
						    {
							    HRESULT t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);

							    if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[m]->IsRemote())
							    {
								    if ( SUCCEEDED(UpdateConnection(&(nsPtrs[m]), &ptmpServ)) )
								    {
									    if (ptmpServ)
									    {
										    t_hr = ptmpServ->ExecQueryAsync(queryLBStr, queryBStr, 0, t_pCtx, pQuerySink);
									    }
								    }
							    }

							    if (SUCCEEDED(t_hr))
							    {
								    if (m_ArrayLock.Lock())
								    {
									    m_iQueriesAsked++;
									    m_ArrayLock.Unlock();
								    }
								    else
								    {
									    pSnk->DisAssociate();
								    }
							    }
							    else
							    {
								    pSnk->DisAssociate();
							    }
						    }
						    else
						    {
							    pSnk->DisAssociate();
						    }

						    if (ptmpServ)
						    {
							    nsPtrs[m]->ReturnServerOrProxy(ptmpServ);
						    }
					    }
					    else
					    {
						    pSnk->DisAssociate();
					    }

					    pSnk->Release();
					    SysFreeString(queryBStr);
					    SysFreeString(queryLBStr);
				    }
					else
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_NAMESPACE ) ;
						a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_NSpaceArray[x]->GetServerCreationError () ) ;
						a_ErrorObject.SetMessage ( L"Failed to send query, invalid or inaccessible namespace" ) ;

						bStatusSet = TRUE;
					}
			    }
            }
		}
	}

	if (m_ArrayLock.Lock())
	{
		m_iQueriesAsked--;

		if (m_iQueriesAsked != m_iQueriesAnswered)
		{
			//just in case this was triggerred while we had yet to ask some queries
			ResetEvent(m_StatusHandle);
		}
		else
		{
			//just in case this wasn't triggerred while we were asking queries
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}

	if (m_iQueriesAsked == 0)
	{
		if ( ! bStatusSet )
		{
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to perform source query(ies), invalid source namespace(s)" ) ;
		}
		return FALSE;
	}

	return TRUE;
}

BOOL ExecQueryTaskObject::ProcessResults(WbemProvErrorObject &a_ErrorObject)
{
	BOOL retVal = TRUE;
	int indexCnt = 0;

	for (int x = 0; retVal && (x < m_ObjSinkArray.GetSize()); x++)
	{
		if (m_ObjSinkArray[x]->IsSet())
		{
			if (SUCCEEDED(m_ObjSinkArray[x]->GetResult()))
			{
				DWORD dwCount = m_ObjSinkArray[x]->m_ObjArray.GetSize();

				if (0 < dwCount)
				{
					indexCnt++;
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_ObjSinkArray[x]->GetResult() ) ;
				a_ErrorObject.SetMessage ( L"Object path and Class qualifiers resulted in a failed query." ) ;
			}
		}
		else 
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Invalid source namespace path OR object path and Class qualifiers resulted in a failed query." ) ;
		}
	}

	if (0 == indexCnt)
	{
		if (retVal)
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_NOT_FOUND ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"No source objects found to support view object path." ) ;
		}

		CleanUpObjSinks();
	}
	else
	{
		if (m_JoinOnArray.IsValid())
		{
#ifdef VP_PERFORMANT_JOINS
			BOOL t_bRes = CreateAndIndicateJoinsPerf(a_ErrorObject, m_bSingleton);
#else
			BOOL t_bRes = CreateAndIndicateJoins(a_ErrorObject, m_bSingleton);
#endif
			retVal =  retVal && t_bRes;
		}
		else //union or association
		{
			if ((m_bSingleton) && (indexCnt > 1))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Too many view instances can be created." ) ;
				CleanUpObjSinks();
			}
			else
			{
				BOOL t_bRes = CreateAndIndicateUnions(a_ErrorObject, -1);
				retVal =  retVal && t_bRes;
			}
		}
	}

	return retVal;
}

BOOL ExecQueryTaskObject :: ExecQuery ()
{
	BOOL t_Status ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery\r\n")
		) ;
)

	if ( _wcsicmp ( m_QueryFormat , WBEM_QUERY_LANGUAGE_SQL1 ) == 0 )
	{
		CTextLexSource querySource(m_Query);
		SQL1_Parser sqlParser(&querySource) ;
		t_Status = ! sqlParser.Parse ( & m_RPNExpression ) ;

		if ( t_Status )
		{
			t_Status = SetClass(m_RPNExpression->bsClassName) ;
			
			if ( t_Status )
			{
				t_Status = ParseAndProcessClassQualifiers(m_ErrorObject);

				if (t_Status)
				{
					t_Status = PerformQuery(m_ErrorObject);
				}
			}
			else
			{
				t_Status = FALSE ;
				m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS ) ;
				m_ErrorObject.SetMessage ( L"Unknown Class" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:Unknown Class\r\n")
		) ;
)
			}
		}
		else
		{
			t_Status = FALSE ;
			m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY ) ;
			m_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			m_ErrorObject.SetMessage ( L"WQL query was invalid for this provider" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:WQL query was invalid for this provider\r\n")
		) ;
)
		}
	}
	else
	{
		t_Status = FALSE ;
		m_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY_TYPE ) ;
		m_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		m_ErrorObject.SetMessage ( L"Query Language not supported" ) ;
DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:Query Language not supported\r\n")
		) ;
)
	}

DebugOut2( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("ExecQueryTaskObject :: ExecQuery:Returning %lx\r\n"),
		t_Status
		) ;
)

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpsinks.cpp ===
//***************************************************************************

//

//  VPSINKS.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the sinks implementations

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern CRITICAL_SECTION g_CriticalSection;


CWbemClassObjectWithIndex :: CWbemClassObjectWithIndex(DWORD a_indx, IWbemClassObject *a_pObj)
: m_pObject(NULL), m_ReferenceCount(0), m_nsindex(a_indx)
{
	if (a_pObj)
	{
		a_pObj->AddRef();
		m_pObject = a_pObj;
	}
}

CWbemClassObjectWithIndex :: ~CWbemClassObjectWithIndex()
{
	if (m_pObject)
	{
		m_pObject->Release();
	}
}

ULONG CWbemClassObjectWithIndex :: AddRef ()
{
    return InterlockedIncrement(&m_ReferenceCount);
}

ULONG CWbemClassObjectWithIndex :: Release ()
{
	ULONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

CObjectSinkResults::CObjectSinkResults(WbemTaskObject* parent, DWORD index)
{
	m_ReferenceCount = 0;
	m_index = index;
	m_bSet = FALSE;
	m_hr = 0;
	m_parent = parent;
	m_parent->AddRef();
	m_ObjArray.SetSize(0, 10); //grow by 10s
}

CObjectSinkResults::~CObjectSinkResults()
{
	if (m_parent != NULL)
	{
		m_parent->Release();
	}

	m_ObjArray.RemoveAll();
}

ULONG CObjectSinkResults::AddRef()
{
    return InterlockedIncrement(&m_ReferenceCount);
}

ULONG CObjectSinkResults::Release()
{
	LONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

void CObjectSinkResults::SetStatus(HRESULT hr, CViewProvObjectSink *pSnk)
{
	if (m_CriticalSection.Lock())
	{
		if (SUCCEEDED(m_hr))
		{
			m_hr = hr;
		}

		RemoveSink(pSnk);
		m_bSet = TRUE;

		if (m_parent != NULL)
		{
			m_parent->SetStatus(hr, m_index);
		}

		m_CriticalSection.Unlock();
	}
}

void CObjectSinkResults::SetSink(CViewProvObjectSink *pSnk)
{
	if (m_CriticalSection.Lock())
	{
		m_realSnks.AddTail(pSnk);
		m_CriticalSection.Unlock();
	}
}

BOOL CObjectSinkResults::RemoveSink(CViewProvObjectSink *pSnk)
{
	BOOL retVal = FALSE;

	if (m_CriticalSection.Lock())
	{
		POSITION t_pos = m_realSnks.GetHeadPosition();

		while (t_pos)
		{
			POSITION t_badPos = t_pos;
			CViewProvObjectSink * t_pSnk = m_realSnks.GetNext(t_pos);

			if (pSnk == t_pSnk)
			{
				m_realSnks.RemoveAt(t_badPos);
				retVal = TRUE;
				break;
			}
		}

		m_CriticalSection.Unlock();
	}

	return retVal;
}

void CObjectSinkResults::Disconnect()
{
//can't call disconnect when locked, since this calls CancelAsyncCall
	CList<CViewProvObjectSink*,CViewProvObjectSink*> t_realSnks;

	if (m_CriticalSection.Lock())
	{
		while (m_realSnks.GetCount() > 0)
		{
			CViewProvObjectSink* t_pSnk = m_realSnks.RemoveTail();

			if (t_pSnk)
			{
				t_pSnk->AddRef();
				t_realSnks.AddTail(t_pSnk);
			}
		}

		if (m_parent != NULL)
		{
			m_parent->Release();
			m_parent = NULL;
		}

		m_CriticalSection.Unlock();
	}

	while (t_realSnks.GetCount() > 0)
	{
		CViewProvObjectSink* t_pSnk = t_realSnks.RemoveTail();

		if (t_pSnk)
		{
			t_pSnk->Disconnect();
			t_pSnk->Release();
		}
	}
}

HRESULT CObjectSinkResults::Indicate(LONG count, IWbemClassObject** ppObjArray, DWORD a_indx)
{
	HRESULT hr = WBEM_NO_ERROR;

	if ( (count > 0) && m_CriticalSection.Lock() )
	{
		if (m_parent != NULL)
		{
			m_parent->SetResultReceived();

			for (LONG x = 0; x < count; x++)
			{
				if (ppObjArray[x] != NULL)
				{
					CWbemClassObjectWithIndex *t_clsWrap = new CWbemClassObjectWithIndex(a_indx, ppObjArray[x]);
					t_clsWrap->AddRef();
					m_ObjArray.Add(t_clsWrap);
				}
				else
				{
					hr = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		else
		{
			hr = WBEM_E_CALL_CANCELLED;
		}

		m_CriticalSection.Unlock();
	}
	else
	{
		if (count < 0)
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
	}

	return hr;
}

CViewProvObjectSink::CViewProvObjectSink(CObjectSinkResults* parent, CWbemServerWrap *pServ, DWORD a_indx)
:m_parent(NULL), m_ServWrap(NULL), m_nsindex(a_indx)
{
	EnterCriticalSection(&g_CriticalSection);
	CViewProvClassFactory :: objectsInProgress++;
	LeaveCriticalSection(&g_CriticalSection);
	m_ReferenceCount = 0;
	m_parent = parent;
	m_parent->AddRef();
	m_parent->SetSink(this);
	m_ServWrap = pServ;
	m_ServWrap->AddRef();
	m_RemoteSink = NULL;
	m_DoCancel = TRUE;
}

CViewProvObjectSink::~CViewProvObjectSink()
{
	if (m_parent != NULL)
	{
		//set status has not been called so call it...
		m_parent->SetStatus(WBEM_E_FAILED, this);
		m_parent->Release();
	}

	if (m_ServWrap != NULL)
	{
		m_ServWrap->Release();
	}

	if (m_RemoteSink != NULL)
	{
		m_RemoteSink->Release();
	}

	EnterCriticalSection(&g_CriticalSection);	
	CViewProvClassFactory :: objectsInProgress--;
	LeaveCriticalSection(&g_CriticalSection);
}

STDMETHODIMP CViewProvObjectSink::QueryInterface (REFIID refIID, LPVOID FAR * ppV)
{
	if (ppV == NULL)
	{
		return E_INVALIDARG;
	}

	*ppV = NULL ;

	if ( refIID == IID_IUnknown )
	{
		*ppV = ( IWbemObjectSink* ) this ;
	}
	else if ( refIID == IID_IWbemObjectSink )
	{
		*ppV = ( IWbemObjectSink* ) this ;		
	}

	if ( *ppV )
	{
		( ( LPUNKNOWN ) *ppV )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG)  CViewProvObjectSink::AddRef()
{
    return InterlockedIncrement(&m_ReferenceCount);
}

STDMETHODIMP_(ULONG)  CViewProvObjectSink::Release()
{
	LONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

HRESULT CViewProvObjectSink::Indicate(LONG count, IWbemClassObject** ppObjArray)
{
	HRESULT hr = WBEM_NO_ERROR;

	if (m_lock.Lock())
	{
		if (m_parent != NULL)
		{
			hr = m_parent->Indicate(count, ppObjArray, m_nsindex);
		}

		m_lock.Unlock();
	}
	
	return hr;
}

HRESULT CViewProvObjectSink::SetStatus(LONG lFlags, HRESULT hr, BSTR bStr, IWbemClassObject* pObj)
{
	if (m_lock.Lock())
	{
		if (m_parent != NULL)
		{
			m_parent->SetStatus(hr, this);
			m_parent->Release();
			m_parent = NULL;

			DisAssociate();
			m_DoCancel = FALSE;
		}

		m_lock.Unlock();
	}

	return WBEM_NO_ERROR;
}

void CViewProvObjectSink::Disconnect()
{
	BOOL doCancel = FALSE;

	if (m_lock.Lock())
	{
		if (m_DoCancel)
		{
			doCancel = TRUE;
			m_DoCancel = FALSE;

			if (m_parent != NULL)
			{
				m_parent->Release();
				m_parent = NULL;
			}
		}

		m_lock.Unlock();
	}

	if (doCancel)
	{
		if (m_ServWrap != NULL)
		{
			IWbemServices *ptmpServ = m_ServWrap->GetServerOrProxy();

			if (ptmpServ)
			{
				if (m_RemoteSink != NULL)
				{
					ptmpServ->CancelAsyncCall(this);
				}
				else
				{
					ptmpServ->CancelAsyncCall(m_RemoteSink);
					DisAssociate();			
				}

				m_ServWrap->ReturnServerOrProxy(ptmpServ);
			}

			m_ServWrap->Release();
			m_ServWrap = NULL;
		}
	}
}

IWbemObjectSink* CViewProvObjectSink::Associate()
{
	IUnsecuredApartment* pUA = NULL;

	if ( SUCCEEDED(CViewProvServ::GetUnsecApp(&pUA)) )
	{
		IUnknown* pUnk = NULL;
		
		if ( SUCCEEDED(pUA->CreateObjectStub(this, &pUnk)) )
		{
			if ( FAILED(pUnk->QueryInterface(IID_IWbemObjectSink, (void **)&m_RemoteSink)) )
			{
				pUnk = NULL;
			}

			pUnk->Release();
		}

		pUA->Release();
	}

	return m_RemoteSink;
}

void CViewProvObjectSink::DisAssociate()
{
	if (m_RemoteSink != NULL)
	{
		m_RemoteSink->Release();
		m_RemoteSink = NULL;
	}
		
	if (m_lock.Lock())
	{
		if (m_parent != NULL)
		{
			m_parent->Release();
			m_parent = NULL;
		}

		m_lock.Unlock();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vptasks.cpp ===
//***************************************************************************

//

//  VPTASKS.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the common methods taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

//need the following three lines
//to get the security stuff to work
#include "precomp.h"

#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern BOOL bAreWeLocal(WCHAR* pServerMachine);

#ifdef VP_BUILD_AS_EXE
HRESULT EnableAllPrivileges(BOOL bProcess)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
	BOOL bRes = FALSE;

	if (bProcess)
	{
		bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
	}
	else
	{
		bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);
	}

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
	memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, 
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
	{
		if ( GetLastError () == ERROR_SUCCESS )
		{
			return WBEM_S_NO_ERROR;
		}
		else
		{
			return WBEM_E_UNEXPECTED ;
		}
	}
}

#endif

#ifdef UNICODE
HRESULT GetCurrentSecuritySettings(DWORD *pdwAuthnSvc, DWORD *pdwAuthzSvc,
								   DWORD *pdwAuthLevel, DWORD *pdwImpLevel,
								   DWORD *pdwCapabilities)
{
	HRESULT hr = WBEM_E_FAILED;
    IServerSecurity * pss = NULL;
    hr = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss);

#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
#endif

    if(S_OK == hr)
    {
        pss->QueryBlanket(pdwAuthnSvc, pdwAuthzSvc, NULL, 
                pdwAuthLevel, NULL, NULL, pdwCapabilities);
        pss->Release();
    }
	else
	{
		if (SUCCEEDED(hr))
		{
			hr = WBEM_E_FAILED;
		}
	}

	if (SUCCEEDED(hr))
	{
		DWORD dwVersion = GetVersion();

		if (dwVersion < 0x80000000)
		{
			if ( 4 < (DWORD)(LOBYTE(LOWORD(dwVersion))) )
			{
				//we're on win2k force static cloaking...
				*pdwCapabilities = EOAC_STATIC_CLOAKING;
			}
		}

		//get implevel...
		HANDLE hThreadTok = NULL;
		hr = WBEM_E_FAILED;

		if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
		{
			DWORD dwBytesReturned = 0;
			DWORD dwThreadImpLevel = 0;

			if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwThreadImpLevel,
										sizeof(DWORD), &dwBytesReturned)) 
			{
				hr = WBEM_NO_ERROR;

				switch(dwThreadImpLevel)
				{
					case SecurityAnonymous:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
					}
					break;

					case SecurityIdentification:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
					}
					break;

					case SecurityImpersonation:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
					}
					break;

					case SecurityDelegation:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
					}
					break;
					
					default:
					{
						hr = WBEM_E_FAILED;
					}
				}

#ifdef VP_BUILD_AS_EXE
				if (*pdwImpLevel < RPC_C_IMP_LEVEL_IMPERSONATE)
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
				}
#endif
			}

			CloseHandle(hThreadTok);
		}
	}
    
	return hr;
}
#endif

HRESULT SetSecurityLevelAndCloaking(IUnknown* pInterface, const wchar_t* prncpl)
{
#ifdef UNICODE

	//first get current security info then set it on the proxy...
    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    DWORD dwAuthLevel = 0;
    DWORD dwImpLevel = 0;
    DWORD dwCapabilities = 0;

	HRESULT hr = GetCurrentSecuritySettings(&dwAuthnSvc, &dwAuthzSvc, &dwAuthLevel, &dwImpLevel, &dwCapabilities);

	if (SUCCEEDED(hr))
	{
#ifdef VP_BUILD_AS_EXE
		EnableAllPrivileges(FALSE);
#endif
		DWORD dwVersion = GetVersion();
		BSTR t_pname = NULL;

		if (dwVersion < 0x80000000)
		{
			if ( 4 < (DWORD)(LOBYTE(LOWORD(dwVersion))) )
			{
				//we're on win2k force COLE_DEFAULT_PRINCIPAL...
				t_pname = COLE_DEFAULT_PRINCIPAL;

				if ((dwImpLevel > 3) && (prncpl != COLE_DEFAULT_PRINCIPAL))
				{
					dwAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
					t_pname = (BSTR)prncpl;					
				}
			}
		}

		hr = WbemSetProxyBlanket(pInterface,
							dwAuthnSvc,//16 
							dwAuthzSvc,//RPC_C_AUTHZ_NONE 
							t_pname, //prncpl,
							dwAuthLevel, //RPC_C_AUTHN_LEVEL_CONNECT
							dwImpLevel, //RPC_C_IMP_LEVEL_IMPERSONATE
							NULL,
							dwCapabilities); //0x20

		//there is no IClientSecurity, we must be running inproc!
		if (hr == E_NOINTERFACE)
		{
			hr = S_OK;
		}

#if 0
		if (SUCCEEDED(hr))
		{
			IClientSecurity *t_pCliSec = NULL;
			HRESULT t_hr = pInterface->QueryInterface(IID_IClientSecurity, (void **) &t_pCliSec);

			if (SUCCEEDED(t_hr))
			{
				DWORD t_AuthnSvc = 0;
				DWORD t_AuthzSvc = 0;
				wchar_t *t_pServerPrincName = NULL;
				DWORD t_AuthnLevel = 0;
				DWORD t_ImpLevel = 0;
				DWORD t_Capabilities = 0;
				t_hr = t_pCliSec->QueryBlanket(pInterface, &t_AuthnSvc,
												&t_AuthzSvc, &t_pServerPrincName,
												&t_AuthnLevel, &t_ImpLevel,
												NULL, &t_Capabilities);

				if (SUCCEEDED(t_hr))
				{
					if (t_pServerPrincName)
					{
						CoTaskMemFree(t_pServerPrincName);
					}
				}

				t_pCliSec->Release();
			}
		}
#endif
	}
#else
	HRESULT hr = WBEM_NO_ERROR;
#endif

    return hr;
}

BOOL IsInObjectPath(ParsedObjectPath *a_ParsedObjectPath, const wchar_t *a_key)
{
	if ( (!a_ParsedObjectPath->IsInstance()) || (a_ParsedObjectPath->m_bSingletonObj) || (a_ParsedObjectPath->m_paKeys == NULL) )
	{
		return FALSE;
	}

	for (int x = 0; x < a_ParsedObjectPath->m_dwNumKeys; x++)
	{
		if ((a_ParsedObjectPath->m_paKeys[x]->m_pName != NULL)
			&& (_wcsicmp(a_key, a_ParsedObjectPath->m_paKeys[x]->m_pName) == 0))
		{
			return TRUE;
		}
	}

	return FALSE;
}

//returns TRUE if VARIANTs are equal
BOOL CompareKeyValueVariants(const VARIANT &a_v1, const VARIANT &a_v2)
{
	BOOL retVal = FALSE;

	if (a_v1.vt == a_v2.vt)
	{
		switch (a_v1.vt)
		{
            case VT_BSTR:
			{
                retVal = (_wcsicmp(a_v1.bstrVal, a_v2.bstrVal) == 0);
                break;
			}

            case VT_I4:
			{
                retVal = (a_v1.lVal == a_v2.lVal);
                break;
			}

            case VT_I2:
			{
                retVal = (a_v1.iVal == a_v2.iVal);
                break;
			}

            case VT_UI1:
			{
                retVal = (a_v1.bVal == a_v2.bVal);
                break;
			}

            case VT_BOOL:
			{
                retVal = (V_BOOL(&a_v1) == V_BOOL(&a_v2));
                break;
			}
			
			default:
			{
			}
		}
	}

	return retVal;
}

//this function assumes class 1 is derived from class2 or vice versa
//returns TRUE if paths are equal
BOOL CompareInstPaths(const wchar_t *a_path1, const wchar_t *a_path2)
{
	BOOL retVal = FALSE;

	if ((a_path1 == NULL) || (a_path2 == NULL))
	{
		return retVal;
	}

	CObjectPathParser t_objectPathParser;
	wchar_t* t_objPath1 = UnicodeStringDuplicate(a_path1);
	wchar_t* t_objPath2 = UnicodeStringDuplicate(a_path2);
	ParsedObjectPath *t_parsedpath1 = NULL;
	ParsedObjectPath *t_parsedpath2 = NULL;

	if ( (t_objectPathParser.Parse(t_objPath1, &t_parsedpath1) == 0) &&
		(t_objectPathParser.Parse(t_objPath2, &t_parsedpath2) == 0) &&
		t_parsedpath1->IsInstance() && t_parsedpath2->IsInstance())
	{
		if (t_parsedpath1->m_dwNumKeys == t_parsedpath2->m_dwNumKeys)
		{
			retVal = TRUE;

			//single properties
			if ((t_parsedpath1->m_dwNumKeys == 1) &&
				((t_parsedpath1->m_paKeys[0]->m_pName == NULL) || (t_parsedpath2->m_paKeys[0]->m_pName == NULL)))
			{
				//compare the values...
				retVal = CompareKeyValueVariants(t_parsedpath1->m_paKeys[0]->m_vValue,
													t_parsedpath2->m_paKeys[0]->m_vValue);
			}
			else
			{
				//any property mismatch set retVal FALSE!
				for (DWORD i = 0; retVal && (i < t_parsedpath1->m_dwNumKeys); i++)
				{
					retVal = FALSE;

					if(t_parsedpath1->m_paKeys[i]->m_pName == NULL)
					{
						break;
					}

					for (DWORD j = 0; j < t_parsedpath2->m_dwNumKeys; j++)
					{
						if(t_parsedpath2->m_paKeys[j]->m_pName == NULL)
						{
							break;
						}

						if (_wcsicmp(t_parsedpath1->m_paKeys[i]->m_pName, t_parsedpath2->m_paKeys[j]->m_pName) == 0)
						{
							//compare the values...
							retVal = CompareKeyValueVariants(t_parsedpath1->m_paKeys[i]->m_vValue,
																t_parsedpath2->m_paKeys[j]->m_vValue);
						}
					}
				}
			}
		}
	}

	delete [] t_objPath1;
	delete [] t_objPath2;

	if (t_parsedpath1 != NULL)
	{
		delete t_parsedpath1;
	}

	if (t_parsedpath2 != NULL)
	{
		delete t_parsedpath2;
	}

	return retVal;
}

WbemTaskObject :: WbemTaskObject (

	CViewProvServ *a_Provider ,
	IWbemObjectSink *a_NotificationHandler ,
	ULONG a_OperationFlag ,
	IWbemContext *a_Ctx,
	IWbemServices *a_Serv,
	CWbemServerWrap *a_ServerWrap

) :m_OperationFlag ( a_OperationFlag ) ,
	m_Provider ( NULL ) ,
	m_NotificationHandler ( NULL ) ,
	m_Ctx ( NULL ) ,
	m_ClassObject ( NULL ),
	m_RPNPostFilter( NULL),
	m_ClassName(NULL),
	m_Ref ( 1 ),
	m_iQueriesAnswered ( 0 ),
	m_iQueriesAsked ( 0 ), 
	m_StatusHandle(NULL),
	m_bAssoc ( FALSE ),
	m_bSingleton ( FALSE ),
	m_Serv ( NULL ),
	m_bIndicate ( TRUE ) ,
	m_ResultReceived ( FALSE ),
	m_ServerWrap (NULL)
{
	m_Provider = a_Provider ;
	m_Provider->AddRef () ;

	m_Serv = a_Serv;

	if (m_Serv != NULL)
	{
		m_Serv->AddRef();
	}

	m_ServerWrap = a_ServerWrap;

	if (m_ServerWrap != NULL)
	{
		m_ServerWrap->AddRef();
	}

	if ((m_Serv == NULL) && (m_ServerWrap == NULL))
	{
		m_Serv = m_Provider->GetServer();
	}


	m_NotificationHandler = a_NotificationHandler ;
	m_NotificationHandler->AddRef () ;

	if (a_Ctx)
	{
		m_Ctx = a_Ctx ;
		m_Ctx->AddRef () ;
	}
}

WbemTaskObject :: ~WbemTaskObject ()
{
	if (m_NotificationHandler)
	{
		m_NotificationHandler->Release () ;
	}

	if (m_Ctx)
	{
		m_Ctx->Release () ;
	}

	if (m_ClassName)
	{
		SysFreeString(m_ClassName);
	}

	if ( m_ClassObject )
	{
		m_ClassObject->Release () ;
	}

	if (m_Serv != NULL)
	{
		m_Serv->Release();
	}

	if (m_ServerWrap != NULL)
	{
		m_ServerWrap->Release();
	}

	int isrc = m_SourceArray.GetSize();
	int ins = m_NSpaceArray.GetSize();
	int i = isrc;

	if (isrc > ins)
	{
		i = ins;

		for (int x = ins; x < isrc; x++)
		{
			delete m_SourceArray[x];
		}
	}
	else if (isrc < ins)
	{
		for (int x = isrc; x < ins; x++)
		{
			delete m_NSpaceArray[x];
		}
	}

	for (int x = 0; x < i; x++)
	{
		delete m_SourceArray[x];
		delete m_NSpaceArray[x];
	}

	m_SourceArray.RemoveAll();
	m_NSpaceArray.RemoveAll();

	for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();
	m_ClassToIndexMap.RemoveAll();
	m_EnumerateClasses.RemoveAll();
	
	//this decrements objectsinprogress so MUST be done LAST!!
	if (m_Provider)
		m_Provider->Release ();
}

WbemProvErrorObject &WbemTaskObject :: GetErrorObject ()
{
	return m_ErrorObject ; 
}	

BOOL WbemTaskObject :: SetClass(const wchar_t* a_Class)
{
	m_ClassName = SysAllocString(a_Class);
	BOOL ret = GetClassObject(m_Serv, m_ClassName, &m_ClassObject, &m_ServerWrap);
	return ret;
}

BOOL WbemTaskObject :: GetClassObject ( IWbemServices* pServ, BSTR a_Class, IWbemClassObject** ppClass, CWbemServerWrap **a_pServWrap)
{

	if ((NULL == a_Class) || (NULL == ppClass) ||
		((NULL == pServ) && ((NULL == a_pServWrap) || (NULL == (*a_pServWrap))))
		)
	{
		return FALSE;
	}
	else
	{
		*ppClass = NULL;
	}

	HRESULT t_Result = WBEM_E_FAILED;

	if (*a_pServWrap)
	{
		IWbemServices *ptmpServ = (*a_pServWrap)->GetServerOrProxy();

		if (ptmpServ)
		{
			t_Result = ptmpServ->GetObject(a_Class, 0, m_Ctx, ppClass,	NULL);

			if ( FAILED(t_Result) && (HRESULT_FACILITY(t_Result) != FACILITY_ITF) && (*a_pServWrap)->IsRemote())
			{
				if ( SUCCEEDED(UpdateConnection(a_pServWrap, &ptmpServ)) )
				{
					if (ptmpServ)
					{
						t_Result = ptmpServ->GetObject(a_Class, 0, m_Ctx, ppClass,	NULL);
					}
				}
			}

			if (ptmpServ)
			{
				(*a_pServWrap)->ReturnServerOrProxy(ptmpServ);
			}
		}
	}
	else
	{
		t_Result = pServ->GetObject(a_Class, 0, m_Ctx, ppClass,	NULL);
	}

	if (FAILED(t_Result))
	{
		*ppClass = NULL;
		return FALSE;
	}

	return TRUE;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	IWbemClassObject *t_ErrorObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemProvErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , &t_Variant , 0 ) ;
			VariantClear ( &t_Variant ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = m_ErrorObject.GetStatus () ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSCODE , 0 , &t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_ErrorObject.GetMessage () ) 
					{
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

						t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , &t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;

						if ( ! SUCCEEDED ( t_Result ) )
						{
							(*a_NotifyObject)->Release () ;
							t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
						}
					}
				}
				else
				{
					(*a_NotifyObject)->Release () ;
					t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
			}

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
		}
	}
	else
	{
		t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	BOOL t_Status = TRUE ;
	WbemProvErrorObject t_ErrorStatusObject ;

	if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;
			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;
			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , &t_Variant , 0 ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_ErrorObject.GetMessage () ) 
				{
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;
					t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , &t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( ! SUCCEEDED ( t_Result ) )
					{
						t_Status = FALSE ;
						(*a_NotifyObject)->Release () ;
						(*a_NotifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				(*a_NotifyObject)=NULL ;
				t_Status = FALSE ;
			}

			VariantClear ( &t_Variant ) ;
			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: ParseAndProcessClassQualifiers(WbemProvErrorObject &a_ErrorObject,
													  ParsedObjectPath *a_ParsedObjectPath,
													  CMap<CStringW, LPCWSTR, int, int> *parentMap)
{
	if (m_ClassObject == NULL)
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to get class object representing this class." ) ;
		return FALSE;
	}
	
	IWbemQualifierSet *pQuals = NULL;

	if ( FAILED(m_ClassObject->GetQualifierSet(&pQuals)) )
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to get qualifiers for this class." ) ;
		return FALSE;
	}

	VARIANT v;
	VariantInit(&v);
	BOOL bUnion = FALSE;
	BOOL retVal = TRUE;

	if (SUCCEEDED(pQuals->Get(VIEW_QUAL_PROVIDER, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			m_ProviderName = v.bstrVal;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Provider qualifier is incorrect for this class." ) ;
		}
	}
	else
	{
		retVal = FALSE;
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Provider qualifier should be present for this class." ) ;
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_FILTER, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			CTextLexSource querySource(v.bstrVal);
			SQL1_Parser sqlParser(&querySource);
			
			if (SQL1_Parser::SUCCESS == sqlParser.Parse(&m_RPNPostFilter))
			{
				if (_wcsicmp(m_ClassName, m_RPNPostFilter->bsClassName) == 0)
				{
					if (m_RPNPostFilter->nNumberOfProperties != 0)
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"PostJoinFilter qualifier may not limit the properties returned." ) ;
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"PostJoinFilter qualifier does not match this class." ) ;
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to parse PostJoinFilter qualifier." ) ;
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"PostJoinFilter qualifier should be a single WQL string." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_JOIN, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			retVal = m_JoinOnArray.Set(v.bstrVal);

			if (!retVal)
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to parse JoinOn qualifier." ) ;
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"JoinOn qualifier should be a single string." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_UNION, 0, &v, NULL)) )
	{
		if (v.vt == VT_BOOL)
		{
			bUnion = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Union qualifier should be a boolean." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_ASSOC, 0, &v, NULL)) )
	{
		if (v.vt == VT_BOOL)
		{
			m_bAssoc = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Association qualifier should be a boolean." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_SNGLTN, 0, &v, NULL)) )
	{
		if (v.vt == VT_BOOL)
		{
			m_bSingleton = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Singleton qualifier should be a boolean." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_ENUM_CLASS, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			m_EnumerateClasses.SetAt(v.bstrVal, 0);
		}
		else if (v.vt == (VT_BSTR | VT_ARRAY))
		{
			if (SafeArrayGetDim(v.parray) == 1)
			{
				LONG count = v.parray->rgsabound[0].cElements;
				BSTR HUGEP *pbstr;

				if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
				{
					for (LONG x = 0; x < count; x++)
					{
						m_EnumerateClasses.SetAt(pbstr[x], 0);
					}

					SafeArrayUnaccessData(v.parray);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Failed to access EnumerateClasses array.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"EnumerateClasses array qualifier has incorrect dimensions.");
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
			a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
			a_ErrorObject.SetMessage (L"EnumerateClasses qualifier should be an array of strings.");
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal &&
		((bUnion && !m_bAssoc && !m_JoinOnArray.IsValid()) ||
		(!bUnion && m_bAssoc && !m_JoinOnArray.IsValid()) ||
		(!bUnion && !m_bAssoc && m_JoinOnArray.IsValid())))
	{
		if (m_JoinOnArray.IsValid())
		{
			if (!m_JoinOnArray.ValidateJoin())
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Join validation failed");
			}
		}

		if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_SOURCES, 0, &v, NULL)) )
		{
			if (v.vt == VT_BSTR)
			{
				CSourceQualifierItem* srcItem = new CSourceQualifierItem(v.bstrVal);
				
				if (srcItem->IsValid())
				{
					int indx = m_SourceArray.Add(srcItem);
					m_ClassToIndexMap.SetAt(srcItem->GetClassName(), indx);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Invalid source query.");
					delete srcItem;
				}
			}
			else if (v.vt == (VT_BSTR | VT_ARRAY))
			{
				if (SafeArrayGetDim(v.parray) == 1)
				{
					LONG count = v.parray->rgsabound[0].cElements;
					BSTR HUGEP *pbstr;

					if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
					{
						for (LONG x = 0; x < count; x++)
						{
							CSourceQualifierItem* srcItem = new CSourceQualifierItem(pbstr[x]);
							
							if (srcItem->IsValid())
							{
								int indx = m_SourceArray.Add(srcItem);
								m_ClassToIndexMap.SetAt(srcItem->GetClassName(), indx);
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
								a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
								a_ErrorObject.SetMessage (L"Invalid source query.");
								delete srcItem;
								break;
							}
						}

						SafeArrayUnaccessData(v.parray);
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
						a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
						a_ErrorObject.SetMessage (L"Invalid source array qualifier.");
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Invalid source array qualifier dimensions.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Invalid source array qualifier type.");
			}
		}
		else
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Source array qualifier not found.");
			}
		}

		VariantClear(&v);
		VariantInit(&v);

		if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_NAMESPACES, 0, &v, NULL)) )
		{
			if (v.vt == VT_BSTR)
			{
				CNSpaceQualifierItem* nsItem = new CNSpaceQualifierItem(v.bstrVal);

				if (nsItem->IsValid())
				{
					m_NSpaceArray.Add(nsItem);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Invalid Namespace in namespaces array.");
					delete nsItem;
				}
			}
			else if (v.vt == (VT_BSTR | VT_ARRAY))
			{
				if (SafeArrayGetDim(v.parray) == 1)
				{
					LONG count = v.parray->rgsabound[0].cElements;
					BSTR HUGEP *pbstr;

					if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
					{
						for (LONG x = 0; x < count; x++)
						{
							CNSpaceQualifierItem* nsItem = new CNSpaceQualifierItem(pbstr[x]);

							if (nsItem->IsValid())
							{
								m_NSpaceArray.Add(nsItem);
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
								a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
								a_ErrorObject.SetMessage (L"Invalid Namespace in namespaces array qualifier.");
								delete nsItem;
								break;
							}
						}

						SafeArrayUnaccessData(v.parray);
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
						a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
						a_ErrorObject.SetMessage (L"Failed to access Namespace array qualifier.");
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Namespace array qualifier has invalid dimensions.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Namespace array qualifier has invalid type.");
			}
		}
		else
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Namespace array qualifier not found.");
			}
		}

		VariantClear(&v);

		if (retVal && (m_NSpaceArray.GetSize() != m_SourceArray.GetSize()))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
			a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
			a_ErrorObject.SetMessage (L"Namespace array qualifier does not match source array qualifier size.");
		}

		if (retVal && m_bAssoc && m_SourceArray.GetSize() != 1)
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Association views may only have a single source.");
			}
		}
	}
	else
	{
		if (retVal)
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
			a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
			a_ErrorObject.SetMessage (L"ONE class qualifier out of \"JoinOn\", \"Union\" or \"Association\" MUST be specified.");
		}
	}

	pQuals->Release();

	//connect and get classes!
	if (retVal)
	{
		IWbemClassObject*** arrayOfArrayOfObjs = new IWbemClassObject**[m_NSpaceArray.GetSize()];

		for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
		{
			HRESULT t_hr = WBEM_S_NO_ERROR;

			UINT nsCount = m_NSpaceArray[x]->GetCount();
			CWbemServerWrap** servArray = new CWbemServerWrap*[nsCount];
			IWbemClassObject** classArray = new IWbemClassObject*[nsCount];
			IWbemClassObject* classObj = NULL;
			CStringW* pathArray = m_NSpaceArray[x]->GetNamespacePaths();

			for (UINT i = 0; i < nsCount; i++)
			{
				classArray[i] = NULL;

				if ( FAILED(t_hr =Connect(pathArray[i], &(servArray[i]))) )
				{
					servArray[i] = NULL;
				}
				else if (servArray[i] != NULL)
				{
					if (GetClassObject(NULL, m_SourceArray[x]->GetClassName(), &classArray[i], &servArray[i])
						&& (classObj == NULL))
					{
						classObj = classArray[i];
					}
				}
			}

			if (NULL != classObj)
			{
				m_SourceArray[x]->SetClassObject(classObj);
			}
			
			arrayOfArrayOfObjs[x] = classArray;
			m_NSpaceArray[x]->SetServerPtrs(servArray);
			m_NSpaceArray[x]->SetServerCreationError(t_hr);
		}

		//check properties and keys
		SAFEARRAY* pNames = NULL;
		DWORD dwKeyCount = 0;
		BOOL bKeysOK = TRUE;

		if (retVal && SUCCEEDED(m_ClassObject->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pNames)) )
		{
			if (SafeArrayGetDim(pNames) == 1)
			{
				LONG arraylen = pNames->rgsabound[0].cElements;
				BSTR HUGEP *pbstr;

				if ( SUCCEEDED(SafeArrayAccessData(pNames, (void HUGEP**)&pbstr)) )
				{
					for (LONG i = 0; retVal && (i < arraylen); i++)
					{
						IWbemQualifierSet* pPropQuals = NULL;

						if ( SUCCEEDED(m_ClassObject->GetPropertyQualifierSet(pbstr[i], &pPropQuals)) )
						{
							BOOL bHidden = FALSE;
							BOOL bKey = FALSE;
							CIMTYPE ct = 0;

							if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_HIDDEN, 0, &v, NULL)) )
							{
								if (v.vt == VT_BOOL)
								{
									bHidden = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Hidden qualifier should be boolean.");
								}
							}

							VariantInit(&v);

							if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_KEY, 0, &v, NULL)) )
							{
								if (v.vt == VT_BOOL)
								{
									if (v.boolVal == VARIANT_TRUE)
									{
										bKey = TRUE;
										dwKeyCount++;

										if (bKeysOK && (a_ParsedObjectPath != NULL))
										{
											bKeysOK = IsInObjectPath(a_ParsedObjectPath, pbstr[i]);

											if ((!bKeysOK) && (dwKeyCount > 1))
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_PARAMETER);
												a_ErrorObject.SetWbemStatus (WBEM_E_INVALID_OBJECT_PATH);
												a_ErrorObject.SetMessage (L"Keys of class do not match those  in the object path passed.");
											}
										}
									}
									else
									{
										bKey = FALSE;
									}
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Key qualifier should be boolean.");
								}
							}

							VariantClear(&v);
							CStringW refStr;
							BOOL bDirect = FALSE;

							if ( SUCCEEDED(m_ClassObject->Get(pbstr[i], 0, NULL, &ct, NULL)) )
							{
								if (ct == CIM_REFERENCE)
								{
									VariantInit(&v);

									if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_TYPE, 0, &v, NULL)) )
									{
										if (v.vt == VT_BSTR)
										{
											//bstrVal is either "ref" OR ref:classname
											wchar_t* tmp = v.bstrVal;
											tmp += 4;

											if (*tmp != '\0')
											{
												refStr = tmp;
											}
											
											VARIANT vDirect;
											VariantInit(&vDirect);

											if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_DIRECT, 0, &vDirect, NULL)) )
											{
												if (vDirect.vt == VT_BOOL)
												{
													bDirect = (vDirect.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
												}
												else
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
													a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
													a_ErrorObject.SetMessage (L"Direct qualifier should be boolean");
												}

												VariantClear(&vDirect);
											}
										}
										else
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
											a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
											a_ErrorObject.SetMessage (L"Cimtype qualifier should be a string");
										}

										VariantClear(&v);
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Failed to get the property type from the  class definition");
									}
								}
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
								a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
								a_ErrorObject.SetMessage (L"Failed to get a property type from the  class definition");
							}

							VariantInit(&v);

							if ( retVal && SUCCEEDED(pPropQuals->Get(VIEW_QUAL_PROPERTY, 0, &v, NULL)) )
							{
								CPropertyQualifierItem* propItem = new CPropertyQualifierItem(pbstr[i], bHidden, bKey, ct, refStr, bDirect);

								if (v.vt == VT_BSTR)
								{
									if (1 != m_SourceArray.GetSize())
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Property sources qualifier array size does not match source list.");
									}
									else
									{
										CStringW t_propNameEntry(v.bstrVal);
										t_propNameEntry.TrimLeft();
										t_propNameEntry.TrimRight();

										if (t_propNameEntry.IsEmpty())
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
											a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
											a_ErrorObject.SetMessage (L"Property sources qualifier must name at least one source property.");
										}
										else
										{
											propItem->m_SrcPropertyNames.Add(t_propNameEntry);
										}
									}
								}
								else if (v.vt == (VT_BSTR | VT_ARRAY))
								{
									if (SafeArrayGetDim(v.parray) == 1)
									{
										LONG count = v.parray->rgsabound[0].cElements;
										BSTR HUGEP *pPropbstr;

										if (count != m_SourceArray.GetSize())
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
											a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
											a_ErrorObject.SetMessage (L"Property sources qualifier array size does not match source list.");
										}
										else
										{
											if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pPropbstr)) )
											{
												BOOL bNoName = TRUE;

												for (LONG x = 0; retVal && (x < count); x++)
												{
													if ((pPropbstr[x] != NULL) && (*(pPropbstr[x]) != L'\0'))
													{
														IWbemClassObject* t_srcObj = m_SourceArray[x]->GetClassObject();

														if (t_srcObj != NULL)
														{
															CIMTYPE src_ct;

															if (SUCCEEDED(t_srcObj->Get(pPropbstr[x], 0, NULL, &src_ct, NULL)))
															{
																if (src_ct != ct)
																{
																	retVal = FALSE;
																	a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
																	a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
																	a_ErrorObject.SetMessage (L"Source property type does not match view class.");
																}
															}
															else
															{
																retVal = FALSE;
																a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
																a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
																a_ErrorObject.SetMessage (L"Source property not found in source class.");
															}

															t_srcObj->Release();
														}

													}

													CStringW t_propNameEntry(pPropbstr[x]);
													t_propNameEntry.TrimLeft();
													t_propNameEntry.TrimRight();
													propItem->m_SrcPropertyNames.Add(t_propNameEntry);

													if (bNoName && !t_propNameEntry.IsEmpty())
													{
														bNoName = FALSE;
													}
												}

												if (bNoName)
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
													a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
													a_ErrorObject.SetMessage (L"Property sources qualifier must name at least one source property.");
												}

												SafeArrayUnaccessData(v.parray);
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
												a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
												a_ErrorObject.SetMessage (L"Property sources qualifier array has incorrect dimensions.");
											}
										}
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Failed to access property sources array qualifier.");
									}
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Property sources qualifier has incorrect type.");
								}

								VariantClear(&v);
								m_PropertyMap.SetAt(pbstr[i], propItem);
							}
							else
							{
								if (retVal)
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Failed to get property sources qualifier.");
								}
							}

							pPropQuals->Release();
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
							a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
							a_ErrorObject.SetMessage (L"Failed to access property qualifiers.");
						}
					}

					SafeArrayUnaccessData(pNames);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Could not access class property names array.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Class property names array has invalid dimensions.");
			}

			SafeArrayDestroy(pNames);
		}
		else
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Failed to get class property names.");
			}
		}

		if (retVal)
		{
			if (a_ParsedObjectPath != NULL)
			{
				if (bKeysOK)
				{
					if (dwKeyCount != a_ParsedObjectPath->m_dwNumKeys)
					{
						retVal = FALSE;
					}
				}
				else
				{
					if ((dwKeyCount != 1) || (a_ParsedObjectPath->m_dwNumKeys != 1) || (a_ParsedObjectPath->m_paKeys[0]->m_pName != NULL))
					{
						retVal = FALSE;
					}
				}

				if (!retVal)
				{
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_PARAMETER);
					a_ErrorObject.SetWbemStatus (WBEM_E_INVALID_OBJECT_PATH);
					a_ErrorObject.SetMessage (L"Keys of class do not match those in the object path passed.");
				}
			}
		}

		//final verifications
		//===================

		if (retVal)
		{
			//make sure all enumeration classes exist
			POSITION pos = m_EnumerateClasses.GetStartPosition();

			while (pos)
			{
				int val;
				CStringW tmpStr;
				m_EnumerateClasses.GetNextAssoc(pos, tmpStr, val);

				if (!m_ClassToIndexMap.Lookup(tmpStr, val))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"EnumerateClasses qualifier contains an entry not found in the source list.");
					break;
				}
			}
		}

		if (retVal)
		{
			if (m_EnumerateClasses.GetCount() == m_SourceArray.GetSize())
			{
				//pointless qualifier if all classes mentioned
				m_EnumerateClasses.RemoveAll();
			}

			if (m_JoinOnArray.IsValid())
			{
				if (!ValidateJoin())
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"JoinOn qualifier is semantically invalid.");
				}
			}
#if 0
			else
			{
				//check all union and assoc source keys are view
				//keys this is done in ValidateClassDependencies
				//since both checks need to loop through the arrays
				//of class objects
			}
#endif
		}

		//must delete each sub-array in ValidateClassDependencies
		//as well as release all the ClassObjects!!
		if (retVal)
		{
			if (!ValidateClassDependencies(arrayOfArrayOfObjs, parentMap))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
		
				if (m_JoinOnArray.IsValid())
				{
					a_ErrorObject.SetMessage (L"Loop in provided classes detected.");
				}
				else
				{
					a_ErrorObject.SetMessage (L"Loop in provided classes detected or key mismatch between view and source class.");
				}
			}
		}
		else
		{
			for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
			{
				UINT nsCount = m_NSpaceArray[x]->GetCount();

				for (UINT i = 0; i < nsCount; i++)
				{
					if (arrayOfArrayOfObjs[x][i] != NULL)
					{
						arrayOfArrayOfObjs[x][i]->Release();
					}
				}

				delete [] arrayOfArrayOfObjs[x];
			}
		}

		delete [] arrayOfArrayOfObjs;
	}

	return retVal;
}

//takes an object path to a view class and translates it
//to the object path of the source instance requested and optionally
//returns the object.
BSTR WbemTaskObject::MapFromView(BSTR path, const wchar_t* src, IWbemClassObject** pInst, BOOL bAllprops)
{
	BSTR retVal = NULL;

	if (path == NULL)
	{
		return retVal;
	}

	CObjectPathParser objectPathParser;
	wchar_t* objPath = UnicodeStringDuplicate(path);
	ParsedObjectPath *parsedObjectPath = NULL;

	if (objectPathParser.Parse(objPath, &parsedObjectPath) == 0)
	{
		wchar_t* tmp = parsedObjectPath->GetNamespacePart();
		CWbemServerWrap *pServ = NULL;

		if (tmp != NULL)
		{
			BOOL bServOK = TRUE;

			if (parsedObjectPath->m_pServer != NULL)
			{
				if (wcscmp(parsedObjectPath->m_pServer, L".") != 0)
				{
					bServOK = FALSE;
					VARIANT v;

					if ( SUCCEEDED(m_ClassObject->Get(WBEM_PROPERTY_SERVER, 0, &v, NULL, NULL)))
					{
						if ((v.vt == VT_BSTR) && (_wcsicmp(v.bstrVal, parsedObjectPath->m_pServer) == 0))
						{
							bServOK = TRUE;
						}
					}
					
					VariantClear(&v);
				}
			}

			if (bServOK)
			{
				wchar_t* tmppath = m_Provider->GetNamespacePath()->GetNamespacePath();

				if (tmppath != NULL)
				{
					if (_wcsicmp(tmppath, tmp) == 0)
					{
						Connect(tmppath, &pServ);
					}

					delete [] tmppath;
				}
			}

			delete [] tmp;
		}
		else
		{
			wchar_t* tmppath = m_Provider->GetNamespacePath()->GetNamespacePath();

			if (tmppath != NULL)
			{
				Connect(tmppath, &pServ);
				delete [] tmppath;
			}
		}

		if (pServ != NULL)
		{
			GetObjectTaskObject *t_AsyncEvent = new GetObjectTaskObject (m_Provider, 
														path, 0, m_NotificationHandler, m_Ctx,
														NULL, pServ);
			IWbemClassObject* pInstObj = NULL;

			if (t_AsyncEvent->GetSourceObject(src, &pInstObj, bAllprops) && pInstObj != NULL)
			{
				VARIANT v;

				if (SUCCEEDED(pInstObj->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
				{
					if (v.vt == VT_BSTR)
					{
						retVal = SysAllocString(v.bstrVal);

						if (pInst != NULL)
						{
							pInstObj->AddRef();
							*pInst = pInstObj;
						}
					}
				}

				VariantClear(&v);
				pInstObj->Release();
			}

			t_AsyncEvent->Release();
			pServ->Release();
		}
	}

	delete [] objPath;

	if (parsedObjectPath != NULL)
	{
		delete parsedObjectPath;
	}

	return retVal;
}

//takes an object path to a source and translates it
//to the object path of the view instance requested.
BSTR WbemTaskObject::MapToView(BSTR path, const wchar_t* src, CWbemServerWrap **a_ns)
{
	BSTR retVal = NULL;
	wchar_t* tmppath = m_Provider->GetNamespacePath()->GetNamespacePath();
	CWbemServerWrap *pServ = NULL;

	if (tmppath != NULL)
	{
		Connect(tmppath, &pServ);
		delete [] tmppath;
	}

	if (pServ != NULL)
	{
		BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

		if (queryLBStr == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		BSTR queryBStr = SysAllocStringLen(NULL, 45 + wcslen(src));

		if (queryBStr == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy(queryBStr, META_CLASS_QUERY_START);
		wcscat(queryBStr, src);
		wcscat(queryBStr, END_QUOTE);
		IWbemContext * t_pCtx = m_Ctx;

		if (pServ->IsRemote())
		{
			t_pCtx = NULL; //don't use context for remote calls
		}

		IWbemServices *ptmpServ = pServ->GetServerOrProxy();

		if (ptmpServ)
		{
			IEnumWbemClassObject *t_pEnum = NULL;
			HRESULT t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);

			if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && pServ->IsRemote())
			{
				if ( SUCCEEDED(UpdateConnection(&pServ, &ptmpServ)) )
				{
					if (ptmpServ)
					{
						t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);
					}
				}
			}

			if (ptmpServ)
			{
				pServ->ReturnServerOrProxy(ptmpServ);
			}			

			if (SUCCEEDED(t_hr))
			{
				if (pServ->IsRemote())
				{
					t_hr = SetSecurityLevelAndCloaking(t_pEnum, pServ->GetPrincipal());
				}
				
				if (SUCCEEDED(t_hr))
				{
					//now use the enumerator and see if there is a result...
					ULONG t_count = 0;
					IWbemClassObject* t_pClsObj = NULL;
					BOOL t_bContinueEnum = TRUE;

					//test each class in the derivation chain...
					while (t_bContinueEnum && (S_OK == t_pEnum->Next(WBEM_INFINITE, 1, &t_pClsObj, &t_count)) )
					{
						if (t_pClsObj)
						{
							//get the class name and use the helper object...
							VARIANT vCls;
							VariantInit(&vCls);

							if ( SUCCEEDED(t_pClsObj->Get(WBEM_PROPERTY_CLASS, 0, &vCls, NULL, NULL)) ) 
							{
								if (vCls.vt == VT_BSTR)
								{
									//do this for src and all classes derived from src...
									//====================================================
									HelperTaskObject* validationObj = new HelperTaskObject(m_Provider,
																							vCls.bstrVal,
																							0,
																							m_NotificationHandler,
																							m_Ctx,
																							NULL,
																							NULL,
																							pServ);
									IWbemClassObject* pInst = NULL;

									try
									{
										if (validationObj->GetViewObject(path, &pInst, a_ns))
										{
											VARIANT v;

											if (SUCCEEDED(pInst->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
											{
												if (v.vt == VT_BSTR)
												{
													if (retVal == NULL)
													{
														retVal = SysAllocString(v.bstrVal);
													}
													else
													{
														//make sure they are the
														//same object else fail
														//TO DO: Use the most derived instance
														//too expensive for little gain since
														//traversal will still get correct instance
														//==========================================
														if (!CompareInstPaths(retVal, v.bstrVal))
														{
															SysFreeString(retVal);
															retVal = NULL;
															//ambiguous results, quit!
															t_bContinueEnum = FALSE;
														}

													}
												}
											}

											VariantClear(&v);
											pInst->Release();
										}
									}
									catch (...)
									{
										validationObj->Release();
										VariantClear(&vCls);
										t_pClsObj->Release();
										t_pEnum->Release();
										pServ->Release();
										SysFreeString(queryLBStr);
										SysFreeString(queryBStr);
										throw;
									}

									validationObj->Release();
								}

								VariantClear(&vCls);
							}

							t_pClsObj->Release();
							t_pClsObj = NULL;
						}

						t_count = 0;
					}
				}

				t_pEnum->Release();
			}
		}

		SysFreeString(queryLBStr);
		SysFreeString(queryBStr);

		if (pServ)
		{
			pServ->Release();
		}
	}

	return retVal;
}


//takes a reference and maps to the "real world" or to a view
//------------------------------------------------------------
BOOL WbemTaskObject::TransposeReference(CPropertyQualifierItem* pItm,
										VARIANT vSrc, VARIANT* pvDst,
										BOOL bMapToView, CWbemServerWrap **a_ns)
{
//make sure reference normalisation/non-normalisation is OK.
//Done the best I can.....
//==========================================================
	if (pvDst != NULL)
	{
		VariantInit(pvDst);
	}
	else
	{
		return FALSE;
	}

	if (vSrc.vt != VT_BSTR)
	{
		return FALSE;
	}

	BOOL retVal = FALSE;

	//associations are the only classes that this
	//method gets called for, therefore, only a
	//single source class to interrogate!
	//=============================================
	IWbemClassObject* pCls = m_SourceArray[0]->GetClassObject();

	if (pCls != NULL)
	{
		CIMTYPE ct;
		//associations are the only classes that this
		//method gets called for, therefore, only a
		//single source class to interrogate!
		//=============================================
		BSTR strClass = pItm->m_SrcPropertyNames[0].AllocSysString();

		if ( SUCCEEDED(pCls->Get(strClass, 0, NULL, &ct, NULL)) )
		{
			if (ct == CIM_REFERENCE)
			{
				IWbemQualifierSet* pQuals = NULL;

				if ( SUCCEEDED(pCls->GetPropertyQualifierSet(strClass, &pQuals)) )
				{
					VARIANT v;

					if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_TYPE, 0, &v, NULL)) )
					{
						if (v.vt == VT_BSTR)
						{
							//bstrVal is either "ref" OR ref:classname
							wchar_t* tmp = v.bstrVal;
							tmp += 4;

							if (*tmp != '\0')
							{
								if (!pItm->GetReferenceClass().IsEmpty())
								{
									if (pItm->IsDirect())
									{
										if (FAILED(VariantCopy(pvDst, &vSrc)))
                                        {
                                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                                        }
										retVal = TRUE;
									}
									else
									{
										if (bMapToView)
										{
											BSTR refStr = MapToView(vSrc.bstrVal, pItm->GetReferenceClass(), a_ns);

											if (refStr != NULL)
											{
												pvDst->vt = VT_BSTR;
												pvDst->bstrVal = refStr;
												retVal = TRUE;
											}
										}
										else
										{
											//map reference back to source class
											BSTR refStr = MapFromView(vSrc.bstrVal, tmp);

											if (refStr != NULL)
											{
												pvDst->vt = VT_BSTR;
												pvDst->bstrVal = refStr;
												retVal = TRUE;
											}
										}
									}
								}
							}
							else
							{
								if (pItm->GetReferenceClass().IsEmpty())
								{
									if (FAILED(VariantCopy(pvDst, &vSrc)))
                                    {
                                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                                    }
									retVal = TRUE;
								}
							}
						}

						VariantClear(&v);
					}

					pQuals->Release();
				}

			}
		}

		SysFreeString(strClass);
		pCls->Release();
	}

	return retVal;
}

//Must release all ClassObjects and free all sub-arrays
//=====================================================
BOOL WbemTaskObject::ValidateClassDependencies(IWbemClassObject*** arrayofArrayOfObjs, CMap<CStringW, LPCWSTR, int, int>* parentMap)
{
	CMap<CStringW, LPCWSTR, int, int> namespaceClassMap;
	
	if (parentMap != NULL)
	{
		POSITION pos = parentMap->GetStartPosition();

		while (pos)
		{
			CStringW tmpStr;
			int tmpInt;
			parentMap->GetNextAssoc(pos, tmpStr, tmpInt);
			namespaceClassMap.SetAt(tmpStr, tmpInt);
		}
	}

	BOOL retVal = TRUE;
	VARIANT v;
	VariantInit(&v);
	
	if (SUCCEEDED(m_ClassObject->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
	{
		if (v.vt != VT_BSTR)
		{
			retVal = FALSE;
		}
		else
		{
			int dummyInt;

			if (namespaceClassMap.Lookup(v.bstrVal, dummyInt))
			{
				retVal = FALSE;
			}
			else
			{
				namespaceClassMap.SetAt(v.bstrVal, 0);
			}
		}
	}
	else
	{
		retVal = FALSE;
	}

	VariantClear(&v);

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		UINT nsCount = m_NSpaceArray[x]->GetCount();

		for (UINT i = 0; i < nsCount; i++)
		{
			if (arrayofArrayOfObjs[x][i] != NULL)
			{
				IWbemQualifierSet* pQuals = NULL;

				if (retVal && SUCCEEDED(arrayofArrayOfObjs[x][i]->GetQualifierSet(&pQuals)) )
				{
					VariantInit(&v);

					if (SUCCEEDED(pQuals->Get(VIEW_QUAL_PROVIDER, 0, &v, NULL)) )
					{
						if (v.vt == VT_BSTR)
						{
							if (m_ProviderName.CompareNoCase(v.bstrVal) == 0)
							{
								VariantClear(&v);
								VariantInit(&v);

								if ( SUCCEEDED(arrayofArrayOfObjs[x][i]->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
								{
									if (v.vt == VT_BSTR)
									{
										HelperTaskObject* validationObj = new HelperTaskObject(m_Provider, 
											v.bstrVal, 0, m_NotificationHandler, m_Ctx,
											NULL,
											m_NSpaceArray[x]->GetServerPtrs()[i]->GetPrincipal(),
											m_NSpaceArray[x]->GetServerPtrs()[i]);

										try
										{
											retVal = validationObj->Validate(&namespaceClassMap);
										}
										catch (...)
										{
											validationObj->Release();
											throw;
										}

										validationObj->Release();
									}
									else
									{
										retVal = FALSE;
									}
								}
								else
								{
									retVal = FALSE;
								}

								VariantClear(&v);
							}
						}
						else
						{
							retVal = FALSE;
						}
					}

					VariantClear(&v);
					pQuals->Release();
				}
				else
				{
					retVal = FALSE;
				}
				
				//Check union, assoc key properties here
				SAFEARRAY* pNames = NULL;

				if (retVal && !m_JoinOnArray.IsValid())
				{
					if ( SUCCEEDED(arrayofArrayOfObjs[x][i]->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pNames)) )
					{
						if (SafeArrayGetDim(pNames) == 1)
						{
							LONG arraylen = pNames->rgsabound[0].cElements;
							BSTR HUGEP *pbstr;

							if ( SUCCEEDED(SafeArrayAccessData(pNames, (void HUGEP**)&pbstr)) )
							{
								for (LONG i = 0; retVal && (i < arraylen); i++)
								{
									//find pbstr[i] as a key in the view class
									//as the xth property name ('cos we're checking the
									//xth source class) in the property arrays
									//of m_PropertyMap...
									retVal = FALSE;
									POSITION pos = m_PropertyMap.GetStartPosition();
									
									while (pos)
									{
										CPropertyQualifierItem* pItm;
										CStringW itmName;
										m_PropertyMap.GetNextAssoc(pos, itmName, pItm);
									
										if (pItm->IsKey() && (_wcsicmp(pbstr[i], pItm->m_SrcPropertyNames[x]) == 0) )
										{
											retVal = TRUE;
											break;
										}
									}
								}

								SafeArrayUnaccessData(pNames);
							}
							else
							{
								retVal = FALSE;
							}
						}
						else
						{
							retVal = FALSE;
						}

						SafeArrayDestroy(pNames);
					}
					else
					{
						retVal = FALSE;
					}
				}

				arrayofArrayOfObjs[x][i]->Release();
			}
		}

		delete [] arrayofArrayOfObjs[x];
	}

	namespaceClassMap.RemoveAll();
	return retVal;
}

LONG WbemTaskObject::AddRef()
{
    return InterlockedIncrement(&m_Ref);
}

LONG WbemTaskObject::Release()
{
	LONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_Ref)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

HRESULT WbemTaskObject :: UpdateConnection(CWbemServerWrap **a_pServ, IWbemServices **a_proxy)
{
	HRESULT retVal = WBEM_NO_ERROR;

#ifdef UNICODE
	if ((*a_pServ)->IsRemote())
	{
		if ((*a_pServ)->ProxyBelongsTo(*a_proxy))
		{
			retVal = Connect((*a_pServ)->GetPath(), a_pServ, TRUE);
		}

		(*a_proxy)->Release();

		if ( SUCCEEDED(retVal) && (*a_pServ) )
		{
			*a_proxy = (*a_pServ)->GetServerOrProxy();
		}
		else
		{
			*a_proxy = NULL;
		}
	}
#endif

	return retVal;
}

HRESULT WbemTaskObject :: Connect(const wchar_t* path, CWbemServerWrap** ppServ, BOOL a_bUpdate)
{
//this function must lock the critsec and unlock it in a balnaced way
//and must also not be locked when calling back into CIMOM...

	if (ppServ == NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		if (!a_bUpdate)
		{
			*ppServ = NULL;
		}
	}

	if ((m_Provider->sm_ConnectionMade == NULL) || !m_Provider->sm_ServerMap.Lock())
	{
		return WBEM_E_UNEXPECTED;
	}

	//possibility of deadlock if ObjectsInProgress == 0 at this point!
	//therefore Connect should never be called by an object which hasn't
	//previously incremented ObjectsInProgress!!!

	BOOL bFound = FALSE;

	if (!a_bUpdate && !m_Provider->sm_ServerMap.IsEmpty() && 
			m_Provider->sm_ServerMap.Lookup(path, *ppServ) )
	{
		(*ppServ)->AddRef();
		bFound = TRUE;
	}

	HRESULT hr = WBEM_NO_ERROR;

	if (!bFound)
	{
		//check the map of outstanding connections...
		int dummyInt = 0;

		if (!m_Provider->sm_OutStandingConnections.IsEmpty() && 
			m_Provider->sm_OutStandingConnections.Lookup(path, dummyInt) ) 
		{
			bFound = TRUE;
		}
		else
		{
			m_Provider->sm_OutStandingConnections[path] = 0;
		}

		m_Provider->sm_ServerMap.Unlock();
		BOOL t_bWait = TRUE;

		while (bFound && t_bWait)
		{
			DWORD dwWait = WbemWaitForSingleObject(m_Provider->sm_ConnectionMade, VP_CONNECTION_TIMEOUT);

			if (dwWait ==  WAIT_OBJECT_0)
			{
				if (m_Provider->sm_ServerMap.Lock())
				{
					if (!m_Provider->sm_OutStandingConnections.IsEmpty() && 
						m_Provider->sm_OutStandingConnections.Lookup(path, dummyInt) )
					{
						ResetEvent(m_Provider->sm_ConnectionMade);
					}
					else
					{
						//no longer outstanding!
						t_bWait = FALSE;;
					}

					m_Provider->sm_ServerMap.Unlock();
				}
				else
				{
					//error
					hr = WBEM_E_FAILED;
					bFound = FALSE;
				}
			}
			else
			{
				//error
				hr = WBEM_E_FAILED;
				bFound = FALSE;
			}
		}

		if (SUCCEEDED (hr))
		{
			if (bFound)
			{
				if (a_bUpdate)
				{
					//another thread did the update on this clear this pointer
					//chances is are it is the same one and use the one in the map
					(*ppServ)->Release();
					*ppServ = NULL;
				}

				if (m_Provider->sm_ServerMap.Lock())
				{
					if ( !m_Provider->sm_ServerMap.IsEmpty() && 
							m_Provider->sm_ServerMap.Lookup(path, *ppServ) )
					{
						(*ppServ)->AddRef();
					}
					else
					{
						//it just failed in another thread 
						//don't try it again this time....
						hr = WBEM_E_FAILED;
					}

					m_Provider->sm_ServerMap.Unlock();
				}
				else
				{
					hr = WBEM_E_FAILED;
				}
			}
			else
			{
				BSTR bstrPath = SysAllocString(path);

				//calling back into winmgmt cannot have a lock...
				hr = DoConnectServer(bstrPath, ppServ, a_bUpdate);
				SysFreeString(bstrPath);

				if (FAILED(hr))
				{
					if (a_bUpdate)
					{
						//we failed to update, remove the item from the map
						if (m_Provider->sm_ServerMap.Lock())
						{
							m_Provider->sm_ServerMap.RemoveKey(path);
							m_Provider->sm_ServerMap.Unlock();
						}

						(*ppServ)->Release();
					}

					*ppServ = NULL;
				}
				else
				{
					if (m_Provider->sm_ServerMap.Lock())
					{
						if (!a_bUpdate)
						{
							(*ppServ)->AddRef();
							m_Provider->sm_ServerMap[path] = *ppServ;
						}
						else
						{
							//has the object been removed in another thread
							CWbemServerWrap *t_pSrvInMap = NULL;

							if (m_Provider->sm_ServerMap.IsEmpty() || 
								!m_Provider->sm_ServerMap.Lookup(path, t_pSrvInMap))
							{
								(*ppServ)->AddRef();
								m_Provider->sm_ServerMap[path] = *ppServ;
							}
						}

						m_Provider->sm_ServerMap.Unlock();
					}
					else
					{
						(*ppServ)->Release();
						*ppServ = NULL;
						hr = WBEM_E_FAILED;
					}
				}

				if (m_Provider->sm_ServerMap.Lock())
				{
					m_Provider->sm_OutStandingConnections.RemoveKey(path);
					SetEvent(m_Provider->sm_ConnectionMade);
					m_Provider->sm_ServerMap.Unlock();
				}
			}
		}
		else
		{
			if (a_bUpdate)
			{
				//we failed to update, remove the item from the map
				if (m_Provider->sm_ServerMap.Lock())
				{
					m_Provider->sm_ServerMap.RemoveKey(path);
					m_Provider->sm_ServerMap.Unlock();
				}

				(*ppServ)->Release();
				*ppServ = NULL;
			}
		}
	}
	else
	{
		m_Provider->sm_ServerMap.Unlock();
	}

	return hr;
}

//Remote connections for NT4+ only,
//Delegation connections for NT5 only.
HRESULT WbemTaskObject :: DoConnectServer (BSTR bstrPath, CWbemServerWrap **a_ppServ, BOOL a_bUpdate)
{
    WCHAR wszMachine[MAX_PATH];
	wszMachine[0] = L'\0';

    // Determine if it is local
	if (bstrPath != NULL)
	{
		if ( (wcslen(bstrPath) > 4) && (bstrPath[0] == L'\\') && (bstrPath[1] == L'\\') )
		{
			WCHAR *t_ServerMachine = &bstrPath[2];

			while (*t_ServerMachine)
			{
				if ( L'\\' == *t_ServerMachine )
				{
					break ;
				}

				t_ServerMachine++;
			}

			if ((*t_ServerMachine != L'\\') || (t_ServerMachine == &bstrPath[2]))
			{
				return WBEM_E_FAILED;
			}

			*t_ServerMachine = L'\0';
			wcscpy(wszMachine, &bstrPath[2]);
			*t_ServerMachine = L'\\';
		}
	}

	BOOL t_Local = bAreWeLocal ( wszMachine ) ;
	IWbemServices* pServ = NULL;
	HRESULT retVal = WBEM_NO_ERROR;
	wchar_t *prncpl = NULL;

	if (!t_Local)
	{
		//Are we on NT5?
		DWORD dwVersion = GetVersion();

		if (dwVersion < 0x80000000)
		{
#ifdef UNICODE
			// we are on Windows 2000+
			if ( 5 <= (DWORD)(LOBYTE(LOWORD(dwVersion))) )
			{
				if (a_bUpdate)
				{
						prncpl = new wchar_t[wcslen((*a_ppServ)->GetPrincipal()) + 1];
						wcscpy(prncpl, (*a_ppServ)->GetPrincipal());
				}
				else
				{
					// set up the security structures for a remote connection
					// Setup the authentication structures
					HINSTANCE t_LibraryInstance = LoadLibrary ( CONST_NETAPI_LIBRARY ) ;

					if ( t_LibraryInstance ) 
					{
						NETAPI_PROC_DsGetDcName t_DsGetDcNameW = ( NETAPI_PROC_DsGetDcName ) GetProcAddress ( t_LibraryInstance , CONST_NETAPI_DSPROC ) ;
						NETAPI_PROC_NetApiBufferFree t_NetApiBufferFree = ( NETAPI_PROC_NetApiBufferFree ) GetProcAddress ( t_LibraryInstance , CONST_NETAPI_NETPROC ) ;

						if ( t_DsGetDcNameW && t_NetApiBufferFree ) 
						{
							//get the principal name
							PDOMAIN_CONTROLLER_INFO pDomInfo = NULL;
							DWORD dwRet = t_DsGetDcNameW ((const wchar_t*)wszMachine, NULL, NULL, NULL, 0, &pDomInfo);

							if (dwRet == NO_ERROR)
							{
								if (pDomInfo->DomainName != NULL)
								{
									prncpl = new wchar_t[wcslen(pDomInfo->DomainName) + wcslen(wszMachine) + 2];
									wcscpy(prncpl, pDomInfo->DomainName);
									wcscat(prncpl, L"\\");
									wcscat(prncpl, wszMachine);
								}

								t_NetApiBufferFree ((void*)pDomInfo);
							}
						}

						FreeLibrary ( t_LibraryInstance ) ;
					}
				}

				//just try the machine name for the principal
				if (prncpl == NULL)
				{
					prncpl = new wchar_t[wcslen(wszMachine) + 1];
					wcscpy(prncpl, wszMachine);
				}

				if (prncpl != NULL)
				{
					COAUTHIDENTITY authident;
					memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
					authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

					COSERVERINFO si;
					si.pwszName = wszMachine;
					si.dwReserved1 = 0;
					si.dwReserved2 = 0;
					si.pAuthInfo = NULL;

					COAUTHINFO ai;
					si.pAuthInfo = &ai;

					ai.pwszServerPrincName = prncpl;
					ai.pAuthIdentityData = NULL;

					retVal = GetCurrentSecuritySettings(&ai.dwAuthnSvc, &ai.dwAuthzSvc,
														&ai.dwAuthnLevel, &ai.dwImpersonationLevel,
														&ai.dwCapabilities);


					if(ai.dwImpersonationLevel >= RPC_C_IMP_LEVEL_DELEGATE)
						ai.dwAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;

					if (SUCCEEDED(retVal))
					{
						retVal = CoCreateForConnectServer(bstrPath, &si, &authident, &pServ);
					}
				}
				else
				{
					retVal = WBEM_E_FAILED;
				}
			}
			else
#endif //UNICODE
			{
				retVal = WBEM_E_FAILED;
			}
		}
		else
		{
			retVal = WBEM_E_FAILED;
		}
	}
	else
	{
		retVal = LocalConnectServer(bstrPath, &pServ);
	}

	if (SUCCEEDED(retVal) && pServ != NULL)
	{
		if (!a_bUpdate)
		{
			*a_ppServ = new CWbemServerWrap(pServ, prncpl, bstrPath);
			(*a_ppServ)->AddRef();
		}
		else
		{
			(*a_ppServ)->SetMainServer(pServ);
		}

		pServ->Release();
	}
	else
	{
		if (!a_bUpdate)
		{
			*a_ppServ = NULL;
		}
	}

	if (prncpl != NULL)
	{
		delete [] prncpl;
	}

    return retVal;
}

#ifdef UNICODE
HRESULT WbemTaskObject :: CoCreateForConnectServer(BSTR bstrPath, COSERVERINFO* psi, COAUTHIDENTITY* pauthid, IWbemServices** ppServ)
{
	MULTI_QI   mqi;
	mqi.pIID = &IID_IWbemLevel1Login;
	mqi.pItf = 0;
	mqi.hr = 0;

	//delegation doesn't really work with CoCreateInstance....
	DWORD dwImp = psi->pAuthInfo->dwImpersonationLevel;

	if (dwImp > RPC_C_IMP_LEVEL_IMPERSONATE)
	{
		psi->pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	}


	HRESULT retVal = CoCreateInstanceEx (

		CLSID_WbemLevel1Login,
		NULL,
		CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
		psi ,
		1,
		&mqi
	);

	psi->pAuthInfo->dwImpersonationLevel = dwImp;

	if ( retVal == S_OK )
	{
		IWbemLevel1Login* t_pLevel1 = (IWbemLevel1Login*) mqi.pItf ;

		// If remote, do the security negotiation

		if (psi)
		{
			retVal = SetSecurityLevelAndCloaking(t_pLevel1, psi->pAuthInfo->pwszServerPrincName);
		}
		
		if(retVal == S_OK)
		{
			//use null context for remote cimoms...
			retVal = t_pLevel1->NTLMLogin(bstrPath, 0, 0, 0, ppServ); 

			if(retVal == S_OK)
			{
				if (psi)
				{
					retVal = SetSecurityLevelAndCloaking(*ppServ, psi->pAuthInfo->pwszServerPrincName);

					if (retVal != S_OK)
					{
						(*ppServ)->Release();
						(*ppServ) = NULL;
					}
				}
			}
		}

		t_pLevel1->Release();
	}
	else
	{
		retVal = WBEM_E_FAILED;
	}

	return retVal;
}
#endif //UNICODE

HRESULT WbemTaskObject :: LocalConnectServer(BSTR bstrPath, IWbemServices** ppServ)
{
	IWbemLocator *pLoc = NULL;

	HRESULT retVal = m_Provider->GetLocator(&pLoc);

	if (SUCCEEDED (retVal))
	{
#ifdef UNICODE
		retVal = pLoc->ConnectServer(bstrPath, NULL, NULL, NULL, 0, NULL, m_Ctx, ppServ);
#else
		retVal = pLoc->ConnectServer(bstrPath, m_Provider->GetUserName(), NULL, NULL, 0, NULL, m_Ctx, ppServ);
#endif
		pLoc->Release();
	}

	if (SUCCEEDED(retVal))
	{
		retVal = SetSecurityLevelAndCloaking(*ppServ, COLE_DEFAULT_PRINCIPAL);

		if (FAILED(retVal))
		{
			(*ppServ)->Release();
			*ppServ = NULL;
		}
	}

	return retVal;
}

void WbemTaskObject::SetResultReceived()
{
	if (m_ArrayLock.Lock())
	{
		m_ResultReceived = TRUE;
		m_ArrayLock.Unlock();
	}
}

void WbemTaskObject::SetStatus(HRESULT hr, DWORD index)
{
	if (m_ArrayLock.Lock())
	{
		m_ResultReceived = TRUE;
		m_iQueriesAnswered++;
		
		if (m_iQueriesAsked == m_iQueriesAnswered)
		{
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}
}

void WbemTaskObject::CleanUpObjSinks(BOOL a_bDisconnect)
{
	for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			if (a_bDisconnect)
			{
				m_ObjSinkArray[x]->Disconnect();
			}

			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();
}

DWORD WbemTaskObject::GetIndexList(const wchar_t* a_src, DWORD** a_pdwArray)
{
	if (NULL == a_pdwArray)
	{
		return 0;
	}

	DWORD retVal = 0;
	
	for (DWORD i = 0; i < m_SourceArray.GetSize(); i++)
	{
		BOOL t_bAdd = FALSE;
		
		if (_wcsicmp(m_SourceArray[i]->GetClassName(), a_src) == 0)
		{
			//try classname match...
			//=======================
			t_bAdd = TRUE;
		}
		else
		{
			//try parentclass match...
			//========================
			IWbemClassObject *t_pCls = m_SourceArray[i]->GetClassObject();

			if (t_pCls)
			{
				VARIANT v;
				VariantInit(&v);
			
				if ( SUCCEEDED(t_pCls->Get(WBEM_PROPERTY_DERIVATION, 0, &v, NULL, NULL)) )
				{
					if (v.vt == VT_BSTR)
					{
						if (_wcsicmp(v.bstrVal, a_src) == 0)
						{
							t_bAdd = TRUE;
						}
					}
					else if (v.vt == (VT_ARRAY | VT_BSTR))
					{
						if (SafeArrayGetDim(v.parray) == 1)
						{
							LONG count = v.parray->rgsabound[0].cElements;
							BSTR HUGEP *pbstr;

							if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
							{
								for (LONG x = 0; x < count; x++)
								{
									if (_wcsicmp(pbstr[x], a_src) == 0)
									{
										t_bAdd = TRUE;
										break;
									}
								}

								SafeArrayUnaccessData(v.parray);
							}
						}
					}

					VariantClear(&v);
				}
				
				t_pCls->Release();
			}
		}

		if (!t_bAdd)
		{
			//try derived class match...i.e. execute the query...
			//select * from meta_class where __this isa "classname" AND __class = "a_src"
			//======================================================================================
			CWbemServerWrap** nsPtrs = m_NSpaceArray[i]->GetServerPtrs();

			for (DWORD j = 0; j < m_NSpaceArray[i]->GetCount(); j++)
			{
				if (nsPtrs[j] != NULL)
				{
					BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

					if (queryLBStr == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}

					BSTR queryBStr = SysAllocStringLen(NULL, 61 + wcslen(m_SourceArray[i]->GetClassName()) + wcslen(a_src));

					if (queryBStr == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}

					wcscpy(queryBStr, META_CLASS_QUERY_START);
					wcscat(queryBStr, m_SourceArray[i]->GetClassName());
					wcscat(queryBStr, META_CLASS_QUERY_MID);
					wcscat(queryBStr, a_src);
					wcscat(queryBStr, END_QUOTE);
					IWbemContext * t_pCtx = m_Ctx;

					if (nsPtrs[j]->IsRemote())
					{
						t_pCtx = NULL; //don't use context for remote calls
					}

					IWbemServices *ptmpServ = nsPtrs[j]->GetServerOrProxy();

					if (ptmpServ)
					{
						IEnumWbemClassObject *t_pEnum = NULL;
						HRESULT t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);

						if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[j]->IsRemote())
						{
							if ( SUCCEEDED(UpdateConnection(&(nsPtrs[j]), &ptmpServ)) )
							{
								if (ptmpServ)
								{
									t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);
								}
							}
						}

						if (ptmpServ)
						{
							nsPtrs[j]->ReturnServerOrProxy(ptmpServ);
						}			

						if (SUCCEEDED(t_hr))
						{
							if (nsPtrs[j]->IsRemote())
							{
								t_hr = SetSecurityLevelAndCloaking(t_pEnum, nsPtrs[j]->GetPrincipal());
							}
							
							if (SUCCEEDED(t_hr))
							{
								//now use the enumerator and see if there is a result...
								IWbemClassObject* t_pClsObj = NULL;
								ULONG t_count = 0;

								//test that a class was returned...
								if ( S_OK == t_pEnum->Next(WBEM_INFINITE, 1, &t_pClsObj, &t_count) )
								{
									if (t_pClsObj)
									{
										t_bAdd = TRUE;
										t_pClsObj->Release();
									}
								}
							}

							t_pEnum->Release();
						}
					}
					
					//only check one namespace, class defns should match
					break;
				}
				else
				{
				}
			}
		}

		if (t_bAdd)
		{
			if (*a_pdwArray == NULL)
			{
				*a_pdwArray = new DWORD[m_SourceArray.GetSize() - i];
			}

			(*a_pdwArray)[retVal] = i;
			retVal++;
		}
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vptasksh.cpp ===
//***************************************************************************

//

//  VPTASKSH.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the helper taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern HRESULT SetSecurityLevelAndCloaking(IUnknown* pInterface, const wchar_t* prncpl);
extern BOOL bAreWeLocal(WCHAR* pServerMachine);


HelperTaskObject::HelperTaskObject(CViewProvServ *a_Provider, 
	const wchar_t *a_ObjectPath, ULONG a_Flag, IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *pCtx, IWbemServices* a_Serv, const wchar_t* prncpl,
	CWbemServerWrap* a_ServWrap)
: WbemTaskObject (a_Provider, a_NotificationHandler, a_Flag, pCtx, a_Serv, a_ServWrap),
	m_ObjectPath(NULL),
	m_ParsedObjectPath(NULL),
	m_principal(NULL)
{
	if (prncpl)
	{
		m_principal = UnicodeStringDuplicate(prncpl);
	}

	m_ObjectPath = UnicodeStringDuplicate(a_ObjectPath);
}

HelperTaskObject::~HelperTaskObject ()
{
	if (m_ObjectPath != NULL)
	{
		delete [] m_ObjectPath;
	}

	if (NULL != m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath;
	}

	if (m_principal)
	{
		delete [] m_principal;
	}
}

BOOL HelperTaskObject::Validate(CMap<CStringW, LPCWSTR, int, int>* parentMap)
{
	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, NULL, parentMap);
		}
	}

	return t_Status;
}

//Get the view object given the namespace and object path of the source and the namespace
BOOL HelperTaskObject::DoQuery(ParsedObjectPath* parsedObjectPath, IWbemClassObject** pInst, int indx)
{
	if (pInst == NULL)
	{
		return FALSE;
	}
	else
	{
		*pInst = NULL;
	}

	BOOL retVal = TRUE;

	//Create the query string
	SQL_LEVEL_1_RPN_EXPRESSION tmpRPN;
	tmpRPN.bsClassName = SysAllocString(m_ClassName);

	//need enough tokens to handle association work-around serverpath or dotpath or relpath
	SQL_LEVEL_1_TOKEN* tokArray = new SQL_LEVEL_1_TOKEN[(parsedObjectPath->m_dwNumKeys) * 6];

	DWORD dwToks = 0;

	for (int i = 0; retVal && (i < parsedObjectPath->m_dwNumKeys); i++)
	{	
		POSITION pos = m_PropertyMap.GetStartPosition();

		while (retVal && pos)
		{
			CStringW key;
			CPropertyQualifierItem* propItem;
			m_PropertyMap.GetNextAssoc(pos, key, propItem);

			if (!propItem->m_SrcPropertyNames[indx].IsEmpty())
			{
				if (propItem->m_SrcPropertyNames[indx].CompareNoCase(parsedObjectPath->m_paKeys[i]->m_pName) == 0)
				{
					tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
					tokArray[dwToks].nOperator = SQL_LEVEL_1_TOKEN::OP_EQUAL;
					tokArray[dwToks].pPropertyName = propItem->GetViewPropertyName().AllocSysString();
					
					if (m_bAssoc && (propItem->GetCimType() == CIM_REFERENCE))
					{
						retVal = TransposeReference(propItem, parsedObjectPath->m_paKeys[i]->m_vValue,
														&(tokArray[dwToks].vConstValue), TRUE, &m_ServerWrap);

						if (retVal)
						{
							//add the extra tokens if neccessary
							//for the association work-around
							wchar_t *t_pChar = tokArray[dwToks].vConstValue.bstrVal;

							//must be \\server\namespace and not \\.\namespace or relpath
							if ( (*t_pChar == L'\\') && (*(t_pChar+1) == L'\\') && (*(t_pChar+2) != L'.') )
							{
								//add the dotted version
								tokArray[dwToks + 1] = tokArray[dwToks++];
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 2;
								
								while (*t_pChar != L'\\')
								{
									t_pChar++;
								}

								--t_pChar;
								*t_pChar = L'.';
								--t_pChar;
								*t_pChar = L'\\';
								--t_pChar;
								*t_pChar = L'\\';
								BSTR t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;

								//add the relpath version
								tokArray[dwToks + 1] = tokArray[dwToks - 1];
								dwToks++;
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 4;
								
								while (*t_pChar != L':')
								{
									t_pChar++;
								}

								//exclude the ':'
								t_pChar++;
								t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
							}
						}
					}
					else
					{
						VariantInit(&(tokArray[dwToks].vConstValue));

                        if (FAILED(VariantCopy(&(tokArray[dwToks].vConstValue),
								&(parsedObjectPath->m_paKeys[i]->m_vValue))))
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
					}

					//after every key add an AND
					//except if this is the first key since there is no where clause
					dwToks++;

					if (i != 0)
					{
						tokArray[dwToks++].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;				
					}
				}
			}
		}
	}

	BSTR queryStr = NULL;

	if ( retVal && ((dwToks > 0) || (parsedObjectPath->m_dwNumKeys == 0)) )
	{
		CStringW qStr = GetStringFromRPN(&tmpRPN, dwToks, tokArray);
		queryStr = qStr.AllocSysString();
	}

	retVal = FALSE;

	if (queryStr != NULL)
	{
		//ExecQuery and test the results
		IEnumWbemClassObject *pEnum = NULL;
		HRESULT t_hr = WBEM_E_FAILED;
		BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

		if (m_ServerWrap)
		{
			IWbemContext * t_pCtx = m_Ctx;

			if (m_principal != NULL)
			{
				t_pCtx = NULL; //don't use context for remote calls
			}

			IWbemServices *ptmpServ = m_ServerWrap->GetServerOrProxy();

			if (ptmpServ)
			{
				t_hr = ptmpServ->ExecQuery(queryLBStr, queryStr, 0, t_pCtx, &pEnum);
			}

			if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && m_ServerWrap->IsRemote())
			{
				if ( SUCCEEDED(UpdateConnection(&m_ServerWrap, &ptmpServ)) )
				{
					if (ptmpServ)
					{
						t_hr = ptmpServ->ExecQuery(queryLBStr, queryStr, 0, t_pCtx, &pEnum);
					}
				}
			}

			if (ptmpServ)
			{
				m_ServerWrap->ReturnServerOrProxy(ptmpServ);
			}
		}

		if (SUCCEEDED(t_hr))
		{
			//set cloaking if remote
			//============================
			if ((m_principal == NULL) || ((m_principal != NULL) &&
				(S_OK == SetSecurityLevelAndCloaking(pEnum, m_principal))) )
			{
				if ( (m_principal != NULL) ||
					((m_principal == NULL) && SUCCEEDED(SetSecurityLevelAndCloaking(pEnum, COLE_DEFAULT_PRINCIPAL))) )
				{
					ULONG uCount = 0;
					IWbemClassObject* pObjs[2];
					pObjs[0] = NULL;
					pObjs[1] = NULL;

					//must be exactly one result...
					if ( SUCCEEDED(pEnum->Next(WBEM_INFINITE, 2, pObjs, &uCount)) )
					{
						//There should only be one result
						if (uCount == 1)
						{
							if (pObjs[0] != NULL)
							{
								*pInst = pObjs[0];
								retVal = TRUE;
							}
							else
							{
								if (pObjs[1] != NULL)
								{
									(pObjs[1])->Release();
								}
							}
						}
						else
						{
							if (pObjs[1] != NULL)
							{
								pObjs[1]->Release();

								if (pObjs[0] != NULL)
								{
									pObjs[0]->Release();
								}
							}
						}
					}
				}
			}

			pEnum->Release();
		}

		SysFreeString(queryLBStr);
	}

	delete [] tokArray;

	if (queryStr != NULL)
	{
		SysFreeString(queryStr);
	}

	return retVal;
}

//Get a view object given a source path
BOOL HelperTaskObject::GetViewObject(const wchar_t* path, IWbemClassObject** pInst, CWbemServerWrap **a_ns)
{
	if ((pInst == NULL) || (path == NULL) || (a_ns == NULL) || (*a_ns == NULL))
	{
		return FALSE;
	}
	else
	{
		*pInst = NULL;
	}

	CObjectPathParser objectPathParser;
	wchar_t* tmpPath = UnicodeStringDuplicate(path);
	ParsedObjectPath* parsedObjectPath = NULL;
	BOOL retVal = !objectPathParser.Parse(tmpPath, &parsedObjectPath);

	if (retVal && !parsedObjectPath->IsInstance())
	{
		retVal = FALSE;
	}

	if (retVal)
	{
		retVal = FALSE;

		if (Validate(NULL))
		{
			//try for all possible classes in namespaces that match 
			//and return as soon as the first view instance is found...
			//==========================================================
			for (DWORD i = 0; (i < m_NSpaceArray.GetSize()) && (*pInst == NULL); i++)
			{
				CWbemServerWrap** t_pSrvs = m_NSpaceArray[i]->GetServerPtrs();
				CStringW* t_pathArray = m_NSpaceArray[i]->GetNamespacePaths();

				for (DWORD j = 0; (j < m_NSpaceArray[i]->GetCount()) && (*pInst == NULL); j++)
				{
					if (t_pSrvs[j] == NULL)
					{
						continue;
					}

					BOOL t_bCont = FALSE;

					//check that the servers match
					//=============================
					if ((parsedObjectPath->m_pServer == NULL) || (_wcsicmp(parsedObjectPath->m_pServer, L".") == 0))
					{
						if ((*a_ns)->IsRemote() && t_pSrvs[j]->IsRemote() &&
							(_wcsicmp((*a_ns)->GetPrincipal(), t_pSrvs[j]->GetPrincipal()) == 0))
						{
							t_bCont = TRUE;
						}
						else if (!(*a_ns)->IsRemote() && !t_pSrvs[j]->IsRemote())
						{
							t_bCont = TRUE;
						}
					}
					else
					{
						BOOL t_Local = bAreWeLocal(parsedObjectPath->m_pServer);
						
						if (t_Local  && !t_pSrvs[j]->IsRemote())
						{
							t_bCont = TRUE;
						}
						else
						{
							if (t_pSrvs[j]->IsRemote())
							{
								if (_wcsicmp(t_pSrvs[j]->GetPrincipal(), parsedObjectPath->m_pServer) == 0)
								{
									t_bCont = TRUE;
								}
								else 
								{
									DWORD t_len1 = wcslen(parsedObjectPath->m_pServer);
									DWORD t_len2 = wcslen(t_pSrvs[j]->GetPrincipal());

									if ((t_len2 > 0) && (t_len1 > 0) && (t_len1 < t_len2))
									{
										//machine.domain
										if ((_wcsnicmp(t_pSrvs[j]->GetPrincipal(), parsedObjectPath->m_pServer, t_len1) == 0) &&
										(((const wchar_t*)t_pSrvs[j]->GetPrincipal())[t_len1] == L'.'))
										{
											t_bCont = TRUE;
										}
										else
										{
											//could be the principal is domain\machine
											wchar_t *slash = wcschr(t_pSrvs[j]->GetPrincipal(), L'\\');

											if ((slash != NULL) && (_wcsicmp(parsedObjectPath->m_pServer, (slash+1)) == 0))
											{
												t_bCont = TRUE;
											}
										}
									}
								}
							}
						}
					}
					
					//check the namespace paths now
					//==============================
					if (t_bCont)
					{
						wchar_t *t_ns1 = parsedObjectPath->GetNamespacePart();
						BOOL t_bDel = TRUE;
						
						if (t_ns1 == NULL)
						{
							t_ns1 = (*a_ns)->GetPath();
							t_bDel = FALSE;
						}

						wchar_t *t_ns2 = t_pSrvs[j]->GetPath();

						if (!t_ns1 || !t_ns2)
						{
							t_bCont = FALSE;
						}
						else
						{
							//normalise...NOTE: no error checking since connection worked or parser worked
							//=============================================================================
							if (*t_ns1 == L'\\')
							{
								//skip the next slash
								t_ns1 += 2;
								
								while (*t_ns1 != L'\\')
								{
									t_ns1++;
								}

								t_ns1++;
							}

							if (*t_ns2 == L'\\')
							{
								//skip the next slash
								t_ns2 += 2;
								
								while (*t_ns2 != L'\\')
								{
									t_ns2++;
								}

								t_ns2++;
							}

							if (_wcsicmp(t_ns1, t_ns2) != 0)
							{
								t_bCont = FALSE;
							}
						}

						if (t_bDel && (t_ns1 != NULL))
						{
							delete [] t_ns1;
						}

						if (t_bCont)
						{
							//check that the class matches
							//=============================
							if (_wcsicmp(parsedObjectPath->m_pClass, m_SourceArray[i]->GetClassName()) == 0)
							{
								retVal = DoQuery(parsedObjectPath, pInst, j);
								break;
							}
							else
							{
								//uh-oh try classes derived from the source, i.e. do the query...
								//select * from meta_class where __this isa "m_SourceArray[i]->GetClassName()"
								// and __class = "parsedObjectPath->m_pClass"
								BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

								if (queryLBStr == NULL)
								{
									throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
								}

								BSTR queryBStr = SysAllocStringLen(NULL,
									61 + wcslen(m_SourceArray[i]->GetClassName()) +
									wcslen(parsedObjectPath->m_pClass));

								if (queryBStr == NULL)
								{
									throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
								}

								wcscpy(queryBStr, META_CLASS_QUERY_START);
								wcscat(queryBStr, m_SourceArray[i]->GetClassName());
								wcscat(queryBStr, META_CLASS_QUERY_MID);
								wcscat(queryBStr, parsedObjectPath->m_pClass);
								wcscat(queryBStr, END_QUOTE);
								IWbemContext * t_pCtx = m_Ctx;

								if (t_pSrvs[j]->IsRemote())
								{
									t_pCtx = NULL; //don't use context for remote calls
								}

								IWbemServices *ptmpServ = t_pSrvs[j]->GetServerOrProxy();

								if (ptmpServ)
								{
									IEnumWbemClassObject *t_pEnum = NULL;
									HRESULT t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);

									if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) &&
										t_pSrvs[j]->IsRemote())
									{
										if ( SUCCEEDED(UpdateConnection(&(t_pSrvs[j]), &ptmpServ)) )
										{
											if (ptmpServ)
											{
												t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0,
																			t_pCtx, &t_pEnum);
											}
										}
									}

									if (ptmpServ)
									{
										t_pSrvs[j]->ReturnServerOrProxy(ptmpServ);
									}			

									if (SUCCEEDED(t_hr))
									{
										if (t_pSrvs[j]->IsRemote())
										{
											t_hr = SetSecurityLevelAndCloaking(t_pEnum,
																				t_pSrvs[j]->GetPrincipal());
										}
										
										if (SUCCEEDED(t_hr))
										{
											//now use the enumerator and see if there is a result...
											IWbemClassObject* t_pClsObj = NULL;
											ULONG t_count = 0;

											//test each class in the derivation chain...
											if ( S_OK == t_pEnum->Next(WBEM_INFINITE, 1, &t_pClsObj, &t_count) )
											{
												if (t_pClsObj)
												{
													retVal = DoQuery(parsedObjectPath, pInst, j);
													t_pClsObj->Release();
												}
											}
										}

										t_pEnum->Release();
									}
								}
							}
						}
					}
				}
			}
		}
	}

	delete [] tmpPath;

	if (parsedObjectPath != NULL)
	{
		delete parsedObjectPath;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vpserv.cpp ===
//***************************************************************************

//

//  VPSERV.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the WBEM services interfaces

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

//need the following three lines
//to get the security stuff to work

#include "precomp.h"

#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <vpdefs.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>
#include <vpcfac.h>

extern CRITICAL_SECTION g_CriticalSection;
extern HRESULT SetSecurityLevelAndCloaking(IUnknown* pInterface, const wchar_t* prncpl);

#ifdef UNICODE
#if 0
extern HRESULT GetCurrentSecuritySettings(DWORD *pdwAuthnSvc, DWORD *pdwAuthzSvc,
								   DWORD *pdwAuthLevel, DWORD *pdwImpLevel,
								   DWORD *pdwCapabilities);


void VPGetUserName()
{
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);

	//first get current security info then set it on the proxy...
    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    DWORD dwAuthLevel = 0;
    DWORD dwImpLevel = 0;
    DWORD dwCapabilities = 0;

	HRESULT hr = GetCurrentSecuritySettings(&dwAuthnSvc, &dwAuthzSvc, &dwAuthLevel, &dwImpLevel, &dwCapabilities);

	HANDLE hThreadTok = NULL;

	if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
	{
		DWORD dwBytesReturned = 0;
		UCHAR tokBuff [1024];
		PTOKEN_USER ptokUser = (PTOKEN_USER)tokBuff;

		if (GetTokenInformation(hThreadTok, TokenUser, ptokUser,
									sizeof(tokBuff), &dwBytesReturned)) 
		{
			wchar_t buffN[1024];
			DWORD buffNlen = 1024;
			wchar_t buffD[1024];
			DWORD buffDlen = 1024;
			SID_NAME_USE snu;

			if (!LookupAccountSid(NULL, ptokUser->User.Sid, buffN, &buffNlen, buffD, &buffDlen, &snu))
			{
				DWORD dwErr = GetLastError();
			}
		}

		CloseHandle(hThreadTok);
	}
}
#endif
#endif

wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
	if ( string )
	{
		int textLength = wcslen ( string ) ;

		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
		wcscpy ( textBuffer , string ) ;

		return textBuffer ;
	}
	else
	{
		return NULL ;
	}
}

wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
	int prefixTextLength = 0 ;
	if ( prefix )
	{
		prefixTextLength = wcstombs ( NULL , prefix , 0 ) ;
	}

	int suffixTextLength = 0 ;
	if ( suffix )
	{
		suffixTextLength = wcstombs ( NULL , suffix , 0 ) ;
	}

	if ( prefix || suffix )
	{
		int textLength = prefixTextLength + suffixTextLength ;
		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

		if ( prefix )
		{
			wcscpy ( textBuffer , prefix ) ;
		}

		if ( suffix )
		{
			wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
		}

		return textBuffer ;
	}	
	else
		return NULL ;
}

CWbemServerWrap::CWbemServerWrap(IWbemServices *pServ, const wchar_t* prncpl, const wchar_t* path)
: m_Principal(NULL), m_Path(NULL)
{
	m_ref = 0;
	m_MainServ = pServ;
	
	if (prncpl != NULL)
	{
		m_Principal = UnicodeStringDuplicate(prncpl);
	}

	if (path != NULL)
	{
		m_Path = SysAllocString(path);
	}

	if (m_MainServ)
	{
		m_MainServ->AddRef();
	}
}

CWbemServerWrap::~CWbemServerWrap()
{
	if (m_MainServ)
	{
		m_MainServ->Release();
	}

#ifdef UNICODE
	if (m_Lock.Lock())
	{
		m_ProxyPool.RemoveAll();
		m_Lock.Unlock();
	}
#endif

	if (m_Principal != NULL)
	{
		delete [] m_Principal;
	}

	if (m_Path != NULL)
	{
		SysFreeString(m_Path);
	}
}

IWbemServices* CWbemServerWrap::GetServerOrProxy()
{
	IWbemServices * retVal = NULL;

#ifdef UNICODE
	if (m_MainServ == NULL)
	{
		return m_MainServ;
	}

	//if (IsRemote())
	{
		if (m_Lock.Lock())
		{
			POSITION t_pos = m_ProxyPool.GetHeadPosition();

			while (t_pos)
			{
				CWbemProxyServerWrap &t_srvRef = m_ProxyPool.GetNext(t_pos);

				if (!t_srvRef.m_InUse)
				{
					t_srvRef.m_InUse = TRUE;
					retVal = t_srvRef.m_Proxy;
					break;
				}
			}

			//calling back into COM so must unlock
			//addref MainServ then release it afterward;
			IWbemServices *t_MainCopy = m_MainServ;
			t_MainCopy->AddRef();

			m_Lock.Unlock();
			
			if (retVal == NULL)
			{
				IClientSecurity *pcs = NULL;

				if ( SUCCEEDED (t_MainCopy->QueryInterface(IID_IClientSecurity, (void**)&pcs)) )
				{
					if (FAILED(pcs->CopyProxy(t_MainCopy, (IUnknown **)(&retVal))))
					{
						retVal = NULL;
					}
					else
					{
						CWbemProxyServerWrap t_srv(retVal);
						t_srv.m_InUse = TRUE;

						if (m_Lock.Lock())
						{
							//only store and use if m_MainServ is unchanged
							if (t_MainCopy == m_MainServ)
							{
								m_ProxyPool.AddTail(t_srv);
							}
							else
							{
								//pathological case, mainserv was bad and has changed
								//could recurse at this point but is it worth it?
								//not thought so at this time.
								retVal->Release();
								retVal = NULL;
							}

							m_Lock.Unlock();
						}
						else
						{
							//can't use this proxy if I can't store it
							retVal->Release();
							retVal = NULL;
						}
					}

					pcs->Release();
				}
 			}

			t_MainCopy->Release();

			if (retVal && FAILED(SetSecurityLevelAndCloaking(retVal, IsRemote() ? m_Principal : COLE_DEFAULT_PRINCIPAL)))
			{
				retVal->AddRef(); //addref for the release that Returning the proxy will do
				ReturnServerOrProxy(retVal);
				retVal = NULL;
			}
		}
	}
	//else
	//{
	//	retVal = m_MainServ;
	//}

#else
		retVal = m_MainServ;
#endif

	if (retVal)
	{
		retVal->AddRef();
	}

	return retVal;
}

void CWbemServerWrap::ReturnServerOrProxy(IWbemServices* a_pServ)
{
#ifdef UNICODE
	//if (IsRemote())
	{
		if (m_Lock.Lock())
		{
			POSITION t_pos = m_ProxyPool.GetHeadPosition();

			while (t_pos)
			{
				CWbemProxyServerWrap &t_proxyRef = m_ProxyPool.GetNext(t_pos);

				if (t_proxyRef.m_Proxy == a_pServ)
				{
					t_proxyRef.m_InUse = FALSE;
					break;
				}
			}

			m_Lock.Unlock();
		}
	}
#endif

	a_pServ->Release();
}

BOOL CWbemServerWrap::ProxyBelongsTo(IWbemServices *a_proxy)
{
	BOOL retVal = FALSE;
#ifdef UNICODE
	if (IsRemote())
	{
		if (m_Lock.Lock())
		{
			POSITION t_pos = m_ProxyPool.GetHeadPosition();

			while (t_pos)
			{
				CWbemProxyServerWrap &t_proxyRef = m_ProxyPool.GetNext(t_pos);

				if (t_proxyRef.m_Proxy == a_proxy)
				{
					retVal = TRUE;
					break;
				}
			}

			m_Lock.Unlock();
		}
	}
#endif

	return retVal;
}

void CWbemServerWrap::SetMainServer(IWbemServices *a_pServ)
{
#ifdef UNICODE
	if (m_Lock.Lock())
	{
		if (m_MainServ)
		{
			m_MainServ->Release();
		}

		m_MainServ = a_pServ;

		if (m_MainServ)
		{
			m_MainServ->AddRef();
		}

		m_ProxyPool.RemoveAll();
		m_Lock.Unlock();
	}
#endif
}

ULONG CWbemServerWrap::AddRef()
{
	return (ULONG)(InterlockedIncrement(&m_ref));
}

ULONG CWbemServerWrap::Release()
{
	ULONG i = (ULONG)(InterlockedDecrement(&m_ref));

	if (i == 0)
	{
		delete this;
	}

	return i;
}

void CIWbemServMap::EmptyMap()
{
	if (Lock())
	{
		RemoveAll();
		Unlock();
	}
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CViewProvServ ::CViewProvServ
// CViewProvServ ::~CViewProvServ
//
//***************************************************************************

CViewProvServ ::CViewProvServ () :
	sm_Locator (NULL),
	sm_ConnectionMade (NULL),
	m_UserName (NULL),
	m_Initialised (FALSE),
	m_Server (NULL),
	m_Namespace (NULL),
	m_NotificationClassObject (NULL),
	m_ExtendedNotificationClassObject (NULL),
	m_GetNotifyCalled (FALSE),
	m_GetExtendedNotifyCalled (FALSE ),
	m_localeId (NULL)
{
	EnterCriticalSection(&g_CriticalSection);
    CViewProvClassFactory :: objectsInProgress++ ;
	LeaveCriticalSection(&g_CriticalSection);

	m_ReferenceCount = 0 ;

/*
 * Implementation
 */

	sm_ConnectionMade = CreateEvent(NULL, TRUE, FALSE, NULL);
}

CViewProvServ ::~CViewProvServ(void)
{
	delete [] m_localeId ;
	delete [] m_Namespace ;

	if ( m_Server ) 
		m_Server->Release () ;

	if ( m_NotificationClassObject )
		m_NotificationClassObject->Release () ;

	if ( m_ExtendedNotificationClassObject )
		m_ExtendedNotificationClassObject->Release () ;

	if (sm_Locator != NULL)
	{
		sm_Locator->Release();
	}

	if (NULL != sm_ConnectionMade)
	{
		CloseHandle(sm_ConnectionMade);
	}

	sm_ServerMap.EmptyMap();

	if (sm_ServerMap.Lock())
	{
		sm_OutStandingConnections.RemoveAll();
		sm_ServerMap.Unlock();
	}

	if (m_UserName != NULL)
	{
		SysFreeString(m_UserName);
	}

	EnterCriticalSection(&g_CriticalSection);
	CViewProvClassFactory :: objectsInProgress--;
	LeaveCriticalSection(&g_CriticalSection);
}

HRESULT CViewProvServ::GetUnsecApp(IUnsecuredApartment** ppLoc)
{
	if (NULL == ppLoc)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	EnterCriticalSection(&g_CriticalSection);

	HRESULT hr = WBEM_NO_ERROR;

	if (NULL == sm_UnsecApp)
	{
		hr = CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_LOCAL_SERVER,
								IID_IUnsecuredApartment, ( void ** )&sm_UnsecApp);

		if (FAILED(hr))
		{
			sm_UnsecApp = NULL;
		}
		else
		{
			sm_UnsecApp->AddRef();
		}
	}
	else
	{
		sm_UnsecApp->AddRef();
	}

	*ppLoc = sm_UnsecApp;
	LeaveCriticalSection(&g_CriticalSection);

	return hr;
}

#if 0
typedef HRESULT (__stdcall *VP_PROC_DllGetClassObject)(REFCLSID rclsid , REFIID riid, void **ppv);
#endif

HRESULT CViewProvServ::GetLocator(IWbemLocator **ppLoc)
{
	if (NULL == ppLoc)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		*ppLoc = NULL;
	}

	HRESULT hr = WBEM_E_FAILED;

	if (m_criticalSection.Lock())
	{
		if (NULL == sm_Locator)
		{
			m_criticalSection.Unlock();
#ifdef UNICODE
			hr = CoCreateInstance(CLSID_WbemLocator, NULL,
									CLSCTX_INPROC_SERVER,
									IID_IWbemLocator, ( void ** )ppLoc);
			
#else

			hr = CoCreateInstance(CLSID_WbemUnauthenticatedLocator, NULL,
									CLSCTX_INPROC_SERVER,
									IID_IWbemLocator, ( void ** )ppLoc);

#endif
			if (m_criticalSection.Lock())
			{
				//another thread may have connected for us...
				if (NULL == sm_Locator)
				{
					if (SUCCEEDED(hr))
					{
						sm_Locator = *ppLoc;
						sm_Locator->AddRef();
					}
				}
				else
				{
					if (FAILED(hr))
					{
						hr = WBEM_NO_ERROR;
						sm_Locator->AddRef();
						*ppLoc = sm_Locator;
					}
				}
			}
			else
			{
				return hr;
			}
		}
		else
		{
			hr = WBEM_NO_ERROR;
			sm_Locator->AddRef();
			*ppLoc = sm_Locator;
		}

		m_criticalSection.Unlock();
	}

	return hr;
}

//***************************************************************************
//
// CViewProvServ ::QueryInterface
// CViewProvServ ::AddRef
// CViewProvServ ::Release
//
// Purpose: IUnknown members for CViewProvServ object.
//***************************************************************************

STDMETHODIMP CViewProvServ ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		if (iplpv == NULL)
		{
			return E_INVALIDARG;
		}

		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( IWbemServices* ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( IWbemServices* ) this ;		
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( IWbemProviderInit* ) this ;		
		}
		

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return S_OK ;
		}
		else
		{
			return E_NOINTERFACE ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDMETHODIMP_(ULONG) CViewProvServ ::AddRef(void)
{
   	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CViewProvServ ::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG t_Ref ;
		if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return t_Ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

IWbemServices *CViewProvServ :: GetServer () 
{ 
	if ( m_Server )
		m_Server->AddRef () ; 

	return m_Server ; 
}

void CViewProvServ :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CViewProvServ :: GetNamespace () 
{
	return m_Namespace ; 
}

void CViewProvServ :: SetNamespace ( wchar_t *a_Namespace ) 
{
	m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

IWbemClassObject *CViewProvServ :: GetNotificationObject (
										WbemProvErrorObject &a_errorObject,
										IWbemContext *pCtx
									) 
{
	if ( m_NotificationClassObject )
	{
		m_NotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateNotificationObject ( a_errorObject, pCtx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_NotificationClassObject->AddRef () ;
		}

	}

	return m_NotificationClassObject ; 
}

IWbemClassObject *CViewProvServ :: GetExtendedNotificationObject (
										WbemProvErrorObject &a_errorObject,
										IWbemContext *pCtx
									) 
{
	if ( m_ExtendedNotificationClassObject )
	{
		m_ExtendedNotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject, pCtx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_ExtendedNotificationClassObject->AddRef () ;
		}
	}

	return m_ExtendedNotificationClassObject ; 
}

BOOL CViewProvServ :: CreateExtendedNotificationObject ( 

	WbemProvErrorObject &a_errorObject,
	IWbemContext *pCtx
)
{
	if ( m_GetExtendedNotifyCalled )
	{
		if ( m_ExtendedNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetExtendedNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	BSTR t_bstrTemp = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);

	HRESULT t_Result = m_Server->GetObject (

		t_bstrTemp ,
		0 ,
		pCtx,
		& m_ExtendedNotificationClassObject ,
		NULL 
	) ;

	SysFreeString(t_bstrTemp);

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;

		m_ExtendedNotificationClassObject = NULL ;
	}

	return t_Status ;
}

BOOL CViewProvServ :: CreateNotificationObject ( 

	WbemProvErrorObject &a_errorObject,
	IWbemContext *pCtx
)
{
	if ( m_GetNotifyCalled )
	{
		if ( m_NotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	BSTR t_bstrTemp = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);

	HRESULT t_Result = m_Server->GetObject (

		t_bstrTemp ,
		0 ,
		pCtx,
		& m_NotificationClassObject ,
		NULL 
	) ;

	SysFreeString(t_bstrTemp);

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
		m_NotificationClassObject = NULL;
	}

	return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CViewProvServ :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink __RPC_FAR* __RPC_FAR* ppHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR* __RPC_FAR *ppObject,
    IWbemCallResult __RPC_FAR* __RPC_FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	HRESULT hr = S_OK;
	SetStructuredExceptionHandler seh;
	GetObjectTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pHandler == NULL)
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			hr = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
	CViewProvServ::sm_debugLog->Write (  

		_T("\r\n")
	) ;

	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("CViewProvServ::GetObjectAsync ()")
	) ;
) 

			if (SUCCEEDED(hr))
			{
			/*
			 * Create Asynchronous GetObjectByPath object
			 */
				t_AsyncEvent = new GetObjectTaskObject ( this , ObjectPath , lFlags , pHandler , pCtx, NULL, NULL ) ;
				t_AsyncEvent->GetObject();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				hr = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"Returning from CViewProvServ::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		hr 
	) ;
)

		}
	}
	catch(Structured_Exception e_SE)
	{
		hr = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->CleanUpObjSinks(TRUE);
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		hr = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_UNEXPECTED;
	}

	return hr ;
}

HRESULT CViewProvServ :: PutClass ( 
		
	IWbemClassObject __RPC_FAR* pClass , 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: PutClassAsync ( 
		
	IWbemClassObject __RPC_FAR* pClass, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CViewProvServ :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CViewProvServ :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext __RPC_FAR* pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: PutInstance (

    IWbemClassObject __RPC_FAR *pInstance,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
	IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: PutInstanceAsync ( 
		
	IWbemClassObject __RPC_FAR* pInstance, 
	long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	PutInstanceTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
	CViewProvServ::sm_debugLog->Write (  

		_T("\r\n")
	) ;

	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("CViewProvServ::PutInstanceAsync ()")
	) ;
) 

			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Asynchronous GetObjectByPath object
				 */

				t_AsyncEvent = new PutInstanceTaskObject ( this , pInstance , lFlags , pHandler , pCtx ) ;
				t_AsyncEvent->PutInstance();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("Returning from CViewProvServ::PutInstanceAsync with Result = (%lx)"),
		t_Result 
	) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

HRESULT CViewProvServ :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CViewProvServ :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: CreateInstanceEnum ( 

	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: CreateInstanceEnumAsync (

 	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler 

) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	ExecQueryTaskObject *t_AsyncEvent = NULL;
	BSTR Query = NULL;

	try
	{
		if (pHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
	CViewProvServ::sm_debugLog->Write (  

		_T("\r\n")
	) ;


	CViewProvServ::sm_debugLog->WriteW (  

		L"CViewProvServ::CreateInstanceEnumAsync ( (%s) )" ,
		Class
	) ;
)

			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Synchronous Enum Instance object
				 */
				Query = SysAllocStringLen(NULL, 33 + (wcslen(Class) * 2));

				if (Query == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}

				wcscpy(Query, ENUM_INST_QUERY_START);
				wcscat(Query, Class);
				wcscat(Query, ENUM_INST_QUERY_MID);
				wcscat(Query, Class);
				wcscat(Query, END_QUOTE);

				t_AsyncEvent = new ExecQueryTaskObject ( this , WBEM_QUERY_LANGUAGE_SQL1 , Query , lFlags , pHandler , pCtx ) ;
				t_AsyncEvent->ExecQuery();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;
				SysFreeString(Query);

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}
DebugOut1( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"Returning from CViewProvServ::CreateInstanceEnumAsync ( (%s),(%s) ) with Result = (%lx)" ,
		Class,
		Query,
		t_Result 
	) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->CleanUpObjSinks(TRUE);
			t_AsyncEvent->Release();
			SysFreeString(Query);
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

HRESULT CViewProvServ :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext __RPC_FAR* pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	ExecQueryTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();

#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
		CViewProvServ::sm_debugLog->Write (  

			_T("\r\n")
		) ;


		CViewProvServ::sm_debugLog->WriteW (  

			L"CViewProvServ::ExecQueryAsync ( (%s),(%s) )" ,
			QueryFormat ,
			Query
		) ;
)

			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Synchronous Enum Instance object
				 */
				pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);

				t_AsyncEvent = new ExecQueryTaskObject ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;
				t_AsyncEvent->ExecQuery();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
		CViewProvServ::sm_debugLog->WriteW (  

			L"Returning from CViewProvServ::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" , 
			QueryFormat ,
			Query ,
			t_Result 
		) ;
)

		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->CleanUpObjSinks(TRUE);
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

HRESULT CViewProvServ :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CViewProvServ :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CViewProvServ :: ExecMethod( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CViewProvServ :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
	IWbemObjectSink __RPC_FAR *pResponseHandler
) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	ExecMethodTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pResponseHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
		CViewProvServ::sm_debugLog->Write (  

			_T("\r\n")
		) ;

		CViewProvServ::sm_debugLog->WriteFileAndLine (  

			_T(__FILE__),__LINE__,
			_T("CViewProvServ::ExecMethodAsync ()") 
		) ;
)
 
			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Asynchronous GetObjectByPath object
				 */
				t_AsyncEvent = new ExecMethodTaskObject ( this , ObjectPath , MethodName ,
																		lFlags , pInParams , pResponseHandler , pCtx ) ;
				t_AsyncEvent->ExecMethod();


				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
		CViewProvServ::sm_debugLog->WriteW (  

			L"Returning from CViewProvServ::ExecMethodAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			t_Result 
		) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

        
HRESULT CViewProvServ :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SetStructuredExceptionHandler seh;

	try
	{
DebugOut1( 

		CViewProvServ::sm_debugLog->Write (  

			_T("\r\n")
		) ;

		CViewProvServ::sm_debugLog->WriteFileAndLine (  

			_T(__FILE__),__LINE__,
			_T("CViewProvServ::Initialize ")
		) ;
)
		if ((pCIMOM == NULL) || (pInitSink == NULL) || (pszNamespace == NULL))
		{
			return WBEM_E_INVALID_PARAMETER;
		}

#ifndef UNICODE
		if (pszUser == NULL)
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		m_UserName = SysAllocString(pszUser);
#endif
		m_Server = pCIMOM ;
		m_Server->AddRef () ;
		m_NamespacePath.SetNamespacePath ( pszNamespace ) ;
		pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 ) ;	

DebugOut1( 

		CViewProvServ::sm_debugLog->WriteFileAndLine (  

			_T(__FILE__),__LINE__,
			_T("Returning From CImpPropProv::Initialize () ")
		) ;
)
	
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}

	return WBEM_NO_ERROR ;
}

HRESULT STDMETHODCALLTYPE CViewProvServ::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vptasksu.cpp ===
//***************************************************************************

//

//  VPTASKSU.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the union methods taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//need the following three lines
//to get the security stuff to work
#include "precomp.h"

#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

BOOL WbemTaskObject::CreateAndIndicateUnions(WbemProvErrorObject &a_ErrorObject, int index)
{
	BOOL retVal = TRUE;

	if (index != -1)
	{
		retVal = CreateAndIndicate(a_ErrorObject, m_ObjSinkArray[index]);

		for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
		{
			if (m_ObjSinkArray[x] != NULL)
			{
				m_ObjSinkArray[x]->Release();
			}
		}
	}
	else
	{
		for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
		{
			if ((m_ObjSinkArray[x] != NULL) && SUCCEEDED(m_ObjSinkArray[x]->GetResult()))
			{
				BOOL t_bRes = CreateAndIndicate(a_ErrorObject, m_ObjSinkArray[x]);
				retVal = retVal && t_bRes;
			}
			else if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;

				if ( FAILED ( m_ObjSinkArray[x]->GetResult() ) )
				{
					a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_ObjSinkArray[x]->GetResult() ) ;
				}
				else
				{
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				}

				a_ErrorObject.SetMessage ( L"A source query failed." );
			}

			if (m_ObjSinkArray[x] != NULL)
			{
				m_ObjSinkArray[x]->Release();
			}
		}
	}

	m_ObjSinkArray.RemoveAll();
	return retVal;
}

//for unions and associations
BOOL WbemTaskObject::CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, CObjectSinkResults* pSrcs)
{
	BOOL retVal = TRUE;

	for (int x = 0; x < pSrcs->m_ObjArray.GetSize(); x++)
	{
		BOOL bIndicate = TRUE;
		IWbemClassObject* srcObj = pSrcs->m_ObjArray[x]->GetWrappedObject();
		IWbemClassObject* viewObj = NULL;
		
		if ( SUCCEEDED(m_ClassObject->SpawnInstance(0, &viewObj)) )
		{
			POSITION propPos = m_PropertyMap.GetStartPosition();

			while ((propPos != NULL) && bIndicate)
			{
				CStringW propName;
				CPropertyQualifierItem* propProps;
				m_PropertyMap.GetNextAssoc(propPos, propName, propProps);
				VARIANT v;
				CIMTYPE c;

				if (propProps->m_SrcPropertyNames[pSrcs->GetIndex()].IsEmpty())
				{
					if (propProps->IsKey())
					{
						if (retVal)
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to set key value for union view instance." );
						}

						bIndicate = FALSE;
					}

				}
				else
				{
					if ( SUCCEEDED(srcObj->Get(propProps->m_SrcPropertyNames[pSrcs->GetIndex()], 0, &v, &c, NULL)) )
					{
						if (((v.vt == VT_NULL) || (v.vt == VT_EMPTY)) && propProps->IsKey())
						{
							if (retVal)
							{
								retVal = FALSE;
							}

							bIndicate = FALSE;
						}
						else
						{
							//transpose reference if necessary
							//=================================
							BOOL bPut = TRUE;

							if (m_bAssoc && (propProps->GetCimType() == CIM_REFERENCE))
							{
								VARIANT vTmp;
								DWORD dwNSIndx = pSrcs->m_ObjArray[x]->GetIndex();
								CWbemServerWrap** pSrvs = m_NSpaceArray[pSrcs->GetIndex()]->GetServerPtrs();

								if (TransposeReference(propProps, v, &vTmp, TRUE, &pSrvs[dwNSIndx]))
								{
									VariantClear(&v);
									VariantInit(&v);

                                    if (FAILED(VariantCopy(&v, &vTmp)))
                                    {
                                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                                    }
								}
								else
								{
									if (propProps->IsKey())
									{
										if (retVal)
										{
											retVal = FALSE;
										}

										bIndicate = FALSE;
									}

									bPut = FALSE;
								}
								
								VariantClear(&vTmp);
							}

							if (bPut && FAILED(viewObj->Put(propName, 0, &v, c)) )
							{
								if (retVal)
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_ErrorObject.SetMessage ( L"Failed to put property" );
								}

								if (propProps->IsKey())
								{
									bIndicate = FALSE;
								}
							}
						}

						VariantClear(&v);
					}
					else
					{
						if (retVal)
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
						}
					}
				}
			}

			if (bIndicate && m_bIndicate)
			{
				m_NotificationHandler->Indicate(1, &viewObj);
			}

			viewObj->Release();
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"WBEM API FAILURE:- Failed to spawn an instance of the view class." ) ;
			break;
		}
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vptasksj.cpp ===
//***************************************************************************

//

//  VPTASKSJ.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the join methods for taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

#include <wbemtime.h>

BOOL CompareSimplePropertyValues(VARIANT* v1, VARIANT* v2, CIMTYPE ct)
{
	BOOL retVal = FALSE;

	if (v1->vt == v2->vt)
	{
		switch (ct)
		{
			case CIM_BOOLEAN:
			{
				if (VT_BOOL == v1->vt)
				{
					if (v1->boolVal == v2->boolVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_UINT8:
			{
				if (VT_UI1 == v1->vt)
				{
					if (v1->bVal == v2->bVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_SINT16:
			case CIM_CHAR16:
			case CIM_SINT8:
			{
				if (VT_I2 == v1->vt)
				{
					if (v1->iVal == v2->iVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_UINT32:
			case CIM_SINT32:
			case CIM_UINT16:
			{
				if (VT_I4 == v1->vt)
				{
					if (v1->lVal == v2->lVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_REFERENCE:
			//TO DO:
			//references should be normalised for equality checks.
			//should do this once CIMOM does...

			case CIM_STRING:
			case CIM_SINT64:
			case CIM_UINT64:
			{
				if (VT_BSTR == v1->vt)
				{
					if (0 == _wcsicmp(v1->bstrVal,v2->bstrVal))
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_DATETIME:
			{
				if (VT_BSTR == v1->vt)
				{
					WBEMTime t1(v1->bstrVal);
					WBEMTime t2(v2->bstrVal);

					if (t1 == t2)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			default:
			{
				//unsupported by this function
			}
		}
	}

	return retVal;
}

//Validate:
//1) All classes mentioned in join exist.
//2) All properties mentioned in join map to view class properties
//3) All classes mentioned in sources are mentioned in join
//4) Any != operator is not applied to two properties which map to the same view property
//5) All clauses have different classes being checked
BOOL WbemTaskObject::ValidateJoin()
{
	//3) check all sources mentioned in join
	//this check with (1) will do the trick
	if (m_JoinOnArray.m_AllClasses.GetCount() != m_SourceArray.GetSize())
	{
		return FALSE;
	}

	//1) check all join classes exist
	POSITION pos = m_JoinOnArray.m_AllClasses.GetStartPosition();

	while (pos)
	{
		int val;
		CStringW tmpStr;
		m_JoinOnArray.m_AllClasses.GetNextAssoc(pos, tmpStr, val);

		if (!m_ClassToIndexMap.Lookup(tmpStr, val))
		{
			return FALSE;
		}
	}

	wchar_t** classA = m_JoinOnArray.GetAClasses();
	wchar_t** propsA = m_JoinOnArray.GetAProperties();
	wchar_t** classB = m_JoinOnArray.GetBClasses();
	wchar_t** propsB = m_JoinOnArray.GetBProperties();
	UINT* ops = m_JoinOnArray.GetOperators();

	//(2), (4) and (5) validations
	//=============================
	for (int x = 0; x < m_JoinOnArray.GetCount(); x++)
	{
		if (_wcsicmp(classA[x], classB[x]) == 0)
		{
			return FALSE;
		}

		int indexA;

		if (m_ClassToIndexMap.Lookup(classA[x], indexA))
		{
			int indexB;

			if (m_ClassToIndexMap.Lookup(classB[x], indexB))
			{
				POSITION pos = m_PropertyMap.GetStartPosition();
				CStringW propA;
				CStringW propB;

				while (pos)
				{
					CStringW key;
					CPropertyQualifierItem* pItem;
					m_PropertyMap.GetNextAssoc(pos, key, pItem);

					if (pItem->m_SrcPropertyNames[indexA].CompareNoCase(propsA[x]) == 0)
					{
						propA = key;

						if (!propB.IsEmpty())
						{
							break;
						}
					}
					
					if (pItem->m_SrcPropertyNames[indexB].CompareNoCase(propsB[x]) == 0)
					{
						propB = key;

						if (!propA.IsEmpty())
						{
							break;
						}
					}
				}

				//check both properties exist (2)
				if (propA.IsEmpty() || propB.IsEmpty())
				{
					return FALSE;
				}

				//validate expression (4)
				if (ops[x] == CJoinOnQualifierArray::NOT_EQUALS_OPERATOR && (propA.CompareNoCase(propB) == 0))
				{
					return FALSE;
				}
			}
			else
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

#ifdef VP_PERFORMANT_JOINS

//should not compile with compiler flag set til I'm ready

BOOL WbemTaskObject::CreateAndIndicateJoinsPerf(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle)
{
	BOOL retVal = TRUE;

	//check all queries were asked...
	if (m_ObjSinkArray.GetSize() != m_SourceArray.GetSize())
	{
		retVal = FALSE;
		a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"A source query failed or was not executed therefore a join could not be created." );
	}

	//check we got results from all queries...
	for (UINT x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if ((m_ObjSinkArray[x] == NULL) || FAILED(m_ObjSinkArray[x]->GetResult()) || !m_ObjSinkArray[x]->m_ObjArray.GetSize())
		{
			if (!a_bSingle)
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;

				if ( FAILED ( m_ObjSinkArray[x]->GetResult() ) )
				{
					a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_ObjSinkArray[x]->GetResult() ) ;
				}
				else
				{
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				}

				a_ErrorObject.SetMessage ( L"A source query failed or returned no instances." );
			}

			retVal = FALSE;
			break;
		}
	}

	//perform the join of all results...
	if (retVal)
	{
		CMap<CStringW, LPCWSTR, int, int> t_JoinedClasses;
		CList<IWbemClassObject*, IWbemClassObject*> t_ResultObjs; 
		retVal = JoinTwoColumns(a_ErrorObject, t_JoinedClasses, t_ResultObjs);
		wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
		wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
		wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
		wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();

		while ( retVal && (t_JoinedClasses.GetCount() != m_SourceArray.GetSize()) )
		{
			DWORD t_column = m_SourceArray.GetSize() + 1;
			CList <int, int> t_IndexArray;
			wchar_t *t_classname = NULL;

			//find a column not already joined that can be joined now...
			for (x = 0; x < m_JoinOnArray.GetCount(); x++)
			{
				if (!m_JoinOnArray.m_bDone[x])
				{
					int dummyInt = 0;

					if (t_classname == NULL)
					{
						if (t_JoinedClasses.Lookup(t_clsA[x], dummyInt))
						{
							if (!m_ClassToIndexMap.Lookup(t_clsB[x], (int &)t_column))
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"An unexpected error ocurred performing the join." );
							}

							t_classname = t_clsB[x];
							t_JoinedClasses.SetAt(t_classname, 0);
							m_JoinOnArray.m_bDone[x] = TRUE;
							t_IndexArray.AddTail(x);

							//want all clauses the same way around...
							t_clsB[x] = t_clsA[x];
							t_clsA[x] = t_classname;
							wchar_t *t_tmpStr = t_prpsA[x];
							t_prpsA[x] = t_prpsB[x];
							t_prpsB[x] = t_tmpStr;
						}
						else if (t_JoinedClasses.Lookup(t_clsB[x], dummyInt))
						{
							if (!m_ClassToIndexMap.Lookup(t_clsA[x], (int &)t_column))
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"An unexpected error ocurred performing the join." );
							}

							t_classname = t_clsA[x];
							t_JoinedClasses.SetAt(t_classname, 0);
							m_JoinOnArray.m_bDone[x] = TRUE;
							t_IndexArray.AddTail(x);
						}
					}
					else
					{
						//find all clauses which can be evaluated now...
						if ((_wcsicmp(t_classname, t_clsA[x]) == 0) && (t_JoinedClasses.Lookup(t_clsB[x], dummyInt)))
						{
							t_IndexArray.AddTail(x);
							m_JoinOnArray.m_bDone[x] = TRUE;
						}
						else if ((_wcsicmp(t_classname, t_clsB[x]) == 0) && (t_JoinedClasses.Lookup(t_clsA[x], dummyInt)))
						{
							//want the clauses in the same order for simpler evaluation later...
							wchar_t *t_tmpStr =  t_clsA[x];
							t_clsA[x] = t_clsB[x];
							t_clsB[x] = t_tmpStr;
							t_tmpStr =  t_prpsA[x];
							t_prpsA[x] = t_prpsB[x];
							t_prpsB[x] = t_tmpStr;
							t_IndexArray.AddTail(x);
							m_JoinOnArray.m_bDone[x] = TRUE;
						}
					}
				}
			}

			if (t_column == m_SourceArray.GetSize() + 1)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to perform join." );
			}
			else
			{
				retVal = AddColumnToJoin(a_ErrorObject, t_JoinedClasses, t_ResultObjs, t_column, t_IndexArray);
				t_IndexArray.RemoveAll();
			}
		}

		if (retVal)
		{
			if (m_bIndicate)
			{
				POSITION t_pos = t_ResultObjs.GetHeadPosition();
				BOOL t_bIndicated = FALSE;

				while (t_pos)
				{
					IWbemClassObject *t_Obj = t_ResultObjs.GetNext(t_pos);

					if (t_Obj)
					{
						if (PostFilter(t_Obj))
						{
							if (a_bSingle && t_bIndicated)
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Too many view instances can be created." ) ;
								break;
							}
							else
							{
								m_NotificationHandler->Indicate(1, &t_Obj);
								t_bIndicated = TRUE;
							}
						}
					}
				}
			}
		}

		t_ResultObjs.RemoveAll();
	}

	//clean up...
	for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();

	return retVal;
}

BOOL WbemTaskObject::JoinItem(WbemProvErrorObject &a_ErrorObject,
						IWbemClassObject *a_Obj1, IWbemClassObject *a_vObj,
						IWbemClassObject *a_resObj, CList <int, int> &a_IndexArray,
						DWORD a_indx1)
{
	BOOL retVal = TRUE;
	wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
	wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
	UINT* t_ops = m_JoinOnArray.GetOperators();
	wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();
	VARIANT t_vA;
	VariantInit(&t_vA);
	CIMTYPE t_cA;
	POSITION t_pos = a_IndexArray.GetHeadPosition();

	while (t_pos && retVal)
	{
		int t_index = a_IndexArray.GetNext(t_pos);

		//get the propertyname in the view...
		int t_srcindxA = 0;
		int t_srcindxB = 0;
		
		if (m_ClassToIndexMap.Lookup(t_clsB[t_index], t_srcindxB) && m_ClassToIndexMap.Lookup(t_clsA[t_index], t_srcindxA))
		{
			//find t_prpsB[t_index] and get the view property name...
			POSITION t_propPos = m_PropertyMap.GetStartPosition();
			CStringW t_propName;

			while (t_propPos != NULL)
			{
				CPropertyQualifierItem *t_propProps;
				m_PropertyMap.GetNextAssoc(t_propPos, t_propName, t_propProps);

				if (!t_propProps->m_SrcPropertyNames[t_srcindxB].IsEmpty() && 
					!t_propProps->m_SrcPropertyNames[t_srcindxA].IsEmpty() &&
					(_wcsicmp(t_propProps->m_SrcPropertyNames[t_srcindxB], t_prpsB[t_index]) == 0) &&
					(_wcsicmp(t_propProps->m_SrcPropertyNames[t_srcindxA], t_prpsA[t_index]) == 0))
				{
					break;
				}
				else
				{
					t_propName.Empty();
				}
			}

			if (!t_propName.IsEmpty() &&  SUCCEEDED(a_Obj1->Get(t_prpsA[t_index], 0, &t_vA, &t_cA, NULL)) )
			{
				VARIANT t_vB;
				VariantInit(&t_vB);
				CIMTYPE t_cB;

				if ( SUCCEEDED(a_vObj->Get(t_propName, 0, &t_vB, &t_cB, NULL)) )
				{
					if (t_cA == t_cB)
					{
						if (t_ops[t_index] == CJoinOnQualifierArray::EQUALS_OPERATOR)
						{
							retVal = CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
						}
						else //NOT_EQUALS
						{
							retVal = !CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Join properties have different CIM types." ) ;
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
				}

				VariantClear(&t_vA);
				VariantClear(&t_vB);
				VariantInit(&t_vA);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to find source property in view class." ) ;
		}
	}

	VariantClear(&t_vA);

	if (retVal)
	{
		//copy properties from sources to result
		POSITION t_propPos = m_PropertyMap.GetStartPosition();

		while ((t_propPos != NULL) && retVal)
		{
			CStringW t_propName;
			CPropertyQualifierItem *t_propProps;
			m_PropertyMap.GetNextAssoc(t_propPos, t_propName, t_propProps);
			
			if (!t_propProps->m_SrcPropertyNames[a_indx1].IsEmpty())
			{
				VARIANT t_v;
				VariantInit(&t_v);
				CIMTYPE t_c;

				if ( SUCCEEDED(a_Obj1->Get(t_propProps->m_SrcPropertyNames[a_indx1], 0, &t_v, &t_c, NULL)) )
				{
					if (((t_v.vt == VT_NULL) || (t_v.vt == VT_EMPTY)) && t_propProps->IsKey())
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"View key value in source instance is NULL" );
					}
					else
					{
						if ( FAILED(a_resObj->Put(t_propName, 0, &t_v, t_c)) )
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to put property" );
						}
					}

					VariantClear(&t_v);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
				}
			}
			else
			{
				continue;
			}
		}
	}

	return retVal;
}


BOOL WbemTaskObject::JoinTwoItems(WbemProvErrorObject &a_ErrorObject,
								IWbemClassObject *a_Obj1, IWbemClassObject *a_Obj2,
								IWbemClassObject *a_resObj, CList <int, int> &a_IndexArray,
								DWORD a_indx1, DWORD a_indx2)
{
	BOOL retVal = TRUE;
	wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
	wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
	UINT* t_ops = m_JoinOnArray.GetOperators();
	wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();
	VARIANT t_vA;
	CIMTYPE t_cA;
	POSITION t_pos = a_IndexArray.GetHeadPosition();

	while (t_pos && retVal)
	{
		int t_index = a_IndexArray.GetNext(t_pos);

		if ( SUCCEEDED(a_Obj1->Get(t_prpsA[t_index], 0, &t_vA, &t_cA, NULL)) )
		{
			VARIANT t_vB;
			CIMTYPE t_cB;

			if ( SUCCEEDED(a_Obj2->Get(t_prpsB[t_index], 0, &t_vB, &t_cB, NULL)) )
			{
				if (t_cA == t_cB)
				{
					if (t_ops[t_index] == CJoinOnQualifierArray::EQUALS_OPERATOR)
					{
						retVal = CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
					}
					else //NOT_EQUALS
					{
						retVal = !CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Join properties have different CIM types." ) ;
				}

				VariantClear(&t_vB);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
			}

			VariantClear(&t_vA);
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
		}
	}

	if (retVal)
	{
		//copy properties from sources to result
		POSITION t_propPos = m_PropertyMap.GetStartPosition();

		while ((t_propPos != NULL) && retVal)
		{
			CStringW t_propName;
			CPropertyQualifierItem *t_propProps;
			m_PropertyMap.GetNextAssoc(t_propPos, t_propName, t_propProps);
			IWbemClassObject *t_src_Obj = NULL;
			DWORD t_index = 0;
			
			if (!t_propProps->m_SrcPropertyNames[a_indx1].IsEmpty())
			{
				t_src_Obj = a_Obj1;
				t_index = a_indx1;
			}
			else if (!t_propProps->m_SrcPropertyNames[a_indx2].IsEmpty())
			{
				t_src_Obj = a_Obj2;
				t_index = a_indx2;
			}
			else
			{
				continue;
			}

			VARIANT t_v;
			VariantInit(&t_v);
			CIMTYPE t_c;

			if ( SUCCEEDED(t_src_Obj->Get(t_propProps->m_SrcPropertyNames[t_index], 0, &t_v, &t_c, NULL)) )
			{
				if (((t_v.vt == VT_NULL) || (t_v.vt == VT_EMPTY)) && t_propProps->IsKey())
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"View key value in source instance is NULL" );
				}
				else
				{
					if ( FAILED(a_resObj->Put(t_propName, 0, &t_v, t_c)) )
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to put property" );
					}
				}

				VariantClear(&t_v);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
			}
		}
	}

	return retVal;
}

BOOL WbemTaskObject::JoinTwoColumns(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs)
{
	BOOL retVal = TRUE;
	wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
	wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
	wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();
	UINT* t_ops = m_JoinOnArray.GetOperators();
	int t_indexA;
	int t_indexB;
	CList <int, int> t_IndexArray;
	t_IndexArray.AddTail(0);
	m_JoinOnArray.m_bDone[0] = TRUE;

	for (int x = 1; x < m_JoinOnArray.GetCount(); x++)
	{
		//find all clauses which can be evaluated now...
		if ((_wcsicmp(t_clsA[0], t_clsA[x]) == 0) && (_wcsicmp(t_clsB[0], t_clsB[x]) == 0))
		{
			t_IndexArray.AddTail(x);
			m_JoinOnArray.m_bDone[x] = TRUE;
		}
		else if ((_wcsicmp(t_clsB[0], t_clsA[x]) == 0) && (_wcsicmp(t_clsA[0], t_clsB[x]) == 0))
		{
			//want the clauses in the same order for simpler evaluation later...
			wchar_t *t_tmp =  t_clsA[x];
			t_clsA[x] = t_clsB[x];
			t_clsB[x] = t_tmp;
			t_tmp =  t_prpsA[x];
			t_prpsA[x] = t_prpsB[x];
			t_prpsB[x] = t_tmp;
			t_IndexArray.AddTail(x);
			m_JoinOnArray.m_bDone[x] = TRUE;
		}
	}

	a_JoinedClasses.SetAt(t_clsA[0], 0);
	a_JoinedClasses.SetAt(t_clsB[0], 0);
	m_ClassToIndexMap.Lookup(t_clsA[0], t_indexA);
	m_ClassToIndexMap.Lookup(t_clsB[0], t_indexB);

	for (int i = 0; retVal && (i < m_ObjSinkArray[t_indexA]->m_ObjArray.GetSize()); i++) 
	{
		if (m_ObjSinkArray[t_indexA]->m_ObjArray[i])
		{
			for (int j = 0; retVal && (j < m_ObjSinkArray[t_indexB]->m_ObjArray.GetSize()); j++)
			{
				if (m_ObjSinkArray[t_indexB]->m_ObjArray[j])
				{
					IWbemClassObject* t_viewObj = NULL;
					
					if ( SUCCEEDED(m_ClassObject->SpawnInstance(0, &t_viewObj)) )
					{
						if (JoinTwoItems(a_ErrorObject, m_ObjSinkArray[t_indexA]->m_ObjArray[i]->GetWrappedObject(),
										m_ObjSinkArray[t_indexB]->m_ObjArray[j]->GetWrappedObject(),
										t_viewObj, t_IndexArray, t_indexA, t_indexB))
						{
							a_ResultObjs.AddTail(t_viewObj);
						}
						else
						{
							t_viewObj->Release();
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"An error occured when spawning an instance of the view class." );
					}
				}
			}

			m_ObjSinkArray[t_indexA]->m_ObjArray[i]->Release();
			m_ObjSinkArray[t_indexA]->m_ObjArray[i] = NULL;
		}
	}

	m_ObjSinkArray[t_indexB]->m_ObjArray.RemoveAll();

	return retVal;
}

BOOL WbemTaskObject::AddColumnToJoin(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs,
						DWORD a_Index, CList <int, int> &a_IndexArray)
{
	BOOL retVal = TRUE;
	CList<IWbemClassObject*, IWbemClassObject*> t_AddedResultObjs;

	for (int i = 0; retVal && (i < m_ObjSinkArray[a_Index]->m_ObjArray.GetSize()); i++) 
	{
		if (m_ObjSinkArray[a_Index]->m_ObjArray[i])
		{
			POSITION t_pos = a_ResultObjs.GetHeadPosition();

			while (retVal && t_pos)
			{
				IWbemClassObject *t_vSrc = a_ResultObjs.GetNext(t_pos);

				if (t_vSrc)
				{
					IWbemClassObject* t_viewObj = NULL;
					
					if ( SUCCEEDED(t_vSrc->Clone(&t_viewObj)) )
					{
						if (JoinItem(a_ErrorObject, m_ObjSinkArray[a_Index]->m_ObjArray[i]->GetWrappedObject(),
										t_vSrc,	t_viewObj, a_IndexArray, a_Index))
						{
							t_AddedResultObjs.AddTail(t_viewObj);
						}
						else
						{
							t_viewObj->Release();
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"An error occured when spawning an instance of the view class." );
					}
				}
			}

			m_ObjSinkArray[a_Index]->m_ObjArray[i]->Release();
			m_ObjSinkArray[a_Index]->m_ObjArray[i] = NULL;
		}
	}

	//don't need partial join any longer
	a_ResultObjs.RemoveAll();

	//copy the new result set to the result list
	//filter if this is the last time here...
	if (retVal)
	{
		POSITION t_pos = t_AddedResultObjs.GetHeadPosition();

		while (t_pos)
		{
			IWbemClassObject *t_vobj = a_ResultObjs.GetNext(t_pos);

			if (t_vobj)
			{
				t_vobj->AddRef();
				a_ResultObjs.AddTail(t_vobj);
			}
		}
	}

	t_AddedResultObjs.RemoveAll();
	return retVal;
}

#else //VP_PERFORMANT_JOINS

BOOL WbemTaskObject::CreateAndIndicateJoins(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle)
{
	BOOL retVal = TRUE;
	UINT isize = 1;

	if (m_ObjSinkArray.GetSize() != m_SourceArray.GetSize())
	{
		retVal = FALSE;
		a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"A source query failed or was not executed therefore a join could not be created." );
	}

	//calculate the size of the results
	for (UINT x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if ((m_ObjSinkArray[x] == NULL) || FAILED(m_ObjSinkArray[x]->GetResult()) || !m_ObjSinkArray[x]->m_ObjArray.GetSize())
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;

			if ( FAILED ( m_ObjSinkArray[x]->GetResult() ) )
			{
				a_ErrorObject.SetWbemStatus ( ( WBEMSTATUS ) m_ObjSinkArray[x]->GetResult() ) ;
			}
			else
			{
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			}

			a_ErrorObject.SetMessage ( L"A source query failed or returned no instances." );
			break;
		}

		if ((0xFFFFFFFF/isize) >= m_ObjSinkArray[x]->m_ObjArray.GetSize())
		{
			isize = isize * m_ObjSinkArray[x]->m_ObjArray.GetSize();
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Too many possible combinations for join. Provider not capable." );
		}
	}

	if (retVal)
	{
		IWbemClassObject** objs = new IWbemClassObject*[m_ObjSinkArray.GetSize()];
		IWbemClassObject* res_obj = NULL;
		int num_res_objs = 0;

		for (UINT i = 0; i < isize; i++)
		{
			UINT t_iDenom = 1;

			for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
			{
				UINT isz = m_ObjSinkArray[x]->m_ObjArray.GetSize();
				objs[x] = m_ObjSinkArray[x]->m_ObjArray[(i/t_iDenom) % isz];
				t_iDenom = t_iDenom * isz;
			}

			BOOL t_bRes = CreateAndIndicate(a_ErrorObject, objs, &res_obj);
			retVal = retVal && t_bRes;

			if (res_obj != NULL)
			{
				num_res_objs++;

				if (a_bSingle)
				{
					if (num_res_objs > 1)
					{
						res_obj->Release();
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Too many view instances can be created." ) ;
						break;
					}
				}
				else
				{
					if (m_bIndicate)
					{
						m_NotificationHandler->Indicate(1, &res_obj);
						res_obj->Release();
						res_obj = NULL;
					}
				}
			}
		}

		if (a_bSingle)
		{
			if (num_res_objs == 1)
			{
				if (m_bIndicate)
				{
					m_NotificationHandler->Indicate(1, &res_obj);
				}

				res_obj->Release();
			}
		}

		delete [] objs;
	}

	for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();

	return retVal;
}

//for joins
BOOL WbemTaskObject::CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, IWbemClassObject ** pSrcs, IWbemClassObject **pOut)
{
	BOOL retVal = TRUE;
	wchar_t** clsA = m_JoinOnArray.GetAClasses();
	wchar_t** clsB = m_JoinOnArray.GetBClasses();
	wchar_t** prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** prpsB = m_JoinOnArray.GetBProperties();
	UINT* ops = m_JoinOnArray.GetOperators();

	for (int x = 0; retVal && (x < m_JoinOnArray.GetCount()); x++)
	{
		int iA;
		int iB;

		m_ClassToIndexMap.Lookup(clsA[x], iA);
		m_ClassToIndexMap.Lookup(clsB[x], iB);

		VARIANT vA;
		CIMTYPE cA;

		if ( SUCCEEDED(pSrcs[iA]->Get(prpsA[x], 0, &vA, &cA, NULL)) )
		{
			VARIANT vB;
			CIMTYPE cB;

			if ( SUCCEEDED(pSrcs[iB]->Get(prpsB[x], 0, &vB, &cB, NULL)) )
			{
				if (cA == cB)
				{
					if (ops[x] == CJoinOnQualifierArray::EQUALS_OPERATOR)
					{
						retVal = CompareSimplePropertyValues(&vA, &vB, cA);
					}
					else //NOT_EQUALS
					{
						retVal = !CompareSimplePropertyValues(&vA, &vB, cA);
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Join properties have different CIM types." ) ;
				}

				VariantClear(&vB);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
			}

			VariantClear(&vA);
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
		}
	}

	if (retVal)
	{
		BOOL bIndicate = TRUE;
		IWbemClassObject* viewObj = NULL;
		
		if ( SUCCEEDED(m_ClassObject->SpawnInstance(0, &viewObj)) )
		{
			POSITION propPos = m_PropertyMap.GetStartPosition();

			while ((propPos != NULL) && bIndicate)
			{
				CStringW propName;
				CPropertyQualifierItem* propProps;
				m_PropertyMap.GetNextAssoc(propPos, propName, propProps);
				VARIANT v;
				BOOL bSetProp = FALSE;
				CIMTYPE c;
				
				for (int x = 0; !bSetProp && (x < propProps->m_SrcPropertyNames.GetSize()); x++)
				{
					if (!propProps->m_SrcPropertyNames[x].IsEmpty())
					{
						bSetProp =  TRUE;

						if ( SUCCEEDED(pSrcs[x]->Get(propProps->m_SrcPropertyNames[x], 0, &v, &c, NULL)) )
						{
							if (((v.vt == VT_NULL) || (v.vt == VT_EMPTY)) && propProps->IsKey())
							{
								if (retVal)
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_ErrorObject.SetMessage ( L"View key value in source instance is NULL" );
								}

								bIndicate = FALSE;
							}
							else
							{
								if ( FAILED(viewObj->Put(propName, 0, &v, c)) )
								{
									if (retVal)
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Failed to put property" );
									}

									if (propProps->IsKey())
									{
										bIndicate = FALSE;
									}
								}
							}

							VariantClear(&v);
						}
						else
						{
							if (retVal)
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
							}
						}
					}
				}
			}

			if (bIndicate)
			{
				retVal = PostFilter(viewObj);

				if (retVal)
				{
					viewObj->AddRef();
					*pOut = viewObj;
				}
			}

			viewObj->Release();
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"WBEM API FAILURE:- Failed to spawn an instance of the view class." ) ;
		}
	}

	return retVal;
}

#endif //VP_PERFORMANT_JOINS

BOOL WbemTaskObject::PostFilter(IWbemClassObject* a_pObj)
{
	BOOL retVal = TRUE;

	if ( (m_RPNPostFilter != NULL) && (m_RPNPostFilter->nNumTokens != 0) )
	{
		BOOL* t_bStack = new BOOL[m_RPNPostFilter->nNumTokens];
		DWORD t_bCnt = 0;

		for (int i = 0; retVal && (i < m_RPNPostFilter->nNumTokens); i++)
		{
			switch (m_RPNPostFilter->pArrayOfTokens[i].nTokenType)
			{
			case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
				{
					t_bStack[t_bCnt] = EvaluateToken(a_pObj, m_RPNPostFilter->pArrayOfTokens[i]);
					t_bCnt++;
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_AND:
				{
					if (t_bCnt > 1)
					{
						t_bStack[t_bCnt - 2] = t_bStack[t_bCnt - 1] && t_bStack[t_bCnt - 2];
						t_bCnt--;
					}
					else
					{
						retVal = FALSE;
					}
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_OR:
				{
					if (t_bCnt > 1)
					{
						t_bStack[t_bCnt - 2] = t_bStack[t_bCnt - 1] || t_bStack[t_bCnt - 2];
						t_bCnt--;
					}
					else
					{
						retVal = FALSE;
					}
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
				{
					if (t_bCnt > 0)
					{
						t_bStack[t_bCnt - 1] = !t_bStack[t_bCnt - 1];
					}
				}
				break;

				default:
				{
				}
				break;
			}
		}

		if (retVal)
		{
			retVal = t_bStack[t_bCnt - 1];
		}

		delete [] t_bStack;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\vp_core_qengine.cpp ===
//***************************************************************************

//

//  VP_CORE_QENGINE.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains taskobject implementation copied from winmgmt core code

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>
#include <wbemtime.h>


//======================================================
//ReadI64, ReadUI64 and bAreWeLocal "stolen" from 
//Core's common\genutil.cpp. Used without modification.
//======================================================

BOOL ReadI64(LPCWSTR wsz, __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }
        
        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}

BOOL ReadUI64(LPCWSTR wsz, unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}

BOOL bAreWeLocal(WCHAR * pServerMachine)
{
	BOOL bRet = FALSE;
	if((pServerMachine == NULL) || (*pServerMachine == L'\0'))
		return TRUE;
	if(!_wcsicmp(pServerMachine,L"."))
		return TRUE;

	TCHAR tcMyName[MAX_PATH];
	DWORD dwSize = MAX_PATH;
	if(!GetComputerName(tcMyName,&dwSize))
		return FALSE;

#ifdef UNICODE
	bRet = !_wcsicmp(tcMyName,pServerMachine);
#else
	WCHAR wWide[MAX_PATH];
	mbstowcs(wWide, tcMyName, MAX_PATH-1);
	bRet = !_wcsicmp(wWide,pServerMachine);
#endif
	return bRet;
}


//============================================================
//This class has been created as a Variant garbage collector
//to mimick the use of a garbage collector in EvaluateToken.
//============================================================

class CVariantClear
{
private:
	VARIANT* m_variant;
public:
	CVariantClear(VARIANT* v) {m_variant = v;}
	~CVariantClear() { VariantClear(m_variant); }
};


//==================================================================
//EvaluateToken "stolen" from core's coredll\qengine.cpp and 
//modified so as not to return INVALID, or use the core's
//QL_LEVEL_1_TOKEN or the core's method of normalising a reference.
//==================================================================

BOOL WbemTaskObject::EvaluateToken(
	IWbemClassObject *pTestObj,
	SQL_LEVEL_1_TOKEN &Tok
	)
{
	VARIANT PropVal;
	VariantInit(&PropVal);
	
	
	//Use the garbage collector class
	//===============================

	CVariantClear clv(&PropVal);

	CIMTYPE cimType;
	HRESULT hRes;

	
	// Special-case 'this'
	// ===================

	if(_wcsicmp(Tok.pPropertyName, L"__THIS") == 0)
	{
		cimType = CIM_OBJECT;
		V_VT(&PropVal) = VT_UNKNOWN;
		hRes = pTestObj->QueryInterface(IID_IWbemClassObject,
											(void**)&V_UNKNOWN(&PropVal));
	}
	else
	{
		hRes = pTestObj->Get(Tok.pPropertyName, 0, &PropVal, &cimType, NULL);
	}

	if (FAILED(hRes))
		return FALSE;

	
	// Handle NULLs
	// ============

	if(V_VT(&PropVal) == VT_NULL)
	{
		if(V_VT(&Tok.vConstValue) == VT_NULL)
		{
			if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
				return TRUE;
			else if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
				return FALSE;
			else
				return FALSE;	//INVALID;
		}
		else
		{
			if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
				return FALSE;
			else if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
				return TRUE;
			else
				return FALSE;	//INVALID;
		}
	}
	else if(V_VT(&Tok.vConstValue) == VT_NULL)
	{
		if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
			return FALSE;
		else if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
			return TRUE;
		else
			return FALSE;	//INVALID;
	}

	// Handle references
	// =================

	if(cimType == CIM_REFERENCE)
	{
		// This is a reference. The only operators allowed are = and !=
		// ============================================================

		//Use the local normalisation method, not core's....
#if 0
		LPWSTR va = CQueryEngine::NormalizePath(V_BSTR(&PropVal), pNs);
		LPWSTR vb = CQueryEngine::NormalizePath(V_BSTR(&Tok.vConstValue), pNs);
#else
		LPWSTR va = NULL;
		LPWSTR vb = NULL;

		if (m_ServerWrap == NULL)
		{
			CWbemServerWrap *t_SWrap = new CWbemServerWrap(m_Serv, NULL, NULL);
			t_SWrap->AddRef();
			va = NormalisePath(V_BSTR(&PropVal), &t_SWrap);

			if (t_SWrap)
			{
				vb = NormalisePath(V_BSTR(&Tok.vConstValue), &t_SWrap);
			}

			if (t_SWrap)
			{
				t_SWrap->Release();
			}
		}
		else
		{
			if (m_ServerWrap)
			{
				va = NormalisePath(V_BSTR(&PropVal), &m_ServerWrap);

				if (m_ServerWrap)
				{
					vb = NormalisePath(V_BSTR(&Tok.vConstValue), &m_ServerWrap);
				}
			}
		}
#endif

		if(va == NULL || vb == NULL)
		{
			return FALSE;	//INVALID;
		}

		int nRet;
		switch (Tok.nOperator)
		{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
			nRet = (_wcsicmp(va,vb) == 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
			nRet = (_wcsicmp(va, vb) != 0);
			break;
		default:
			nRet = FALSE;	//INVALID;
			break;
		}

		delete [] va;
		delete [] vb;

		return nRet;
	}


	// Check if ISA is used
	// ====================

//ISA operators not identified by the SQL parser the provider has...
//===================================================================
#if 0

	if(Tok.nOperator == QL1_OPERATOR_ISA ||
	   Tok.nOperator == QL1_OPERATOR_ISNOTA ||
	   Tok.nOperator == QL1_OPERATOR_INV_ISA ||
	   Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
	{
		// Account for inversion
		// =====================

		VARIANT* pv1;
		VARIANT* pv2;
		int bNeedDerived;

		if(Tok.nOperator == QL1_OPERATOR_ISA ||
		   Tok.nOperator == QL1_OPERATOR_ISNOTA)
		{
			pv2 = &Tok.vConstValue;
			pv1 = &PropVal;
			bNeedDerived = (Tok.nOperator == QL1_OPERATOR_ISA);
		}
		else
		{
			pv1 = &Tok.vConstValue;
			pv2 = &PropVal;
			bNeedDerived = (Tok.nOperator == QL1_OPERATOR_INV_ISA);
		}

		// The second argument has to be a string
		// ======================================

		if(V_VT(pv2) != VT_BSTR)
		{
			return INVALID;
		}

		BSTR strParentClass = V_BSTR(pv2);

		// The first argument has to be an object or a string
		// ==================================================

		BOOL bDerived;
		if(V_VT(pv1) == VT_EMBEDDED_OBJECT)
		{
			IWbemClassObject* pObj = (IWbemClassObject*)V_EMBEDDED_OBJECT(pv1);
			bDerived = (pObj->InheritsFrom(strParentClass) == WBEM_S_NO_ERROR);
		}
		else if(V_VT(pv1) == VT_BSTR)
		{
			// TBD
			// ===

			return INVALID;
		}
		else
		{
			return INVALID;
		}

		// Now that we have bDerived, see if it matches the requirement
		// ============================================================

		if(bDerived == bNeedDerived)
			return TRUE;
		else
			return FALSE;

	}
#endif

	// Perform UINT32 workaround
	// =========================

	if((cimType == CIM_UINT32) && (V_VT(&PropVal) == VT_I4))
	{
		DWORD dwVal = (DWORD)V_I4(&PropVal);
		WCHAR wszVal[20];
		swprintf(wszVal, L"%lu", dwVal);
		V_VT(&PropVal) = VT_BSTR;
		V_BSTR(&PropVal) = SysAllocString(wszVal);
	}

	if(((cimType == CIM_SINT64) ||
			 (cimType == CIM_UINT64) ||
			 (cimType == CIM_UINT32)) &&
		(V_VT(&Tok.vConstValue) != VT_NULL) && (V_VT(&PropVal) != VT_NULL))
	{
		// We have a 64-bit comparison where both sides are present.
		// =========================================================

		hRes = VariantChangeType(&Tok.vConstValue, &Tok.vConstValue, 0,
									VT_BSTR);
		if(FAILED(hRes))
		{
			return FALSE;	//INVALID;
		}

		if(cimType == CIM_UINT64)
		{
			unsigned __int64 ui64Prop, ui64Const;

			if(!ReadUI64(V_BSTR(&PropVal), ui64Prop))
				return FALSE;	//INVALID;

			if(!ReadUI64(V_BSTR(&Tok.vConstValue), ui64Const))
				return FALSE;	//INVALID;

			switch (Tok.nOperator)
			{
				case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (ui64Prop == ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
					return (ui64Prop != ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
					return (ui64Prop >= ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
					return (ui64Prop <= ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
					return (ui64Prop < ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
					return (ui64Prop > ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_LIKE: return (ui64Prop == ui64Const);
			}
			return FALSE;	//INVALID;
		}
		else
		{
			__int64 i64Prop, i64Const;

			if(!ReadI64(V_BSTR(&PropVal), i64Prop))
				return FALSE;	//INVALID;

			if(!ReadI64(V_BSTR(&Tok.vConstValue), i64Const))
				return FALSE;	//INVALID;

			switch (Tok.nOperator)
			{
				case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
				case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
					return (i64Prop != i64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
					return (i64Prop >= i64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
					return (i64Prop <= i64Const);
				case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
					return (i64Prop < i64Const);
				case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
					return (i64Prop > i64Const);
				case SQL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
			}
			return FALSE;	//INVALID;
		}
	}

	if((cimType == CIM_CHAR16) &&
		(V_VT(&Tok.vConstValue) == VT_BSTR) && (V_VT(&PropVal) != VT_NULL))
	{
		// Coerce strings correctly
		// ========================

		BSTR str = V_BSTR(&Tok.vConstValue);
		if(wcslen(str) != 1)
			return FALSE;	//INVALID;

		short va = V_I2(&PropVal);
		short vb = str[0];

		switch (Tok.nOperator)
		{
			case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
			case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
			case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
			case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
			case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
		}

		return FALSE;	//INVALID;
	}

	if((cimType == CIM_DATETIME) &&
			(V_VT(&Tok.vConstValue) == VT_BSTR) && (V_VT(&PropVal) == VT_BSTR))
	{
		WBEMTime tConst(Tok.vConstValue.bstrVal);
		WBEMTime tProp(PropVal.bstrVal);

		__int64 i64Const = tConst.GetTime();
		__int64 i64Prop = tProp.GetTime();

		if ((i64Const == INVALID_TIME) || (i64Prop == INVALID_TIME))
		{
			return FALSE;	//INVALID;
		}

		switch (Tok.nOperator)
		{
			case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
			case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
				return (i64Prop != i64Const);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
				return (i64Prop >= i64Const);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
				return (i64Prop <= i64Const);
			case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
				return (i64Prop < i64Const);
			case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
				return (i64Prop > i64Const);
			case SQL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
		}
	}

	// Coerce types to match.
	// ======================

	VARIANT ConstVal;
	VariantInit(&ConstVal);

	if (FAILED(VariantCopy(&ConstVal, &Tok.vConstValue)))
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

	if(V_VT(&Tok.vConstValue) != VT_NULL && V_VT(&PropVal) != VT_NULL)
	{
		hRes = VariantChangeType(&ConstVal, &ConstVal, 0, V_VT(&PropVal));
		if(FAILED(hRes))
		{
			return FALSE;	//INVALID;
		}
	}

	switch (V_VT(&ConstVal))
	{
		case VT_NULL:
			return FALSE;	//INVALID; // handled above

		case VT_I4:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				LONG va = V_I4(&PropVal);
				LONG vb = V_I4(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_I2:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				short va = V_I2(&PropVal);
				short vb = V_I2(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_UI1:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				BYTE va = V_I1(&PropVal);
				BYTE vb = V_I1(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_BSTR:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
				LPWSTR vb = (LPWSTR) V_BSTR(&ConstVal);

				int retCode = 0;
				BOOL bDidIt = TRUE;

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL:
						retCode = ( _wcsicmp(va,vb) == 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
						retCode = (_wcsicmp(va, vb) != 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
						retCode = (_wcsicmp(va, vb) >= 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
						retCode = (_wcsicmp(va, vb) <= 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
						retCode = (_wcsicmp(va, vb) < 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
						retCode = (_wcsicmp(va, vb) > 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_LIKE:
						retCode = (_wcsicmp(va,vb) == 0);
						break;
					default:
						bDidIt = FALSE;
						break;
				}
				VariantClear(&ConstVal);
				if (bDidIt)
				{
					return retCode;
				}
			}
			break;

		case VT_R8:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				double va = V_R8(&PropVal);
				double vb = V_R8(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_R4:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				float va = V_R4(&PropVal);
				float vb = V_R4(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_BOOL:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				VARIANT_BOOL va = V_BOOL(&PropVal);
				if(va != VARIANT_FALSE) va = VARIANT_TRUE;
				VARIANT_BOOL vb = V_BOOL(&ConstVal);
				if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;
	}

	return FALSE;
}


//=============================================
//NormalisePath replaces core's version, This 
//returns the full path including server name.
//=============================================

wchar_t* WbemTaskObject::NormalisePath(wchar_t *wszObjectPath, CWbemServerWrap **pNSWrap)
{
	CObjectPathParser objPathparser;
	ParsedObjectPath* pParsedPath;

	if ( (objPathparser.Parse(wszObjectPath, &pParsedPath) != CObjectPathParser::NoError) ||
		(!pParsedPath->IsObject()) )
	{
		return NULL;
	}

	if(pParsedPath->m_pClass == NULL)
	{
		return NULL;
	}

	// Start off with the server and namespace part

	CStringW wsNormal(L"\\\\");

	if(bAreWeLocal(pParsedPath->m_pServer))
	{
		wsNormal += L".";
	}
	else
	{
		wsNormal += pParsedPath->m_pServer;
	}

	wsNormal += L"\\";
	LPWSTR pPath = pParsedPath->GetNamespacePart();
	BOOL bGetNS = FALSE;
	CWbemServerWrap *pServ = NULL;

	if(pPath)
	{
		wsNormal += pPath;
		Connect(pPath, &pServ);
	}
	else
	{
		bGetNS = TRUE;
	}

	if (pPath != NULL)
	{
		delete [] pPath;
	}

	// Find the parent that defined the key
	// ====================================

	//ConfigMgr::GetDbPtr()->FindKeyRoot(pNs->GetNamespaceId(), pParsedPath->m_pClass, &pRootClass);
	
	wchar_t *nsPath = NULL;
	wchar_t *pRootClass = NULL;
	
	if (pServ)
	{
		pRootClass = GetClassWithKeyDefn(&pServ, pParsedPath->m_pClass, bGetNS, &nsPath);

		if (pServ)
		{
			pServ->Release();
		}
	}
	else
	{
		pRootClass = GetClassWithKeyDefn(pNSWrap, pParsedPath->m_pClass, bGetNS, &nsPath);
	}

	if(pRootClass != NULL)
	{
		if (bGetNS)
		{
			wsNormal += nsPath;
			delete [] nsPath;
		}

		wsNormal += L":";
		wsNormal += pRootClass;
	}
	else
	{
		delete [] pParsedPath;
		return NULL;
	}

	// Convert this part to upper-case
	// ===============================

	wsNormal.MakeUpper();

	LPWSTR wszKey = pParsedPath->GetKeyString();
	wsNormal += L"=";
	wsNormal += wszKey;
	delete [] wszKey;
	delete pParsedPath;
	delete [] pRootClass;
	wchar_t* retVal = new wchar_t[wsNormal.GetLength() + 1];
	wcscpy(retVal, wsNormal);
	return retVal;
}

//===================================================================
//GetClassWithKeyDefn replaces core's version of FindKeyRoot. This 
//returns the class name that contains the key definitions and 
//optionally the path of the namespaces that the class is contained.
//===================================================================

wchar_t* WbemTaskObject::GetClassWithKeyDefn(
	CWbemServerWrap **pNS,
	BSTR classname,
	BOOL bGetNS,
	wchar_t **nsPath,
	BOOL bCheckSingleton
)
{
	if (bGetNS)
	{
		if (nsPath == NULL)
		{
			return NULL;
		}
		else
		{
			*nsPath = NULL;
		}
	}

	wchar_t *retVal = NULL;
	IWbemClassObject *pObj = NULL;

	IWbemServices *ptmpServ = (*pNS)->GetServerOrProxy();
	HRESULT hr = WBEM_E_FAILED;

	if (ptmpServ)
	{
		hr = ptmpServ->GetObject(classname, 0, m_Ctx, &pObj, NULL);

		if ( FAILED(hr) && (HRESULT_FACILITY(hr) != FACILITY_ITF) && (*pNS)->IsRemote())
		{
			if ( SUCCEEDED(UpdateConnection(pNS, &ptmpServ)) )
			{
				if (ptmpServ)
				{
					hr = ptmpServ->GetObject(classname, 0, m_Ctx, &pObj, NULL);
				}
			}
		}

		if (ptmpServ)
		{
			(*pNS)->ReturnServerOrProxy(ptmpServ);
		}
	}

	if ( SUCCEEDED(hr) )
	{
		BOOL bContinue = TRUE;
		VARIANT v;

		if (bGetNS)
		{
			VariantInit(&v);
			bContinue = FALSE;

			if ( SUCCEEDED(pObj->Get(WBEM_PROPERTY_NSPACE, 0, &v, NULL, NULL)) )
			{
				if (v.vt == VT_BSTR)
				{
					*nsPath = UnicodeStringDuplicate(v.bstrVal);
					bContinue = TRUE;
				}
			}

			VariantClear(&v);
		}

		if (bContinue && bCheckSingleton)
		{
			IWbemQualifierSet *pQuals = NULL;
			bContinue = FALSE;

			if ( SUCCEEDED(pObj->GetQualifierSet(&pQuals)) )
			{
				VariantInit(&v);

				if (SUCCEEDED(pQuals->Get(VIEW_QUAL_SNGLTN, 0, &v, NULL)) )
				{
					if (v.vt == VT_BOOL)
					{
						if (v.boolVal == VARIANT_TRUE)
						{
							retVal = UnicodeStringDuplicate(classname);
						}
					}
				}
				else
				{
					bContinue = TRUE;
				}

				VariantClear(&v);
				pQuals->Release();
			}
		}

		if (bContinue)
		{
			SAFEARRAY *t_pArray = NULL;

			if ( SUCCEEDED(pObj->GetNames(NULL, WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_LOCAL_ONLY,
											NULL, &t_pArray)) )
			{
				if (SafeArrayGetDim(t_pArray) == 1)
				{
					if (0 == t_pArray->rgsabound[0].cElements)
					{
						VariantInit(&v);
						bContinue = FALSE;

						if ( SUCCEEDED(pObj->Get(WBEM_PROPERTY_SCLASS, 0, &v, NULL, NULL)) )
						{
							if (v.vt == VT_BSTR)
							{
								retVal = GetClassWithKeyDefn(pNS, v.bstrVal, FALSE, NULL, FALSE);
							}
						}

						VariantClear(&v);
					}
					else
					{
						retVal = UnicodeStringDuplicate(classname);
					}
				}

				SafeArrayDestroy(t_pArray);
			}
		}

		pObj->Release();
	}
	
	if ((retVal == NULL) && bGetNS && (*nsPath != NULL))
	{
		delete [] *nsPath;
		*nsPath = NULL;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\include\vpcfac.h ===
//***************************************************************************

//

//  VPCFAC.H

//

//  Module: WBEM VIEW PROVIDER

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPCFAC_H
#define _VIEW_PROV_VPCFAC_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for the event provider.

class CViewProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CViewProvClassFactory () ;
    ~CViewProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP LockServer ( BOOL ) ;
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );

};

#endif //_VIEW_PROV_VPCFAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\include\vpdefs.h ===
//***************************************************************************

//

//  VPDEFS.H

//

//  Module: WBEM VIEW PROVIDER

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPDEFS_H
#define _VIEW_PROV_VPDEFS_H

#define VP_QUERY_TIMEOUT		3600000	//1 hour timeout
#define VP_CONNECTION_TIMEOUT	1200000	//20 minute timeout

#define HKEYCLASSES					_T("SOFTWARE\\Classes\\")
#define WBEM_CLASS_EXTENDEDSTATUS	L"__ExtendedStatus" 
#define WBEM_QUERY_LANGUAGE_SQL1	L"WQL"

#define WBEM_PROPERTY_CLASS				L"__CLASS"
#define WBEM_PROPERTY_SCLASS			L"__SUPERCLASS"
#define WBEM_PROPERTY_DERIVATION		L"__DERIVATION"
#define WBEM_PROPERTY_RELPATH			L"__RELPATH"
#define WBEM_PROPERTY_NSPACE			L"__NAMESPACE"
#define WBEM_PROPERTY_PATH				L"__PATH"
#define WBEM_PROPERTY_SERVER			L"__SERVER"
#define WBEM_PROPERTY_STATUSCODE		L"StatusCode"
#define WBEM_PROPERTY_PROVSTATUSCODE	L"ProvStatusCode"
#define WBEM_PROPERTY_PROVSTATUSMESSAGE	L"Description"

#define ENUM_INST_QUERY_START	L"select * from "
#define ENUM_INST_QUERY_MID		L" where __CLASS = \""

#define META_CLASS_QUERY_START	L"select * from meta_class where __this isa \""
#define META_CLASS_QUERY_MID	L"\" AND __class = \""

#define END_QUOTE		L"\""
#define NS_DELIMIT		L"::"

//Qualifiers
#define VIEW_QUAL_SOURCES		L"ViewSources"
#define VIEW_QUAL_NAMESPACES	L"ViewSpaces"
#define VIEW_QUAL_UNION			L"Union"
#define VIEW_QUAL_JOIN			L"JoinOn"
#define VIEW_QUAL_PROVIDER		L"provider"
#define VIEW_QUAL_PROPERTY		L"PropertySources"
#define VIEW_QUAL_METHOD		L"MethodSource"
#define VIEW_QUAL_FILTER		L"PostJoinFilter"
#define VIEW_QUAL_ENUM_CLASS	L"EnumerateClasses"
#define VIEW_QUAL_HIDDEN		L"HiddenDefault"
#define VIEW_QUAL_KEY			L"Key"
#define VIEW_QUAL_ASSOC			L"Association"
#define VIEW_QUAL_SNGLTN		L"Singleton"
#define VIEW_QUAL_TYPE			L"Cimtype"
#define VIEW_QUAL_STATIC		L"Static"
#define VIEW_QUAL_DIRECT		L"Direct"


//Default key values
#define VIEW_KEY_BOOL_VAL		VARIANT_FALSE
#define VIEW_KEY_NUMBER_VAL		0
#define VIEW_KEY_64_VAL			L"0"
#define VIEW_KEY_STRING_VAL		L"DefaultUnionValue"
#define VIEW_KEY_DATE_VAL		L"20000101000000.000000+000"

#define MAX_QUERIES			32

// {AA70DDF4-E11C-11d1-ABB0-00C04FD9159E}
DEFINE_GUID(CLSID_CViewProviderClassFactory, 
0xaa70ddf4, 0xe11c, 0x11d1, 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);


class CFreeBuff
{
private:

	void *m_buff;

public:

		CFreeBuff(void *buff) : m_buff(buff) {}

	void SetBuff(void *buff) { m_buff = buff; } 
	
		~CFreeBuff() { free (m_buff); }
};

#endif //_VIEW_PROV_VPDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\include\vpserv.h ===
//***************************************************************************

//

//  VPSERV.H

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the WBEM services interfaces

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPSERV_H
#define _VIEW_PROV_VPSERV_H

typedef 
enum tag_WBEMPROVSTATUS
{

	WBEM_PROV_NO_ERROR							= 0,
	WBEM_PROV_S_NO_ERROR							= 0,
	WBEM_PROV_S_NO_MORE_DATA						= 0x40001,
	WBEM_PROV_S_ALREADY_EXISTS					= WBEM_PROV_S_NO_MORE_DATA + 1,
	WBEM_PROV_S_NOT_FOUND						= WBEM_PROV_S_ALREADY_EXISTS + 1,
	WBEM_PROV_S_RESET_TO_DEFAULT					= WBEM_PROV_S_NOT_FOUND + 1,
	WBEM_PROV_E_FAILED							= 0x80041001,
	WBEM_PROV_E_NOT_FOUND						= WBEM_PROV_E_FAILED + 1,
	WBEM_PROV_E_ACCESS_DENIED					= WBEM_PROV_E_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_FAILURE					= WBEM_PROV_E_ACCESS_DENIED + 1,
	WBEM_PROV_E_TYPE_MISMATCH					= WBEM_PROV_E_PROVIDER_FAILURE + 1,
	WBEM_PROV_E_OUT_OF_MEMORY					= WBEM_PROV_E_TYPE_MISMATCH + 1,
	WBEM_PROV_E_INVALID_CONTEXT					= WBEM_PROV_E_OUT_OF_MEMORY + 1,
	WBEM_PROV_E_INVALID_PARAMETER				= WBEM_PROV_E_INVALID_CONTEXT + 1,
	WBEM_PROV_E_NOT_AVAILABLE					= WBEM_PROV_E_INVALID_PARAMETER + 1,
	WBEM_PROV_E_CRITICAL_ERROR					= WBEM_PROV_E_NOT_AVAILABLE + 1,
	WBEM_PROV_E_INVALID_STREAM					= WBEM_PROV_E_CRITICAL_ERROR + 1,
	WBEM_PROV_E_NOT_SUPPORTED					= WBEM_PROV_E_INVALID_STREAM + 1,
	WBEM_PROV_E_INVALID_SUPERCLASS				= WBEM_PROV_E_NOT_SUPPORTED + 1,
	WBEM_PROV_E_INVALID_NAMESPACE				= WBEM_PROV_E_INVALID_SUPERCLASS + 1,
	WBEM_PROV_E_INVALID_OBJECT					= WBEM_PROV_E_INVALID_NAMESPACE + 1,
	WBEM_PROV_E_INVALID_CLASS					= WBEM_PROV_E_INVALID_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_FOUND				= WBEM_PROV_E_INVALID_CLASS + 1,
	WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION	= WBEM_PROV_E_PROVIDER_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_LOAD_FAILURE			= WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_PROV_E_INITIALIZATION_FAILURE			= WBEM_PROV_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_PROV_E_TRANSPORT_FAILURE				= WBEM_PROV_E_INITIALIZATION_FAILURE + 1,
	WBEM_PROV_E_INVALID_OPERATION				= WBEM_PROV_E_TRANSPORT_FAILURE + 1,
	WBEM_PROV_E_INVALID_QUERY					= WBEM_PROV_E_INVALID_OPERATION + 1,
	WBEM_PROV_E_INVALID_QUERY_TYPE				= WBEM_PROV_E_INVALID_QUERY + 1,
	WBEM_PROV_E_ALREADY_EXISTS					= WBEM_PROV_E_INVALID_QUERY_TYPE + 1,
	WBEM_PROV_E_OVERRIDE_NOT_ALLOWED				= WBEM_PROV_E_ALREADY_EXISTS + 1,
	WBEM_PROV_E_PROPAGATED_QUALIFIER				= WBEM_PROV_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_PROV_E_UNEXPECTED						= WBEM_PROV_E_PROPAGATED_QUALIFIER + 1,
	WBEM_PROV_E_ILLEGAL_OPERATION				= WBEM_PROV_E_UNEXPECTED + 1,
	WBEM_PROV_E_CANNOT_BE_KEY					= WBEM_PROV_E_ILLEGAL_OPERATION + 1,
	WBEM_PROV_E_INCOMPLETE_CLASS					= WBEM_PROV_E_CANNOT_BE_KEY + 1,
	WBEM_PROV_E_INVALID_SYNTAX					= WBEM_PROV_E_INCOMPLETE_CLASS + 1,
	WBEM_PROV_E_NONDECORATED_OBJECT				= WBEM_PROV_E_INVALID_SYNTAX + 1,
	WBEM_PROV_E_READ_ONLY						= WBEM_PROV_E_NONDECORATED_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_CAPABLE				= WBEM_PROV_E_READ_ONLY + 1,
	WBEM_PROV_E_CLASS_HAS_CHILDREN				= WBEM_PROV_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_PROV_E_CLASS_HAS_INSTANCES				= WBEM_PROV_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_PROV_E_INVALID_PROPERTY					= WBEM_PROV_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_PROV_E_INVALID_QUALIFIER				= WBEM_PROV_E_INVALID_PROPERTY + 1 ,
	WBEM_PROV_E_INVALID_PATH						= WBEM_PROV_E_INVALID_QUALIFIER + 1 ,
	WBEM_PROV_E_INVALID_PATHKEYPARAMETER			= WBEM_PROV_E_INVALID_PATH + 1 ,
	WBEM_PROV_E_MISSINGPATHKEYPARAMETER 			= WBEM_PROV_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_INVALID_KEYORDERING				= WBEM_PROV_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER		= WBEM_PROV_E_INVALID_KEYORDERING + 1 ,
	WBEM_PROV_E_MISSINGKEY						= WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORT				= WBEM_PROV_E_MISSINGKEY + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORTCONTEXT			= WBEM_PROV_E_INVALID_TRANSPORT + 1 ,
	WBEM_PROV_E_TRANSPORT_ERROR					= WBEM_PROV_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_PROV_E_TRANSPORT_NO_RESPONSE			= WBEM_PROV_E_TRANSPORT_ERROR + 1 ,
	WBEM_PROV_E_NOWRITABLEPROPERTIES				= WBEM_PROV_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_PROV_E_NOREADABLEPROPERTIES				= WBEM_PROV_E_NOWRITABLEPROPERTIES + 1 , 
	WBEM_PROV_E_TOOMANYRESULTSRETURNED				= WBEM_PROV_E_NOREADABLEPROPERTIES + 1 

} WBEMPROVSTATUS;

wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;
wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;

class CWbemProxyServerWrap
{
public:

	BOOL m_InUse;
	IWbemServices *m_Proxy;

	CWbemProxyServerWrap(IWbemServices *a_Proxy) : m_Proxy(NULL), m_InUse(FALSE) {m_Proxy = a_Proxy;}
	CWbemProxyServerWrap() : m_Proxy(NULL), m_InUse(FALSE) {}
};

template <> inline void AFXAPI DestructElements<CWbemProxyServerWrap> (CWbemProxyServerWrap* ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i].m_Proxy != NULL)
		{
			ptr_e[i].m_Proxy->Release();
		}
	}
}

class CWbemServerWrap
{
private:

	LONG m_ref;
	CList<CWbemProxyServerWrap, CWbemProxyServerWrap &> m_ProxyPool;
	IWbemServices *m_MainServ;
	wchar_t *m_Principal;
	BSTR m_Path;
	CCriticalSection m_Lock;

public:

		CWbemServerWrap(IWbemServices *pServ, const wchar_t* prncpl, const wchar_t* path);
	
	ULONG	AddRef();
	ULONG	Release();

	BOOL			IsRemote() { return m_Principal != NULL; }
	const wchar_t*	GetPrincipal() { return m_Principal; }
	BSTR			GetPath() { return m_Path; }
	IWbemServices*	GetServerOrProxy();
	void			ReturnServerOrProxy(IWbemServices *a_pServ);
	void			SetMainServer(IWbemServices *a_pServ);
	BOOL			ProxyBelongsTo(IWbemServices *a_proxy);

		~CWbemServerWrap();
};

template <> inline void AFXAPI  DestructElements<CWbemServerWrap*> (CWbemServerWrap** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

template <> inline void AFXAPI  DestructElements<IWbemServices*> (IWbemServices** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

class CIWbemServMap : public CMap<CStringW, LPCWSTR, CWbemServerWrap*, CWbemServerWrap*>
{
private:

	CCriticalSection m_Lock;


public:

	BOOL Lock() { return m_Lock.Lock(); }
	void EmptyMap();
	BOOL Unlock() { return m_Lock.Unlock(); }
};

class WbemProvErrorObject 
{
private:

	wchar_t *m_provErrorMessage ;
	WBEMPROVSTATUS m_provErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemProvErrorObject () : m_provErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_provErrorStatus ( WBEM_PROV_NO_ERROR ) {} ;
	virtual ~WbemProvErrorObject () { delete [] m_provErrorMessage ; } ;

	void SetStatus ( WBEMPROVSTATUS a_provErrorStatus )
	{
		m_provErrorStatus = a_provErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_provErrorMessage )
	{
		delete [] m_provErrorMessage ;
		m_provErrorMessage = UnicodeStringDuplicate ( a_provErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_provErrorMessage ; } ;
	WBEMPROVSTATUS GetStatus () { return m_provErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;

class CViewProvServ : public IWbemServices, public IWbemProviderInit
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_criticalSection ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;

	wchar_t *m_localeId ;
	BSTR m_UserName;


	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

protected:
public:

	static ProvDebugLog*	sm_debugLog;
	static IUnsecuredApartment* sm_UnsecApp;

	CIWbemServMap	sm_ServerMap;
	IWbemLocator*	sm_Locator;
	CMap<CStringW, LPCWSTR, int, int> sm_OutStandingConnections;
	HANDLE sm_ConnectionMade;

	CViewProvServ () ;
    ~CViewProvServ () ;

	// Implementation
	HRESULT GetLocator(IWbemLocator** ppLoc);

	static HRESULT GetUnsecApp(IUnsecuredApartment** ppLoc);

	IWbemServices *GetServer () ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

#ifndef UNICODE	
	BSTR GetUserName() {return m_UserName;}
#endif

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateExtendedNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	BOOL CreateNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetExtendedNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);
        
} ;

#define DebugOut8(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 8) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugOut4(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 4) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugOut2(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 2) ) \
	{ \
		{a ; } \
	} \
} 


#define DebugOut1(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 1 ) ) \
	{ \
		{a ; } \
	} \
} 


#endif //_VIEW_PROV_VPSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\include\vpquals.h ===
//***************************************************************************

//

//  VPQUALS.H

//

//  Module: WBEM VIEW PROVIDER

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPQUALS_H
#define _VIEW_PROV_VPQUALS_H

//forward definition
class CWbemServerWrap;

CStringW GetStringFromRPN(SQL_LEVEL_1_RPN_EXPRESSION* pRPN, DWORD num_extra,
						 SQL_LEVEL_1_TOKEN* pExtraTokens, BOOL bAllprops = FALSE);

template <> inline BOOL AFXAPI CompareElements<CStringW, LPCWSTR>(const CStringW* pElement1, const LPCWSTR* pElement2)
{
	//return TRUE if equal
	return (pElement1->CompareNoCase(*pElement2) == 0);
}


template <> inline UINT AFXAPI HashKey <LPCWSTR> (LPCWSTR key)
{
	CStringW tmp(key);
	tmp.MakeUpper();
	return HashKeyLPCWSTR((const WCHAR*)tmp);
}

class CSourceQualifierItem : public CObject
{
private:

	CStringW						m_QueryStr;
	SQL_LEVEL_1_RPN_EXPRESSION*	m_RPNExpr;
	IWbemClassObject*			m_pClassObj;
	BOOL						m_isValid;

public:

	//Constructor
		CSourceQualifierItem(wchar_t* qry, IWbemClassObject* obj = NULL);

	//set methods may be called after instance creation
	void SetClassObject(IWbemClassObject* pObj);

	//retrieval of stored members
	BOOL						IsValid() { return m_isValid; }
	SQL_LEVEL_1_RPN_EXPRESSION* GetRPNExpression() { return m_RPNExpr; }
	IWbemClassObject*			GetClassObject();
	CStringW						GetQueryStr() { return m_QueryStr; }
	BSTR						GetClassName();

	//Destructor
		~CSourceQualifierItem();
};


class CNSpaceQualifierItem : public CObject
{
private:

	CWbemServerWrap**	m_ServObjs;
	CStringW*		m_NSPaths;
	UINT			m_Count;
	BOOL			m_Valid;

	HRESULT			m_hrServError;

	void Parse(const wchar_t* ns_path);

public:

	//Constructor
		CNSpaceQualifierItem(const wchar_t* ns_path);

	//set members
	void			SetServerPtrs(CWbemServerWrap** pServs) { m_ServObjs = pServs; }
		
	//retrieval of members
	CWbemServerWrap**	GetServerPtrs() { return m_ServObjs; }
	UINT				GetCount() { return m_Count; }
	CStringW*			GetNamespacePaths() { return m_NSPaths; }
	BOOL				IsValid() { return m_Valid; }

	void				SetServerCreationError ( HRESULT hr )
	{
		m_hrServError = hr;
	}

	HRESULT				GetServerCreationError ()
	{
		HRESULT hr = WBEM_E_FAILED;
		if ( FAILED ( m_hrServError ) )
		{
			hr = m_hrServError;
		}

		return hr;
	}

	//Destructor
		~CNSpaceQualifierItem();

};

class CPropertyQualifierItem
{
private:

	CStringW		m_ViewPropertyName;
	BOOL			m_HiddenDefault;
	BOOL			m_bKey;
	CIMTYPE			m_CimType;
	CStringW		m_RefTo;
	BOOL			m_bDirect;

public:

	//public members
	CArray<CStringW, LPCWSTR> m_SrcPropertyNames;

	//Constructor
		CPropertyQualifierItem(const wchar_t* prop, BOOL bHD, BOOL bKy, CIMTYPE ct, CStringW rfto, BOOL bDt);

	//retrieval methods
	CStringW	GetViewPropertyName() { return m_ViewPropertyName; }
	BOOL	IsHiddenDefault() { return m_HiddenDefault; }
	BOOL	IsKey() { return m_bKey; }
	BOOL	IsDirect() { return m_bDirect; }
	CIMTYPE	GetCimType() { return m_CimType; }
	CStringW	GetReferenceClass() { return m_RefTo; }

	//Destructor
		~CPropertyQualifierItem();

};

class CJoinOnQualifierArray
{
private:

	UINT		m_Count;
	wchar_t*	m_Buff;
	wchar_t**	m_AClasses;
	wchar_t**	m_AProps;
	wchar_t**	m_BClasses;
	wchar_t**	m_BProps;
	UINT*		m_Ops;
	BOOL		m_Valid;

	void		Parse(const wchar_t* qualStr);
	wchar_t*	SkipSpace(wchar_t*& src);
	wchar_t*	SkipToSpecial(wchar_t*& src);
	wchar_t*	GetClassStr(wchar_t*& src);
	wchar_t*	GetPropertyStrAndOperator(wchar_t*& src, UINT& op);
	wchar_t*	GetPropertyStr(wchar_t*& src);
	BOOL		StripAnd(wchar_t*& src);


public:

	//possible operators
	enum{NO_OPERATOR = 0, EQUALS_OPERATOR = 1, NOT_EQUALS_OPERATOR = 2};
	CMap<CStringW, LPCWSTR, int, int> m_AllClasses;
	BOOL*		m_bDone;

	//Constructor
		CJoinOnQualifierArray();

	BOOL		Set(const wchar_t* jStr);
	UINT		GetCount() { return m_Count; }
	wchar_t**	GetAClasses() { return m_AClasses; }
	wchar_t**	GetAProperties() { return m_AProps; }
	wchar_t**	GetBClasses() { return m_BClasses; }
	wchar_t**	GetBProperties() { return m_BProps; }
	UINT*		GetOperators() { return m_Ops; }
	BOOL		IsValid() { return m_Valid; }
	BOOL		ValidateJoin();

	//Destructor
		~CJoinOnQualifierArray();
	
};

template <> inline void AFXAPI  DestructElements<CPropertyQualifierItem*> (CPropertyQualifierItem** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			delete ((CPropertyQualifierItem*)(ptr_e[i]));
		}
	}
}


#endif //_VIEW_PROV_VPQUALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\viewprovider\include\vptasks.h ===
//***************************************************************************

//

//  VPTASKS.H

//

//  Module: 

//

//  Purpose: Defines tasks that IWbemServices needs to perform.

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPTASKS_H
#define _VIEW_PROV_VPTASKS_H

#define WBEM_TASKSTATE_START				0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT	0x100001

#define CONST_NETAPI_LIBRARY _T("netapi32.dll")
#define CONST_NETAPI_DSPROC ("DsGetDcNameW")
#define CONST_NETAPI_NETPROC ("NetApiBufferFree")

typedef DWORD ( WINAPI *NETAPI_PROC_DsGetDcName ) (

    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
) ;

typedef NET_API_STATUS ( NET_API_FUNCTION *NETAPI_PROC_NetApiBufferFree ) (

    IN LPVOID Buffer
) ;



class WbemTaskObject;
class CObjectSinkResults;

class CViewProvObjectSink : public IWbemObjectSink
{
private:
	
	LONG m_ReferenceCount;         //Object reference count
	CObjectSinkResults *m_parent;
	CCriticalSection m_lock;
	CWbemServerWrap *m_ServWrap;
	IWbemObjectSink *m_RemoteSink;
	BOOL m_DoCancel;
	DWORD m_nsindex;

public:

	//Constructor
		CViewProvObjectSink(CObjectSinkResults* parent, CWbemServerWrap *pServ, DWORD a_indx);

	//Non-delegating object IUnknown

    STDMETHODIMP			QueryInterface (REFIID refIID, LPVOID FAR * ppV);
    STDMETHODIMP_(ULONG) 	AddRef ();
    STDMETHODIMP_(ULONG) 	Release ();

    //IWbemObjectSink methods
	HRESULT STDMETHODCALLTYPE	Indicate(LONG count, IWbemClassObject** ppObjArray);
	HRESULT STDMETHODCALLTYPE	SetStatus(LONG lFlags, HRESULT hr, BSTR bStr, IWbemClassObject* pObj);

	//implementation
	void				Disconnect();
	void				DisAssociate();
	IWbemObjectSink*	Associate();

	//Destructor
		~CViewProvObjectSink();

};

template <> inline void AFXAPI  DestructElements<IWbemClassObject*> (IWbemClassObject** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

class CWbemClassObjectWithIndex
{
private:
	LONG m_ReferenceCount;
	DWORD m_nsindex;
	IWbemClassObject *m_pObject;

public:
    
		CWbemClassObjectWithIndex(DWORD a_indx, IWbemClassObject *a_pObj);

	ULONG	AddRef();
    ULONG	Release();
	DWORD	GetIndex() { return m_nsindex; }
	IWbemClassObject * GetWrappedObject() { return m_pObject; }

		~CWbemClassObjectWithIndex();
};

template <> inline void AFXAPI  DestructElements<CWbemClassObjectWithIndex*> (CWbemClassObjectWithIndex** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

class CObjectSinkResults : public CObject
{
private:

	CList<CViewProvObjectSink *, CViewProvObjectSink *> m_realSnks;
	CCriticalSection m_CriticalSection;
	WbemTaskObject *m_parent;
	DWORD m_index;
	HRESULT m_hr;
	BOOL m_bSet;
	LONG m_ReferenceCount;

public:
	 
	CArray<CWbemClassObjectWithIndex*, CWbemClassObjectWithIndex*> m_ObjArray;
	DWORD	GetIndex() { return m_index; }
	BOOL	IsSet() { return m_bSet; }
	HRESULT	GetResult() { return m_hr; }
	void	Disconnect();
	BOOL	RemoveSink(CViewProvObjectSink *pSnk);
	void	SetSink(CViewProvObjectSink *pSnk);
	void	SetStatus(HRESULT hr, CViewProvObjectSink *pSnk);
	HRESULT	Indicate(LONG count, IWbemClassObject** ppObjArray, DWORD a_indx);
    ULONG	AddRef ();
    ULONG	Release ();


	CObjectSinkResults(WbemTaskObject* parent, DWORD index);
	~CObjectSinkResults();
};

class WbemTaskObject
{
private:
protected:

	WbemProvErrorObject m_ErrorObject ;

	ULONG m_OperationFlag;
	IWbemClassObject *m_ClassObject;
	IWbemObjectSink *m_NotificationHandler;
	IWbemContext *m_Ctx;
	CViewProvServ *m_Provider;
	CTypedPtrArray<CObArray, CSourceQualifierItem*> m_SourceArray;
	CMap<CStringW, LPCWSTR, int, int> m_ClassToIndexMap;
	CTypedPtrArray<CObArray, CNSpaceQualifierItem*> m_NSpaceArray;
	CMap<CStringW, LPCWSTR, CPropertyQualifierItem*, CPropertyQualifierItem*> m_PropertyMap;
	CMap<CStringW, LPCWSTR, int, int> m_EnumerateClasses;
	CJoinOnQualifierArray m_JoinOnArray;
	SQL_LEVEL_1_RPN_EXPRESSION*	m_RPNPostFilter;
	BSTR m_ClassName;
	CStringW m_ProviderName;
	LONG m_Ref;
	CTypedPtrArray<CObArray, CObjectSinkResults*> m_ObjSinkArray;
	CCriticalSection m_ArrayLock;
	int m_iQueriesAsked;
	int m_iQueriesAnswered;
	BOOL m_bAssoc;
	BOOL m_bSingleton;
	HANDLE m_StatusHandle;
	IWbemServices *m_Serv;
	CWbemServerWrap *m_ServerWrap;
	BOOL m_bIndicate;
	BOOL m_ResultReceived;


protected:

	void SetRequestHandle ( ULONG a_RequestHandle ) ;
	BOOL GetRequestHandle () ;
	BOOL GetClassObject (IWbemServices* pServ, BSTR a_Class, IWbemClassObject** ppClass, CWbemServerWrap **a_pServ = NULL) ;
	BOOL SetClass (const wchar_t* a_Class) ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL ParseAndProcessClassQualifiers (WbemProvErrorObject &a_ErrorObject,
											ParsedObjectPath *a_ParsedObjectPath = NULL,
											CMap<CStringW, LPCWSTR, int, int>* parentMap = NULL);
#ifdef VP_PERFORMANT_JOINS
	BOOL CreateAndIndicateJoinsPerf(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle);
	BOOL JoinTwoColumns(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs);
	BOOL AddColumnToJoin(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs,
						DWORD a_Index,
						CList <int, int> &a_IndexArray);
	BOOL JoinTwoItems(WbemProvErrorObject &a_ErrorObject,
						IWbemClassObject *a_Obj1,
						IWbemClassObject *a_Obj2,
						IWbemClassObject *a_resObj,
						CList <int, int> &a_IndexArray,
						DWORD a_indx1, DWORD a_indx2);
	BOOL JoinItem(WbemProvErrorObject &a_ErrorObject,
						IWbemClassObject *a_Obj1,
						IWbemClassObject *a_vObj,
						IWbemClassObject *a_resObj,
						CList <int, int> &a_IndexArray,
						DWORD a_indx1);
#else
	BOOL CreateAndIndicateJoins(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle);
	BOOL CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, IWbemClassObject **pSrcs, IWbemClassObject **pOut);
#endif

	BOOL CreateAndIndicateUnions(WbemProvErrorObject &a_ErrorObject, int index = -1);
	BOOL CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, CObjectSinkResults *pSrcs);
#if 0
	BOOL SetDefaultUnionKeyValue(wchar_t* propstr, IWbemClassObject* pObj);
#endif
	BOOL ValidateClassDependencies(IWbemClassObject*** arrayofArrayOfObjs, CMap<CStringW, LPCWSTR, int, int>* parentMap);
	BOOL ValidateJoin();
	BOOL TransposeReference(CPropertyQualifierItem* pItm, VARIANT vSrc, VARIANT* pvDst, BOOL bMapToView, CWbemServerWrap **a_ns);
	BSTR MapFromView(BSTR path, const wchar_t* src, IWbemClassObject** pInst = NULL, BOOL bAllprops = FALSE);
	BSTR MapToView(BSTR path, const wchar_t* src, CWbemServerWrap **a_ns);
	BOOL EvaluateToken(IWbemClassObject *pTestObj, SQL_LEVEL_1_TOKEN &Tok);
	BOOL PostFilter(IWbemClassObject* a_pObj);
	HRESULT	Connect(const wchar_t* path, CWbemServerWrap** ppServ, BOOL a_bUpdate = FALSE);
	HRESULT UpdateConnection(CWbemServerWrap **a_pServ, IWbemServices **a_proxy);
	HRESULT DoConnectServer(BSTR bstrPath, CWbemServerWrap **a_ppServ, BOOL a_bUpdate);
	HRESULT LocalConnectServer(BSTR bstrPath, IWbemServices** ppServ);
#ifdef UNICODE
	HRESULT CoCreateForConnectServer(BSTR bstrPath, COSERVERINFO* psi, COAUTHIDENTITY* pauthid, IWbemServices** ppServ);
#endif

	wchar_t* NormalisePath(wchar_t *wszObjectPath, CWbemServerWrap **pNSWrap);
	wchar_t* GetClassWithKeyDefn(CWbemServerWrap **pNS, BSTR classname, BOOL bGetNS, wchar_t **nsPath, BOOL bCheckSingleton = TRUE);
	DWORD GetIndexList(const wchar_t* a_src, DWORD** a_pdwArray);

public:

	WbemTaskObject ( 

		CViewProvServ *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag ,
		IWbemContext *a_Ctx ,
		IWbemServices* a_Serv = NULL,
		CWbemServerWrap *a_ServWrap = NULL
	) ;

	LONG	AddRef();
	LONG	Release();
	WbemProvErrorObject &GetErrorObject();
	void	CleanUpObjSinks(BOOL a_bDisconnect = FALSE);
	virtual void SetStatus(HRESULT hr, DWORD index);
	void	SetResultReceived();

	virtual ~WbemTaskObject();


} ;

class HelperTaskObject : public WbemTaskObject
{
private:
	wchar_t *m_ObjectPath ;
	ParsedObjectPath *m_ParsedObjectPath ;
	wchar_t* m_principal ;

	BOOL DoQuery(ParsedObjectPath* parsedObjectPath, IWbemClassObject** pInst, int indx);

public:

		HelperTaskObject(
			CViewProvServ *a_Provider , 
			const wchar_t *a_ObjectPath , 
			ULONG a_Flag , 
			IWbemObjectSink *a_NotificationHandler,
			IWbemContext *pCtx,
			IWbemServices* a_Serv,
			const wchar_t* prncpl,
			CWbemServerWrap* a_ServWrap
		);

	BOOL Validate(CMap<CStringW, LPCWSTR, int, int>* parentMap);
	BOOL GetViewObject(const wchar_t* path, IWbemClassObject** pInst, CWbemServerWrap **a_ns);

		~HelperTaskObject();

};

class GetObjectTaskObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	ParsedObjectPath *m_ParsedObjectPath ;

protected:

	BOOL	PerformGet(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst = NULL, const wchar_t* src = NULL, BOOL bAllprops = FALSE);
	BOOL	PerformQueries(WbemProvErrorObject &a_ErrorObject, BOOL bAllprops);
	BOOL	ProcessResults(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst, const wchar_t* src);

public:

	GetObjectTaskObject ( 
		CViewProvServ *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler,
		IWbemContext *pCtx,
		IWbemServices* a_Serv,
		CWbemServerWrap *a_ServerWrap
		);

	BOOL	GetObject();
	BOOL	GetSourceObject(const wchar_t* src, IWbemClassObject** pInst, BOOL bAllprops);

	~GetObjectTaskObject();

} ;


class ExecMethodTaskObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Method ;
	ParsedObjectPath *m_ParsedObjectPath ;
	IWbemClassObject* m_InParamObject;
	IWbemClassObject* m_OutParamObject;

protected:

	BOOL CompareMethods(WbemProvErrorObject &a_ErrorObject,
						LONG &a_Index,
						CStringW &a_SrcMethodName,
						BOOL &a_bStatic);

	BOOL PerformMethod(WbemProvErrorObject &a_ErrorObject,
						LONG a_Index,
						CStringW a_SrcMethodName,
						BOOL a_bStatic);

public:

	ExecMethodTaskObject ( 

		CViewProvServ *a_Provider , 
		wchar_t *a_ObjectPath ,
		wchar_t *a_MethodName,
		ULONG a_Flag ,
		IWbemClassObject *a_InParams ,		
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	);

	BOOL ExecMethod();

	~ExecMethodTaskObject();
} ;


class PutInstanceTaskObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_InstObject ;

protected:

	BOOL PerformPut(WbemProvErrorObject &a_ErrorObject);

public:

	PutInstanceTaskObject ( 

		CViewProvServ *a_Provider , 
		IWbemClassObject *a_Inst , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	);

	BOOL PutInstance();

	~PutInstanceTaskObject();
} ;

class ExecQueryTaskObject : public WbemTaskObject
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

protected:

	BOOL	PerformQuery(WbemProvErrorObject &a_ErrorObject);
	BOOL	PerformEnumQueries(WbemProvErrorObject &a_ErrorObject);
	BOOL	PerformSelectQueries(WbemProvErrorObject &a_ErrorObject, BOOL &bWait);
	BOOL	ProcessResults(WbemProvErrorObject &a_ErrorObject);
	void	ModifySourceQueriesForUserQuery();
	void	ModifySourceQueriesWithEnumResults();

public:

	ExecQueryTaskObject ( 

		CViewProvServ *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	);

	BOOL	ExecQuery();

		~ExecQueryTaskObject();
} ;

#endif //_VIEW_PROV_VPTASKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\classfac.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
//  CLASSFAC.CPP
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "wdmdefs.h"
////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CProvFactory::CProvFactory(const CLSID & ClsId)
{
    m_cRef=0L;
    InterlockedIncrement((LONG *) &g_cObj);
    m_ClsId = ClsId;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////
CProvFactory::~CProvFactory(void)
{
    InterlockedDecrement((LONG *) &g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Standard Ole routines needed for all interfaces
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv=this;
    }

    if (NULL!=*ppv)
    {
        AddRef();
        hr = NOERROR;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}
////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiates an object returning an interface pointer.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, PPVOID ppvObj)
{
    HRESULT   hr = E_OUTOFMEMORY;
    IUnknown* pObj = NULL;

    *ppvObj=NULL;

    //==================================================================
    // This object doesnt support aggregation.
    //==================================================================

    try
	{
		if (NULL!=pUnkOuter)
		{
			hr = CLASS_E_NOAGGREGATION;
		}
		else
		{
			//==============================================================
			//Create the object passing function to notify on destruction.
			//==============================================================
			if (m_ClsId == CLSID_WMIProvider)
			{
		        CWMI_Prov * ptr = new CWMI_Prov () ;

                if( ptr ) 
                {
				    if (  FALSE == ptr->Initialized () )
				    {
					    delete ptr ;
					    ptr = NULL ;

					    hr = E_FAIL ;
				    }
				    else
				    {
					    if ( FAILED ( hr = ptr->QueryInterface ( __uuidof ( IUnknown ), ( void ** ) &pObj ) ) )
					    {
						    delete ptr ;
						    ptr = NULL ;
					    }
				    }
                }
			}
			else if (m_ClsId == CLSID_WMIEventProvider)
			{
    		    CWMIEventProvider *ptr = new CWMIEventProvider ( WMIEVENT ) ;

                if( ptr )
                {
				    if ( FALSE == ptr->Initialized () )
				    {
					    delete ptr ;
					    ptr = NULL ;

					    hr = E_FAIL ;
				    }
				    else
				    {
					    if ( FAILED ( hr = ptr->QueryInterface ( __uuidof ( IUnknown ), ( void ** ) &pObj ) ) )
					    {
						    delete ptr ;
						    ptr = NULL ;
					    }
				    }
                }
			}
			else if (m_ClsId == CLSID_WMIHiPerfProvider)
			{
    		    CWMIHiPerfProvider *ptr = new CWMIHiPerfProvider ( ) ;

                if( ptr )
                {
				    if ( FALSE == ptr->Initialized () )
				    {
					    delete ptr ;
					    ptr = NULL ;

					    hr = E_FAIL ;
				    }
				    else
				    {
					    if ( FAILED ( hr = ptr->QueryInterface ( __uuidof ( IUnknown ), ( void ** ) &pObj ) ) )
					    {
						    delete ptr ;
						    ptr = NULL ;
					    }
				    }
                }
			}
		}
	}
	catch ( Heap_Exception & e )
	{
	}

	if ( pObj )
	{
		hr = pObj->QueryInterface(riid, ppvObj);

		pObj->Release () ;
		pObj = NULL ;
	}

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\classfac.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMI_CPROVFACTORY_HEADER
#define _WMI_CPROVFACTORY_HEADER

typedef void** PPVOID;
////////////////////////////////////////////////////////////////////
//
// This class is the class factory for CWMI_Prov objects.
//
////////////////////////////////////////////////////////////////////

class CProvFactory : public IClassFactory 
{

    protected:
        ULONG           m_cRef;
        CLSID m_ClsId;

    public:
        CProvFactory(const CLSID & ClsId);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP         LockServer(BOOL);
};

typedef CProvFactory *PCProvFactory;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\globals.h ===
////////////////////////////////////////////////////////////////////

//

//  globals.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#include <WDMSHELL.h>
#include <wchar.h>
#include <flexarry.h>
#include <provexpt.h>


typedef LPVOID * PPVOID;
#define PUT_INSTANCE 1
#define CREATE_INSTANCE_ENUM 2


// {0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIEventProvider, 0x725c3cb, 0xfefb, 0x11d0, 0x99, 0xf9, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {D2D588B5-D081-11d0-99E0-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIProvider,0xd2d588b5, 0xd081, 0x11d0, 0x99, 0xe0, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {35B78F79-B973-48c8-A045-CAEC732A35D5}
DEFINE_GUID(CLSID_WMIHiPerfProvider,0x35b78f79, 0xb973, 0x48c8, 0xa0, 0x45, 0xca, 0xec, 0x73, 0x2a, 0x35, 0xd5);

#include "wdmperf.h"
#include "classfac.h"
#include "wmiprov.h"
#include "wmievent.h"
#include "wmimof.h"

//===============================================================
// These variables keep track of when the module can be unloaded
//===============================================================

extern long g_cObj;
extern long g_cLock;
extern CWMIEvent *  g_pBinaryMofEvent;

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Common functions regarding binary mof processing & security
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CheckImpersonationLevel();

HRESULT InitializeProvider	( 
								/* [in] */ LPWSTR pszNamespace,
								/* [in] */ LPWSTR pszLocale,
								/* [in] */ IWbemServices __RPC_FAR *pNamespace,
								/* [in] */ IWbemContext __RPC_FAR *pCtx,
								/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink,

								/* [in] */  CHandleMap * pMap,
								/* [out] */ IWbemServices ** ppServices,
								/* [out] */ IWbemServices ** ppRepository,
								/* [out] */ IWbemContext  ** ppCtx = NULL,

								/* [in] */ BOOL bProcessMof = TRUE
							) ;

HRESULT UnInitializeProvider	( ) ;

HRESULT GetRepository	( 
							/* [in] */  LPWSTR pszNamespace,
							/* [in] */  LPWSTR pszLocale,
							/* [in] */  IWbemContext __RPC_FAR *pCtx,
							/* [out] */ IWbemServices __RPC_FAR ** pServices
						) ;


#define STANDARD_CATCH      catch(Structured_Exception e_SE) {  hr = E_UNEXPECTED;  } \
                            catch(Heap_Exception e_HE)       {  hr = E_OUTOFMEMORY; } \
                            catch(...)                       {  hr = WBEM_E_UNEXPECTED;   }

#ifndef	__LEAVEPTR__
#define	__LEAVEPTR__

template <typename T, typename FT, FT F>
class LeavePtrFnc
{
	private:
	T		Val_;
	BOOL	bExec;

	public:
	LeavePtrFnc ( T Val ): Val_ ( Val ), bExec ( FALSE )
	{
	};

	void Exec ( BOOL bSetExecFlag = TRUE )
	{
		(Val_->*F)();

		if ( bSetExecFlag )
		{
			bExec = TRUE;
		}
	}

	~LeavePtrFnc ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

#endif	__LEAVEPTR__

#ifndef	__WAITEXPTR__
#define	__WAITEXPTR__

template < typename T, typename FT, FT F, int iTime >
class WaitExceptionPtrFnc
{
	public:
	WaitExceptionPtrFnc ( T Val_ )
	{
		BOOL bResult = FALSE;
		while ( ! bResult )
		{
			try
			{
				(Val_->*F)();
				bResult = TRUE;
			}
			catch ( ... )
			{
			}

			if ( ! bResult )
			{
				::Sleep ( iTime );
			}
		}
	}
};

#endif	__WAITEXPTR__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <Allocator.h>
#include <HashTable.h>

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\maindll.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MAINDLL.CPP
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <initguid.h>
#include <locale.h>
#include "wdmdefs.h"
#include <stdio.h>
#include <tchar.h>

#include <strsafe.h>

HMODULE ghModule;
CWMIEvent *  g_pBinaryMofEvent = NULL;

CCriticalSection g_EventCs;
CCriticalSection g_SharedLocalEventsCs;
CCriticalSection g_ListCs;   
CCriticalSection g_LoadUnloadCs;   

CCriticalSection *g_pEventCs = &g_EventCs;							// pointer for backward comp 
CCriticalSection *g_pSharedLocalEventsCs = &g_SharedLocalEventsCs;	// pointer for backward comp
CCriticalSection *g_pListCs = &g_ListCs;							// pointer for backward comp   
CCriticalSection *g_pLoadUnloadCs = &g_LoadUnloadCs;				// pointer for backward comp   

//Count number of objects and number of locks.
long       g_cObj=0;
long       g_cLock=0;

long glInits			= 0;
long glProvObj			= 0;
long glEventsRegistered = 0;

#include "wmiguard.h"
WmiGuard * pGuard = NULL;

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    SetStructuredExceptionHandler seh;

    BOOL fRc = TRUE;

    try
    {
        switch( ulReason )
        {
            case DLL_PROCESS_DETACH:
			{
				//
				// release binary mof changes worker
				//
				SAFE_DELETE_PTR(g_pBinaryMofEvent);

				if ( pGuard )
				{
					delete pGuard;
					pGuard = NULL;

					if( g_ListCs.IsValid() )
					{
        				g_ListCs.Delete();
					}

					if( g_EventCs.IsValid() )
					{
        				g_EventCs.Delete();
					}

					if( g_SharedLocalEventsCs.IsValid() )
					{
						g_SharedLocalEventsCs.Delete();
					}

					if( g_LoadUnloadCs.IsValid() )
					{
						g_LoadUnloadCs.Delete();
					}
				}
			}
			break;

            case DLL_PROCESS_ATTACH:
			{
				if ( ( pGuard = new WmiGuard ( ) ) == NULL )
				{
					fRc = FALSE;
				}
				else
				{
					g_LoadUnloadCs.Init();
   					g_SharedLocalEventsCs.Init();
					g_EventCs.Init();
					g_ListCs.Init();

					fRc = ( g_LoadUnloadCs.IsValid() && 
							g_SharedLocalEventsCs.IsValid() &&
							g_EventCs.IsValid() &&
							g_ListCs.IsValid() ) ? TRUE : FALSE ;

					if ( fRc )
					{
						fRc = pGuard->Init ( g_pSharedLocalEventsCs );

						if ( fRc )
						{
							//
							// instantiate worker for driver's
							// classes addition and deletion
							//
							fRc = FALSE;

							HRESULT hr = WBEM_S_NO_ERROR ;
							try
							{
								g_pBinaryMofEvent = (CWMIEvent *)new CWMIEvent(INTERNAL_EVENT);  // This is the global guy that catches events of new drivers being added at runtime.
								if(g_pBinaryMofEvent)
								{
									if ( g_pBinaryMofEvent->Initialized () )
									{
										fRc = TRUE ;
									}
									else
									{
										delete g_pBinaryMofEvent ;
										g_pBinaryMofEvent = NULL ;
									}
								}
								else
								{
								}
							}
							STANDARD_CATCH
						}
					}
				}

 			    ghModule = hInstance;
			    if (!DisableThreadLibraryCalls(ghModule))
				{
					ERRORTRACE((THISPROVIDER, "DisableThreadLibraryCalls failed\n" ));
				}
			}
            break;
       }
    }
    catch(Structured_Exception e_SE)
    {
        fRc = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        fRc = FALSE;
    }
    catch(...)
    {
        fRc = FALSE;
    }

    return fRc;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr =  CLASS_E_CLASSNOTAVAILABLE ;
    CProvFactory *pFactory = NULL;
    SetStructuredExceptionHandler seh;

    try
    {
        //============================================================================
        //  Verify the caller is asking for our type of object.
        //============================================================================
        if((CLSID_WMIProvider != rclsid) &&  (CLSID_WMIEventProvider != rclsid) && (CLSID_WMIHiPerfProvider != rclsid) )
        {
            hr = E_FAIL;
        }
        else
		{
            //============================================================================
            // Check that we can provide the interface.
            //============================================================================
            if (IID_IUnknown != riid && IID_IClassFactory != riid)
            {
                hr = E_NOINTERFACE;
            }
            else
			{					
				CAutoBlock block (g_pLoadUnloadCs);

				//============================================================================
				// Get a new class factory.
				//============================================================================
    			pFactory=new CProvFactory(rclsid);
				if (NULL!=pFactory)
				{
					//============================================================================
					// Verify we can get an instance.
					//============================================================================
					hr = pFactory->QueryInterface(riid, ppv);
					if ( FAILED ( hr ) )
					{
						SAFE_DELETE_PTR(pFactory);
					}
					else
					{
						//
						// it is safe to check if this is 1st object like this
						// as there is no way any provider or class factory is
						// incrementing global refrence count
						//

						if ( 1 == g_cObj )
						{
							//
							// GlobalInterfaceTable
							//

							hr = CoCreateInstance	(	CLSID_StdGlobalInterfaceTable,
														NULL,
														CLSCTX_INPROC_SERVER, 
														IID_IGlobalInterfaceTable, 
														(void**)&g_pGIT
													);

							//
							// bail out every resource
							//

							if ( FAILED ( hr ) )
							{
								SAFE_DELETE_PTR(pFactory);
								SAFE_RELEASE_PTR(g_pGIT);
							}
						}
					}
				}
            }
        }
    }
    STANDARD_CATCH

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
/////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	HRESULT sc = S_FALSE ;

	try
	{
		CAutoBlock block (g_pLoadUnloadCs);

		//============================================================================
		// It is OK to unload if there are no objects or locks on the 
		// class factory.
		//============================================================================

		if ( 0L == g_cObj && 0L == g_cLock )
		{
			sc = S_OK ;
			SAFE_RELEASE_PTR(g_pGIT);
		}
	}
	catch ( ... )
	{
	}

	return sc;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// CreateKey
//
// Purpose: Function to create a key
//
// Return:  NOERROR if registration successful, error otherwise.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CreateKey(TCHAR * szCLSID, TCHAR * szName)
{
    HKEY hKey1, hKey2;
    HRESULT hr = S_OK;

#ifdef LOCALSERVER

    HKEY hKey;
	TCHAR szProviderCLSIDAppID[128];

	if ( SUCCEEDED ( hr = StringCchPrintf ( szProviderCLSIDAppID, 128, _T("SOFTWARE\\CLASSES\\APPID\\%s"), szName ) ) )
	{
		hr = RegCreateKeyEx	(
								HKEY_LOCAL_MACHINE,
								szProviderCLSIDAppID,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								NULL
							);

		if( ERROR_SUCCESS == hr )
		{
			RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)szName, (_tcsclen(szName) + 1) * sizeof(TCHAR));
    		CloseHandle(hKey);
		}
		else
		{
			hr = HRESULT_FROM_WIN32 ( hr );
		}
	}

#endif


    if( S_OK == hr )
    {
		hr = RegCreateKeyEx	(
								HKEY_CLASSES_ROOT,
								szCLSID,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey1,
								NULL
							);

        if( ERROR_SUCCESS == hr )
        {
            DWORD dwLen;
            dwLen = (_tcsclen(szName)+1) * sizeof(TCHAR);
            hr = RegSetValueEx(hKey1, NULL, 0, REG_SZ, (CONST BYTE *)szName, dwLen);
            if( ERROR_SUCCESS == hr )
            {

#ifdef LOCALSERVER
				hr = RegCreateKeyEx	(
										hKey1,
										_T("LocalServer32"),
										0,
										NULL,
										REG_OPTION_NON_VOLATILE,
										KEY_ALL_ACCESS,
										NULL,
										&hKey2,
										NULL
									);
#else
				hr = RegCreateKeyEx	(
										hKey1,
										_T("InprocServer32"),
										0,
										NULL,
										REG_OPTION_NON_VOLATILE,
										KEY_ALL_ACCESS,
										NULL,
										&hKey2,
										NULL
									);
#endif

                if( ERROR_SUCCESS == hr )
                {
                    TCHAR szModule [MAX_PATH+1];
                    szModule [MAX_PATH] = 0;

					if ( GetModuleFileName(ghModule, szModule, MAX_PATH) )
					{
						dwLen = (_tcsclen(szModule)+1) * sizeof(TCHAR);
						hr = RegSetValueEx(hKey2, NULL, 0, REG_SZ, (CONST BYTE *)szModule, dwLen );
						if( ERROR_SUCCESS == hr )
						{
							dwLen = (_tcsclen(_T("Both"))+1) * sizeof(TCHAR);
							hr = RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ,(CONST BYTE *)_T("Both"), dwLen);
						}
						else
						{
							hr = HRESULT_FROM_WIN32 ( hr );
						}
					}
					else
					{
						hr = HRESULT_FROM_WIN32 ( ::GetLastError () );
					}

                    CloseHandle(hKey2);
                }
				else
				{
					hr = HRESULT_FROM_WIN32 ( hr );
				}
            }
            CloseHandle(hKey1);
        }
		else
		{
			hr = HRESULT_FROM_WIN32 ( hr );
		}
    }

    return hr;
    
}
/////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _X86_
BOOL IsReallyWOW64( void )
{
	// Environment variable should only exist on WOW64
	return ( GetEnvironmentVariable( L"PROCESSOR_ARCHITEW6432", 0L, NULL ) != 0L );
}
#endif

STDAPI DllRegisterServer(void)
{   
    WCHAR wcID[128];
    TCHAR szCLSID[128];
    HRESULT hr = WBEM_E_FAILED;
    
    SetStructuredExceptionHandler seh;

    try{

#ifdef _X86

		if (!IsReallyWOW64())
		{
			// on 32-bit builds, we want to register everything if we are not really running in syswow64

#endif
			//==============================================
			// Create keys for WDM Instance Provider.
			//==============================================
			StringFromGUID2(CLSID_WMIProvider, wcID, 128);
			StringCchPrintf(szCLSID, 128, _T("CLSID\\%s"), wcID);

			hr = CreateKey(szCLSID,_T("WDM Instance Provider"));
			if( ERROR_SUCCESS == hr )
			{
				//==============================================
				// Create keys for WDM Event Provider.
				//==============================================
				StringFromGUID2(CLSID_WMIEventProvider, wcID, 128);
				StringCchPrintf(szCLSID, 128, _T("CLSID\\%s"), wcID);

				hr = CreateKey(szCLSID,_T("WDM Event Provider"));
				if( ERROR_SUCCESS == hr )
				{
					//==============================================
					// Create keys for WDM HiPerf Provider.
					//==============================================
					StringFromGUID2(CLSID_WMIHiPerfProvider, wcID, 128);
					StringCchPrintf(szCLSID, 128, _T("CLSID\\%s"), wcID);
					hr = CreateKey(szCLSID,_T("WDM HiPerf Provider"));
				}
			}

#ifdef _X86

		}
		else
		{

			// on 32-bit builds, we want to register only the HiPerf Provider if we are really running in syswow64

			//==============================================
			// Create keys for WDM HiPerf Provider.
			//==============================================
			StringFromGUID2(CLSID_WMIHiPerfProvider, wcID, 128);
			StringCchPrintf(szCLSID, 128, _T("CLSID\\%s"), wcID);
			hr = CreateKey(szCLSID,_T("WDM HiPerf Provider"));
		}

#endif

    }
    STANDARD_CATCH


    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////
//
// DeleteKey
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT DeleteKey(TCHAR * pCLSID, TCHAR * pID)
{
    HKEY hKey;
	HRESULT hr = S_OK;


#ifdef LOCALSERVER

	TCHAR szTmp[MAX_PATH];
	StringCchPrintf(szTmp, MAX_PATH, _T("SOFTWARE\\CLASSES\\APPID\\%s"), pID);

	//Delete entries under APPID

	hr = RegDeleteKey(HKEY_LOCAL_MACHINE, szTmp);
    if( ERROR_SUCCESS == hr )
    {
        StringCchPrintf(szTmp, MAX_PATH, _T("%s\\LocalServer32"), pCLSID);
	    hr = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);
    }

#endif
    hr = RegOpenKey(HKEY_CLASSES_ROOT, pCLSID, &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteKey(hKey,_T("InprocServer32"));
        CloseHandle(hKey);
    }


    hr = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteKey(hKey,pID);
        CloseHandle(hKey);
    }


    return hr;
}
/////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
    WCHAR      wcID[128];
    TCHAR      strCLSID[MAX_PATH];
    HRESULT hr = WBEM_E_FAILED;

    try
    {

#ifdef _X86

		if (!IsReallyWOW64())
		{
			// on 32-bit builds, we want to unregister everything if we are not really running in syswow64

#endif

			//===============================================
			// Delete the WMI Instance Provider
			//===============================================
			StringFromGUID2(CLSID_WMIProvider, wcID, 128);
			StringCchPrintf(strCLSID, MAX_PATH, _T("CLSID\\%s"), wcID);
			hr = DeleteKey(strCLSID, wcID);

			if( ERROR_SUCCESS == hr )
			{
				//==========================================
				// Delete the WMI Event Provider
				//==========================================
				StringFromGUID2(CLSID_WMIEventProvider, wcID, 128);
				StringCchPrintf(strCLSID, MAX_PATH, _T("CLSID\\%s"), wcID);
				hr = DeleteKey(strCLSID,wcID);
				if( ERROR_SUCCESS == hr )
				{
					//==========================================
					// Delete the WMI HiPerf Provider
					//==========================================
					StringFromGUID2(CLSID_WMIHiPerfProvider, wcID, 128);
					StringCchPrintf(strCLSID, MAX_PATH, _T("CLSID\\%s"), wcID);
					hr = DeleteKey(strCLSID,wcID);
				}
			}

#ifdef _X86

		}
		else
		{
			// on 32-bit builds, we need to unregister only the HiPerf provider if we are really running in syswow64

			//==========================================
			// Delete the WMI HiPerf Provider
			//==========================================
			StringFromGUID2(CLSID_WMIHiPerfProvider, wcID, 128);
			StringCchPrintf(strCLSID, MAX_PATH, _T("CLSID\\%s"), wcID);
			hr = DeleteKey(strCLSID,wcID);
		}

#endif

    }
    STANDARD_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wdmdefs.h ===
////////////////////////////////////////////////////////////////////

//

//  wdmdefs.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////

#ifndef _WDMDEFS_H_
#define _WDMDEFS_H_


// {0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIEventProvider, 0x725c3cb, 0xfefb, 0x11d0, 0x99, 0xf9, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {D2D588B5-D081-11d0-99E0-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIProvider,0xd2d588b5, 0xd081, 0x11d0, 0x99, 0xe0, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {35B78F79-B973-48c8-A045-CAEC732A35D5}
DEFINE_GUID(CLSID_WMIHiPerfProvider,0x35b78f79, 0xb973, 0x48c8, 0xa0, 0x45, 0xca, 0xec, 0x73, 0x2a, 0x35, 0xd5);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wdmperf.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
//	WDMPerf.cpp
//
//	Module:	WMI WDM high performance provider
//
//	This file includes the provider and refresher code.
//
// Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#if defined(_WIN64)
ULONG Hash ( const LONG a_Arg ) {return a_Arg;}
#include <Allocator.cpp>
#endif

////////////////////////////////////////////////////////////////////////////////////////
//
//	CRefresher
//
////////////////////////////////////////////////////////////////////////////////////////
CRefresher::CRefresher(CWMI_Prov* pProvider) 
{
    m_lRef = 0;
	// ===========================================================
	// Retain a copy of the provider
	// ===========================================================
	m_pProvider = pProvider;
	if (m_pProvider)
    {
		m_pProvider->AddRef();
    }
	// ===========================================================
	// Increment the global COM object counter
	// ===========================================================

	InterlockedIncrement(&g_cObj);
}
////////////////////////////////////////////////////////////////////////////////////////

CRefresher::~CRefresher()
{
    
    // ===========================================================
	// Release the provider
	// ===========================================================
    if (m_pProvider){
		m_pProvider->Release();
    }

	// ===========================================================
	// Decrement the global COM object counter
	// ===========================================================

	InterlockedDecrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Standard COM mterface
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRefresher::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = (LPVOID)(IUnknown*)this;
    }
	else if (riid == IID_IWbemRefresher)
    {
		*ppv = (LPVOID)(IWbemRefresher*)this;
    }

    if( *ppv )
    {
   	    AddRef();
        hr = S_OK;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}
////////////////////////////////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CRefresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        delete this;
    }
    return lRef;
}

////////////////////////////////////////////////////////////////////////////////////////
//**************************************************************************************
//
//  Externally called
//
//**************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//
//  Executed to refresh a set of instances bound to the particular refresher.
//
//	In most situations the instance data, such as counter values and 
//	the set of current instances within any existing enumerators, would 
//	be updated whenever Refresh was called.  
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRefresher::Refresh(/* [in] */ long lFlags)
{
	HRESULT	hr = WBEM_NO_ERROR;
	IWbemObjectAccess* pObj = NULL;
    SetStructuredExceptionHandler seh;
    CWMIHiPerfShell WMI(TRUE);
 
	try
    {	
	    // ================================================================
	    // Updates all instances that have been added to the refresher, and
        // updates their counter values
	    // ================================================================
        hr = WMI.Initialize(TRUE,WMIGUID_QUERY,m_pProvider->HandleMapPtr(),NULL,m_pProvider->ServicesPtr(),m_pProvider->RepositoryPtr(),NULL,NULL);
        if( SUCCEEDED(hr))
        {
            WMI.SetHiPerfHandleMap(&m_HiPerfHandleMap);
            hr = WMI.RefreshCompleteList();
        }
	}
    STANDARD_CATCH

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a given class is required.   
//
//  The objects are constructed and sent back to the caller through the sink.  
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		wszClass		- The class name for which instances are required.
//		lFlags			- Reserved.
//		pCtx			- The user-supplied context (not used here).
//		pSink			- The sink to which to deliver the objects.  The objects
//							can be delivered synchronously through the duration
//							of this call or asynchronously (assuming we
//							had a separate thread).  A IWbemObjectSink::SetStatus
//							call is required at the end of the sequence.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::QueryInstances(  IWbemServices __RPC_FAR *pNamespace,
                                                WCHAR __RPC_FAR *wcsClass, long lFlags,
                                                IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pHandler )
{
    //  Since we have implemented a IWbemServices interface, this code lives in CreateInstanceEnum instead
   	return E_NOTIMPL;
}    
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  Not used.
//		lFlags			- Reserved.
//		ppRefresher		- Receives the requested refresher.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::CreateRefresher( IWbemServices __RPC_FAR *pNamespace, long lFlags,
                                         IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
{
   	HRESULT hr = WBEM_E_FAILED;
    CWMIHiPerfShell WMI(TRUE);
    SetStructuredExceptionHandler seh;
    if (pNamespace == 0 || ppRefresher == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
   	// =========================================================
    // Construct and initialize a new empty refresher
   	// =========================================================
    try
    {
        hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,NULL,pNamespace,m_pIWbemRepository,NULL,NULL);
        if( SUCCEEDED(hr))
        {
	        CRefresher* pNewRefresher = new CRefresher(this);

            if( pNewRefresher )
            {
   	            // =========================================================
                // Follow COM rules and AddRef() the thing before sending it 
                // back
   	            // =========================================================
                pNewRefresher->AddRef();
                *ppRefresher = pNewRefresher;
                hr = WBEM_NO_ERROR;
            }
        }
    }
    STANDARD_CATCH

    return hr;
   
}

////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//
//	Note that the object returned in ppRefreshable is a clone of the 
//	actual instance maintained by the provider.  If refreshers shared
//	a copy of the same instance, then a refresh call on one of the 
//	refreshers would impact the state of both refreshers.  This would 
//	break the refresher rules.	Instances in a refresher are only 
//	allowed to be updated when 'Refresh' is called.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace in WINMGMT.
//		pTemplate		- A pointer to a copy of the object which is to be
//							added.  This object itself cannot be used, as
//							it not owned locally.        
//		pRefresher		- The refresher to which to add the object.
//		lFlags			- Not used.
//		pContext		- Not used here.
//		ppRefreshable	- A pointer to the internal object which was added
//							to the refresher.
//		plId			- The Object Id (for identification during removal).        
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::CreateRefreshableObject( IWbemServices __RPC_FAR *pNamespace,
                                                 IWbemObjectAccess __RPC_FAR *pAccess,
                                                 IWbemRefresher __RPC_FAR *pRefresher,
                                                 long lFlags,
                                                 IWbemContext __RPC_FAR *pCtx,
                                                 IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
                                                 long __RPC_FAR *plId )
{
   	HRESULT hr = WBEM_E_FAILED;
    CWMIHiPerfShell WMI(FALSE);
    SetStructuredExceptionHandler seh;

    if (pNamespace == 0 || pAccess == 0 || pRefresher == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	// =========================================================
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// =========================================================
    try
    { 
#if defined(_WIN64)
		if (m_HashTable == NULL)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
#endif
		{
			hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,NULL,pNamespace,m_pIWbemRepository,NULL,pCtx);
    
			if( SUCCEEDED(hr))
			{
				CRefresher *pOurRefresher = (CRefresher *) pRefresher;

				if( pOurRefresher )
				{
    				// =================================================
    				// Add the object to the refresher. The ID is set by 
					// AddObject
					// =================================================
					WMI.SetHiPerfHandleMap(pOurRefresher->HiPerfHandleMap());
					ULONG_PTR realId = 0;
					hr = WMI.AddAccessObjectToRefresher(pAccess,ppRefreshable, &realId);
#if defined(_WIN64)
					if (SUCCEEDED(hr))
					{
						CCritical_SectionWrapper csw(&m_CS);
						
						if (csw.IsLocked())
						{
							*plId = m_ID;
							m_ID++;

							if (e_StatusCode_Success != m_HashTable->Insert (*plId, realId))
							{
								hr = WBEM_E_FAILED;
							}
						}
						else
						{
							hr = WBEM_E_FAILED;
						}
					}
#else
					*plId = realId;
#endif
				}
			}
		}
    }
    STANDARD_CATCH
    return hr;
   
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called when an enumerator is being added to a refresher.  The 
//	enumerator will obtain a fresh set of instances of the specified 
//	class every time that refresh is called.
//     
//	wszClass must be examined to determine which class the enumerator 
//	is being assigned.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		wszClass		- The class name for the requested enumerator.
//		pRefresher		- The refresher object for which we will add the enumerator
//		lFlags			- Reserved.
//		pContext		- Not used here.
//		pHiPerfEnum		- The enumerator to add to the refresher.
//		plId			- A provider specified ID for the enumerator.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::CreateRefreshableEnum( IWbemServices* pNamespace, 
                                               LPCWSTR wcsClass,
                                               IWbemRefresher* pRefresher,
	                                           long lFlags, IWbemContext* pCtx,
	                                           IWbemHiPerfEnum* pHiPerfEnum, long* plId )
{
   	HRESULT hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;

    if( !pHiPerfEnum || wcsClass == NULL || (wcslen(wcsClass) == 0))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	CWMIHiPerfShell WMI(FALSE);
    
	// ===========================================================
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// ===========================================================
    try
    {
#if defined(_WIN64)
		if (m_HashTable == NULL)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
#endif
		{
			hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,(WCHAR*)wcsClass,pNamespace,m_pIWbemRepository,NULL,pCtx);
			if( SUCCEEDED(hr))
			{
				ULONG_PTR realId = 0;
				CRefresher *pOurRefresher = (CRefresher *) pRefresher;

				if( pOurRefresher )
				{
    				// ===========================================================
					// Add the enumerator to the refresher  
					// ===========================================================
					WMI.SetHiPerfHandleMap(pOurRefresher->HiPerfHandleMap());
					hr = WMI.AddEnumeratorObjectToRefresher(pHiPerfEnum,&realId);
#if defined(_WIN64)
					if (SUCCEEDED(hr))
					{
						CCritical_SectionWrapper csw(&m_CS);
						
						if (csw.IsLocked())
						{
							*plId = m_ID;
							m_ID++;

							if (e_StatusCode_Success != m_HashTable->Insert (*plId, realId))
							{
								hr = WBEM_E_FAILED;
							}
						}
						else
						{
							hr = WBEM_E_FAILED;
						}
					}
#else
					*plId = realId;
#endif
				}
				if(SUCCEEDED(hr))
				{
					if(FAILED(hr = WMI.RefreshCompleteList()))
					{
						// This function is called before as RemoveObjectFromHandleMap
						// deletes the member variables and resets the pointers
						WMI.RemoveObjectFromHandleMap(realId);
						*plId = 0;
					}
				}
				
			}
		}
    }
    STANDARD_CATCH

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//		pRefresher			- The refresher object from which we are to remove the 
//                            perf object.
//		lId					- The ID of the object.
//		lFlags				- Not used.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::StopRefreshing( IWbemRefresher __RPC_FAR *pInRefresher, long lId, long lFlags )
{
   	HRESULT hr = WBEM_S_NO_ERROR;
    CWMIHiPerfShell WMI(TRUE);
    SetStructuredExceptionHandler seh;

	// ===========================================================
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// ===========================================================
    try
    {
#if defined(_WIN64)
		ULONG_PTR realId = 0;

		if (m_HashTable != NULL)
		{
			CCritical_SectionWrapper csw(&m_CS);
			
			if (csw.IsLocked())
			{
				if (e_StatusCode_Success != m_HashTable->Find (lId, realId))
				{
					hr = WBEM_E_FAILED;
				}
				else
				{
					m_HashTable->Delete (lId) ;
				}
			}
			else
			{
				hr = WBEM_E_FAILED;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
#else
		ULONG_PTR realId = lId;
#endif

		if (SUCCEEDED(hr))
		{
			hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,NULL,m_pIWbemServices,m_pIWbemRepository,NULL, NULL);
			if( SUCCEEDED(hr))
			{
				CRefresher *pRefresher = (CRefresher *) pInRefresher;
				WMI.SetHiPerfHandleMap(pRefresher->HiPerfHandleMap());

				if(FAILED(hr))
				{
					// This function is called before as RemoveObjectFromHandleMap
					// deletes the member variables and resets the pointers
				}
				else
				{
					hr = WMI.RemoveObjectFromHandleMap(realId);
				}
			}
		}
    }
    STANDARD_CATCH

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called when a request is made to provide all instances currently being managed by 
//  the provider in the specified namespace.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		lNumObjects		- The number of instances being returned.
//		apObj			- The array of instances being returned.
//		lFlags			- Reserved.
//		pContext		- Not used here.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::GetObjects( IWbemServices* pNamespace, long lNumObjects,
	                                IWbemObjectAccess** apObj, long lFlags,
                                    IWbemContext* pCtx)
{
    //  Since we have implemented a IWbemServices interface, this code lives in CreateInstanceEnum instead
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wmievent.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef __WBEM_WMI_EVENT_PROVIDER__H_
#define __WBEM_WMI_EVENT_PROVIDER__H_

#define WMIEVENT 1

#define WMI_EVENT_CLASS L"WMIEvent"
#define BINARY_MOF_ID   static_cast < DWORD > ( -1 )

/////////////////////////////////////////////////////////////////////////////////////////////

class CWMIEvent 
{
    protected:
        long m_lRef;
    	IWbemObjectSink __RPC_FAR   * m_pEventHandler;
	    IWbemServices __RPC_FAR     * m_pEventServices;
	    IWbemServices __RPC_FAR     * m_pEventRepository;
	    IWbemContext __RPC_FAR      * m_pEventCtx;
        CHandleMap                  m_HandleMap;
        int                         m_nType;
 
		BOOL					m_bInitialized ;

    public:

		inline BOOL				Initialized ()
		{
			return m_bInitialized ;
		}

        CWMIEvent(int nType);
        ~CWMIEvent();
		
		void ReleaseAllPointers();

        BOOL IsGuidInListIfSoGetCorrectContext(GUID gGuid, WMIEventRequest *& pEvent );
        BOOL IsGuidInList(WCHAR *Guids, WMIEventRequest *& pEvent);
        BOOL RegisterForInternalEvents( );

        HRESULT RegisterForRequestedEvent(DWORD dwId, WCHAR * wcsClasss, WORD wType);
        HRESULT RemoveWMIEvent(DWORD dwId);
		HRESULT DeleteBinaryMofResourceEvent();
        HRESULT DeleteAllLeftOverEvents();

        int NoMoreEventConsumersRegistered(GUID gGuid);

        void WMIEventCallback(PWNODE_HEADER WnodeHeader);
        void SetEventHandler(IWbemObjectSink __RPC_FAR * pHandler);
        void SetEventServices(IWbemServices __RPC_FAR * pServices);
        void SetEventRepository(IWbemServices __RPC_FAR * pServices);
        void SetEventContext(IWbemContext __RPC_FAR * pCtx);

        inline IWbemServices  __RPC_FAR * GetServices()		{return m_pEventServices;}
        inline IWbemServices  __RPC_FAR * GetRepository()	{return m_pEventRepository;}
        inline IWbemContext __RPC_FAR * GetContext()		{return m_pEventCtx;}

	private:

		BOOL IsIndexInList ( WCHAR *Guid, DWORD dwIndex ) ;
};

class CWMIEventProvider : public CWMIEvent, public IWbemEventProvider,  public IWbemEventProviderQuerySink, public IWbemProviderInit, public IWbemEventProviderSecurity
{
    private:
        HANDLE  m_hResyncEvent;
        
    public:
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        STDMETHOD(NewQuery)(DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery);
        STDMETHOD(CancelQuery)(DWORD dwId);
        STDMETHOD(ProvideEvents)( IWbemObjectSink __RPC_FAR *pSink,long lFlags);
		STDMETHOD (Initialize)(LPWSTR wszUser, long lFlags, 
								LPWSTR wszNamespace,
								LPWSTR wszLocale, IWbemServices* pNamespace, IWbemContext* pCtx,
								IWbemProviderInitSink* pSink);

        STDMETHOD(AccessCheck)(WBEM_CWSTR wszLanguage, WBEM_CWSTR wszQuery, long lSidLength, const BYTE* aSid);

        CWMIEventProvider(int nType);
        ~CWMIEventProvider() ;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wmiguard.h ===
#ifndef __WMIGUARD_H__
#define __WMIGUARD_H__

/* 
 *	Class:
 *
 *		WmiGuard
 *
 */

class WmiGuard
{
private:

	CCriticalSection* m_pCS ;

public:

	HRESULT TryEnter () ;
	HRESULT Enter () ;
	HRESULT Leave () ;

	WmiGuard () ;
	~WmiGuard () ;

	BOOL	Init ( CCriticalSection* pCS ) { return ( pCS == NULL ) ? FALSE : ( m_pCS = pCS ), TRUE; } ;
} ;

#endif __WMIGUARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wmievent.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include <aclapi.h>  
#include <groupsforuser.h>
#include <sql_1.h>
#include <flexq.h>

static CFlexArray   g_apRequests;   // Shared between all CWMIEvent instances to provide a master event list

extern CCriticalSection * g_pEventCs; 
extern CCriticalSection * g_pListCs; 

#include <helper.h>

typedef	WaitExceptionPtrFnc < CCriticalSection*, void ( CCriticalSection::* ) (), CCriticalSection::Enter, 1000 >	EnterCS;
typedef	LeavePtrFnc < CCriticalSection*, void ( CCriticalSection::* ) (), CCriticalSection::Leave >					LeaveCS;

////////////////////////////////////////////////////////////////////////////////////////////////
class CFlexQueueEx : public CFlexQueue
{
	public:

		void ResetQueue() 
		{
			delete [] m_ppData;
			m_ppData = NULL;
			m_nSize = m_nHeadIndex = m_nTailIndex = 0;
		}
};

CFlexQueueEx Q;

////////////////////////////////////////////////////////////////////////////////////////////////
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    bool bQueued = FALSE;
	
	if( SUCCEEDED( hr ) )
	{
		try
		{
			PWNODE_HEADER * pEventHeader = NULL;

			//scope the use of the critsec...
			{
				CAutoBlock block (g_pListCs);
				// Create a queue
				pEventHeader = new PWNODE_HEADER;
				if( pEventHeader )
				{
					*pEventHeader = WnodeHeader;
                    bQueued = Q.Enqueue(pEventHeader);
				}
			}

            //
            // The following code will be rarely called when the Queue
            // does not grow due to memory exhaustion.
            //

            if( FALSE == bQueued ) {
                ((CWMIEvent*) Context)->WMIEventCallback(*pEventHeader);
                delete pEventHeader;
            }

			while( TRUE )
			{
				//scope the use of the critsec...
				{
					CAutoBlock block( g_pListCs );
			
					if( Q.GetQueueSize() == 0 )
					{
						Q.ResetQueue();
						break;
					}

					pEventHeader = (PWNODE_HEADER *) Q.Dequeue();
					if (pEventHeader == 0)
					{
						break;
					}
				}
				CWMIEvent * p = (CWMIEvent* ) Context;
				p->WMIEventCallback(*pEventHeader);
			}
		}
		catch( ... )
		{
			//don't throw outside of the provider, also make sure CoUninitialize happens...
		}

		CoUninitialize();	
	}
}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventHandler(IWbemObjectSink __RPC_FAR * pHandler) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventHandler )
	{
		m_pEventHandler->Release();
	}

    m_pEventHandler = pHandler; 
	if( m_pEventHandler )
    {
		m_pEventHandler->AddRef(); 
	}
}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventServices(IWbemServices __RPC_FAR * pServices) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventServices )
	{
		m_pEventServices->Release();
	}
    m_pEventServices = pServices; 
	if( m_pEventServices )
    {
		m_pEventServices->AddRef(); 
	}
}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventRepository(IWbemServices __RPC_FAR * pServices) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventRepository )
	{
		m_pEventRepository->Release();
	}
    m_pEventRepository = pServices; 
	if( m_pEventRepository )
    {
		m_pEventRepository->AddRef(); 
	}
}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventContext(IWbemContext __RPC_FAR * pCtx) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventCtx )
	{
		m_pEventCtx->Release();
	}
    m_pEventCtx = pCtx; 
	if( m_pEventCtx )
    {
		m_pEventCtx->AddRef(); 
	}
}

////////////////////////////////////////////////////////////////////////
CWMIEvent::CWMIEvent(int nType) :
m_nType ( nType ) ,
m_pEventHandler ( NULL ) ,
m_pEventServices ( NULL ) ,
m_pEventRepository ( NULL ) ,
m_pEventCtx ( NULL ) ,
m_bInitialized ( FALSE )
{
	if ( TRUE == ( m_bInitialized = m_HandleMap.IsValid () ) )
	{
		m_lRef = 0;

		if( m_nType != INTERNAL_EVENT )
		{
			InterlockedIncrement(&g_cObj);
		}
	}
}
////////////////////////////////////////////////////////////////////////
CWMIEvent::~CWMIEvent()
{
	if ( m_bInitialized )
	{
		ReleaseAllPointers ();

		if( m_nType != INTERNAL_EVENT )
		{
			InterlockedDecrement(&g_cObj);
		}
	}
}

void CWMIEvent::ReleaseAllPointers()
{

	IWbemObjectSink    * pHandler		= NULL;
	IWbemServices      * pServices		= NULL;
	IWbemServices      * pRepository	= NULL;
	IWbemContext      * pCtx			= NULL;

	{
		CAutoBlock Block(g_pEventCs);
		pHandler	= m_pEventHandler;
		pServices	= m_pEventServices;
		pRepository	= m_pEventRepository;
		pCtx		= m_pEventCtx;

		m_pEventCtx			= NULL;
		m_pEventServices	= NULL;
		m_pEventRepository	= NULL;
		m_pEventHandler		= NULL;
	}


	SAFE_RELEASE_PTR( pHandler );
	SAFE_RELEASE_PTR( pServices );
	SAFE_RELEASE_PTR( pRepository );
	SAFE_RELEASE_PTR( pCtx );
}

////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::RegisterForInternalEvents( )
{
    BOOL fRc = FALSE;

	if( SUCCEEDED(RegisterForRequestedEvent(BINARY_MOF_ID,RUNTIME_BINARY_MOFS_ADDED,MOF_ADDED)))
	{
		if( SUCCEEDED(RegisterForRequestedEvent(BINARY_MOF_ID,RUNTIME_BINARY_MOFS_DELETED,MOF_DELETED)))
		{
			fRc = TRUE;
		}
	}

	if ( FALSE == fRc )
	{
		//
		// must clear global object so next
		// initialization will have a chance
		//

		DeleteBinaryMofResourceEvent () ;
	}

    return fRc;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::RemoveWMIEvent(DWORD dwId)
{
    HRESULT hr = S_OK;

    if( m_nType == WMIEVENT )
    {
        hr = CheckImpersonationLevel();
    }
	else
    {
		HRESULT t_TempResult = RevertToSelf();
		#ifdef	DBG
		if ( FAILED ( t_TempResult ) )
		{
			DebugBreak();
		}
		#endif	DBG
	}

    if( SUCCEEDED(hr))
    {
        CWMIManagement WMI;

		EnterCS ecs ( g_pEventCs );
		LeaveCS lcs ( g_pEventCs );

		// ================================
		// Remove all requests with this Id
		// ================================
		int nSize =  g_apRequests.Size();
		int i = 0;

		while( i  < nSize )
		{
			WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];

			//
			// we are about to remove standard events in this call
			// that means we must skip hardcoded handles
			//
			if( ( !IsBinaryMofResourceEvent ( WMI_RESOURCE_MOF_ADDED_GUID,pReq->gGuid ) ) &&
				( !IsBinaryMofResourceEvent ( WMI_RESOURCE_MOF_REMOVED_GUID,pReq->gGuid ) ) )
			{
				if(pReq->dwId == dwId)
				{
					g_apRequests.RemoveAt(i);

					//
					// leave critical section as the same critical
					// section is used inside of the event callback
					//

					//
					// left mark for scope deletion of lcs FALSE
					// as we will re-enter the same critical section
					//
					// CancelWMIEventRegistartion nor
					// NoMoreEventConsumersRegistered doesn't throw exception !
					//

					lcs.Exec( FALSE );

					// Inform WMI we don't want this anymore as 
					// long as there are no more these guids in 
					// the list, there might be more than one
					// event consumer registered.
					// =========================================

					//
					// check agains 0 as we have removed from list already
					//

					if( NoMoreEventConsumersRegistered( pReq->gGuid ) == 0 )
					{
						ULONG_PTR uRc =(ULONG_PTR)this;
 						WMI.CancelWMIEventRegistration(pReq->gGuid,uRc);
					}

					delete pReq;
					pReq = NULL;

					//
					// re-enter the same critical section here
					// its flag of execution is FALSE which means
					// that it will be left final time by destructor
					// of LeaveCS data type ( lcs )
					//
					EnterCS ecs1 ( g_pEventCs );

					nSize =  g_apRequests.Size();
				}
				else
				{
					i++;
				}
			}
			else
			{
				i++;
			}
		}
    }

    CheckImpersonationLevel();
    return WBEM_S_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::DeleteBinaryMofResourceEvent()
{
	HRESULT t_TempResult = RevertToSelf();
	#ifdef	DBG
	if ( FAILED ( t_TempResult ) )
	{
		DebugBreak();
	}
	#endif	DBG

 	CWMIManagement WMI;

	EnterCS ecs ( g_pEventCs );
	LeaveCS lcs ( g_pEventCs );

	// Remove all requests with this Id
	// ================================
	int nSize = g_apRequests.Size();
	int i = 0;

	while( i < nSize ){

		WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];

		if( ( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,pReq->gGuid)) ||
			( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,pReq->gGuid)))
		{
			g_apRequests.RemoveAt(i);

			//
			// leave critical section as the same critical
			// section is used inside of the event callback
			//

			//
			// left mark for scope deletion of lcs FALSE
			// as we will re-enter the same critical section
			//
			// CancelWMIEventRegistartion doesn't throw exception !
			//

			lcs.Exec( FALSE );

			ULONG_PTR uRc =(ULONG_PTR)this;
 			WMI.CancelWMIEventRegistration(pReq->gGuid,uRc);

			delete pReq;
			pReq = NULL;

			//
			// re-enter the same critical section here
			// its flag of execution is FALSE which means
			// that it will be left final time by destructor
			// of LeaveCS data type ( lcs )
			//
			EnterCS ecs1 ( g_pEventCs );

			nSize = g_apRequests.Size();
		}
		else
		{
			i++;
		}
	}
	CheckImpersonationLevel();

	return WBEM_S_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////
int CWMIEvent::NoMoreEventConsumersRegistered(GUID gGuid)
{
	EnterCS ecs(g_pEventCs);
	LeaveCS lcs(g_pEventCs);

	int nTotalNumberOfRegisteredEventConsumers = 0;
	WMIEventRequest * pEvent;

    for(int i = 0; i < g_apRequests.Size(); i++)
	{
        pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);
        if( pEvent->gGuid == gGuid)
		{
            nTotalNumberOfRegisteredEventConsumers++;
        }

    }
	return nTotalNumberOfRegisteredEventConsumers;
}
////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::IsGuidInListIfSoGetCorrectContext(GUID gGuid, WMIEventRequest *& pEvent )
{
	EnterCS ecs(g_pEventCs);
	LeaveCS lcs(g_pEventCs);

	for( int i = 0; i < g_apRequests.Size(); i++ )
	{
		pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);
		if( pEvent->gGuid == gGuid){
			return TRUE;
		}
	}

	pEvent = NULL;
    return FALSE;
}
////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::IsGuidInList(WCHAR * wcsGuid, WMIEventRequest *& pEvent)
{
	EnterCS ecs(g_pEventCs);
	LeaveCS lcs(g_pEventCs);

	BOOL fRc = FALSE;
    int Size = g_apRequests.Size();

    for(int i =0 ; i < Size; i++ ){

        pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);

		if( (_wcsicmp(pEvent->wcsGuid,wcsGuid)) == 0 ){
            fRc = TRUE;
            break;
        }
    }
    
    return fRc;

}

////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::IsIndexInList ( WCHAR * wcsGuid, DWORD dwIndex )
{
	EnterCS ecs(g_pEventCs);
	LeaveCS lcs(g_pEventCs);

	BOOL fRc = FALSE;
    int Size = g_apRequests.Size();

    for(int i =0 ; i < Size; i++ ){

        WMIEventRequest* pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);

		if( (_wcsicmp(pEvent->wcsGuid,wcsGuid)) == 0 )
		{
			if ( pEvent->dwId == dwIndex )
			{
				fRc = TRUE;
				break;
			}
        }
    }
    
    return fRc;

}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::RegisterForRequestedEvent( DWORD dwId,  WCHAR * wcsClass, WORD wType)
{
    BOOL fRegistered = FALSE;
    CWMIStandardShell WMI;
    HRESULT hr = WBEM_E_ACCESS_DENIED;
	BOOL fInternalEvent = TRUE;
	if( wType == STANDARD_EVENT	)
	{
		fInternalEvent = FALSE;
	}

	if( SUCCEEDED(WMI.Initialize	(
										wcsClass,
										fInternalEvent,
										&m_HandleMap,
										TRUE,
										WMIGUID_NOTIFICATION|WMIGUID_QUERY,
										m_pEventServices,
										m_pEventRepository,
										m_pEventHandler,
										m_pEventCtx
									)))
	{

		if( m_nType == WMIEVENT )
		{
			hr = CheckImpersonationLevel();
		}
		else
		{
			HRESULT t_TempResult = RevertToSelf();
			#ifdef	DBG
			if ( FAILED ( t_TempResult ) )
			{
				DebugBreak();
			}
			#endif	DBG

			hr = S_OK;
		}

		if( SUCCEEDED(hr) )
		{
			WCHAR wcsGuid[128];
        
			hr = WMI.SetGuidForEvent( wType, wcsGuid, 128 );
			if( SUCCEEDED(hr)){

				WMIEventRequest * pAlreadyRegisteredEvent;

				//===========================================================
				//  Keep a record of this guy, see if it is already registered
				//  if it is/isn't we call WDM with different flags
				//===========================================================
				fRegistered = IsGuidInList( wcsGuid, pAlreadyRegisteredEvent );
				
				//===========================================================
				//  Register for the requested event
				//===========================================================
				ULONG_PTR uRc =(ULONG_PTR)this;
 
				CLSID Guid;
				hr = WMI.RegisterWMIEvent(wcsGuid,uRc,Guid,fRegistered);
				if( SUCCEEDED(hr) )
				{
					BOOL bRegister = TRUE ;
					if ( fRegistered )
					{
						//
						// verify that there is no event request
						// containing the index already in the global array
						//
						bRegister = !IsIndexInList ( wcsGuid, dwId ) ;
					}

					if ( bRegister )
					{
						//=======================================================
						//  If we succeeded, then add it to our list of events we
						//  are watching
						//=======================================================
						WMIEventRequest * pEvent = new WMIEventRequest;
						if( pEvent ) {
							pEvent->gGuid = Guid;
							pEvent->dwId = dwId;
							pEvent->fHardCoded = wType;
							wcscpy( pEvent->wcsGuid,wcsGuid);
            				pEvent->SetClassName(wcsClass);
							pEvent->AddPtrs(m_pEventHandler,m_pEventServices,m_pEventRepository,m_pEventCtx);

							g_apRequests.Add(pEvent);

						} else hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
			}
		}
		CheckImpersonationLevel();
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////
CWMIEventProvider::CWMIEventProvider(int nType) : CWMIEvent(nType)
{
	if ( m_bInitialized )
	{
		m_hResyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		DEBUGTRACE((THISPROVIDER,"Event Provider constructed\n"));
	}
	else
	{
		ERRORTRACE((THISPROVIDER,"Event Provider construction failed\n"));
	}
}
////////////////////////////////////////////////////////////////////////
CWMIEventProvider::~CWMIEventProvider()
{
	if ( m_bInitialized )
	{
		UnInitializeProvider ( ) ;

		DEBUGTRACE((THISPROVIDER,"No longer registered for WDM events\n"));        
		DEBUGTRACE((THISPROVIDER,"Event Provider denstructed\n"));
	}
}

////////////////////////////////////////////////////////////////////////

STDMETHODIMP CWMIEventProvider::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

	if(riid == IID_IUnknown)
	{
        *ppv = this;
	}
	else
    if(riid == IID_IWbemEventProvider)
    {
        *ppv = (IWbemEventProvider*)this;
    }
    else if(riid == IID_IWbemEventProviderQuerySink)
    {
        *ppv = (IWbemEventProviderQuerySink*)this;
    }
    else if (IsEqualIID(riid, IID_IWbemProviderInit)) 
    {
        *ppv = (IWbemProviderInit *) this ;
    }
    else if (IsEqualIID(riid, IID_IWbemEventProviderSecurity)) 
    {
        *ppv = (IWbemEventProviderSecurity *) this ;
    }

    if( *ppv)
    {
        AddRef();
        hr = S_OK;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE CWMIEventProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}
////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE CWMIEventProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);

    if(lRef == 0){
	    //**********************************************
		// reference count is zero, delete this object.
	    // and do all of the cleanup for this user,
		//**********************************************
    	delete this ;
    }
    return lRef;
}
/////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::Initialize(LPWSTR wszUser, long lFlags, 
                                LPWSTR wszNamespace,
                                LPWSTR wszLocale, 
                                IWbemServices* pNamespace, 
                                IWbemContext* pCtx,
                                IWbemProviderInitSink* pSink)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
    if(pNamespace != NULL)
	{
		IWbemClassObject * pWMIClass = NULL;
		if ( SUCCEEDED ( hr = pNamespace->GetObject(WMI_EVENT_CLASS, 0, NULL, &pWMIClass, NULL) ) )
		{
			hr = InitializeProvider	(
										wszNamespace,
										wszLocale,
										pNamespace,
										pCtx,
										pSink,
										&m_HandleMap,
										&m_pEventServices,
										&m_pEventRepository,
										&m_pEventCtx,
										FALSE
									) ;
		}

		SAFE_RELEASE_PTR(pWMIClass);
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink,long lFlags)
{
	EnterCS ecs(g_pEventCs);
	LeaveCS lcs(g_pEventCs);

	SetEventHandler(pSink);

	// ===============================================================================
	// Make sure any request added before this was called gets the updated handler
	// PROVIDING it isn't the binary mof guid
	// ===============================================================================
	for(int i = 0; i < g_apRequests.Size(); i++)
	{
		WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];
		if(!pReq->pHandler)
		{
			if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,pReq->gGuid) ||
				IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,pReq->gGuid) ) 
			{
			}
			else
			{
				if( !pReq->pHandler )
				{
					pReq->pHandler = pSink;
				}
			}

		}
	}

	return S_OK;
}
////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::NewQuery( DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery)
{
   HRESULT hRes = WBEM_S_NO_ERROR;

   if (_wcsicmp(wszLanguage, L"WQL") != 0) 
   {
      hRes = WBEM_E_INVALID_QUERY_TYPE;
   }
   if( hRes == WBEM_S_NO_ERROR )
   {
		// Parse the query
		// Construct the lex source
		// ========================
	    CTextLexSource Source(wszQuery);
		// Use the lex source to set up for parser
		// =======================================
		SQL1_Parser QueryParser(&Source);

		SQL_LEVEL_1_RPN_EXPRESSION * pParse;
		int ParseRetValue = QueryParser.Parse(&pParse);
		if( SQL1_Parser::SUCCESS != ParseRetValue) {
			hRes = WBEM_E_INVALID_QUERY;
		}
		else{
		    //Set the class
			if( pParse )
			{
				hRes = RegisterForRequestedEvent(dwId,pParse->bsClassName,STANDARD_EVENT);

				delete pParse;
				pParse = NULL;
			}
		}
	}
	
    return hRes;
}
////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::CancelQuery(DWORD dwId)
{
	HRESULT hr = WBEM_E_FAILED;
	hr = RemoveWMIEvent(dwId);
	return hr;
}
////////////////////////////////////////////////////////////////////////

STDMETHODIMP CWMIEventProvider::AccessCheck(WBEM_CWSTR wszLanguage,   
											WBEM_CWSTR wszQuery, 
											long lSidLength,
											const BYTE* aSid)
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

	//=======================================================
	//  Check platform
	//=======================================================
    if(!IsNT())
        return WBEM_S_FALSE;

	//=======================================================
	//  Check query language
	//=======================================================
	if (_wcsicmp(wszLanguage, L"WQL") != 0) {
		return WBEM_E_INVALID_QUERY_TYPE;
	}

	//=======================================================
	//  If the PSid is NULL, then check impersonation level
	//  as usual - based on the thread
	//=======================================================

    PSID pSid = (PSID)aSid;
    HANDLE hToken = NULL;
    if(pSid == NULL){
	    //=================================================
	    //  if this is the INTERNAL_EVENT class, then we
		//  do not want the local events set up again.
		//=================================================
        BOOL VerifyLocalEventsAreSetup = TRUE;

		if( m_nType == INTERNAL_EVENT ){
			VerifyLocalEventsAreSetup = FALSE;
		}

	    hr = CheckImpersonationLevel() ;
    }
	else{
 		//=======================================================
		// Parse the query
		//=======================================================
		CTextLexSource Source(wszQuery);

		//=======================================================
		// Use the lex source to set up for parser
		//=======================================================
		SQL1_Parser QueryParser(&Source);

		SQL_LEVEL_1_RPN_EXPRESSION * pParse;

		int ParseRetValue = QueryParser.Parse(&pParse);
		if( SQL1_Parser::SUCCESS != ParseRetValue) {
			return WBEM_E_INVALID_QUERY;
		}
		else{
			if( pParse ){

				CWMIStandardShell WMI;
				if( SUCCEEDED(WMI.Initialize	(
													pParse->bsClassName,
													FALSE,
													&m_HandleMap,
													TRUE,
													WMIGUID_NOTIFICATION|WMIGUID_QUERY,
													m_pEventServices,
													m_pEventRepository,
													m_pEventHandler,
													m_pEventCtx
												)))
				{
    				CLSID * pGuid;

					pGuid = WMI.GuidPtr();
             		if(pGuid != NULL)
					{  
						//========================================
						// Get the ACL
						//========================================
						PACL pDacl;
						PSECURITY_DESCRIPTOR psd = NULL;
						SE_OBJECT_TYPE ObjectType = SE_WMIGUID_OBJECT;
                    
						hr = WBEM_E_ACCESS_DENIED;

						WCHAR * GuidName = NULL;

						hr = UuidToString(pGuid, &GuidName);
						if (hr == RPC_S_OK)
						{
							hr = S_OK;
							DWORD dwRc = GetNamedSecurityInfo(GuidName,ObjectType,DACL_SECURITY_INFORMATION,NULL,NULL,&pDacl, NULL, &psd );
							if( dwRc != ERROR_SUCCESS )
							{
								ERRORTRACE((THISPROVIDER, "GetNamedSecurityInfo returned %ld.\n", dwRc ));
								hr = WBEM_E_ACCESS_DENIED;
							}
						}
						if( GuidName )
						{
							RpcStringFree(&GuidName);
						}
            			if(SUCCEEDED(hr))
						{
							//====================================
							// This is our own ACL walker
							//====================================
     
							DWORD dwAccessMask;
							NTSTATUS st = GetAccessMask((PSID)pSid, pDacl, &dwAccessMask);
							if(st)
							{
								ERRORTRACE((THISPROVIDER, "WDM event provider unable "
											"to retrieve access mask for the creator of "
											"registration %S: NT status %d.\n"
											"Registration disabled\n", wszQuery,st));
								return WBEM_E_FAILED;
							}

    						if((dwAccessMask & WMIGUID_QUERY) == 0)
							{
	    						hr = WBEM_E_ACCESS_DENIED;
		    				}
			    			else
							{
				    			hr = S_OK;
								m_nType = PERMANENT_EVENT;
							}
						}
						if( psd != NULL)
						{
							AccFree( psd );
						}
					}
					delete pParse;
				}
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////
void CWMIEvent::WMIEventCallback(PWNODE_HEADER WnodeHeader)
{
        LPGUID EventGuid = &WnodeHeader->Guid;	    

		ERRORTRACE((THISPROVIDER,"Received Event\n"));
	    //=======================================================
	    //  We only support WNODE_FLAG_ALL_DATA and 
	    //  WNODE_FLAG_SINGLE_INSTANCE
	    //
	    //  Parse thru whatever it is and send it off to HMOM
	    //=======================================================
	    if( WnodeHeader )
		{
            HRESULT hr;
	        WMIEventRequest * pEvent;
            //===========================================================
            //  Make sure it is an event we want
            //===========================================================
			if( IsGuidInListIfSoGetCorrectContext( *EventGuid,pEvent))
			{

        		CWMIStandardShell WMI;
				//=======================================================
				//  See if a binary mof event is being added or deleted
				//=======================================================
				WORD wBinaryMofType = 0;
				BOOL fInternalEvent = FALSE;
				if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,WnodeHeader->Guid))
				{
					fInternalEvent = TRUE;
					wBinaryMofType = MOF_ADDED;
				}
				else if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,WnodeHeader->Guid))
				{
					fInternalEvent = TRUE;
					wBinaryMofType = MOF_DELETED;
				}

				IWbemServices* pServices = NULL;
				if( SUCCEEDED(pEvent->gipServices.Localize(&pServices)))
				{
					// release upon destruction
					OnDeleteObj0 <IWbemServices, ULONG(__stdcall IWbemServices:: *)(), IWbemServices::Release> pServicesRelease (pServices);

					IWbemServices* pRepository = NULL;
					if( SUCCEEDED(pEvent->gipRepository.Localize(&pRepository)))
					{
						// release upon destruction
						OnDeleteObj0 <IWbemServices, ULONG(__stdcall IWbemServices:: *)(), IWbemServices::Release> pRepositoryRelease (pRepository);

						if( SUCCEEDED(WMI.Initialize	(
															pEvent->pwcsClass,
															fInternalEvent,
															&m_HandleMap,
															TRUE,
															WMIGUID_QUERY|WMIGUID_NOTIFICATION,
															pServices,
															pRepository,
															pEvent->pHandler,
															pEvent->pCtx
														)))
						{
							//=======================================================
							//  If it was, then process it, otherwise go on... :)
							//=======================================================
							WMI.ProcessEvent(wBinaryMofType,WnodeHeader);
						}
					}
				}
			}
	    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wmiguard.cpp ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name:

	Wmiguard.cpp

--*/

#include "precomp.h"
#include "wmiguard.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiGuard :: WmiGuard ( ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiGuard :: ~WmiGuard ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiGuard :: TryEnter()
{
	HRESULT hr = E_UNEXPECTED;
	if ( m_pCS != NULL )
	{
		try
		{
			if ( m_pCS->TryEnter () )
			{
				hr = S_OK;
			}
			else
			{
				hr = S_FALSE ;
			}
		}
		STANDARD_CATCH
	}

	return hr;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiGuard :: Enter()
{
	HRESULT hr = E_UNEXPECTED;
	if ( m_pCS != NULL )
	{
		try
		{
			m_pCS->Enter ();
			hr = S_OK;
		}
		STANDARD_CATCH
	}

	return hr;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiGuard :: Leave()
{
	HRESULT hr = E_UNEXPECTED;
	if ( m_pCS != NULL )
	{
		try
		{
			m_pCS->Leave ();
			hr = S_OK;
		}
		STANDARD_CATCH
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wdmperf.h ===
//////////////////////////////////////////////////////////////////////////////////////////////

//

//	WDMPerf.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////

#ifndef __WBEM_WMI_HIPERF_PROVIDER__H_
#define __WBEM_WMI_HIPERF_PROVIDER__H_

class CWMI_Prov;
//////////////////////////////////////////////////////////////
//
//	Constants and globals
//	
//////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	CRefresher
//
//	The refresher maintains an object and an enumerator cache. When an enumerator is added to the refrehser
//  it is added to the enumerator cache, and the index of the array is passed back as a unique ID.  
//  The refresher creates a cache of all instances during its initialization.  When an object 
//	is added to the refresher, a mapping to the object is created between the unique ID and the index of 
//  the object in the cache.  This allows the objects to be reused and facilitates the management of objects 
//  that have been added multiple times.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

class CRefresher : public IWbemRefresher
{
    private:
	    //===================================================
        // COM reference counter & other stuff...
	    //===================================================
        long                m_lRef;

	    //===================================================
        // The list of instances for this refresher, which
        // are clones of the provider's master list
	    //===================================================
        CHiPerfHandleMap    m_HiPerfHandleMap;
	    //===================================================
	    // The parent provider
	    //===================================================
	    CWMI_Prov*   m_pProvider;

    public:

	    CRefresher(CWMI_Prov* pProvider);
	    virtual ~CRefresher();

        CHiPerfHandleMap * HiPerfHandleMap() { return &m_HiPerfHandleMap;}
	    //===================================================
	    // COM methods
	    //===================================================

	    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	    STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

	    STDMETHODIMP Refresh(/* [in] */ long lFlags);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wmiprov.h ===
////////////////////////////////////////////////////////////////////
//
//  WMIProv.h
//
//  Purpose: Include file for the WMI_Provider
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//	history:
//		05/16/97	jennymc		updated
//
////////////////////////////////////////////////////////////////////

#ifndef _WMIPROV_H_
#define _WMIPROV_H_

class CRefresher;
class CRefCacheElement;
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Provider interfaces are provided by objects of this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

class CCritical_SectionWrapper
{
private:

	CRITICAL_SECTION *m_cs;

public:
	
	CCritical_SectionWrapper( CRITICAL_SECTION * cs): m_cs (NULL)
	{
		if (cs)
		{
			try
			{
				EnterCriticalSection(cs);
				m_cs = cs;
			}
			catch(...)
			{
			}
		}
	}

	~CCritical_SectionWrapper()
	{
		if (m_cs)
		{
			try
			{
				LeaveCriticalSection(m_cs);
			}
			catch(...)
			{
			}
		}
	}

	BOOL IsLocked () { return (m_cs != NULL); }
};

class CWMI_Prov : public IWbemServices, public IWbemProviderInit,public IWbemHiPerfProvider
{

	protected:
        long                    m_cRef;
        IWbemServices         * m_pIWbemServices;
        IWbemServices         * m_pIWbemRepository;
        CHandleMap              m_HandleMap;
        CHiPerfHandleMap        m_HiPerfHandleMap;

#if defined(_WIN64)
		CRITICAL_SECTION m_CS;
		WmiAllocator *m_Allocator ;
		WmiHashTable <LONG, ULONG_PTR, 17> *m_HashTable; 
		LONG m_ID;
#endif

	private:

		BOOL					m_bInitialized ;

	public:

		inline BOOL				Initialized ()
		{
			return m_bInitialized ;
		}

        inline CHiPerfHandleMap      * HandleMapPtr()        { return &m_HiPerfHandleMap; }
        inline IWbemServices         * ServicesPtr()         { return m_pIWbemServices;}
        inline IWbemServices         * RepositoryPtr()       { return m_pIWbemRepository;}

		enum{
			SUCCESS = 0,
			FAILURE = 1,
			NO_DATA_AVAILABLE = 2,
			DATA_AVAILABLE
		};


        CWMI_Prov();
        ~CWMI_Prov(void);

		//=======================================================
        // Non-delegating object IUnknown
		//=======================================================

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//=======================================================
        //IWbemServices supported interfaces
		//=======================================================
        STDMETHOD(OpenNamespace) (
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);

		STDMETHOD(Initialize)( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);
			
        STDMETHOD(GetObjectAsync)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        STDMETHOD(CreateInstanceEnumAsync)(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        STDMETHOD(PutInstanceAsync)(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

		//========================================================
        //	IWbemServices unsupported interfaces
		//========================================================
        STDMETHOD(GetTypeInfoCount)	(THIS_ UINT * pctinfo) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(GetTypeInfo)		(THIS_ UINT itinfo, LCID lcid, ITypeInfo * * pptinfo) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(GetIDsOfNames)	(THIS_  REFIID riid, OLECHAR * * rgszNames, UINT cNames,LCID lcid, DISPID * rgdispid) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(Invoke)			(THIS_   DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,   UINT * puArgErr) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(GetObject)(            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(PutClassAsync)(            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(CreateClassEnum)(/* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
			{ return E_NOTIMPL;}

        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return E_NOTIMPL;}

        STDMETHOD(PutInstance)	 (
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteInstanceAsync)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecQuery)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecQueryAsync)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        STDMETHOD(CancelAsyncRequest)(THIS_ long lAsyncRequestHandle)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(CancelAsyncCall)(THIS_ IWbemObjectSink __RPC_FAR *pSink)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(QueryObjectSink)(THIS_ /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(PutClass)(    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteClass)(            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteClassAsync)(    /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecNotificationQuery)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
            			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecMethod)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
            			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecMethodAsync)(    /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        //==========================================================
	    // IWbemHiPerfProvider COM interfaces
        //==========================================================

	    STDMETHOD(QueryInstances)( IWbemServices __RPC_FAR *pNamespace, WCHAR __RPC_FAR *wszClass,
		                             long lFlags, IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pSink );
    
	    STDMETHOD(CreateRefresher)( IWbemServices __RPC_FAR *pNamespace, long lFlags, IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
    
	    STDMETHOD(CreateRefreshableObject)( IWbemServices __RPC_FAR *pNamespace, IWbemObjectAccess __RPC_FAR *pTemplate,
		                                      IWbemRefresher __RPC_FAR *pRefresher, long lFlags,
		                                      IWbemContext __RPC_FAR *pContext, IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		                                      long __RPC_FAR *plId );
    
	    STDMETHOD(StopRefreshing)( IWbemRefresher __RPC_FAR *pRefresher, long lId, long lFlags );

	    STDMETHOD(CreateRefreshableEnum)( IWbemServices* pNamespace, LPCWSTR wszClass, IWbemRefresher* pRefresher,
		                                    long lFlags, IWbemContext* pContext, IWbemHiPerfEnum* pHiPerfEnum, long* plId);

	    STDMETHOD(GetObjects)( IWbemServices* pNamespace, long lNumObjects, IWbemObjectAccess** apObj,
                                 long lFlags, IWbemContext* pContext);
};

class CWMIHiPerfProvider : public CWMI_Prov
{
		STDMETHOD(Initialize)( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\wdmprovider\wmiprov.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  WMIProv.CPP
//
//  Module: WMI Provider class methods
//
//  Purpose: Provider class definition.  An object of this class is
//           created by the class factory for each connection.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////
#include "precomp.h"

extern long glInits;
extern long glProvObj;
extern long glEventsRegistered ;

extern CWMIEvent *  g_pBinaryMofEvent;

extern CCriticalSection * g_pLoadUnloadCs ;

#include "wmiguard.h"
extern WmiGuard * pGuard;

#include <helper.h>
typedef OnDeleteObj0 <WmiGuard, HRESULT(WmiGuard:: *)(), WmiGuard::Leave> WmiGuardLeave;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT VerifyLocalEventsAreRegistered()
{
	HRESULT hr = E_FAIL ;
    if( !g_pBinaryMofEvent->RegisterForInternalEvents())
    {
        InterlockedCompareExchange (&glEventsRegistered, 0, glEventsRegistered);
		ERRORTRACE((THISPROVIDER,"Failed Registeration for Mof Events\n"));
    }
	else
	{
		DEBUGTRACE((THISPROVIDER,"Successfully Registered for Mof Events\n"));
		hr = S_OK ;
	}
	return hr ;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAllBinaryMofs	(
									CHandleMap * pMap,
									IWbemServices __RPC_FAR *pNamespace,
									IWbemServices __RPC_FAR *pRepository,
									IWbemContext __RPC_FAR *pCtx
								)
{
	HRESULT hr = E_FAIL ;
	CWMIBinMof Mof;
	
	if( SUCCEEDED( hr = Mof.Initialize(pMap,TRUE,WMIGUID_EXECUTE|WMIGUID_QUERY,pNamespace,pRepository,NULL,pCtx)))
	{
		HRESULT t_TempResult = RevertToSelf();
		#ifdef	DBG
		if ( FAILED ( t_TempResult ) )
		{
			DebugBreak();
		}
		#endif	DBG

		Mof.ProcessListOfWMIBinaryMofsFromWMI();
		CheckImpersonationLevel();
	}

	return hr ;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT InitializeBinaryMofs 	(
									IWbemServices __RPC_FAR *pNamespace,
									IWbemServices __RPC_FAR *pRepository,
									IWbemContext __RPC_FAR *pCtx
								)
{
	HRESULT hr = E_FAIL ;

	//==============================================================
	//  Register for hardcoded event to be notified of WMI updates
	//  make it a member var, so it stays around for the life
	//  of the provider
	//==============================================================

	try
	{
		g_pBinaryMofEvent->SetEventServices(pNamespace);
		g_pBinaryMofEvent->SetEventRepository(pRepository);
		g_pBinaryMofEvent->SetEventContext(pCtx);

		hr = VerifyLocalEventsAreRegistered();
	}
	STANDARD_CATCH

	if ( FAILED ( hr ) )
	{
		//
		// must clear global object so next
		// initialization will have a chance
		//

		g_pBinaryMofEvent->ReleaseAllPointers () ;
	}

	return hr ;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*********************************************************************
//  Check the impersonation level
//*********************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;
	HANDLE hThreadTok;

    if (IsNT())
    {
		if( GetUserThreadToken(&hThreadTok) )
        {
	        DWORD dwImp, dwBytesReturned;
	        if (GetTokenInformation( hThreadTok, TokenImpersonationLevel, &dwImp, sizeof(DWORD), &dwBytesReturned))
			{
                // Is the impersonation level Impersonate?
                if ((dwImp == SecurityImpersonation) || ( dwImp == SecurityDelegation) )
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_ACCESS_DENIED;
                    ERRORTRACE((THISPROVIDER,IDS_ImpersonationFailed));
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
                ERRORTRACE((THISPROVIDER,IDS_ImpersonationFailed));
            }

            // Done with this handle
            CloseHandle(hThreadTok);
        }
     
    }
    else
    {
        // let win9X in...
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT GetRepository	( 
							/* [in] */ LPWSTR pszNamespace,
							/* [in] */ LPWSTR pszLocale,
							/* [in] */ IWbemContext __RPC_FAR *pCtx,
							/* [out] */ IWbemServices __RPC_FAR ** pServices
						) 
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER ;
	if ( pszNamespace )
	{
		IWbemLocator* pLocator = NULL ;
		hr = ::CoCreateInstance ( __uuidof ( WbemLocator ), NULL, CLSCTX_INPROC_SERVER, __uuidof ( IWbemLocator ), (void**) &pLocator ) ;

		if ( SUCCEEDED ( hr ) )
		{
			// release upon destruction
			OnDeleteObj0 <IWbemLocator, ULONG(__stdcall IWbemLocator:: *)(), IWbemLocator::Release> pLocatorRelease ( pLocator ) ;

			hr = pLocator->ConnectServer	(
												pszNamespace ,
												NULL ,
												NULL ,
												pszLocale ,
												WBEM_FLAG_CONNECT_REPOSITORY_ONLY ,
												NULL ,
												pCtx ,
												pServices
											) ;
		}
	}

	return hr ;
}

////////////////////////////////////////////////////////////////////
HRESULT InitializeProvider	( 
								/* [in] */ LPWSTR pszNamespace,
								/* [in] */ LPWSTR pszLocale,
								/* [in] */ IWbemServices __RPC_FAR *pNamespace,
								/* [in] */ IWbemContext __RPC_FAR *pCtx,
								/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink,

								/* [in] */  CHandleMap * pMap,
								/* [out] */ IWbemServices ** ppServices,
								/* [out] */ IWbemServices ** ppRepository,
								/* [out] */ IWbemContext  ** ppCtx,

								/* [in] */ BOOL bProcessMof
							)
{
	//
	// avoid collision with un-initialization
	//
	g_pLoadUnloadCs->Enter ();
	InterlockedIncrement ( &glProvObj ) ;
	g_pLoadUnloadCs->Leave ();

	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if(pNamespace!=NULL)
	{
		//===============================================

		(*ppServices) = pNamespace;
		(*ppServices)->AddRef();

		if ( pCtx )
		{
			if ( ppCtx )
			{
				(*ppCtx) = pCtx;
				(*ppCtx)->AddRef();
			}
		}

		if ( SUCCEEDED ( hr = GetRepository ( pszNamespace, pszLocale, pCtx, ppRepository ) ) )
		{
			if ( S_OK == ( hr = pGuard->TryEnter () ) )
			{
				WmiGuardLeave wql ( pGuard ) ;

				if( 0 == InterlockedCompareExchange ( &glEventsRegistered, 1, 0 ) )
				{
					hr = InitializeBinaryMofs ( *ppServices, *ppRepository, pCtx ) ;
				}
			}

			if ( SUCCEEDED ( hr ) && bProcessMof )
			{
				if( 0 == InterlockedCompareExchange ( &glInits, 1, 0 ) )
				{
					try
					{
						hr = ProcessAllBinaryMofs ( pMap, *ppServices, *ppRepository, pCtx ) ;
					}
					STANDARD_CATCH

					if ( FAILED ( hr ) )
					{
						//
						// let's try to process mofs next time
						//
						InterlockedCompareExchange ( &glInits, 0, glInits ) ;
					}
				}
			}
		}

		if ( SUCCEEDED ( hr ) )
		{
			pInitSink->SetStatus ( WBEM_S_INITIALIZED, 0 ) ;
		}
		else
		{
			pInitSink->SetStatus ( WBEM_E_FAILED , 0 ) ;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// this function assumes that InitializeProvider (called from within IWbemProviderInit) 
// is always called. That basically means that IWbemProviderInit is always called.
//
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT UnInitializeProvider ( )
{
	HRESULT hr = WBEM_S_FALSE ;
	BOOL bContinue = FALSE;

	{
		//
		// let's find out if this is
		// possibly last provider here
		//
		CAutoBlock block (g_pLoadUnloadCs);

		//
		// check to see if we did InitializeProvider
		//
		if ( 0 <= InterlockedCompareExchange ( &glProvObj, glProvObj, 0 ) )
		{
			if ( 0 == InterlockedDecrement ( &glProvObj ) )
			{
				bContinue = TRUE ;
			}
		}
		else
		{
			#ifdef	_DEBUG
			DebugBreak () ;
			#endif
		}
	}

	if ( bContinue )
	{
		//
		// registartion and unregistration must be exclusive
		//
		if ( SUCCEEDED ( pGuard->Enter() ) )
		{
			WmiGuardLeave wgl ( pGuard );

			//
			// verify that binary notifications were 
			// successfully initialized
			//
			if ( 1 == InterlockedCompareExchange ( &glEventsRegistered, glEventsRegistered, 1 ) )
			{
				g_pBinaryMofEvent->DeleteBinaryMofResourceEvent();

				//
				// avoid collision with initialization
				//
				CAutoBlock block (g_pLoadUnloadCs);

				//
				// check to see there was not provider re-entrancy
				//
				if ( 0 == InterlockedCompareExchange ( &glProvObj, glProvObj, 0 ) )
				{
					g_pBinaryMofEvent->ReleaseAllPointers();

					InterlockedCompareExchange (&glEventsRegistered, 0, glEventsRegistered);
					DEBUGTRACE((THISPROVIDER,"No longer registered for Mof events\n"));

					//
					// we want to process binary mofs next initialize
					// as this was the last provider
					//
					InterlockedCompareExchange ( &glInits, 0, 1 );
				}
				else
				{
					//
					// seems like there was a callback instantiating 
					// another provider as it was adding/deleting
					// classes 
					//
					// as InitializeProvider now skipped InitializeBinaryMofs
					// we must re-register what was cancelled here
					//
					// this way we keep possibility to respond
					// to add/delete binary mofs
					//

					try
					{
						hr = VerifyLocalEventsAreRegistered();
					}
					STANDARD_CATCH

					if ( FAILED ( hr ) )
					{
						//
						// must clear global object so next
						// initialization will have a chance
						//
						g_pBinaryMofEvent->ReleaseAllPointers () ;

						//
						// let's try to process mofs next time
						//
						InterlockedCompareExchange ( &glInits, 0, glInits ) ;
					}
				}
			}
		}
	}

	return hr ;
}

////////////////////////////////////////////////////////////////////
//******************************************************************
//
//   PUBLIC FUNCTIONS
//
//******************************************************************
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::CWMI_Prov
//
////////////////////////////////////////////////////////////////////
CWMI_Prov::CWMI_Prov() :
m_cRef ( 0 ),
m_pIWbemServices ( NULL ),
m_pIWbemRepository ( NULL ),
m_bInitialized ( FALSE )
{
	if ( m_HandleMap.IsValid () )
	{
#if defined(_WIN64)

	BOOL bAllocated = FALSE ;

	m_Allocator = NULL;
	m_HashTable = NULL;
	m_ID = 0;

	try
	{
		if ( TRUE == InitializeCriticalSectionAndSpinCount ( &m_CS, 0 ) )
		{
			WmiAllocator t_Allocator ;

			WmiStatusCode t_StatusCode = t_Allocator.New (
				( void ** ) & m_Allocator ,
				sizeof ( WmiAllocator ) 
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				:: new ( ( void * ) m_Allocator ) WmiAllocator ;

				t_StatusCode = m_Allocator->Initialize () ;

				if ( t_StatusCode != e_StatusCode_Success )
				{
					t_Allocator.Delete ( ( void * ) m_Allocator	) ;
					m_Allocator = NULL;
					DeleteCriticalSection(&m_CS);
				}
				else
				{
					m_HashTable = ::new WmiHashTable <LONG, ULONG_PTR, 17> ( *m_Allocator ) ;
					t_StatusCode = m_HashTable->Initialize () ;
					
					if ( t_StatusCode != e_StatusCode_Success )
					{
						m_HashTable->UnInitialize () ;
						::delete m_HashTable;
						m_HashTable = NULL;
						m_Allocator->UnInitialize ();
						t_Allocator.Delete ( ( void * ) m_Allocator	) ;
						m_Allocator = NULL;
						DeleteCriticalSection(&m_CS);
					}
					else
					{
						bAllocated = TRUE ;
					}
				}
			}
			else
			{
				m_Allocator = NULL;
				DeleteCriticalSection(&m_CS);
			}
		}
	}
	catch (...)
	{
	}

	if ( bAllocated ) 
	{
#endif

	m_bInitialized = TRUE ;

#if defined(_WIN64)
	}
#endif
	}

	if ( m_bInitialized )
	{
		DEBUGTRACE((THISPROVIDER,"Instance Provider constructed\n"));
		InterlockedIncrement(&g_cObj);
	}
	else
	{
		ERRORTRACE((THISPROVIDER,"Instance Provider construction failed\n"));
	}
}

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::~CWMI_Prov
//
////////////////////////////////////////////////////////////////////
CWMI_Prov::~CWMI_Prov(void)
{
	if ( m_HandleMap.IsValid () )
	{
#if defined(_WIN64)
	if (m_HashTable)
	{
		WmiAllocator t_Allocator ;
		m_HashTable->UnInitialize () ;
		::delete m_HashTable;
		m_HashTable = NULL;
		m_Allocator->UnInitialize ();
		t_Allocator.Delete ( ( void * ) m_Allocator	) ;
		m_Allocator = NULL;
		DeleteCriticalSection(&m_CS);
#endif

	if ( m_bInitialized )
	{
		UnInitializeProvider ( ) ;

		DEBUGTRACE((THISPROVIDER,"Instance Provider destructed\n"));
		InterlockedDecrement(&g_cObj);
	}

    SAFE_RELEASE_PTR( m_pIWbemServices );
    SAFE_RELEASE_PTR( m_pIWbemRepository );

#if defined(_WIN64)
	}
#endif
	}
}
////////////////////////////////////////////////////////////////////
//
//  QueryInterface
//
////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::QueryInterface(REFIID riid, PPVOID ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) 
    {
        *ppvObj =(IWbemServices *) this ;
    }
    else if (IsEqualIID(riid, IID_IWbemServices)) 
    {
        *ppvObj =(IWbemServices *) this ;
    }
    else if (IsEqualIID(riid, IID_IWbemProviderInit)) 
    {
        *ppvObj = (IWbemProviderInit *) this ;
    }
    else if(riid == IID_IWbemProviderInit)
    {
        *ppvObj = (LPVOID)(IWbemProviderInit*)this;
    }
	else if (riid == IID_IWbemHiPerfProvider)
    {
		*ppvObj = (LPVOID)(IWbemHiPerfProvider*)this;
    }

    if(*ppvObj) 
    {
        AddRef();
        hr = NOERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	return InitializeProvider	(
									pszNamespace,
									pszLocale,
									pNamespace,
									pCtx,
									pInitSink,
									&m_HandleMap,
									&m_pIWbemServices,
									&m_pIWbemRepository
								) ;
}

//////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWMI_Prov::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CWMI_Prov::Release(void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::OpenNamespace
//
////////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::OpenNamespace(
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::CreateInstanceEnumAsync
//
// Purpose:  Asynchronously enumerates the instances of the 
//			 given class.  
//
////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::CreateInstanceEnumAsync(BSTR wcsClass, 
										   long lFlags, 
                                           IWbemContext __RPC_FAR *pCtx,
				 						   IWbemObjectSink __RPC_FAR * pHandler) 
{
	HRESULT hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;
    CWMIStandardShell WMI;
	if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_QUERY,m_pIWbemServices,m_pIWbemRepository,pHandler,pCtx)))
	{

		if (SUCCEEDED(hr = CheckImpersonationLevel()))
		{
			//============================================================
			//  Init and get the WMI Data block
			//============================================================
			if( pHandler != NULL ) 
			{
				//============================================================
				//  Parse through all of it
				//============================================================
				try
				{	
					hr = WMI.ProcessAllInstances();
				}
				STANDARD_CATCH
			}
		}
		WMI.SetErrorMessage(hr);
	}
    return hr;
}
//***************************************************************************
HRESULT CWMI_Prov::ExecQueryAsync( BSTR QueryLanguage,
                                   BSTR Query,
                                   long lFlags,
                                   IWbemContext __RPC_FAR *pCtx,
                                   IWbemObjectSink __RPC_FAR *pHandler)
{
    WCHAR wcsClass[_MAX_PATH+2];
    HRESULT hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;
    BOOL fRc = FALSE;

   	//============================================================
	// Do a check of arguments and make sure we have pointers 
   	//============================================================
    if( pHandler == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	try
    {
		//============================================================
		//  Get the properties and class to get
		//============================================================
		wcsClass [ 0 ] = 0;
		fRc = GetParsedPropertiesAndClass(Query,wcsClass,_MAX_PATH+2);
	}
    STANDARD_CATCH

	if ( fRc )
	{
		CWMIStandardShell WMI;
		if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pIWbemServices,m_pIWbemRepository,pHandler,pCtx)))
		{
			if( fRc )
			{
    			hr = CheckImpersonationLevel();
			}
			hr = WMI.SetErrorMessage(hr);
		}
	}
    return hr;
}
//***************************************************************************
//
// CWMI_Prov::GetObjectAsync
//
// Purpose:  Asynchronously creates an instance given a particular path value.
//
// NOTE 1:  If there is an instance name in the returned WNODE, then this is a
//			dynamic instance.  You can tell because the pWNSI->OffsetInstanceName
//			field will not be blank.  If this is the case, then the name will not
//			be contained within the datablock, but must instead be retrieved
//			from the WNODE.  See NOTE 1, below.
//
//***************************************************************************

HRESULT CWMI_Prov::GetObjectAsync(BSTR ObjectPath, long lFlags, 
                                  IWbemContext __RPC_FAR *pCtx, 
                                  IWbemObjectSink __RPC_FAR * pHandler )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    SetStructuredExceptionHandler seh;
    WCHAR wcsClass[_MAX_PATH*2];
    WCHAR wcsInstance[_MAX_PATH*2];
    //============================================================
    // Do a check of arguments and make sure we have pointers 
    //============================================================
    if(ObjectPath == NULL || pHandler == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

 	try
	{
		//============================================================
		//  Get the path and instance name
		//============================================================
		wcsClass [ 0 ] = 0;
		wcsInstance [ 0 ] = 0;

		hr = GetParsedPath( ObjectPath,wcsClass,_MAX_PATH*2,wcsInstance,_MAX_PATH*2,m_pIWbemServices );
	}
	STANDARD_CATCH

	if( SUCCEEDED(hr) )
	{
		if (SUCCEEDED(hr = CheckImpersonationLevel()))
		{
			try
			{
 			   CWMIStandardShell WMI;
	  		   if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_QUERY,m_pIWbemServices,m_pIWbemRepository,pHandler,pCtx)))
			   {
					//============================================================
					//  Get the WMI Block
    				//============================================================
    				hr = WMI.ProcessSingleInstance(wcsInstance);
					hr = WMI.SetErrorMessage(hr);
				}
			}
			STANDARD_CATCH
		}
	}
    return hr;
}
//***************************************************************************
//
// CWMI_Prov::PutInstanceAsync
//
// Purpose:  Asynchronously put an instance.
//
//***************************************************************************

HRESULT CWMI_Prov::PutInstanceAsync(IWbemClassObject __RPC_FAR * pIWbemClassObject, 
							   long lFlags, 
                               IWbemContext __RPC_FAR *pCtx,
                               IWbemObjectSink __RPC_FAR *pHandler )
{
	HRESULT	   hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;

    if(pIWbemClassObject == NULL || pHandler == NULL )
    {
	    return WBEM_E_INVALID_PARAMETER;
    }

	//===========================================================
	// Get the class name
	//===========================================================
    CVARIANT vName;
	hr = pIWbemClassObject->Get(L"__CLASS", 0, &vName, NULL, NULL);		
	if( SUCCEEDED(hr))
	{
	    CWMIStandardShell WMI;
		if( SUCCEEDED(WMI.Initialize(vName.GetStr(),FALSE,&m_HandleMap,TRUE,WMIGUID_SET|WMIGUID_QUERY,m_pIWbemServices,m_pIWbemRepository,pHandler,pCtx)))
		{
			if (SUCCEEDED(hr = CheckImpersonationLevel()))
			{
	   			//=======================================================
				//  If there is not a context object, then we know we are 
				//  supposed to put the whole thing, otherwise we are 
				//  supposed to put only the properties specified.
    			//=======================================================
    			try
				{    
    				if( !pCtx )
					{
	      				hr = WMI.FillInAndSubmitWMIDataBlob(pIWbemClassObject,PUT_WHOLE_INSTANCE,vName);
					}
					else
					{
	           			//===================================================
						// If we have a ctx object and the __PUT_EXTENSIONS
						// property is not specified, then we know we are
						// supposed to put the whole thing
        				//===================================================
						CVARIANT vPut;

						if( SUCCEEDED(pCtx->GetValue(L"__PUT_EXT_PROPERTIES", 0, &vPut)))
						{		
			      			hr = WMI.FillInAndSubmitWMIDataBlob(pIWbemClassObject,PUT_PROPERTIES_IN_LIST_ONLY,vPut);
						}
						else
						{
    	      				hr = WMI.FillInAndSubmitWMIDataBlob(pIWbemClassObject,PUT_WHOLE_INSTANCE,vPut);
						}
					}
				}
				STANDARD_CATCH
			}
		}
		hr = WMI.SetErrorMessage(hr);
	}

    return hr;
}
/************************************************************************
*                                                                       *      
*CWMIMethod::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation                     *
************************************************************************/
STDMETHODIMP CWMI_Prov::ExecMethodAsync(BSTR ObjectPath, 
										BSTR MethodName, 
										long lFlags, 
										IWbemContext __RPC_FAR * pCtx, 
										IWbemClassObject __RPC_FAR * pIWbemClassObject, 
										IWbemObjectSink __RPC_FAR * pHandler)
{
    CVARIANT vName;
    HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject * pClass = NULL; //This is an IWbemClassObject.
    WCHAR wcsClass[_MAX_PATH*2];
    WCHAR wcsInstance[_MAX_PATH*2];
    SetStructuredExceptionHandler seh;
	try
    {    
		//============================================================
		//  Get the path and instance name and check to make sure it
		//  is valid
		//============================================================
		wcsClass [ 0 ] = 0;
		wcsInstance [ 0 ] = 0;

		hr = GetParsedPath( ObjectPath,wcsClass,_MAX_PATH*2,wcsInstance,_MAX_PATH*2,m_pIWbemServices);
	}
    STANDARD_CATCH

	if ( SUCCEEDED ( hr ) )
	{
		CWMIStandardShell WMI;
		
		if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_EXECUTE|WMIGUID_QUERY,m_pIWbemServices,m_pIWbemRepository,pHandler,pCtx)))
		{
			if (SUCCEEDED(hr = CheckImpersonationLevel()))
			{
				//================================================================	
				//  We are ok, so proceed
				//================================================================	
				hr = m_pIWbemServices->GetObject(wcsClass, 0, pCtx, &pClass, NULL);
				if( SUCCEEDED(hr) )
				{
					//==========================================================
					//  Now, get the list of Input and Output parameters
					//==========================================================
					IWbemClassObject * pOutClass = NULL; //This is an IWbemClassObject.
					IWbemClassObject * pInClass = NULL; //This is an IWbemClassObject.

					hr = pClass->GetMethod(MethodName, 0, &pInClass, &pOutClass);
					if( SUCCEEDED(hr) )
					{
						try
						{
   							hr = WMI.ExecuteMethod( wcsInstance, MethodName,pClass, pIWbemClassObject,pInClass, pOutClass);
						}
						STANDARD_CATCH
					}
					SAFE_RELEASE_PTR( pOutClass );
					SAFE_RELEASE_PTR( pInClass );
					SAFE_RELEASE_PTR( pClass );
				}
			}
			hr = WMI.SetErrorMessage(hr);
		}
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	return InitializeProvider	(
									pszNamespace,
									pszLocale,
									pNamespace,
									pCtx,
									pInitSink,
									&m_HandleMap,
									&m_pIWbemServices,
									&m_pIWbemRepository,
									NULL,
									FALSE
								) ;
}

////////////////////////////////////////////////////////////////////
//******************************************************************
//
//   PRIVATE FUNCTIONS
//
//******************************************************************
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\joprocess.cpp ===
/******************************************************************

Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved 

   JOProcess.CPP -- WMI provider class implementation
  
******************************************************************/

#include "precomp.h"
#if NTONLY >= 5

#include "JOProcess.h"
#include <autoptr.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CJOProcess MyCJOProcess(
               PROVIDER_NAME_WIN32NAMEDJOBOBJECTPROCESS, 
               IDS_CimWin32Namespace);

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CJOProcess::CJOProcess( 
    LPCWSTR setName, 
    LPCWSTR pszNameSpace /*=NULL*/)
:	Provider(setName, pszNameSpace)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CJOProcess::~CJOProcess()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CJOProcess::GetObject( 
    CInstance* pInstance, 
    long lFlags /*= 0L*/ )
{
    return FindSingleInstance(pInstance);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CJOProcess::EnumerateInstances(
    MethodContext* pMethodContext, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Enumerate(pMethodContext);

    return hr;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// We will only optimize for the
// case where a specific job was
// specified.

HRESULT CJOProcess::ExecQuery (

    MethodContext *pMethodContext, 
    CFrameworkQuery& Query, 
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    std::vector<_bstr_t> rgJOs;
    DWORD dwJOsCount = 0L;
    Query.GetValuesForProp(L"Collection", rgJOs);
    dwJOsCount = rgJOs.size();

    if(dwJOsCount > 0)
    {
        CInstancePtr pInstJO;
        CHString chstrPath;

        for(DWORD x = 0; x < dwJOsCount; x++)
        {
            // First we see if the specified JO exists.
            chstrPath.Format(
                L"\\\\.\\%s:%s", 
                IDS_CimWin32Namespace, 
                (LPCWSTR)rgJOs[x]);

            hr = CWbemProviderGlue::GetInstanceKeysByPath(
                     chstrPath, 
                     &pInstJO, 
                     pMethodContext);

            if (SUCCEEDED(hr))
            {
                // Ok, the JO exists.  Enumerate its processes...
                // rgJOs[x] contains something like
                // Win32_NamedJobObject.CollectionID="myjob", 
                // from which I want just the myjob part.
                CHString chstrInstKey;
                if(GetInstKey(
                       CHString((LPCWSTR)rgJOs[x]),
                       chstrInstKey))
                {
                    hr = EnumerateProcsInJob(
                             chstrInstKey, 
                             pMethodContext);

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
                else
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
            }
        }
    }

    else
    {
       hr = Enumerate(pMethodContext);
    }

    return hr;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CJOProcess::PutInstance (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    MethodContext *pMethodContext = Instance.GetMethodContext();
	long lCreateFlags = lFlags & 3;

    // Decide how to proceed based on the value of lFlags:
    // (we want to support PutInstance in all cases except
    // where the client asked to update the instance).
    if(lCreateFlags != WBEM_FLAG_UPDATE_ONLY)
    {
        // The caller only wants to create an instance that doesn't exist.
        if((hr = FindSingleInstance(
                &Instance)) == WBEM_E_NOT_FOUND)
        {
            // The association instance does not already exist, so create it...
            // First see that the job object instance exists...
            CHString chstrJOPath;
            if ( ! Instance.GetCHString(L"Collection", chstrJOPath) )
			{
				return WBEM_E_FAILED ;
			}

            CInstancePtr pJOInst;

            hr = CWbemProviderGlue::GetInstanceKeysByPath(
                     chstrJOPath, 
                     &pJOInst, 
                     pMethodContext);

            if (SUCCEEDED(hr))
            {
                // Confirm that the process exists...
                CHString chstrProcPath;
                if ( ! Instance.GetCHString(L"Member", chstrProcPath) )
				{
					return WBEM_E_FAILED ;
				}

                CInstancePtr pProcInst;

                hr = CWbemProviderGlue::GetInstanceKeysByPath(
                         chstrProcPath, 
                         &pProcInst, 
                         pMethodContext);
                
                if(SUCCEEDED(hr))
                {
                    hr = Create(pJOInst, pProcInst);
                }
            }
        }
    }
    
    return hr;
}

/*****************************************************************************
*
*  FUNCTION    :    CJOProcess::FindSingleInstance
*
*  DESCRIPTION :    Internal helper function used to locate a single job
*                   object.
*
*  INPUTS      :    A pointer to a CInstance containing the instance we are
*                   attempting to locate and fill values for.
*
*  RETURNS     :    A valid HRESULT 
*
*****************************************************************************/

HRESULT CJOProcess::FindSingleInstance (

    const CInstance* pInstance
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(!pInstance)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    MethodContext* pMethodContext = pInstance->GetMethodContext();
    CHString chstrCollection;
    CHString chstrMember;
    
    // Find out which JO and which process are specified...
    if ( ! pInstance->GetCHString(L"Collection", chstrCollection) )
	{
		return WBEM_E_FAILED ;
	}

    if ( ! pInstance->GetCHString(L"Member", chstrMember) )
	{
		return WBEM_E_FAILED ;
	}

    CHString chstrCollectionID;
    CHString chstrProcessHandle;
    CInstancePtr cinstJO;
    CInstancePtr cinstProcess;

    if(GetInstKey(chstrCollection, chstrCollectionID) &&
       GetInstKey(chstrMember, chstrProcessHandle))
    {
        // See if the specified job exists...            
        hr = CWbemProviderGlue::GetInstanceKeysByPath(
                 chstrCollection,
                 &cinstJO,
                 pMethodContext);

        if(SUCCEEDED(hr))
        {
            // See if the specified process exists...
            hr = CWbemProviderGlue::GetInstanceKeysByPath(
                     chstrMember,
                     &cinstProcess,
                     pMethodContext);
        }

        if(SUCCEEDED(hr))
        {
            // The endpoints exist.  Is the specified
            // process part of the specified job though?
            CHString chstrProcessID;
            DWORD dwProcessID;

            if(cinstProcess->GetCHString(L"Handle", chstrProcessID))
            {
                dwProcessID = _wtoi(chstrProcessID);
                
                SmartCloseHandle hJob;

                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    chstrCollectionID,
                    chstrUndecoratedJOName);

                hJob = ::OpenJobObject(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);
                       
                if(hJob != NULL)
                {
                    long lSize = 0L;
                    bool fGotProcList = false;
                    DWORD dwLen = 0L;

                    lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + (5 * sizeof(ULONG_PTR));
					wmilib::auto_buffer < BYTE > pbBuff ( new BYTE [ lSize ], lSize ) ;

                    if ( pbBuff.get () )
                    {
                        fGotProcList = ::QueryInformationJobObject(
                            hJob,
                            JobObjectBasicProcessIdList,
                            pbBuff.get (),
                            lSize,
                            &dwLen);

                        if(!fGotProcList)
                        {
                            // need to grow the buffer...
                            lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + 
                                (((JOBOBJECT_BASIC_PROCESS_ID_LIST*)pbBuff.get ())->NumberOfAssignedProcesses - 1)*sizeof(ULONG_PTR);

                            pbBuff.reset ( new BYTE [ lSize ] ) ;
							if ( pbBuff.get () )
                            {
                                fGotProcList = ::QueryInformationJobObject(
                                    hJob,
                                    JobObjectBasicProcessIdList,
                                    pbBuff.get (),
                                    lSize,
                                    &dwLen);
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }

                        if(fGotProcList)
                        {
                            PJOBOBJECT_BASIC_PROCESS_ID_LIST pjobpl = static_cast<PJOBOBJECT_BASIC_PROCESS_ID_LIST>(static_cast<PVOID>(pbBuff.get ()));
                    
                            bool fExists = false;

                            for(long m = 0; 
                                m < pjobpl->NumberOfProcessIdsInList && !fExists; 
                                m++)
                            {
                                if(dwProcessID == pjobpl->ProcessIdList[m])
                                {
                                    fExists = true;
                                }
                            }
            
                            // If the process wasn't in the job,
                            // we didn't find an instance of the
                            // requested association, even though
                            // the endpoints may have existed.
                            if(!fExists)
                            {
                                hr = WBEM_E_NOT_FOUND;
                            }
                        }
                        else
                        {
                            hr = WinErrorToWBEMhResult(::GetLastError());
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WinErrorToWBEMhResult(::GetLastError());
                }
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        } 
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    :    CJOProcess::Create
*
*  DESCRIPTION :    Internal helper function used to add a process to a job.
*
*  INPUTS      :    A pointer to the JO instance to add the proc to, and
*                   a pointer to the proc instance to add
*
*  RETURNS     :    A valid HRESULT. 
*
*****************************************************************************/

HRESULT CJOProcess::Create (

    const CInstance &JOInstance,
    const CInstance &ProcInstance
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrJOID;
    CHString chstrProcHandle;

    // JO to add the proc to...
    if ( ! JOInstance.GetCHString(L"CollectionID", chstrJOID) )
	{
		return WBEM_E_FAILED ;
	}

    // Proc to add to the job...
    if ( ! ProcInstance.GetCHString(L"Handle", chstrProcHandle) )
	{
		return WBEM_E_FAILED ;
	}

    DWORD dwProcID = _wtol(chstrProcHandle);

    // Do the add
    SmartCloseHandle hJob;

    CHString chstrUndecoratedJOName;

    UndecorateJOName(
        chstrJOID,
        chstrUndecoratedJOName);

    hJob = ::OpenJobObject(
               MAXIMUM_ALLOWED,
               FALSE,
               chstrUndecoratedJOName);
               
    if(hJob != NULL)
    {
        SmartCloseHandle hProc;
        hProc = ::OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    dwProcID);
        
        if(hProc != NULL)
        {
            if(!::AssignProcessToJobObject(
                   hJob,
                   hProc))
            {
                hr = MAKE_SCODE(
                         SEVERITY_ERROR, 
                         FACILITY_WIN32, 
                         GetLastError());
            }
        }
    }
    else
	{
		hr = WinErrorToWBEMhResult(::GetLastError());
	}

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    :    CJOProcess::Enumerate
*
*  DESCRIPTION :    Internal helper function used to enumerate instances of
*                   this class.  All instances are enumerated, but only the
*                   properties specified are obtained.
*
*  INPUTS      :    A pointer to a the MethodContext for the call.
*                   A DWORD specifying which properties are requested.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/

HRESULT CJOProcess::Enumerate (

    MethodContext *pMethodContext
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> JOList;

    hr = CWbemProviderGlue::GetInstancesByQuery(
             L"SELECT CollectionID FROM Win32_NamedJobObject",
             &JOList,
             pMethodContext,
             IDS_CimWin32Namespace);

    if(SUCCEEDED(hr))
    {
        REFPTRCOLLECTION_POSITION pos;

        // Initialize the enum
        if(JOList.BeginEnum(pos))
        {
            // Set some vars
            CHString chstrJOID;
            CInstancePtr pJOInst;
        	
            for (pJOInst.Attach(JOList.GetNext(pos)) ;
                   (pJOInst != NULL) ;
                    pJOInst.Attach(JOList.GetNext(pos)) )
            {
                bool t_Status = pJOInst->GetCHString (

                    L"CollectionID", 
                    chstrJOID
				) ;

				if ( t_Status )
				{
					hr = EnumerateProcsInJob (

						chstrJOID, 
						pMethodContext
					);
				}
				else
				{
					hr = WBEM_E_FAILED ;
				}
            }
        }
    }

    return hr;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CJOProcess::EnumerateProcsInJob (

    LPCWSTR wstrJobID, 
    MethodContext *pMethodContext
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SmartCloseHandle hJob;

    CHString chstrUndecoratedJOName;

    UndecorateJOName(
        wstrJobID,
        chstrUndecoratedJOName);

    hJob = ::OpenJobObject(
               MAXIMUM_ALLOWED,
               FALSE,
               chstrUndecoratedJOName);
               
    if(hJob != NULL)
    {
        long lSize = 0L;
        bool fGotProcList = false;
        DWORD dwLen = 0L;

        lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + (5 * sizeof(ULONG_PTR));
		wmilib::auto_buffer < BYTE > pbBuff ( new BYTE [ lSize ], lSize ) ;

        if ( pbBuff.get () )
        {
            fGotProcList = ::QueryInformationJobObject(
                hJob,
                JobObjectBasicProcessIdList,
                pbBuff.get (),
                lSize,
                &dwLen);

            if(!fGotProcList)
            {
                // need to grow the buffer...
                lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + 
                    (((JOBOBJECT_BASIC_PROCESS_ID_LIST*)pbBuff.get ())->NumberOfAssignedProcesses - 1)*sizeof(ULONG_PTR);

				pbBuff.reset ( new BYTE [ lSize ] ) ;
                if ( pbBuff.get () )
                {
                    fGotProcList = ::QueryInformationJobObject(
                        hJob,
                        JobObjectBasicProcessIdList,
                        pbBuff.get (),
                        lSize,
                        &dwLen);
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

            if(fGotProcList)
            {
                PJOBOBJECT_BASIC_PROCESS_ID_LIST pjobpl = static_cast<PJOBOBJECT_BASIC_PROCESS_ID_LIST>(static_cast<PVOID>(pbBuff.get ()));

                for(long m = 0; 
                    m < pjobpl->NumberOfProcessIdsInList; 
                    m++)
                {
                    // Create association inst for each
                    // proc in the job...
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), 
                                            false);

                    // Set the endpoints...
                    CHString chstrEscaped;

                    DecorateJOName(chstrUndecoratedJOName, chstrEscaped);
                    EscapeBackslashes(chstrEscaped, chstrEscaped);
                    EscapeQuotes(chstrEscaped, chstrEscaped);

                    CHString chstrTmp;
                    chstrTmp.Format(L"\\\\.\\%s:Win32_NamedJobObject.CollectionID=\"%s\"", 
                        IDS_CimWin32Namespace, 
                        (LPCWSTR)chstrEscaped);

                    pInstance->SetCHString(L"Collection", chstrTmp);
        
        
                    CHString chstrHandle;
                    chstrHandle.Format(L"%d", pjobpl->ProcessIdList[m]);
                    chstrTmp.Format(L"\\\\.\\%s:Win32_Process.Handle=\"%s\"", 
                        IDS_CimWin32Namespace, 
                        (LPCWSTR) chstrHandle);

                    pInstance->SetCHString(L"Member", chstrTmp);


				    if (SUCCEEDED(hr))
				    {
					    hr = pInstance->Commit();
				    }
                }
            }
            else
            {
                hr = WinErrorToWBEMhResult(::GetLastError());
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = WinErrorToWBEMhResult(::GetLastError());
    }

    return hr;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

bool CJOProcess::GetInstKey (

	CHString& chstrInstPath, 
	CHString& chstrKeyName
)
{
    // the object path is specified in
    // the first arg.  It should at a 
    // minimum always contain an '=' sign,
    // after which, in quotes is the 
    // object key.
    bool fRet = false;
    CHString chstrTmp;
    LONG lPos = chstrInstPath.Find(L'=');
    if(lPos != -1)
    {
        chstrTmp = chstrInstPath.Mid(lPos + 1);
        // Remove quotes...
        if(chstrTmp.Left(1) == L"\"")
        {
            chstrTmp = chstrTmp.Mid(1);
            if(chstrTmp.Right(1) == L"\"")
            {
                chstrTmp = chstrTmp.Left(chstrTmp.GetLength() - 1);
                chstrKeyName = chstrTmp;
                fRet = true;
            }
        }
    }

    return fRet;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// Takes a decorated job object name and
// undecorates it.  Decorated job object names
// have a backslash preceeding any character
// that should be uppercase once undecorated.
// 
// Due to the way CIMOM handles backslashes,
// we will get capital letters preceeded by
// two, not just one, backslashes.  Hence, we
// must strip them both.
//
// According to the decoration scheme, the
// following are both lower case: 'A' and 'a',
// while the following are both upper case:
// '\a' and '\A'.
//

void CJOProcess::UndecorateJOName (

    LPCWSTR wstrDecoratedName,
    CHString& chstrUndecoratedJOName
)
{
    if(wstrDecoratedName != NULL &&
        *wstrDecoratedName != L'\0')
    {
        LPWSTR wstrDecoratedNameLower = NULL;

        try
        {
            wstrDecoratedNameLower = new WCHAR[wcslen(wstrDecoratedName)+1];

            if(wstrDecoratedNameLower)
            {
                wcscpy(wstrDecoratedNameLower, wstrDecoratedName);
                _wcslwr(wstrDecoratedNameLower);

                WCHAR* p3 = chstrUndecoratedJOName.GetBuffer(
                    wcslen(wstrDecoratedNameLower) + 1);

                const WCHAR* p1 = wstrDecoratedNameLower;
                const WCHAR* p2 = p1 + 1;

                while(*p1 != L'\0')
                {
                    if(*p1 == L'\\')
                    {
                        if(*p2 != NULL)
                        {
                            // Might have any number of
                            // backslashes back to back,
                            // which we will treat as
                            // being the same as one
                            // backslash - i.e., we will
                            // skip over the backslash(s)
                            // and copy over the following
                            // letter.
                            while(*p2 == L'\\')
                            {
                                p2++;
                            };
                    
                            *p3 = towupper(*p2);
                            p3++;

                            p1 = p2 + 1;
                            if(*p1 != L'\0')
                            {
                                p2 = p1 + 1;
                            }
                        }
                        else
                        {
                            p1++;
                        }
                    }
                    else
                    {
                        *p3 = *p1;
                        p3++;

                        p1 = p2;
                        if(*p1 != L'\0')
                        {
                            p2 = p1 + 1;
                        }
                    }
                }
        
                *p3 = NULL;

                chstrUndecoratedJOName.ReleaseBuffer();

                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
        }
        catch(...)
        {
            if(wstrDecoratedNameLower)
            {
                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
            throw;
        }
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// Does the inverse of the above function.
// However, here, we only need to put in one
// backslash before each uppercase letter.
// CIMOM will add the second backslash.

void CJOProcess::DecorateJOName (

    LPCWSTR wstrUndecoratedName,
    CHString& chstrDecoratedJOName
)
{
    if(wstrUndecoratedName != NULL &&
        *wstrUndecoratedName != L'\0')
    {
        // Worst case is that we will have
        // a decorated string twice as long
        // as the undecorated string (happens
        // is every character in the undecorated
        // string is a capital letter).
        WCHAR* p3 = chstrDecoratedJOName.GetBuffer(
            2 * (wcslen(wstrUndecoratedName) + 1));

        const WCHAR* p1 = wstrUndecoratedName;

        while(*p1 != L'\0')
        {
            if(iswupper(*p1))
            {
                // Add in a backslash...
                *p3 = L'\\';
                p3++;

                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
            else
            {
                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
        }

        *p3 = NULL;
        
        chstrDecoratedJOName.ReleaseBuffer();

        // What if we had a job called Job,
        // and someone specified it in the
        // object path as "Job" instead of
        // "\Job"?  We DON'T want to find it
        // in such a case, because this would
        // appear to not be adhering to our
        // own convention.  Hence, we 
        // lowercase the incoming string.
        chstrDecoratedJOName.MakeLower();
    }
}

#endif   // #if NTONLY >= 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\ntdomain.h ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  NtDomain.h
//
//  Purpose: Nt domain discovery property set provider
//
//***************************************************************************

#ifndef _NTDOMAIN_H
#define _NTDOMAIN_H

// into strings.h
extern LPCWSTR IDS_DomainControllerName;
extern LPCWSTR IDS_DomainControllerAddress;
extern LPCWSTR IDS_DomainControllerAddressType;
extern LPCWSTR IDS_DomainGuid;
extern LPCWSTR IDS_DomainName;
extern LPCWSTR IDS_DnsForestName;
extern LPCWSTR IDS_DS_PDC_Flag;
extern LPCWSTR IDS_DS_WRITABLE_Flag;
extern LPCWSTR IDS_DS_GC_Flag;
extern LPCWSTR IDS_DS_DS_Flag;
extern LPCWSTR IDS_DS_KDC_Flag;
extern LPCWSTR IDS_DS_TIMESERV_Flag;
extern LPCWSTR IDS_DS_DNS_CONTROLLER_Flag;
extern LPCWSTR IDS_DS_DNS_DOMAIN_Flag;
extern LPCWSTR IDS_DS_DNS_FOREST_Flag;
extern LPCWSTR IDS_DcSiteName;
extern LPCWSTR IDS_ClientSiteName;

//==================================
#define  PROPSET_NAME_NTDOMAIN L"Win32_NTDomain"


// PROPERTY SET
//=============
class CWin32_NtDomain: public Provider
{
private:
      
	// property names 
    CHPtrArray m_pProps ;

	void SetPropertyTable() ;

	HRESULT GetDomainInfo(

		CNetAPI32	&a_NetAPI, 
		bstr_t		&a_bstrDomainName, 
		CInstance	*a_pInst,
		DWORD		a_dwProps 
	) ;

	HRESULT EnumerateInstances(

		MethodContext	*a_pMethodContext,
		long			a_Flags,
		CNetAPI32		&a_rNetAPI, 
		DWORD			a_dwProps
	) ;


public:

    // Constructor/destructor
    //=======================

    CWin32_NtDomain( LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
   ~CWin32_NtDomain() ;

    // Functions that provide properties with current values
    //======================================================

    HRESULT GetObject ( 
		
		CInstance *a_Instance,
		long a_Flags,
		CFrameworkQuery &a_rQuery
	) ;

    HRESULT EnumerateInstances ( 

		MethodContext *a_pMethodContext, 
		long a_Flags = 0L 
	) ;


	HRESULT ExecQuery ( 

		MethodContext *a_pMethodContext, 
		CFrameworkQuery &a_rQuery, 
		long a_Flags = 0L
	) ;


	// Property offset defines
	enum ePropertyIDs { 
		e_DomainControllerName,			// Win32_NtDomain
		e_DomainControllerAddress,
		e_DomainControllerAddressType,
		e_DomainGuid,
		e_DomainName,
		e_DnsForestName,
		e_DS_PDC_Flag,
		e_DS_Writable_Flag,
		e_DS_GC_Flag,
		e_DS_DS_Flag,
		e_DS_KDC_Flag,
		e_DS_Timeserv_Flag,
		e_DS_DNS_Controller_Flag,
		e_DS_DNS_Domain_Flag,
		e_DS_DNS_Forest_Flag,
		e_DcSiteName,
		e_ClientSiteName,
		e_CreationClassName,			// CIM_System
		e_Name,							/* override from CIM_ManagedSystemElement */
		e_NameFormat,
		e_PrimaryOwnerContact,
		e_PrimaryOwnerName,
		e_Roles,
		e_Caption,						// CIM_ManagedSystemElement
		e_Description,
		e_InstallDate,
		e_Status,
		e_End_Property_Marker,			// end marker
		e_32bit = 32					// gens compiler error if additions to this set >= 32 
	};
};

#endif // _NTDOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\joprocess.h ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   JOProcess.H -- WMI provider class definition

   Description: 
   
*******************************************************************/

#if NTONLY >= 5


#pragma once

#define PROVIDER_NAME_WIN32NAMEDJOBOBJECTPROCESS L"Win32_NamedJobObjectProcess"

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));


class CJOProcess : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CJOProcess(
            LPCWSTR lpwszClassName, 
            LPCWSTR lpwszNameSpace);
        
        virtual ~CJOProcess();

    protected:

        // Reading Functions
        //============================
        virtual HRESULT ExecQuery(
            MethodContext *pMethodContext, 
            CFrameworkQuery& Query, 
            long lFlags);

        virtual HRESULT GetObject( 
            CInstance* pInstance, 
            long lFlags /*= 0L*/ );

        virtual HRESULT EnumerateInstances(
            MethodContext* pMethodContext, 
            long lFlags);


        
        // Writing Functions
        //============================
        virtual HRESULT PutInstance(
            const CInstance& Instance, 
            long lFlags = 0L);


    private:

        HRESULT FindSingleInstance(
            const CInstance* pInstance);

        HRESULT Create(
            const CInstance &JOInstance,
            const CInstance &ProcInstance);

        bool GetInstKey(
            CHString& chstrCollection, 
            CHString& chstrCollectionID);

        HRESULT Enumerate(
            MethodContext *pMethodContext);

        HRESULT EnumerateProcsInJob(
            LPCWSTR wstrJobID, 
            MethodContext *pMethodContext);

        void UndecorateJOName(
            LPCWSTR wstrDecoratedName,
            CHString& chstrUndecoratedJOName);

        void DecorateJOName(
            LPCWSTR wstrUndecoratedName,
            CHString& chstrDecoratedJOName);


};

#endif // #if NTONLY >= 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: WBEM Framework Instance provider
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <initguid.h>
#include "FactoryRouter.h"
#include "ResourceManager.h"
#include "timerqueue.h"
#include <shutdownevent.h>
#include <volumechange.h>

HMODULE ghModule;

// {04788120-12C2-498d-83C1-A7D92E677AC6}
DEFINE_GUID(CLSID_CimWinProviderA, 
0x4788120, 0x12c2, 0x498d, 0x83, 0xc1, 0xa7, 0xd9, 0x2e, 0x67, 0x7a, 0xc6);
// {A3E41207-BE04-492a-AFF0-19E880FF7545}
DEFINE_GUID(CLSID_ShutdownEventProvider, 
0xa3e41207, 0xbe04, 0x492a, 0xaf, 0xf0, 0x19, 0xe8, 0x80, 0xff, 0x75, 0x45);
// {E2CBCB87-9C07-4523-A78F-061499C83987}
DEFINE_GUID(CLSID_VolumeChangeEventProvider, 
0xe2cbcb87, 0x9c07, 0x4523, 0xa7, 0x8f, 0x6, 0x14, 0x99, 0xc8, 0x39, 0x87);


#define PROVIDER_NAME L"WMIPCIMA"

//====================================================================================
// initialize class globals
//====================================================================================
CFactoryRouterData     g_FactoryRouterData;
CShutdownEventFactory* gp_ShutdownEventFactory = NULL;
CVolumeChangeFactory*  gp_VolumeChangeFactory = NULL;

CTimerQueue CTimerQueue :: s_TimerQueue ;
CResourceManager CResourceManager::sm_TheResourceManager ;

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;

    try
    {
        if ( CLSID_CimWinProviderA == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = g_FactoryRouterData.DllGetClassObject( rclsid, riid, ppv ) ;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow()
{
    SCODE sc = S_FALSE;

    try
    {
        // It is OK to unload if there are no locks on the
        // class factory and the framework allows us to go.
        if (g_FactoryRouterData.DllCanUnloadNow())
        {
            sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
        }

        if ( sc == S_OK )
        {
            CTimerQueue::s_TimerQueue.OnShutDown();
            CResourceManager::sm_TheResourceManager.ForcibleCleanUp () ;

#ifdef WIN9XONLY
            HoldSingleCim32NetPtr::FreeCim32NetApiPtr() ;
#endif
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM Framework Instance Provider CIMA"), CLSID_CimWinProviderA ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllRegisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CimWinProviderA ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllUnregisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitializeEventFactories(void)
{
	BOOL fRet = FALSE;

	gp_ShutdownEventFactory = new CShutdownEventFactory( CLSID_ShutdownEventProvider,SHUTDOWN_EVENT_CLASS ) ;
	if( gp_ShutdownEventFactory )
	{
		gp_VolumeChangeFactory = new CVolumeChangeFactory( CLSID_VolumeChangeEventProvider,VOLUME_CHANGE_EVENT ) ;
		if( gp_VolumeChangeFactory )
		{
			fRet = TRUE;
		}
	}
	return fRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
void CleanupEventFactories(void)
{
	if( gp_ShutdownEventFactory )
	{
		delete gp_ShutdownEventFactory;
		gp_ShutdownEventFactory = NULL;
	}
	if( gp_VolumeChangeFactory )
	{
		delete gp_VolumeChangeFactory;
		gp_VolumeChangeFactory = NULL;
	}
}
//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
				if( bRet )
				{
					bRet = InitializeEventFactories();
				}
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					CleanupEventFactories();
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\physicalmedia.cpp ===
/******************************************************************

PhysicalMedia.CPP -- WMI provider class implementation

Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved

******************************************************************/


#include "Precomp.h"

#include <setupapi.h>
#include <devioctl.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <strsafe.h>

#include "PhysicalMedia.h"

#include <scopeguard.h>

CPhysicalMedia MyPhysicalMediaSettings ( 

	PROVIDER_NAME_PHYSICALMEDIA, 
	L"root\\cimv2"
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CPhysicalMedia::CPhysicalMedia
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CPhysicalMedia :: CPhysicalMedia (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{	
}

/*****************************************************************************
 *
 *  FUNCTION    :   CPhysicalMedia::~CPhysicalMedia
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CPhysicalMedia :: ~CPhysicalMedia ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CPhysicalMedia :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	hRes = Enumerate ( pMethodContext );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CPhysicalMedia :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
#if NTONLY
    HRESULT hRes = WBEM_S_NO_ERROR;
	CHString t_DriveName;

	if ( pInstance->GetCHString ( TAG, t_DriveName ) )
	{
		BOOL bFound = FALSE;
		int uPos;
		//Find the drive number
		for ( WCHAR ch = L'0'; ch <= L'9'; ch++ )
		{
			uPos = t_DriveName.Find ( ch );
			if ( uPos != -1 )
			{
				bFound= TRUE;
				break;
			}
		}

		if ( bFound )
		{
			DWORD dwAccess;
#if  NTONLY >= 5
	dwAccess = GENERIC_READ | GENERIC_WRITE;
#else	
    dwAccess = GENERIC_READ;
#endif 
			int len = t_DriveName.GetLength();
			CHString t_DriveNo ( t_DriveName.Right ( len - uPos ));
			BYTE bDriveNo = ( BYTE )_wtoi ( (LPCTSTR)t_DriveNo );

			SmartCloseHandle hDiskHandle = CreateFile (

				t_DriveName.GetBuffer(0),
				dwAccess, 
				FILE_SHARE_READ | FILE_SHARE_WRITE, 
				NULL, 
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, 
				NULL 
			) ;

			DWORD dwErr = GetLastError () ;

			if ( hDiskHandle != INVALID_HANDLE_VALUE ) 
			{
				CHString t_SerialNumber;
				hRes = GetSmartVersion ( hDiskHandle, bDriveNo, t_SerialNumber );

				if ( SUCCEEDED ( hRes ) && (t_SerialNumber.GetLength() > 0) )
				{
        			pInstance->SetCHString ( SERIALNUMBER, t_SerialNumber );
                }
                else
                {
					hRes = GetSCSIVersion(
                        hDiskHandle,
                        bDriveNo,
                        t_SerialNumber);

                    if(SUCCEEDED(hRes))
				    {
        			    pInstance->SetCHString(SERIALNUMBER, t_SerialNumber);
                    }
                    else
                    {
                        hRes = WBEM_E_NOT_FOUND;
                    }
				}
			}
			else
			{
				hRes = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hRes = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetObject
*
*  DESCRIPTION :    Enumerates all the Instances 
*
*****************************************************************************/
HRESULT CPhysicalMedia::Enumerate(

	MethodContext *pMethodContext 
)
{
    HRESULT	hRes = WBEM_S_NO_ERROR;

	HDEVINFO t_DeviceInfo = SetupDiGetClassDevs (

		&DiskClassGuid, 
		NULL, 
		NULL,
        DIGCF_PRESENT | DIGCF_INTERFACEDEVICE
	);

    if ( t_DeviceInfo == NULL ) 
	{
        return WBEM_E_CRITICAL_ERROR ;                
    }

	// 
	// auto destructor when leaving function scope
	//
	ON_BLOCK_EXIT ( SetupDiDestroyDeviceInfoList, t_DeviceInfo ) ;

    SP_DEVICE_INTERFACE_DATA t_DeviceInterfaceData ;
    t_DeviceInterfaceData.cbSize = sizeof ( t_DeviceInterfaceData ) ;

    ULONG t_SizeDeviceInterfaceDetail = sizeof ( SP_DEVICE_INTERFACE_DETAIL_DATA ) + ( MAX_PATH * sizeof( WCHAR ) ) ;
    PSP_DEVICE_INTERFACE_DETAIL_DATA t_DeviceInterfaceDetail = ( PSP_DEVICE_INTERFACE_DETAIL_DATA ) LocalAlloc ( 0 , t_SizeDeviceInterfaceDetail );
    if ( t_DeviceInterfaceDetail == NULL) 
	{
        return WBEM_E_OUT_OF_MEMORY ;                
    }

	// 
	// auto destructor when leaving function scope
	//
	ON_BLOCK_EXIT ( LocalFree, t_DeviceInterfaceDetail ) ;

    t_DeviceInterfaceDetail->cbSize = sizeof ( SP_DEVICE_INTERFACE_DETAIL_DATA ) ;

	ULONG t_Index = 0 ;
	while ( true )
	{
        BOOL t_Status = SetupDiEnumDeviceInterfaces (

			t_DeviceInfo ,
			NULL ,
			& DiskClassGuid ,
			t_Index ,
			& t_DeviceInterfaceData
		) ;

		if ( ! t_Status )
		{
            break;
        }
        
        t_Status = SetupDiGetDeviceInterfaceDetail (

			t_DeviceInfo ,
			& t_DeviceInterfaceData , 
			t_DeviceInterfaceDetail ,
			t_SizeDeviceInterfaceDetail , 
            NULL , 
			NULL
		) ;

        if ( ! t_Status ) 
		{
            continue ;
        }

		SmartCloseHandle hDiskHandle = CreateFile (

			t_DeviceInterfaceDetail->DevicePath ,
			FILE_ANY_ACCESS , 
			FILE_SHARE_READ | FILE_SHARE_WRITE ,
			NULL, 
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL, 
			NULL 
		) ;

		if ( hDiskHandle != INVALID_HANDLE_VALUE ) 
		{
			STORAGE_DEVICE_NUMBER t_DeviceNumber ;
			DWORD t_Bytes = 0 ;

			BOOL t_Status = DeviceIoControl (

				hDiskHandle ,
				IOCTL_STORAGE_GET_DEVICE_NUMBER ,
				NULL ,
				0 , 
				& t_DeviceNumber ,
				sizeof ( t_DeviceNumber ),
				& t_Bytes ,
				NULL
			);

			if ( t_Status )
			{
				// Maximum size of integer plus preamble.

				wchar_t t_DiskSpec [ MAX_PATH ] ;

				StringCchPrintf ( t_DiskSpec , MAX_PATH , L"\\\\.\\PHYSICALDRIVE%lu" , ( DWORD )t_DeviceNumber.DeviceNumber ) ;

				CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ) , false ) ;

				if ( SUCCEEDED (GetPhysDiskInfoNT ( pInstance, t_DiskSpec , t_DeviceNumber.DeviceNumber ) ) )
				{
					hRes = pInstance->Commit () ;
				}	
			}
		}
        
		t_Index ++ ;
    }

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetPhysDiskInfoNT
*
*  DESCRIPTION :    Gets the serial Id
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetPhysDiskInfoNT (

	CInstance *pInstance,
    LPCWSTR lpwszDiskSpec,
    BYTE bIndex
)
{
#ifdef NTONLY
	HRESULT hRes = WBEM_E_NOT_FOUND ;
	DWORD dwAccess;
#if  NTONLY >= 5
	dwAccess = GENERIC_READ | GENERIC_WRITE;
#else
    dwAccess = GENERIC_READ;
#endif 

	// Get handle to physical drive
	//=============================
    pInstance->SetCHString ( TAG , lpwszDiskSpec) ;

	SmartCloseHandle hDiskHandle = CreateFile (

		lpwszDiskSpec,
		dwAccess, 
		FILE_SHARE_READ | FILE_SHARE_WRITE, 
		NULL, 
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL, 
		NULL 
	) ;

	if ( hDiskHandle != INVALID_HANDLE_VALUE ) 
	{
		CHString t_SerialNumber;
		hRes = GetSmartVersion ( hDiskHandle, bIndex, t_SerialNumber );

		if ( SUCCEEDED ( hRes ) && (t_SerialNumber.GetLength() > 0))
		{
			pInstance->SetCHString ( SERIALNUMBER, t_SerialNumber );
		}
        else
        {
            hRes = GetSCSIVersion(
                hDiskHandle,
                bIndex,
                t_SerialNumber);

            if ( SUCCEEDED ( hRes ) && (t_SerialNumber.GetLength() > 0))
            {
                pInstance->SetCHString(SERIALNUMBER, t_SerialNumber);    
            }
        }
	}

  	return ( hRes );
#else
	return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetIdentifyData
*
*  DESCRIPTION :   Gets the Serial Number
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetIdentifyData( HANDLE hDrive, BYTE bDriveNumber, BYTE bDfpDriveMap, BYTE bIDCmd, CHString &t_SerialNumber )
{
	HRESULT hRes = WBEM_S_NO_ERROR;

   SENDCMDINPARAMS      inputParams;
   BYTE					outputParams[sizeof(SENDCMDOUTPARAMS) - 1 + IDENTIFY_BUFFER_SIZE];
   ULONG                bytesReturned;
   BOOL                 success = TRUE;

   ZeroMemory(&inputParams, sizeof(SENDCMDINPARAMS));
   ZeroMemory(&outputParams, sizeof(outputParams));
       
   // Build register structure to enable smart functionality.       
   inputParams.irDriveRegs.bFeaturesReg     = 0;
   inputParams.irDriveRegs.bSectorCountReg  = 1;
   inputParams.irDriveRegs.bSectorNumberReg = 1;
   inputParams.irDriveRegs.bCylLowReg       = 0;
   inputParams.irDriveRegs.bCylHighReg      = 0;
   inputParams.irDriveRegs.bDriveHeadReg    = 0xA0 | (( bDriveNumber & 1) << 4);
   inputParams.irDriveRegs.bCommandReg      = bIDCmd;

   inputParams.bDriveNumber = bDriveNumber;
   inputParams.cBufferSize = IDENTIFY_BUFFER_SIZE;

   success = DeviceIoControl (hDrive, 
                         SMART_RCV_DRIVE_DATA,
                         (LPVOID)&inputParams,
                         sizeof(SENDCMDINPARAMS) - 1,
                         (LPVOID) &outputParams,
                         sizeof(SENDCMDOUTPARAMS) - 1 + IDENTIFY_BUFFER_SIZE,
                         &bytesReturned,
                         NULL);

	if ( success )
	{	

		PIDSECTOR pids = (PIDSECTOR) ((PSENDCMDOUTPARAMS)&outputParams)->bBuffer;
		ChangeByteOrder( pids->sSerialNumber, 
			sizeof pids->sSerialNumber);

    	CHAR	sSerialNumber[21];
        memset(sSerialNumber, 0, sizeof(sSerialNumber));
        memcpy(sSerialNumber, pids->sSerialNumber, sizeof(pids->sSerialNumber));

		t_SerialNumber = sSerialNumber;

	}	

	if ( GetLastError() != 0 )
	{
		hRes = WBEM_E_FAILED;
	}

   return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::EnableSmart
*
*  DESCRIPTION :    Enables Smart IOCTL
*
*****************************************************************************/

HRESULT CPhysicalMedia::EnableSmart( HANDLE hDrive, BYTE bDriveNum, BYTE & bDfpDriveMap )
{

   SENDCMDINPARAMS  inputParams;
   SENDCMDOUTPARAMS outputParams;
   ULONG            bytesReturned;
   BOOL             success = TRUE;

   ZeroMemory(&inputParams, sizeof(SENDCMDINPARAMS));
   ZeroMemory(&outputParams, sizeof(SENDCMDOUTPARAMS));

   //
   // Build register structure to enable smart functionality.
   //

   inputParams.irDriveRegs.bFeaturesReg     = ENABLE_SMART;
   inputParams.irDriveRegs.bSectorCountReg  = 1;
   inputParams.irDriveRegs.bSectorNumberReg = 1;
   inputParams.irDriveRegs.bCylLowReg       = SMART_CYL_LOW;
   inputParams.irDriveRegs.bCylHighReg      = SMART_CYL_HI;

   //set DRV to Master or Slave
   inputParams.irDriveRegs.bDriveHeadReg    = 0xA0 | ((bDriveNum & 1) << 4);
   inputParams.irDriveRegs.bCommandReg      = SMART_CMD;
   inputParams.bDriveNumber = bDriveNum;

   success = DeviceIoControl ( hDrive,
                         SMART_SEND_DRIVE_COMMAND,
                         &inputParams,
                         sizeof(SENDCMDINPARAMS) - 1 ,
                         &outputParams,
                         sizeof(SENDCMDOUTPARAMS) - 1,
                         &bytesReturned,
                         NULL);

   if ( success )
   {
	   bDfpDriveMap |= (1 << bDriveNum);
   }

   HRESULT hRes = WBEM_S_NO_ERROR;

   if ( GetLastError() != ERROR_SUCCESS )
   {
	   hRes  = WBEM_E_FAILED;
   }

   return ( hRes );
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetSmartVersion
*
*  DESCRIPTION :    Gets a Smart Version
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetSmartVersion(
               
	HANDLE Handle,
	BYTE bDriveNumber,
	CHString &a_SerialNumber
)
{
   GETVERSIONINPARAMS versionIn;
   ULONG bytesReturned;

   HRESULT hRes = WBEM_S_NO_ERROR;
   ZeroMemory(&versionIn, sizeof(GETVERSIONINPARAMS));

   //
   // Send the IOCTL to retrieve the version information.
   //

   BOOL bSuccess = DeviceIoControl (Handle,
                         SMART_GET_VERSION,
                         NULL,
                         0,
                         &versionIn,
                         sizeof(GETVERSIONINPARAMS),
                         &bytesReturned,
                         NULL);

   if ( bSuccess )
   {
		// If there is a IDE device at number "i" issue commands
		// to the device.
		//
		if (versionIn.bIDEDeviceMap >> bDriveNumber & 1)
		{
			//
			// Try to enable SMART so we can tell if a drive supports it.
			// Ignore ATAPI devices.
			//

			if (!(versionIn.bIDEDeviceMap >> bDriveNumber & 0x10))
			{
				BYTE bDfpDriveMap;
				hRes = EnableSmart( Handle, bDriveNumber, bDfpDriveMap );
				if ( SUCCEEDED ( hRes ) )
				{
					BYTE bIDCmd;

					bIDCmd = (versionIn.bIDEDeviceMap >> bDriveNumber & 0x10) ? IDE_ATAPI_ID : IDE_ID_FUNCTION;

					hRes = GetIdentifyData( Handle, bDriveNumber, bDfpDriveMap, bIDCmd, a_SerialNumber );
					if ( GetLastError () != ERROR_SUCCESS )
					{
					   hRes = WBEM_E_FAILED;
					}
				}

			}
		}
   }


   return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetSCSIVersion
*
*  DESCRIPTION :    Gets a Smart Version
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetSCSIVersion(
	HANDLE h,
	BYTE bDriveNumber,
	CHString &a_SerialNumber)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    PSTORAGE_DEVICE_DESCRIPTOR psdd = NULL;
    STORAGE_PROPERTY_QUERY spq;

    ULONG ulBytesReturned = 0L;

    spq.PropertyId = StorageDeviceProperty;
    spq.QueryType = PropertyStandardQuery;
    spq.AdditionalParameters[0] = 0;

    try
    {
        psdd = (PSTORAGE_DEVICE_DESCRIPTOR) new BYTE[sizeof(STORAGE_DEVICE_DESCRIPTOR) + 2048];

        if(psdd)
        {
            ZeroMemory(psdd, sizeof(STORAGE_DEVICE_DESCRIPTOR) + 2048);
            // Send the IOCTL to retrieve the serial number information.
            BOOL fSuccess = DeviceIoControl(
                h,
                IOCTL_STORAGE_QUERY_PROPERTY,
                &spq,
                sizeof(STORAGE_PROPERTY_QUERY),
                psdd,
                sizeof(STORAGE_DEVICE_DESCRIPTOR) + 2046,
                &ulBytesReturned,
                NULL);

            if(fSuccess)
            {
                if(ulBytesReturned > 0 && psdd->SerialNumberOffset != 0 && psdd->SerialNumberOffset != -1)
                {
	                LPBYTE lpBaseAddres = (LPBYTE) psdd;
	                LPBYTE lpSerialNumber =  lpBaseAddres + psdd->SerialNumberOffset;

                    if(*lpSerialNumber)
                    {
                        a_SerialNumber = (LPSTR)lpSerialNumber;
                    }
                }
            }
            else
            {
                hr = WinErrorToWBEMhResult(::GetLastError());
            }

            delete psdd;
            psdd = NULL;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch(...)
    {
        if(psdd)
        {
            delete psdd;
            psdd = NULL;
        }
    }
    
   return hr;
}


/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::ChangeByteOrder
*
*  DESCRIPTION :    Changes the byte order for extracting the Serial Number 
*					for Smart IOCTL
*
*****************************************************************************/
void CPhysicalMedia::ChangeByteOrder(char *szString, USHORT uscStrSize)
{

	USHORT	i;
	char temp;

	for (i = 0; i < uscStrSize; i+=2)
	{
		temp = szString[i];
		szString[i] = szString[i+1];
		szString[i+1] = temp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\ntdomain.cpp ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  NtDomain.cpp
//
//  Purpose: Nt domain discovery property set provider
//
//***************************************************************************

#include "precomp.h"
#include <frqueryex.h>

#include "wbemnetapi32.h"
#include <dsgetdc.h>

#include "NtDomain.h"

#define MAX_PROPS			CWin32_NtDomain::e_End_Property_Marker
#define MAX_PROP_IN_BYTES	MAX_PROPS/8 + 1

#define _tobit( a ) ( 1 << a )

#define DOMAIN_PREPEND L"Domain: "
#define DOMAIN_PREPEND_SIZE ((sizeof(DOMAIN_PREPEND)/sizeof(WCHAR)) - 1 )

// into strings.cpp
LPCWSTR IDS_DomainControllerName		= L"DomainControllerName" ;
LPCWSTR IDS_DomainControllerAddress		= L"DomainControllerAddress" ;
LPCWSTR IDS_DomainControllerAddressType = L"DomainControllerAddressType" ;
LPCWSTR IDS_DomainGuid					= L"DomainGuid" ;
LPCWSTR IDS_DomainName					= L"DomainName" ;
LPCWSTR IDS_DnsForestName				= L"DnsForestName" ;
LPCWSTR IDS_DS_PDC_Flag					= L"DSPrimaryDomainControllerFlag" ;
LPCWSTR IDS_DS_Writable_Flag			= L"DSWritableFlag" ;
LPCWSTR IDS_DS_GC_Flag					= L"DSGlobalCatalogFlag" ;
LPCWSTR IDS_DS_DS_Flag					= L"DSDirectoryServiceFlag" ;
LPCWSTR IDS_DS_KDC_Flag					= L"DSKerberosDistributionCenterFlag" ;
LPCWSTR IDS_DS_Timeserv_Flag			= L"DSTimeServiceFlag" ;
LPCWSTR IDS_DS_DNS_Controller_Flag		= L"DSDnsControllerFlag" ;
LPCWSTR IDS_DS_DNS_Domain_Flag			= L"DSDnsDomainFlag" ;
LPCWSTR IDS_DS_DNS_Forest_Flag			= L"DSDnsForestFlag" ;
LPCWSTR IDS_DcSiteName					= L"DcSiteName" ;
LPCWSTR IDS_ClientSiteName				= L"ClientSiteName" ;

// Property set declaration
//=========================
CWin32_NtDomain s_Win32_NtDomain( PROPSET_NAME_NTDOMAIN , IDS_CimWin32Namespace ) ;


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_NtDomain::CWin32_NtDomain
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_NtDomain::CWin32_NtDomain (

LPCWSTR a_Name,
LPCWSTR a_Namespace
)
: Provider(a_Name, a_Namespace)
{
	SetPropertyTable() ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_NtDomain::~CWin32_NtDomain
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_NtDomain :: ~CWin32_NtDomain()
{
}

//
void CWin32_NtDomain::SetPropertyTable()
{
	// property set names for query optimization
	m_pProps.SetSize( MAX_PROPS ) ;

	// Win32_NtDomain
	m_pProps[e_DomainControllerName]		=(LPVOID) IDS_DomainControllerName;
	m_pProps[e_DomainControllerAddress]		=(LPVOID) IDS_DomainControllerAddress;
	m_pProps[e_DomainControllerAddressType]	=(LPVOID) IDS_DomainControllerAddressType;
	m_pProps[e_DomainGuid]					=(LPVOID) IDS_DomainGuid;
	m_pProps[e_DomainName]					=(LPVOID) IDS_DomainName;
	m_pProps[e_DnsForestName]				=(LPVOID) IDS_DnsForestName;
	m_pProps[e_DS_PDC_Flag]					=(LPVOID) IDS_DS_PDC_Flag;
	m_pProps[e_DS_Writable_Flag]			=(LPVOID) IDS_DS_Writable_Flag;
	m_pProps[e_DS_GC_Flag]					=(LPVOID) IDS_DS_GC_Flag;
	m_pProps[e_DS_DS_Flag]					=(LPVOID) IDS_DS_DS_Flag;
	m_pProps[e_DS_KDC_Flag]					=(LPVOID) IDS_DS_KDC_Flag;
	m_pProps[e_DS_Timeserv_Flag]			=(LPVOID) IDS_DS_Timeserv_Flag;
	m_pProps[e_DS_DNS_Controller_Flag]		=(LPVOID) IDS_DS_DNS_Controller_Flag;
	m_pProps[e_DS_DNS_Domain_Flag]			=(LPVOID) IDS_DS_DNS_Domain_Flag;
	m_pProps[e_DS_DNS_Forest_Flag]			=(LPVOID) IDS_DS_DNS_Forest_Flag;
	m_pProps[e_DcSiteName]					=(LPVOID) IDS_DcSiteName;
	m_pProps[e_ClientSiteName]				=(LPVOID) IDS_ClientSiteName;

	// CIM_System
    m_pProps[e_CreationClassName]			=(LPVOID) IDS_CreationClassName;
	m_pProps[e_Name]						=(LPVOID) IDS_Name; // key, override from CIM_ManagedSystemElement
	m_pProps[e_NameFormat]					=(LPVOID) IDS_NameFormat;
	m_pProps[e_PrimaryOwnerContact]			=(LPVOID) IDS_PrimaryOwnerContact;
	m_pProps[e_PrimaryOwnerName]			=(LPVOID) IDS_PrimaryOwnerName;
	m_pProps[e_Roles]						=(LPVOID) IDS_Roles;

	// CIM_ManagedSystemElement
	m_pProps[e_Caption]						=(LPVOID) IDS_Caption;
	m_pProps[e_Description]					=(LPVOID) IDS_Description;
	m_pProps[e_InstallDate]					=(LPVOID) IDS_InstallDate;
	m_pProps[e_Status]						=(LPVOID) IDS_Status;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_NtDomain::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The calling function will commit the instance.
//
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_NtDomain::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_NtDomain::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	HRESULT					t_hResult = WBEM_E_NOT_FOUND ;
	CHString				t_chsDomainName ;
	CHString				t_chsDomainKey ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	std::vector<_bstr_t>	t_vectorTrustList ;
	CNetAPI32				t_NetAPI ;

	if( ERROR_SUCCESS != t_NetAPI.Init() )
	{
		return WBEM_E_FAILED ;
	}

	// the key
	a_pInstance->GetCHString( IDS_Name, t_chsDomainKey ) ;

	// NTD: begins the key -- this keeps this class from colliding
	// other CIM_System based classes
	if( 0 == _wcsnicmp(t_chsDomainKey, DOMAIN_PREPEND, DOMAIN_PREPEND_SIZE ) )
	{
		t_chsDomainName = t_chsDomainKey.Mid( DOMAIN_PREPEND_SIZE ) ;
	}
	else
	{
		return WBEM_E_NOT_FOUND ;
	}

	// test resultant key
	if( t_chsDomainName.IsEmpty() )
	{
		return WBEM_E_NOT_FOUND ;
	}

	// secure trusted domain list for key validation
	t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

	for( UINT t_u = 0L; t_u < t_vectorTrustList.size(); t_u++ )
	{
		if( 0 == _wcsicmp( t_vectorTrustList[t_u], bstr_t( t_chsDomainName ) ) )
		{
			// properties required
			t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
			t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

  			t_hResult = GetDomainInfo(	t_NetAPI,
										bstr_t( t_chsDomainName ),
										a_pInstance,
										t_dwBits ) ;

			if( WBEM_E_NOT_FOUND == t_hResult )
			{
				// We have instantiated the domain. Couldn't obtain info though...
				t_hResult = WBEM_S_PARTIAL_RESULTS ;
			}
			break;
		}
	}

	return t_hResult ;
}
#endif
////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_NtDomain::EnumerateInstances
//
//  Inputs:     MethodContext*  a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_NtDomain::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_NtDomain::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	CNetAPI32	t_NetAPI ;

	if( ERROR_SUCCESS != t_NetAPI.Init() )
	{
		return WBEM_E_FAILED ;
	}

	// Property mask -- include all
	DWORD t_dwBits = 0xffffffff;

	return EnumerateInstances(	a_pMethodContext,
								a_Flags,
								t_NetAPI,
								t_dwBits ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_NtDomain::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32_NtDomain::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_NtDomain::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
    HRESULT					t_hResult			= WBEM_S_NO_ERROR ;
	HRESULT					t_hPartialResult	= WBEM_S_NO_ERROR ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	std::vector<_bstr_t>	t_vectorReqDomains ;
	std::vector<_bstr_t>	t_vectorTrustList;
	CNetAPI32				t_NetAPI ;
	CHString				t_chsDomainPrepend( DOMAIN_PREPEND ) ;

	if( ERROR_SUCCESS != t_NetAPI.Init() )
	{
		return WBEM_E_FAILED ;
	}

	// properties required
	t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
	t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

	// keys supplied
	a_rQuery.GetValuesForProp( IDS_Name, t_vectorReqDomains ) ;

	// Note: the primary key has prepended chars to distinquish
	//		 these instances from other CIM_System instances.
	//
	if( t_vectorReqDomains.size() )
	{
		// strip prepended characters
		for( int t_y = 0; t_y < t_vectorReqDomains.size(); t_y++ )
		{
			if( DOMAIN_PREPEND_SIZE < t_vectorReqDomains[t_y].length() )
			{
				// match on prepend?
				if( _wcsnicmp( (wchar_t*)t_vectorReqDomains[t_y],
										DOMAIN_PREPEND,
										DOMAIN_PREPEND_SIZE ) == 0 )
				{
					t_vectorReqDomains[t_y] = ( (wchar_t*)t_vectorReqDomains[t_y] +
												DOMAIN_PREPEND_SIZE ) ;
				}
			}
			else
			{
				// does not contain the class prepend
				t_vectorReqDomains.erase( t_vectorReqDomains.begin() + t_y ) ;
                t_y--;
			}
		}
	}

	// If the primary key is not specified
	// then try for the alternate non key query.
	//
	// This is a requirement for assocation support
	// via CBinding as the linkage there is to DomainName
	if( !t_vectorReqDomains.size() )
	{
		a_rQuery.GetValuesForProp( IDS_DomainName, t_vectorReqDomains ) ;
	}

	// General enum if query is ambigious
	if( !t_vectorReqDomains.size() )
	{
		t_hResult = EnumerateInstances( a_pMethodContext,
										a_lFlags,
										t_NetAPI,
										t_dwBits ) ;
	}
	else
	{
		// smart ptr
		CInstancePtr t_pInst ;

		// secure trusted domain list
		t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

		// by query list
		for ( UINT t_uD = 0; t_uD < t_vectorReqDomains.size(); t_uD++ )
		{
			// by Domain trust list
			for( UINT t_uT = 0L; t_uT < t_vectorTrustList.size(); t_uT++ )
			{
				// Trust to request match
				if( 0 == _wcsicmp( t_vectorTrustList[t_uT], t_vectorReqDomains[t_uD] ) )
				{
					t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

					t_hResult = GetDomainInfo(	t_NetAPI,
												t_vectorReqDomains[t_uD],
												t_pInst,
												t_dwBits ) ;

					if( SUCCEEDED( t_hResult ) )
					{
						// the key
						t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
														(wchar_t*)t_vectorReqDomains[t_uD] ) ;

						t_hResult = t_pInst->Commit() ;
					}
					else if( WBEM_E_NOT_FOUND == t_hResult )
					{
						// We have instantiated the domain. Couldn't obtain info though...
						t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
														(wchar_t*)t_vectorReqDomains[t_uD] ) ;

						t_hResult = t_pInst->Commit() ;

						t_hPartialResult = WBEM_S_PARTIAL_RESULTS ;
					}

					break ;
				}
			}

			if( FAILED( t_hResult ) )
			{
				break ;
			}
		}
	}

    return ( WBEM_S_NO_ERROR != t_hResult ) ? t_hResult : t_hPartialResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_NtDomain::EnumerateInstances(

MethodContext	*a_pMethodContext,
long			a_Flags,
CNetAPI32		&a_rNetAPI,
DWORD			a_dwProps
)
{
	HRESULT					t_hResult			= WBEM_S_NO_ERROR ;
	HRESULT					t_hPartialResult	= WBEM_S_NO_ERROR ;
	std::vector<_bstr_t>	t_vectorTrustList;

	CHString				t_chsDomainPrepend( DOMAIN_PREPEND ) ;

	// smart ptr
	CInstancePtr t_pInst ;

	// secure trusted domain list
	a_rNetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

	for( UINT t_u = 0L; t_u < t_vectorTrustList.size(); t_u++ )
	{
		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		t_hResult = GetDomainInfo(	a_rNetAPI,
									t_vectorTrustList[ t_u ],
									t_pInst,
									a_dwProps ) ;

		if( SUCCEEDED( t_hResult ) )
		{
			// the key
			t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
											(wchar_t*)t_vectorTrustList[t_u] ) ;

			t_hResult = t_pInst->Commit() ;
		}
		else if( WBEM_E_NOT_FOUND == t_hResult )
		{
			// the key. We have instantiated the domain. Couldn't obtain info though...
			t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
											(wchar_t*)t_vectorTrustList[t_u] ) ;

			t_hResult = t_pInst->Commit() ;

			t_hPartialResult = WBEM_S_PARTIAL_RESULTS ;
		}
		else
		{
			break ;
		}
	}

	return ( WBEM_S_NO_ERROR != t_hResult ) ? t_hResult : t_hPartialResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_NtDomain::GetDomainInfo(

CNetAPI32	&a_rNetAPI,
bstr_t		&a_bstrDomainName,
CInstance	*a_pInst,
DWORD		a_dwProps
)
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	if( a_bstrDomainName.length() )
	{
		ULONG					t_uFlags = 0L ;
		DOMAIN_CONTROLLER_INFO *t_pDCInfo = NULL ;
		DWORD					t_dwNetApiResult = 0 ;

		try
        {
			// avoid the NetAPI call if not needed
			if( a_dwProps & (

				_tobit( e_DomainControllerName )	|
				_tobit( e_DomainControllerAddress )	|
				_tobit( e_DomainControllerAddressType ) |
				_tobit( e_DomainGuid )	|
				_tobit( e_DomainName )	|
				_tobit( e_DnsForestName )	|
				_tobit( e_DS_PDC_Flag )	|
				_tobit( e_DS_Writable_Flag )	|
				_tobit( e_DS_GC_Flag )	|
				_tobit( e_DS_DS_Flag )	|
				_tobit( e_DS_KDC_Flag )	|
				_tobit( e_DS_Timeserv_Flag )	|
				_tobit( e_DS_DNS_Controller_Flag )	|
				_tobit( e_DS_DNS_Domain_Flag )	|
				_tobit( e_DS_DNS_Forest_Flag )	|
				_tobit( e_DcSiteName )	|
				_tobit( e_ClientSiteName ) ) )
			{
				// if requesting domain IP
				if( a_dwProps & _tobit( e_DomainControllerAddress ) )
				{
					t_uFlags |= DS_IP_REQUIRED ;
				}

				t_dwNetApiResult = a_rNetAPI.DsGetDcName(
										NULL,
										(wchar_t*)a_bstrDomainName,
										NULL,
										NULL,
										t_uFlags,
										&t_pDCInfo ) ;


				// force it if not cached
				if( NO_ERROR != t_dwNetApiResult )
				{
					t_uFlags |= DS_FORCE_REDISCOVERY ;

					t_dwNetApiResult = a_rNetAPI.DsGetDcName(
										NULL,
										(wchar_t*)a_bstrDomainName,
										NULL,
										NULL,
										t_uFlags,
										&t_pDCInfo ) ;
				}

				if( ( NO_ERROR == t_dwNetApiResult ) && t_pDCInfo )
				{
					// DomainControllerName
					if( a_dwProps & _tobit( e_DomainControllerName ) )
					{
						if( t_pDCInfo->DomainControllerName )
						{
							a_pInst->SetWCHARSplat(	IDS_DomainControllerName,
													t_pDCInfo->DomainControllerName ) ;
						}
					}

					// DomainControllerAddress
					if( a_dwProps & _tobit( e_DomainControllerAddress ) )
					{
						if( t_pDCInfo->DomainControllerAddress )
						{
							a_pInst->SetWCHARSplat(	IDS_DomainControllerAddress,
													t_pDCInfo->DomainControllerAddress ) ;
						}

						// DomainControllerAddressType, dependent on DS_IP_REQUIRED request
						if( a_dwProps & _tobit( e_DomainControllerAddressType ) )
						{
							a_pInst->SetDWORD(	IDS_DomainControllerAddressType,
												t_pDCInfo->DomainControllerAddressType ) ;
						}
					}

					// DomainGuid
					if( a_dwProps & _tobit( e_DomainGuid ) )
					{
						GUID	t_NullGuid ;
						memset( &t_NullGuid, 0, sizeof( t_NullGuid ) ) ;

						if( !IsEqualGUID( t_NullGuid, t_pDCInfo->DomainGuid ) )
						{
							WCHAR t_cGuid[ 128 ] ;

							StringFromGUID2( t_pDCInfo->DomainGuid, t_cGuid, sizeof( t_cGuid ) / sizeof (WCHAR) ) ;

							a_pInst->SetWCHARSplat(	IDS_DomainGuid,
													t_cGuid ) ;
						}
					}

					// DomainName
					if( a_dwProps & _tobit( e_DomainName ) )
					{
						if( t_pDCInfo->DomainName )
						{
							a_pInst->SetWCHARSplat(	IDS_DomainName,
													t_pDCInfo->DomainName ) ;
						}
					}

					// DnsForestName
					if( a_dwProps & _tobit( e_DnsForestName ) )
					{
						if( t_pDCInfo->DnsForestName )
						{
							a_pInst->SetWCHARSplat(	IDS_DnsForestName,
													t_pDCInfo->DnsForestName ) ;
						}
					}

					// DSPrimaryDomainControllerFlag
					if( a_dwProps & _tobit( e_DS_PDC_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_PDC_Flag,
											(bool)(t_pDCInfo->Flags & DS_PDC_FLAG) ) ;
					}

					// DSWritableFlag
					if( a_dwProps & _tobit( e_DS_Writable_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_Writable_Flag,
											(bool)(t_pDCInfo->Flags & DS_WRITABLE_FLAG) ) ;
					}

					// DSGlobalCatalogFlag
					if( a_dwProps & _tobit( e_DS_GC_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_GC_Flag,
											(bool)(t_pDCInfo->Flags & DS_GC_FLAG) ) ;
					}

					// DSDirectoryServiceFlag
					if( a_dwProps & _tobit( e_DS_DS_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DS_Flag,
											(bool)(t_pDCInfo->Flags & DS_DS_FLAG) ) ;
					}

					// DSKerberosDistributionCenterFlag
					if( a_dwProps & _tobit( e_DS_KDC_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_KDC_Flag,
											(bool)(t_pDCInfo->Flags & DS_KDC_FLAG) ) ;
					}

					// DSTimeServiceFlag
					if( a_dwProps & _tobit( e_DS_Timeserv_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_Timeserv_Flag,
											(bool)(t_pDCInfo->Flags & DS_TIMESERV_FLAG) ) ;
					}

					// DSDnsControllerFlag
					if( a_dwProps & _tobit( e_DS_DNS_Controller_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DNS_Controller_Flag,
											(bool)(t_pDCInfo->Flags & DS_DNS_CONTROLLER_FLAG) ) ;
					}

					// DSDnsDomainFlag
					if( a_dwProps & _tobit( e_DS_DNS_Domain_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DNS_Domain_Flag,
											(bool)(t_pDCInfo->Flags & DS_DNS_DOMAIN_FLAG) ) ;
					}

					// DSDnsForestFlag
					if( a_dwProps & _tobit( e_DS_DNS_Forest_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DNS_Forest_Flag,
											(bool)(t_pDCInfo->Flags & DS_DNS_FOREST_FLAG) ) ;
					}

					// DcSiteName
					if( a_dwProps & _tobit( e_DcSiteName ) )
					{
						if( t_pDCInfo->DcSiteName )
						{
							a_pInst->SetWCHARSplat(	IDS_DcSiteName,
													t_pDCInfo->DcSiteName ) ;
						}
					}

					// ClientSiteName
					if( a_dwProps & _tobit( e_ClientSiteName ) )
					{
						if( t_pDCInfo->ClientSiteName )
						{
							a_pInst->SetWCHARSplat(	IDS_ClientSiteName,
													t_pDCInfo->ClientSiteName ) ;
						}
					}

					t_hResult = WBEM_S_NO_ERROR ;

				}
				else if( ERROR_NOT_ENOUGH_MEMORY == t_dwNetApiResult )
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}
				else
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
			}

			// CIM_System follows

			// CreationClassName
			if( a_dwProps & _tobit( e_CreationClassName ) )
			{
				a_pInst->SetWCHARSplat(	IDS_CreationClassName,
										PROPSET_NAME_NTDOMAIN ) ;
			}

			// CIM_System::Name is the key

			// TODO:
			// e_NameFormat, IDS_NameFormat
			// e_PrimaryOwnerContact, IDS_PrimaryOwnerContact
			// e_PrimaryOwnerName, IDS_PrimaryOwnerName
			// e_Roles, IDS_Roles


			// CIM_ManagedSystemElement follows

			// Caption
			if( a_dwProps & _tobit( e_Caption ) )
			{
				// REVIEW:
				a_pInst->SetWCHARSplat(	IDS_Caption,
										(wchar_t*)a_bstrDomainName ) ;
			}

			// Description
			if( a_dwProps & _tobit( e_Description ) )
			{
				// REVIEW:
				a_pInst->SetWCHARSplat(	IDS_Description,
										(wchar_t*)a_bstrDomainName ) ;
			}

			// Status
			if( a_dwProps & _tobit( e_Status ) )
			{
				if( NO_ERROR == t_dwNetApiResult )
				{
					// REVIEW:
					a_pInst->SetCHString ( IDS_Status , IDS_STATUS_OK ) ;
				}
				else
				{
					// REVIEW:
					a_pInst->SetCHString ( IDS_Status , IDS_STATUS_Unknown ) ;
				}
			}

			// TODO:
			//	e_InstallDate, IDS_InstallDate
		}
		catch(...)
		{
			if( t_pDCInfo )
			{
				a_rNetAPI.NetApiBufferFree( t_pDCInfo ) ;
			}

			throw;
		}

		if( t_pDCInfo )
		{
			a_rNetAPI.NetApiBufferFree( t_pDCInfo ) ;
			t_pDCInfo = NULL ;
		}
	}
	else	// NULL domain
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\precomp.h ===
#pragma message("Precompiling header...")


#include <fwcommon.h>
#include <brodcast.h>
#include "dllutils.h"
#include <smartptr.h>
#include "strings.h"
#include "ConfgMgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\physicalmedia.h ===
/******************************************************************



   PhysicalMedia.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef  _CPHYSICALMEDIA_H_
#define  _CPHYSICALMEDIA_H_

#define PROVIDER_NAME_PHYSICALMEDIA		 L"Win32_PhysicalMedia"

#define ERROR_CLASSPATH					 L"\\\\.\\root\\cimv2:__ExtendedStatus"

#define TAG							   L"Tag"
#define SERIALNUMBER				   L"SerialNumber"
//
// Valid values for the bCommandReg member of IDEREGS.
//
#define	IDE_ATAPI_ID				0xA1	// Returns ID sector for ATAPI.
#define	IDE_ID_FUNCTION				0xEC	// Returns ID sector for ATA.
#define	IDE_EXECUTE_SMART_FUNCTION	0xB0	// Performs SMART cmd.
											// Requires valid bFeaturesReg,
#if(_WIN32_WINNT >= 0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER    CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)
// IOCTL support for SMART drive fault prediction.
#define SMART_GET_VERSION               CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA            CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */											// bCylLowReg, and bCylHighReg

//---------------------------------------------------------------------
// The following struct defines the interesting part of the IDENTIFY
// buffer:
//---------------------------------------------------------------------
typedef struct _IDSECTOR {
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	USHORT	wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	USHORT	wBS;
	USHORT	wNumCurrentCyls;
	USHORT	wNumCurrentHeads;
	USHORT	wNumCurrentSectorsPerTrack;
	ULONG	ulCurrentSectorCapacity;
	USHORT	wMultSectorStuff;
	ULONG	ulTotalAddressableSectors;
	USHORT	wSingleWordDMA;
	USHORT	wMultiWordDMA;
	BYTE	bReserved[128];
} IDSECTOR, *PIDSECTOR;


class CPhysicalMedia : public Provider 
{
private:
	HRESULT Enumerate( MethodContext *pMethodContext );
	HRESULT GetPhysDiskInfoNT ( CInstance *pInstance, LPCWSTR lpwszDiskSpec, BYTE bIndex );
	void ChangeByteOrder(char *szString, USHORT uscStrSize);
	HRESULT GetIdentifyData( HANDLE hDrive, BYTE bDriveNumber, BYTE bDfpDriveMap, BYTE bIDCmd, CHString &a_SerialNumber );
	HRESULT EnableSmart( HANDLE hDrive, BYTE bDriveNum, BYTE & bDfpDriveMap );
	HRESULT GetSmartVersion( HANDLE Handle, BYTE bDriveNumber, 	CHString &a_SerialNumber );
    HRESULT GetSCSIVersion(
        HANDLE h, 
        BYTE bDriveNumber, 	
        CHString &a_SerialNumber);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;
public:
        
		CPhysicalMedia (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CPhysicalMedia () ;
private:
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\shutdownevent.h ===
//=================================================================

//

// PowerManagement.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   03/31/99	a-peterc        Created
//
//=================================================================

#ifndef _WMI_SHUTDOWN_EVENT_PROVIDER_H
#define _WMI_SHUTDOWN_EVENT_PROVIDER_H

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"


#define SHUTDOWN_EVENT_CLASS L"Win32_ComputerShutdownEvent"

//
class CShutdownEventFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CShutdownEventFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CShutdownEventFactory() {};

		// implementation of abstract CProviderClassFactory
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CShutdownEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
		void HandleEvent( 
							UINT a_message,
							WPARAM a_wParam,
							LPARAM	a_lParam  ) ;

		BOOL m_bRegistered;
	
	protected:
	public:

		CShutdownEvent() : m_bRegistered( FALSE ) {};
		~CShutdownEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CEventProvider
		virtual void ProvideEvents() ;

		// implementation of abstract CEventProvider
        void OnFinalRelease();

		// implementation of class name retrieval for CEventProvider
		virtual BSTR GetClassName() ;

		BOOL fGetComputerName( LPWSTR lpwcsBuffer, LPDWORD nSize ) ;
	
};

#endif // _WMI_SHUTDOWN_EVENT_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\useassoc.cpp ===
//=================================================================

//

// useassoc.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assoc.h>

CAssociation MyOperatingSystemAutochkSetting(
    L"Win32_OperatingSystemAutochkSetting",
    IDS_CimWin32Namespace,
    L"Win32_OperatingSystem",
    L"Win32_AutoChkSetting",
    IDS_Element,
    IDS_Setting
) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include ..\..\..\..\common\makefile.cmn
SOURCES_USED=..\..\..\..\common\makefile.cmn

TARGETNAME=wmipcima

TARGETPATH=obj
TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES); \
	$(COMMON_NEWTHROW_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(CIMWIN32_LIB_INC); \
	$(WMIIDL_INC); \
	$(CRT_INC_PATH); \
	$(FRAMEDYN_PRIVATE); \
	$(NET_INC_PATH); \
	$(BASE_INC_PATH); \

PRESOURCES=$(PRESOURCES) \
	..\useassoc.cpp \
	..\usebinding.cpp \
	..\JOProcess.cpp \
	..\Ntdomain.cpp \
	..\PhysicalMedia.cpp \
	..\ShutdownEvent.cpp \
	..\UsbHub.cpp	\
	..\VolumeChange.cpp \
	..\Win32_ControllerHasHub.cpp \

NTSOURCES=$(NTSOURCES) \

MISCSOURCES=$(MISCSOURCES) \
	..\cimwin32a.rc \
        ..\maindll.cpp	\

TARGETLIBS= \
	$(COMMON_NEWTHROW_LIB) \
!ifdef USE_FRAMEDYD
	$(WMIROOT)\SDK\FrameDyn\dyd\$(O)\framedydp.lib \
!else
	$(WMIROOT)\SDK\FrameDyn\dyn\$(O)\framedynp.lib \
!endif
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(CIMWIN32_LIB)	\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\setupapi.lib \


C_DEFINES=$(C_DEFINES) /D_WINDLL /D_WIN32_DCOM
USER_C_FLAGS=$(USER_C_FLAGS)
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
USE_STL=1
DLLENTRY=_DllMainCRTStartup

DLLDEF=$(O)\cimwin32A.def

!ifdef USE_FRAMEDYD
DEBUG_CRTS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\shutdownevent.cpp ===
//=================================================================

//

// PowerManagement.cpp -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "ShutdownEvent.h"
#include <cnvmacros.h>

#include <computerAPI.h> 

DWORD	g_dwLogoffMarker = 0 ;
DWORD	g_dwShutdownMarker = 0 ;

//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================
// Implements a PowerEventProvider
IUnknown * CShutdownEventFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CShutdownEvent) ;
}



//=================================================================
//
// CShutdownEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CWmiProviderInit needs the class name
BSTR CShutdownEvent::GetClassName()
{
	return SysAllocString(SHUTDOWN_EVENT_CLASS);
}


// CWmiEventProvider signals us to begin providing for events
void CShutdownEvent::ProvideEvents()
{
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE;
		CWinMsgEvent::RegisterForMessage( WM_ENDSESSION ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CShutdownEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
	switch ( a_message ) 
	{
		case WM_ENDSESSION: 
		{
			BOOL	t_HandleMessage = FALSE ;	
			DWORD	t_dwTicks = GetTickCount() ; 

			// we will get a number of these... 
			// pace the events 30 sec apart.   

			if( ENDSESSION_LOGOFF & a_lParam )	// logoff
			{
				// don't resignal if the minimum time between events
				// have not passed.  
				if( 30000 < t_dwTicks - g_dwLogoffMarker )
				{
					g_dwLogoffMarker = t_dwTicks ;			
					t_HandleMessage = TRUE ;
				}		
			}
			else // shutdown
			{
				// don't resignal if the minimum time between events
				// have not passed.  
				if( 30000 < t_dwTicks - g_dwShutdownMarker )
				{
					g_dwShutdownMarker = t_dwTicks ;
					t_HandleMessage = TRUE ;
				}
			}
		
			if( t_HandleMessage )
			{
				HandleEvent( a_message, a_wParam, a_lParam ) ;
			}			
			break ;
		}
	}
} 

//
void CShutdownEvent::HandleEvent( 

UINT a_message,
WPARAM a_wParam,
LPARAM	a_lParam 
)
{
	BOOL t_Pause = FALSE ;

	IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

	if( t_pClass != NULL && t_pHandler != NULL )
	{
    	IWbemClassObjectPtr t_pInst;

		if( SUCCEEDED( t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		{
			VARIANT t_varEvent ;
			VariantInit( &t_varEvent ) ;

			t_varEvent.vt	= VT_I4 ;
			
			if( ENDSESSION_LOGOFF & a_lParam )
			{
				t_varEvent.lVal = 0 ; // logoff	
			}
			else
			{
				t_varEvent.lVal = 1 ; // shutdown	
			}
		
			if ( SUCCEEDED( t_pInst->Put( L"Type", 0, &t_varEvent, CIM_UINT32 ) ) )
			{
				// Get the current computer name
                CHString t_sComputerName;
                DWORD    t_dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                fGetComputerName( t_sComputerName.GetBuffer( t_dwBufferLength ), &t_dwBufferLength ) ;
                t_sComputerName.ReleaseBuffer();
				
				variant_t t_vName( t_sComputerName ) ;

				if ( SUCCEEDED( t_pInst->Put( L"MachineName", 0, &t_vName, NULL ) ) )
				{
                    IWbemClassObject *p2 = t_pInst;
			        t_pHandler->Indicate ( 1, &p2 ) ;

					t_Pause = TRUE ;
				}
			}

			VariantClear ( &t_varEvent ) ;
		}
	}
	if( t_Pause )
	{
		// allow WMI some time to process this event 
		//Sleep( 3500 ) ; 
	}
}

//
BOOL CShutdownEvent::fGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
		return ProviderGetComputerName ( lpwcsBuffer, nSize ) ;
    }
    else
    {
        char lpBuffer[_MAX_PATH];
        
        BOOL bRet = GetComputerNameA(lpBuffer, nSize);

        // If the call worked
        if (bRet)
        {
			bool t_ConversionFailure = false ;
            WCHAR *pName = NULL ;
            ANSISTRINGTOWCS(lpBuffer, pName , t_ConversionFailure );
			if ( ! t_ConversionFailure )
			{
				if ( pName )
				{
					wcscpy(lpwcsBuffer, pName);
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			else
			{
				SetLastError(ERROR_NO_UNICODE_TRANSLATION);
				return FALSE ;
			}
        }

        return bRet;

    }
}

void CShutdownEvent::OnFinalRelease()
{
    if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_ENDSESSION ) ;
	}

    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\usbhub.h ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  USBHub.h
//
//  Purpose: USB Hub property set provider
//
//***************************************************************************

// Property set identification
//============================
#ifndef _USBHUB_H
#define _USBHUB_H

#define USBHUB_ALL_PROPS                    0xFFFFFFFF
#define USBHUB_KEY_ONLY                     0x00000010
#define USBHUB_PROP_ConfigManagerErrorCode  0x00000001
#define USBHUB_PROP_ConfigManagerUserConfig 0x00000002
#define USBHUB_PROP_Status                  0x00000004
#define USBHUB_PROP_PNPDeviceID             0x00000008
#define USBHUB_PROP_DeviceID                0x00000010
#define USBHUB_PROP_SystemCreationClassName 0x00000020
#define USBHUB_PROP_SystemName              0x00000040
#define USBHUB_PROP_Description             0x00000080
#define USBHUB_PROP_Caption                 0x00000100
#define USBHUB_PROP_Name                    0x00000200
#define USBHUB_PROP_CreationClassName       0x00000400

#define	PROPSET_NAME_USBHUB	L"Win32_USBHub"

class CWin32USBHub : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;

    protected:

        virtual bool IsOneOfMe
        (
            void *a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void *a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void *a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps = USBHUB_ALL_PROPS
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32USBHub
        (
			const CHString &a_strName, 
			LPCWSTR a_pszNamespace
        );

        ~CWin32USBHub();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance *a_pInst, 
            long a_lFlags,
            CFrameworkQuery& pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext *a_pMethodContext, 
            CFrameworkQuery &a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags = 0L
        );        
} ;

// This is the base; it should always commit in the base.
inline bool CWin32USBHub::ShouldBaseCommit
(
    void *a_pvData
)
{ 
    return true; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\usbhub.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  USBHub.cpp
//
//  Purpose: USB Hub property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <ProvExce.h>

#include "USBHub.h"

// Property set declaration
//=========================

CWin32USBHub MyUSBHub( PROPSET_NAME_USBHUB, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::CWin32USBHub
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32USBHub::CWin32USBHub
(
	const CHString &a_strName,
	LPCWSTR a_pszNamespace
)
: Provider( a_strName, a_pszNamespace )
{
    m_ptrProperties.SetSize(11);
    m_ptrProperties[0]	= ( (LPVOID) IDS_ConfigManagerErrorCode );
    m_ptrProperties[1]	= ( (LPVOID) IDS_ConfigManagerUserConfig );
    m_ptrProperties[2]	= ( (LPVOID) IDS_Status);
    m_ptrProperties[3]	= ( (LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4]	= ( (LPVOID) IDS_DeviceID);
    m_ptrProperties[5]	= ( (LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6]	= ( (LPVOID) IDS_SystemName);
    m_ptrProperties[7]	= ( (LPVOID) IDS_Description);
    m_ptrProperties[8]	= ( (LPVOID) IDS_Caption);
    m_ptrProperties[9]	= ( (LPVOID) IDS_Name);
    m_ptrProperties[10] = ( (LPVOID) IDS_CreationClassName );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::~CWin32USBHub
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 ****************************************************************************/

CWin32USBHub::~CWin32USBHub()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USBHub::GetObject
//
//  Inputs:     CInstance		*a_pInst - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::GetObject
(
    CInstance *a_pInst,
    long a_lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND ;
    CConfigManager t_cfgmgr ;

	// Let's see if config manager recognizes this device at all
	CHString t_sDeviceID ;
	a_pInst->GetCHString( IDS_DeviceID, t_sDeviceID ) ;

	CConfigMgrDevicePtr t_pDevice;
	if( t_cfgmgr.LocateDevice( t_sDeviceID, t_pDevice ) )
	{
		// OK, it knows about it.  Is it a USB Hub?
		if( IsOneOfMe(t_pDevice ) )
		{
            CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &pQuery ) ;
            DWORD t_dwProperties ;

	        t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;

			t_hResult = LoadPropertyValues( &CLPVParams( a_pInst,
														t_pDevice,
														t_dwProperties ) ) ;
		}
	}

	return t_hResult;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::ExecQuery
//
//  Inputs:     MethodContext *a_pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::ExecQuery
(
    MethodContext *a_pMethodContext,
    CFrameworkQuery &a_pQuery,
    long a_lFlags
)
{
    CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_pQuery ) ;
    DWORD t_dwProperties ;

	t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;
    return Enumerate( a_pMethodContext, a_lFlags, t_dwProperties ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USBHub::EnumerateInstances
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::EnumerateInstances
(
    MethodContext *a_pMethodContext,
    long a_lFlags /*= 0L*/
)
{
    return Enumerate( a_pMethodContext, a_lFlags ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USBHub::Enumerate
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::Enumerate
(
    MethodContext *a_pMethodContext,
    long a_lFlags,
    DWORD a_dwReqProps
)
{
    HRESULT				t_hResult = WBEM_E_FAILED ;
    CConfigManager		t_cfgManager ;
    CDeviceCollection	t_deviceList ;
	CInstancePtr		t_pInst;
	CConfigMgrDevicePtr t_pDevice;

	if( t_cfgManager.GetDeviceListFilterByClass( t_deviceList, L"USB" ) )
	{
		REFPTR_POSITION t_pos;
		if( t_deviceList.BeginEnum( t_pos ) )
		{
			t_hResult = WBEM_S_NO_ERROR;

			// Walk the list
            for (t_pDevice.Attach(t_deviceList.GetNext( t_pos ));
                 SUCCEEDED( t_hResult ) && (t_pDevice != NULL);
                 t_pDevice.Attach(t_deviceList.GetNext( t_pos )))
			{
				// Now to find out if this is the usb Hub
				if( IsOneOfMe( t_pDevice ) )
				{
                    t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
					if( SUCCEEDED( t_hResult = LoadPropertyValues( &CLPVParams(
																		t_pInst,
																		t_pDevice,
																		a_dwReqProps ) ) ) )
					{
						// Derived classes (like CW32USBCntrlDev) may
						// commit as result of call to
						// LoadPropertyValues, so check if we should
						// (only do so if we are of this class's type).
						if( ShouldBaseCommit( NULL ) )
						{
							t_hResult = t_pInst->Commit(  ) ;
						}
					}
				}
			}

			// Always call EndEnum().
			t_deviceList.EndEnum();
		}
	}

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : void *a_pv - Instance package to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32USBHub::LoadPropertyValues
(
    void *a_pv
)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR;
    CHString	t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/
    CLPVParams			*t_pData		= ( CLPVParams * ) a_pv ;
    CInstance			*t_pInst		= ( CInstance * )( t_pData->m_pInstance ) ; // This instance released by caller
    CConfigMgrDevice	*t_pDevice		= ( CConfigMgrDevice * )( t_pData->m_pDevice ) ;
    DWORD				t_dwReqProps	= ( DWORD )( t_pData->m_dwReqProps ) ;

    if( t_pInst == NULL || t_pDevice == NULL )
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID( t_chstrDeviceID ) ;

    if( t_chstrDeviceID.GetLength() == 0 )
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInst->SetCHString( IDS_DeviceID, t_chstrDeviceID ) ;
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if( t_dwReqProps & USBHUB_PROP_PNPDeviceID )
    {
        t_pInst->SetCHString( IDS_PNPDeviceID, t_chstrDeviceID ) ;
    }

	if( t_dwReqProps & USBHUB_PROP_SystemCreationClassName )
    {
        t_pInst->SetCHString( IDS_SystemCreationClassName,
                                  IDS_Win32ComputerSystem ) ;
    }
	if( t_dwReqProps & USBHUB_PROP_CreationClassName )
    {
        SetCreationClassName(t_pInst);
    }
    if( t_dwReqProps & USBHUB_PROP_SystemName )
    {
        t_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;
    }

    if( t_dwReqProps & (USBHUB_PROP_Description | USBHUB_PROP_Caption | USBHUB_PROP_Name) )
    {
        if( t_pDevice->GetDeviceDesc( t_chstrDesc ) )
        {
            t_pInst->SetCHString( IDS_Description, t_chstrDesc ) ;
        }
    }

    if( t_dwReqProps & USBHUB_PROP_ConfigManagerErrorCode ||
        t_dwReqProps & USBHUB_PROP_Status )
    {
        DWORD t_dwStatus	= 0L;
        DWORD t_dwProblem	= 0L;

		if( t_pDevice->GetStatus( &t_dwStatus, &t_dwProblem ) )
        {
            if( t_dwReqProps & USBHUB_PROP_ConfigManagerErrorCode )
            {
                t_pInst->SetDWORD( IDS_ConfigManagerErrorCode, t_dwProblem ) ;
            }

            if( t_dwReqProps & USBHUB_PROP_Status )
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInst->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if( t_dwReqProps & USBHUB_PROP_ConfigManagerUserConfig )
    {
        t_pInst->SetDWORD( IDS_ConfigManagerUserConfig,
                               t_pDevice->IsUsingForcedConfig() ) ;
    }

    // Use the friendly name for caption and name
    if( t_dwReqProps & USBHUB_PROP_Caption || t_dwReqProps & USBHUB_PROP_Name )
    {
        if( t_pDevice->GetFriendlyName( t_chstrTemp ) )
        {
            t_pInst->SetCHString( IDS_Caption, t_chstrTemp ) ;
            t_pInst->SetCHString( IDS_Name, t_chstrTemp ) ;
        }
        else
        {
            // If we can't get the name, settle for the description
            if( t_chstrDesc.GetLength() > 0 )
            {
                t_pInst->SetCHString( IDS_Caption, t_chstrDesc ) ;
                t_pInst->SetCHString( IDS_Name, t_chstrDesc ) ;
            }
        }
    }
    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a hub and not some
 *                other type of USB device.
 *
 *  INPUTS      : void *a_pv - The device to check.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32USBHub::IsOneOfMe
(
    void *a_pv
)
{
    bool t_fRet = false;

    if( NULL != a_pv )
    {
        CConfigMgrDevice *t_pDevice = ( CConfigMgrDevice * ) a_pv ;

		// Is it a usb device?
        if( t_pDevice->IsClass( L"USB" ) )
        {
            // Now to find out if this is a usb hub
            CConfigMgrDevicePtr t_pParentDevice;

			if( t_pDevice->GetParent( t_pParentDevice ) )
            {
                if( t_pParentDevice->IsClass( L"USB" ) )
                {
                    t_fRet = true ;
                }
            }
        }
    }
    return t_fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Binding.h>

CBinding UserToDomain(
    L"Win32_UserInDomain",
    IDS_CimWin32Namespace,
    L"Win32_NTDomain",
    L"Win32_UserAccount",
    IDS_GroupComponent,
    IDS_PartComponent,
    L"DomainName",
    IDS_Domain
);

CBinding GroupToDomain(
    L"Win32_GroupInDomain",
    IDS_CimWin32Namespace,
    L"Win32_NTDomain",
    L"Win32_Group",
    IDS_GroupComponent,
    IDS_PartComponent,
    L"DomainName",
    IDS_Domain
);

CBinding JOStats(
    L"Win32_NamedJobObjectStatistics",
    IDS_CimWin32Namespace,
    L"Win32_NamedJobObjectActgInfo",
    L"Win32_NamedJobObject",
    L"Stats",
    L"Collection",
    L"Name",
    L"CollectionID"
);

CBinding JOLimit(
    L"Win32_NamedJobObjectLimit",
    IDS_CimWin32Namespace,
    L"Win32_NamedJobObjectLimitSetting",
    L"Win32_NamedJobObject",
    L"Setting",
    L"Collection",
    L"SettingID",
    L"CollectionID"
);

CBinding JOSecLimit(
    L"Win32_NamedJobObjectSecLimit",
    IDS_CimWin32Namespace,
    L"Win32_NamedJobObjectSecLimitSetting",
    L"Win32_NamedJobObject",
    L"Setting",
    L"Collection",
    L"SettingID",
    L"CollectionID"
);

CBinding Win32_LogonSessionMappedDisk(
    L"Win32_LogonSessionMappedDisk",
    IDS_CimWin32Namespace,
    L"Win32_LogonSession",
    L"Win32_MappedLogicalDisk",
    L"Antecedent",
    L"Dependent",
    L"LogonID",
    L"SessionID"
);

CBinding Win32_DiskDrivePhysicalMedia(
   L"Win32_DiskDrivePhysicalMedia",
   IDS_CimWin32Namespace,
   L"Win32_DiskDrive",
   L"Win32_PhysicalMedia",
   L"Dependent",
   L"Antecedent",
   L"DeviceID",
   L"Tag"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\volumechange.h ===
//=================================================================

//

// VolumeChange.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"
#include <dbt.h>


#define VOLUME_CHANGE_EVENT L"Win32_VolumeChangeEvent"

//
class CVolumeChangeFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CVolumeChangeFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CVolumeChangeFactory() {};

		// implementation of abstract CProviderClassFactory
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CVolumeChangeEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
        void HandleEvent( WPARAM wParam, DEV_BROADCAST_VOLUME *pVol );
		BOOL m_bRegistered;
	
	protected:
	public:

		CVolumeChangeEvent() : m_bRegistered ( FALSE ) {};
		~CVolumeChangeEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CWmiEventProvider
		virtual void ProvideEvents() ;

		// implementation of class name retrieval for CEventProvider
		virtual void OnFinalRelease() ;

		// implementation of class name retrieval for CWmiProviderInit
		virtual BSTR GetClassName() ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\win32_controllerhashub.h ===
//=================================================================

//

// Win32_ControllerHasHub.h -- Controller to usb hub assoc

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "assoc.h"

#define MAX_ORS 3

class CContHasHub : public CBinding
{
    public:

        CContHasHub(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        virtual ~CContHasHub() {}

    protected:

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        // We need to disable this
        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
            ) {}

        // We need to disable this
        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
            ) { return WBEM_S_NO_ERROR; }

//-----------

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\win32_controllerhashub.cpp ===
//=================================================================

//

// Win32_ControllerHasHub.cpp -- Controller to usb hub assoc

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Binding.h>
#include <ConfgMgr.h>
#include "Win32_ControllerHasHub.h"

CContHasHub::CContHasHub(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName

) : CBinding (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName,
    pwszLeftBindingPropertyName,
    pwszRightBindingPropertyName
)
{
}

CContHasHub UserToDomain(
    L"Win32_ControllerHasHub",
    IDS_CimWin32Namespace,
    L"Win32_USBController",
    L"Win32_USBHub",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_DeviceID
);

bool CContHasHub::AreRelated(

    const CInstance *pLeft, 
    const CInstance *pRight
)
{
    // Ok, at this point, we know pLeft is a usb controller and pRight
    // is a usb hub.  The only question left is whether the usb controller
    // is controlling this specific hub.

    bool bRet = false;
    CHString sHub;

    pRight->GetCHString(IDS_DeviceID, sHub);

    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pDevice, pParentDevice;

    if ( cfgmgr.LocateDevice ( sHub , pDevice ) )
    {
        CHString sController, sDeviceID;

        pLeft->GetCHString(IDS_DeviceID, sController);

        while (pDevice->GetParent(pParentDevice))
        {
            pParentDevice->GetDeviceID(sDeviceID);

            if (sDeviceID.CompareNoCase(sController) == 0)
            {
                bRet = true;
                break;
            }
            else
            {
                pDevice = pParentDevice;
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\volumechange.cpp ===
//=================================================================

//

// VolumeChange.cpp -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <dbt.h>
#include "VolumeChange.h"

//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================
// Implements a VolumeChangeProvider
IUnknown * CVolumeChangeFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CVolumeChangeEvent) ;
}

//=================================================================
//
// CVolumeChangeEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CWmiProviderInit needs the class name
BSTR CVolumeChangeEvent::GetClassName()
{
	return SysAllocString(VOLUME_CHANGE_EVENT);
}

// CWmiEventProvider signals us to begin providing for events
void CVolumeChangeEvent::ProvideEvents()
{
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE;
		CWinMsgEvent::RegisterForMessage( WM_DEVICECHANGE ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CVolumeChangeEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
    DEV_BROADCAST_HDR *pHdr = (DEV_BROADCAST_HDR *)a_lParam;

    if (
          (
           (a_wParam == DBT_DEVICEARRIVAL) ||
           (a_wParam == DBT_DEVICEREMOVECOMPLETE) 
          ) &&

          (pHdr->dbch_devicetype == DBT_DEVTYP_VOLUME) 
       )
    {
	    HandleEvent( a_wParam, (DEV_BROADCAST_VOLUME *) pHdr ) ;
    }
}

void CVolumeChangeEvent::HandleEvent( WPARAM wParam, DEV_BROADCAST_VOLUME *pVol )
{
    HRESULT hr = S_OK;  // Note that this result is NOT sent back from this function
                        // since I don't have any place to send it TO.

    if ( ( pVol->dbcv_flags == 0 ) || ( pVol->dbcv_flags & DBTF_MEDIA ) )
    {
	    IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	    IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

    	if( t_pClass != NULL && t_pHandler != NULL )
	    {
        	IWbemClassObjectPtr t_pInst;

		    if( SUCCEEDED( hr = t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		    {
                DWORD dwUnitMask = pVol->dbcv_unitmask;

                for (DWORD i = 0; i < 26; ++i)
                {
                    if (dwUnitMask & 0x1)
                    {
						WCHAR l[3];
						l[0] = i + L'A';
						l[1] = L':';
						l[2] = L'\0';

						variant_t vValue(l);
						variant_t vEventType;

						switch (wParam)
						{
							case DBT_DEVICEARRIVAL:
							{
								vEventType = (long)2;
								break;
							}

							case DBT_DEVICEREMOVECOMPLETE:
							{
								vEventType = (long)3;
								break;
							}

							default:
							{
								hr = WBEM_E_FAILED;
								break;
							}
						}

						if ( SUCCEEDED(hr) &&
							SUCCEEDED( hr = t_pInst->Put( L"DriveName", 0, &vValue, 0 ) ) &&
							SUCCEEDED( hr = t_pInst->Put( L"EventType", 0, &vEventType, 0 ) )
						)
						{
							// We can't use t_pInst here, cuz the operator(cast) for this smartptr
							// will FREE the pointer before passing it in, under the assumption
							// that Indicate is going to POPULATE this pointer.
							IWbemClassObject *p2 = t_pInst;
							hr = t_pHandler->Indicate ( 1, &p2 ) ;
						}
                    }

                    dwUnitMask = dwUnitMask >> 1;
                }
			}
	    }
    }
}


//
void CVolumeChangeEvent::OnFinalRelease()
{
    if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_DEVICECHANGE ) ;
	}

	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\accessentry.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.cpp - implementation file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( void )
:	m_Sid(),
	m_bACEType( 0 ),
	m_bACEFlags( 0 ),
	m_dwAccessMask( 0 ),
    m_pguidObjType(NULL),
    m_pguidInhObjType(NULL)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				PSID		pSid - Sid to intialize from
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( PSID pSid,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName ) : m_Sid( pSid, pszComputerName ),
											m_bACEType( bACEType ),
											m_bACEFlags( bACEFlags ),
                                            m_pguidObjType(NULL),
                                            m_pguidInhObjType(NULL),
											m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				PSID		pSid - Sid to intialize from
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( PSID pSid,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName,
                bool fLookup ) : m_Sid( pSid, pszComputerName, fLookup ),
							  	 m_bACEType( bACEType ),
								 m_bACEFlags( bACEFlags ),
                                 m_pguidObjType(NULL),
                                 m_pguidInhObjType(NULL),
								 m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				CSid&		sid - Sid to intialize from
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( const CSid& sid,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName ) : m_Sid( sid ),
											m_bACEType( bACEType ),
											m_bACEFlags( bACEFlags ),
                                            m_pguidObjType(NULL),
                                            m_pguidInhObjType(NULL),
											m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				char*		pszAccountName - Account Name
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( LPCTSTR pszAccountName,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName ) : m_Sid( pszAccountName, pszComputerName ),
											m_bACEType( bACEType ),
                                            m_pguidObjType(NULL),
                                            m_pguidInhObjType(NULL),
											m_bACEFlags( bACEFlags ),
											m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class copy constructor.
//
//	Inputs:
//				const CAccessEntry	r_AccessEntry - object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( const CAccessEntry &r_AccessEntry )
:
    m_Sid(),
	m_bACEType( 0 ),
	m_bACEFlags( 0 ),
	m_dwAccessMask( 0 ),
    m_pguidObjType(NULL),
    m_pguidInhObjType(NULL)
{
	// Copy the values over
	m_Sid = r_AccessEntry.m_Sid;
	m_dwAccessMask = r_AccessEntry.m_dwAccessMask;
	m_bACEType = r_AccessEntry.m_bACEType;
	m_bACEFlags = r_AccessEntry.m_bACEFlags;
    if(r_AccessEntry.m_pguidObjType != NULL)
    {
        SetObjType(*(r_AccessEntry.m_pguidObjType));
    }
    if(r_AccessEntry.m_pguidInhObjType != NULL)
    {
        SetInhObjType(*(r_AccessEntry.m_pguidInhObjType));
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Assignment operator.
//
//	Inputs:
//				const CAccessEntry	r_AccessEntry - object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry &	CAccessEntry::operator= ( const CAccessEntry &r_AccessEntry )
{
	// Copy the values over
	m_Sid = r_AccessEntry.m_Sid;
	m_dwAccessMask = r_AccessEntry.m_dwAccessMask;
	m_bACEType = r_AccessEntry.m_bACEType;
	m_bACEFlags = r_AccessEntry.m_bACEFlags;
    if(r_AccessEntry.m_pguidObjType != NULL)
    {
        SetObjType(*(r_AccessEntry.m_pguidObjType));
    }
    if(r_AccessEntry.m_pguidInhObjType != NULL)
    {
        SetInhObjType(*(r_AccessEntry.m_pguidInhObjType));
    }

	return (*this);
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	== Comparison operator.
//
//	Inputs:
//				const CAccessEntry	r_AccessEntry - object to compare.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntry::operator== ( const CAccessEntry &r_AccessEntry )
{
	bool fRet = false;
    if(	    m_Sid			==	r_AccessEntry.m_Sid
		&&	m_dwAccessMask	==	r_AccessEntry.m_dwAccessMask
		&&	m_bACEType		==	r_AccessEntry.m_bACEType
		&&	m_bACEFlags		==	r_AccessEntry.m_bACEFlags)
    {
        if((r_AccessEntry.m_pguidObjType == NULL && m_pguidObjType == NULL) ||
           ((r_AccessEntry.m_pguidObjType != NULL && m_pguidObjType != NULL) &&
            (*(r_AccessEntry.m_pguidObjType) == *m_pguidObjType)))
        {
            if((r_AccessEntry.m_pguidInhObjType == NULL && m_pguidInhObjType == NULL) ||
               ((r_AccessEntry.m_pguidInhObjType != NULL && m_pguidInhObjType != NULL) &&
                (*(r_AccessEntry.m_pguidInhObjType) == *m_pguidInhObjType)))
            {
                fRet = true;
            }
        }
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::~CAccessEntry
//
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::~CAccessEntry( void )
{
    if(m_pguidObjType != NULL) delete m_pguidObjType;
    if(m_pguidInhObjType != NULL) delete m_pguidInhObjType;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::AllocateACE
//
//	Helper function to allocate an appropriate ACE object so outside
//	code can quickly and easily fill out PACLs.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACE_HEADER**	ppACEHeader - Pointer to allocated
//								ACE Header.
//
//	Returns:
//				BOOL			Succes/Failure
//
//	Comments:
//
//	User should use FreeACE to free the allocated object.
//
///////////////////////////////////////////////////////////////////

BOOL CAccessEntry::AllocateACE( ACE_HEADER** ppACEHeader )
{
	// Clear out the structure
	*ppACEHeader = NULL;

	if ( m_Sid.IsValid() )
	{
		ACE_HEADER*	pACEHeader = NULL;
		WORD		wAceSize = 0;
		DWORD		dwSidLength = m_Sid.GetLength();

		switch ( m_bACEType )
		{
			case ACCESS_ALLOWED_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_ALLOWED_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_ALLOWED_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_ALLOWED_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

			case ACCESS_DENIED_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_DENIED_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_DENIED_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_DENIED_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

			case SYSTEM_AUDIT_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_AUDIT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_AUDIT_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_AUDIT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_ALLOWED_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_ALLOWED_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_ALLOWED_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
                        pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
/************************* this type has not been implemented yet on W2K *************************************

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_ALLOWED_COMPOUND_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_ALLOWED_COMPOUND_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_ALLOWED_COMPOUND_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                        memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

*************************************************************************************************************/
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_DENIED_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_DENIED_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_DENIED_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_AUDIT_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_AUDIT_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_AUDIT_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

/********************************* type not yet supported under w2k ********************************************
            case SYSTEM_ALARM_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_ALARM_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_ALARM_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_ALARM_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
/********************************* type not yet supported under w2k ********************************************/
/********************************* type not yet supported under w2k ********************************************
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_ALARM_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_ALARM_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_ALARM_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
/********************************* type not yet supported under w2k ********************************************/

			default:
			{
				// Something bad just happened
				ASSERT_BREAK(0);
			}

		}	// SWITCH

		// Fill out the common values, then store the value for return.
		if ( NULL != pACEHeader )
		{
			pACEHeader->AceType = m_bACEType;
			pACEHeader->AceFlags = m_bACEFlags;
			pACEHeader->AceSize = wAceSize;

			*ppACEHeader = pACEHeader;
		}

	}

	// Return whether or not a valid ACE is coming out
	return ( NULL != *ppACEHeader );

}

void CAccessEntry::DumpAccessEntry(LPCWSTR wstrFilename)
{
    CHString chstrTemp1;

    Output(L"ACE contents follow...", wstrFilename);

    // Dump the access mask...
    chstrTemp1.Format(L"ACE access mask (hex): %x", m_dwAccessMask);
    Output(chstrTemp1, wstrFilename);

    // Dump the ace type...
    chstrTemp1.Format(L"ACE type (hex): %x", m_bACEType);
    Output(chstrTemp1, wstrFilename);

    // Dump the ace flags...
    chstrTemp1.Format(L"ACE flags (hex): %x", m_bACEFlags);
    Output(chstrTemp1, wstrFilename);

    // Dump the ace sid...
    m_Sid.DumpSid(wstrFilename);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\accessentry.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.h - header file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CACCESSENTRY_H__
#define __CACCESSENTRY_H__

#include "Sid.h"			// CSid class

#define ALL_ACCESS_WITHOUT_GENERIC	0x01FFFFFF	// all possible access rights
												// without generic

// This is an NT 5 flag that we will use to tell us that an ACE although read out, should
// NOT be written back.  It was copied from the NT 5 WINNT.H, since we are not building
// using that file.

#define INHERITED_ACE                     (0x10)

//////////////////////////////////////////////////////////////////
//
//	Class: CAccessEntry
//
//	Class to encapsulate Windows NT ACE information.  It basically
//	acts as a repository for a SID, and access information.
//
//////////////////////////////////////////////////////////////////

class CAccessEntry
{
	// Constructors and destructor
	public:
		CAccessEntry();

		CAccessEntry( PSID pSid,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask = ALL_ACCESS_WITHOUT_GENERIC,
				LPCTSTR pszComputerName = NULL );

        CAccessEntry( PSID pSid,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName,
                bool fLookup );

		CAccessEntry( const CSid& sid,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask = ALL_ACCESS_WITHOUT_GENERIC,
				LPCTSTR pszComputerName = NULL );

		CAccessEntry( LPCTSTR pszAccountName,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask = ALL_ACCESS_WITHOUT_GENERIC,
				LPCTSTR pszComputerName = NULL );

		CAccessEntry( const CAccessEntry &r_AccessEntry );
		~CAccessEntry( void );

		CAccessEntry &	operator= ( const CAccessEntry & );
		bool operator== ( const CAccessEntry & );

		BOOL IsEqualToSID( PSID psid );
		void GetSID( CSid& sid );
		DWORD GetAccessMask( void );
		BYTE GetACEType( void );
		BYTE GetACEFlags( void );
        bool GetObjType(GUID &guidObjType);
        bool GetInhObjType(GUID &guidInhObjType);

		void SetAccessMask( DWORD dwAccessMask );
		void MergeAccessMask( DWORD dwMergeMask );
		void SetACEFlags( BYTE bACEFlags );
		void SetSID( CSid& sid );
		void SetACEType( BYTE aceType );
        void SetObjType(GUID &guidObjType);
        void SetInhObjType(GUID &guidInhObjType);

		BOOL AllocateACE( ACE_HEADER** ppACEHeader );
		void FreeACE( ACE_HEADER* pACEHeader );

		bool IsInherited( void );
        bool IsAllowed();
        bool IsDenied();

        void DumpAccessEntry(LPCWSTR wstrFilename = NULL);

	private:
		CSid		m_Sid;
		DWORD		m_dwAccessMask;
		BYTE		m_bACEType;
		BYTE		m_bACEFlags;
        GUID       *m_pguidObjType;
        GUID       *m_pguidInhObjType;

	

};

inline void CAccessEntry::GetSID( CSid& sid )
{
	sid = m_Sid;
}

inline void CAccessEntry::SetSID( CSid& sid )
{
	m_Sid = sid;
}

inline BOOL CAccessEntry::IsEqualToSID( PSID psid )
{
	return EqualSid( psid, m_Sid.GetPSid() );
}

inline DWORD CAccessEntry::GetAccessMask( void )
{
	return m_dwAccessMask;
}

inline BYTE CAccessEntry::GetACEType( void )
{
	return m_bACEType;
}

inline void CAccessEntry::SetACEType( BYTE aceType )
{
	m_bACEType = aceType;
}

inline BYTE CAccessEntry::GetACEFlags( void )
{
	return m_bACEFlags;
}

inline void CAccessEntry::SetAccessMask( DWORD dwAccessMask )
{
	m_dwAccessMask = dwAccessMask;
}

inline void CAccessEntry::MergeAccessMask( DWORD dwMergeMask )
{
	m_dwAccessMask |= dwMergeMask;
}

inline void CAccessEntry::SetACEFlags( BYTE bACEFlags )
{
	m_bACEFlags = bACEFlags;
}


inline bool CAccessEntry::GetObjType(GUID &guidObjType)
{
    bool fRet = false;
    if(m_pguidObjType != NULL)
    {
        memcpy(&guidObjType, m_pguidObjType, sizeof(GUID));
        fRet = true;
    }
    return fRet;
}

inline void CAccessEntry::SetObjType(GUID &guidObjType)
{
    if(m_pguidObjType == NULL)
    {
        try
        {
            m_pguidObjType = new GUID;   
        }
        catch(...)
        {
            if(m_pguidObjType != NULL)
            {
                delete m_pguidObjType;
                m_pguidObjType = NULL;
            }
            throw;
        }
    }
    if(m_pguidObjType != NULL)
    {
        memcpy(m_pguidObjType, &guidObjType, sizeof(GUID));
    }
}

inline bool CAccessEntry::GetInhObjType(GUID &guidObjType)
{
    bool fRet = false;
    if(m_pguidInhObjType != NULL)
    {
        memcpy(&guidObjType, m_pguidInhObjType, sizeof(GUID));
        fRet = true;
    }
    return fRet;
}

inline void CAccessEntry::SetInhObjType(GUID &guidInhObjType)
{
    if(m_pguidInhObjType == NULL)
    {
        try
        {
            m_pguidInhObjType = new GUID;   
        }
        catch(...)
        {
            if(m_pguidInhObjType != NULL)
            {
                delete m_pguidInhObjType;
                m_pguidInhObjType = NULL;
            }
            throw;
        }
    }
    if(m_pguidInhObjType != NULL)
    {
        memcpy(m_pguidInhObjType, &guidInhObjType, sizeof(GUID));
    }
}

inline void CAccessEntry::FreeACE( ACE_HEADER* pACEHeader )
{
	free( pACEHeader );
}

inline bool CAccessEntry::IsInherited( void )
{
	bool fRet = false;
    if(m_bACEFlags & INHERITED_ACE)
    {
        fRet = true;
    } 
    return fRet;
}

inline bool CAccessEntry::IsAllowed( void )
{
	bool fRet = false;
    if(( m_bACEType == ACCESS_ALLOWED_ACE_TYPE) ||
       ( m_bACEType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ||
       ( m_bACEType == ACCESS_ALLOWED_OBJECT_ACE_TYPE))
    {
        fRet = true;
    }
    return fRet;
}

inline bool CAccessEntry::IsDenied( void )
{
	bool fRet = false;
    if(( m_bACEType == ACCESS_DENIED_ACE_TYPE) ||
       ( m_bACEType == ACCESS_DENIED_OBJECT_ACE_TYPE))
    {
        fRet = true;
    }
    return fRet;
}

#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\accessentrylist.cpp ===
/*****************************************************************************/
/*  Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.cpp - implementation file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */
#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntryList.h"
#include "DACL.h"
#include "SACL.h"
#include "securitydescriptor.h"
#include "AdvApi32Api.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"
#ifndef MAXDWORD
#define MAXDWORD MAXULONG
#endif

// We're using STL, so this is a requirement
using namespace std;

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CAccessEntryList
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntryList::CAccessEntryList( void )
:	m_ACL()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CAccessEntryList
//
//	Class constructor.
//
//	Inputs:
//				PACL		pWin32ACL - ACL to initialize from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntryList::CAccessEntryList( PACL pWin32ACL, bool fLookup /* = true */ )
:	m_ACL()
{
	InitFromWin32ACL( pWin32ACL, ALL_ACE_TYPES, fLookup );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::~CAccessEntryList
//
//	Class destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntryList::~CAccessEntryList( void )
{
	Clear();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Add
//
//	Adds a CAccessEntry* pointer to the front of the list.
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to add to the list
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Add( CAccessEntry* pACE )
{
	// Add to the front of the list
	m_ACL.push_front( pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Append
//
//	Appends a CAccessEntry* pointer to the end of the list.
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to add to the list
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Append( CAccessEntry* pACE )
{
	// Add to the end of the list
	m_ACL.push_back( pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates a CAccessEntry* pointer in our list
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to find in the list
//
//	Outputs:
//				None.
//
//	Returns:
//				ACLIter		iterator pointing at entry we found
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

ACLIter CAccessEntryList::Find( CAccessEntry* pACE )
{
	for (	ACLIter	acliter	=	m_ACL.begin();
			acliter != m_ACL.end()
		&&	*acliter != pACE;
			acliter++ );

	return acliter;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates a CAccessEntry* pointer in our list whose contents match
//	the supplied ACE.
//
//	Inputs:
//				const CAccessEntry&	ace - ACE to find in the list
//
//	Outputs:
//				None.
//
//	Returns:
//				CAccessEntry*	pointer to matchiong ace.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry* CAccessEntryList::Find( const CAccessEntry& ace )
{
	for (	ACLIter	acliter	=	m_ACL.begin();
			acliter != m_ACL.end()
		&&	!( *(*acliter) == ace );
			acliter++ );

	return ( acliter == m_ACL.end() ? NULL : *acliter );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				CAccessEntry* Pointer to object we found.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry* CAccessEntryList::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, bool fLookup /* = true */ )
{

	// Traverse the list until we find an element matching the psid, ACE Type and
	// ACE Flags, or run out of elements.
	for(ACLIter	acliter	= m_ACL.begin(); acliter != m_ACL.end(); acliter++)
    {
		CAccessEntry tempace(psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, NULL, fLookup);
        CAccessEntry *ptempace2 = *acliter;
        if(*ptempace2 == tempace) break;
    }
	return ( acliter == m_ACL.end() ? NULL : *acliter );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AddNoDup
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.  If one is found, we replace the
//	values of that object.  Otherwise, we add the new object to
//	the list.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//				DWORD		dwMask - Access Mask.
//				BOOL		fMerge - Merge flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		success/failure.
//
//	Comments:
//				If fMerge is TRUE, if we find a value, we or the
//				access masks together, otherwise, we replace
//				the mask.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AddNoDup( PSID psid, BYTE bACEType, BYTE bACEFlags, DWORD dwMask, GUID *pguidObjGuid,
                       GUID *pguidInhObjGuid, bool fMerge /* = false */ )
{
	bool	fReturn = true;

	// Look for a duplicate entry in our linked list.  This means that
	// the sid, the ACEType and the flags are the same.  If this happens,
	// we merge the entries by ORing in the new mask or overwrite (based
	// on the merge mask).  Otherwise, we should add the new entry to the
	// front of the list

	CAccessEntry*	pAccessEntry = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask );

	if ( NULL == pAccessEntry )
	{
		// NOT found, so we need to add a new entry.
		try
        {
            pAccessEntry = new CAccessEntry(	psid,
											    bACEType,
											    bACEFlags,
                                                pguidObjGuid,
                                                pguidInhObjGuid,
											    dwMask );
		    if ( NULL != pAccessEntry )
		    {
			    Add( pAccessEntry );
		    }
		    else
		    {
			    fReturn = false;
		    }
        }
        catch(...)
        {
            if(pAccessEntry != NULL)
            {
                delete pAccessEntry;
                pAccessEntry = NULL;
            }
            throw;
        }

	}
	else
	{
		if ( fMerge )
		{
			// OR in any new values.
			pAccessEntry->MergeAccessMask( dwMask );
		}
		else
		{
			pAccessEntry->SetAccessMask( dwMask );
		}
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AppendNoDup
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.  If one is found, we replace the
//	values of that object.  Otherwise, we append the new object to
//	the list.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//				DWORD		dwMask - Access Mask.
//				BOOL		fMerge - Merge flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		success/failure.
//
//	Comments:
//				If fMerge is TRUE, if we find a value, we or the
//				access masks together, otherwise, we replace
//				the mask.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AppendNoDup( PSID psid,
                                    BYTE bACEType,
                                    BYTE bACEFlags,
                                    DWORD dwMask,
                                    GUID *pguidObjGuid,
                                    GUID *pguidInhObjGuid,
                                    bool fMerge /* = false */ )
{
	bool	fReturn = true;

	// Look for a duplicate entry in our linked list.  This means that
	// the sid, the ACEType and the flags are the same.  If this happens,
	// we merge the entries by ORing in the new mask or overwrite (based
	// on the merge mask).  Otherwise, we should add the new entry to the
	// end of the list

	CAccessEntry*	pAccessEntry = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask );

	if ( NULL == pAccessEntry )
	{
		// NOT found, so we need to append a new entry.
		try
        {
            pAccessEntry = new CAccessEntry(	psid,
											    bACEType,
											    bACEFlags,
                                                pguidObjGuid,
                                                pguidInhObjGuid,
                                                dwMask );
		    if ( NULL != pAccessEntry )
		    {
			    Append( pAccessEntry );
		    }
		    else
		    {
			    fReturn = false;
		    }
        }
        catch(...)
        {
            if(pAccessEntry != NULL)
            {
                delete pAccessEntry;
                pAccessEntry = NULL;
            }
            throw;
        }

	}
	else
	{
		if ( fMerge )
		{
			// OR in any new values.
			pAccessEntry->MergeAccessMask( dwMask );
		}
		else
		{
			pAccessEntry->SetAccessMask( dwMask );
		}
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AppendNoDup
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.  If one is found, we replace the
//	values of that object.  Otherwise, we append the new object to
//	the list.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//				DWORD		dwMask - Access Mask.
//				BOOL		fMerge - Merge flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		success/failure.
//
//	Comments:
//				If fMerge is TRUE, if we find a value, we or the
//				access masks together, otherwise, we replace
//				the mask.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AppendNoDup( PSID psid,
                                    BYTE bACEType,
                                    BYTE bACEFlags,
                                    DWORD dwMask,
                                    GUID *pguidObjGuid,
                                    GUID *pguidInhObjGuid,
                                    bool fMerge,
                                    bool fLookup )
{
	bool	fReturn = true;

	// Look for a duplicate entry in our linked list.  This means that
	// the sid, the ACEType and the flags are the same.  If this happens,
	// we merge the entries by ORing in the new mask or overwrite (based
	// on the merge mask).  Otherwise, we should add the new entry to the
	// end of the list

	CAccessEntry*	pAccessEntry = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask, fLookup );

	if ( NULL == pAccessEntry )
	{
		// NOT found, so we need to append a new entry.
		try
        {
            pAccessEntry = new CAccessEntry(	psid,
											    bACEType,
											    bACEFlags,
                                                pguidObjGuid,
                                                pguidInhObjGuid,
                                                dwMask,
                                                NULL,
                                                fLookup );
		    if ( NULL != pAccessEntry )
		    {
			    Append( pAccessEntry );
		    }
		    else
		    {
			    fReturn = false;
		    }
        }
        catch(...)
        {
            if(pAccessEntry != NULL)
            {
                delete pAccessEntry;
                pAccessEntry = NULL;
            }
            throw;
        }

	}
	else
	{
		if ( fMerge )
		{
			// OR in any new values.
			pAccessEntry->MergeAccessMask( dwMask );
		}
		else
		{
			pAccessEntry->SetAccessMask( dwMask );
		}
	}

	return fReturn;

}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Remove
//
//	Removes the specified pointer from our list.
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to remove.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	We DO NOT free the pointer.
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Remove( CAccessEntry* pACE )
{
	ACLIter	acliter = Find( pACE );

	if ( acliter != m_ACL.end() )
	{
		m_ACL.erase( acliter );
	}

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Clear
//
//	Clears and empties out the list.  Frees the pointers as they
//	are located.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Clear( void )
{

	// Delete all list entries and then clear out the list.

	for (	ACLIter	acliter	=	m_ACL.begin();
			acliter != m_ACL.end();
			acliter++ )
	{
		delete *acliter;
	}

	m_ACL.erase( m_ACL.begin(), m_ACL.end() );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates an ACE in our list matching the specified criteria.
//
//	Inputs:
//				const CSid&	sid - SID
//				BYTE		bACEType - ACE Type
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bACEFlags - ACE Flags
//
//	Outputs:
//				CAccessEntry&	ace
//
//	Returns:
//				BOOL		success/failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::Find( const CSid& sid,
                             BYTE bACEType,
                             BYTE bACEFlags,
                             GUID *pguidObjGuid,
                             GUID *pguidInhObjGuid,
                             DWORD dwAccessMask,
                             CAccessEntry& ace )
{
	CAccessEntry	tempace( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask );

	CAccessEntry* pACE = NULL;
    try
    {
        pACE = Find( tempace );

	    if ( NULL != pACE )
	    {
		    ace = *pACE;
	    }
    }
    catch(...)
    {
        if(pACE != NULL)
        {
            delete pACE;
            pACE = NULL;
        }
        throw;
    }

	return ( NULL != pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates an ACE in our list matching the specified criteria.
//
//	Inputs:
//				PSID		psid - PSID.
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - ACE Flags
//
//	Outputs:
//				CAccessEntry&	ace
//
//	Returns:
//				BOOL		success/failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
	CAccessEntry* pACE = NULL;
    try
    {
        CAccessEntry* pACE = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask);

	    if ( NULL != pACE )
	    {
		    ace = *pACE;
	    }
    }
    catch(...)
    {
        if(pACE != NULL)
        {
            delete pACE;
            pACE = NULL;
        }
        throw;
    }

	return ( NULL != pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Copy
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::Copy( CAccessEntryList& ACL )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		CAccessEntry*	pACE = NULL;
        try
        {
            pACE = new CAccessEntry( *(*acliter) );

		    if ( NULL != pACE )
		    {
			    Append( pACE );
		    }
		    else
		    {
			    break;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies non-Inherited ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyACEs( CAccessEntryList& ACL, BYTE bACEType )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We don't want inherited ACEs
		if (	(*acliter)->GetACEType() == bACEType
			&&	!(*acliter)->IsInherited() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }

            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyInheritedACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies Inherited ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyInheritedACEs( CAccessEntryList& ACL, BYTE bACEType )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want inherited ACEs
		if (	(*acliter)->GetACEType() == bACEType
			&&	(*acliter)->IsInherited() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyAllowedACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies Allowed ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyAllowedACEs( CAccessEntryList& ACL )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want allowed ACEs
		if ( (*acliter)->IsAllowed() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyDeniedACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies Denied ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyDeniedACEs( CAccessEntryList& ACL )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want denied ACEs
		if ( (*acliter)->IsDenied() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyByACEType
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies ACEs of the specified type and inheritence.
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyByACEType(CAccessEntryList& ACL, BYTE bACEType, bool fInherited)
{
	// Dump out our existing entries
	Clear();
    bool fIsInh;
    fInherited ? fIsInh = true : fIsInh = false;

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want inherited ACEs
		if ( ( (*acliter)->GetACEType() == bACEType ) &&
             ( ((*acliter)->IsInherited() != 0) == fIsInh ) )
        {
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }
        }
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AppendList
//
//	Appends list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to append.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AppendList( CAccessEntryList& ACL )
{

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		CAccessEntry*	pACE = NULL;
        try
        {
            pACE = new CAccessEntry( *(*acliter) );

		    if ( NULL != pACE )
		    {
			    Append( pACE );
		    }
		    else
		    {
			    break;
		    }
        }

        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }


	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::BeginEnum
//
//	Call to establish an ACLPOSIION& value for continung enumerations.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Beginning position.
//
//	Returns:
//				BOOL			Success/Failure.
//
//	Comments:
//
//	User MUST call EndEnum() on pos.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::BeginEnum( ACLPOSITION& pos )
{
	// Allocate a new iterator and stick it at the beginning
	ACLIter*	pACLIter = NULL;
    try
    {
        pACLIter = new ACLIter;
    }
    catch(...)
    {
        if(pACLIter != NULL)
        {
            delete pACLIter;
            pACLIter = NULL;
        }
        throw;
    }

	if ( NULL != pACLIter )
	{
		*pACLIter = m_ACL.begin();
	}

	pos = (ACLPOSITION) pACLIter;

	return ( NULL != pACLIter );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::GetNext
//
//	Enumeration call using ACLPOSITION.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Beginning position.
//				CAccessEntry&	ACE - enumed value.
//
//	Returns:
//				BOOL			Success/Failure.
//
//	Comments:
//
//	Because it returns copies, this function is FOR public use.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::GetNext( ACLPOSITION& pos, CAccessEntry& ACE )
{
	CAccessEntry*	pACE = NULL;
    try
    {
        pACE = GetNext( pos );
    }
    catch(...)
    {
        if(pACE != NULL)
        {
            delete pACE;
            pACE = NULL;
        }
        throw;
    }

	if ( NULL != pACE )
	{
		ACE = *pACE;
	}

	// TRUE/FALSE return based on whether we got back a pointer or not.
	return ( NULL != pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::GetNext
//
//	Enumeration call using ACLPOSITION.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Beginning position.
//
//	Returns:
//				CAccessEntry*	enumed pointer
//
//	Comments:
//
//	Because it returns actual pointers, DO NOT make this function
//	public.
//
///////////////////////////////////////////////////////////////////

CAccessEntry* CAccessEntryList::GetNext( ACLPOSITION& pos )
{
	CAccessEntry*	pACE		=	NULL;
	ACLIter*		pACLIter	=	(ACLIter*) pos;

	// We'll want to get the current value and increment
	// if we're anywhere but the end.

	if ( *pACLIter != m_ACL.end() )
	{
		// Get the ACE out
		pACE = *(*pACLIter);
		(*pACLIter)++;
	}

	return pACE;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:EndEnum
//
//	Enumeration End call.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Position to end on.
//
//	Returns:
//				None.
//
//	Comments:
//
//	ACLPOSITION passed in will be invalidated.
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::EndEnum( ACLPOSITION& pos )
{
	ACLIter*	pACLIter = (ACLIter*) pos;

	delete pACLIter;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:GetAt
//
//	Locates ACE at specified index.
//
//	Inputs:
//				DWORD			dwIndex - Index to find.
//
//	Outputs:
//				CAccessEntry&	ace - ACE located at dwIndex.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::GetAt( DWORD dwIndex, CAccessEntry& ace )
{
	bool	fReturn = false;

	if ( dwIndex < m_ACL.size() )
	{
		ACLIter	acliter	=	m_ACL.begin();

		// Enum the list until we hit the index or run out of values.
		// we should hit the index since we verified that dwIndex is
		// indeed < m_ACL.size().

		for (	DWORD	dwCtr = 0;
				dwCtr < dwIndex
			&&	acliter != m_ACL.end();
				acliter++, dwCtr++ );

		if ( acliter != m_ACL.end() )
		{
			// Copy the ACE
			ace = *(*acliter);
			fReturn = true;
		}

	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:SetAt
//
//	Locates ACE at specified index and overwrites it.
//
//	Inputs:
//				DWORD			dwIndex - Index to find.
//				CAccessEntry&	ace - ACE to set at dwIndex.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::SetAt( DWORD dwIndex, const CAccessEntry& ace )
{
	bool	fReturn = false;

	if ( dwIndex < m_ACL.size() )
	{
		ACLIter	acliter	=	m_ACL.begin();

		// Enum the list until we hit the index, at which point we will
		// replace the existing entry data with the supplied data.

		for (	DWORD	dwCtr = 0;
				dwCtr < dwIndex
			&&	acliter != m_ACL.end();
				acliter++, dwCtr++ );

		if ( acliter != m_ACL.end() )
		{
			// Copy the ACE
			*(*acliter) = ace;
			fReturn = true;
		}

	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:RemoveAt
//
//	Locates ACE at specified index and removes it.
//
//	Inputs:
//				DWORD			dwIndex - Index to find.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::RemoveAt( DWORD dwIndex )
{
	bool	fReturn = false;

	if ( dwIndex < m_ACL.size() )
	{
		ACLIter	acliter	=	m_ACL.begin();

		// Enum the list until we hit the index, at which point we will
		// delete the pointer at the entry and erase it from the list.

		for (	DWORD	dwCtr = 0;
				dwCtr < dwIndex
			&&	acliter != m_ACL.end();
				acliter++, dwCtr++ );

		if ( acliter != m_ACL.end() )
		{
			delete *acliter;
			m_ACL.erase( acliter );
			fReturn = true;
		}

	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:CalculateWin32ACLSize
//
//	Traverses our list and calculates the size of a Win32ACL
//	containing corresponding values.
//
//	Inputs:
//				None.
//
//	Outputs:
//				LPDWORD			pdwACLSize - ACL Size.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CAccessEntryList::CalculateWin32ACLSize( LPDWORD pdwACLSize )
{
	BOOL	fReturn = TRUE;

	if ( 0 == *pdwACLSize )
	{
		*pdwACLSize = sizeof(ACL);
	}

	// Objects for internal manipulations and gyrationships
	CAccessEntry*	pAce = NULL;
	CSid			sid;
	ACLPOSITION		pos;

	if ( BeginEnum( pos ) )
	{
        try
        {
		    while (		fReturn
				    &&	( pAce = GetNext( pos ) ) != NULL )
		    {
				// Different structures for different ACEs
				switch ( pAce->GetACEType() )
				{
					case ACCESS_ALLOWED_ACE_TYPE:	            *pdwACLSize += sizeof( ACCESS_ALLOWED_ACE );	                break;
					case ACCESS_DENIED_ACE_TYPE:	            *pdwACLSize += sizeof( ACCESS_DENIED_ACE );		                break;
					case SYSTEM_AUDIT_ACE_TYPE:		            *pdwACLSize += sizeof( SYSTEM_AUDIT_ACE );		                break;
                    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:        *pdwACLSize += sizeof( ACCESS_ALLOWED_OBJECT_ACE );             break;
                    //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:		*pdwACLSize += sizeof( ACCESS_ALLOWED_COMPOUND_ACE );		    break;
                    case ACCESS_DENIED_OBJECT_ACE_TYPE:         *pdwACLSize += sizeof( ACCESS_DENIED_OBJECT_ACE );              break;
                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:          *pdwACLSize += sizeof( SYSTEM_AUDIT_OBJECT_ACE );               break;
                    //case SYSTEM_ALARM_ACE_TYPE:		            *pdwACLSize += sizeof( SYSTEM_ALARM_ACE_TYPE );		            break;
                    //case SYSTEM_ALARM_OBJECT_ACE_TYPE:          *pdwACLSize += sizeof( SYSTEM_ALARM_OBJECT_ACE );               break;
					default:						            ASSERT_BREAK(0); fReturn = FALSE;			                	break;
				}

				pAce->GetSID( sid );

				// Calculate the storage required for the Sid using the formula
				// from the security reference code samples

				*pdwACLSize += GetLengthSid( sid.GetPSid() ) - sizeof( DWORD );

            }

        }
        catch(...)
        {
            if(pAce != NULL)
            {
                delete pAce;
                pAce = NULL;
            }
            throw;
        }
		EndEnum( pos );
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:FillWin32ACL
//
//	Traverses our list and adds ACE entries to a Win32 ACL.
//
//	Inputs:
//				PACL		pACL - ACL to add ACEs to.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CAccessEntryList::FillWin32ACL( PACL pACL )
{
	DWORD			dwReturn = ERROR_SUCCESS;

    if(pACL == NULL)
    {
        return E_POINTER;
    }

	// Objects for internal manipulations and gyrationships
	CAccessEntry*	pACE = NULL;
	ACLPOSITION		pos;
	ACE_HEADER*		pAceHeader = NULL;

#if NTONLY >= 5
    CAdvApi32Api *t_pAdvApi32 = NULL;
    t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
#endif

	// Enumerate the List.

	if ( BeginEnum( pos ) )
	{
        while (		ERROR_SUCCESS == dwReturn
				&&	( pACE = GetNext( pos ) ) != NULL )
		{
#if NTONLY >= 5
            if(pACE->GetACEType() == ACCESS_ALLOWED_OBJECT_ACE_TYPE)
            {
                if(t_pAdvApi32 != NULL)
                {
                    // Call the new function AddAccessAllowedObjectAce...
                    CSid sid;
                    pACE->GetSID(sid);
                    BOOL fRetval = FALSE;
                    GUID guidObjType, guidInhObjType;
                    GUID *pguidObjType = NULL;
                    GUID *pguidInhObjType = NULL;

                    if(pACE->GetObjType(guidObjType)) pguidObjType = &guidObjType;
                    if(pACE->GetInhObjType(guidInhObjType)) pguidInhObjType = &guidInhObjType;

                    if(!t_pAdvApi32->AddAccessAllowedObjectAce(pACL,
                                                                ACL_REVISION_DS,
                                                                pACE->GetACEFlags(),
                                                                pACE->GetAccessMask(),
                                                                pguidObjType,
                                                                pguidInhObjType,
                                                                sid.GetPSid(),
                                                                &fRetval))
                    {
                        dwReturn = ERROR_PROC_NOT_FOUND;
                    }
                    else // fn exists in dll
                    {
                        if(!fRetval)
                        {
                            dwReturn = ::GetLastError();
                        }
                    }
                }
                else
                {
                    dwReturn = E_FAIL;
                }
            }
            else if(pACE->GetACEType() == ACCESS_DENIED_OBJECT_ACE_TYPE)
            {
                if(t_pAdvApi32 != NULL)
                {
                    // Call the new function AddAccessDeniedObjectAce...
                    CSid sid;
                    pACE->GetSID(sid);
                    BOOL fRetval = FALSE;
                    GUID guidObjType, guidInhObjType;
                    GUID *pguidObjType = NULL;
                    GUID *pguidInhObjType = NULL;

                    if(pACE->GetObjType(guidObjType)) pguidObjType = &guidObjType;
                    if(pACE->GetInhObjType(guidInhObjType)) pguidInhObjType = &guidInhObjType;
                    if(!t_pAdvApi32->AddAccessDeniedObjectAce(pACL,
                                                                ACL_REVISION_DS,
                                                                pACE->GetACEFlags(),
                                                                pACE->GetAccessMask(),
                                                                pguidObjType,
                                                                pguidInhObjType,
                                                                sid.GetPSid(),
                                                                &fRetval))
                    {
                        dwReturn = ERROR_PROC_NOT_FOUND;
                    }
                    else // fn exists in dll
                    {
                        if(!fRetval)
                        {
                            dwReturn = ::GetLastError();
                        }
                    }
                }
                else
                {
                    dwReturn = E_FAIL;
                }
            }
            else if(pACE->GetACEType() == SYSTEM_AUDIT_OBJECT_ACE_TYPE)
            {
                if(t_pAdvApi32 != NULL)
                {
                    // Call the new function AddAccessDeniedObjectAce...
                    CSid sid;
                    pACE->GetSID(sid);
                    BOOL fRetval = FALSE;
                    if(!t_pAdvApi32->AddAuditAccessObjectAce(pACL,
                                                                ACL_REVISION_DS,
                                                                pACE->GetACEFlags(),
                                                                pACE->GetAccessMask(),
                                                                NULL,
                                                                NULL,
                                                                sid.GetPSid(),
                                                                FALSE,  // we pick this up through the third argument
                                                                FALSE,  // we pick this up through the third argument
                                                                &fRetval))
                    {
                        if(!fRetval)
                        {
                            dwReturn = ::GetLastError();
                        }
                        else
                        {
                            dwReturn = ERROR_PROC_NOT_FOUND;
                        }
                    }
                }
                else
                {
                    dwReturn = E_FAIL;
                }
            }
            else
#endif
            {
                // For Each ACE we enum, allocate a Win32 ACE, and stick that bad boy at the
				// end of the Win32 ACL.

                if ( pACE->AllocateACE( &pAceHeader ) )
				{
					if ( !::AddAce( pACL, pACL->AclRevision, MAXDWORD, (void*) pAceHeader, pAceHeader->AceSize ) )
					{
						dwReturn = ::GetLastError();
					}

					// Cleanup the memory block
					pACE->FreeACE( pAceHeader );
				}
				else
				{
					dwReturn = ERROR_NOT_ENOUGH_MEMORY;
				}
            }
		}

		EndEnum( pos );
	}

#if NTONLY >= 5
    if(t_pAdvApi32 != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
        t_pAdvApi32 = NULL;
    }
#endif


	return dwReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:InitFromWin32ACL
//
//	Traverses a Win32ACL and copies ACEs into our list.
//
//	Inputs:
//				PACL		pACL - ACL to add ACEs to.
//				BYTE		bACEFilter - ACEs to filter on.
//              bool        fLookup - whether the sids should be
//                          resolved to their domain and name values.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	If bACEFilter is not ALL_ACE_TYPES, then we will only copy out
//	ACEs of the specified type.
//
///////////////////////////////////////////////////////////////////

DWORD CAccessEntryList::InitFromWin32ACL( PACL pWin32ACL, BYTE bACEFilter /* = ALL_ACE_TYPES */, bool fLookup /* = true */ )
{
	DWORD		dwError		=	0;
	ACE_HEADER*	pACEHeader	=	NULL;
	DWORD		dwAceIndex	=	0;
	BOOL		fGotACE		=	FALSE;
	DWORD		dwMask		=	0;
	PSID		psid		=	NULL;
    GUID       *pguidObjType = NULL;
    GUID       *pguidInhObjType = NULL;

	// Empty out
	Clear();

	// For each ACE we find, get the values necessary to initialize our
	// CAccessEntries
	do
	{
		fGotACE = ::GetAce( pWin32ACL, dwAceIndex, (LPVOID*) &pACEHeader );

		if ( fGotACE )
		{
			switch ( pACEHeader->AceType )
			{
				case ACCESS_ALLOWED_ACE_TYPE:
				{
					ACCESS_ALLOWED_ACE*	pACE = (ACCESS_ALLOWED_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;

				case ACCESS_DENIED_ACE_TYPE:
				{
					ACCESS_DENIED_ACE*	pACE = (ACCESS_DENIED_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;

				case SYSTEM_AUDIT_ACE_TYPE:
				{
					SYSTEM_AUDIT_ACE*	pACE = (SYSTEM_AUDIT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
				{
					ACCESS_ALLOWED_OBJECT_ACE*	pACE = (ACCESS_ALLOWED_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;
/********************************* type not yet supported under w2k ********************************************
                case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
				{
					ACCESS_ALLOWED_COMPOUND_ACE_TYPE*	pACE = (ACCESS_ALLOWED_COMPOUND_ACE_TYPE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;
***************************************************************************************************************/
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
				{
					ACCESS_DENIED_OBJECT_ACE*	pACE = (ACCESS_DENIED_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;

                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
				{
					SYSTEM_AUDIT_OBJECT_ACE*	pACE = (SYSTEM_AUDIT_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;

/********************************* type not yet supported under w2k ********************************************
                case SYSTEM_ALARM_ACE_TYPE:
				{
					SYSTEM_ALARM_ACE*	pACE = (SYSTEM_ALARM_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;
/********************************* type not yet supported under w2k ********************************************/

/********************************* type not yet supported under w2k ********************************************
                case SYSTEM_ALARM_OBJECT_ACE_TYPE:
				{
					SYSTEM_ALARM_OBJECT_ACE*	pACE = (SYSTEM_ALARM_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;
/********************************* type not yet supported under w2k ********************************************/

				default:
				{
					ASSERT_BREAK(0);	// BAD, we don't know what this is!
					dwError = ERROR_INVALID_PARAMETER;
				}
			}

			// We must have no errors, and the filter MUST accept all ACE Types
			// or the ACE Type must match the filter.

			if (	ERROR_SUCCESS == dwError
				&&	(	ALL_ACE_TYPES == bACEFilter
					||	bACEFilter == pACEHeader->AceType ) )
			{

				// We merge duplicate entries during initialization
				if ( !AppendNoDup(	psid,
									pACEHeader->AceType,
									pACEHeader->AceFlags,
									dwMask,
                                    pguidObjType,
                                    pguidInhObjType,
									true,              // Merge flag
                                    fLookup ) )	       // whether to resolve domain and name of sid
				{
					dwError = ERROR_NOT_ENOUGH_MEMORY;
				}

			}


		}	// IF fGot ACE

		// Get the next ACE
		++dwAceIndex;

	}
	while ( fGotACE && ERROR_SUCCESS == dwError );


	return dwError;
}


void CAccessEntryList::DumpAccessEntryList(LPCWSTR wstrFilename)
{
    Output(L"AccessEntryList contents follow...", wstrFilename);

    // Run through the list, outputting each...
    CAccessEntry*	pACE = NULL;
	ACLPOSITION		pos;

    if(BeginEnum(pos))
    {
        while((pACE = GetNext(pos)) != NULL)
        {
            pACE->DumpAccessEntry(wstrFilename);
        }
        EndEnum(pos);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\accessentrylist.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntryList.h - header file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CACCESSENTRYLIST_H__
#define __CACCESSENTRYLIST_H__

#include "AccessEntry.h"
#include "list"


//////////////////////////////////////////////////////////////////
//
//	Class: CAccessEntryList
//
//	Class to encapsulate Windows NT ACL data.  It basically
//	maintains a list of ACEs using an STL Linked List.  It provides
//	a series of public and protected functions to allow manipulation
//	of the list.  By keeping a large group of these functions
//	protected, we goofproof the class by not allowing public
//	users to manipulate our internal data.
//
//////////////////////////////////////////////////////////////////


// Used for front and end indeces

//#define	ACCESSENTRY_LIST_FRONT	(-1)
//#define	ACCESSENTRY_LIST_END	(-2)

// We will hide an ACLIter* as a DWORD
typedef	LPVOID	ACLPOSITION;

typedef std::list<CAccessEntry*>::iterator ACLIter;

// FOR ACE Filtering when Initializing from a PACL.  This value
// means ALL_ACE_TYPES

#define ALL_ACE_TYPES	0xFF

class CAccessEntryList
{
	// Constructors and destructor
	public:
		CAccessEntryList();
		CAccessEntryList( PACL pWin32ACL, bool fLookup = true);
		~CAccessEntryList( void );

		// The only public functions available allow enumeration
		// of entries, and emptying the list.

		bool BeginEnum( ACLPOSITION& pos );
		bool GetNext( ACLPOSITION& pos, CAccessEntry& ACE );
		void EndEnum( ACLPOSITION& pos );
		DWORD NumEntries( void );
		bool IsEmpty( void );
		void Clear( void );
		bool GetAt( DWORD nIndex, CAccessEntry& ace );

		// ACE Location helpers
		virtual bool Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
		virtual bool Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );

		// Win32 ACL helpers
		BOOL CalculateWin32ACLSize( LPDWORD pdwACLSize );
		DWORD FillWin32ACL( PACL pACL );
		DWORD InitFromWin32ACL( PACL pWin32ACL, BYTE bACEFilter = ALL_ACE_TYPES, bool fLookup = true);

        void DumpAccessEntryList(LPCWSTR wstrFilename = NULL);

//	protected:

		// Only derived classes have access to modify our actual lists.
		void Add( CAccessEntry* pACE );
		void Append( CAccessEntry* pACE );
		ACLIter Find( CAccessEntry* pACE );
		CAccessEntry* Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, bool fLookup = true );
		CAccessEntry* Find( const CAccessEntry& ace );
		void Remove( CAccessEntry* pACE );
		bool SetAt( DWORD dwIndex, const CAccessEntry& ace );
		bool RemoveAt( DWORD dwIndex );

		// These two functions allow us to Add an entry either overwriting or merging
		// the access mask of a preexisting entry.

		bool AddNoDup( PSID psid, 
                       BYTE bACEType, 
                       BYTE bACEFlags, 
                       DWORD dwMask, 
                       GUID *pguidObjGuid, 
                       GUID *pguidInhObjGuid, 
                       bool fMerge = false );

		bool AppendNoDup( PSID psid, 
                          BYTE bACEType, 
                          BYTE bACEFlags, 
                          DWORD dwMask, 
                          GUID *pguidObjGuid, 
                          GUID *pguidInhObjGuid, 
                          bool fMerge = false );


        bool AppendNoDup( PSID psid, 
                          BYTE bACEType, 
                          BYTE bACEFlags, 
                          DWORD dwMask, 
                          GUID *pguidObjGuid, 
                          GUID *pguidInhObjGuid, 
                          bool fMerge,
                          bool fLookup);


		// The copy protection is protected so derived classes can
		// implement a typesafe equals operator
		bool Copy( CAccessEntryList& ACL );
		bool AppendList( CAccessEntryList& ACL );

		// For NT 5, we will need to handle ACEs separately, so use these
		// functions to copy lists inherited/noninherited ACEs into another list.
		bool CopyACEs( CAccessEntryList& ACL, BYTE bACEType );
		bool CopyInheritedACEs( CAccessEntryList& ACL, BYTE bACEType );
        // and use this one to copy lists allowed/denied into another list.
        bool CopyAllowedACEs(CAccessEntryList& ACL);
        bool CopyDeniedACEs(CAccessEntryList& ACL);
        bool CopyByACEType(CAccessEntryList& ACL, BYTE bACEType, bool fInherited);

		// Only let derived classes work with actual pointer values.  This way
		// public users can't 86 our internal memory.
		CAccessEntry* GetNext( ACLPOSITION& pos );


	private:

		std::list<CAccessEntry*>	m_ACL;

};

inline DWORD CAccessEntryList::NumEntries( void )
{
	return m_ACL.size();
}

inline bool CAccessEntryList::IsEmpty( void )
{
	return (m_ACL.empty() ? true : false);
}

#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\accessrights.h ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/







//=================================================================

//

// AccessRights.CPP -- Base class for obtaining effective access

//                      rights.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/99    a-kevhu         Created
//
//=================================================================
#ifndef _CACCESSRIGHTS_H_
#define _CACCESSRIGHTS_H_

#ifdef NTONLY

#define AR_GENERIC_FAILURE  0x00010001
#define AR_BAD_SID          0x00010002
#define AR_ACL_EMPTY        0x00010003
#define AR_BAD_ACL          0x00010004

#define AR_RET_CODE         DWORD
#define USER                void*
#define USER_SPECIFIER      short

#define USER_IS_PSID        0
#define USER_IS_HANDLE      1


class CAccessRights
{
    public:

        // Constructors and destructor...
        CAccessRights(bool fUseCurThrTok = false);
        CAccessRights(const USER user, USER_SPECIFIER usp);
        CAccessRights(const USER psid, const PACL pacl, USER_SPECIFIER usp);
        CAccessRights(const PACL pacl, bool fUseCurThrTok = false);

        //CAccessRights(const CAccessRights &RAccessRights);

        ~CAccessRights();
        
        // Utility functions...
        bool SetUserToThisThread();
        bool SetUser(const USER user, USER_SPECIFIER usp);

        bool SetAcl(const PACL pacl);

        AR_RET_CODE GetEffectiveAccessRights(PACCESS_MASK pAccessMask); 
        
        DWORD GetError() { return m_dwError; }

        bool GetCSid(CSid &csid, bool fResolve = false);


    protected:
        DWORD m_dwError;
        
    private:

        bool InitTrustee(bool fInitFromCurrentThread, const HANDLE hToken = NULL);
        bool InitSidFromToken(const HANDLE hThreadToken);
        AR_RET_CODE FillEmptyPACL(PACL *paclNew);

        TRUSTEE m_trustee;
        CSid m_csid;
        CAccessEntryList m_ael;

};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\accessrights.cpp ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/





//=================================================================

//

// AccessRights.CPP -- Base class for obtaining effective access

//                      rights.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/99    a-kevhu         Created
//
//=================================================================


#include "precomp.h"


#ifdef NTONLY


#include <assertbreak.h>
#include "AdvApi32Api.h"
#include "accctrl.h"
#include "sid.h"
#include "AccessEntryList.h"
#include "AccessRights.h"

//==============================================================================
// CONSTRUCTORS AND DESTRUCTORS
//==============================================================================
// Default initialization...
CAccessRights::CAccessRights(bool fUseCurThrTok /* = false */)
: m_dwError(ERROR_SUCCESS)
{
    if(fUseCurThrTok)
    {
        // Initialize using the current thread token...
        InitTrustee(true);
    }
}

// Initialization specifying user only. Sid domain/account
// not resolved.  ACL uninitialized.
CAccessRights::CAccessRights(const USER user, USER_SPECIFIER usp)
:  m_dwError(ERROR_SUCCESS)
{
    if(usp == USER_IS_PSID)
    {
        m_csid = CSid((PSID)user, NULL, false);
        InitTrustee(false);
    }
    else if(usp == USER_IS_HANDLE)
    {
        ASSERT_BREAK(user != NULL);
        InitTrustee(false, (HANDLE)user);
    }
}

// Initialization of user and acl.  Sid domain/account
// not resolved. ACL initialized.
CAccessRights::CAccessRights(const USER user, const PACL pacl, USER_SPECIFIER usp)
: m_ael(pacl, false),
  m_dwError(ERROR_SUCCESS)
{
    if(usp == USER_IS_PSID)
    {
        m_csid = CSid((PSID)user, NULL, false);
        InitTrustee(false);
    }
    else if(usp == USER_IS_HANDLE)
    {
        ASSERT_BREAK(user != NULL);
        InitTrustee(false, (HANDLE)user);
    }
}


// Initialization of acl only.  ACL Sids not resolved.
CAccessRights::CAccessRights(const PACL pacl, bool fUseCurThrTok /* = false */)
: m_ael(pacl, false),
  m_dwError(ERROR_SUCCESS)
{
    if(fUseCurThrTok)
    {
        // Initialize using the current thread token...
        InitTrustee(true);
    }
}

// Copy constructor
/*  Not complete yet
CAccessRights::CAccessRights(const CAccessRights &RAccessRights)
{
    // Copy members.  We may or may not have either.
    if(RAccessRights.m_csid.IsValid() && RAccessRights.m_csid.IsOK())
    {
        m_csid = RAccessRights.m_csid;
    }
    m_ael.Clear();
    if(!RAccessRights.m_ael.IsEmpty())
    {
        // The best way to do this, to guarentee that the sids are not
        // resolved into domain/name, is to gat a PACL, then reinitialize
        // ourselves from it.
        PACL paclNew = NULL;
        try
        {
            if(RAccessRights.FillEmptyPACL(paclNew))
            {
                if(paclNew != NULL)
                {
                    if(!m_ael.InitFromWin32ACL(paclNew, ALL_ACE_TYPES, false))
                    {
                        // If something went wrong, clean
                        // up after ourselves.
                        m_ael.Clear();
                    }
                    delete paclNew;
                    paclNew = NULL;
                }
            }
        }
        catch(...)
        {
            if(paclNew != NULL)
            {
                delete paclNew;
                paclNew = NULL;
            }
            throw;
        }
    }
}
*/

// Destructor - members destruct themselves.
CAccessRights::~CAccessRights()
{
}


//==============================================================================
// UTILITY FUNCTIONS
//==============================================================================

AR_RET_CODE CAccessRights::GetEffectiveAccessRights(PACCESS_MASK pAccessMask)
{
    DWORD dwRet = AR_GENERIC_FAILURE;
    CAdvApi32Api *pAdvApi32 = NULL;
    PACL pacl = NULL;
    try
    {
        pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
        if(pAdvApi32 != NULL)
        {
            if((dwRet = FillEmptyPACL(&pacl)) == ERROR_SUCCESS)
            {
                ASSERT_BREAK(pacl != NULL);

                if(pacl != NULL)
                {
                    if(m_csid.IsValid() && m_csid.IsOK())
                    {
                        pAdvApi32->GetEffectiveRightsFromAclW(pacl,
                                                              &m_trustee,
                                                              pAccessMask,
                                                              &dwRet);
                    }
                    else
                    {
                        dwRet = AR_BAD_SID;
                    }
                    delete pacl;
                    pacl = NULL;
                }
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
            pAdvApi32 = NULL;
        }
    }
    catch(...)
    {
        if(pacl != NULL)
        {
            delete pacl;
            pacl = NULL;
        }
        if(pAdvApi32 != NULL)
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
            pAdvApi32 = NULL;
        }
        throw;
    }
    return dwRet;
}

bool CAccessRights::InitTrustee(bool fInitFromCurrentThread, const HANDLE hToken)
{
    bool fRet = false;

    // The main thing done here is a sid is obtained and the TRUSTEE struct
    // filled in.

    if(fInitFromCurrentThread)
    {
        // Get the sid of the user/group of the current thread...
        SmartCloseHandle hThreadToken;
        if(::OpenThreadToken(::GetCurrentThread(), TOKEN_READ, FALSE, &hThreadToken))
        {
            InitSidFromToken(hThreadToken);
        }
    }
    else
    {
        // If we were given a hToken, use it instead...
        if(hToken != NULL)
        {
            InitSidFromToken(hToken);
        }
    }

    // We should now have a valid sid in our member CSid (either from the
    // InitSidFromToken calls or from construction).
    // Now we need to initialize the TRUSTEE object.  Check again that our sid
    // is in good standing...
    if(m_csid.IsValid() && m_csid.IsOK())
    {
        m_trustee.pMultipleTrustee = NULL;
        m_trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        m_trustee.TrusteeForm = TRUSTEE_IS_SID;
        m_trustee.TrusteeType = TRUSTEE_IS_UNKNOWN; // we could be operating
                                                    // on behalf of a user,
                                                    // group, well-known-group,
                                                    // who knows.

        m_trustee.ptstrName = (LPWSTR)m_csid.GetPSid();
        fRet = true;
    }
    else
    {
        m_dwError = AR_BAD_SID;
    }
    return fRet;
}


bool CAccessRights::InitSidFromToken(const HANDLE hThreadToken)
{
    bool fRet = false;

    if(hThreadToken != NULL)
    {
        DWORD dwLength = 0L;
        DWORD dwReqLength = 0L;
        PSID psid = NULL;
        LPVOID pBuff = NULL;
        if(!::GetTokenInformation(hThreadToken, TokenUser, NULL, 0, &dwReqLength))
        {
            if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // Allocate a buffer to hold the token info...
                try
                {
                    pBuff = new BYTE[dwReqLength];
                    if(pBuff != NULL)
                    {
                        dwLength = dwReqLength;
                        // Now that we have the right size buffer, call again...
                        if(::GetTokenInformation(hThreadToken,
                                                 TokenUser,
                                                 pBuff,
                                                 dwLength,
                                                 &dwReqLength))
                        {
                            if(pBuff != NULL)
                            {
                                TOKEN_USER *pTokUsr = (TOKEN_USER*)pBuff;
                                psid = pTokUsr->User.Sid;

                                ASSERT_BREAK((psid != NULL) && ::IsValidSid(psid));

	                            if((psid != NULL) && ::IsValidSid(psid))
	                            {
                                    m_csid = CSid(psid, NULL, false);
                                    fRet = true;
                                }
                                else
                                {
                                    m_dwError = AR_BAD_SID;
                                }
                            }
                        }
                        delete pBuff;
                        pBuff = NULL;
                    }
                }
                catch(...)
                {
                    if(pBuff != NULL)
                    {
                        delete pBuff;
                        pBuff = NULL;
                    }
                    throw;
                }
            }
        }
    }
    return fRet;
}


// Resets the user to the user to whom the current thread token belongs.
bool CAccessRights::SetUserToThisThread()
{
    return InitTrustee(true, NULL);
}

// Resets the user to the user specified by psid or handle
bool CAccessRights::SetUser(const USER user, USER_SPECIFIER usp)
{
    bool fRet = false;
    if(usp == USER_IS_PSID)
    {
        CSid csidTemp((PSID)user);
        if(csidTemp.IsValid() && csidTemp.IsOK())
        {
            m_csid = csidTemp;
            fRet = true;
        }
    }
    else if(usp == USER_IS_HANDLE)
    {
        fRet = InitSidFromToken((HANDLE)user);
    }
    return fRet;
}


// Resets the acl to the passed in PACL
bool CAccessRights::SetAcl(const PACL pacl)
{
    bool fRet = false;
    if(pacl != NULL)
    {
        m_ael.Clear();
        if(m_ael.InitFromWin32ACL(pacl, ALL_ACE_TYPES, false) == ERROR_SUCCESS)
        {
            fRet = true;
        }
    }
    return fRet;
}

// Gets us a filled out PACL, which must be freed by the caller, using delete.
AR_RET_CODE CAccessRights::FillEmptyPACL(PACL *paclOut)
{
    DWORD dwRet = AR_GENERIC_FAILURE;
    if(paclOut != NULL)
    {
        // The best way to do this, to guarentee that the sids are not
        // resolved into domain/name, is to get a PACL, then reinitialize
        // ourselves from it.
        DWORD dwAclSize = 0L;
        if(m_ael.NumEntries() > 0)
        {
            if(m_ael.CalculateWin32ACLSize(&dwAclSize))
            {
                if(dwAclSize > sizeof(ACL))
                {
                    PACL paclTemp = NULL;
                    try
                    {
                        paclTemp = (PACL) new BYTE[dwAclSize];
                        if(paclTemp != NULL)
                        {
                            ::InitializeAcl(paclTemp, dwAclSize, ACL_REVISION);
                            if((dwRet = m_ael.FillWin32ACL(paclTemp)) == ERROR_SUCCESS)
                            {
                                *paclOut = paclTemp;
                                dwRet = ERROR_SUCCESS;
                            }
                        }
                    }
                    catch(...)
                    {
                        if(paclTemp != NULL)
                        {
                            delete paclTemp;
                            paclTemp = NULL;
                        }
                        throw;
                    }
                }
                else
                {
                    dwRet = AR_ACL_EMPTY;
                }
            }
            else
            {
                dwRet = AR_BAD_ACL;
            }
        }
        else
        {
            dwRet = AR_ACL_EMPTY;
        }
    }
    return dwRet;
}


bool CAccessRights::GetCSid(CSid &csid, bool fResolve)
{
    bool fRet = false;
    if(m_dwError == ERROR_SUCCESS)
    {
        if(m_csid.IsValid() && m_csid.IsOK())
        {
            if(fResolve)
            {
                // Need to create a new one since ours doesn't
                // have account or domain name resolved.
                CSid csidTemp(m_csid.GetPSid());
                if(csidTemp.IsValid() && csidTemp.IsOK())
                {
                    csid = csidTemp;
                    fRet = true;
                }
            }
            else
            {
                csid = m_csid;
                fRet = true;
            }
        }
    }
    return fRet;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\advapi32api.cpp ===
//=================================================================

//

// AdvApi32Api.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "AdvApi32Api.h"
#include "DllWrapperCreatorReg.h"

// {15E4C152-D051-11d2-911F-0060081A46FD}
static const GUID g_guidAdvApi32Api =
{0x15e4c152, 0xd051, 0x11d2, {0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrAdvApi32[] = _T("ADVAPI32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CAdvApi32Api, &g_guidAdvApi32Api, g_tstrAdvApi32> MyRegisteredAdvApi32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CAdvApi32Api::CAdvApi32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnLsaEnumerateTrustedDomains(NULL),
   m_pfnLsaQueryInformationPolicy(NULL),
   m_pfnLsaNtStatusToWinError(NULL),
   m_pfnLsaFreeMemory(NULL),
   m_pfnLsaOpenPolicy(NULL),
   m_pfnLsaClose(NULL),
   m_pfnSetNamedSecurityInfoW(NULL),
   m_pfnGetNamedSecurityInfoW(NULL),
   m_pfnQueryServiceStatusEx(NULL),
   m_pfnDuplicateTokenEx(NULL),
   m_pfnSetSecurityDescriptorControl(NULL),
   m_pfnConvertToAutoInheritPrivateObjectSecurity(NULL),
   m_pfnDestroyPrivateObjectSecurity(NULL),
   m_pfnSetNamedSecurityInfoEx(NULL),
   m_pfnGetExplicitEntriesFromAcl(NULL),
   m_pfnCheckTokenMembership(NULL),
   m_pfnAddAccessAllowedObjectAce(NULL),
   m_pfnAddAccessDeniedObjectAce(NULL),
   m_pfnAddAuditAccessObjectAce(NULL),
   m_pfnGetEffectiveRightsFromAclW(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CAdvApi32Api::~CAdvApi32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CAdvApi32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnLsaEnumerateTrustedDomains = (PFN_LSA_ENUMERATE_TRUSTED_DOMAINS)
                                  GetProcAddress("LsaEnumerateTrustedDomains");
        m_pfnLsaQueryInformationPolicy = (PFN_LSA_QUERY_INFORMATION_POLICY)
                                   GetProcAddress("LsaQueryInformationPolicy");
        m_pfnLsaNtStatusToWinError = (PFN_LSA_NT_STATUS_TO_WIN_ERROR)
                                       GetProcAddress("LsaNtStatusToWinError");
        m_pfnLsaFreeMemory = (PFN_LSA_FREE_MEMORY)
                                               GetProcAddress("LsaFreeMemory");
        m_pfnLsaOpenPolicy = (PFN_LSA_OPEN_POLICY)
                                               GetProcAddress("LsaOpenPolicy");
        m_pfnLsaClose = (PFN_LSA_CLOSE) GetProcAddress("LsaClose");

#ifdef NTONLY
        // These functions are only on NT 4 and later
        m_pfnQueryServiceStatusEx = (PFN_QUERY_SERVICE_STATUS_EX)
                                        GetProcAddress("QueryServiceStatusEx");

        m_pfnDuplicateTokenEx = (PFN_DUPLICATE_TOKEN_EX)
                                            GetProcAddress("DuplicateTokenEx");
        // These functions is only on NT 5 or later only
        m_pfnSetSecurityDescriptorControl = (PFN_SET_SECURITY_DESCRIPTOR_CONTROL)
                                GetProcAddress("SetSecurityDescriptorControl");

        m_pfnConvertToAutoInheritPrivateObjectSecurity = (PFN_CONVERT_TO_AUTO_INHERIT_PRIVATE_OBJECT_SECURITY)
                                GetProcAddress("ConvertToAutoInheritPrivateObjectSecurity");

        m_pfnDestroyPrivateObjectSecurity = (PFN_DESTROY_PRIVATE_OBJECT_SECURITY)
                                GetProcAddress("DestroyPrivateObjectSecurity");

		m_pfnCheckTokenMembership = (PFN_CHECK_TOKEN_MEMBERSHIP)
								GetProcAddress("CheckTokenMembership");

        m_pfnAddAccessAllowedObjectAce = (PFN_ADD_ACCESS_ALLOWED_OBJECT_ACE)
                                GetProcAddress("AddAccessAllowedObjectAce");

        m_pfnAddAccessDeniedObjectAce = (PFN_ADD_ACCESS_DENIED_OBJECT_ACE)
                                GetProcAddress("AddAccessDeniedObjectAce");

        m_pfnAddAuditAccessObjectAce = (PFN_ADD_AUDIT_ACCESS_OBJECT_ACE)
                                GetProcAddress("AddAuditAccessObjectAce");

#if ((defined UNICODE) || (defined _UNICODE))
        m_pfnSetNamedSecurityInfoW = (PFN_SET_NAMED_SECURITY_INFO_W)
                                       GetProcAddress("SetNamedSecurityInfoW");

        m_pfnGetNamedSecurityInfoW = (PFN_GET_NAMED_SECURITY_INFO_W)
                                       GetProcAddress("GetNamedSecurityInfoW");

        m_pfnSetNamedSecurityInfoEx = (PFN_SET_NAMED_SECURITY_INFO_EX)
                                GetProcAddress("SetNamedSecurityInfoExW");

        m_pfnGetExplicitEntriesFromAcl = (PFN_GET_EXPLICIT_ENTRIES_FROM_ACL)
                                GetProcAddress("GetExplicitEntriesFromAclW");

        m_pfnGetEffectiveRightsFromAclW = (PFN_GET_EFFECTIVE_RIGHTS_FROM_ACL_W)
                                GetProcAddress("GetEffectiveRightsFromAclW");
#else
        m_pfnSetNamedSecurityInfoEx = (PFN_SET_NAMED_SECURITY_INFO_EX)
                                GetProcAddress("SetNamedSecurityInfoExA");

        m_pfnGetExplicitEntriesFromAcl = (PFN_GET_EXPLICIT_ENTRIES_FROM_ACL)
                                GetProcAddress("GetExplicitEntriesFromAclA");
#endif

#endif


        // These functions are considered essential to all versions of this
        // dll; therefore, if any are not found, return false.
        if(m_pfnLsaEnumerateTrustedDomains == NULL  ||
           m_pfnLsaQueryInformationPolicy == NULL ||
           m_pfnLsaNtStatusToWinError == NULL ||
           m_pfnLsaFreeMemory == NULL ||
           m_pfnLsaOpenPolicy == NULL ||
           m_pfnLsaClose == NULL)
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in AdvApi32Api");
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping AdvApi32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
NTSTATUS CAdvApi32Api::LsaEnumerateTrustedDomains
(
    LSA_HANDLE a_PolicyHandle,
    PLSA_ENUMERATION_HANDLE a_EnumerationContext,
    PVOID *a_Buffer,
    ULONG a_PreferedMaximumLength,
    PULONG a_CountReturned
)
{
    return m_pfnLsaEnumerateTrustedDomains(a_PolicyHandle, a_EnumerationContext,
                                           a_Buffer, a_PreferedMaximumLength,
                                           a_CountReturned);
}

NTSTATUS CAdvApi32Api::LsaQueryInformationPolicy
(
    LSA_HANDLE a_PolicyHandle,
    POLICY_INFORMATION_CLASS a_InformationClass,
    PVOID *a_Buffer
)
{
    return m_pfnLsaQueryInformationPolicy(a_PolicyHandle, a_InformationClass,
                                          a_Buffer);
}

NTSTATUS CAdvApi32Api::LsaNtStatusToWinError
(
    NTSTATUS a_Status
)
{
    return m_pfnLsaNtStatusToWinError(a_Status);
}

NTSTATUS CAdvApi32Api::LsaFreeMemory
(
    PVOID a_Buffer
)
{
    return m_pfnLsaFreeMemory(a_Buffer);
}

NTSTATUS CAdvApi32Api::LsaOpenPolicy
(
    PLSA_UNICODE_STRING a_SystemName,
    PLSA_OBJECT_ATTRIBUTES a_ObjectAttributes,
    ACCESS_MASK a_DesiredAccess,
    PLSA_HANDLE a_PolicyHandle
)
{
    return m_pfnLsaOpenPolicy(a_SystemName, a_ObjectAttributes,
                              a_DesiredAccess, a_PolicyHandle);
}

NTSTATUS CAdvApi32Api::LsaClose
(
    LSA_HANDLE a_ObjectHandle
)
{
    return m_pfnLsaClose(a_ObjectHandle);
}

bool CAdvApi32Api::SetNamedSecurityInfoW
(
    IN LPWSTR                a_pObjectName,
    IN SE_OBJECT_TYPE        a_ObjectType,
    IN SECURITY_INFORMATION  a_SecurityInfo,
    IN PSID                  a_psidOowner,
    IN PSID                  a_psidGroup,
    IN PACL                  a_pDacl,
    IN PACL                  a_pSacl,
    DWORD                   *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnSetNamedSecurityInfoW != NULL)
    {
        DWORD t_dwTemp = m_pfnSetNamedSecurityInfoW(a_pObjectName,
                                     a_ObjectType,
                                     a_SecurityInfo,
                                     a_psidOowner,
                                     a_psidGroup,
                                     a_pDacl,
                                     a_pSacl);

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::GetNamedSecurityInfoW
(
	LPWSTR                 a_pObjectName,
    SE_OBJECT_TYPE         a_ObjectType,
    SECURITY_INFORMATION   a_SecurityInfo,
    PSID                  *a_ppsidOowner,
    PSID                  *a_ppsidGroup,
    PACL                  *a_ppDacl,
    PACL                  *a_ppSacl,
    PSECURITY_DESCRIPTOR  *a_ppSecurityDescriptor,
    DWORD                 *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnGetNamedSecurityInfoW != NULL)
    {
        DWORD t_dwTemp;
        {
            t_dwTemp = m_pfnGetNamedSecurityInfoW(a_pObjectName,
                                                  a_ObjectType,
                                                  a_SecurityInfo,
                                                  a_ppsidOowner,
                                                  a_ppsidGroup,
                                                  a_ppDacl,
                                                  a_ppSacl,
                                                  a_ppSecurityDescriptor);
        }

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}


bool CAdvApi32Api::QueryServiceStatusEx
(
    SC_HANDLE       a_hService,
    SC_STATUS_TYPE  a_InfoLevel,
    LPBYTE          a_lpBuffer,
    DWORD           a_cbBufSize,
    LPDWORD         a_pcbBytesNeeded,
    BOOL           *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnQueryServiceStatusEx != NULL)
    {
        BOOL t_fTemp = m_pfnQueryServiceStatusEx(a_hService,
                                     a_InfoLevel,
                                     a_lpBuffer,
                                     a_cbBufSize,
                                     a_pcbBytesNeeded);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::DuplicateTokenEx
(
    HANDLE a_h,					        // handle to token to duplicate
    DWORD a_dw,							// access rights of new token
    LPSECURITY_ATTRIBUTES a_lpsa,		// security attributes of the new token
    SECURITY_IMPERSONATION_LEVEL a_sil,	// impersonation level of new token
    TOKEN_TYPE a_tt,					// primary or impersonation token
    PHANDLE a_ph,                       // handle to duplicated token
    BOOL *a_fRetval                      // encapsulated function return value
)
{
    bool t_fExists = false;
    if(m_pfnDuplicateTokenEx != NULL)
    {
        BOOL t_fTemp = m_pfnDuplicateTokenEx(a_h, a_dw, a_lpsa,
                                             a_sil, a_tt, a_ph);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}


bool CAdvApi32Api::SetSecurityDescriptorControl
(
    PSECURITY_DESCRIPTOR a_pSecurityDescriptor,
    SECURITY_DESCRIPTOR_CONTROL a_ControlBitsOfInterest,
    SECURITY_DESCRIPTOR_CONTROL a_ControlBitsToSet,
    BOOL *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnSetSecurityDescriptorControl != NULL)
    {
        BOOL t_fTemp = m_pfnSetSecurityDescriptorControl(a_pSecurityDescriptor,
                                                         a_ControlBitsOfInterest,
                                                         a_ControlBitsToSet);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::ConvertToAutoInheritPrivateObjectSecurity
(
    PSECURITY_DESCRIPTOR a_ParentDescriptor,
    PSECURITY_DESCRIPTOR a_CurrentSecurityDescriptor,
    PSECURITY_DESCRIPTOR *a_NewSecurityDescriptor,
    GUID *a_ObjectType,
    BOOLEAN a_IsDirectoryObject,
    PGENERIC_MAPPING a_GenericMapping,
    BOOL *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnConvertToAutoInheritPrivateObjectSecurity != NULL)
    {
        BOOL t_fTemp = m_pfnConvertToAutoInheritPrivateObjectSecurity(a_ParentDescriptor,
                                                         a_CurrentSecurityDescriptor,
                                                         a_NewSecurityDescriptor,
                                                         a_ObjectType,
                                                         a_IsDirectoryObject,
                                                         a_GenericMapping);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::DestroyPrivateObjectSecurity
(
    PSECURITY_DESCRIPTOR *a_ObjectDescriptor,
    BOOL *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnDestroyPrivateObjectSecurity != NULL)
    {
        BOOL t_fTemp = m_pfnDestroyPrivateObjectSecurity(a_ObjectDescriptor);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::SetNamedSecurityInfoEx
(
    LPCTSTR              a_lpObject,
    SE_OBJECT_TYPE       a_ObjectType,
    SECURITY_INFORMATION a_SecurityInfo,
    LPCTSTR              a_lpProvider,
    PACTRL_ACCESS        a_pAccessList,
    PACTRL_AUDIT         a_pAuditList,
    LPTSTR               a_lpOwner,
    LPTSTR               a_lpGroup,
    PACTRL_OVERLAPPED    a_pOverlapped,
    DWORD               *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnSetNamedSecurityInfoEx != NULL)
    {
        DWORD t_dwTemp = m_pfnSetNamedSecurityInfoEx(a_lpObject,a_ObjectType,
                                                     a_SecurityInfo,a_lpProvider,
                                                     a_pAccessList,a_pAuditList,
                                                     a_lpOwner,a_lpGroup,
                                                     a_pOverlapped);

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::GetExplicitEntriesFromAcl
(
    PACL                  a_pacl,
    PULONG                a_pcCountOfExplicitEntries,
    PEXPLICIT_ACCESS     *a_pListOfExplicitEntries,
    DWORD                *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnGetExplicitEntriesFromAcl != NULL)
    {
        DWORD t_dwTemp = m_pfnGetExplicitEntriesFromAcl(a_pacl,
                                                        a_pcCountOfExplicitEntries,
                                                        a_pListOfExplicitEntries);

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::CheckTokenMembership
(
		HANDLE a_hTokenHandle OPTIONAL,
		PSID a_pSidToCheck,
		PBOOL a_pfIsMember,
		BOOL *a_fRetval
)
{
	bool t_fExists = false;
	if(m_pfnCheckTokenMembership)
	{
		t_fExists = true;
		BOOL t_fRet = m_pfnCheckTokenMembership(a_hTokenHandle,
		                                        a_pSidToCheck,
		                                        a_pfIsMember);
		if(a_fRetval)
		{
			*a_fRetval = t_fRet;
		}
	}
	return t_fExists ;
}

bool CAdvApi32Api::AddAccessAllowedObjectAce
(
    PACL  a_pAcl,
    DWORD a_dwAceRevision,
    DWORD a_AceFlags,
    DWORD a_AccessMask,
    GUID  *a_ObjectTypeGuid,
    GUID  *a_InheritedObjectTypeGuid,
    PSID  a_pSid,
    BOOL  *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnAddAccessAllowedObjectAce != NULL)
    {
        BOOL t_fTemp = m_pfnAddAccessAllowedObjectAce(a_pAcl,
                                                      a_dwAceRevision,
                                                      a_AceFlags,
                                                      a_AccessMask,
                                                      a_ObjectTypeGuid,
                                                      a_InheritedObjectTypeGuid,
                                                      a_pSid);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::AddAccessDeniedObjectAce
(
    PACL  a_pAcl,
    DWORD a_dwAceRevision,
    DWORD a_AceFlags,
    DWORD a_AccessMask,
    GUID  *a_ObjectTypeGuid,
    GUID  *a_InheritedObjectTypeGuid,
    PSID  a_pSid,
    BOOL  *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnAddAccessDeniedObjectAce != NULL)
    {
        BOOL t_fTemp = m_pfnAddAccessDeniedObjectAce(a_pAcl,
                                                     a_dwAceRevision,
                                                     a_AceFlags,
                                                     a_AccessMask,
                                                     a_ObjectTypeGuid,
                                                     a_InheritedObjectTypeGuid,
                                                     a_pSid);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::AddAuditAccessObjectAce
(
    PACL  a_pAcl,
    DWORD a_dwAceRevision,
    DWORD a_AceFlags,
    DWORD a_AccessMask,
    GUID  *a_ObjectTypeGuid,
    GUID  *a_InheritedObjectTypeGuid,
    PSID  a_pSid,
    BOOL  a_bAuditSuccess,
    BOOL  a_bAuditFailure,
    BOOL  *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnAddAuditAccessObjectAce != NULL)
    {
        BOOL t_fTemp = m_pfnAddAuditAccessObjectAce(a_pAcl,
                                                    a_dwAceRevision,
                                                    a_AceFlags,
                                                    a_AccessMask,
                                                    a_ObjectTypeGuid,
                                                    a_InheritedObjectTypeGuid,
                                                    a_pSid,
                                                    a_bAuditSuccess,
                                                    a_bAuditFailure);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::GetEffectiveRightsFromAclW
(
    PACL          a_pacl,
    PTRUSTEE_W    a_pTrustee,
    PACCESS_MASK  a_pAccessRights,
    DWORD         *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnGetEffectiveRightsFromAclW != NULL)
    {
        DWORD t_dwTemp;
        {
            t_dwTemp = m_pfnGetEffectiveRightsFromAclW(a_pacl,
                                                       a_pTrustee,
                                                       a_pAccessRights);
        }

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\advapi32api.h ===
//=================================================================

//

// AdvApi32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_ADVAPI32API_H_
#define	_ADVAPI32API_H_



#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> 
#include <dsgetdc.h>
#include <aclapi.h>

#include "DllUtils.h"
/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidAdvApi32Api;
extern const TCHAR g_tstrAdvApi32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_ENUMERATE_TRUSTED_DOMAINS)
(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_QUERY_INFORMATION_POLICY)
(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_NT_STATUS_TO_WIN_ERROR)
(
    IN NTSTATUS Status
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_FREE_MEMORY)
(
    IN PVOID Buffer
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_OPEN_POLICY)
(
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_CLOSE)
(
    IN LSA_HANDLE ObjectHandle
);

typedef DWORD (WINAPI *PFN_SET_NAMED_SECURITY_INFO_W)
( 
    IN LPWSTR                pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOowner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
);

typedef DWORD (WINAPI *PFN_GET_NAMED_SECURITY_INFO_W)
(
	LPWSTR                 pObjectName,
    SE_OBJECT_TYPE         ObjectType,
    SECURITY_INFORMATION   SecurityInfo,
    PSID                  *ppsidOowner,
    PSID                  *ppsidGroup,
    PACL                  *ppDacl,
    PACL                  *ppSacl,
    PSECURITY_DESCRIPTOR  *ppSecurityDescriptor 
);

typedef BOOL (WINAPI *PFN_QUERY_SERVICE_STATUS_EX) 
(
    SC_HANDLE           hService,
    SC_STATUS_TYPE      InfoLevel,
    LPBYTE              lpBuffer,
    DWORD               cbBufSize,
    LPDWORD             pcbBytesNeeded
);

typedef BOOL  (WINAPI *PFN_DUPLICATE_TOKEN_EX ) 
(  
    HANDLE ,					        // handle to token to duplicate
    DWORD ,								// access rights of new token
    LPSECURITY_ATTRIBUTES ,				// security attributes of the new token
    SECURITY_IMPERSONATION_LEVEL ,		// impersonation level of new token
    TOKEN_TYPE ,						// primary or impersonation token
    PHANDLE                             // handle to duplicated token
);

typedef BOOL (WINAPI *PFN_SET_SECURITY_DESCRIPTOR_CONTROL)
(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
);

typedef BOOL (WINAPI *PFN_CONVERT_TO_AUTO_INHERIT_PRIVATE_OBJECT_SECURITY)
(
    IN PSECURITY_DESCRIPTOR ParentDescriptor,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
);

typedef BOOL (WINAPI *PFN_DESTROY_PRIVATE_OBJECT_SECURITY)
(
    IN OUT PSECURITY_DESCRIPTOR * ObjectDescriptor
);

typedef DWORD (WINAPI *PFN_SET_NAMED_SECURITY_INFO_EX)
(
    IN    LPCTSTR              lpObject,
    IN    SE_OBJECT_TYPE       ObjectType,
    IN    SECURITY_INFORMATION SecurityInfo,
    IN    LPCTSTR              lpProvider,
    IN    PACTRL_ACCESS        pAccessList,
    IN    PACTRL_AUDIT         pAuditList,
    IN    LPTSTR               lpOwner,
    IN    LPTSTR               lpGroup,
    IN    PACTRL_OVERLAPPED    pOverlapped
);

typedef DWORD (WINAPI *PFN_GET_EXPLICIT_ENTRIES_FROM_ACL)
(
    IN  PACL                  pacl,
    OUT PULONG                pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS    * pListOfExplicitEntries
);
						
typedef BOOL (APIENTRY *PFN_CHECK_TOKEN_MEMBERSHIP)
(  
    IN HANDLE					TokenHandle OPTIONAL,
    IN PSID						SidToCheck,
    OUT PBOOL					IsMember
);

typedef BOOL (WINAPI *PFN_ADD_ACCESS_ALLOWED_OBJECT_ACE)
(
    IN OUT PACL pAcl,
    IN DWORD dwAceRevision,
    IN DWORD AceFlags,
    IN DWORD AccessMask,
    IN GUID *ObjectTypeGuid,
    IN GUID *InheritedObjectTypeGuid,
    IN PSID pSid
);

typedef BOOL (WINAPI *PFN_ADD_ACCESS_DENIED_OBJECT_ACE)
(
    IN OUT PACL pAcl,
    IN DWORD dwAceRevision,
    IN DWORD AceFlags,
    IN DWORD AccessMask,
    IN GUID *ObjectTypeGuid,
    IN GUID *InheritedObjectTypeGuid,
    IN PSID pSid
);

typedef BOOL (WINAPI *PFN_ADD_AUDIT_ACCESS_OBJECT_ACE)
(
    IN OUT PACL pAcl,
    IN DWORD dwAceRevision,
    IN DWORD AceFlags,
    IN DWORD AccessMask,
    IN GUID *ObjectTypeGuid,
    IN GUID *InheritedObjectTypeGuid,
    IN PSID pSid,
    IN BOOL bAuditSuccess,
    IN BOOL bAuditFailure
);

typedef DWORD (WINAPI *PFN_GET_EFFECTIVE_RIGHTS_FROM_ACL_W)
(
    IN  PACL          pacl,
    IN  PTRUSTEE_W    pTrustee,
    OUT PACCESS_MASK  pAccessRights
);





/******************************************************************************
 * Wrapper class for AdvApi32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CAdvApi32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_LSA_ENUMERATE_TRUSTED_DOMAINS   m_pfnLsaEnumerateTrustedDomains;
    PFN_LSA_QUERY_INFORMATION_POLICY    m_pfnLsaQueryInformationPolicy;
    PFN_LSA_NT_STATUS_TO_WIN_ERROR      m_pfnLsaNtStatusToWinError;
    PFN_LSA_FREE_MEMORY                 m_pfnLsaFreeMemory;
    PFN_LSA_OPEN_POLICY                 m_pfnLsaOpenPolicy;
    PFN_LSA_CLOSE                       m_pfnLsaClose;
    PFN_SET_NAMED_SECURITY_INFO_W       m_pfnSetNamedSecurityInfoW;
    PFN_GET_NAMED_SECURITY_INFO_W       m_pfnGetNamedSecurityInfoW;
    PFN_QUERY_SERVICE_STATUS_EX         m_pfnQueryServiceStatusEx;
    PFN_DUPLICATE_TOKEN_EX              m_pfnDuplicateTokenEx;
    PFN_SET_SECURITY_DESCRIPTOR_CONTROL m_pfnSetSecurityDescriptorControl;
    PFN_CONVERT_TO_AUTO_INHERIT_PRIVATE_OBJECT_SECURITY m_pfnConvertToAutoInheritPrivateObjectSecurity;
    PFN_DESTROY_PRIVATE_OBJECT_SECURITY m_pfnDestroyPrivateObjectSecurity;
    PFN_SET_NAMED_SECURITY_INFO_EX      m_pfnSetNamedSecurityInfoEx;
    PFN_GET_EXPLICIT_ENTRIES_FROM_ACL   m_pfnGetExplicitEntriesFromAcl;
	PFN_CHECK_TOKEN_MEMBERSHIP			m_pfnCheckTokenMembership;
    PFN_ADD_ACCESS_ALLOWED_OBJECT_ACE   m_pfnAddAccessAllowedObjectAce;
    PFN_ADD_ACCESS_DENIED_OBJECT_ACE    m_pfnAddAccessDeniedObjectAce;
    PFN_ADD_AUDIT_ACCESS_OBJECT_ACE     m_pfnAddAuditAccessObjectAce;
    PFN_GET_EFFECTIVE_RIGHTS_FROM_ACL_W m_pfnGetEffectiveRightsFromAclW;

public:

    // Constructor and destructor:
    CAdvApi32Api(LPCTSTR a_tstrWrappedDllName);
    ~CAdvApi32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    NTSTATUS LsaEnumerateTrustedDomains
    (
        LSA_HANDLE a_PolicyHandle,
        PLSA_ENUMERATION_HANDLE a_EnumerationContext,
        PVOID *a_Buffer,
        ULONG a_PreferedMaximumLength,
        PULONG a_CountReturned
    );

    NTSTATUS LsaQueryInformationPolicy
    (
        LSA_HANDLE a_PolicyHandle,
        POLICY_INFORMATION_CLASS a_InformationClass,
        PVOID *a_Buffer
    );

    NTSTATUS LsaNtStatusToWinError
    (
        NTSTATUS a_Status
    );

    NTSTATUS LsaFreeMemory
    (
        PVOID a_Buffer
    );

    NTSTATUS LsaOpenPolicy
    (
        PLSA_UNICODE_STRING a_SystemName,
        PLSA_OBJECT_ATTRIBUTES a_ObjectAttributes,
        ACCESS_MASK a_DesiredAccess,
        PLSA_HANDLE a_PolicyHandle
    );

    NTSTATUS LsaClose
    (
        LSA_HANDLE a_ObjectHandle
    );

    bool SetNamedSecurityInfoW
    ( 
        LPWSTR                a_pObjectName,
        SE_OBJECT_TYPE        a_ObjectType,
        SECURITY_INFORMATION  a_SecurityInfo,
        PSID                  a_psidOowner,
        PSID                  a_psidGroup,
        PACL                  a_pDacl,
        PACL                  a_pSacl,
        DWORD                *a_dwRetval 
    );

    bool GetNamedSecurityInfoW
    (
	    LPWSTR                 a_pObjectName,
        SE_OBJECT_TYPE         a_ObjectType,
        SECURITY_INFORMATION   a_SecurityInfo,
        PSID                  *a_ppsidOowner,
        PSID                  *a_ppsidGroup,
        PACL                  *a_ppDacl,
        PACL                  *a_ppSacl,
        PSECURITY_DESCRIPTOR  *a_ppSecurityDescriptor,
        DWORD                 *a_dwRetval  
    );

    bool QueryServiceStatusEx 
    (
        SC_HANDLE       a_hService,
        SC_STATUS_TYPE  a_InfoLevel,
        LPBYTE          a_lpBuffer,
        DWORD           a_cbBufSize,
        LPDWORD         a_pcbBytesNeeded,
        BOOL           *a_fRetval 
    );

    bool DuplicateTokenEx 
    (  
        HANDLE a_h,					        // handle to token to duplicate
        DWORD a_dw,							// access rights of new token
        LPSECURITY_ATTRIBUTES a_lpsa,		// security attributes of the new token
        SECURITY_IMPERSONATION_LEVEL a_sil,	// impersonation level of new token
        TOKEN_TYPE a_tt,					// primary or impersonation token
        PHANDLE a_ph,                       // handle to duplicated token
        BOOL *a_fRetval                     // encapsulated function return value
    );

    bool SetSecurityDescriptorControl
    (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
        SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet,
        BOOL *a_fRetval
    );

    bool ConvertToAutoInheritPrivateObjectSecurity
    (
        PSECURITY_DESCRIPTOR a_ParentDescriptor,
        PSECURITY_DESCRIPTOR a_CurrentSecurityDescriptor,
        PSECURITY_DESCRIPTOR *a_NewSecurityDescriptor,
        GUID *a_ObjectType,
        BOOLEAN a_IsDirectoryObject,
        PGENERIC_MAPPING a_GenericMapping,
        BOOL *a_fRetval
    );

    bool DestroyPrivateObjectSecurity
    (
        PSECURITY_DESCRIPTOR *a_ObjectDescriptor,
        BOOL *a_fRetval
    );

    bool SetNamedSecurityInfoEx
    (
        LPCTSTR              a_lpObject,
        SE_OBJECT_TYPE       a_ObjectType,
        SECURITY_INFORMATION a_SecurityInfo,
        LPCTSTR              a_lpProvider,
        PACTRL_ACCESS        a_pAccessList,
        PACTRL_AUDIT         a_pAuditList,
        LPTSTR               a_lpOwner,
        LPTSTR               a_lpGroup,
        PACTRL_OVERLAPPED    a_pOverlapped,
        DWORD               *a_dwRetval
    );

    bool GetExplicitEntriesFromAcl
    (
        PACL                  a_pacl,
        PULONG                a_pcCountOfExplicitEntries,
        PEXPLICIT_ACCESS     *a_pListOfExplicitEntries,
        DWORD                *a_dwRetval
    );
	
	bool CheckTokenMembership 
	(
		HANDLE a_hTokenHandle OPTIONAL,
		PSID a_pSidToCheck,
		PBOOL a_pfIsMember,
		BOOL *a_fRetval
    );

    bool AddAccessAllowedObjectAce
    (
        PACL  a_pAcl,
        DWORD a_dwAceRevision,
        DWORD a_AceFlags,
        DWORD a_AccessMask,
        GUID  *a_ObjectTypeGuid,
        GUID  *a_InheritedObjectTypeGuid,
        PSID  a_pSid,
        BOOL  *a_fRetval
    );

    bool AddAccessDeniedObjectAce 
    (
        PACL  a_pAcl,
        DWORD a_dwAceRevision,
        DWORD a_AceFlags,
        DWORD a_AccessMask,
        GUID  *a_ObjectTypeGuid,
        GUID  *a_InheritedObjectTypeGuid,
        PSID  a_pSid,
        BOOL  *a_fRetval
    );

    bool AddAuditAccessObjectAce
    (
        PACL  a_pAcl,
        DWORD a_dwAceRevision,
        DWORD a_AceFlags,
        DWORD a_AccessMask,
        GUID  *a_ObjectTypeGuid,
        GUID  *a_InheritedObjectTypeGuid,
        PSID  a_pSid,
        BOOL  a_bAuditSuccess,
        BOOL  a_bAuditFailure,
        BOOL  *a_fRetval
    );

    bool GetEffectiveRightsFromAclW
    (
        PACL          a_pacl,
        PTRUSTEE_W    a_pTrustee,
        PACCESS_MASK  a_pAccessRights,
        DWORD         *a_dwRetval
    );

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\assoc.cpp ===
//=================================================================================================

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// assoc.cpp -- Rule-based association class
//
// This class allows for the creation of a specific type of rule-based associations.  Consider 
// this example:
// 
//     CAssociation MyThisComputerPhysicalFixedDisk(
//         L"ThisComputerPhysicalFixedDisk",
//         L"Root\\default",
//         L"ThisComputer",
//         L"PhysicalFixedDisk",
//         L"GroupComponent",
//         L"PartComponent"
//     ) ;
// 
// This declaration is saying that there is a class named "ThisComputerPhysicalFixedDisk" which 
// resides in the "root\default" namespace.  It is an association between the "ThisComputer" 
// class, and the "PhysicalFixedDisk" class.  The "ThisComputer" value goes into the 
// "GroupComponent" property of the "ThisComputerPhysicalFixedDisk" class, and the 
// "PhysicalFixedDisk" value goes in the "PartComponent" property of the 
// "ThisComputerPhysicalFixedDisk" class.
// 
// Some notes:
// - This class will take all the instances of the left class ("ThisComputer" in the example
// above) and relate them to ALL instances of the right class ("PhysicalFixedDisk" in the example
// above).  So, if there are 3 instances of the left class, and 4 instances of the right class,
// this association class will return 12 instances.
// 
// - When choosing which of the two classes should be the left class, choose the class that is
// likely to have fewer instances.  This will result in less memory being used, and instances
// being sent back to the client sooner.
// 
// - CAssociation supports ExecQuery, GetObject, and EnumerateInstances.
// 
// - CAssociation is designed to be derived from.  For example, if your association needs to 
// support DeleteInstance, ExecMethod, or PutInstance, create a class that derives from 
// CAssociation, and add the appropriate methods.  Also, various methods such as 
// LoadPropertyValues and AreRelated may be useful for further customization.
// 
// - The two endpoint classes can be dynamic, static, or abstract.  CAssociation will do a deep 
// enumeration (actually a query, which is always deep) to retrieve the instances.
//
// - When calling the endpoint classes, CAssociation will use per property gets, and queries
// with Select clauses and/or Where statements.  If the endpoint classes support per-property
// gets or queries, this will result in better performance for the associaton class.
//
// - The association class and both endpoints must all be in the same namespace.
// 
// See also: CBinding (binding.cpp) for a different type of rule-based association.
//
//=================================================================================================

#include "precomp.h"
#include "Assoc.h"

#include <helper.h>

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::CAssociation
//
// Constructor.
//
/////////////////////////////////////////////////////////////////////

CAssociation::CAssociation(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName

) : Provider(pwszClassName, pwszNamespaceName)
{
    // Save off the class and property names
    m_sLeftClassName = pwszLeftClassName;
    m_sRightClassName = pwszRightClassName;

    m_sLeftPropertyName = pwszLeftPropertyName;
    m_sRightPropertyName = pwszRightPropertyName;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::~CAssociation
//
// Destructor
//
/////////////////////////////////////////////////////////////////////

CAssociation::~CAssociation()
{
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ExecQuery
//
// This routine will optimize on queries of the form:
// WHERE prop1 = value1 [ or prop1 = value2 ...]
// 
// This type of query is commonly seen when doing an ASSOCIATORS or 
// REFERENCES query against one of the endpoint classes.
// 
// This routine will also optimize on queries of the form:
// WHERE prop1 = value1 [ or prop1 = value2 ...] AND 
//       prop2 = value3 [ or prop2 = value4 ...]
// 
// It will NOT optmize on queries of the form:
// WHERE prop1 <> value1
// WHERE prop1 > value1
// WHERE prop1 = value1 OR prop2 = value2
// 
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ExecQuery(

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> lefts;

    CHStringArray sLeftPaths, sRightPaths;

    // Look for WHERE m_sLeftPropertyName=value1
    pQuery.GetValuesForProp ( m_sLeftPropertyName, sLeftPaths ) ;

    // Look for WHERE m_sRightPropertyName=value1
    pQuery.GetValuesForProp ( m_sRightPropertyName, sRightPaths ) ;

    if (sLeftPaths.GetSize() == 0)
    {
        // They didn't ask for a specific set of left instances.  However,
        // it may be that we can figure out what left instances we need
        // by looking at what right instances they requested.  CAssociation 
        // doesn't do this, but CBinding does.
        CHStringArray sRightWheres;
        bool bHadRights = sRightPaths.GetSize() > 0;

        MakeWhere(sRightPaths, sRightWheres);

        // If we used to have a list of RightWheres, and MakeWhere discarded
        // them all as unusable, then there aren't going to be any
        // instances that match the query.
        if (!bHadRights || sRightPaths.GetSize() > 0)
        {
            // GetLeftInstances populates lefts using a sRightWheres
            // to construct a query.
            hr = GetLeftInstances(pMethodContext, lefts, sRightWheres);
        }
    }
    else
    {
        // For each sLeftPaths that is valid, create an entry in lefts by
        // doing a GetObject on the sLeftPaths entry.
        hr = ValidateLeftObjectPaths(pMethodContext, sLeftPaths, lefts);
    }

    // If we failed, or if there are no instances on the left, there's
    // no point in continuing.
    if (SUCCEEDED(hr) && lefts.GetSize() > 0)
    {
        // If the where clause didn't specify any value for the right property
        if (sRightPaths.GetSize() == 0)
        {
            // We may be able to use the information from the already retrieved 
            // left instances to limit which instances we retrieve from the right.
            // CAssociation doesn't do this, but CBinding does.
            CHStringArray sLeftWheres;
            hr = FindWhere(lefts, sLeftWheres);

            if (SUCCEEDED(hr))
            {
                // GetRightInstances takes the 'lefts' and rubs all the
                // rights against them creating instances where appropriate
                hr = GetRightInstances(pMethodContext, &lefts, sLeftWheres);
            }
        }
        else
        {
            // They gave us a list of object paths for the righthand property
            TRefPointerCollection<CInstance> rights;

            // For each sRightPaths that is valid, create an instance
            hr = ValidateRightObjectPaths(pMethodContext, sRightPaths, lefts);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetObject
//
// Verify the exist of the specified association class instance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetObject(

    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString sLeftPath, sRightPath;

    // Get the two endpoints to verify
    if (pInstance->GetCHString(m_sLeftPropertyName, sLeftPath ) &&
        pInstance->GetCHString(m_sRightPropertyName, sRightPath ) )
    {
        CInstancePtr pLeft, pRight;

        // Try to get the objects
        if (
                SUCCEEDED(hr = RetrieveLeftInstance(

                                    sLeftPath, 
                                    &pLeft, 
                                    pInstance->GetMethodContext())
                       ) &&
                SUCCEEDED(hr = RetrieveRightInstance(

                                    sRightPath, 
                                    &pRight, 
                                    pInstance->GetMethodContext())
                         ) 
           )
        {

            hr = WBEM_E_NOT_FOUND;

            // So, the end points exist.  Are they derived from or equal 
            // to the classes we are working with?
            CHString sLeftClass, sRightClass;

            pLeft->GetCHString(L"__Class", sLeftClass);
            pRight->GetCHString(L"__Class", sRightClass);

            bool bDerived = IsDerivedFrom(

                                m_sLeftClassName, 
                                sLeftClass, 
                                pInstance->GetMethodContext()
                            );

            if (bDerived)
            {
                bDerived = IsDerivedFrom(

                                m_sRightClassName, 
                                sRightClass, 
                                pInstance->GetMethodContext()
                            );
            }

            if (bDerived)
            {
                // Just because two instances are valid and derive from the right class, 
                // doesn't mean they are related.  Do any other checks.
                if (AreRelated(pLeft, pRight))
                {
                    // CBinding and CAssoc don't populate any additional properties, but
                    // an overload of one of these classes might.
                    hr = LoadPropertyValues(pInstance, pLeft, pRight);
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::EnumerateInstances
//
// Return all instances of the association class
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::EnumerateInstances(

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> lefts;
    CHStringArray sWheres;

    // GetLeftInstances populates lefts
    if (SUCCEEDED(hr = GetLeftInstances(pMethodContext, lefts, sWheres)))
    {
        // We may be able to use the information from the already retrieved 
        // left instances to limit which instances we retrieve from the right.
        // CAssociation doesn't do this, but CBinding does.
        FindWhere(lefts, sWheres);

        // GetRightInstances takes the 'lefts' and rubs all the
        // rights against them
        hr = GetRightInstances(pMethodContext, &lefts, sWheres);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetRightInstances
//
// For each instance of the righthand class retrieved, call
// CAssociation::StaticEnumerationCallback.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts,
    const CHStringArray &sLeftWheres
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_sRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        GetNamespace(),
        pMethodContext,
        lefts);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::StaticEnumerationCallback
//
// Put the 'this' pointer back, and call CAssociation::EnumerationCallback
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CAssociation::StaticEnumerationCallback(

    Provider* pThat,
    CInstance* pInstance,
    MethodContext* pContext,
    void* pUserData
)
{
    HRESULT hr;

    CAssociation *pThis = (CAssociation *) pThat;

    if (pThis)
    {
        hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::EnumerationCallback
//
// Take the righthand instance that was passed in and pair it
// with each of the left hand instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::EnumerationCallback(

    CInstance *pRight,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    HRESULT hr = WBEM_E_FAILED;

    CInstancePtr pLeft;
    REFPTRCOLLECTION_POSITION posLeft;
    CHString sLeftPath, sRightPath;

    // Cast for userdata back to what it is
    TRefPointerCollection<CInstance> *pLefts = (TRefPointerCollection<CInstance> *)pUserData;

    if (pLefts->BeginEnum(posLeft))
    {
        hr = WBEM_S_NO_ERROR;

        // Walk all the pLefts
        for (pLeft.Attach(pLefts->GetNext(posLeft)) ;
            (SUCCEEDED(hr)) && (pLeft != NULL) ;
            pLeft.Attach(pLefts->GetNext(posLeft)) )
        {
            // Compare it to the current pRight
            if(AreRelated(pLeft, pRight))
            {
                // We have a winner.  Populate the properties and send it back.
                if (GetLocalInstancePath(pLeft,  sLeftPath) &&
                    GetLocalInstancePath(pRight, sRightPath))
                {
                    CInstancePtr pNewAssoc(CreateNewInstance(pMethodContext), false);

                    if (pNewAssoc->SetCHString(m_sLeftPropertyName, sLeftPath) &&
                        pNewAssoc->SetCHString(m_sRightPropertyName, sRightPath) )
                    {
                        if (SUCCEEDED(hr = LoadPropertyValues(pNewAssoc, pLeft, pRight)))
                        {
                            hr = pNewAssoc->Commit();
                        }
                    }
                }
            }
        }

        pLefts->EndEnum();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ValidateLeftObjectPaths
//
// Populate the lefts array by doing GetObjects on the object paths
// passed in sPaths.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ValidateLeftObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0; x < sPaths.GetSize(); x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sPath(sPaths[x]);

        // Parse the object path
        int nStatus = objpathParser.Parse( sPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            OnDeleteObj<ParsedObjectPath *,
            	                  CObjectPathParser,            	                
            	                void(CObjectPathParser::*)(ParsedObjectPath *),
            	                &CObjectPathParser::Free>  ReleaseMe(&objpathParser,pParsedPath);

        
            // Is this class derived from or equal to the lefthand class?
            bool bDerived = false;

            bDerived = IsDerivedFrom(

                            m_sLeftClassName, 
                            pParsedPath->m_pClass, 
                            pMethodContext
                        );

            // Make sure this is an absolute path
            if (pParsedPath->m_dwNumNamespaces == 0)
            {
                sPath = L"\\\\.\\" + GetNamespace() + L':' + sPath;
            }

            if (bDerived)
            {
                // See if it is valid.  Note that we DON'T send back an error just because
                // we can't find one of the object paths.
                if (SUCCEEDED(RetrieveLeftInstance(sPath, &pInstance, pMethodContext)))
                {
                    // Yup, add it to the list
                    lefts.Add(pInstance);
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ValidateRightObjectPaths
//
// Retrieve the righthand instances by doing GetObjects on the object 
// paths passed in sPaths.  Pass them to EnumerationCallback.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ValidateRightObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    HRESULT hr = WBEM_S_NO_ERROR;;
    CInstancePtr pInstance;
    
    // Walk the object paths
    for (DWORD x=0;
    (x < sPaths.GetSize()) && SUCCEEDED(hr);
    x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sPath(sPaths[x]);
        
        int nStatus = objpathParser.Parse( sPath,  &pParsedPath );
        
        if ( 0 == nStatus )
        {
            OnDeleteObj<ParsedObjectPath *,
            	                CObjectPathParser,
            	                void(CObjectPathParser::*)(ParsedObjectPath *),
            	                &CObjectPathParser::Free>  ReleaseMe(&objpathParser,pParsedPath);
        
            bool bDerived = false;

            // Make sure this object path is at least related to us
            bDerived = IsDerivedFrom(
                
                m_sRightClassName, 
                pParsedPath->m_pClass, 
                pMethodContext
                );
            
            // Make sure this is an absolute path
            if (pParsedPath->m_dwNumNamespaces == 0)
            {
                sPath = L"\\\\.\\" + GetNamespace() + L':' + sPath;
            }
            
            if (bDerived)
            {
                // See if it is valid.  Note that we DON'T send back an error just because
                // we can't find one of the object paths.
                if (SUCCEEDED(RetrieveRightInstance(sPath, &pInstance, pMethodContext)))
                {
                    hr = EnumerationCallback(pInstance, pMethodContext, &lefts);
                }
            }
        }
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetLeftInstances
//
// Retrieve all the lefthand instances and store them in lefts
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts,
    const CHStringArray &sRightWheres
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_sLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext, GetNamespace());
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::RetrieveLeftInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the keys for maximum performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::RetrieveRightInstance
//
// Retrieve a specific righthand instance.  Use per-property gets
// to only request the keys for maximum performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::IsInstance
//
// See whether the specified CInstance is an Instance object, or a
// Class object.
//
/////////////////////////////////////////////////////////////////////

bool CAssociation::IsInstance(const CInstance *pInstance)
{
    DWORD dwGenus = 0;

    pInstance->GetDWORD(L"__Genus", dwGenus);

    return dwGenus == WBEM_GENUS_INSTANCE;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::IsDerivedFrom
//
// See whether the specified class is derived from or equal 
// to the class we are working with.  Specifically, does 
// pszDerivedClassName derive from pszBaseClassName?
//
/////////////////////////////////////////////////////////////////////

bool CAssociation::IsDerivedFrom(
                              
    LPCWSTR pszBaseClassName, 
    LPCWSTR pszDerivedClassName, 
    MethodContext *pMethodContext
)
{
    // First let's see if they are equal.  CWbemProviderGlue::IsDerivedFrom 
    // doesn't check for this case
    bool bDerived = _wcsicmp(pszBaseClassName, pszDerivedClassName) == 0;
    if (!bDerived)
    {
        bDerived = CWbemProviderGlue::IsDerivedFrom(
            
                                            pszBaseClassName, 
                                            pszDerivedClassName, 
                                            pMethodContext,
                                            GetNamespace()
                                        );
    }

    return bDerived;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\assoc.h ===
//=================================================================

//

// assoc.h -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#pragma once

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CAssociation : public Provider
{
    public:

        CAssociation(
        LPCWSTR pwszClassName,
        LPCWSTR pwszNamespaceName,

        LPCWSTR pwszLeftClassName,
        LPCWSTR pwszRightClassName,

        LPCWSTR pwszLeftPropertyName,
        LPCWSTR pwszRightPropertyName
        );

        virtual ~CAssociation();

        HRESULT ExecQuery(

            MethodContext* pMethodContext, 
            CFrameworkQuery &pQuery, 
            long lFlags 
        );

        HRESULT GetObject(

            CInstance* pInstance, 
            long lFlags,
            CFrameworkQuery &pQuery
        );

        HRESULT EnumerateInstances(

            MethodContext *pMethodContext,
            long lFlags /*= 0L*/
        );

    protected:
        
        bool IsInstance(const CInstance *pInstance);

        static HRESULT WINAPI StaticEnumerationCallback(

            Provider* pThat,
            CInstance* pInstance,
            MethodContext* pContext,
            void* pUserData
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT EnumerationCallback(

            CInstance *pRight, 
            MethodContext *pMethodContext, 
            void *pUserData
        );

        virtual HRESULT ValidateLeftObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT ValidateRightObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return IsInstance(pLeft) && IsInstance(pRight);
        }

        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
        )
        {
        }

        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts,
            const CHStringArray &sRightValues
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts,
            const CHStringArray &sLeftWheres
        );

        bool IsDerivedFrom(
                              
            LPCWSTR pszBaseClassName, 
            LPCWSTR pszDerivedClassName, 
            MethodContext *pMethodContext
        );

        CHString m_sLeftClassName;
        CHString m_sRightClassName;

        CHString m_sLeftPropertyName;
        CHString m_sRightPropertyName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\binding.h ===
//=================================================================

//

// binding.h -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "assoc.h"

#define MAX_ORS 3

class CBinding : public CAssociation
{
    public:

        CBinding(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        virtual ~CBinding();

    protected:

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
        );

        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
        );

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts,
            const CHStringArray &sRightValues
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts,
            const CHStringArray &sLeftWheres
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);

        HRESULT MakeString(VARIANT *pvValue, CHString &sTemp);

        DWORD IsInList(
                                
            const CHStringArray &csaArray, 
            LPCWSTR pwszValue
        );

        void EscapeCharacters(LPCWSTR wszIn,
                          CHString& chstrOut);

//-----------

        CHString m_sLeftBindingPropertyName;
        CHString m_sRightBindingPropertyName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\binding.cpp ===
//=================================================================

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// binding.cpp -- Rule-based association class
//
// This class allows for the creation of a specific type of rule-based associations.  Consider 
// this example:
// 
// CBinding MyPhysicalDiskToLogicalDisk(
//     L"PhysicalDiskToLogicalDisk",
//     L"Root\\default",
//     L"PhysicalFixedDisk",
//     L"LogicalDisk",
//     L"Antecendent",
//     L"Dependent",
//     L"MappedDriveLetter",
//     L"DriveLetter"
// );
// 
// This declaration is saying that there is a class named "PhysicalDiskToLogicalDisk" which 
// resides in the "root\default" namespace.  It is an association between the "PhysicalFixedDisk" 
// class, and the "LogicalDisk" class.  The "PhysicalFixedDisk" value goes into the 
// "Antecendent" property of the "PhysicalDiskToLogicalDisk" class, and the 
// "LogicalDisk" value goes in the "Dependent" property of the "PhysicalDiskToLogicalDisk" class.
// Only return instances where PhysicalFixedDisk.MappedDriveLetter = LogicalDisk.DriveLetter.
// 
// Some notes:
// - When choosing which of the two classes should be the left class, choose the class that is
// likely to have fewer instances.  This will result in less memory being used, and instances
// being sent back to the client sooner.
// 
// - CBinding supports ExecQuery, GetObject, and EnumerateInstances.
// 
// - CBinding is designed to be derived from.  For example, if your association needs to 
// support DeleteInstance, ExecMethod, or PutInstance, create a class that derives from 
// CBinding, and add the appropriate methods.  Also, various methods such as 
// LoadPropertyValues and AreRelated may be useful for further customization.
// 
// - The two endpoint classes can be dynamic, static, or abstract.  CBinding will do a deep 
// enumeration (actually a query, which is always deep) to retrieve the instances.
// 
// - When calling the endpoint classes, CBinding will use per property gets, and queries
// with Select clauses and/or Where statements.  If the endpoint classes support per-property
// gets or queries, this will result in better performance for the associaton class.
// 
// - The association class and both endpoints must all be in the same namespace.
// 
// See also: CAssociation (assoc.cpp) for a different type of rule-based association.
// 
//=================================================================

#include "precomp.h"
#include "Binding.h"

#include <helper.h>

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::CBinding
//
// Constructor.
//
/////////////////////////////////////////////////////////////////////

CBinding::CBinding(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName

) : CAssociation (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName
)
{
    // Save off the binding property names
    m_sLeftBindingPropertyName = pwszLeftBindingPropertyName;
    m_sRightBindingPropertyName = pwszRightBindingPropertyName;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::~CBinding
//
// Destructor.
//
/////////////////////////////////////////////////////////////////////

CBinding::~CBinding()
{
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::AreRelated
//
// Determine whether the two instances are related.  For
// CBinding, this is done by comparing their BindingProperty values.
//
// Note that NULL properties values are not considered to be related
// to anything, even another NULL.
//
/////////////////////////////////////////////////////////////////////

bool CBinding::AreRelated(

    const CInstance *pLeft,
    const CInstance *pRight
)
{
    bool bRet = false;

    variant_t   LeftBindingPropertyValue,
                RightBindingPropertyValue;

    if (pLeft->GetVariant(m_sLeftBindingPropertyName, LeftBindingPropertyValue) &&
        pRight->GetVariant(m_sRightBindingPropertyName,  RightBindingPropertyValue) )
    {
        bRet = CompareVariantsNoCase(&LeftBindingPropertyValue, &RightBindingPropertyValue);
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::GetRightInstances
//
// Make an async call (well, sort of async) to retrieve all of the
// instances of the righthand class.  If possible use the sLeftWheres
// to create a query to minimize the number of returned instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts,
    const CHStringArray &sLeftWheres
)
{
    CHString sQuery;

    // Did we get any where clauses?
    if (sLeftWheres.GetSize() == 0)
    {
        // Nope, retrieve them all.
        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE %s<>NULL", 

                        (LPCWSTR)m_sRightBindingPropertyName, 
                        (LPCWSTR)m_sRightClassName,
                        (LPCWSTR)m_sRightBindingPropertyName);
    }
    else
    {
        // Yup, build a query to only retrieve those instances.
        CHString sQuery2;

        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE (%s<>NULL) AND (%s=%s ", 

            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)m_sRightClassName, 
            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)sLeftWheres[0]);

        // Usually, we should only have one (that what ASSOCIATORS and REFERENCES will
        // generate).  However, if we have more than one, tack the rest on.
        for (DWORD x=1; x < sLeftWheres.GetSize(); x++)
        {
            sQuery2.Format(L"OR %s=%s ", (LPCWSTR)m_sRightBindingPropertyName, (LPCWSTR)sLeftWheres[x]);
            sQuery += sQuery2;
        }

        // put the final close parenthesis.
        sQuery.SetAt(sQuery.GetLength() - 1, L')');
    }

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        GetNamespace(),
        pMethodContext,
        lefts);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::GetLeftInstances
//
// Retrieve the lefthand instances, storing them in lefts
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts,
    const CHStringArray &sRightWheres
)
{
    CHString sQuery;

    // Did we get any where clauses?
    if (sRightWheres.GetSize() == 0)
    {
        // Nope, retrieve them all.
        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE %s <> NULL", 
                            (LPCWSTR)m_sLeftBindingPropertyName, 
                            (LPCWSTR)m_sLeftClassName,
                            (LPCWSTR)m_sLeftBindingPropertyName
                            );
    }
    else
    {
        // Yup, build a query to only retrieve those instances.
        CHString sQuery2;

        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE (%s<>NULL) AND (%s=%s ", 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)m_sLeftClassName, 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)sRightWheres[0]);

        // Usually, we should only have one (that what ASSOCIATORS and REFERENCES will
        // generate).  However, if we have more than one, tack the rest on.
        for (DWORD x=1; x < sRightWheres.GetSize(); x++)
        {
            sQuery2.Format(L"OR %s=%s ", (LPCWSTR)m_sLeftBindingPropertyName, (LPCWSTR)sRightWheres[x]);
            sQuery += sQuery2;
        }

        // put the final close parenthesis.
        sQuery.SetAt(sQuery.GetLength() - 1, L')');
    }

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext, GetNamespace());
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::RetrieveLeftInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the required properties for best performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__Relpath");
    csaProperties.Add(m_sLeftBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::RetrieveRightInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the required properties for best performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__Relpath");
    csaProperties.Add(m_sRightBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::MakeWhere
//
// If the key property of the righthand class also happens to be
// the binding property AND if we have a path for specific righthand
// instances we need to return, then we can use the path for the 
// righthand instances to build a where clause for the lefthand 
// instances.
//
// Note that if we find invalid paths in sRightPaths, we remove
// them from sRightPaths.
//
/////////////////////////////////////////////////////////////////////

void CBinding::MakeWhere(

    CHStringArray &sRightPaths,
    CHStringArray &sRightWheres
)
{
    // See if we have any righthand instances
    if (sRightPaths.GetSize() > 0)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sTemp;

        for (DWORD x=0; x < sRightPaths.GetSize();) // Note that x++ is done inside the loop
        {
            // Parse the instance
            int nStatus = objpathParser.Parse( sRightPaths[x],  &pParsedPath );

            if ( 0 == nStatus )
            {
                OnDeleteObj<ParsedObjectPath *,
                	                CObjectPathParser,                	                
                	                void(CObjectPathParser::*)(ParsedObjectPath *),
                	                &CObjectPathParser::Free>  ReleaseMe(&objpathParser,pParsedPath);
            
                    // See if the property name in the key is the property name we are binding on
                    if ( (pParsedPath->m_dwNumKeys == 1) && (pParsedPath->m_paKeys[0]->m_pName != NULL) )
                    {
                        if (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, m_sRightBindingPropertyName) == 0)
                        {
                            // Yes, it is.  Make a where clause statement.
                            HRESULT hr = MakeString(&pParsedPath->m_paKeys[0]->m_vValue, sTemp);

                            // See if we already have that where clause
                            if ( SUCCEEDED(hr) && IsInList(sRightWheres, sTemp) == -1)
                            {
                                // A query with 1000 where clauses isn't going
                                // to be very efficient either.  Pick a reasonable limit
                                if (sRightWheres.GetSize() < MAX_ORS)
                                {
                                    sRightWheres.Add(sTemp);
                                }
                                else
                                {
                                    // Too many.  Fall back on a complete enum
                                    sRightWheres.RemoveAll();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Fall back on a complete enum
                            sRightWheres.RemoveAll();
                            break;
                        }
                    }
                    else
                    {
                        // Fall back on a complete enum
                        sRightWheres.RemoveAll();
                        break;
                    }

                    // This was a valid path
                    x++;
            }
            else
            {
                // This was an invalid path.  Remove it
                sRightPaths.RemoveAt(x);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::FindWhere
//
// At this point, we have loaded all the lefthand instances.  We
// can use the binding property from these instances to build
// a where clause to be used when retrieve the righthand instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::FindWhere(

    TRefPointerCollection<CInstance> &lefts,
    CHStringArray &sLeftWheres
)
{
    REFPTRCOLLECTION_POSITION posLeft;
    CInstancePtr pLeft;
    HRESULT hr = WBEM_S_NO_ERROR;

    if (lefts.BeginEnum(posLeft))
    {
        variant_t   vLeftBindingPropertyValue;
        CHString sTemp;

        // Walk the left instances
        for (pLeft.Attach(lefts.GetNext(posLeft)) ;
            (pLeft != NULL) ;
            pLeft.Attach(lefts.GetNext(posLeft)) )
        {
            // Get the binding property from the left
            if (pLeft->GetVariant(m_sLeftBindingPropertyName, vLeftBindingPropertyValue))
            {
                // Turn it into a where clause
                hr = MakeString(&vLeftBindingPropertyValue, sTemp);

                // See if we alread have this where clause
                if (SUCCEEDED(hr) && IsInList(sLeftWheres, sTemp) == -1)
                {
                    // A query with 1000 where clauses isn't going
                    // to be very efficient either.  Pick a reasonable limit
                    if (sLeftWheres.GetSize() < MAX_ORS)
                    {
                        sLeftWheres.Add(sTemp);
                    }
                    else
                    {
                        // Too many.  Fall back to enum
                        sLeftWheres.RemoveAll();
                        break;
                    }
                }

                vLeftBindingPropertyValue.Clear();
            }
            else
            {
                hr = WBEM_E_FAILED;
                break;
            }
        }

        lefts.EndEnum();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::MakeString
//
// Turn the bindingproperty value into a string suitable for using
// in a wql where clause.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::MakeString(VARIANT *pvValue, CHString &sTemp)
{
    bool bIsString = V_VT(pvValue) == VT_BSTR;
    HRESULT hr = VariantChangeType(
        
            pvValue, 
            pvValue, 
            VARIANT_NOVALUEPROP, 
            VT_BSTR
    );

    if (SUCCEEDED(hr))
    {
        // If the original type was string, we need to escape quotes
        // and backslashes, and put double quotes around it.
        if (bIsString)
        {
            CHString sTemp2;
            EscapeCharacters(V_BSTR(pvValue), sTemp2);

            sTemp.Format(L"\"%s\"", (LPCWSTR)sTemp2);
        }
        else
        {
            sTemp = V_BSTR(pvValue);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::IsInList
//
// See whether a given string already exists in a chstring array.
//
/////////////////////////////////////////////////////////////////////

DWORD CBinding::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE INSENSITIVE compare
        if (_wcsicmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::CompareVariantsNoCase
//
// Compare two variants to see if they are the same.
//
/////////////////////////////////////////////////////////////////////

bool CBinding::CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2)
{
   if (v1->vt == v2->vt)
   {
      switch (v1->vt)
      {
          case VT_NULL: return false;
          case VT_BOOL: return (v1->boolVal == v2->boolVal);
          case VT_UI1:  return (v1->bVal == v2->bVal);
          case VT_I2:   return (v1->iVal == v2->iVal);
          case VT_I4:   return (v1->lVal == v2->lVal);
          case VT_R4:   return (v1->fltVal == v2->fltVal);
          case VT_R8:   return (v1->dblVal == v2->dblVal);
          case VT_BSTR:
          {
              if ( (v1->bstrVal == v2->bstrVal) || // deal with both being NULL
                   (0 == _wcsicmp(v1->bstrVal, v2->bstrVal)) )
              {                   
                  return true;
              }
              else
              {
                  return false;
              }
          }
          default:
          {
              // Should never get here
          }
      }
   }

   return false;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::EscapeBackslashes
//
// Prefix " and \ characters with an additional \
//
/////////////////////////////////////////////////////////////////////

VOID CBinding::EscapeCharacters(LPCWSTR wszIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname(wszIn);
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next character to escape
    while( (lNext = chstrCpyNormPathname.FindOneOf(L"\"\\") ) != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
    }

    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cautolock.h ===
//============================================================================
//
// CAutoLock.h -- Automatic locking class for mutexes and critical sections.
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#ifndef __CAUTOLOCK_H__
#define __CAUTOLOCK_H__

#include "CGlobal.h"
#include "CMutex.h"
#include "CCriticalSec.h"

class CAutoLock 
{
private:

	//HANDLE m_hMutexHandle;
	//CMutex* m_pcMutex;
	CCriticalSec* m_pcCritSec;
	CStaticCritSec* m_psCritSec;    
	BOOL bExec ;

    //CAutoLock( HANDLE hMutexHandle);    	
public:
    // Constructors

    //CAutoLock( CMutex& rCMutex);
    CAutoLock( CCriticalSec& rCCriticalSec);
    CAutoLock( CStaticCritSec & rCCriticalSec);
    
    // Destructor
    ~CAutoLock();

	BOOL Exec () ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cautolock.cpp ===
//============================================================================
//
// CAutoLock.cpp -- Automatic locking class for mutexes and critical sections.
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CAutoLock.h"

/*
CAutoLock::CAutoLock(HANDLE hMutexHandle)
:  
   m_pcCritSec(NULL),
   m_pcMutex(NULL),
   m_psCritSec(NULL),   
   m_hMutexHandle(hMutexHandle),
   bExec ( FALSE )
{
    ::WaitForSingleObject(m_hMutexHandle, INFINITE);
}

CAutoLock::CAutoLock(CMutex& rCMutex):  
   m_pcCritSec(NULL),
   m_psCritSec(NULL),    
   m_hMutexHandle(NULL),
   m_pcMutex(&rCMutex),
   bExec ( FALSE )

{

    m_pcMutex->Wait(INFINITE);
}
*/

CAutoLock::CAutoLock(CCriticalSec& rCCritSec):  
//   m_hMutexHandle(NULL),
//   m_pcMutex(NULL),   
   m_pcCritSec(&rCCritSec),
   m_psCritSec(NULL),
   bExec ( FALSE )

{
    m_pcCritSec->Enter();
}

CAutoLock::CAutoLock( CStaticCritSec & rCCriticalSec):  
//    m_hMutexHandle(NULL),
//   m_pcMutex(NULL),  
    m_pcCritSec(NULL),
    m_psCritSec(&rCCriticalSec),
   bExec ( FALSE )

{
    m_psCritSec->Enter();
};

// destructor...
CAutoLock::~CAutoLock()
{
	if ( FALSE == bExec )
	{
		Exec () ;
	}
}

BOOL CAutoLock::Exec ()
{
    BOOL bStatus = TRUE;
/*
    if (m_hMutexHandle)
    {
        bStatus = ::ReleaseMutex(m_hMutexHandle);
    }
    else if (m_pcMutex)
    {
        bStatus = m_pcMutex->Release();
    }
    else */
	if (m_pcCritSec)
    {
        m_pcCritSec->Leave();
    }
    else
    {
        m_psCritSec->Leave();        
    }

    if (!bStatus)
    {        
        LogMessage2(L"CAutoLock Error: %d", ::GetLastError());
    }
	else
	{
		bExec = TRUE ;
	}

	return bStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ccriticalsec.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CCriticalSec.h -- Critical Section Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#ifndef __CCriticalSec_H__
#define __CCriticalSec_H__

#include <windows.h>
#include <process.h>

#ifndef STATUS_POSSIBLE_DEADLOCK 
#define STATUS_POSSIBLE_DEADLOCK (0xC0000194L)
#endif /*STATUS_POSSIBLE_DEADLOCK */

DWORD  BreakOnDbgAndRenterLoop(void);

class CCriticalSec : public CRITICAL_SECTION
{
public:
    CCriticalSec() 
    {
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400
        bool initialized = (InitializeCriticalSectionAndSpinCount(this,0))?true:false;
        if (!initialized) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
#else
        bool initialized = false;
        __try
        {
            InitializeCriticalSection(this);
            initialized = true;
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
        }
        if (!initialized) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);  
#endif
#else
        bool initialized = false;
        __try
        {
            InitializeCriticalSection(this);
            initialized = true;
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
        }
        if (!initialized) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);  
#endif        
    }

    ~CCriticalSec()
    {
        DeleteCriticalSection(this);
    }

    void Enter()
    {
        __try {
          EnterCriticalSection(this);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }

    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

        
class CInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
public:
    CInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        __try {
          EnterCriticalSection(m_pcs);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }
    inline ~CInCritSec()
    {
        LeaveCriticalSection(m_pcs);
    }
};

class CStaticCritSec : public CRITICAL_SECTION
{
private:
    bool initialized_;      
    static BOOL anyFailed_;    
public:
    static BOOL anyFailure();    
    static void SetFailure();        
    CStaticCritSec();
    ~CStaticCritSec();
    void Enter();
    void Leave();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cfgmgrdevice.cpp ===
/////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <assertbreak.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "irqdesc.h"

#include <regstr.h>
#include "refptr.h"

#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include "iodesc.h"        // don't need this yet
#include "devdesc.h"       // don't need this yet
#include "dmadesc.h"
#include <cregcls.h>
#include "nt4svctoresmap.h"
#include "chwres.h"
#include "configmgrapi.h"
#include <map>
// The Map we will use below is an STL Template, so make sure we have the std namespace
// available to us.

using namespace std;

typedef ULONG (WINAPI  *CIM16GetConfigManagerStatus)(LPSTR HardwareKey);

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::CConfigMgrDevice
//
//	Class Constructor.
//
//	Inputs:		LPCTSTR		pszConfigMgrName - Name of device in config
//							manager (HKEY_DYN_DATA\Config Manager\Enum
//							subkey).
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////


CConfigMgrDevice::CConfigMgrDevice( LPCWSTR pszConfigMgrName,DWORD dwTypeToGet )
:					CRefPtrLite(),
                	m_strConfigMgrName( pszConfigMgrName ),
	                m_strHardwareKey(),
	                m_strDeviceDesc(),
	                m_pbAllocationData( NULL ),
	                m_dwSizeAllocationData( 0 )
{
    m_dwTypeToGet = dwTypeToGet;
	GetConfigMgrInfo();
	GetDeviceInfo();

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::CConfigMgrDevice
//
//	Class Constructor.
//
//	Inputs:		DEVNODE		m_dn - Device Node  from tree
//				DWORD		dwResType - Resource Types to Enum
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
CConfigMgrDevice::CConfigMgrDevice( DEVNODE dn, DWORD dwResType /*=ResType_All*/ )
:					CRefPtrLite(),
                	m_strConfigMgrName(),
	                m_strHardwareKey(),
	                m_strDeviceDesc(),
	                m_pbAllocationData( NULL ),
	                m_dwSizeAllocationData( 0 ),
					m_dn( dn ),
					m_dwTypeToGet( dwResType )
{

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::~CConfigMgrDevice
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CConfigMgrDevice::~CConfigMgrDevice( void )
{
	if ( NULL != m_pbAllocationData ){
		delete [] m_pbAllocationData;
		m_pbAllocationData = NULL;
	}
}
////////////////////////////////////////////////////////////////////////
//
//  This function searches for the configuration manager device name
//  based on the
//
////////////////////////////////////////////////////////////////////////
BOOL CConfigMgrDevice::MapKeyToConfigMgrDeviceName()
{
	BOOL fRc = FALSE;
    CRegistrySearch Search;
    CHPtrArray chsaList;
	CHString  *pPtr;

	Search.SearchAndBuildList( _T("Config Manager\\Enum"), chsaList,
							   m_strConfigMgrName,
							   _T("HardWareKey"),
							   VALUE_SEARCH,HKEY_DYN_DATA );
    if( chsaList.GetSize() > 0 ){

        pPtr = ( CHString *) chsaList.GetAt(0);
		WCHAR szTmp[50];
      szTmp[0] = _T('\0');
		swscanf(*pPtr, L"Config Manager\\Enum\\%s", szTmp);
      m_strConfigMgrName = CHString(szTmp);
		fRc = TRUE;
    }
    Search.FreeSearchList( CSTRING_PTR, chsaList );

	return fRc;

}

////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
DWORD CConfigMgrDevice::GetStatusFromConfigManagerDirectly(void)
{
    DWORD dwStatus = 0L;
        // thunk down to 16-bit to get it
    CCim32NetApi *t_pCim32Api = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
    if( t_pCim32Api)
    {
        dwStatus = (t_pCim32Api->GetWin9XConfigManagerStatus)((char*)(const char*)_bstr_t(m_strHardwareKey));
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Api);
        t_pCim32Api = NULL;
	}
    return dwStatus;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//  This function translates the binary status code from the registry
//  into the following values:
//     OK, ERROR, DEGRADED, UNKNOWN
//
////////////////////////////////////////////////////////////////////////
BOOL CConfigMgrDevice::GetStatus(CHString & chsStatus)
{
	DWORD dwStatus = 0L;
	BOOL fRc = FALSE;
	CRegistry Reg;
	CHString chsKey = CONFIGMGR_ENUM_KEY+m_strConfigMgrName;

    chsStatus = IDS_STATUS_Unknown;

	// Do this the old tried and true LEGACY way.  Lose this code ASAP!
	if ( NULL == m_dn )
	{
#ifdef WIN9XONLY
		{
			if( !m_strHardwareKey.IsEmpty() )
			{
				dwStatus = GetStatusFromConfigManagerDirectly();
			}
		}
#endif
#ifdef NTONLY
		if( !m_strConfigMgrName.IsEmpty())
#endif
		{
			//===================================================
			//  Initialize
			//===================================================
			if( Reg.Open(HKEY_DYN_DATA, chsKey, KEY_READ) == ERROR_SUCCESS )
			{
                DWORD dwSize = 4;
				Reg.GetCurrentBinaryKeyValue(CONFIGMGR_DEVICE_STATUS_VALUE, (BYTE *)&dwStatus, &dwSize);
			}
		}
	}
	else
	{
		// Use the config manager to get the data for us
		GetStatus( &dwStatus, NULL );
	}

    if( dwStatus != 0L )
	{
		fRc = TRUE;
		//==============================================
		//  OK, these are wild guesses at translation,
		//  we may need to fiddle with these
		//==============================================
		if( dwStatus & DN_ROOT_ENUMERATED  ||
			dwStatus & DN_DRIVER_LOADED ||
			dwStatus & DN_ENUM_LOADED ||
			dwStatus & DN_STARTED ){
			chsStatus = IDS_STATUS_OK;
		}
		// we don't care about these:
		// DN_MANUAL,DN_NOT_FIRST_TIME,DN_HARDWARE_ENUM,DN_FILTERED
		// DN_DISABLEABLE, DN_REMOVABLE,DN_MF_PARENT,DN_MF_CHILD
	    // DN_NEED_TO_ENUM, DN_LIAR,DN_HAS_MARK
		if( dwStatus & DN_MOVED ||
			dwStatus & DN_WILL_BE_REMOVED){
			chsStatus = IDS_STATUS_Degraded;
		}

		if( dwStatus & DN_HAS_PROBLEM ||
			dwStatus & DN_PRIVATE_PROBLEM){
			chsStatus = IDS_STATUS_Error;
		}
	}
	return fRc;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetConfigMgrInfo
//
//	Opens the appropriate Config Manager SubKey and loads values from
//	there.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we open the subkey and get the values
//								we wanted.
//
//	Comments:	Needs to be able to get read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetConfigMgrInfo( void )
{
	BOOL	fReturn = FALSE;

	// For this to function correctly, we MUST have a value in
	// m_strConfigMgrName.


	if ( !m_strConfigMgrName.IsEmpty() ){
		HKEY	hConfigMgrKey = NULL;

		CHString	strKeyName( CONFIGMGR_ENUM_KEY );

		// Open the config manager key

		strKeyName += m_strConfigMgrName;	// Don't forget to concat name Sanj, you big dummy

		if ( ERROR_SUCCESS == RegOpenKeyEx(	HKEY_DYN_DATA,
											TOBSTRT(strKeyName),
											0,
											KEY_READ,
											&hConfigMgrKey ) )
		{
			ON_BLOCK_EXIT ( RegCloseKey, hConfigMgrKey ) ;

			// Get our hardware key, status and our resource allocation
			if ( GetHardwareKey( hConfigMgrKey ) )
			{
				// Status is device status information from the registry.
				if ( GetStatusInfo( hConfigMgrKey ) )
				{
					fReturn = GetResourceAllocation( hConfigMgrKey );
				}
			}
		}

	}

	return FALSE;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetHardwareKey
//
//	Gets the Config Manager HardwareKey value.
//
//	Inputs:		HKEY		Key - Config Manager SubKey to open.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value.
//
//	Comments:	Needs to be able to get read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetHardwareKey( HKEY hKey )
{
	BOOL	fReturn					=	FALSE;
	DWORD	dwSizeHardwareKeyName	=	0;


	// First, get the Hardware key name buffer size.

	if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
											CONFIGMGR_DEVICE_HARDWAREKEY_VALUE,
											0,
											NULL,
											NULL,
											&dwSizeHardwareKeyName ) )
	{
		m_strHardwareKey = L"";

        // We do it this way since CHString no longer changes types with TCHAR
//		LPTSTR	pszBuffer = m_strHardwareKey.GetBuffer( dwSizeHardwareKeyName );
        LPTSTR  pszBuffer = new TCHAR[dwSizeHardwareKeyName]; //(LPTSTR) malloc(dwSizeHardwareKeyName * sizeof(TCHAR));

		if ( NULL != pszBuffer )
		{

            try
            {
			    // Now get the real buffer
			    if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
													    CONFIGMGR_DEVICE_HARDWAREKEY_VALUE,
													    0,
													    NULL,
													    (LPBYTE) pszBuffer,
													    &dwSizeHardwareKeyName ) )
			    {
				    fReturn = TRUE;
                    m_strHardwareKey = pszBuffer;
			    }
            }
            catch ( ... )
            {
    			delete [] pszBuffer;
                throw ;
            }

			delete [] pszBuffer;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// IF RegQueryValue Ex

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetResourceAllocation
//
//	Gets the Config Manager Device Resource Allocation and fills
//	out the resource list as appropriate.
//
//	Inputs:		HKEY		Key - Config Manager SubKey to open.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value.
//
//	Comments:	Must have read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetResourceAllocation( HKEY hKey )
{
	BOOL	fReturn					=	FALSE;
	DWORD	dwSizeAllocation		=	0;


	// First, get the buffer size.

	if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
											CONFIGMGR_DEVICE_ALLOCATION_VALUE,
											0,
											NULL,
											NULL,
											&dwSizeAllocation ) )
	{
		// Initialize pbData, using a stack buffer if we can (most of the time
		// this will probably suffice).
		LPBYTE	pbData	=	new BYTE[dwSizeAllocation];
		// Just be safe here.
		if ( NULL != pbData )
        {
			// Now get the real buffer

			if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
													CONFIGMGR_DEVICE_ALLOCATION_VALUE,
													0,
													NULL,
													pbData,
													&dwSizeAllocation ) )
			{
				m_pbAllocationData = pbData;
				m_dwSizeAllocationData = dwSizeAllocation;
				fReturn = TRUE;
			}

			// DON'T delete the data buffer.  The object destructor does it.
//			delete [] pbData;

			else
			{
				// MUST delete here though !!!
				delete [] pbData;
			}
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// IF RegQueryValue Ex

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetStatusInfo
//
//	Gets the Config Manager Device Status and Problem fields.
//
//	Inputs:		HKEY		Key - Config Manager SubKey to open.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the values.
//
//	Comments:	Must have read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetStatusInfo( HKEY hKey )
{
	BOOL	fReturn					=	FALSE;
	DWORD	dwBuffSize				=	sizeof(DWORD);


	// First, get the status value, then get the problem value.

	if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
											CONFIGMGR_DEVICE_STATUS_VALUET,
											0,
											NULL,
											(LPBYTE) &m_dwStatus,
											&dwBuffSize ) )
	{

		// Now get the problem

		dwBuffSize = sizeof(DWORD);

		if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
												CONFIGMGR_DEVICE_PROBLEM_VALUE,
												0,
												NULL,
												(LPBYTE) &m_dwProblem,
												&dwBuffSize ) )	{
			fReturn = TRUE;
		}

	}	// IF RegQueryValue Ex

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDeviceInfo
//
//	Uses the HardwareKey value to get further device information.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value(s).
//
//	Comments:	Needs to be able to get read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDeviceInfo( void )
{
	BOOL	fReturn = FALSE;

	// For this to function correctly, we MUST have a value in
	// m_strHardwareKey


	if ( !m_strHardwareKey.IsEmpty() )
	{
		HKEY	hDeviceKey = NULL;

		CHString	strKeyName( LOCALMACHINE_ENUM_KEY );

		// Open the config manager key

		strKeyName += m_strHardwareKey;	// Don't forget to concat name Sanj, you big dummy

		if ( ERROR_SUCCESS == RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
											TOBSTRT(strKeyName),
											0,
											KEY_READ,
											&hDeviceKey ) )
		{
			ON_BLOCK_EXIT ( RegCloseKey, hDeviceKey ) ;

			fReturn = GetDeviceDesc( hDeviceKey );
		}

	}

	return FALSE;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDeviceDesc
//
//	Gets the Device Description from the supplied subkey.
//
//	Inputs:		HKEY		Key - Device SubKey to get info from.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value.
//
//	Comments:	If the value doesn't exist, this is not an error.  We'll
//				just clear the value.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDeviceDesc( HKEY hKey )
{
	BOOL	fReturn				=	FALSE;
	DWORD	dwSizeDeviceName	=	0;
	LONG	lReturn				=	0L;


	// First, get the DeviceDesc buffer size.

	if ( ( lReturn = RegQueryValueEx(	hKey,
										CONFIGMGR_DEVICEDESC_VALUE,
										0,
										NULL,
										NULL,
										&dwSizeDeviceName ) )
					== ERROR_SUCCESS )
	{
		//LPTSTR	pszBuffer = m_strDeviceDesc.GetBuffer( dwSizeDeviceName );
        LPTSTR pszBuffer = new TCHAR[dwSizeDeviceName]; //(LPTSTR) malloc(dwSizeDeviceName * sizeof(TCHAR));

		m_strDeviceDesc = L"";
        // Just be safe here.

		if ( NULL != pszBuffer )
		{
            try
            {
			    // Now get the real buffer

			    if ( ( lReturn = RegQueryValueEx(	hKey,
												    CONFIGMGR_DEVICEDESC_VALUE,
												    0,
												    NULL,
												    (LPBYTE) pszBuffer,
												    &dwSizeDeviceName ) )
							    == ERROR_SUCCESS )
			    {
				    fReturn = TRUE;
                    m_strDeviceDesc = pszBuffer;
			    }
			    else
			    {
				    fReturn = ( ERROR_FILE_NOT_FOUND == lReturn );
			    }
            }
            catch ( ... )
            {
                delete [] pszBuffer;
                throw ;
            }

			//m_strDeviceDesc.ReleaseBuffer();	// Resets to string size
            delete [] pszBuffer;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// IF RegQueryValue Ex
	else
	{
		fReturn = ( ERROR_FILE_NOT_FOUND == lReturn );
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetIRQResources
//
//	Walks the device's allocated resource configuration and fills out
//	an IRQ collection with IRQ Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CIRQCollection&	irqList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetIRQResources( CIRQCollection& irqList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the irq list first

	irqList.Empty();

	// Populate the resource list first, specifying only IRQ resources, then we will
	// need to Dup the data into the irq list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_IRQ ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr	pResource;

			// Check each resource, validating it is an IRQ before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_IRQ );

				if ( pResource->GetResourceType() == ResType_IRQ )
				{

					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CIRQDescriptor*	pIRQ = (CIRQDescriptor*) pResource.GetInterfacePtr();
					irqList.Add( pIRQ );

				}	// IF an IRQ Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetIOResources
//
//	Walks the device's allocated resource configuration and fills out
//	an IO collection with IO Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CIOCollection&	IOList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetIOResources( CIOCollection& IOList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the IO list first

	IOList.Empty();

	// Populate the resource list first, specifying only IO resources, then we will
	// need to Dup the data into the IO list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_IO ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr pResource;

			// Check each resource, validating it is an IO before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_IO );

				if ( pResource->GetResourceType() == ResType_IO )
				{
					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CIODescriptor*	pIO = (CIODescriptor*) pResource.GetInterfacePtr();
					IOList.Add( pIO );

				}	// IF an IO Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum()

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDMAResources
//
//	Walks the device's allocated resource configuration and fills out
//	an DMA collection with DMA Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CDMACollection&	DMAList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDMAResources( CDMACollection& DMAList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the DMA list first

	DMAList.Empty();

	// Populate the resource list first, specifying only DMA resources, then we will
	// need to Dup the data into the DMA list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_DMA ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr pResource;

			// Check each resource, validating it is an DMA before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_DMA );

				if ( pResource->GetResourceType() == ResType_DMA )
				{

					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CDMADescriptor*	pDMA = (CDMADescriptor*) pResource.GetInterfacePtr();
					DMAList.Add( pDMA );

				}	// IF an DMA Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDeviceMemoryResources
//
//	Walks the device's allocated resource configuration and fills out
//	an DeviceMemory collection with DeviceMemory Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CDeviceMemoryCollection&	DeviceMemoryList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the DeviceMemory list first

	DeviceMemoryList.Empty();

	// Populate the resource list first, specifying only DeviceMemory resources, then we will
	// need to Dup the data into the DeviceMemory list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_Mem ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr	pResource;

			// Check each resource, validating it is an DeviceMemory before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_Mem );

				if ( pResource->GetResourceType() == ResType_Mem )
				{
					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CDeviceMemoryDescriptor*	pDeviceMemory = (CDeviceMemoryDescriptor*) pResource.GetInterfacePtr();;
					DeviceMemoryList.Add( pDeviceMemory );

				}	// IF an DeviceMemory Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::WalkAllocatedResources
//
//	Walks the device's allocated resource configuration and fills out
//	a resource collection with the appropriate data.
//
//	Inputs:		RESOURCEID					resType - Types of resources
//											to return.
//				CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		TRUE/FALSE				List found or not.
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::WalkAllocatedResources( CResourceCollection& resourceList, CNT4ServiceToResourceMap *pResourceMap, RESOURCEID resType  )
{
    LOG_CONF LogConfig;
    RES_DES ResDes;
    CONFIGRET cr;
	BOOL	fReturn = FALSE ;

	// Dump the resource list first
	resourceList.Empty();

	// If we're on NT 4, we gotta march to the beat of a different
	// drummer.

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		// Convert Resource Type from RESOURCEID to CM_RESOURCE_TYPE

		fReturn = WalkAllocatedResourcesNT4( resourceList, pResourceMap, RESOURCEIDToCM_RESOURCE_TYPE( resType ) );
	}
	else
#endif
	{
		CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
		if ( pconfigmgr )
		{
			if ( pconfigmgr->IsValid () )
			{
#ifdef NTONLY
		BOOL			fIsNT5 = IsWinNT5();
#endif

				// Get the allocated Logical Configuration.  From there, we can iterate resource descriptors
				// until we find an IRQ Descriptor.

				cr = CR_NO_MORE_LOG_CONF ;

				if ( (

					pconfigmgr->CM_Get_First_Log_Conf( &LogConfig, m_dn, ALLOC_LOG_CONF ) == CR_SUCCESS ||
					pconfigmgr->CM_Get_First_Log_Conf( &LogConfig, m_dn, BOOT_LOG_CONF ) == CR_SUCCESS
				) )
				{
					cr = CR_SUCCESS ;

					RESOURCEID	resID;

					// To get the first Resource Descriptor, we pass in the logical configuration.
					// The config manager knows how to handle this (or at least that's what the
					// ahem-"documentation" sez.

					RES_DES	LastResDes = LogConfig;

					do
					{

						// Get only resources of the type we were made to retrieve
						cr = pconfigmgr->CM_Get_Next_Res_Des( &ResDes, LastResDes, resType, &resID, 0 );

						// Clean up the prior resource descriptor handle
						if ( LastResDes != LogConfig )
						{
							pconfigmgr->CM_Free_Res_Des_Handle( LastResDes );
						}

						if ( CR_SUCCESS == cr )
						{

							// CAUTION!	On NT5, if we are doing a resource Type that is NOT ResType_All,
							// the OS does not appear to fill out ResID.  I guess the assumption being
							// that we already know the resource type we are trying to get.  HOWEVER,
							// if any bits like ResType_Ignored are set, NT 5 appears to be smartly
							// dropping those resources, so we'll just set resID here as if the
							// call on NT 5 had done anything.

#ifdef NTONLY
							if	(	ResType_All	!=	resType
								&&	fIsNT5 )
							{
								resID = resType;
							}
#endif

							ULONG	ulDataSize = 0;

							if ( CR_SUCCESS == ( cr = pconfigmgr->CM_Get_Res_Des_Data_Size( &ulDataSize, ResDes, 0 ) ) )
							{
								ulDataSize += 10;	// Pad for 10 bytes of safety

								BYTE*	pbData = new BYTE[ulDataSize];

								if ( NULL != pbData )
								{
                                    try
                                    {
									    cr = pconfigmgr->CM_Get_Res_Des_Data( ResDes, pbData, ulDataSize, 0 );

									    if ( CR_SUCCESS == cr )
									    {
										    if ( !AddResourceToList( resID, pbData, ulDataSize, resourceList ) )
										    {
											    cr = CR_OUT_OF_MEMORY;
										    }
									    }
                                    }
                                    catch ( ... )
                                    {
                                        delete [] pbData;
                                        throw ;
                                    }

									// We're done with the data
									delete [] pbData;

								}	// IF NULL != pbData
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }

							}	// IF Get Data Size

							// Store the last descriptor, so we can go on to the next one.
							LastResDes = ResDes;

						}	// If we got a descriptor

					}	while ( CR_SUCCESS == cr );

					// If we blew out on this, we're okay, since the error means we ran out of
					// resource descriptors.

					if ( CR_NO_MORE_RES_DES == cr )
					{
						cr = CR_SUCCESS;
					}

					// Clean up the logical configuration handle
					pconfigmgr->CM_Free_Log_Conf_Handle( LogConfig );
				}	// IF got alloc logconf
				fReturn = ( CR_SUCCESS == cr );
			}
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
		}
	}	// else !NT 4
	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::AddResourceToList
//
//	Copies resource data as necessary, coercing from 16 to 32 bit as
//	necessary, then adds the resource to the supplied list.
//
//	Inputs:		RESOURCEID				resourceID - What resource is this?
//				LPVOID					pResource - The resource
//				DWORD					dwResourceLength - How long is it?
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		TRUE/FALSE				Add succeeded or failed.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::AddResourceToList( RESOURCEID resourceID, LPVOID pResource, DWORD dwResourceLength, CResourceCollection& resourceList )
{
	IRQ_DES		irqDes;
	IOWBEM_DES	ioDes;
	DMA_DES		dmaDes;
	MEM_DES		memDes;

	// Don't know if Config Manager will return a resource ignored value,
	// so what we'll do here is check if the ignored bit is set, and for
	// now, ASSERT

	//ASSERT_BREAK( !(resourceID & ResType_Ignored_Bit) );

	// Filter out extraneous bits
	RESOURCEID	resType = ( resourceID & RESOURCE_TYPE_MASK );

	// Hey, I'm an optimist
	BOOL		fReturn = TRUE;

	// Different structures for 32/16 bit CFGMGR, so if
	// we ain't on WINNT, we need to coerce the data into
	// a proper structure.

#ifdef WIN9XONLY
	{
		// We have to cheat here and coerce the data from a 16-bit
		// structure into a matching 32-bit structure.

		switch ( resType )
		{
			case ResType_IRQ:
			{
				IRQDes16To32( (PIRQ_DES16) pResource, &irqDes );
			}
			break;

			case ResType_IO:
			{
				IODes16To32( (PIO_DES16) pResource, &ioDes );
			}
			break;

			case ResType_DMA:
			{
				DMADes16To32( (PDMA_DES16) pResource, &dmaDes );
			}
			break;

			case ResType_Mem:
			{
				MEMDes16To32( (PMEM_DES16) pResource, &memDes );
			}
			break;

		}	// switch ResourceID

	}	// IF !IsWinNT
#endif
#ifdef NTONLY
	{
		// Just copy the resource data into the appropriate descriptor

		switch ( resType )
		{
			case ResType_IRQ:
			{
				CopyMemory( &irqDes, pResource, sizeof(IRQ_DES) );
			}
			break;

			case ResType_IO:
			{
				// Because 16-bit has values 32-bit does not, we cheated and came up with our
				// own structure.  32-bit values are at the top, so zero out the struct and
				// trhe other values will just be ignored...yeah, that's the ticket.

				ZeroMemory( &ioDes, sizeof(ioDes) );
				CopyMemory( &ioDes, pResource, sizeof(IO_DES) );
			}
			break;

			case ResType_DMA:
			{
				CopyMemory( &dmaDes, pResource, sizeof(DMA_DES) );
			}
			break;

			case ResType_Mem:
			{
				CopyMemory( &memDes, pResource, sizeof(MEM_DES) );
			}
			break;

		}	// SWITCH ResourceId

	}	// else IsWinNT
#endif

	CResourceDescriptorPtr	pResourceDescriptor;

	// Just copy the resource data into the appropriate descriptor

    bool bAdd = true;

	switch ( resType )
	{
		case ResType_IRQ:
		{
			pResourceDescriptor.Attach( (CResourceDescriptor*) new CIRQDescriptor( resourceID, irqDes, this ) );
		}
		break;

		case ResType_IO:
		{
            bAdd = (ioDes).IOD_Alloc_End >= (ioDes).IOD_Alloc_Base;
			pResourceDescriptor.Attach ( (CResourceDescriptor*) new CIODescriptor( resourceID, ioDes, this ) );
		}
		break;

		case ResType_DMA:
		{
			pResourceDescriptor.Attach ( (CResourceDescriptor*) new CDMADescriptor( resourceID, dmaDes, this ) );
		}
		break;

		case ResType_Mem:
		{
			pResourceDescriptor.Attach ( (CResourceDescriptor*) new CDeviceMemoryDescriptor( resourceID, memDes, this ) );
		}
		break;

		default:
		{
			// We don't know what it is, but make a raw one anyway
			pResourceDescriptor.Attach ( new CResourceDescriptor( resourceID, pResource, dwResourceLength, this ) );
		}
		break;

	}	// SWITCH ResourceId

    if (bAdd)
    {
	    if ( NULL != pResourceDescriptor )
	    {
    	    fReturn = resourceList.Add( pResourceDescriptor );
	    }
	    else
	    {
		    fReturn = FALSE;
	    }
    }
    else
    {
        fReturn = TRUE;
    }

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::WalkAllocatedResourcesNT4
//
//	Because none of the logical configuration stuff in NT4 seems to
//	work worth a darn, we're gonna manhandle our own data from the
//	registry data under HKLM\HARDWARE\RESOURCEMAP.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - Resource map
//											to use for the walk.  We create
//											one if this is NULL.
//				CM_RESOURCE_TYPE			resType - Resource Types to return.
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		TRUE/FALSE				List found or not.
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CConfigMgrDevice::WalkAllocatedResourcesNT4(
    CResourceCollection& resourceList,
    CNT4ServiceToResourceMap *pResourceMap,
    CM_RESOURCE_TYPE resType )
{
	BOOL						fReturn = FALSE;
	CHString					strServiceName;

	// Allocate a map if we need one.  Otherwise use the one passed in that somebody
	// theoretically has cached off somewhere.

	CNT4ServiceToResourceMap*	pLocalMap = pResourceMap;

	if ( NULL == pLocalMap )
	{
		pLocalMap = new CNT4ServiceToResourceMap;
	}

	if ( NULL != pLocalMap )
	{

        try
        {
		    // Get our service name.  If this succeeds, pull our resources from the reource map
		    if ( GetService( strServiceName ) )
		    {
			    fReturn = GetServiceResourcesNT4( strServiceName, *pLocalMap, resourceList, resType );
		    }
        }
        catch ( ... )
        {
		    if ( pLocalMap != pResourceMap )
		    {
			    delete pLocalMap;
		    }
            throw ;
        }

		// Clean up the local map if we allocated one
		if ( pLocalMap != pResourceMap )
		{
			delete pLocalMap;
		}
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }


	return fReturn;
}
#endif

#ifdef NTONLY
BOOL CConfigMgrDevice::GetServiceResourcesNT4( LPCTSTR pszServiceName, CNT4ServiceToResourceMap& resourceMap, CResourceCollection& resourceList, CM_RESOURCE_TYPE cmrtFilter/*=CmResourceTypeNull*/ )
{
	BOOL						fReturn = TRUE;
	LPRESOURCE_DESCRIPTOR		pResourceDescriptor;

	// Iterate the resources, looking for matches against values we may be filtering
	// for.

	DWORD	dwNumResources = resourceMap.NumServiceResources( pszServiceName );

	for	(	DWORD	dwCtr	=	0;
					dwCtr	<	dwNumResources
			&&		fReturn;
					dwCtr++ )
	{
		pResourceDescriptor = resourceMap.GetServiceResource( pszServiceName, dwCtr );

		// Grab the resource if it's our filter, or our filter is NULL, meaning grab everything
		if	(	NULL	!=	pResourceDescriptor
			&&	(	CmResourceTypeNull	==	cmrtFilter
				||	cmrtFilter			==	pResourceDescriptor->CmResourceDescriptor.Type
				)
			)
		{
			CResourceDescriptorPtr pResource;

			// Perform appropriate type coercsions, and hook the resource into the resource
			/// list.
			switch ( pResourceDescriptor->CmResourceDescriptor.Type )
			{
				case CmResourceTypeInterrupt:
				{
					IRQ_DES		irqDes;
					NT4IRQToIRQ_DES( pResourceDescriptor, &irqDes );
					pResource.Attach(new CIRQDescriptor( ResType_IRQ, irqDes, this ) );
				}
				break;

				case CmResourceTypePort:
				{
					IOWBEM_DES		ioDes;
					NT4IOToIOWBEM_DES( pResourceDescriptor, &ioDes );
					pResource.Attach(new CIODescriptor( ResType_IO, ioDes, this ) );
				}
				break;

				case CmResourceTypeMemory:
				{
					MEM_DES		memDes;
					NT4MEMToMEM_DES( pResourceDescriptor, &memDes );
					pResource.Attach(new CDeviceMemoryDescriptor( ResType_Mem, memDes, this ));
				}
				break;

				case CmResourceTypeDma:
				{
					DMA_DES		dmaDes;
					NT4DMAToDMA_DES( pResourceDescriptor, &dmaDes );
					pResource.Attach(new CDMADescriptor( ResType_DMA, dmaDes, this ));
				}
				break;

				// If it ain't one of these four, there ain't a whole heck of a
				// lot we're gonna do here
			}


			if ( NULL != pResource )
			{
    			fReturn = resourceList.Add( pResource );
			}
			else
			{
				// We beefed on a simple memory allocation.  Get out of here.
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

		}	// IF resource was one we wanted to handle

	}	// FOR enum resources

	return fReturn;
}
#endif

#ifdef NTONLY
CM_RESOURCE_TYPE CConfigMgrDevice::RESOURCEIDToCM_RESOURCE_TYPE( RESOURCEID resType )
{
	CM_RESOURCE_TYPE	cmResType = CmResourceTypeNull;
	switch ( resType )
	{
		case ResType_All:		cmResType	=	CmResourceTypeNull;			break;
		case ResType_IO:		cmResType	=	CmResourceTypePort;			break;
		case ResType_IRQ:		cmResType	=	CmResourceTypeInterrupt;	break;
		case ResType_DMA:		cmResType	=	CmResourceTypeDma;			break;
		case ResType_Mem:		cmResType	=	CmResourceTypeMemory;		break;
		default:				cmResType	=	CmResourceTypeNull;			break;
	}

	return cmResType;
}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4IRQToIRQ_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIRQ_DES pirqDes32 )
{
	ZeroMemory( pirqDes32, sizeof(IRQ_DES) );

	// 32-bit structure
	//typedef struct IRQ_Des_s {
	//   DWORD IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
	//   DWORD IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
	//   DWORD IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
	//   ULONG IRQD_Alloc_Num;   // specifies the IRQ that was allocated
	//   ULONG IRQD_Affinity;
	//} IRQ_DES, *PIRQ_DES;

	pirqDes32->IRQD_Alloc_Num = pResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level;
	pirqDes32->IRQD_Affinity = pResourceDescriptor->CmResourceDescriptor.u.Interrupt.Affinity;

	// We'll do our best on the flags conversion.

	if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	{
		pirqDes32->IRQD_Flags |= fIRQD_Share;
	}

	// Latched -> Edge?  Have no idea, the other value in either case was Level,
	// so here's a leap of faith.

	if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_INTERRUPT_LATCHED )
	{
		pirqDes32->IRQD_Flags |= fIRQD_Edge;
	}

}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4IOToIOWBEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIOWBEM_DES pioDes32 )
{
	ZeroMemory( pioDes32, sizeof(IOWBEM_DES) );

	// 32-bit structure
	//typedef struct _IOWBEM_DES{
	//	DWORD		IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
	//	DWORD		IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
	//	DWORDLONG	IOD_Alloc_Base;     // base of allocated port range
	//	DWORDLONG	IOD_Alloc_End;      // end of allocated port range
	//	DWORD		IOD_DesFlags;       // flags relating to allocated port range
	//	BYTE		IOD_Alloc_Alias;	// From 16-bit-land
	//	BYTE		IOD_Alloc_Decode;	// From 16-bit-land
	//} IOWBEM_DES;

    LARGE_INTEGER liTemp;  // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

	pioDes32->IOD_Alloc_Base = liTemp.QuadPart;
	pioDes32->IOD_Alloc_End = pioDes32->IOD_Alloc_Base + ( pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1);

	// Don't know what to do with Share disposition here, since CFGMGR32 doesn't seem to
	// do it for IO Ports.
	//if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	//{
	//	pioDes32->IOD_Flags |= fIRQD_Share;
	//}

	//
	// Port Type flags convert straight across
	//

	//#define fIOD_PortType   (0x1) // Bitmask,whether port is IO or memory
	//#define fIOD_Memory     (0x0) // Port resource really uses memory
	//#define fIOD_IO         (0x1) // Port resource uses IO ports

	//#define CM_RESOURCE_PORT_MEMORY 0
	//#define CM_RESOURCE_PORT_IO 1

	pioDes32->IOD_DesFlags = pResourceDescriptor->CmResourceDescriptor.Flags;

}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4MEMToMEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PMEM_DES pmemDes32 )
{
	ZeroMemory( pmemDes32, sizeof(MEM_DES) );

	// 32-bit structure
	//typedef struct Mem_Des_s {
	//   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
	//   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
	//   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
	//   DWORDLONG MD_Alloc_End;    // end of allocated range
	//   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
	//   DWORD     MD_Reserved;
	//} MEM_DES, *PMEM_DES;

    LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Memory.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Memory.Start.LowPart;

	pmemDes32->MD_Alloc_Base = liTemp.QuadPart;
	pmemDes32->MD_Alloc_End = pmemDes32->MD_Alloc_Base + ( pResourceDescriptor->CmResourceDescriptor.u.Memory.Length - 1);

	// Don't know what to do with Share disposition here, since CFGMGR32 doesn't seem to
	// do it for IO Ports.
	//if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	//{
	//	pioDes32->MD_Flags |= fIRQD_Share;
	//}

	// Flag conversions I can do
	if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_READ_WRITE )
	{
		pmemDes32->MD_Flags |= fMD_RAM;
		pmemDes32->MD_Flags |= fMD_ReadAllowed;
	}
	else if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_READ_ONLY )
	{
		pmemDes32->MD_Flags |= fMD_ROM;
		pmemDes32->MD_Flags |= fMD_ReadAllowed;
	}
	else if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_WRITE_ONLY )
	{
		pmemDes32->MD_Flags |= fMD_RAM;
		pmemDes32->MD_Flags |= fMD_ReadDisallowed;
	}

	if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_PREFETCHABLE )
	{
		pmemDes32->MD_Flags |= fMD_PrefetchAllowed;
	}

	// Don't know what to do with these flags:

	//#define mMD_32_24                   (0x2) // Bitmask, memory is 24 or 32-bit
	//#define fMD_32_24                   mMD_32_24 // compatibility
	//#define fMD_24                      (0x0) // Memory range is 24-bit
	//#define fMD_32                      (0x2) // Memory range is 32-bit

	//#define mMD_CombinedWrite           (0x10) // Bitmask,supports write-behind
	//#define fMD_CombinedWrite           mMD_CombinedWrite // compatibility
	//#define fMD_CombinedWriteDisallowed (0x0)  // no combined-write caching
	//#define fMD_CombinedWriteAllowed    (0x10) // supports combined-write caching

	//#define mMD_Cacheable               (0x20) // Bitmask,whether memory is cacheable
	//#define fMD_NonCacheable            (0x0)  // Memory range is non-cacheable
	//#define fMD_Cacheable               (0x20) // Memory range is cacheable

}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4DMAToDMA_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PDMA_DES pdmaDes32 )
{
	ZeroMemory( pdmaDes32, sizeof(DMA_DES) );

	// 32-bit structure
	//typedef struct DMA_Des_s {
	//   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
	//   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
	//   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
	//   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
	//} DMA_DES, *PDMA_DES;

	pdmaDes32->DD_Alloc_Chan = pResourceDescriptor->CmResourceDescriptor.u.Dma.Channel;

	// Don't know what to do with Share disposition here, since CFGMGR32 doesn't seem to
	// do it for IO Ports.
	//if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	//{
	//	pioDes32->MD_Flags |= fIRQD_Share;
	//}

	// These are possible flags for DMA, but I don't see any values from the
	// CHWRES.H file which make a sensible conversion to these values.

	//
	// Define the attribute flags for a DMA resource range.  Each bit flag is
	// identified with a constant bitmask.  Following the bitmask definition
	// are the possible values.
	//
	//#define mDD_Width         (0x3)    // Bitmask, width of the DMA channel:
	//#define fDD_BYTE          (0x0)    //   8-bit DMA channel
	//#define fDD_WORD          (0x1)    //   16-bit DMA channel
	//#define fDD_DWORD         (0x2)    //   32-bit DMA channel
	//#define fDD_BYTE_AND_WORD (0x3)    //   8-bit and 16-bit DMA channel

	//#define mDD_BusMaster     (0x4)    // Bitmask, whether bus mastering is supported
	//#define fDD_NoBusMaster   (0x0)    //   no bus mastering
	//#define fDD_BusMaster     (0x4)    //   bus mastering

	//#define mDD_Type         (0x18)    // Bitmask, specifies type of DMA
	//#define fDD_TypeStandard (0x00)    //   standard DMA
	//#define fDD_TypeA        (0x08)    //   Type-A DMA
	//#define fDD_TypeB        (0x10)    //   Type-B DMA
	//#define fDD_TypeF        (0x18)    //   Type-F DMA

}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::IRQDes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PIRQ_DES16				pirqDes16 - 16-bit structure
//
//	Outputs:	PIRQ_DES				pirqDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::IRQDes16To32( PIRQ_DES16 pirqDes16, PIRQ_DES pirqDes32 )
{
	ZeroMemory( pirqDes32, sizeof(IRQ_DES) );

	// 16-bit Structure
	//struct	IRQ_Des_s {
	//	WORD			IRQD_Flags;
	//	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	//	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	//	WORD			IRQD_Reserved;
	//};

	// 32-bit structure
	//typedef struct IRQ_Des_s {
	//   DWORD IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
	//   DWORD IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
	//   DWORD IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
	//   ULONG IRQD_Alloc_Num;   // specifies the IRQ that was allocated
	//   ULONG IRQD_Affinity;
	//} IRQ_DES, *PIRQ_DES;

	pirqDes32->IRQD_Alloc_Num	=	pirqDes16->IRQD_Alloc_Num;
	pirqDes32->IRQD_Flags		=	pirqDes16->IRQD_Flags;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::IODes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PIO_DES16				pioDes16 - 16-bit structure
//
//	Outputs:	PIOWBEM_DES				pioDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::IODes16To32( PIO_DES16 pioDes16, PIOWBEM_DES pioDes32 )
{
	ZeroMemory( pioDes32, sizeof(IOWBEM_DES) );

	// 16-bit structure
	//struct	IO_Des_s {
	//	WORD			IOD_Count;
	//	WORD			IOD_Type;
	//	WORD			IOD_Alloc_Base;
	//	WORD			IOD_Alloc_End;
	//	WORD			IOD_DesFlags;
	//	BYTE			IOD_Alloc_Alias;
	//	BYTE			IOD_Alloc_Decode;
	//};

	// 32-bit Structure
	//typedef struct _IOWBEM_DES{
	//	DWORD		IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
	//	DWORD		IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
	//	DWORDLONG	IOD_Alloc_Base;     // base of allocated port range
	//	DWORDLONG	IOD_Alloc_End;      // end of allocated port range
	//	DWORD		IOD_DesFlags;       // flags relating to allocated port range
	//	BYTE		IOD_Alloc_Alias;	// From 16-bit-land
	//	BYTE		IOD_Alloc_Decode;	// From 16-bit-land
	//} IOWBEM_DES;

	pioDes32->IOD_Count			=	pioDes16->IOD_Count;
	pioDes32->IOD_Type			=	pioDes16->IOD_Type;
	pioDes32->IOD_Alloc_Base	=	pioDes16->IOD_Alloc_Base;
	pioDes32->IOD_Alloc_End		=	pioDes16->IOD_Alloc_End;
	pioDes32->IOD_DesFlags		=	pioDes16->IOD_DesFlags;
	pioDes32->IOD_Alloc_Alias	=	pioDes16->IOD_Alloc_Alias;
	pioDes32->IOD_Alloc_Decode	=	pioDes16->IOD_Alloc_Decode;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::DMADes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PDMA_DES16				pdmaDes16 - 16-bit structure
//
//	Outputs:	PDMA_DES				pdmaDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::DMADes16To32( PDMA_DES16 pdmaDes16, PDMA_DES pdmaDes32 )
{
	ZeroMemory( pdmaDes32, sizeof(DMA_DES) );

	// 16-bit structure
	//struct	DMA_Des_s {
	//	BYTE			DD_Flags;
	//	BYTE			DD_Alloc_Chan;	// Channel number allocated
	//	BYTE			DD_Req_Mask;	// Mask of possible channels
	//	BYTE			DD_Reserved;
	//};

	// 32-bit structure
	//typedef struct DMA_Des_s {
	//   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
	//   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
	//   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
	//   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
	//} DMA_DES, *PDMA_DES;

	pdmaDes32->DD_Flags			=	pdmaDes16->DD_Flags;
	pdmaDes32->DD_Alloc_Chan	=	pdmaDes16->DD_Alloc_Chan;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::MEMDes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PMEM_DES16				pmemDes16 - 16-bit structure
//
//	Outputs:	PMEM_DES				pmemDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::MEMDes16To32( PMEM_DES16 pmemDes16, PMEM_DES pmemDes32 )
{
	ZeroMemory( pmemDes32, sizeof(MEM_DES) );

	// 16-bit Structure
	//struct	Mem_Des_s {
	//	WORD			MD_Count;
	//	WORD			MD_Type;
	//	ULONG			MD_Alloc_Base;
	//	ULONG			MD_Alloc_End;
	//	WORD			MD_Flags;
	//	WORD			MD_Reserved;
	//};

	// 32-bit Structure
	//typedef struct Mem_Des_s {
	//   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
	//   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
	//   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
	//   DWORDLONG MD_Alloc_End;    // end of allocated range
	//   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
	//   DWORD     MD_Reserved;
	//} MEM_DES, *PMEM_DES;

	pmemDes32->MD_Count			=	pmemDes16->MD_Count;
	pmemDes32->MD_Type			=	pmemDes16->MD_Type;
	pmemDes32->MD_Alloc_Base	=	pmemDes16->MD_Alloc_Base;
	pmemDes32->MD_Alloc_End		=	pmemDes16->MD_Alloc_End;
	pmemDes32->MD_Flags			=	pmemDes16->MD_Flags;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::TraverseAllocationData
//
//	Traverses a block of data in order to determine
//	resource allocations for a particular device.
//
//	Inputs:		None.
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		None.
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::TraverseAllocationData( CResourceCollection& resourceList )
{
	const BYTE *	pbTraverseData		=	m_pbAllocationData;
	DWORD			dwSizeRemainingData =	m_dwSizeAllocationData,
					dwResourceType		=	ResType_None,
					dwResourceSize		=	0;

	// Clear the resource list first
	resourceList.Empty();

	// OWCH!  The first hack.  Near as I can tell, we need to jump eight bytes in to get
	// to the first resource descriptor header (if there is one).

	TraverseData( pbTraverseData, dwSizeRemainingData, FIRST_RESOURCE_OFFSET );

	// From here on, we only want to deal with known resource information.  Use the
	// clever GetNextResource function to do all of our dirty work for us.  If it
	// returns TRUE, then it's located a resource.  Allocate the proper type of
	// descriptor based on type, place it in the list and go on to the next resource.

	while ( GetNextResource( pbTraverseData, dwSizeRemainingData, dwResourceType, dwResourceSize ) )
	{
        if( dwResourceType == m_dwTypeToGet ){

		    PPOORMAN_RESDESC_HDR	pResDescHdr	=	(PPOORMAN_RESDESC_HDR) pbTraverseData;
		    CResourceDescriptorPtr pResDesc;

		    // We have a valid type, however the actual resource descriptor will
		    // lie SIZEOF_RESDESC_HDR bytes past where we're at now (pointing at
		    // a resource header).

		    switch ( dwResourceType ){
			    case ResType_Mem:
			    {
				    CDeviceMemoryDescriptor*	pMemDesc = new CDeviceMemoryDescriptor( pResDescHdr, this );
				    pResDesc.Attach(pMemDesc);
				    break;
			    }

			    case ResType_IO:
			    {
				    CIODescriptor*	pIODesc = new CIODescriptor( pResDescHdr, this );
				    pResDesc.Attach(pIODesc);
				    break;
			    }

			    case ResType_DMA:
			    {
				    CDMADescriptor*	pDMADesc = new CDMADescriptor( pResDescHdr, this );
				    pResDesc.Attach(pDMADesc);
				    break;
			    }

			    case ResType_IRQ:
			    {
				    CIRQDescriptor*	pIRQDesc = new CIRQDescriptor( pResDescHdr, this );
				    pResDesc.Attach(pIRQDesc);
				    break;
			    }

			    default:
			    {
				    pResDesc.Attach (new CResourceDescriptor( pResDescHdr, this ));
			    }

    		}	// SWITCH

    		// Give up if we have any failures, since they are most likely memory
		    // related, and something really bad has happened.

		    if ( NULL != pResDesc )
            {
                if ( !resourceList.Add( pResDesc ) )
                {
				    break;
			    }
		    }
		    else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }
        }
		// Move the pointer to the next resource descriptor header.
		TraverseData( pbTraverseData, dwSizeRemainingData, dwResourceSize );

	}	// WHILE finding new resources

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::FindNextResource
//
//	Iterates through a block of data, hunting for byte patterns that
//	identify a resource type.  In this case, as long as there are
//	SIZEOF_RESDESC_HDR bytes let to work with, we extract the resource
//	type and size and return those values for interpretation.
//
//	Inputs:		const BYTE*		pbTraverseData	- Data we are traversing.  The
//								value will change as we progress through the
//								data.
//				DWORD			dwSizeRemainingData - How much data remains to
//								be traversed.
//
//	Outputs:	DWORD&			dwResourceType - What type of resource have we
//								found.
//				DWORD&			dwResourceSize - How big the block of data
//								describing the resource is.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetNextResource( const BYTE  *pbTraverseData, DWORD dwSizeRemainingData, DWORD& dwResourceType, DWORD& dwResourceSize )
{
	BOOL	fReturn = FALSE;

	// If we have less than SIZEOF_RESDESC_HDR bytes to work with,
	// give up, we ain't goin' nowhere.

	if ( dwSizeRemainingData > SIZEOF_RESDESC_HDR )
	{
		PPOORMAN_RESDESC_HDR	pResDescHdr = (PPOORMAN_RESDESC_HDR) pbTraverseData;
		DWORD					dwResourceId = 0;

		dwResourceSize = pResDescHdr->dwResourceSize;

		// If we run into a zero byte header, the only value will be length, which
		// makes no sense, so we should probably just give up.

		if ( 0 != dwResourceSize )
		{
			// See if it's one of the four standard types.  If so, be aware that this code
			// ain't checking to see if it's ignored, and that an OEM can create a replacement
			// for one of these standard types, in which case strange and wondrous things
			// may happen.

			// Strip out any unwanted data, the first 5 bits are reserved for resource type
			// identification, so mask out everything else

			dwResourceType = pResDescHdr->dwResourceId;
			dwResourceType &= RESOURCE_TYPE_MASK;

			// We got a live one!
			fReturn = TRUE;

		}
	}

	// Return whether or not we found a resource

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetStatus
//
//	Returns the status of the device as a string.  If OK, it is "OK", if
//	we have a problem, it is "Error".
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - String to place status in.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::GetProblem( CHString& str )
{
	// Save the string
	str = ( 0 == m_dwProblem ? IDS_CfgMgrDeviceStatus_OK : IDS_CfgMgrDeviceStatus_ERR );
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::TraverseData
//
//	Helper function to safely bounce a pointer around our data.  It will
//	jump the pointer by the specified amount, or the amount remaining,
//	whichever is smaller.
//
//	Inputs:		DWORD			dwSizeTraverse - Size of upcoming jump.
//
//	Outputs:	const BYTE*&	pbTraverseData	- Data we are traversing.  The
//								value will change as we progress through the
//								data.
//				DWORD&			dwSizeRemainingData - How much data remains to
//								be traversed.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::TraverseData( const BYTE *& pbTraverseData, DWORD& dwSizeRemainingData, DWORD dwSizeTraverse )
{
	// Increment the pointer and reduce the size of remaining data, do this safely, not
	// traversing beyond the end of the remaining data, if that is all that is left.

	pbTraverseData += min( dwSizeRemainingData, dwSizeTraverse );
	dwSizeRemainingData -= min( dwSizeRemainingData, dwSizeTraverse );
}

// New functions that converse directly with the Config Manager APIs

BOOL CConfigMgrDevice::GetDeviceID( CHString& strID )
{
	BOOL bRet = FALSE ;
	CONFIGRET	cr = CR_SUCCESS;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			char		szDeviceId[MAX_DEVICE_ID_LEN+1];

			ULONG		ulBuffSize = 0;

			cr = pconfigmgr->CM_Get_Device_IDA( m_dn, szDeviceId, sizeof(szDeviceId), 0  );

			if ( CR_SUCCESS == cr )
			{
				strID = szDeviceId;
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetStatus( LPDWORD pdwStatus, LPDWORD pdwProblem )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			DWORD		dwStatus,
						dwProblem;

			CONFIGRET	cr = pconfigmgr->CM_Get_DevNode_Status( &dwStatus, &dwProblem, m_dn, 0 );

			// Perform pointer testing here.  Ignore the man behind the curtain...
			if ( CR_SUCCESS == cr )
			{
				if ( NULL != pdwStatus )
				{
					*pdwStatus = dwStatus;
				}

				if ( NULL != pdwProblem )
				{
					*pdwProblem = dwProblem;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::IsUsingForcedConfig()
{
	BOOL bRet = FALSE ;
	LOG_CONF			conf;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			bRet = (pconfigmgr->CM_Get_First_Log_Conf(&conf, m_dn, FORCED_LOG_CONF) ==
					CR_SUCCESS);
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetParent( CConfigMgrDevicePtr & pParentDevice )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	DEVNODE			dn;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			CONFIGRET	cr = pconfigmgr->CM_Get_Parent( &dn, m_dn, 0 );

			if ( CR_SUCCESS == cr )
			{
				CConfigMgrDevice* pDevice = new CConfigMgrDevice( dn );
				pParentDevice.Attach(pDevice);
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetChild( CConfigMgrDevicePtr & pChildDevice )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	DEVNODE			dn;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			CONFIGRET	cr = pconfigmgr->CM_Get_Child( &dn, m_dn, 0 );

			if ( CR_SUCCESS == cr )
			{
				CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( dn );
				pChildDevice.Attach(pDevice);
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetSibling( CConfigMgrDevicePtr & pSiblingDevice )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	DEVNODE			dn;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			CONFIGRET	cr = pconfigmgr->CM_Get_Sibling( &dn, m_dn, 0 );

			if ( CR_SUCCESS == cr )
			{
				CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( dn );
				pSiblingDevice.Attach(pDevice);
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetStringProperty( ULONG ulProperty, CHString& strValue )
{
    TCHAR Buffer[REGSTR_VAL_MAX_HCID_LEN+1];
    ULONG Type;
    ULONG Size = sizeof(Buffer);
	BOOL bRet = FALSE ;
	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						ulProperty,
																						&Type,
																						Buffer,
																						&Size,
																						0 ) ) )
			{
				if ( REG_SZ == Type )
				{
					strValue = Buffer;
				}
				else
				{
					cr = CR_WRONG_TYPE;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetDWORDProperty( ULONG ulProperty, DWORD *pdwVal )
{
	DWORD	dwVal = 0;
    ULONG Type;
    ULONG Size = sizeof(DWORD);
	BOOL bRet = FALSE ;
	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						ulProperty,
																						&Type,
																						&dwVal,
																						&Size,
																						0 ) ) )
			{
#ifdef NTONLY
				{
					if ( REG_DWORD == Type )
					{
						*pdwVal = dwVal;
					}
					else
					{
						cr = CR_WRONG_TYPE;
					}

				}
#endif
#ifdef WIN9XONLY
				{
					if ( REG_BINARY == Type )	// Apparently Win16 doesn't do REG_DWORD
					{
						*pdwVal = dwVal;
					}
					else
					{
						cr = CR_WRONG_TYPE;
					}
				}
#endif
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetMULTISZProperty( ULONG ulProperty, CHStringArray& strArray )
{
	CONFIGRET	cr = CR_SUCCESS;
	BOOL bRet = FALSE ;
// No one is currently using this, so I'm not going to fix it now
#ifdef DOESNT_WORK_FOR_UNICODE
	LPSTR	pszStrings = NULL;
    ULONG	Type;
    ULONG	Size = 0;


	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						ulProperty,
																						&Type,
																						pszStrings,
																						&Size,
																						0 ) )
				||	CR_BUFFER_SMALL	==	cr )

			{
				// SZ or MULTI_SZ is Okay (32-bit has MULTI_SZ values that are SZ in 16-bit)
				if ( REG_SZ == Type || REG_MULTI_SZ == Type )
				{
					// Pad the string, but be aware that on NT4 I have seen situations in which
					// it reports less data than it actually returns (scary)

					Size += 32;
					pszStrings = new char[Size];

					if ( NULL != pszStrings )
					{
                        try
                        {
					        // Clear out the memory to be especially safe.
					        ZeroMemory( pszStrings, Size );

						    if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																									    ulProperty,
																									    &Type,
																									    pszStrings,
																									    &Size,
																									    0 ) ) )
						    {
							    // For REG_SZ, add a single entry to the array
							    if ( REG_SZ == Type )
							    {
								    strArray.Add( pszStrings );
							    }
							    else if ( REG_MULTI_SZ == Type )
							    {
								    // Add strings to the array, watching out for the double NULL
								    // terminator for the array

								    LPSTR	pszTemp = pszStrings;

								    do
								    {
									    strArray.Add( pszTemp );
									    pszTemp += ( lstrlen( pszTemp ) + 1 );
								    } while ( NULL != *pszTemp );
							    }
							    else
							    {
								    cr = CR_WRONG_TYPE;
							    }

						    }	// If Got value
                        }
                        catch ( ... )
                        {
                            delete [] pszStrings;
                            throw ;
                        }

						delete [] pszStrings;

					}	// IF alloc pszStrings
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
				}	// IF REG_SZ or REG_MULTI_SZ
				else
				{
					cr = CR_WRONG_TYPE;
				}

			}	// IF got size of entry
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
#endif

	return bRet ;
}

BOOL CConfigMgrDevice::GetBusInfo( INTERFACE_TYPE *pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap *pResourceMap/*=NULL*/  )
{
	CMBUSTYPE		busType = 0;
	ULONG			ulSizeOfInfo = 0;
	PBYTE			pbData = NULL;
	BOOL			fReturn = FALSE;

	// Farm out to the appropriate handler
#if NTONLY > 4
	fReturn = GetBusInfoNT5( pitBusType, pdwBusNumber );
#endif
#if NTONLY == 4
	fReturn = GetBusInfoNT4( pitBusType, pdwBusNumber, pResourceMap );
#endif
#ifdef WIN9XONLY
	{
		// Buffer for data.  Should be big enough for any of the values we come across.
		BYTE		abData[255];

		ulSizeOfInfo = sizeof(abData);

		// Get the type and number.  If the type is PCI, then get the PCI info, and this
		// will return a Bus Number value.  If it returns a type other than PCI, then
		// we will assume a bus number of 0.
		CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
		if ( pconfigmgr )
		{
			if ( pconfigmgr->IsValid () )
			{
				CONFIGRET	cr = pconfigmgr->CM_Get_Bus_Info( m_dn, &busType, &ulSizeOfInfo, abData, 0 );

				if ( CR_SUCCESS == cr )
				{
					// Make sure we can convert from a 16-bit type to a known 32-bit type.
					// BusType_None will usually fail this, in which case we can call it
					// quits.

					if ( BusType16ToInterfaceType( busType, pitBusType ) )
					{

						if ( BusType_PCI == busType )
						{
							sPCIAccess *pPCIInfo = (sPCIAccess*) abData;
							*pdwBusNumber = pPCIInfo->bBusNumber;
						}
						else
						{
							*pdwBusNumber = 0;
						}

					}	// IF 16-32bit conversion
					else
					{
						cr = CR_FAILURE;
					}

				}	// CR_SUCCESS == cr

				fReturn = ( CR_SUCCESS == cr );
			}
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
		}
	}	// else !IsWinNT
#endif
	return fReturn;
}

#if NTONLY > 4
// This is to hack around W2K problem where Cfg Mgr devices report they're
// using Isa on boxes that have Eisa and not Isa.
BOOL CConfigMgrDevice::IsIsaReallyEisa()
{
    static bRet = -1;

    if (bRet == -1)
    {
        // FYI: This code based on code from motherboard.cpp.

        CRegistry   regAdapters;
	    CHString    strPrimarySubKey;
	    HRESULT     hRc = WBEM_E_FAILED;
	    DWORD       dwPrimaryRc;

        // If anything below fails, we'll just assume Isa really is Isa.
        bRet = FALSE;

        //****************************************
        //  Open the registry
        //****************************************
        if (regAdapters.OpenAndEnumerateSubKeys(
            HKEY_LOCAL_MACHINE,
            L"HARDWARE\\Description\\System",
            KEY_READ) == ERROR_SUCCESS)
        {
    	    BOOL    bDone = FALSE,
                    bIsaFound = FALSE,
                    bEisaFound = FALSE;

            // Our goal is to find any subkey that has the string "Adapter" in
            // it and then read the "Identifier" value.
            for ( ;
                (!bIsaFound || !bEisaFound) &&
                ((dwPrimaryRc = regAdapters.GetCurrentSubKeyName(strPrimarySubKey))
                    == ERROR_SUCCESS);
                regAdapters.NextSubKey())
            {
                strPrimarySubKey.MakeUpper();

                // If this is one of the keys we want since it has "Adapter" in
                // it then get the "Identifier" value.
		        if (wcsstr(strPrimarySubKey, L"ADAPTER"))
                {
                    WCHAR		szKey[_MAX_PATH];
			        CRegistry	reg;

                    swprintf(
				        szKey,
				        L"%s\\%s",
                        L"HARDWARE\\Description\\System",
				        (LPCWSTR) strPrimarySubKey);

                    if (reg.OpenAndEnumerateSubKeys(
                        HKEY_LOCAL_MACHINE,
                        szKey,
                        KEY_READ) == ERROR_SUCCESS)
                    {
				        CHString strSubKey;

        	            // Enumerate the  system components (like 0,1,...).
                        for ( ;
                            reg.GetCurrentSubKeyName(strSubKey) == ERROR_SUCCESS;
                            reg.NextSubKey())
                        {
                            CHString strBus;

                            if (reg.GetCurrentSubKeyValue(L"Identifier",
                                strBus) == ERROR_SUCCESS)
                            {
				                if (strBus == L"ISA")
                                    bIsaFound = TRUE;
                                else if (strBus == L"EISA")
                                    bEisaFound = TRUE;
                            }
                        }
                    }
                }
            }

            // If we found Eisa but not Isa, assume Cfg Mgr devices that report they're
            // using Isa are actually using Eisa.
            if (!bIsaFound && bEisaFound)
                bRet = TRUE;
	    }
    }

    return bRet;
}
#endif

#if NTONLY > 4
INTERFACE_TYPE CConfigMgrDevice::ConvertBadIsaBusType(INTERFACE_TYPE type)
{
    if (type == Isa && IsIsaReallyEisa())
        type = Eisa;

    return type;
}
#endif

#if NTONLY > 4
BOOL CConfigMgrDevice::GetBusInfoNT5( INTERFACE_TYPE *pitBusType, LPDWORD pdwBusNumber )
{
	ULONG			ulSizeOfInfo = 0;
	CONFIGRET		cr;

	// Bus Number and Type are retrieved via the Registry function.  This will only
	// work on NT 5.
	BOOL bRet = FALSE ;
	DWORD			dwType = 0;
	DWORD			dwBusNumber;
	INTERFACE_TYPE	BusType;

	ulSizeOfInfo = sizeof(DWORD);
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						CM_DRP_BUSNUMBER,
																						&dwType,
																						&dwBusNumber,
																						&ulSizeOfInfo,
																						0 ) ) )
			{
				*pdwBusNumber = dwBusNumber;

				ulSizeOfInfo = sizeof(BusType);

				if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																							CM_DRP_LEGACYBUSTYPE,
																							&dwType,
																							&BusType,
																							&ulSizeOfInfo,
																							0 ) ) )
				{
					*pitBusType = ConvertBadIsaBusType(BusType);
				}	// IF GetBusType

			}	// IF GetBusNumber
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}

	return bRet ;
}
#endif

#if NTONLY == 4
BOOL CConfigMgrDevice::GetBusInfoNT4( INTERFACE_TYPE *pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL			fReturn = FALSE;
	CHString		strService;

	if ( GetService( strService ) )
	{
		CNT4ServiceToResourceMap*	pLocalMap = pResourceMap;

		// Instantiate a resource map if we need one.  Then look for
		// resources for this service

		if ( NULL == pLocalMap )
		{
			pLocalMap = new CNT4ServiceToResourceMap;
		}

		if ( NULL != pLocalMap )
		{
            try
            {
			    if ( 0 != pLocalMap->NumServiceResources( strService ) )
			    {
				    LPRESOURCE_DESCRIPTOR	pResource = pLocalMap->GetServiceResource( strService, 0 );

				    // If we got a resource, then use its BUS information directly to populate
				    // our values.

				    if ( NULL != pResource )
				    {
					    fReturn = TRUE;
					    *pitBusType = pResource->InterfaceType;
					    *pdwBusNumber = pResource->Bus;
				    }

			    }	// If there are resources for this service
            }
            catch ( ... )
            {
			    if ( pLocalMap != pResourceMap )
			    {
				    delete pLocalMap;
			    }
                throw ;
            }

			// Delete the local map if we allocated one.
			if ( pLocalMap != pResourceMap )
			{
				delete pLocalMap;
			}

		}	// if pLocalMap
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// If got service name

	return fReturn;
}
#endif

BOOL CConfigMgrDevice::BusType16ToInterfaceType( CMBUSTYPE cmBusType16, INTERFACE_TYPE *pinterfaceType )
{

	BOOL	fReturn = TRUE;

//	These are the enums defined for NT, so we'll standardize on these
//
//	typedef enum Interface_Type {
//		Internal,
//		Isa,
//		Eisa,
//		MicroChannel,
//		TurboChannel,
//		PCIBus,
//		VMEBus,
//		NuBus,
//		PCMCIABus,
//		CBus,
//		MPIBus,
//		MPSABus,
//		MaximumInterfaceType
//	}INTERFACE_TYPE;
//

	switch ( cmBusType16 )
	{
		case BusType_ISA:
		{
			*pinterfaceType = Isa;
		}
		break;

		case BusType_EISA:
		{
			*pinterfaceType = Eisa;
		}
		break;

		case BusType_PCI:
		{
			*pinterfaceType = PCIBus;
		}
		break;

		case BusType_PCMCIA:
		{
			*pinterfaceType = PCMCIABus;
		}
		break;

		case BusType_ISAPNP:
		{
			// Closest match I could find
			*pinterfaceType = Isa;
		}
		break;

		case BusType_MCA:
		{
			*pinterfaceType = MicroChannel;
		}
		break;

		case BusType_BIOS:
		{
			*pinterfaceType = Internal;
		}
		break;

		default:
		{
			// Couldn't make the conversion (e.g. BusType_None)
			fReturn = FALSE;
		}
	}

	return fReturn;
}

// Registry Access functions.  Sometimes we want to access the registry directly because
// the device in question places private values in there that our regular functions cannot
// access.
BOOL CConfigMgrDevice::GetRegistryKeyName( CHString &strName)
{
	CHString	strDeviceID;
    BOOL bRet = TRUE;

    if ( GetDeviceID(strDeviceID) )
	{

		// Build the correct key
#ifdef NTONLY
			strName = _T("SYSTEM\\CurrentControlSet\\Enum\\");
#endif
#ifdef WIN9XONLY
			strName = _T("Enum\\");
#endif

		strName += strDeviceID;
    }
    else
    {
        bRet = false;
    }

    return bRet;
}

//
//	Constructor and Destructor for the Device Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceCollection::CDeviceCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceCollection::CDeviceCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceCollection::~CDeviceCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceCollection::~CDeviceCollection( void )
{
}

BOOL CDeviceCollection::GetResourceList( CResourceCollection& resourceList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CResourceCollection	deviceresourceList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

#ifdef NTONLY
	CNT4ServiceToResourceMap*	pResourceMap = NULL;

	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}

    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the Resource List first

	resourceList.Empty();

	if ( BeginEnum( pos ) )
	{

		// Get the resource list from the device, then append it
		// to the list passed in to us.

		for ( pDevice.Attach(GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach(GetNext( pos ) ) )
		{
#ifdef NTONLY
			pDevice->GetResourceList( deviceresourceList, pResourceMap );
#endif
#ifdef WIN9XONLY
			pDevice->GetResourceList( deviceresourceList, NULL );
#endif
			resourceList.Append( deviceresourceList );

		}	// WHILE enuming devices

		EndEnum();

	}
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetIRQResources( CIRQCollection& IRQList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CIRQCollection		deviceIRQList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the IRQ List first

	IRQList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device, get the IRQs and append them to the
		// supplied IRQ list

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetIRQResources( deviceIRQList, pResourceMap );
			IRQList.Append( deviceIRQList );

		}	// for all devices

		EndEnum();

	}	// Begin Enum
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetIOResources( CIOCollection& IOList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CIOCollection		deviceIOList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the IO List first

	IOList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device, get the IO Port List and append
		// it to the supplied list of IO Ports.

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetIOResources( deviceIOList, pResourceMap );
			IOList.Append( deviceIOList );

		}	// for all devices

		EndEnum();

	}	// BeginEnum
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetDMAResources( CDMACollection& DMAList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CDMACollection		deviceDMAList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the DMA List first

	DMAList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device, get the DMA resources and append them
		// to the supplied list of DMA resources

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetDMAResources( deviceDMAList, pResourceMap );
			DMAList.Append( deviceDMAList );

		}	// for all devices

	}	// BeginEnum
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CDeviceMemoryCollection	memoryList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the DeviceMemory List first

	DeviceMemoryList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device get the list of Memory Resources and
		// append it to the list of supplied Memory Resources.

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetDeviceMemoryResources( memoryList, pResourceMap );
			DeviceMemoryList.Append( memoryList );

		}	// for all devices

		EndEnum();

	}	// BeginEnum()
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

#define MAX_DOS_DEVICES 8192

/*****************************************************************************
 *
 *  FUNCTION    : QueryDosDeviceNames
 *
 *  DESCRIPTION : Queries for all Dos Device symbolic links
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL WINAPI QueryDosDeviceNames ( TCHAR *&a_DosDeviceNameList )
{
	BOOL t_Status = FALSE ;

	BOOL	bContinue = TRUE ;
	ULONG	ulDosDevices = MAX_DOS_DEVICES ;

	do
	{
		//
		// let's finish loop
		//
		bContinue = FALSE ;

		CSmartBuffer pQueryBuffer ( ( ulDosDevices * sizeof ( TCHAR ) ) );

		DWORD t_QueryStatus = QueryDosDevice ( NULL , (LPTSTR)((LPBYTE)pQueryBuffer) , ulDosDevices ) ;
		if ( t_QueryStatus )
		{
			a_DosDeviceNameList = new TCHAR [ t_QueryStatus ] ;
			if (a_DosDeviceNameList == NULL)
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			memcpy ( a_DosDeviceNameList , (void*)((LPBYTE)pQueryBuffer) , t_QueryStatus * sizeof ( TCHAR ) ) ;

			t_Status = TRUE;
		}
		else
		{
			if ( STATUS_BUFFER_TOO_SMALL == (NTSTATUS)NtCurrentTeb()->LastStatusValue )
			{
				//
				// let's continue if the reason of failure 
				// is just small buffer here
				//
				ulDosDevices = ulDosDevices * 2 ;
				bContinue = TRUE ;
			}
		}
	}
	while ( bContinue ) ;

	return t_Status ;
}

/*****************************************************************************
 *
 *  FUNCTION    : FindDosDeviceName
 *
 *  DESCRIPTION : Finds the dos device symbolic link given an NT device name
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#define MAX_MAPPED_DEVICES 26
#define MAX_DEVICENAME_LENGTH 256

BOOL WINAPI FindDosDeviceName ( const TCHAR *a_DosDeviceNameList , const CHString a_SymbolicName , CHString &a_DosDevice , BOOL a_MappedDevice )
{
	BOOL t_Status = FALSE ;

	CSmartBuffer t_MappedDevices ;

	if ( a_MappedDevice )
	{
		DWORD t_Length = GetLogicalDriveStrings ( 0 , NULL ) ;

        if (t_Length)
        {
            LPBYTE t_buff = new BYTE[(t_Length + 1)  * sizeof(TCHAR)];

            if (t_buff == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            t_MappedDevices = t_buff;

            if (!GetLogicalDriveStrings ( t_Length , (LPTSTR)((LPBYTE)t_MappedDevices) ) )
            {
                DWORD t_Error = GetLastError () ;
                return FALSE;
            }
        }
        else
        {
            DWORD t_Error = GetLastError () ;
            return FALSE;
        }
	}

	const TCHAR *t_Device = a_DosDeviceNameList ;
	while ( *t_Device != NULL )
	{
		CSmartBuffer pQueryBuffer ((MAX_DOS_DEVICES * sizeof (TCHAR)));

		DWORD t_QueryStatus = QueryDosDevice ( t_Device , (LPTSTR)((LPBYTE)pQueryBuffer) , MAX_DOS_DEVICES ) ;
		if ( t_QueryStatus )
		{
			TCHAR *t_Symbolic = (LPTSTR)((LPBYTE)pQueryBuffer) ;

			while ( *t_Symbolic != NULL )
			{
				if ( _wcsicmp ( a_SymbolicName , TOBSTRT(t_Symbolic) ) == 0 )
				{
/*
 *	Atleast get a match even if there is no mapped drive
 */
					t_Status = TRUE ;
					a_DosDevice = t_Device ;

					if ( a_MappedDevice )
					{
						const TCHAR *t_CurrentDevice = (const LPTSTR)((LPBYTE)t_MappedDevices) ;
						while ( *t_CurrentDevice != NULL )
						{
							if ( _tcsnicmp ( t_Device, t_CurrentDevice , 2 ) == 0 )
							{
								t_Status = TRUE ;
								a_DosDevice = t_Device ;
								return TRUE ;
							}

							t_CurrentDevice = t_CurrentDevice + _tcslen ( t_CurrentDevice ) + 1 ;
						}
					}
					else
					{
						return TRUE ;
					}
				}

				t_Symbolic = t_Symbolic + _tcslen ( t_Symbolic ) + 1 ;
			}
		}
		else
		{
			DWORD t_Error = GetLastError () ;
		}

		t_Device = t_Device + _tcslen ( t_Device ) + 1 ;
	}

	return t_Status ;
}

BOOL CConfigMgrDevice::IsClass(LPCWSTR pwszClassName)
{
    BOOL bRet = FALSE;
    CHString sTemp;

    if (GetClass(sTemp))
    {
        if (sTemp.CompareNoCase(pwszClassName) == 0)
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        CHString sClass(pwszClassName);
        sClass.MakeUpper();

        WCHAR cGuid[128];
        GUID gFoo = CConfigManager::s_ClassMap[sClass];
        StringFromGUID2(gFoo, cGuid, sizeof(cGuid)/sizeof(WCHAR));
        if (GetClassGUID(sTemp) && (sTemp.CompareNoCase(cGuid) == 0))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL CConfigMgrDevice::GetRegStringProperty(
    LPCWSTR szProperty,
    CHString &strValue)
{
    CHString    strKeyName;
    DWORD       dwRet;
    CRegistry   reg;

    if (GetRegistryKeyName(strKeyName) &&
        (dwRet = reg.Open(HKEY_LOCAL_MACHINE, strKeyName,
        KEY_QUERY_VALUE) == ERROR_SUCCESS))
    {
        dwRet = reg.GetCurrentKeyValue(szProperty, strValue);
    }

    return dwRet == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ccriticalsec.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CCriticalSec.cpp -- Critical Section Wrapper

//

//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#include "precomp.h"
#include "CCriticalSec.h"

DWORD  BreakOnDbgAndRenterLoop(void)
{
    __try
    { 
        DebugBreak();
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {};
    
    return EXCEPTION_CONTINUE_EXECUTION;
};

BOOL CStaticCritSec::anyFailed_ = FALSE; 


CStaticCritSec::CStaticCritSec(): initialized_(false)  
{
    InitializeCriticalSectionAndSpinCount(this,0)?(initialized_ = true) :(anyFailed_ = TRUE);
}
 
CStaticCritSec::~CStaticCritSec()
{
    if(initialized_)
        DeleteCriticalSection(this);
}

void CStaticCritSec::Enter()
    {
        __try {
          EnterCriticalSection(this);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }

void CStaticCritSec::Leave()
    {
        LeaveCriticalSection(this);
    }


BOOL CStaticCritSec::anyFailure()
{ 
    return anyFailed_;
};

void CStaticCritSec::SetFailure()
{
    anyFailed_ = TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cglobal.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CGlobal.h -- Global declarations

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================


#ifndef __CGLOBAL_H__
#define __CGLOBAL_H__


#include <windows.h>
#include <process.h>
#include <winerror.h>
#include <stdio.h>
#include <brodcast.h>
#include <dllutils.h>

#define ERR_LOG_FILE _T("c:\\temp\\test.txt")

// forward class declarations to make the compiler happy...
class CWaitableObject;
class CWaitableCollection;
class CKernel;
class CMutex;
class CSemaphore;
class CEvent;
class CThread;
class CCriticalSec;
class CAutoLock;
class CMonitor;
class CSharedMemory;
class CMailbox;

// defined symbol determines if CThrowError throws exceptions
// or just prints debug error messages...
#ifndef __C_THROW_EXCEPTIONS__
#define __C_THROW_EXCEPTIONS__   TRUE
#endif

// for higher level objects which might have to check internal
// object status when exceptions are disabled, these macros can be useful...

// PTR is the smart pointer to check for NULL, 
// STATUS is the variable in which to store an error code if an error is detected...
#if __C_THROW_EXCEPTIONS__
#define C_CHECK_AUTOPTR_OBJECT(PTR,STATUS) if ((PTR).IsNull()) { /*CThrowError(ERROR_OUTOFMEMORY);*/ LogMessage2(L"CAutoLock Error: %d", ERROR_OUTOFMEMORY); }
#else
#define C_CHECK_AUTOPTR_OBJECT(PTR,STATUS) if ((PTR).IsNull()) { (STATUS) = ERROR_OUTOFMEMORY; return; }
#endif

// SCODE is the return value to check,
// STATUS is the variable in which to store an error code if an error is detected...
#if __C_THROW_EXCEPTIONS__
#define C_CHECK_CREATION_STATUS(SCODE,STATUS) {}
#else
#define C_CHECK_CREATION_STATUS(SCODE,STATUS) if (((SCODE)!=NO_ERROR)&&((SCODE)!=ERROR_ALREADY_EXISTS)) { STATUS = (SCODE); return; }
#endif

//// error handling macro and function...
//#define CThrowError(dwStatus) CInternalThrowError((dwStatus), __FILE__, __LINE__)
//extern void CInternalThrowError( DWORD dwStatus, LPCWSTR lpFilename, int line);

// check handle for NULL and INVALID_HANDLE
inline BOOL CIsValidHandle( HANDLE hHandle) {
    return ((hHandle != NULL) && (hHandle != INVALID_HANDLE_VALUE));
}

// validate wait return codes...
inline BOOL CWaitSucceeded( DWORD dwWaitResult, DWORD dwHandleCount) {
    return (dwWaitResult < WAIT_OBJECT_0 + dwHandleCount);
}

inline BOOL CWaitAbandoned( DWORD dwWaitResult, DWORD dwHandleCount) {
    return ((dwWaitResult >= WAIT_ABANDONED_0) &&
            (dwWaitResult < WAIT_ABANDONED_0 + dwHandleCount));
}

inline BOOL CWaitTimeout( DWORD dwWaitResult) {
    return (dwWaitResult == WAIT_TIMEOUT);
}
    
inline BOOL CWaitFailed( DWORD dwWaitResult) {
    return (dwWaitResult == WAIT_FAILED);
}

// compute object indices for waits...
inline DWORD CWaitSucceededIndex( DWORD dwWaitResult) {
    return (dwWaitResult - WAIT_OBJECT_0);
}

inline DWORD CWaitAbandonedIndex( DWORD dwWaitResult) {
    return (dwWaitResult - WAIT_ABANDONED_0);
}

// Log messages
inline DWORD LogMsg(LPCTSTR szMsg, LPCTSTR szFileName = ERR_LOG_FILE)
{    
    SYSTEMTIME systime;
    GetSystemTime(&systime);
    {
        TCHAR szTime[64];
        ZeroMemory(szTime,sizeof(szTime));
        wsprintf(szTime,_T("(%02d:%02d:%02d.%04d) "),systime.wHour,systime.wMinute,systime.wSecond,systime.wMilliseconds);
        LogMessage3((LPCWSTR)TOBSTRT(_T("%s%s")), TOBSTRT(szTime), TOBSTRT(szMsg));
    }
    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cglobal.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CGlobal.cpp -- Global functions

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CGlobal.h"
/*
void CInternalThrowError(DWORD dwStatus, LPCWSTR lpFilename, int line)
{
#ifdef _DEBUG
    // print the error for debug builds...
    WCHAR string[2*MAX_PATH];
    wsprintf( string, "C Library Win32 Error 0x%08x(%d) at %s line %d\n",
                dwStatus, dwStatus, lpFilename, line);
    OutputDebugString(string);
#endif

#if __C_THROW_EXCEPTIONS__
    // throw exception for fatal errors...
    throw dwStatus;
#endif
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\chwres.h ===
//=================================================================

//

// chwres.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

// Pseudo handle type definition.
#define HREGKEY     LPKEY

// Single value description within a key.
typedef struct _VALUE
{
   LPTSTR  Name;
   DWORD   Type;
}  VALUE, *LPVALUE;

// Macro to initialize a value description table entry.
//
//  v   - value name
//  t   - value type

#define MakeValue( v, t )                                              \
{                                                                      \
   #v,                                                                 \
   REG_##t                                                             \
}


// Single key description. Points to a table of value descriptions.
typedef struct _KEY
{
    HKEY    ParentHandle;
    LPTSTR  Name;
    DWORD   CountOfValues;
    LPVALUE Values;
    HKEY    hKey;
    LPBYTE  Data;
    DWORD   Size;
    LPTSTR  ValueName;
    DWORD   ValueNameLength;
    LPTSTR  Subkey;
    DWORD   SubkeyLength;
    DWORD   Subkeys;
    DWORD   Type;
    DWORD   CurrentSize;
    DWORD   CurrentValueNameLength;
    DWORD   CurrentValue;
    DWORD   CurrentSubkeyLength;
    DWORD   CurrentSubkey;
}   KEY, *LPKEY;

// Macro to initialize a subkey description.
//
//  k   - key variable name
//  h   - parent handle (HREGKEY)
//  n   - key name (path)

#define InitializeKey( k, h, n )                                            \
    {                                                                       \
        ( k )->ParentHandle             = h->hRegKey;                       \
        ( k )->Name                     = n;                                \
        ( k )->CountOfValues            = 0;                                \
        ( k )->Values                   = NULL;                             \
        ( k )->hKey                     = NULL;                             \
        ( k )->Data                     = NULL;                             \
        ( k )->Size                     = 0;                                \
        ( k )->ValueName                = NULL;                             \
        ( k )->ValueNameLength          = 0;                                \
        ( k )->Subkey                   = NULL;                             \
        ( k )->SubkeyLength             = 0;                                \
        ( k )->Subkeys                  = 0;                                \
        ( k )->Type                     = REG_NONE;                         \
        ( k )->CurrentSize              = 0;                                \
        ( k )->CurrentValueNameLength   = 0;                                \
        ( k )->CurrentValue             = 0;                                \
        ( k )->CurrentSubkeyLength      = 0;                                \
        ( k )->CurrentSubkey            = 0;                                \
    }

// Macro to statically initialize a key description.
//
//  k   - key variable name
//  h   - parent handle
//  n   - key name (path)
//  v   - count of values in table
//  t   - pointer to values table
//

#define MakeKey( k, h, n, v, t )                                            \
    KEY                                                                     \
    k = {                                                                 \
          h,                                                                  \
          n,                                                                  \
          v,                                                                  \
          t,                                                                  \
          NULL,                                                               \
          NULL,                                                               \
          0,                                                                  \
          NULL,                                                               \
          0,                                                                  \
          NULL,                                                               \
          0,                                                                  \
          0,                                                                  \
          REG_NONE,                                                           \
          0,                                                                  \
          0,                                                                  \
          0,                                                                  \
          0,                                                                  \
          0                                                                   \
        }


class ClRegistry {
public:
   BOOL CloseRegistryKey(HREGKEY Handle);
   BOOL QueryNextValue(HREGKEY Handle);
   HREGKEY OpenRegistryKey(LPKEY Key);
   HREGKEY QueryNextSubkey(HREGKEY Handle);
};

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

// ntconfig.h defines this as an int
#ifndef _NTCONFIG_
typedef enum _CM_RESOURCE_TYPE {
    CmResourceTypeNull = 0,    // Reserved
    CmResourceTypePort,
    CmResourceTypeInterrupt,
    CmResourceTypeMemory,
    CmResourceTypeDma,
    CmResourceTypeDeviceSpecific
} CM_RESOURCE_TYPE;

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

#endif
//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY 0x0000
#define CM_RESOURCE_PORT_IO 0x0001

#ifndef _NTCONFIG_
typedef enum Interface_Type {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE;
#endif


#define REG_RESOURCE_LIST            ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description


// ntconfig.h defines this
#ifndef _NTCONFIG_
#pragma pack(4)
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;


#pragma pack()
#endif

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

// ntconfig.h defines this
#ifndef _NTCONFIG_
typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;
#endif

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

// ntconfig.h defines this
#ifndef _NTCONFIG_
typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;
#endif

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// Note2: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

// ntconfig.h defines this
#ifndef _NTCONFIG_
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;
#endif

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

// ntconfig.h defines this as an int
#ifndef _NTCONFIG_
typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;
#endif

typedef struct _RESOURCE_DESCRIPTOR *LPRESOURCE_DESCRIPTOR;
typedef struct _DEVICE              *LPDEVICE;


typedef struct _RESOURCE_DESCRIPTOR 
{
  CM_PARTIAL_RESOURCE_DESCRIPTOR  CmResourceDescriptor;
  LPRESOURCE_DESCRIPTOR           NextSame;
  LPRESOURCE_DESCRIPTOR           NextDiff;
  LPDEVICE                        Owner;
  ULONG                           Bus;
  INTERFACE_TYPE                  InterfaceType;
} RESOURCE_DESCRIPTOR;

typedef struct _DEVICE 
{
   LPTSTR                          Name;
   LPRESOURCE_DESCRIPTOR           ResourceDescriptorHead;
   LPRESOURCE_DESCRIPTOR           ResourceDescriptorTail;
   LPDEVICE                        Next;
   LPTSTR                          KeyName;
} DEVICE;
                                    
typedef struct _SYSTEM_RESOURCES 
{                 
    LPDEVICE                        DeviceHead;
    LPDEVICE                        DeviceTail;
    LPRESOURCE_DESCRIPTOR           DmaHead;
    LPRESOURCE_DESCRIPTOR           DmaTail;
    LPRESOURCE_DESCRIPTOR           InterruptHead;
    LPRESOURCE_DESCRIPTOR           InterruptTail;
    LPRESOURCE_DESCRIPTOR           MemoryHead;
    LPRESOURCE_DESCRIPTOR           MemoryTail;
    LPRESOURCE_DESCRIPTOR           PortHead;
    LPRESOURCE_DESCRIPTOR           PortTail;
}   SYSTEM_RESOURCES, *LPSYSTEM_RESOURCES;

// Helper function for converting interface_type values to strings
BOOL WINAPI StringFromInterfaceType( INTERFACE_TYPE it, CHString& strVal );

#ifdef NTONLY
class CHWResource {

    public :

        CHWResource() ;
       ~CHWResource() ;

        void CreateSystemResourceLists(void);
        void DestroySystemResourceLists();

        SYSTEM_RESOURCES _SystemResourceList ;

    private :

        void EnumerateResources(CHString sKeyName);
        void CreateResourceList(CHString sDeviceName,
                                DWORD dwResourceCount,
                                PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, CHString sKeyName);
        void CreateResourceRecord(LPDEVICE pDevice, INTERFACE_TYPE Interface, ULONG Bus,
                                  PCM_PARTIAL_RESOURCE_DESCRIPTOR pResource);


} ;

#endif

#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\chwres.cpp ===
//====================================================================

//

// chwres.cpp -- Hardware resource access wrapper class implementation

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/25/97    a-jmoon    Adapted from original horrible
//                                      code -- only comments remain.
//
//====================================================================
#include "precomp.h"
#include <cregcls.h>
#include "chwres.h"

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::CHWResource
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Initialization
 *
 *****************************************************************************/

#ifdef NTONLY
CHWResource::CHWResource()
{
    // Zero out public structure
    //==========================

    memset(&_SystemResourceList, 0, sizeof(_SystemResourceList)) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::~CHWResource
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Cleanup
 *
 *****************************************************************************/

CHWResource::~CHWResource()
{
    // Make sure we've destroyed everything
    //=====================================

    DestroySystemResourceLists() ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::DestroySystemResourceLists
 *
 *  DESCRIPTION : Walks list of devices & frees associated resource records
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CHWResource::DestroySystemResourceLists()
{
    LPDEVICE pDevice ;
    LPRESOURCE_DESCRIPTOR pResource ;

    while(_SystemResourceList.DeviceHead != NULL)
    {
        pDevice = _SystemResourceList.DeviceHead ;
        _SystemResourceList.DeviceHead = pDevice->Next ;

        delete pDevice->Name ;
        delete pDevice->KeyName ;

        while(pDevice->ResourceDescriptorHead != NULL)
        {
            pResource = pDevice->ResourceDescriptorHead ;
            pDevice->ResourceDescriptorHead = pResource->NextDiff ;

            delete pResource ;
        }

        delete pDevice ;
    }

    memset(&_SystemResourceList, 0, sizeof(_SystemResourceList)) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::CreateSystemResourceLists
 *                CHWResource::EnumerateResources
 *                CHWResource::CreateResourceList
 *                CHWResource::CreateResourceRecord
 *
 *  DESCRIPTION : These four routines recursively enumerate device records
 *                under HKEY_LOCAL_MACHINE\Hardware\ResourceMap and its
 *                subkeys, creating a linked list of discovered devices.
 *                Under each device, a linked list of resources owned by
 *                the device is also created.  Resource records are also
 *                linked into chains specific to the type of resource.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Initialization
 *
 *****************************************************************************/

void CHWResource::CreateSystemResourceLists()
{
    // Start w/clean slate
    //====================

    DestroySystemResourceLists() ;

    // Begin device enumeration at HKLM\Hardware\ResourceMap
    //======================================================

    EnumerateResources(_T("Hardware\\ResourceMap")) ;
}

void CHWResource::EnumerateResources(CHString sKeyName)
{
    CRegistry Reg ;
    CHString sSubKeyName, sDeviceName ;
    int iFirst ;
    DWORD i, dwCount, dwValueType, dwValueNameSize, dwValueDataSize ;
    TCHAR *pValueName ;
    unsigned char *pValueData ;
    PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor ;

    // Open target key
    //================

    if(Reg.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) sKeyName, KEY_READ) != ERROR_SUCCESS)
    {
        return ;
    }

    // First, enumerate subkeys
    //=========================

    for( ; ; )
    {
        if(Reg.GetCurrentSubKeyName(sSubKeyName) == ERROR_SUCCESS)
        {
            EnumerateResources(sKeyName + "\\" + sSubKeyName) ;
        }

        if(Reg.NextSubKey() != ERROR_SUCCESS)
        {
            break ;
        }
    }

    // Extract this subkey's name
    //===========================

    iFirst = sKeyName.ReverseFind('\\') ;
    sSubKeyName = sKeyName.Mid(iFirst + 1, sKeyName.GetLength() - iFirst) ;

    // Create name & data buffers
    //===========================

    pValueName = new TCHAR[Reg.GetLongestValueName() + 2] ;
    pValueData = new unsigned char[Reg.GetLongestValueData() + 2] ;

    if(pValueName == NULL || pValueData == NULL)
    {

        delete [] pValueName ;
        delete [] pValueData ;

        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    // Enumerate subkeys
	//==================

    try
    {
        for(i = 0 ; i < Reg.GetValueCount() ; i++)
        {

            // We need type data, so can't use the CRegistry wrapper
            //======================================================

            dwValueNameSize = Reg.GetLongestValueName() + 2 ;
            dwValueDataSize = Reg.GetLongestValueData() + 2 ;

            if(RegEnumValue(Reg.GethKey(), i, pValueName, &dwValueNameSize,
                            NULL, &dwValueType, pValueData, &dwValueDataSize) != ERROR_SUCCESS)
            {
                continue ;
            }

            // Only deal w/'Raw' data
            //=======================

            sDeviceName = pValueName ;
            if(sDeviceName.Right(4) != _T(".Raw")) {

                continue ;
            }

            // We've found some resource records -- extract device name
            //=========================================================

            iFirst = sDeviceName.ReverseFind('\\') ;
            if(iFirst == -1)
            {
                // No device in value name -- device is subkey
                //============================================

                sDeviceName = sSubKeyName ;
            }
            else
            {
                sDeviceName = sDeviceName.Mid(iFirst + 1, sDeviceName.GetLength() - 5 - iFirst) ;
            }

            if(sDeviceName.IsEmpty())
            {
                continue ;
            }

            // Based on returned type, set up for resource enumeration
            //========================================================

            if(dwValueType == REG_FULL_RESOURCE_DESCRIPTOR)
            {
                dwCount         = 1 ;
                pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) pValueData ;
            }
            else if(dwValueType == REG_RESOURCE_LIST)
            {
                dwCount         = ((PCM_RESOURCE_LIST) pValueData)->Count ;
                pFullDescriptor = ((PCM_RESOURCE_LIST) pValueData)->List ;
            }
            else
            {
                continue ;
            }

            // Add the device & resources to system lists
            //===========================================

            CreateResourceList(sDeviceName, dwCount, pFullDescriptor, sKeyName) ;
        }
    }
    catch ( ... )
    {
        delete [] pValueName ;
        delete [] pValueData ;

        throw;
    }

    delete [] pValueName ;
    delete [] pValueData ;

    Reg.Close() ;
}

void CHWResource::CreateResourceList(CHString sDeviceName, DWORD dwFullResourceCount,
                                     PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, CHString sKeyName)
{
    LPDEVICE pDevice ;
    DWORD i, j ;
    PCM_PARTIAL_RESOURCE_LIST pPartialList ;

    // Locate/create record for device
    //================================

    pDevice = _SystemResourceList.DeviceHead ;
    while(pDevice != NULL)
    {

        if(sDeviceName == pDevice->Name)
        {

            break ;
        }

        pDevice = pDevice->Next ;
    }

    if(pDevice == NULL)
    {

        // Device not found -- create new device record
        //=============================================

        pDevice = new DEVICE ;
        if(pDevice == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        memset(pDevice, 0, sizeof(DEVICE)) ;

        pDevice->Name = new TCHAR[sDeviceName.GetLength() + 2] ;
        if(pDevice->Name == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        try
        {
            _tcscpy(pDevice->Name, LPCTSTR(sDeviceName)) ;

            pDevice->KeyName = new TCHAR [sKeyName.GetLength() + 2] ;
            if(pDevice->KeyName == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            _tcscpy(pDevice->KeyName, LPCTSTR(sKeyName)) ;

            if(_SystemResourceList.DeviceHead == NULL)
            {
                _SystemResourceList.DeviceHead = pDevice ;
            }
            else
            {
                _SystemResourceList.DeviceTail->Next = pDevice ;
            }

            _SystemResourceList.DeviceTail = pDevice ;
        }
        catch ( ... )
        {
            delete pDevice;
            throw ;
        }
    }

    // Create record for each owned resource
    //======================================

    for(i = 0 ; i < dwFullResourceCount ; i++)
    {
        pPartialList = &pFullDescriptor->PartialResourceList ;

        for(j = 0 ; j < pPartialList->Count; j++)
        {
            CreateResourceRecord(pDevice, pFullDescriptor->InterfaceType, pFullDescriptor->BusNumber, &pPartialList->PartialDescriptors[j]) ;
        }

        // Point to next full descriptor
        //==============================

        pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;
    }
}

void CHWResource::CreateResourceRecord(LPDEVICE pDevice, INTERFACE_TYPE InterfaceType, ULONG Bus, PCM_PARTIAL_RESOURCE_DESCRIPTOR pResource)
{
    LPRESOURCE_DESCRIPTOR pNewResource, *pHead, *pTail, pCurrent, pLast ;

    // Only deal w/'known' resource types
    //===================================

    if(pResource->Type != CmResourceTypePort        &&
       pResource->Type != CmResourceTypeInterrupt   &&
       pResource->Type != CmResourceTypeMemory      &&
       pResource->Type != CmResourceTypeDma         )
    {
        return ;
    }

    // Create new record for resource & add to device's list
    //======================================================

    pNewResource = new RESOURCE_DESCRIPTOR ;
    if(pNewResource == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
        memset(pNewResource, 0, sizeof(RESOURCE_DESCRIPTOR)) ;

        memcpy(&pNewResource->CmResourceDescriptor, pResource, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)) ;

        pNewResource->Owner = pDevice ;
        pNewResource->Bus = Bus;
        pNewResource->InterfaceType = InterfaceType;

        if(pDevice->ResourceDescriptorHead == NULL)
        {

            pDevice->ResourceDescriptorHead = pNewResource ;
        }
        else
        {

            pDevice->ResourceDescriptorTail->NextDiff = pNewResource ;
        }

        pDevice->ResourceDescriptorTail = pNewResource ;
    }
    catch ( ... )
    {
        delete pNewResource;
        throw ;
    }

    // Locate insertion point into sorted type-specific list
    //======================================================

    switch(pResource->Type)
    {
        case CmResourceTypePort :

            pHead = &_SystemResourceList.PortHead ;
            pTail = &_SystemResourceList.PortTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            LARGE_INTEGER liTemp;  // Used to avoid 64bit alignment problems

            liTemp.HighPart = pResource->u.Port.Start.HighPart;
            liTemp.LowPart = pResource->u.Port.Start.LowPart;

            while(pCurrent != NULL)
            {
                LARGE_INTEGER liTemp2;  // Used to avoid 64bit alignment problems

                liTemp2.HighPart = pCurrent->CmResourceDescriptor.u.Port.Start.HighPart;
                liTemp2.LowPart = pCurrent->CmResourceDescriptor.u.Port.Start.LowPart;

                if (liTemp2.QuadPart < liTemp.QuadPart)
                {
                    pLast    = pCurrent ;
                    pCurrent = pCurrent->NextSame ;
                }
                else
                {
                    break;
                }
            }

            break;

        case CmResourceTypeInterrupt :
        {
            pHead = &_SystemResourceList.InterruptHead ;
            pTail = &_SystemResourceList.InterruptTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            ULONGLONG iIRQ = pResource->u.Interrupt.Level;

            // If the IRQ to add is less than the current IRQ, OR
            // if the IRQ to add is the same as the current IRQ and the current
            // IRQ is not an internal one, put it after the current one.  This
            // will make sure that internal IRQs are listed last in the list.
            while (pCurrent != NULL &&
                   ( (pCurrent->CmResourceDescriptor.u.Interrupt.Level < iIRQ) ||
                     ((pCurrent->CmResourceDescriptor.u.Interrupt.Level == iIRQ) &&
                      (pCurrent->InterfaceType != Internal))
                  ))
            {
                pLast    = pCurrent ;
                pCurrent = pCurrent->NextSame ;
            }

            break;
        }

        case CmResourceTypeMemory :
        {

            pHead = &_SystemResourceList.MemoryHead ;
            pTail = &_SystemResourceList.MemoryTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            LARGE_INTEGER liTemp;  // Used to avoid 64bit alignment problems

            liTemp.HighPart = pResource->u.Memory.Start.HighPart;
            liTemp.LowPart = pResource->u.Memory.Start.LowPart;

            while(pCurrent != NULL)
            {
                LARGE_INTEGER liTemp2;  // Used to avoid 64bit alignment problems

                liTemp2.HighPart = pCurrent->CmResourceDescriptor.u.Memory.Start.HighPart;
                liTemp2.LowPart = pCurrent->CmResourceDescriptor.u.Memory.Start.LowPart;

                if (liTemp2.QuadPart < liTemp.QuadPart)
                {
                    pLast    = pCurrent ;
                    pCurrent = pCurrent->NextSame ;
                }
                else
                {
                    break;
                }
            }

            break;
        }

        case CmResourceTypeDma :

            pHead = &_SystemResourceList.DmaHead ;
            pTail = &_SystemResourceList.DmaTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            while(pCurrent != NULL &&
                  pCurrent->CmResourceDescriptor.u.Dma.Channel < pResource->u.Dma.Channel)
            {
                pLast    = pCurrent ;
                pCurrent = pCurrent->NextSame ;
            }

            break;

    }

    // Insert into...
    //===============

    if(*pHead == NULL)
    {

        // ...empty list
        //==========================

        (*pHead) = pNewResource ;
        (*pTail) = pNewResource ;
    }
    else if(pLast == NULL)
    {

        // ...beginning of list
        //=================================

        pNewResource->NextSame = pCurrent ;
        (*pHead)               = pNewResource ;
    }
    else if(pCurrent == NULL)
    {
        // ...end of list
        //=========================

        pLast->NextSame = pNewResource ;
        (*pTail)        = pNewResource ;
    }
    else
    {
        // ...middle of list
        //==============================

        pLast->NextSame        = pNewResource ;
        pNewResource->NextSame = pCurrent ;
    }
}
#endif

// Helper function for converting strings to resource types
BOOL WINAPI StringFromInterfaceType( INTERFACE_TYPE it, CHString& strVal )
{
	//BOOL	fReturn = TRUE;

	//switch ( it )
	//{
	//	case	Internal:			strVal = "INTERNAL";			break;
	//	case	Isa:				strVal = "ISA";					break;
	//	case	Eisa:				strVal = "EISA";				break;
	//	case	MicroChannel:		strVal = "MICROCHANNEL";		break;
	//	case	TurboChannel:		strVal = "TURBOCHANNEL";		break;
	//	case	PCIBus:				strVal = "PCI";					break;
	//	case	VMEBus:				strVal = "VME";					break;
	//	case	NuBus:				strVal = "NU";					break;
	//	case	PCMCIABus:			strVal = "PCMCIA";				break;
	//	case	CBus:				strVal = "INTERNAL";			break;
	//	case	MPIBus:				strVal = "INTERNAL";			break;
	//	case	MPSABus:			strVal = "MPSA";				break;
	//	case	ProcessorInternal:	strVal = "PROCESSORINTERNAL";	break;
	//	case	InternalPowerBus:	strVal = "INTERNALPOWER";		break;
	//	case	PNPISABus:			strVal = "PNPISA";				break;
	//	case	PNPBus:				strVal = "PNP";					break;
	//	default:					fReturn = FALSE;
	//}

    if(it > InterfaceTypeUndefined && it < MaximumInterfaceType)
    {
        strVal = szBusType[it];
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ckernel.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CKernal.cpp -- Wraper for Kernal functions

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CKernel.h"

CKernel::CKernel()
{
    m_hHandle = NULL;
    m_dwStatus = ERROR_INVALID_HANDLE;
}

CKernel::~CKernel()
{
    if (CIsValidHandle(m_hHandle))
    {
        ::CloseHandle(m_hHandle);
        m_hHandle = NULL;
    }
}

void CKernel::ThrowError(DWORD dwStatus)
{
    //CThrowError(dwStatus);
    LogMessage2(L"CKernel Error: %d", dwStatus);
}

DWORD CKernel::Status() const
{
    return m_dwStatus;
}

DWORD CKernel::Wait(DWORD dwMilliseconds)
{
    return ::WaitForSingleObject(m_hHandle, dwMilliseconds);
}

// wait on the current object and one other...
DWORD CKernel::WaitForTwo(CWaitableObject &rCWaitableObject,
                          BOOL bWaitAll,
                          DWORD dwMilliseconds)
{
    HANDLE handles[2];

    // the current object...
    handles[0] = m_hHandle;

    // the parameter object...
    handles[1] = rCWaitableObject.GetHandle();

    // wait for the objects...
    return ::WaitForMultipleObjects(2, handles, bWaitAll, dwMilliseconds);
}

HANDLE CKernel::GetHandle() const
{
    if (this != NULL)
    {
        return m_hHandle;
    }
    else
    {
        return NULL;
    }
}

CKernel::operator HANDLE() const
{
    return GetHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cfgmgrdevice.h ===
/////////////////////////////////////////////////////////////////////////

//

//  cfgmgrdevice.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __CFGMGRDEVICE_H__
#define __CFGMGRDEVICE_H__

/////////////////////////////////////////////////////////////////////////
//  registry keys
/////////////////////////////////////////////////////////////////////////
#define	CONFIGMGR_ENUM_KEY					L"Config Manager\\Enum\\"
#define	LOCALMACHINE_ENUM_KEY				L"Enum\\"

#define	CONFIGMGR_DEVICE_HARDWAREKEY_VALUE	_T("HardwareKey")
#define	CONFIGMGR_DEVICE_ALLOCATION_VALUE	_T("Allocation")
#define	CONFIGMGR_DEVICEDESC_VALUE			_T("DeviceDesc")
#define	CONFIGMGR_DEVICE_PROBLEM_VALUE		_T("Problem")
#define	CONFIGMGR_DEVICE_STATUS_VALUE		L"Status"
#define	CONFIGMGR_DEVICE_STATUS_VALUET		_T("Status")

#include "iodesc.h"
#include "chwres.h"
#include "sms95lanexp.h"
#include "refptrlite.h"

class CIRQCollection;
class CDMACollection;
class CDeviceMemoryCollection;
class CNT4ServiceToResourceMap;

BOOL WINAPI FindDosDeviceName ( const TCHAR *a_DosDeviceNameList , const CHString a_SymbolicName , CHString &a_DosDevice , BOOL a_MappedDevice = FALSE ) ;
BOOL WINAPI QueryDosDeviceNames ( TCHAR *&a_DosDeviceNameList ) ;


class __declspec(uuid("CB0E0536-D375-11d2-B35E-00104BC97924")) CConfigMgrDevice;

_COM_SMARTPTR_TYPEDEF(CConfigMgrDevice, __uuidof(CConfigMgrDevice));

/////////////////////////////////////////////////////////////////////////
class 
__declspec(uuid("CB0E0536-D375-11d2-B35E-00104BC97924"))
CConfigMgrDevice : public CRefPtrLite
{
	
    public:

	    // Construction/Destruction
	    CConfigMgrDevice( LPCWSTR pszConfigMgrName,DWORD dwTypeToGet );
	    //CConfigMgrDevice( LPCWSTR pszDevice );
		CConfigMgrDevice( DEVNODE dn = NULL, DWORD dwResType = ResType_All );
	    ~CConfigMgrDevice();

		//////////////////////////////////////////////////
		//	AVOID THESE FUNCTIONS, THESE ARE LEGACY		//
		//////////////////////////////////////////////////

	    LPCWSTR	GetName( void );
	    LPCWSTR	GetHardwareKey( void );
	    LPCWSTR	GetDeviceDesc( void );

		// Status and problem functions
		DWORD	GetStatus( void );
		BOOL	GetStatus( CHString& str );
		void	GetProblem( CHString& str );

		DWORD	GetProblem( void );
		BOOL	IsOK( void );
		BOOL	MapKeyToConfigMgrDeviceName();

		//////////////////////////////////
		//	END LEGACY FUNCTIONS		//
		//////////////////////////////////

		//////////////////////////////////////////////////////
		//	USE THESE FUNCTIONS, THESE ARE THE REAL THING!	//
		//////////////////////////////////////////////////////

		// New functions that use config manager APIs directly

		// Resource retrieval
	    void GetResourceList( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetIRQResources( CIRQCollection& irqList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetIOResources( CIOCollection& ioList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetDMAResources( CDMACollection& dmaList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList, CNT4ServiceToResourceMap* pResourceMap = NULL  );

		// String Values
		BOOL GetDeviceDesc( CHString& strVal );
		BOOL GetService( CHString& strVal );
		BOOL GetClass( CHString& strVal );
		BOOL GetClassGUID( CHString& strVal );
		BOOL GetDriver( CHString& strVal );
		BOOL GetMfg( CHString& strVal );
		BOOL GetFriendlyName( CHString& strVal );
		BOOL GetLocationInformation( CHString& strVal );
		BOOL GetPhysicalDeviceObjectName( CHString& strVal );
		BOOL GetEnumeratorName( CHString& strVal );

		// DWORD Values
		BOOL GetConfigFlags( DWORD& dwVal );
		BOOL GetCapabilities( DWORD& dwVal );
		BOOL GetUINumber( DWORD& dwVal );

		// MULTI_SZ Values
		BOOL GetHardwareID( CHStringArray& strArray );
		BOOL GetCompatibleIDS( CHStringArray& strArray );
		BOOL GetUpperFilters( CHStringArray& strArray );
		BOOL GetLowerFilters( CHStringArray& strArray );

		// Use Config Manager APIs directly
		BOOL GetStringProperty( ULONG ulProperty, CHString& strValue );
		BOOL GetDWORDProperty( ULONG ulProperty, DWORD* pdwVal );
		BOOL GetMULTISZProperty( ULONG ulProperty, CHStringArray& strArray );

		// Device Relationship functions
		BOOL GetParent( CConfigMgrDevicePtr & pParentDevice );
		BOOL GetChild( CConfigMgrDevicePtr & pChildDevice );
		BOOL GetSibling( CConfigMgrDevicePtr & pSiblingDevice );

		// Miscelaneous Device functions
		BOOL GetBusInfo( INTERFACE_TYPE* pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap* pResourceMap = NULL );
		BOOL GetDeviceID( CHString& strID );
		BOOL GetStatus( LPDWORD pdwStatus, LPDWORD pdwProblem );
		BOOL IsUsingForcedConfig();
        BOOL IsClass(LPCWSTR pwszClassName);

		// Direct registry access helpers
        BOOL GetRegistryKeyName( CHString &strName);
        BOOL GetRegStringProperty(LPCWSTR szProperty, CHString &strValue);

		BOOL operator == ( const CConfigMgrDevice& device );

    private:

	    // Registry traversal helpers

		// LEGACY FUNCTIONS BEGIN		
	    BOOL GetConfigMgrInfo( void );
	    BOOL GetDeviceInfo( void );

	    BOOL GetHardwareKey( HKEY hKey );
	    BOOL GetResourceAllocation( HKEY hKey );
		BOOL GetStatusInfo( HKEY hKey );
	    BOOL GetDeviceDesc( HKEY hKey );
		// LEGACY FUNCTIONS END

#if NTONLY > 4
		// NT 5 Helpers
		BOOL GetBusInfoNT5( INTERFACE_TYPE* pitBusType, LPDWORD pdwBusNumber );
        static BOOL WINAPI IsIsaReallyEisa();
        static INTERFACE_TYPE WINAPI ConvertBadIsaBusType(INTERFACE_TYPE type);
#endif

	    // Resource Allocation Data Helpers

	    // Resource allocation registry walkthroughs
	    void TraverseAllocationData( CResourceCollection& resourceList );
	    void TraverseData( const BYTE *& pbTraverseData, DWORD& dwSizeRemainingData, DWORD dwSizeTraverse );
	    BOOL GetNextResource( const BYTE * pbTraverseData, DWORD dwSizeRemainingData, DWORD& dwResourceType, DWORD& dwResourceSize );

		// Resource functions
		BOOL WalkAllocatedResources( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap, RESOURCEID resType );
		BOOL AddResourceToList( RESOURCEID resourceID, LPVOID pResource, DWORD dwResourceLength, CResourceCollection& resourceList );

#ifdef NTONLY
		// NT4 Resource functions
		BOOL WalkAllocatedResourcesNT4( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap, CM_RESOURCE_TYPE resType );
		BOOL GetServiceResourcesNT4( LPCWSTR pszServiceName, CNT4ServiceToResourceMap& resourceMap, CResourceCollection& resourceList, CM_RESOURCE_TYPE cmrtFilter = CmResourceTypeNull );
#if NTONLY == 4
		BOOL GetBusInfoNT4( INTERFACE_TYPE* pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap* pResourceMap );
#endif

		// NT 4 resource datatype coercsion functions
		CM_RESOURCE_TYPE RESOURCEIDToCM_RESOURCE_TYPE( RESOURCEID resType );
		void NT4IRQToIRQ_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIRQ_DES pirqDes32 );
		void NT4IOToIOWBEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIOWBEM_DES pioDes32 );
		void NT4MEMToMEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PMEM_DES pmemDes32 );
		void NT4DMAToDMA_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PDMA_DES pdmaDes32 );
#endif

		// 16 to 32-bit coercsion functions
		void IRQDes16To32( PIRQ_DES16 pirqDes16, PIRQ_DES pirqDes32 );
		void IODes16To32( PIO_DES16 pioDes16, PIOWBEM_DES pioDes32 );
		void DMADes16To32( PDMA_DES16 pdmaDes16, PDMA_DES pdmaDes32 );
		void MEMDes16To32( PMEM_DES16 pmemDes16, PMEM_DES pmemDes32 );
		BOOL BusType16ToInterfaceType( CMBUSTYPE cmBusType16, INTERFACE_TYPE* pinterfaceType );

		// LEGACY VARIABLES BEGIN		

	    CHString	m_strConfigMgrName;
	    CHString	m_strHardwareKey;
	    CHString	m_strDeviceDesc;
        DWORD       m_dwTypeToGet;

	    // If we get allocation information, we store it in here.
	    BYTE*	m_pbAllocationData;
	    DWORD	m_dwSizeAllocationData;

		// Device status info
		DWORD	m_dwStatus;
		DWORD	m_dwProblem;

#ifdef WIN9XONLY
        DWORD   GetStatusFromConfigManagerDirectly(void);
#endif

		// LEGACY VARIABLES END

		// Use the devnode to query values directly from config manager
		DEVNODE	m_dn;
};



inline LPCWSTR CConfigMgrDevice::GetName( void )
{
	return m_strConfigMgrName;
}


inline LPCWSTR CConfigMgrDevice::GetHardwareKey( void )
{
	return m_strHardwareKey;
}

inline LPCWSTR CConfigMgrDevice::GetDeviceDesc( void )
{
	return m_strDeviceDesc;
}

inline void CConfigMgrDevice::GetResourceList( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap/*=NULL*/ )
{
	WalkAllocatedResources( resourceList, pResourceMap, m_dwTypeToGet );
}

inline DWORD CConfigMgrDevice::GetStatus( void )
{
	return m_dwStatus;
}

inline DWORD CConfigMgrDevice::GetProblem( void )
{
	return m_dwProblem;
}

inline BOOL CConfigMgrDevice::IsOK( void )
{
	return ( 0 == m_dwProblem );
}

// New Config manager functions that query Config Manager (16 & 32 bit)
// directly for info.

// REG_SZ Properties
inline BOOL CConfigMgrDevice::GetDeviceDesc( CHString& strVal )
{
	return GetStringProperty( CM_DRP_DEVICEDESC, strVal );
}

inline BOOL CConfigMgrDevice::GetService( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_SERVICE, strVal );
}

inline BOOL CConfigMgrDevice::GetClass( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_CLASS, strVal );
}

inline BOOL CConfigMgrDevice::GetClassGUID( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_CLASSGUID, strVal );
}

inline BOOL CConfigMgrDevice::GetDriver( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_DRIVER, strVal );
}

inline BOOL CConfigMgrDevice::GetMfg( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_MFG, strVal );
}

inline BOOL CConfigMgrDevice::GetFriendlyName( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_FRIENDLYNAME, strVal );
}

inline BOOL CConfigMgrDevice::GetLocationInformation( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_LOCATION_INFORMATION, strVal );
}

inline BOOL CConfigMgrDevice::GetPhysicalDeviceObjectName( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME, strVal );
}

inline BOOL CConfigMgrDevice::GetEnumeratorName( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_ENUMERATOR_NAME, strVal );
}

// DWORD functions
inline BOOL CConfigMgrDevice::GetConfigFlags( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_CONFIGFLAGS, &dwVal );
}

inline BOOL CConfigMgrDevice::GetCapabilities( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_CAPABILITIES, &dwVal );
}

inline BOOL CConfigMgrDevice::GetUINumber( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_UI_NUMBER, &dwVal );
}

// MULTI_SZ properties
inline BOOL CConfigMgrDevice::GetHardwareID( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_HARDWAREID, strArray );
}

inline BOOL CConfigMgrDevice::GetCompatibleIDS( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_COMPATIBLEIDS, strArray );
}

inline BOOL CConfigMgrDevice::GetUpperFilters( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_UPPERFILTERS, strArray );
}

inline BOOL CConfigMgrDevice::GetLowerFilters( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_LOWERFILTERS, strArray );
}

// Overloaded == operator.  Checks if DEVNODEs are the same.
inline BOOL CConfigMgrDevice::operator == ( const CConfigMgrDevice& device )
{
	return ( m_dn == device.m_dn );
}

// A collection of Devices
class CDeviceCollection : public TRefPtr<CConfigMgrDevice>
{
public:

	// Construction/Destruction
	CDeviceCollection();
	~CDeviceCollection();

	// Get the resources for this list of devices.

	BOOL GetResourceList( CResourceCollection& resourceList );
	BOOL GetIRQResources( CIRQCollection& IRQList );
	BOOL GetDMAResources( CDMACollection& DMAList );
	BOOL GetIOResources( CIOCollection& IOList );
	BOOL GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList );
private:
	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).
	const CDeviceCollection& operator = ( const CDeviceCollection& srcCollection );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ckernel.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CKernal.h -- Wraper for Kernal functions

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================



#ifndef __CKERNEL_H__
#define __CKERNEL_H__

#include "CGlobal.h"
#include "CWaitableObject.h"

class CKernel : public CWaitableObject 
{
protected:
    HANDLE m_hHandle;
    DWORD m_dwStatus;

protected:
    // constructor...
    CKernel();

    // error handling...
    void ThrowError(DWORD dwStatus);

public:
    // destructor is virtual to make CKernel an abstract base class...
    virtual ~CKernel() = 0;

    // read the creation status of the internal kernel object...
    DWORD Status() const;

    // wait on the current kernel object...
    DWORD Wait(DWORD dwMilliseconds);

    // wait on the current object and one other...
    DWORD WaitForTwo(CWaitableObject &rCWaitableObject, 
                     BOOL bWaitAll, 
                     DWORD dwMilliseconds);

    // get the internal handle...
    HANDLE GetHandle() const;

    // another way to get the internal handle...
    operator HANDLE() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cluidhelper.cpp ===
//=================================================================
//
// CLuidHelper.cpp
//
// Copyright (c) 2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "CLuidHelper.h"
#include "DllWrapperCreatorReg.h"

#include <scopeguard.h>

// {5356C625-EE38-4c4f-9370-D925C91A6D99}
static const GUID g_guidSecur32Api = 
{ 0x5356c625, 0xee38, 0x4c4f, { 0x93, 0x70, 0xd9, 0x25, 0xc9, 0x1a, 0x6d, 0x99 } };

static const WCHAR g_tstrSecur32[] = L"Secur32.DLL" ;

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CSecur32Api, &g_guidSecur32Api, g_tstrSecur32> MyRegisteredSecur32Wrapper;

/******************************************************************************
 * Constructor
 ******************************************************************************/

CSecur32Api::CSecur32Api ( LPCWSTR a_tstrWrappedDllName ) : CDllWrapperBase ( a_tstrWrappedDllName ) ,

	m_pfncLsaEnumerateLogonSessions ( NULL ) ,
	m_pfncLsaGetLogonSessionData ( NULL ) ,
	m_pfncLsaFreeReturnBuffer ( NULL )

{
}

/******************************************************************************
 * Destructor
 ******************************************************************************/

CSecur32Api::~CSecur32Api ()
{
}

bool CSecur32Api::Init ()
{
	bool bRet = LoadLibrary () ;
	if ( bRet )
	{
		m_pfncLsaEnumerateLogonSessions	=
			( PFN_LSA_ENUMERATE_LOGON_SESSIONS ) GetProcAddress ( "LsaEnumerateLogonSessions" ) ;
		m_pfncLsaGetLogonSessionData	=
			( PFN_LSA_GET_LOGON_SESSION_DATA ) GetProcAddress ( "LsaGetLogonSessionData" ) ;
		m_pfncLsaFreeReturnBuffer		=
			( PFN_LSA_FREE_RETURN_BUFFER ) GetProcAddress ( "LsaFreeReturnBuffer" ) ;

		if	(
				m_pfncLsaEnumerateLogonSessions == NULL ||
				m_pfncLsaGetLogonSessionData == NULL ||
				m_pfncLsaFreeReturnBuffer == NULL 
			)
		{
			bRet = FALSE ;
		}
	}

	return bRet ;
}

NTSTATUS CSecur32Api::LsaEnumerateLogonSessions	(
													PULONG  LogonSessionCount,
													PLUID* LogonSessionList
												)
{
	NTSTATUS NtStatus = STATUS_PROCEDURE_NOT_FOUND ;

	if ( m_pfncLsaEnumerateLogonSessions )
	{
		NtStatus = m_pfncLsaEnumerateLogonSessions ( LogonSessionCount, LogonSessionList ) ;
	}
	return NtStatus ;
}

NTSTATUS CSecur32Api::LsaGetLogonSessionData	(
													PLUID LogonId,
													PSECURITY_LOGON_SESSION_DATA* ppLogonSessionData
												)
{
	NTSTATUS NtStatus = STATUS_PROCEDURE_NOT_FOUND ;

	if ( m_pfncLsaGetLogonSessionData )
	{
		NtStatus = m_pfncLsaGetLogonSessionData ( LogonId, ppLogonSessionData ) ;
	}
	return NtStatus ;
}

NTSTATUS CSecur32Api::LsaFreeReturnBuffer	(	PVOID Buffer	)
{
	NTSTATUS NtStatus = STATUS_PROCEDURE_NOT_FOUND ;

	if ( m_pfncLsaFreeReturnBuffer )
	{
		NtStatus = m_pfncLsaFreeReturnBuffer ( Buffer ) ;
	}
	return NtStatus ;
}

//
// LUID HELPER
//

CLuidHelper::Resource::Resource () : m_pSecur32 ( NULL )
{
	m_pSecur32 = ( CSecur32Api* ) CResourceManager::sm_TheResourceManager.GetResource ( g_guidSecur32Api, NULL ) ;
}

CLuidHelper::Resource::~Resource ()
{
	if ( m_pSecur32 )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidSecur32Api, m_pSecur32 ) ;
	}
}

BOOL CLuidHelper::IsInteractiveSession ( PLUID session )
{
	BOOL bResult = FALSE ;
	if ( NULL != session )
	{
		Resource res;
		if ( FALSE == !res )
		{
			PSECURITY_LOGON_SESSION_DATA data = NULL ;
			NTSTATUS Status = STATUS_SUCCESS ;
			if ( STATUS_SUCCESS == ( Status = res()->LsaGetLogonSessionData ( session, &data ) ) )
			{
				if ( NULL != data )
				{
					ScopeGuard datafree = MakeObjGuard ( (CSecur32Api) res, CSecur32Api::LsaFreeReturnBuffer, data ) ;

					if ( Interactive == ( SECURITY_LOGON_TYPE ) data->LogonType )
					{
						bResult = TRUE ;
					}
				}
			}
		}
	}

	return bResult ;
}

NTSTATUS CLuidHelper::GetLUIDFromProcess ( HANDLE process, PLUID pLUID)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL ;

	if ( process )
	{
		SmartCloseHandle token ;
		if ( OpenProcessToken ( process, TOKEN_QUERY, &token ) )
		{
			TOKEN_STATISTICS tokstats ;
			DWORD dwRetSize ;

			if ( GetTokenInformation ( token, TokenStatistics, &tokstats, sizeof ( TOKEN_STATISTICS ), &dwRetSize ) )
			{
				pLUID->LowPart = tokstats.AuthenticationId.LowPart ;
				pLUID->HighPart = tokstats.AuthenticationId.HighPart ;

				Status = STATUS_SUCCESS ;
			}
			else
			{
				Status = (NTSTATUS)NtCurrentTeb()->LastStatusValue ;
			}
		}
		else
		{
			Status = (NTSTATUS)NtCurrentTeb()->LastStatusValue ;
		}
	}

	return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cluidhelper.h ===
//
//	Copyright (c) 2002 Microsoft Corporation, All Rights Reserved
//

#pragma once

#include <ntsecapi.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidSecur32Api ;
extern const WCHAR g_tstrSecur32[] ;

typedef NTSTATUS (*PFN_LSA_ENUMERATE_LOGON_SESSIONS)
(
    OUT PULONG  LogonSessionCount,
    OUT PLUID*  LogonSessionList
);


typedef NTSTATUS (*PFN_LSA_GET_LOGON_SESSION_DATA)
(
    IN   PLUID                           LogonId,
    OUT  PSECURITY_LOGON_SESSION_DATA*   ppLogonSessionData
);


typedef NTSTATUS (*PFN_LSA_FREE_RETURN_BUFFER)
(
    IN PVOID Buffer
);

class CSecur32Api : public CDllWrapperBase
{
	PFN_LSA_ENUMERATE_LOGON_SESSIONS	m_pfncLsaEnumerateLogonSessions ;
	PFN_LSA_GET_LOGON_SESSION_DATA		m_pfncLsaGetLogonSessionData ;
	PFN_LSA_FREE_RETURN_BUFFER			m_pfncLsaFreeReturnBuffer ;

	public:

	NTSTATUS LsaEnumerateLogonSessions	(
											PULONG  LogonSessionCount,
											PLUID* LogonSessionList
										) ;

	NTSTATUS LsaGetLogonSessionData	(
										PLUID LogonId,
										PSECURITY_LOGON_SESSION_DATA* ppLogonSessionData
									) ;

	NTSTATUS LsaFreeReturnBuffer	(	PVOID Buffer	) ;

	// Inherrited initialization function.
	virtual bool Init();

	CSecur32Api ( LPCTSTR a_tstrWrappedDllName ) ;
	~CSecur32Api () ;
} ;

class CLuidHelper
{
	class Resource
	{
		CSecur32Api * m_pSecur32 ;

		public:
		Resource () ;
		~Resource () ;

		CSecur32Api * operator () () const
		{
			return m_pSecur32 ;
		}

		operator CSecur32Api () const
		{
			return *m_pSecur32 ;
		}

		BOOL operator ! () const
		{
			return ( NULL == m_pSecur32 ) ;
		}
	} ;

	public:

	BOOL IsInteractiveSession ( PLUID ) ;

	NTSTATUS GetLUIDFromProcess ( HANDLE , PLUID ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cmdh.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// CMDH.cpp - Helper class for working with
//            logical disks mapped by logon
//            session.
// 
// Created: 4/23/2000   Kevin Hughes (khughes)
//


#pragma once



#define STR_FROM_bool(x) ( x ? L"TRUE" : L"FALSE" )



_COM_SMARTPTR_TYPEDEF(IDiskQuotaControl, IID_IDiskQuotaControl);


#define GET_NOTHING                             0x00000000
#define GET_ALL_PROPERTIES                      0xFFFFFFFF
#define GET_DEVICEID                            0x00000001
#define GET_PROVIDER_NAME                       0x00000002
#define GET_VOLUME_NAME                         0x00000004
#define GET_FILE_SYSTEM                         0x00000008
#define GET_VOLUME_SERIAL_NUMBER                0x00000010
#define GET_COMPRESSED                          0x00000020
#define GET_SUPPORTS_FILE_BASED_COMPRESSION     0x00000040
#define GET_MAXIMUM_COMPONENT_LENGTH            0x00000080
#define GET_SUPPORTS_DISK_QUOTAS                0x00000100
#define GET_QUOTAS_INCOMPLETE                   0x00000200
#define GET_QUOTAS_REBUILDING                   0x00000400
#define GET_QUOTAS_DISABLED                     0x00000800
#define GET_PERFORM_AUTOCHECK                   0x00001000
#define GET_FREE_SPACE                          0x00002000
#define GET_SIZE                                0x00004000

#define GET_VOL_INFO        (GET_VOLUME_NAME | \
                             GET_FILE_SYSTEM | \
                             GET_VOLUME_SERIAL_NUMBER | \
                             GET_COMPRESSED | \
                             GET_SUPPORTS_FILE_BASED_COMPRESSION | \
                             GET_MAXIMUM_COMPONENT_LENGTH | \
                             GET_SUPPORTS_DISK_QUOTAS | \
                             GET_QUOTAS_INCOMPLETE | \
                             GET_QUOTAS_REBUILDING | \
                             GET_QUOTAS_DISABLED | \
                             GET_PERFORM_AUTOCHECK)

#define SPIN_DISK           (GET_VOL_INFO | \
                             GET_FREE_SPACE | \
                             GET_SIZE)


enum 
{
    PROP_DEVICEID                          = 0,
    PROP_PROVIDER_NAME                     = 1,                   	
    PROP_VOLUME_NAME                       = 2,
    PROP_FILE_SYSTEM                       = 3,
    PROP_VOLUME_SERIAL_NUMBER              = 4,
    PROP_COMPRESSED                        = 5,
    PROP_SUPPORTS_FILE_BASED_COMPRESSION   = 6,
    PROP_MAXIMUM_COMPONENT_LENGTH          = 7,
    PROP_SUPPORTS_DISK_QUOTAS              = 8,
    PROP_QUOTAS_INCOMPLETE                 = 9,
    PROP_QUOTAS_REBUILDING                 = 10,
    PROP_QUOTAS_DISABLED                   = 11,
    PROP_PERFORM_AUTOCHECK                 = 12,
    PROP_FREE_SPACE                        = 13,
    PROP_SIZE                              = 14,

    PROP_COUNT                             = 15

};








class CMDH
{
public:

    CMDH() : m_dwImpPID(-1L) {}
    CMDH(
        DWORD dwPID)
      : m_dwImpPID(dwPID)
    {}

    virtual ~CMDH() {}

    HRESULT GetMDData(
        DWORD dwReqProps,
        VARIANT* pvarData);

    HRESULT GetOneMDData(
	    BSTR bstrDrive,
	    DWORD dwReqProps, 
	    VARIANT* pvarData);

    DWORD GetImpPID()
    {
        return m_dwImpPID;
    }

    void SetImpPID(
        DWORD dwPID)
    {
        m_dwImpPID = dwPID;
    }

private:

    HRESULT GetMappedDisksAndData(
        DWORD dwReqProps,
        VARIANT* pvarData);

    HRESULT GetSingleMappedDiskAndData(
        BSTR bstrDrive,
        DWORD dwReqProps,
        VARIANT* pvarData);

#ifdef NTONLY
    void GetMappedDriveList(
        std::vector<_bstr_t>& vecMappedDrives);
#endif

    HRESULT GetMappedDriveInfo(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps,
        DWORD dwReqProps);

    HRESULT GetProviderName(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps);

    HRESULT GetDriveVolumeInformation(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps);

    BOOLEAN IsVolumeDirty(
        _bstr_t &bstrtNtDriveName,
        BOOLEAN *Result);

    HRESULT GetDriveFreeSpace(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps);

    HRESULT SetProperty(
        long lDrivePropArrayDriveIndex,
        long lDrivePropArrayPropIndex,
        LPCWSTR wstrPropValue,
        SAFEARRAY* saDriveProps);

    HANDLE Impersonate();


    DWORD m_dwImpPID;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cmdh.cpp ===
//  Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved
//
// CMDH.cpp - Helper class for working with
//            logical disks mapped by logon
//            session.
// 
// Created: 4/23/2000   Kevin Hughes (khughes)
//

// USEAGE NOTE: This class presents a view of
// information pertaining to mapped drives in
// the context of the process id specified in
// the class constructor.


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#pragma warning (disable: 4786)
#pragma warning (disable: 4284)

#include <precomp.h>
#include <objbase.h>
#include <comdef.h>
#include <stdio.h>    //sprintf
#include <stdlib.h>
#include <assert.h>
#include <strstrea.h>
#include <vector>
#include <DskQuota.h>
#include <smartptr.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "NtDllApi.h"
#include "Kernel32Api.h"

#include <ntioapi.h>
#include "cmdh.h"

#include <session.h>
#include <dllutils.h>
#include <..\..\framework\provexpt\include\provexpt.h>

#include "Sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "CToken.h"
#include "SecureKernelObj.h"

#include <cominit.h>

#include <autoptr.h>
#include <scopeguard.h>

///////////////////////////////////////////////////////////////////////////////
//  CMDH Public interface functions
///////////////////////////////////////////////////////////////////////////////


HRESULT CMDH::GetMDData(
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = S_OK;
    
    if(!pvarData) return E_POINTER;
    
    if(SUCCEEDED(hr))
    {
        hr = GetMappedDisksAndData(
            dwReqProps,
            pvarData);
    }

    return hr;
}

HRESULT CMDH::GetOneMDData(
	BSTR bstrDrive,
	DWORD dwReqProps, 
	VARIANT* pvarData)
{
    HRESULT hr = S_OK;

    if(!pvarData) return E_POINTER;

    if(SUCCEEDED(hr))
    {
        hr = GetSingleMappedDiskAndData(
            bstrDrive,
            dwReqProps,
            pvarData);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  CMDH Private internal functions
///////////////////////////////////////////////////////////////////////////////

// This function does pretty much all of the
// work this object was constructed to do -
// it obtains, for the process space that this
// server is running in, the set of mapped
// drives, and for each of these, the following
// information as well:
// 
HRESULT CMDH::GetMappedDisksAndData(
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ::VariantInit(pvarData);
	V_VT(pvarData) = VT_EMPTY;

    // Get the mapped drives into a vector...
    std::vector<_bstr_t> vecMappedDrives;
    {
        // Impersonate member process...
        SmartRevertTokenHANDLE hCurImpTok;
        hCurImpTok = Impersonate();

        if(hCurImpTok != INVALID_HANDLE_VALUE)
        {
            GetMappedDriveList(
                vecMappedDrives);
        }
    }

    // Now allocate the two dimensional
    // safearray that will hold the properties
    // for each mapped drive...
    SAFEARRAY* saDriveProps = NULL;
    SAFEARRAYBOUND rgsabound[2];
    
    rgsabound[0].cElements = PROP_COUNT;
	rgsabound[0].lLbound = 0; 

    rgsabound[1].cElements = vecMappedDrives.size();
	rgsabound[1].lLbound = 0;

    saDriveProps = ::SafeArrayCreate(
        VT_BSTR, 
        2, 
        rgsabound);

    if(saDriveProps)
    {
        // For each mapped drive, obtain its
        // properties and store in the safearray...
        for(long m = 0;
            m < vecMappedDrives.size() && SUCCEEDED(hr);
            m++)
        {
            hr = GetMappedDriveInfo(
                vecMappedDrives[m],
                m,
                saDriveProps,
                dwReqProps);
        }

        // And finally package the safearray
        // into the outgoing variant.
        if(SUCCEEDED(hr))
        {
            ::VariantInit(pvarData);
	        V_VT(pvarData) = VT_BSTR | VT_ARRAY; 
            V_ARRAY(pvarData) = saDriveProps;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}


// Similar to GetMappedDisksAndData, but only
// retrieves info for a single disk.
//
HRESULT CMDH::GetSingleMappedDiskAndData(
    BSTR bstrDrive,
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ::VariantInit(pvarData);
	V_VT(pvarData) = VT_EMPTY;

    // Impersonate member process...
    SmartRevertTokenHANDLE hCurImpTok;
    hCurImpTok = Impersonate();

    if(hCurImpTok != INVALID_HANDLE_VALUE)
    {
        // Get the mapped drives into a vector...
        std::vector<_bstr_t> vecMappedDrives;
        GetMappedDriveList(
            vecMappedDrives);

        // Now allocate the two dimensional
        // safearray that will hold the properties
        // for each mapped drive...
        // Note: in this routine, it is really
        // only a one dimensional array, but,
        // for code reuse, we'll treat it as a
        // two dimensional array with only one
        // element in one of the dimensions.
        SAFEARRAY* saDriveProps = NULL;
        SAFEARRAYBOUND rgsabound[2];
    
        rgsabound[0].cElements = PROP_COUNT; 
	    rgsabound[0].lLbound = 0; 

        rgsabound[1].cElements = 1; // for code reuse
	    rgsabound[1].lLbound = 0;

        saDriveProps = ::SafeArrayCreate(
            VT_BSTR, 
            2, 
            rgsabound);

        if(saDriveProps)
        {
            // See if the drive specified is a member
            // of the vector.
            _bstr_t bstrtTmp = bstrDrive;
            bstrtTmp += L"\\";
            bool fFoundIt = false;

            for(long n = 0;
                n < vecMappedDrives.size() && !fFoundIt;
                n++)
            {
                if(_wcsicmp(bstrtTmp, vecMappedDrives[n]) == 0)
                {
                    fFoundIt = true;
                    n--;
                }
            }
            // For the mapped drive, obtain its
            // properties and store in the safearray...
            if(fFoundIt)
            {
                hr = GetMappedDriveInfo(
                    vecMappedDrives[n],
                    0,   // for code reuse
                    saDriveProps,
                    dwReqProps);

                // And finally package the safearray
                // into the outgoing variant.
                ::VariantInit(pvarData);
	            V_VT(pvarData) = VT_BSTR | VT_ARRAY; 
                V_ARRAY(pvarData) = saDriveProps;
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}


// Builds a list of mapped drives as
// seen with respect to the process
// identified by m_dwImpPID.  Hence, this
// routine will return a valid picture
// of the drives seen by m_dwImpPID, regardless
// of our current thread impersonation.
//
#ifdef NTONLY  // uses ntdll.dll functions
void CMDH::GetMappedDriveList(
    std::vector<_bstr_t>& vecMappedDrives)
{
    // Need to call NtQueryInformationProcess,
    // asking for ProcessDeviceMap info, specifying
    // a handle to the process identified by
    // m_dwImpPID.

    // Need to get a process handle to the 
    // process specified by PID.
    NTSTATUS Status;

    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

	Status = ::NtQueryInformationProcess(
        ::GetCurrentProcess() /*hProcess*/,
        ProcessDeviceMap,
        &ProcessDeviceMapInfo.Query,
        sizeof(ProcessDeviceMapInfo.Query),

        NULL);

    if(NT_SUCCESS(Status))
    {
        WCHAR wstrDrive[4];
        for(short s = 0; 
            s < 32; 
            s++) 
        {
            if(ProcessDeviceMapInfo.Query.DriveMap & (1<<s))
            {
                wstrDrive[0] = s + L'A';
                wstrDrive[1] = L':';
                wstrDrive[2] = L'\\';
                wstrDrive[3] = L'\0';
        
                if(ProcessDeviceMapInfo.Query.DriveType[s] == 
                      DOSDEVICE_DRIVE_REMOTE)
                {
                    vecMappedDrives.push_back(wstrDrive);
                }
                else if(ProcessDeviceMapInfo.Query.DriveType[s] == 
                      DOSDEVICE_DRIVE_CALCULATE)
                {
                    // We have more work to do.
                    // Create an nt file path...
                    WCHAR NtDrivePath[_MAX_PATH] = { '\0' };
                    wcscpy(NtDrivePath, L"\\??\\");
                    wcscat(NtDrivePath, wstrDrive);

                    // Create the unicode string...
                    UNICODE_STRING ustrNtFileName;

                    ::RtlInitUnicodeString(
                        &ustrNtFileName, 
                        NtDrivePath);

                    // Get the object attributes...
                    OBJECT_ATTRIBUTES oaAttributes;

                    InitializeObjectAttributes(&oaAttributes,
					   &ustrNtFileName,
					   OBJ_CASE_INSENSITIVE,
					   NULL,
					   NULL);

                    // Open the file
                    DWORD dwStatus = ERROR_SUCCESS;
                    IO_STATUS_BLOCK IoStatusBlock;
                    HANDLE hFile = NULL;

                    dwStatus = ::NtOpenFile( 
                        &hFile,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &oaAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0);

                    FILE_FS_DEVICE_INFORMATION DeviceInfo;

                    if(NT_SUCCESS(dwStatus))
                    {
						try
						{
							// Get information on the file...
							dwStatus = ::NtQueryVolumeInformationFile( 
								hFile,
								&IoStatusBlock,
								&DeviceInfo,
								sizeof(DeviceInfo),
								FileFsDeviceInformation);

							::NtClose(hFile);
							hFile = NULL;
						}
						catch(...)
						{
							::NtClose(hFile);
							hFile = NULL;
							throw;
						}
                    }

                    if(NT_SUCCESS(dwStatus))
                    {
                        if((DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) ||
                            (DeviceInfo.DeviceType == FILE_DEVICE_NETWORK ||
                            DeviceInfo.DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM))
                        {
                            // it is a remote drive...
                            vecMappedDrives.push_back(wstrDrive);                                    
                        }
                    }
                }
            }
        }
    }
}
#endif

// All of the routines used in this function -
// GetProviderName, GetVolumeInformation,
// and GetDriveFreeSpace, return information
// for the drive who's mapping string appears
// in wstrDriveName with respect to that
// mapping string's meaning in the context of
// the current thread's impersonation. Hence
// we impersonate before calling them.
//
HRESULT CMDH::GetMappedDriveInfo(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps,
    DWORD dwReqProps)
{
    HRESULT hr = S_OK;

    // Right away we can set the device id prop...
    hr = SetProperty(
        lDrivePropArrayDriveIndex,
        PROP_DEVICEID,
        wstrDriveName,
        saDriveProps);

    // If we couldn't even set the device id, it is
    // a problem.  Otherwise, continue.
    if(SUCCEEDED(hr))
    {
        // Set the other properties if they
        // were requested...
        // Get Expensive properties now if appropriate.
	    if(dwReqProps &
            (SPIN_DISK |
            GET_PROVIDER_NAME))
        {
			
            // Impersonate member process...
            SmartRevertTokenHANDLE hCurImpTok;
            hCurImpTok = Impersonate(); 

            if(dwReqProps & GET_PROVIDER_NAME)
			{   
                GetProviderName(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
            }

            if(dwReqProps & GET_VOL_INFO)
			{
				// Obtain volume information
				GetDriveVolumeInformation(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
			}

			
			if ( dwReqProps &
				(PROP_SIZE |
				 PROP_FREE_SPACE) )
			{
				GetDriveFreeSpace(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
			}
        }
    }

    return hr;
}


// Presents a view based on the current 
// impersonation of the current thread.
//
HRESULT CMDH::GetProviderName(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;

    WCHAR wstrTempDrive[_MAX_PATH] ;
	wsprintf(
        wstrTempDrive, 
        L"%c%c", 
        wstrDriveName[0], 
        wstrDriveName[1]);

	WCHAR wstrProvName[_MAX_PATH];
	DWORD dwProvName = sizeof(wstrProvName ) ;
    WCHAR* wstrNewProvName = NULL;

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
	try  
    {
	    DWORD dwRetCode = ::WNetGetConnection(
            wstrTempDrive, 
            wstrProvName, 
            &dwProvName);

	    if(dwRetCode == NO_ERROR ||
            dwRetCode == ERROR_CONNECTION_UNAVAIL)
	    {
		    hr = SetProperty(
                lDrivePropArrayDriveIndex,
                PROP_PROVIDER_NAME,
                wstrProvName,
                saDriveProps);
	    }
	    else
	    {
		    dwRetCode = GetLastError();

		    if((dwRetCode == ERROR_MORE_DATA) && 
                (dwProvName > _MAX_PATH))
		    {
                wstrNewProvName = new WCHAR[dwProvName];
			    if(wstrNewProvName != NULL)
			    {
					dwRetCode = ::WNetGetConnection(
                        wstrTempDrive, 
                        wstrNewProvName, 
                        &dwProvName);

					if(dwRetCode == NO_ERROR ||
                        dwRetCode == ERROR_CONNECTION_UNAVAIL)
					{
						hr = SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_PROVIDER_NAME,
                            wstrNewProvName,
                            saDriveProps);
					}
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwRetCode);
                    }

				    delete wstrNewProvName;
                }
                else
			    {
				    hr = E_OUTOFMEMORY;
			    }
		    }
            else
            {
                hr = HRESULT_FROM_WIN32(dwRetCode);
            }
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
        if(wstrNewProvName)
        {
            delete wstrNewProvName;
            wstrNewProvName = NULL;
        }
        hr = WBEM_E_FAILED;
    }  
    catch(...)
    {
        if(wstrNewProvName)
        {
            delete wstrNewProvName;
            wstrNewProvName = NULL;
        }
        // The filter will do the work.  Just re-throw here.
        throw;
    }    
  

    return hr;
}



// Presents a view based on the current 
// impersonation of the current thread.
//
HRESULT CMDH::GetDriveVolumeInformation(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;
    DWORD dwResult = ERROR_SUCCESS;

	WCHAR wstrVolumeName[_MAX_PATH];
	WCHAR wstrFileSystem[_MAX_PATH];
    WCHAR wstrTmp[_MAX_PATH];
    DWORD dwSerialNumber;
	DWORD dwMaxComponentLength;
	DWORD dwFSFlags;

	BOOL fReturn = ::GetVolumeInformation(
		wstrDriveName,
		wstrVolumeName,
		sizeof(wstrVolumeName)/sizeof(WCHAR),
		&dwSerialNumber,
		&dwMaxComponentLength,
		&dwFSFlags,
		wstrFileSystem,
		sizeof(wstrFileSystem)/sizeof(WCHAR)
	);

    if(fReturn)
	{
	    // Win32 API will return volume information for all drive types.
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_VOLUME_NAME,
            wstrVolumeName,
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_FILE_SYSTEM,
            wstrFileSystem,
            saDriveProps);

        if (dwSerialNumber != 0)
        {
	        WCHAR wstrSerialNumber[_MAX_PATH];
            wsprintf(wstrSerialNumber, 
                L"%.8X", 
                dwSerialNumber);

            SetProperty(
                lDrivePropArrayDriveIndex,
                PROP_VOLUME_SERIAL_NUMBER,
                wstrSerialNumber,
                saDriveProps);
        }

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_COMPRESSED,
            STR_FROM_bool(dwFSFlags & FS_VOL_IS_COMPRESSED),
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SUPPORTS_FILE_BASED_COMPRESSION,
            STR_FROM_bool(dwFSFlags & FS_FILE_COMPRESSION),
            saDriveProps);

        _ultow(dwMaxComponentLength,
            wstrTmp,
            10);
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_MAXIMUM_COMPONENT_LENGTH,
            wstrTmp,
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SUPPORTS_DISK_QUOTAS,
            STR_FROM_bool(dwFSFlags & FILE_VOLUME_QUOTAS),
            saDriveProps);

		

		// To get the state of the volume, 
        // we need to get the Interface pointer...
        IDiskQuotaControlPtr pIQuotaControl;
        ::SetLastError(ERROR_SUCCESS);

		if(SUCCEEDED(CoCreateInstance(
		    CLSID_DiskQuotaControl,
		    NULL,
		    CLSCTX_INPROC_SERVER,
		    IID_IDiskQuotaControl,
		    (void **)&pIQuotaControl)))
		{
			WCHAR wstrVolumePathName[MAX_PATH + 1];
            ::SetLastError(ERROR_SUCCESS);

			BOOL fRetVal = FALSE;
            
            CKernel32Api* pKernel32 = NULL;
            pKernel32 = (CKernel32Api*)CResourceManager::sm_TheResourceManager.GetResource(
                    g_guidKernel32Api, NULL);
    
            try
            {
                if(pKernel32)
                {
                    pKernel32->GetVolumePathName(
			            wstrDriveName,    
			            wstrVolumePathName, 
			            MAX_PATH,
                        &fRetVal);

                    CResourceManager::sm_TheResourceManager.ReleaseResource(
                        g_guidKernel32Api, pKernel32);

                    pKernel32 = NULL;
                }
            }
            catch(...)
            {
                if(pKernel32)
                {
                    CResourceManager::sm_TheResourceManager.ReleaseResource(
                        g_guidKernel32Api, pKernel32);
                }
                throw;            
            }

			if(fRetVal)
			{
				::SetLastError(ERROR_SUCCESS);
                if(SUCCEEDED(pIQuotaControl->Initialize(
                    wstrVolumePathName, 
                    TRUE)))
				{
					DWORD dwQuotaState;
                    ::SetLastError(ERROR_SUCCESS);

					hr = pIQuotaControl->GetQuotaState(&dwQuotaState);
					if(SUCCEEDED(hr))
					{
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_INCOMPLETE,
                            STR_FROM_bool(DISKQUOTA_FILE_INCOMPLETE(dwQuotaState)),
                            saDriveProps);
					
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_REBUILDING,
                            STR_FROM_bool(DISKQUOTA_FILE_REBUILDING(dwQuotaState)),
                            saDriveProps);
				
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_DISABLED,
                            STR_FROM_bool(DISKQUOTA_STATE_DISABLED & dwQuotaState),
                            saDriveProps);
					}
					else
					{
						dwResult = GetLastError();
					}
				}
				else
				{
					dwResult = GetLastError();
				}
			}
		}
		else
		{
			dwResult = GetLastError();
		}
    }
    else
    {
        dwResult = GetLastError();
    }

    // for chkdsk VolumeDirty Property
	BOOLEAN fVolumeDirty = FALSE;
	BOOL fSuccess = FALSE;

	_bstr_t bstrtDosDrive(wstrDriveName);
	UNICODE_STRING string = { 0 };
    _bstr_t nt_drive_name;

    try
    {
	    if ( RtlDosPathNameToNtPathName_U	(
												(LPCWSTR)bstrtDosDrive, 
												&string, 
												NULL, 
												NULL
											)
		   )
		{
			string.Buffer[string.Length/sizeof(WCHAR) - 1] = 0;
			nt_drive_name = string.Buffer;

			if(string.Buffer)
			{
				RtlFreeUnicodeString(&string);
				string.Buffer = NULL;
			}
		}
		else
		{
			dwResult = RtlNtStatusToDosError ( (NTSTATUS)NtCurrentTeb()->LastStatusValue );
		}
    }
    catch(...)
    {
        if(string.Buffer)
        {
            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
        throw;
    }

	if ( dwResult == ERROR_SUCCESS )
	{
		::SetLastError(ERROR_SUCCESS);
		fSuccess = IsVolumeDirty(
			nt_drive_name, 
			&fVolumeDirty );

		if(fSuccess)
		{
			SetProperty(
				lDrivePropArrayDriveIndex,
				PROP_PERFORM_AUTOCHECK,
				STR_FROM_bool(!fVolumeDirty),
				saDriveProps);
		}
		else
		{
			dwResult = GetLastError();
		}
	}

    if(dwResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }

    return hr;
}



// Presents a view based on the current 
// impersonation of the current thread.
//
BOOLEAN CMDH::IsVolumeDirty(
    _bstr_t &bstrtNtDriveName,
    BOOLEAN *Result)
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            status = 0;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h = 0;
    ULONG               r = 0;
	BOOLEAN				bRetVal = FALSE;
    WCHAR               wstrNtDriveName[_MAX_PATH];

    wcscpy(wstrNtDriveName, bstrtNtDriveName);
    u.Length = (USHORT) wcslen(wstrNtDriveName) * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = wstrNtDriveName;

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    status = NtOpenFile(
        &h,
        SYNCHRONIZE | FILE_READ_DATA,
        &obj,
        &iosb,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        FILE_SYNCHRONOUS_IO_ALERT);

    if(NT_SUCCESS(status)) 
	{
		try
		{
			status = NtFsControlFile(
				h, NULL, NULL, NULL,
				&iosb,
				FSCTL_IS_VOLUME_DIRTY,
				NULL, 0,
				&r, sizeof(r));

			if(NT_SUCCESS(status)) 
			{

#if(_WIN32_WINNT >= 0x0500)
				*Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
				*Result = (BOOLEAN)r;
#endif
				bRetVal = TRUE;
			}
		}
		catch(...)
		{
			NtClose(h);
			h = 0;
			throw;
		}

		NtClose(h);
		h = 0;
	}

	return bRetVal;
}



// Presents a view based on the current 
// impersonation of the current thread.
//
HRESULT CMDH::GetDriveFreeSpace(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
	HRESULT hr = S_OK;

	ULARGE_INTEGER uliTotalBytes;
	ULARGE_INTEGER uliUserFreeBytes;
	ULARGE_INTEGER uliTotalFreeBytes;

    ::SetLastError(ERROR_SUCCESS);
	if(::GetDiskFreeSpaceEx(
        wstrDriveName, 
        &uliUserFreeBytes, 
        &uliTotalBytes, 
        &uliTotalFreeBytes))
	{
		WCHAR wstrTmp[128] = { L'\0' };
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SIZE,
            _ui64tow(
                uliTotalBytes.QuadPart,
                wstrTmp,
                10),
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_FREE_SPACE,
            _ui64tow(
                uliTotalFreeBytes.QuadPart,
                wstrTmp,
                10),
            saDriveProps);

	}
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());    
    }

    return hr;
}



// Sets a property for a given drive
// in the drive safearray.
//
HRESULT CMDH::SetProperty(
    long lDrivePropArrayDriveIndex,
    long lDrivePropArrayPropIndex,
    LPCWSTR wstrPropValue,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;

    bstr_t bstrTmp( wstrPropValue); // this will work because PutElement makes a copy   
    long ix[2];
    ix[0] = lDrivePropArrayPropIndex;
    ix[1] = lDrivePropArrayDriveIndex;

    hr = ::SafeArrayPutElement(saDriveProps, ix, (void *)((BSTR)bstrTmp));

    return hr;
}

// Sets our current thread's impersonation
// to the token belonging to the process
// identified by our member, m_dwImpPID.
//
HANDLE CMDH::Impersonate()
{
    HANDLE hCurToken = INVALID_HANDLE_VALUE;

    // Find the explorer process...
    if(m_dwImpPID != -1L)
    {
		//
		// get SID of current process
		//
		CSid csidCurrentProcess;
		{
			//
			// get process credentials
			// and try to get client's back when leaving scope
			//

			WbemCoRevertToSelf () ;
			ScopeGuard SmartWbemCoImpersonateClientFnc = MakeGuard ( WbemCoImpersonateClient ) ;

			CProcessToken cpt ( NULL, true, TOKEN_QUERY ) ;

			PBYTE buff = NULL ;
			DWORD dwBuff = 0L ;

			if ( FALSE == ::GetTokenInformation	(
													cpt.GetTokenHandle () ,
													TokenUser ,
													NULL ,
													0 ,
													&dwBuff
												) 
				)
			{
				if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
				{
					buff = new BYTE [ dwBuff ] ;
					wmilib::auto_buffer < BYTE > SmartBuff ( buff ) ;

					if ( TRUE == ::GetTokenInformation	(
															cpt.GetTokenHandle () ,
															TokenUser ,
															buff ,
															dwBuff ,
															&dwBuff
														) 
					)
					{
						csidCurrentProcess = CSid ( ( ( PTOKEN_USER ) buff )->User.Sid ) ;
					}
				}
			}

			SmartWbemCoImpersonateClientFnc.Dismiss () ;

			HRESULT t_hResult = S_OK ;
			if ( FAILED ( t_hResult = WbemCoImpersonateClient () ) )
			{
				throw CFramework_Exception( L"CoImpersonateClient failed", t_hResult ) ;
			}
		}

		if ( csidCurrentProcess.IsValid () )
		{
			//
			// smart CloseHandle
			//
			ScopeGuard SmartCloseHandleFnc = MakeGuard ( CloseHandle, hCurToken ) ;

			bool fOK = false;

			if(::OpenThreadToken(
				::GetCurrentThread(), 
				TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, 
				TRUE, 
				&hCurToken))
			{
				SmartCloseHandle hProcess;
				hProcess = ::OpenProcess(
					PROCESS_QUERY_INFORMATION,
					FALSE,
					m_dwImpPID);

				if(hProcess != INVALID_HANDLE_VALUE)
				{
					// now open its token...
					SmartCloseHandle hProcToken;
					if(::OpenProcessToken(
							hProcess,
							TOKEN_READ | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
							&hProcToken))
					{
						CProcessToken cpt ( hProcToken );
						if ( cpt.IsValidToken () )
						{
							TOKEN_TYPE type;
							if ( cpt.GetTokenType ( type ) )
							{
								if ( TokenPrimary == type )
								{
									CToken ct;
									if ( ct.Duplicate ( cpt, FALSE ) )
									{
										// Set the thread token...
										if(::SetThreadToken(NULL, ct.GetTokenHandle ()))
										{
											fOK = true;                        
										}
									}
								}
								else
								{
									#if DBG == 1
									// for testing purpose I will let process break
									::DebugBreak();
									#endif

									// Set the thread token...
									if(::SetThreadToken(NULL, cpt.GetTokenHandle ()))
									{
										fOK = true;                        
									}
								}
							}
						}
					}
				}
			}

			SmartCloseHandleFnc.Dismiss () ;
			if(!fOK)
			{
				if(hCurToken != INVALID_HANDLE_VALUE)
				{
					::CloseHandle(hCurToken);
					hCurToken = INVALID_HANDLE_VALUE;
				}    
			}
			else
			{
				BOOL bSucceeded = FALSE ;

				//
				// need to adjust SD associated with thread
				// to contain current process' SID
				//

				CThreadToken ctt;
				if ( ctt.IsValidToken () )
				{
					// Obtain access to its security descriptor...
					CSecureKernelObj sko(ctt.GetTokenHandle(), FALSE);
					// Modify the security descriptor...
					if( sko.AddDACLEntry	(
												csidCurrentProcess,
												ENUM_ACCESS_ALLOWED_ACE_TYPE,
												TOKEN_ALL_ACCESS,
												0,
												NULL,
												NULL
											))
					{
						if ( ERROR_SUCCESS == sko.ApplySecurity( DACL_SECURITY_INFORMATION ) )
						{
							bSucceeded = TRUE ;
						}
					}
				}

				if ( FALSE == bSucceeded )
				{
					//
					// we need to revert back as SD was
					// not successfully adjusted
					//

					if ( ! ::SetThreadToken ( NULL, hCurToken ) )
					{
						::CloseHandle ( hCurToken ) ;
						throw CFramework_Exception(L"SetThreadToken failed", GetLastError());
					}

					::CloseHandle ( hCurToken ) ;
					hCurToken = INVALID_HANDLE_VALUE ;
				}
			}
		}
    }

    return hCurToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cmutex.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CMutex.cpp -- Mutex Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#include "precomp.h"
#include "CMutex.h"

// constructor creates a mutex allowing creation parameters to be specified...
CMutex::CMutex(BOOL bInitialOwner, LPCTSTR lpName, LPSECURITY_ATTRIBUTES lpMutexAttributes)
{
    m_hHandle = ::CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
    if (CIsValidHandle(m_hHandle))
    {
        if (lpName)
        {
            m_dwStatus = GetLastError();
        }
        else
        {
            m_dwStatus = NO_ERROR;
        }
    }
    else
    {
        m_dwStatus = GetLastError();
        ThrowError(m_dwStatus);
    }
}

// constructor opens an existing named mutex...
CMutex::CMutex(LPCTSTR lpName, BOOL bInheritHandle, DWORD dwDesiredAccess)
{
    m_hHandle = ::OpenMutex(dwDesiredAccess, bInheritHandle, lpName);
    if (CIsValidHandle(m_hHandle))
    {
        m_dwStatus = NO_ERROR;
    }
    else
    {
        m_dwStatus = GetLastError();
    }
}

// release a lock on a mutex...
BOOL CMutex::Release(void)
{
    return ::ReleaseMutex(m_hHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cndisapi.h ===
//=================================================================

//

// NTDriverIO.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/07/99	a-peterc        Created
//
//=================================================================
#ifndef _CNDISAPI_H_
#define _CNDISAPI_H_

class CNdisApi
{
	private:
  	
	protected:
	public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
  		CNdisApi();
       ~CNdisApi();

    	UINT PnpUpdateGateway(	PCWSTR a_pAdapter ) ; 
		
		UINT PnpUpdateNbtAdapter( PCWSTR a_pAdapter ) ; 

		UINT PnpUpdateNbtGlobal( 

								BOOL a_fLmhostsFileSet,
								BOOL a_fEnableLmHosts
								) ; 
		
		UINT PnpUpdateIpxGlobal() ;
		UINT PnpUpdateIpxAdapter( PCWSTR a_pAdapter, BOOL a_fAuto ) ; 
};

#endif _CNDISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\computerapi.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  ComputerAPI.CPP
//
//***************************************************************************

#include "precomp.h"
#include "computerAPI.h"
#include "ImpersonateRevert.h"

BOOL ProviderGetComputerName ( LPWSTR lpwcsBuffer, LPDWORD nSize )
{
	BOOL bResult = FALSE;
    if ( ( bResult = GetComputerNameW(lpwcsBuffer, nSize) ) == FALSE )
	{
		DWORD dwError = ::GetLastError ();
		if ( ERROR_ACCESS_DENIED == dwError )
		{
			// The GetComputer will need to be called in the process's context.
			ProviderImpersonationRevert ir;

			if ( ir.Reverted () )
			{
				bResult = GetComputerNameW(lpwcsBuffer, nSize);
			}
			else
			{
				// I was not impersonated or revert failed
				// that means call GetComputerName failed with process credentials already
				// or will fail as I'm not reverted

				::SetLastError ( dwError );
			}
		}
	}

	return bResult;
}

BOOL ProviderGetComputerNameEx ( COMPUTER_NAME_FORMAT NameType, LPWSTR lpwcsBuffer, LPDWORD nSize )
{
	BOOL bResult = FALSE;
    if ( ( bResult = GetComputerNameExW(NameType, lpwcsBuffer, nSize) ) == FALSE )
	{
		DWORD dwError = ::GetLastError ();
		if ( ERROR_ACCESS_DENIED == dwError )
		{
			// The GetComputer will need to be called in the process's context.
			ProviderImpersonationRevert ir;

			if ( ir.Reverted () )
			{
				bResult = GetComputerNameExW(NameType, lpwcsBuffer, nSize);
			}
			else
			{
				// I was not impersonated or revert failed
				// that means call GetComputerName failed with process credentials already
				// or will fail as I'm not reverted

				::SetLastError ( dwError );
			}
		}
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cndisapi.cpp ===
//=================================================================

//

// NTDriverIO.cpp --

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/07/99	a-peterc        Created
//
//=================================================================













#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include "CNdisApi.h"
#include "ndismisc.h"




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  CNdisApi::CNdisApi()

 Description: encapsulates the functionallity of NdisHandlePnPEvent()

 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

CNdisApi::CNdisApi()
{
}

//
CNdisApi::~CNdisApi()
{
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateGateway(

PCWSTR a_pAdapter,
BOOL a_fRouterDiscovery,
BOOL a_fIPEnableRouter
)

 Description:	PNP notification of gateway changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateGateway(

PCWSTR a_pAdapter
)
{
	IP_PNP_RECONFIG_REQUEST IpReconfigRequest;

	memset( &IpReconfigRequest, NULL, sizeof( IP_PNP_RECONFIG_REQUEST ) ) ;

	// DWORD version
    IpReconfigRequest.version = IP_PNP_RECONFIG_VERSION;
	IpReconfigRequest.gatewayListUpdate = TRUE ;
	IpReconfigRequest.InterfaceMetricUpdate = TRUE ;

	IpReconfigRequest.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE |
                              IP_PNP_FLAG_INTERFACE_METRIC_UPDATE ;

	IpReconfigRequest.gatewayListUpdate  = TRUE ;
	IpReconfigRequest.InterfaceMetricUpdate = TRUE ;

	CHString t_chsAdapterDevice(L"\\Device\\") ;
			 t_chsAdapterDevice += a_pAdapter ;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, t_chsAdapterDevice ) ;

	UNICODE_STRING	t_strTcpIp ;
	RtlInitUnicodeString( &t_strTcpIp, L"Tcpip" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	UINT t_iRet = NdisHandlePnPEvent(
									NDIS,
									RECONFIGURE,
									&t_strAdapter,
									&t_strTcpIp,
									&t_strBinding,
									&IpReconfigRequest,
									sizeof( IP_PNP_RECONFIG_REQUEST )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}
	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateNbtAdapter( PCWSTR a_pAdapter )

 Description:	PNP notification of NetBios adapter level changes
 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateNbtAdapter( PCWSTR a_pAdapter )
{
	CHString t_chsAdapterDevice(L"\\Device\\") ;
			 t_chsAdapterDevice += a_pAdapter ;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, t_chsAdapterDevice ) ;

	UNICODE_STRING	t_strNetBT ;
	RtlInitUnicodeString( &t_strNetBT, L"NetBT" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// per adapter notification
	UINT t_iRet = NdisHandlePnPEvent(
									TDI,
									RECONFIGURE,
									&t_strAdapter,
									&t_strNetBT,
									&t_strBinding,
									NULL,
									0
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateNbtGlobal(

BOOL a_fLmhostsFileSet,
BOOL a_fEnableLmHosts
)

 Description:	PNP notification of NetBios global level changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateNbtGlobal(

BOOL a_fLmhostsFileSet,
BOOL a_fEnableLmHosts
)
{
	NETBT_PNP_RECONFIG_REQUEST t_NetbtReconfigRequest;

	memset( &t_NetbtReconfigRequest, NULL, sizeof( NETBT_PNP_RECONFIG_REQUEST ) ) ;

	// DWORD version
    t_NetbtReconfigRequest.version = 1;

	t_NetbtReconfigRequest.enumDnsOption = WinsThenDns;
	t_NetbtReconfigRequest.fScopeIdUpdated = FALSE;
	t_NetbtReconfigRequest.fLmhostsEnabled = a_fEnableLmHosts == 0 ? 0 : 1;
	t_NetbtReconfigRequest.fLmhostsFileSet = a_fLmhostsFileSet == 0 ? 0 : 1;


	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, L""  ) ;

	UNICODE_STRING	t_strNetBT ;
	RtlInitUnicodeString( &t_strNetBT, L"NetBT" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// global notification
	UINT t_iRet = NdisHandlePnPEvent(
									TDI,
									RECONFIGURE,
									&t_strAdapter,
									&t_strNetBT,
									&t_strBinding,
									&t_NetbtReconfigRequest,
									sizeof( NETBT_PNP_RECONFIG_REQUEST )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateIpxGlobal()

 Description:	PNP notification of IPX global level changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateIpxGlobal()
{
	RECONFIG t_IpxConfig ;

	memset( &t_IpxConfig, NULL, sizeof( RECONFIG ) ) ;

	// DWORD version
    t_IpxConfig.ulVersion = IPX_RECONFIG_VERSION;
	t_IpxConfig.InternalNetworkNumber = TRUE;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, L""  ) ;

	UNICODE_STRING	t_strIPX ;
	RtlInitUnicodeString( &t_strIPX, L"NwlnkIpx" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// global notification
	UINT t_iRet = NdisHandlePnPEvent(
									NDIS,
									RECONFIGURE,
									&t_strAdapter,
									&t_strIPX,
									&t_strBinding,
									&t_IpxConfig,
									sizeof( RECONFIG )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateIpxAdapter( PCWSTR a_pAdapter, BOOL a_fAuto )

 Description:	PNP notification of IPX adapter level changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateIpxAdapter( PCWSTR a_pAdapter, BOOL a_fAuto )
{
	RECONFIG t_IpxConfig ;

	memset( &t_IpxConfig, NULL, sizeof( RECONFIG ) ) ;

	// DWORD version
    t_IpxConfig.ulVersion = IPX_RECONFIG_VERSION;
	t_IpxConfig.InternalNetworkNumber = FALSE ;

	t_IpxConfig.AdapterParameters[ a_fAuto ? RECONFIG_AUTO_DETECT : RECONFIG_MANUAL ] = TRUE;

	// set all frame types
	memset( &t_IpxConfig.AdapterParameters[ RECONFIG_PREFERENCE_1 ],
			TRUE,
			sizeof(BOOLEAN) * 8) ;

	CHString t_chsAdapterDevice(L"\\Device\\") ;
			 t_chsAdapterDevice += a_pAdapter ;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, t_chsAdapterDevice ) ;

	UNICODE_STRING	t_strIPX ;
	RtlInitUnicodeString( &t_strIPX, L"NwlnkIpx" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// global notification
	UINT t_iRet = NdisHandlePnPEvent(
									NDIS,
									RECONFIGURE,
									&t_strAdapter,
									&t_strIPX,
									&t_strBinding,
									&t_IpxConfig,
									sizeof( RECONFIG )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cmutex.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CMutex.h -- Mutex Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================


#ifndef __CMUTEX_H__
#define __CMUTEX_H__

#include "CKernel.h"

class CMutex : public CKernel {
public:
    CMutex(BOOL bInitialOwner = FALSE, 
           LPCTSTR lpName = NULL, 
           LPSECURITY_ATTRIBUTES lpMutexAttributes = NULL);
    
    // Constructor opens an existing named mutex.
    // Check the status after using this constructor, as it will
    // NOT throw an error exception if the object cannot be opened.
    CMutex(LPCTSTR lpName, 
           BOOL bInheritHandle = FALSE, 
           DWORD dwDesiredAccess = MUTEX_ALL_ACCESS);

    // release a lock on a mutex...
    BOOL Release(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\computerapi.h ===
//***************************************************************************
//
//	Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  ComputerAPI.h
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef	__Computer_API__
#define	__Computer_API__

#ifndef	_WINBASE_
#include <winbase.h>
#endif	_WINBASE_

BOOL ProviderGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize);
BOOL ProviderGetComputerNameEx(COMPUTER_NAME_FORMAT NameType, LPWSTR lpwcsBuffer, LPDWORD nSize);

#endif	__Computer_API__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\confgmgr.h ===
//=================================================================

//

// ConfgMgr.h

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include <chstring.h>
#include <chptrarr.h>
#include "refptr.h"
#include "poormansresource.h"
//#include <cfgmgrdevice.h>
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include "dmadesc.h"
#include "devdesc.h"
#include "configmgrapi.h"

#define CFGMGR_WORRY_SIZE 250
typedef std::map<CHString, _GUID> STRING2GUID;

typedef struct _IO_INFO{
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD Alias;
    DWORD Decode;
    CHString OwnerName;
    CHString DeviceType;
} IO_INFO;


typedef struct _DMA_INFO{
    DWORD Channel;
    DWORD ChannelWidth;
    CHString OwnerDeviceId;
    CHString OwnerName;
    DWORD OEMNumber;
    CHString DeviceType;
    DWORD Port;
} DMA_INFO;

typedef struct _IRQ_INFO{
    BOOL Shareable;
    DWORD IRQNumber;
    CHString OwnerDeviceId;
    CHString OwnerName;
    DWORD OEMNumber;
    CHString DeviceType;
    DWORD Vector;
} IRQ_INFO;

typedef struct _MEM_INFO{
    DWORD StartingAddress;
    DWORD EndingAddress;
    CHString OwnerName;
    CHString DeviceType;
    CHString MemoryType;
} MEM_INFO;

class CConfigManager
{
    public:

		// The Type to get parameter should be discarded whenever we get a chance.
        CConfigManager( DWORD dwTypeToGet = ResType_All );
        ~CConfigManager()                   { ResetList();}

		//////////////////////////////////////////////////////////////////
		//	The following functions are LEGACY!  Phase these out ASAP!	//
		//	DO NOT USE!													//
		//////////////////////////////////////////////////////////////////

        BOOL BuildListsForThisDevice(CConfigMgrDevice *pDevice);
        BOOL RefreshList();

        inline IRQ_INFO * GetIRQ(int i)    {  return(( IRQ_INFO * ) m_List.GetAt(i));}
        inline DMA_INFO * GetDMA(int i)    {  return(( DMA_INFO * ) m_List.GetAt(i));}
        inline IO_INFO  * GetIO(int i)     {  return(( IO_INFO * )  m_List.GetAt(i));}
        inline MEM_INFO * GetMem(int i)    {  return(( MEM_INFO * ) m_List.GetAt(i));}

        inline int GetTotal()   { return m_List.GetSize(); }

		//////////////////////////////
		//	End Legacy functions	//
		//////////////////////////////

		BOOL GetDeviceList( CDeviceCollection& deviceList, LPCWSTR pszFilter = NULL, ULONG ulProperty = CM_DRP_MAX );
		BOOL LocateDevice( LPCWSTR pszDeviceID, CConfigMgrDevicePtr & pCfgMgrDevice );

		// Device List Helper functions
		BOOL GetDeviceListFilterByClass( CDeviceCollection& deviceList, LPCWSTR pszFilter );
		BOOL GetDeviceListFilterByService( CDeviceCollection& deviceList, LPCWSTR pszFilter );
		BOOL GetDeviceListFilterByDriver( CDeviceCollection& deviceList, LPCWSTR pszFilter );
		BOOL GetDeviceListFilterByClassGUID( CDeviceCollection& deviceList, LPCWSTR pszFilter );

        static STRING2GUID	s_ClassMap;

    private:

		// Legacy function
        void ResetList();

        static BOOL s_ClassIsValid;

        DWORD GetIRQVector(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, DWORD dwIRQNum);
        LPCWSTR GetMemoryType(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, ULONGLONG ulStartAddress);
        DWORD GetDMAPort(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, DWORD dwChannel);

		BOOL WalkDeviceTree( DEVNODE dn, CDeviceCollection& deviceList, LPCWSTR pszFilter, ULONG ulFilterProperty, CConfigMgrAPI *a_pconfigmgr );
		BOOL WalkDeviceTree2( DEVNODE dn, CDeviceCollection& deviceList,  CConfigMgrAPI *a_pconfigmgr ) ;

		// Legacy variables
        CHPtrArray m_List;
        DWORD m_dwTypeToGet;
        BOOL CheckForLoop(CDeviceCollection& deviceList, CConfigMgrDevice* pDevice);
};

// Device List Helper functions
inline BOOL CConfigManager::GetDeviceListFilterByService( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
	return GetDeviceList( deviceList, pszFilter, CM_DRP_SERVICE );
}

inline BOOL CConfigManager::GetDeviceListFilterByDriver( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
	return GetDeviceList( deviceList, pszFilter, CM_DRP_DRIVER );
}

inline BOOL CConfigManager::GetDeviceListFilterByClassGUID( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
	return GetDeviceList( deviceList, pszFilter, CM_DRP_CLASSGUID );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\confgmgr.cpp ===
//=================================================================

//

// Confgmgr.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//              10/17/97        jennymc     Created
//
/////////////////////////////////////////////////////////////////////////
#define INITGUID
#include "precomp.h"
#include <cregcls.h>
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include "DllUtils.h"
#include "dmadesc.h"
#include <brodcast.h>
#include <lockwrap.h>
#include "strings.h"
#include <smartptr.h>

#include <devguid.h>

static CCritSec map;
STRING2GUID	CConfigManager::s_ClassMap;
BOOL CConfigManager::s_ClassIsValid = FALSE;


CConfigManager::CConfigManager( DWORD dwTypeToGet )
{
    m_dwTypeToGet = dwTypeToGet;

    if (!s_ClassIsValid)
    {
        CLockWrapper t_lockMap( map ) ;

        // Check again now that we have the lock
        if (!s_ClassIsValid)
        {
            s_ClassMap[_T("1394")] = GUID_DEVCLASS_1394;
            s_ClassMap[_T("ADAPTER")] = GUID_DEVCLASS_ADAPTER;
            s_ClassMap[_T("APMSUPPORT")] = GUID_DEVCLASS_APMSUPPORT;
            s_ClassMap[_T("BATTERY")] = GUID_DEVCLASS_BATTERY;
            s_ClassMap[_T("CDROM")] = GUID_DEVCLASS_CDROM;
            s_ClassMap[_T("COMPUTER")] = GUID_DEVCLASS_COMPUTER;
            s_ClassMap[_T("DECODER")] = GUID_DEVCLASS_DECODER;
            s_ClassMap[_T("DISKDRIVE")] = GUID_DEVCLASS_DISKDRIVE;
            s_ClassMap[_T("DISPLAY")] = GUID_DEVCLASS_DISPLAY;
            s_ClassMap[_T("FDC")] = GUID_DEVCLASS_FDC;
            s_ClassMap[_T("FLOPPYDISK")] = GUID_DEVCLASS_FLOPPYDISK;
            s_ClassMap[_T("GPS")] = GUID_DEVCLASS_GPS;
            s_ClassMap[_T("HDC")] = GUID_DEVCLASS_HDC;
            s_ClassMap[_T("HIDCLASS")] = GUID_DEVCLASS_HIDCLASS;
            s_ClassMap[_T("IMAGE")] = GUID_DEVCLASS_IMAGE;
            s_ClassMap[_T("INFRARED")] = GUID_DEVCLASS_INFRARED;
            s_ClassMap[_T("KEYBOARD")] = GUID_DEVCLASS_KEYBOARD;
            s_ClassMap[_T("LEGACYDRIVER")] = GUID_DEVCLASS_LEGACYDRIVER;
            s_ClassMap[_T("MEDIA")] = GUID_DEVCLASS_MEDIA;
            s_ClassMap[_T("MODEM")] = GUID_DEVCLASS_MODEM;
            s_ClassMap[_T("MONITOR")] = GUID_DEVCLASS_MONITOR;
            s_ClassMap[_T("MOUSE")] = GUID_DEVCLASS_MOUSE;
            s_ClassMap[_T("MTD")] = GUID_DEVCLASS_MTD;
            s_ClassMap[_T("MULTIFUNCTION")] = GUID_DEVCLASS_MULTIFUNCTION;
            s_ClassMap[_T("MULTIPORTSERIAL")] = GUID_DEVCLASS_MULTIPORTSERIAL;
            s_ClassMap[_T("NET")] = GUID_DEVCLASS_NET;
            s_ClassMap[_T("NETCLIENT")] = GUID_DEVCLASS_NETCLIENT;
            s_ClassMap[_T("NETSERVICE")] = GUID_DEVCLASS_NETSERVICE;
            s_ClassMap[_T("NETTRANS")] = GUID_DEVCLASS_NETTRANS;
            s_ClassMap[_T("NODRIVER")] = GUID_DEVCLASS_NODRIVER;
            s_ClassMap[_T("PCMCIA")] = GUID_DEVCLASS_PCMCIA;
            s_ClassMap[_T("PORTS")] = GUID_DEVCLASS_PORTS;
            s_ClassMap[_T("PRINTER")] = GUID_DEVCLASS_PRINTER;
            s_ClassMap[_T("PRINTERUPGRADE")] = GUID_DEVCLASS_PRINTERUPGRADE;
            s_ClassMap[_T("SCSIADAPTER")] = GUID_DEVCLASS_SCSIADAPTER;
            s_ClassMap[_T("SMARTCARDREADER")] = GUID_DEVCLASS_SMARTCARDREADER;
            s_ClassMap[_T("SOUND")] = GUID_DEVCLASS_SOUND;
            s_ClassMap[_T("SYSTEM")] = GUID_DEVCLASS_SYSTEM;
            s_ClassMap[_T("TAPEDRIVE")] = GUID_DEVCLASS_TAPEDRIVE;
            s_ClassMap[_T("UNKNOWN")] = GUID_DEVCLASS_UNKNOWN;
            s_ClassMap[_T("USB")] = GUID_DEVCLASS_USB;
            s_ClassMap[_T("VOLUME")] = GUID_DEVCLASS_VOLUME;

            s_ClassIsValid = TRUE;
        }

    }

}
////////////////////////////////////////////////////////////////////////
//
//  Reads the config manager registry keys for win98 and win95
//
////////////////////////////////////////////////////////////////////////
BOOL CConfigManager::BuildListsForThisDevice(CConfigMgrDevice *pDevice)
{
    CResourceCollection	resourceList;
    CHString sDeviceName, sClass, sKey(_T("Enum\\"));
    BOOL fRc = FALSE;
    CRegistry RegInfo;

	// Extract the device name
	sDeviceName = pDevice->GetDeviceDesc();
	// Pull the resource list out and enumerate it.
	pDevice->GetResourceList( resourceList );

   sKey += pDevice->GetHardwareKey();
   if (RegInfo.Open(HKEY_LOCAL_MACHINE, sKey, KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue(L"Class", sClass);
   }

	REFPTR_POSITION	pos;

	if ( resourceList.BeginEnum( pos ) ){
        PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor = NULL;// Watch the scoping on this guy!
        DWORD dwCount = 0;

#if NTONLY >= 5
        // Go find the resource descriptor for this device
        CHString sRegKeyName;
        CRegistry Reg;
        CSmartBuffer Buffer;  // Watch the scoping on this guy!

        if ( (Reg.Open(HKEY_LOCAL_MACHINE, L"hardware\\resourcemap\\PnP Manager\\PNPManager", KEY_QUERY_VALUE) == ERROR_SUCCESS) &&
            pDevice->GetPhysicalDeviceObjectName(sRegKeyName) )
        {
            sRegKeyName += L".raw";

            DWORD dwValueType;
            DWORD dwValueDataSize = Reg.GetLongestValueData() + 2 ;

            Buffer = new BYTE[dwValueDataSize];

            if ((LPBYTE)Buffer == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            if(RegQueryValueEx(Reg.GethKey(), sRegKeyName, NULL,
                            &dwValueType, (LPBYTE)Buffer, &dwValueDataSize) == ERROR_SUCCESS)
            {
                if(dwValueType == REG_FULL_RESOURCE_DESCRIPTOR)
                {
                    dwCount         = 1 ;
                    pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) (LPBYTE)Buffer ;// Watch the scoping on this guy!
                }
                else if(dwValueType == REG_RESOURCE_LIST)
                {
                    dwCount         = ((PCM_RESOURCE_LIST) (LPBYTE)Buffer)->Count ;
                    pFullDescriptor = ((PCM_RESOURCE_LIST) (LPBYTE)Buffer)->List ;// Watch the scoping on this guy!
                }
            }
        }
#endif

        CHString sResource;
        //=========================================================
		// For each descriptor we find, if it's not ignored,
        // we should get the string data, and place it in the
        // appropriate list based on Type.
        //=========================================================
        CResourceDescriptorPtr pResDesc;
		for( pResDesc.Attach(resourceList.GetNext( pos ));
			 NULL != pResDesc;
             pResDesc.Attach(resourceList.GetNext( pos )) )

	    {
		    DWORD t_dwResType = pResDesc->GetResourceType();

	    	if ( (!pResDesc->IsIgnored()) &&
                ((m_dwTypeToGet == ResType_All) || (m_dwTypeToGet == t_dwResType) ) )
            {

			    switch ( t_dwResType )
                {

		    		case ResType_DMA:

                        DMA_INFO  *pDMA_Info;
                        DMA_DES  *pTmp;
                        pDMA_Info = new DMA_INFO;
                        if (pDMA_Info != NULL)
                        {

                            try
                            {
                                DWORD dwChannelWidth;

                                pTmp = (DMA_DES*) pResDesc->GetResource();
                                dwChannelWidth = (pTmp->DD_Flags) & 0x0003;

                                pDMA_Info->ChannelWidth = 0;
                                if( dwChannelWidth == 0 )
                                {
                                    pDMA_Info->ChannelWidth = 8;
                                }
                                else if( dwChannelWidth == 1 )
                                {
                                    pDMA_Info->ChannelWidth = 16;
                                }
                                else if( dwChannelWidth == 2 )
                                {
                                    pDMA_Info->ChannelWidth = 32;
                                }

						        pDMA_Info->DeviceType = sClass;
                                pDMA_Info->Channel      = pTmp->DD_Alloc_Chan;
                                pResDesc->GetOwnerDeviceID(pDMA_Info->OwnerDeviceId);
                                pResDesc->GetOwnerName(pDMA_Info->OwnerName);
                                pDMA_Info->OEMNumber = pResDesc->GetOEMNumber();
                                pDMA_Info->Port = GetDMAPort(pFullDescriptor, dwCount, pTmp->DD_Alloc_Chan);
                            }
                            catch ( ... )
                            {
                                delete pDMA_Info;
                                throw ;
                            }

						    // real DMA channels are in the range 0-7
						    // sometimes the confug mugger reports channels
						    // with great big numbers - we don't care
						    if (pDMA_Info->Channel < 8)
                            {
                                try
                                {
			    			        m_List.Add(pDMA_Info);
                                }
                                catch ( ... )
                                {
                                    delete pDMA_Info;
                                    throw ;
                                }
                            }
						    else
                            {
							    delete pDMA_Info;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

	    				break;

			    	case ResType_IRQ:
                        IRQ_INFO  *pIRQ_Info;
                        IRQ_DES  *pTmpIrq;
                        pIRQ_Info = new IRQ_INFO;

                        if (pIRQ_Info != NULL)
                        {
                            try
                            {
                                pTmpIrq = (IRQ_DES*) pResDesc->GetResource();

                                pIRQ_Info->Shareable = pTmpIrq->IRQD_Flags;
	                            pIRQ_Info->IRQNumber = pTmpIrq->IRQD_Alloc_Num;		// Allocated IRQ number

						        pIRQ_Info->DeviceType = sClass;
                                pResDesc->GetOwnerDeviceID(pIRQ_Info->OwnerDeviceId);
                                pResDesc->GetOwnerName(pIRQ_Info->OwnerName);
                                pIRQ_Info->OEMNumber = pResDesc->GetOEMNumber();
                                pIRQ_Info->Vector = GetIRQVector(pFullDescriptor, dwCount, pTmpIrq->IRQD_Alloc_Num);

			    		        m_List.Add(pIRQ_Info);
                            }
                            catch ( ... )
                            {
                                delete pIRQ_Info;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

				    	break;

			    	case ResType_IO:
                        IO_INFO  *pIO_Info;
                        IOWBEM_DES  *pTmpIO;
                        pIO_Info = new IO_INFO;

                        if (pIO_Info != NULL)
                        {
                            try
                            {

                                pTmpIO = (IOWBEM_DES*) pResDesc->GetResource();

                                pIO_Info->DeviceType = sClass;
                                pIO_Info->StartingAddress = pTmpIO->IOD_Alloc_Base;
                                pIO_Info->EndingAddress = pTmpIO->IOD_Alloc_End;
                                pIO_Info->Alias = pTmpIO->IOD_Alloc_Alias;
                                pIO_Info->Decode = pTmpIO->IOD_Alloc_Decode;
                                pResDesc->GetOwnerName(pIO_Info->OwnerName);
                                m_List.Add(pIO_Info);
                            }
                            catch ( ... )
                            {
                                delete pIO_Info;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                        break;

			    	case ResType_Mem:
                        MEM_INFO  *pMem_Info;
                        MEM_DES  *pTmpMem;
                        pMem_Info = new MEM_INFO;

                        if (pMem_Info != NULL)
                        {
                            try
                            {
                                pTmpMem = (MEM_DES*) pResDesc->GetResource();

						        pMem_Info->DeviceType = sClass;
                 		        pMem_Info->StartingAddress = pTmpMem->MD_Alloc_Base;
                 		        pMem_Info->EndingAddress = pTmpMem->MD_Alloc_End;
                                pResDesc->GetOwnerName(pMem_Info->OwnerName);
                                pMem_Info->MemoryType = GetMemoryType(pFullDescriptor, dwCount, pTmpMem->MD_Alloc_Base);

			    		        m_List.Add(pMem_Info);
                            }
                            catch ( ... )
                            {
                                delete pMem_Info;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

				    	break;


				}	// SWITCH
			}	// IF !IsIgnored

		}	// For EnumResources

		resourceList.EndEnum();

	}	// IF BeginEnum()

    return fRc;
}
////////////////////////////////////////////////////////////////////////
void CConfigManager::ResetList()
{
   IO_INFO  *pIOInfo;
   IRQ_INFO  *pIRQInfo;
   DMA_INFO  *pDMAInfo;
   MEM_INFO  *pMemInfo;

   int nNum =  m_List.GetSize();

   for( int i=0; i < nNum; i++ ){
      switch (m_dwTypeToGet) {

         case ResType_DMA:
            pDMAInfo = ( DMA_INFO *) m_List.GetAt(i);
            delete pDMAInfo;
            break;

         case ResType_IRQ:
            pIRQInfo = ( IRQ_INFO *) m_List.GetAt(i);
            delete pIRQInfo;
            break;

         case ResType_IO:
            pIOInfo = ( IO_INFO *) m_List.GetAt(i);
            delete pIOInfo;
            break;

         case ResType_Mem:
            pMemInfo = ( MEM_INFO *) m_List.GetAt(i);
            delete pMemInfo;
            break;

         default:
            ASSERT_BREAK(0);
            break;
      }
   }
   m_List.RemoveAll();
}
////////////////////////////////////////////////////////////////////////
BOOL CConfigManager::RefreshList()
{
    BOOL bRc = FALSE;
    //===========================================================
    //  Reset lists
    //===========================================================
    ResetList();

	// Get all the available devices and check each of them for resources used
	CDeviceCollection	deviceList;

	if ( GetDeviceList( deviceList ) )
	{
		REFPTR_POSITION	pos;

		if ( deviceList.BeginEnum( pos ) )
		{

			CConfigMgrDevicePtr	pDevice;

			for ( pDevice.Attach(deviceList.GetNext( pos )) ;
                  pDevice != NULL;
                  pDevice.Attach(deviceList.GetNext( pos )))
			{
				BuildListsForThisDevice(pDevice);
			}

			// For every begin, there is an End
			deviceList.EndEnum();

		}	// BeginEnum

		bRc = TRUE;
	}

	return bRc;

/*
    //===========================================================
    //  Enumerate all
    //===========================================================
    CRegistry Reg;
    CHString sDevice;

    if( ERROR_SUCCESS == Reg.OpenAndEnumerateSubKeys(HKEY_DYN_DATA, "Config Manager\\Enum", KEY_READ )){

        while( ERROR_SUCCESS == Reg.GetCurrentSubKeyName(sDevice) ){

            //===========================================================
	        // Since we're keeping back pointers to the Device Object,
	        // new him, rather than keeping him on the stack so we're
	        // not dependent on the order of destruction as to how
	        // safe we are.
            //===========================================================
	        CConfigMgrDevice *pDevice = new CConfigMgrDevice(sDevice,m_dwTypeToGet);
            if ( NULL != pDevice ){
                if( !BuildListsForThisDevice(pDevice) ){
		        // We're done with this pointer
                   delete pDevice;
                }
                // otherwise ptr is deleted after device is added to list
	        }	// IF NULL != pDevice
            bRc = TRUE;
			if( Reg.NextSubKey() != ERROR_SUCCESS ){
				break;
			}

        }
    }
    return bRc;
*/
}

// valid properties for filtering
//#define CM_DRP_DEVICEDESC                  (0x00000001) // DeviceDesc REG_SZ property (RW)
//#define CM_DRP_SERVICE                     (0x00000005) // Service REG_SZ property (RW)
//#define CM_DRP_CLASS                       (0x00000008) // Class REG_SZ property (RW)
//#define CM_DRP_CLASSGUID                   (0x00000009) // ClassGUID REG_SZ property (RW)
//#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)
//#define CM_DRP_MFG                         (0x0000000C) // Mfg REG_SZ property (RW)
//#define CM_DRP_FRIENDLYNAME                (0x0000000D) // FriendlyName REG_SZ property (RW)
//#define CM_DRP_LOCATION_INFORMATION        (0x0000000E) // LocationInformation REG_SZ property (RW)
//#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000F) // PhysicalDeviceObjectName REG_SZ property (R)
//#define CM_DRP_MIN                         (0x00000001)
//#define CM_DRP_MAX                         (0x00000017)

BOOL CConfigManager::GetDeviceList( CDeviceCollection& deviceList, LPCWSTR pszFilter/*=NULL*/, ULONG ulProperty/*=CM_DRP_MAX*/ )
{
	CONFIGRET		cr = CR_INVALID_POINTER;

	// Dump the list first
	deviceList.Empty();

	DEVNODE dnRoot;
	CConfigMgrAPI*	t_pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	try
	{
		if ( t_pconfigmgr )
		{
			if ( t_pconfigmgr->IsValid () )
			{
				if ( CR_SUCCESS == ( cr = t_pconfigmgr->CM_Locate_DevNode( &dnRoot, NULL, 0 ) ) )
				{
					DEVNODE dnFirst;
					if ( CR_SUCCESS == ( cr = t_pconfigmgr->CM_Get_Child( &dnFirst, dnRoot, 0 ) ) )
					{
						// This should only fail in case we are unable to allocate a device
						if ( !WalkDeviceTree( dnFirst, deviceList, pszFilter, ulProperty, t_pconfigmgr ) )
						{
							cr = CR_OUT_OF_MEMORY;
						}
					}
				}

				CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
				t_pconfigmgr = NULL ;
			}
			else
			{
				::SetLastError ( t_pconfigmgr->GetCreationError () );
			}
		}
	}
	catch ( ... )
	{
		if ( t_pconfigmgr )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
			t_pconfigmgr = NULL ;
		}
		throw ;
	}

	return ( CR_SUCCESS == cr );
}

// This device MUST be Released!
BOOL CConfigManager::LocateDevice( LPCWSTR pszDeviceID, CConfigMgrDevicePtr & pCfgMgrDevice )
{
	CONFIGRET		cr = CR_INVALID_POINTER;

    if ( (pszDeviceID != NULL) && (pszDeviceID[0] != L'\0') )
    {
	    CConfigMgrAPI*	t_pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	    try
	    {
		    if ( t_pconfigmgr )
		    {
				if ( t_pconfigmgr->IsValid ()  )
				{
					DEVNODE dnRoot;

					if ( CR_SUCCESS == ( cr = t_pconfigmgr->CM_Locate_DevNode( &dnRoot, bstr_t(pszDeviceID), 0 ) ) )
					{
						pCfgMgrDevice.Attach(new CConfigMgrDevice( dnRoot, m_dwTypeToGet ));
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
					t_pconfigmgr = NULL ;
				}
				else
				{
					::SetLastError ( t_pconfigmgr->GetCreationError () );
				}
		    }
	    }
	    catch ( ... )
	    {
		    if ( t_pconfigmgr )
		    {
			    CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
			    t_pconfigmgr = NULL ;
		    }
		    throw ;
	    }
    }

	return ( CR_SUCCESS == cr );
}

BOOL CConfigManager::WalkDeviceTree( DEVNODE dn, CDeviceCollection& deviceList, LPCWSTR pszFilter, ULONG ulFilterProperty, CConfigMgrAPI *a_pconfigmgr )
{
    BOOL fReturn = TRUE;

    // While it would make more sense to check the filter in WalkDeviceTree2,
    // we can't.  Config manager sometimes has a loop in its nodes.  As a result,
    // we need to be checking the entire list for a loop, so we need to apply
    // the filter here.

    if ( NULL == pszFilter)
    {
        // Load ALL the nodes
        fReturn = WalkDeviceTree2(dn, deviceList, a_pconfigmgr );
    }
    else
    {
        CDeviceCollection deviceList2;
        CConfigMgrDevicePtr	pDevice;
        fReturn = WalkDeviceTree2(dn, deviceList2, a_pconfigmgr );

        if (fReturn)
        {
            // Walk all the nodes looking for ones that match the filter.  Copy the matches
            // to the passed in array.

            CHString strFilterValue;
            DWORD dwSize = deviceList2.GetSize();
            for (int x=0; x < dwSize; x++)
            {
                pDevice.Attach(deviceList2.GetAt(x));
                // Apply our filter, and save the device pointer to the list only
                // if the device property value is the same as the filter.

                if ( pDevice->GetStringProperty( ulFilterProperty, strFilterValue ) )
                {
                    if ( strFilterValue.CompareNoCase( pszFilter ) == 0 )
                    {
                        fReturn = deviceList.Add( pDevice );
                    }
                }
            }
        }
    }

    return fReturn;
}

BOOL CConfigManager::WalkDeviceTree2( DEVNODE dn, CDeviceCollection& deviceList, CConfigMgrAPI *a_pconfigmgr )

{
	BOOL				fReturn = TRUE;	// Assume TRUE, the only failure is where we
										// beef allocating a device.
    BOOL                fIsLoop = FALSE; // Config manager has a bug that causes a loop in device lists<sigh>
    CConfigMgrDevicePtr	pDevice;
//	CHString			strFilterValue;
    DEVNODE				dnSibling,
						dnChild;

	// We're walking the list for siblings and children.  Waliing for siblings
	// is done in the context of the following loop, since siblings are at
	// the same level in the tree.  Walking for children is, of course, recursive.

    do
    {
		// Store siblings, since we will proceed from it to the next
		// sibling.

		if ( CR_SUCCESS != a_pconfigmgr->CM_Get_Sibling( &dnSibling, dn, 0 ) )
		{
			dnSibling = NULL;
		}

		// Allocate a new device, and if it passes through our filter, or if
		// there is no filter, go ahead and store the device in the device collection.

		pDevice.Attach(new CConfigMgrDevice( dn, m_dwTypeToGet ));

		if	( NULL != pDevice )
		{

            if (deviceList.GetSize() > CFGMGR_WORRY_SIZE)
            {
                fIsLoop = CheckForLoop(deviceList, pDevice);
            }

            if (!fIsLoop)
            {
                // While it would make more sense to check the filter in WalkDeviceTree2,
                // we can't.  Config manager sometimes has a loop in its nodes.  As a result,
                // we need to be checking the entire list for a loop, so we need to apply
                // the filter here.

				fReturn = deviceList.Add( pDevice );
            }

		}	// IF NULL != pszDevice
		else
		{
			// We just beefed on memory, so bail out while the gettin's good
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

		// If we have a child, we must walk recursively.
		// Note that fReturn of FALSE supercedes all of this.

		if ( fReturn &&	!fIsLoop && CR_SUCCESS == a_pconfigmgr->CM_Get_Child( &dnChild, dn, 0 ) )
		{
			fReturn = WalkDeviceTree2( dnChild, deviceList, a_pconfigmgr );
		}

		// The new active node will be our sibling.
		dn = dnSibling;

    } while ( fReturn && NULL != dn && !fIsLoop );

    return fReturn;
}

// Check to see if pInDevice already exists in deviceList
BOOL CConfigManager::CheckForLoop(CDeviceCollection& deviceList, CConfigMgrDevice *pInDevice)
{
    DWORD dwSize, x, y;
    BOOL bIsLoop = FALSE;
    CConfigMgrDevicePtr pDevice1;
    CConfigMgrDevicePtr pDevice2;

    // Get the list size
    dwSize = deviceList.GetSize()-1;

    // If it is in here, it is probably close to the end, let's walk backward
    for (x = dwSize; ((x > 0) && (!bIsLoop)); x--)
    {
        pDevice1.Attach(deviceList.GetAt(x));

        // This compares the device nodes (see CConfigMgrDevice)
        if (*pDevice1 == *pInDevice)
        {
            // Yup, there's a loop
            bIsLoop = TRUE;
        }
    }

    // If there is a loop, let's drop off the duplicated elements
    if (bIsLoop)
    {
        // Remember, x get decremented one more time from the last loop
        y = dwSize;
        do {
            pDevice1.Attach(deviceList.GetAt(x--));
            pDevice2.Attach(deviceList.GetAt(y--));
        } while ((*pDevice1 == *pDevice2) && (x > 0));

        // Delete all the duplicate elements
        y++;
        for (x = dwSize; x > y; x--)
        {
            deviceList.Remove(x);
        }
    }

    return bIsLoop;
}

BOOL CConfigManager::GetDeviceListFilterByClass( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
#ifdef NTONLY
    if (IsWinNT5())
    {
        CHString sClassName(pszFilter);
        sClassName.MakeUpper();
        WCHAR cGuid[128];

        StringFromGUID2(s_ClassMap[sClassName], cGuid, sizeof(cGuid)/sizeof(WCHAR));

	    return GetDeviceList( deviceList, cGuid, CM_DRP_CLASSGUID );
    }
    else
    {
    	return GetDeviceList( deviceList, pszFilter, CM_DRP_CLASS );
    }

#else
	return GetDeviceList( deviceList, pszFilter, CM_DRP_CLASS );
#endif
}

// Given a FULL_RESOURCE_DESCRIPTOR, find the specified IRQ number, and return its vector
DWORD CConfigManager::GetIRQVector(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwFullCount, DWORD dwIRQNum)
{
    if	(NULL != pFullDescriptor)
    {
        PCM_PARTIAL_RESOURCE_LIST pPartialList ;

        for (DWORD x=0; x < dwFullCount; x++)
        {
            pPartialList = &pFullDescriptor->PartialResourceList ;

            for (DWORD y = 0; y < pPartialList->Count; y++)
            {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = &pPartialList->PartialDescriptors[y];

                if ( (CmResourceTypeInterrupt == pDescriptor->Type) &&
                     ( pDescriptor->u.Interrupt.Level == dwIRQNum)
                   )
                {
                    return pDescriptor->u.Interrupt.Vector;
                }
            }

            pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;

        }

        ASSERT_BREAK(0);

    }

    return 0xffffffff;
}

// Given a FULL_RESOURCE_DESCRIPTOR, find the specified DMA channel, and return its port
DWORD CConfigManager::GetDMAPort(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwFullCount, DWORD dwChannel)
{
	if	(NULL != pFullDescriptor)
    {
        PCM_PARTIAL_RESOURCE_LIST pPartialList ;

        for (DWORD x=0; x < dwFullCount; x++)
        {
            pPartialList = &pFullDescriptor->PartialResourceList ;

            for (DWORD y = 0; y < pPartialList->Count; y++)
            {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = &pPartialList->PartialDescriptors[y];

                if ( (CmResourceTypeDma == pDescriptor->Type) &&
                     ( pDescriptor->u.Dma.Channel == dwChannel)
                   )
                {
                    return pDescriptor->u.Dma.Port;
                }
            }

            pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;
        }

        ASSERT_BREAK(0);

    }

    return 0xffffffff;
}

// Given a FULL_RESOURCE_DESCRIPTOR, find the specified startingaddress, and return its MemoryType
LPCWSTR CConfigManager::GetMemoryType(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, ULONGLONG ulStartAddress)
{
	if	(NULL != pFullDescriptor)
    {
        PCM_PARTIAL_RESOURCE_LIST pPartialList ;

        for (DWORD x=0; x < dwCount; x++)
        {
            pPartialList = &pFullDescriptor->PartialResourceList ;

            for (DWORD y = 0; y < pPartialList->Count; y++)
            {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = &pPartialList->PartialDescriptors[y];

                LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

                liTemp.HighPart = pDescriptor->u.Memory.Start.HighPart;
                liTemp.LowPart = pDescriptor->u.Memory.Start.LowPart;

                if ( (CmResourceTypeMemory == pDescriptor->Type) &&
                     ( liTemp.QuadPart == ulStartAddress)
                   )
                {
                    switch(pDescriptor->Flags)
	                {
                        case CM_RESOURCE_MEMORY_READ_WRITE :
		                {
			                return IDS_MTReadWrite;
		                }

                        case CM_RESOURCE_MEMORY_READ_ONLY:
		                {
			                return IDS_MTReadOnly;
		                }

                        case CM_RESOURCE_MEMORY_WRITE_ONLY:
		                {
			                return IDS_MTWriteOnly;
		                }

                        case CM_RESOURCE_MEMORY_PREFETCHABLE:
		                {
			                return IDS_MTPrefetchable;
		                }
                    }

                    return L"";
                }
            }

            pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;
        }

        ASSERT_BREAK(0);

    }

    return L"";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\configmgrapi.h ===
//=================================================================

//

// CfgMgr32.h

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	__CFGMGR32_H__
#define	__CFGMGR32_H__

extern "C"
{
#include <cfgmgr32.h>
}

#ifdef WIN9XONLY
#include "Cim32NetApi.h"
#endif

#include "sms95lanexp.h"

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "ResourceManager.h"
#include "TimedDllResource.h"
extern const GUID guidCFGMGRAPI ;


typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_CONNECT_MACHINEA)	(	PCSTR		UNCServerName,
																	PHMACHINE	phMachine
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_DISCONNECT_MACHINE)	(	HMACHINE	hMachine
																	);
typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_LOCATE_DEVNODE)	(	PDEVINST	pdnDevInst,
																	TCHAR       *pDeviceID,
																	ULONG		ulFlags
																	);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_PARENT)		(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_CHILD)			(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_SIBLING)		(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);


typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY)		(	DEVINST	dnDevInst,
																						ULONG	ulProperty,
																						PULONG	pulRegDataType,
																						PVOID	Buffer,
																						PULONG	pulLength,
																						ULONG	ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVNODE_STATUS)					(	PULONG	pulStatus,
																						PULONG	pulProblemNumber,
																						DEVINST	dnDevInst,
																						ULONG	ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_FIRST_LOG_CONF)					(	PLOG_CONF plcLogConf,
																						DEVINST   dnDevInst,
																						ULONG     ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_NEXT_RES_DES)						(	PRES_DES    prdResDes,
																						RES_DES     rdResDes,
																						RESOURCEID  ForResource,
																						PRESOURCEID pResourceID,
																						ULONG       ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_RES_DES_DATA)						(	RES_DES  rdResDes,
																						PVOID    Buffer,
																						ULONG    BufferLen,
																						ULONG    ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_RES_DES_DATA_SIZE)					(	PULONG   pulSize,
																						RES_DES  rdResDes,
																						ULONG    ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_FREE_LOG_CONF_HANDLE)					(	LOG_CONF  lcLogConf
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_FREE_RES_DES_HANDLE)					(	RES_DES    rdResDes
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVICE_IDA)						(	DEVNODE		dnDevNode,
																						PCHAR		Buffer,
																						ULONG		BufferLen,
																						ULONG		ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVICE_ID_SIZE)					(	PULONG		pulLen,
																						DEVNODE		dnDevNode,
																						ULONG		ulFlags
																					);

class CConfigMgrAPI : public CTimedDllResource
{
public:

	CConfigMgrAPI();
	~CConfigMgrAPI();

	BOOL IsValid () ;

	CONFIGRET	CM_Connect_MachineA( PCSTR UNCServerName, PHMACHINE phMachine );
	CONFIGRET	CM_Disconnect_Machine( HMACHINE hMachine );
	CONFIGRET	CM_Get_Parent( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Child( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Sibling( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Locate_DevNode( PDEVINST pdnDevInst, TCHAR *pDeviceID, ULONG ulFlags );
	CONFIGRET	CM_Get_DevNode_Registry_PropertyA( DEVINST dnDevInst, ULONG ulProperty, PULONG pulRegDataType,
													PVOID Buffer, PULONG pulLength, ULONG ulFlags );
	CONFIGRET	CM_Get_DevNode_Status( PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVINST dnDevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
	CONFIGRET	CM_Get_Res_Des_Data( RES_DES rdResDes, PVOID Buffer, ULONG BufferLen, ULONG ulFlags );
	CONFIGRET	CM_Get_Res_Des_Data_Size( PULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
	CONFIGRET	CM_Free_Log_Conf_Handle( LOG_CONF lcLogConf );
	CONFIGRET	CM_Free_Res_Des_Handle( RES_DES rdResDes );
	CONFIGRET	CM_Get_Device_IDA(	DEVNODE dnDevNode, PCHAR Buffer, ULONG BufferLen, ULONG ulFlags );
	CONFIGRET	CM_Get_Device_ID_Size( PULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );

	// Win 95/98 only
#ifdef WIN9XONLY
	CONFIGRET	CM_Get_Bus_Info( DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags );

    // So far these are only needed on 9x.
    CONFIGRET   CM_Query_Arbitrator_Free_Data(PVOID pData, ULONG DataLen, DEVINST dnDevInst, RESOURCEID ResourceID, ULONG ulFlags);
    CONFIGRET   CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags);
    CONFIGRET   CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags);
    CONFIGRET   CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags);
    CONFIGRET   CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags);
#endif

private:

#ifdef NTONLY
	HINSTANCE	m_hConfigMgrDll;
#endif
#ifdef WIN9XONLY
    CCim32NetApi* m_pCim32NetApi;
#endif

#ifdef NTONLY
	// 32-bit Config Manager pointers
	PCFGMGR32_CM_CONNECT_MACHINEA		m_pCM_Connect_MachineA;
	PCFGMGR32_CM_DISCONNECT_MACHINE		m_pCM_Disconnect_Machine;
	PCFGMGR32_CM_LOCATE_DEVNODE 		m_pCM_Locate_DevNode;
	PCFGMGR32_CM_GET_CHILD				m_pCM_Get_Child;
	PCFGMGR32_CM_GET_SIBLING			m_pCM_Get_Sibling;
	PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY		m_pCM_Get_DevNode_Registry_Property;
	PCFGMGR32_CM_GET_DEVNODE_STATUS		m_pCM_Get_DevNode_Status;
	PCFGMGR32_CM_GET_FIRST_LOG_CONF		m_pCM_Get_First_Log_Config;
	PCFGMGR32_CM_GET_NEXT_RES_DES		m_pCM_Get_Next_Res_Des;
	PCFGMGR32_CM_GET_RES_DES_DATA		m_pCM_Get_Res_Des_Data;
	PCFGMGR32_CM_GET_RES_DES_DATA_SIZE	m_pCM_Get_Res_Des_Data_Size;
	PCFGMGR32_CM_FREE_LOG_CONF_HANDLE	m_pCM_Free_Log_Conf_Handle;
	PCFGMGR32_CM_FREE_RES_DES_HANDLE	m_pCM_Free_Res_Des_Handle;
	PCFGMGR32_CM_GET_DEVICE_IDA			m_pCM_Get_Device_IDA;
	PCFGMGR32_CM_GET_DEVICE_ID_SIZE		m_pCM_Get_Device_ID_Size;
	PCFGMGR32_CM_GET_PARENT				m_pCM_Get_Parent;
#endif

#ifdef WIN9XONLY
	// 16-bit Config Manager Thunking Pass-Thrus
/*
	PCIM32THK_CM_LOCATE_DEVNODE			m_pCM16_Locate_DevNode;
	PCIM32THK_CM_GET_CHILD				m_pCM16_Get_Child;
	PCIM32THK_CM_GET_SIBLING			m_pCM16_Get_Sibling;
	PCIM32THK_CM_READ_REGISTRY_VALUE	m_pCM16_Read_Registry_Value;
	PCIM32THK_CM_GET_DEVNODE_STATUS		m_pCM16_Get_DevNode_Status;
	PCIM32THK_CM_GET_DEVICE_ID			m_pCM16_Get_Device_ID;
	PCIM32THK_CM_GET_DEVICE_ID_SIZE		m_pCM16_Get_Device_ID_Size;
	PCIM32THK_CM_GET_FIRST_LOG_CONF		m_pCM16_Get_First_Log_Conf;
	PCIM32THK_CM_GET_NEXT_RES_DES		m_pCM16_Get_Next_Res_Des;
	PCIM32THK_CM_GET_RES_DES_DATA_SIZE	m_pCM16_Get_Res_Des_Data_Size;
	PCIM32THK_CM_GET_RES_DES_DATA		m_pCM16_Get_Res_Des_Data;
	PCIM32THK_CM_GET_BUS_INFO			m_pCM16_Get_Bus_Info;
	PCIM32THK_CM_GET_PARENT				m_pCM16_Get_Parent;
*/
#endif

	const static char*					s_pszRegistryStrings[];
	static ULONG						s_pszRegistryValueTypes[];
};

// CIM16 registry ULONG to Str conversions
#define CM_DRP_DEVICEDESC_S						"DeviceDesc" // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID_S						"HardwareID" // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS_S					"CompatibleIDs" // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_NTDEVICEPATHS_S					"NtDevicePaths" // NTDevicePaths (NT4)
#define CM_DRP_SERVICE_S 						"Service" // Service REG_SZ property (RW)
#define CM_DRP_CONFIGURATION_S					"Configuration" // Configuration (NT4)
#define CM_DRP_CONFIGURATIONVECTOR_S			"ConfigurationVector" // ConfigurationVector(NT4)
#define CM_DRP_CLASS_S							"Class" // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID_S						"ClassGUID" // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER_S							"Driver" // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS_S					"ConfigFlags" // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG_S							"Mfg" // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME_S					"FriendlyName" // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION_S			"LocationInformation" // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S	"PhysicalDeviceObjectName" // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES_S					"Capabilities" // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER_S						"UiNumber" // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS_S					"UpperFilters" // UpperFilters REG_MULTI_SZ property (RW)
#define CM_DRP_LOWERFILTERS_S					"LowerFilters" // LowerFilters REG_MULTI_SZ property (RW)
#define CM_DRP_BUSTYPEGUID_S					"BusTypeGuid" // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE_S					"LegacyBusType" // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER_S						"BusNumber" // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME_S				"Enumerator" // Enumerator Name REG_SZ property (R)
#define CM_DRP_MIN_S							""			// Min
#define CM_DRP_MAX_S							""			// Max

#endif //__CFGMGRCOMPUTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\configmgrapi.cpp ===
//=================================================================
//
// Configmgrapi.cpp
//
// Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>

#include "DllWrapperBase.h"

#ifdef  WIN9XONLY
    #include "Cim32NetApi.h"
#endif

#include "configmgrapi.h"

//
// resource management failures
//
extern BOOL bAddInstanceCreatorFailure ;

/**********************************************************************************************************
 * Register this class with the CResourceManager.
 **********************************************************************************************************/
// {4D060F17-C791-11d2-B353-00105A1F8569}
static const GUID guidCFGMGRAPI =
{ 0x4d060f17, 0xc791, 0x11d2, { 0xb3, 0x53, 0x0, 0x10, 0x5a, 0x1f, 0x85, 0x69 } };


class CConfigMgrApiCreatorRegistration
{
public:
    CConfigMgrApiCreatorRegistration ()
    {
        try
        {
            BOOL bNonFailure = 
            CResourceManager::sm_TheResourceManager.AddInstanceCreator ( guidCFGMGRAPI, CConfigMgrApiCreator ) ;

            if ( FALSE == bNonFailure )
            {
                bAddInstanceCreatorFailure = TRUE ;
            }
        }
        catch ( CHeap_Exception& e_HE )
        {
            bAddInstanceCreatorFailure = TRUE ;
        }
    }
    ~CConfigMgrApiCreatorRegistration ()
    {}

    static CResource * CConfigMgrApiCreator ( PVOID pData )
    {
        CConfigMgrAPI *t_pConfigmgrapi = new CConfigMgrAPI ;
        if ( !t_pConfigmgrapi )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        return t_pConfigmgrapi ;
    }
};

CConfigMgrApiCreatorRegistration MyCConfigMgrApiCreatorRegistration ;

/**********************************************************************************************************/


// String array for converting between 32-bit ULONG Constants and
// corresponding registry strings in 16-bit land

const char*    CConfigMgrAPI::s_pszRegistryStrings[]    =    {
                                                    CM_DRP_DEVICEDESC_S,
                                                    CM_DRP_HARDWAREID_S,
                                                    CM_DRP_COMPATIBLEIDS_S,
                                                    CM_DRP_NTDEVICEPATHS_S,
                                                    CM_DRP_SERVICE_S,
                                                    CM_DRP_CONFIGURATION_S,
                                                    CM_DRP_CONFIGURATIONVECTOR_S,
                                                    CM_DRP_CLASS_S,
                                                    CM_DRP_CLASSGUID_S,
                                                    CM_DRP_DRIVER_S,
                                                    CM_DRP_CONFIGFLAGS_S,
                                                    CM_DRP_MFG_S,
                                                    CM_DRP_FRIENDLYNAME_S,
                                                    CM_DRP_LOCATION_INFORMATION_S,
                                                    CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S,
                                                    CM_DRP_CAPABILITIES_S,
                                                    CM_DRP_UI_NUMBER_S,
                                                    CM_DRP_UPPERFILTERS_S,
                                                    CM_DRP_LOWERFILTERS_S,
                                                    CM_DRP_BUSTYPEGUID_S,
                                                    CM_DRP_LEGACYBUSTYPE_S,
                                                    CM_DRP_BUSNUMBER_S,
                                                    CM_DRP_ENUMERATOR_NAME_S,
                                                    CM_DRP_MAX_S
                                                };

ULONG    CConfigMgrAPI::s_pszRegistryValueTypes[]    =    {
                                                        REG_SZ,    // CM_DRP_DEVICEDESC_S
                                                        REG_SZ,    // CM_DRP_HARDWAREID_S
                                                        REG_SZ,    // CM_DRP_COMPATIBLEIDS_S
                                                        REG_SZ,    // CM_DRP_NTDEVICEPATHS_S
                                                        REG_SZ,    // CM_DRP_SERVICE_S
                                                        REG_SZ,    // CM_DRP_CONFIGURATION_S
                                                        REG_SZ,    // CM_DRP_CONFIGURATIONVECTOR_S
                                                        REG_SZ,    // CM_DRP_CLASS_S
                                                        REG_SZ,    // CM_DRP_CLASSGUID_S
                                                        REG_SZ,    // CM_DRP_DRIVER_S
                                                        REG_BINARY,    // CM_DRP_CONFIGFLAGS_S
                                                        REG_SZ,    // CM_DRP_MFG_S
                                                        REG_SZ,    // CM_DRP_FRIENDLYNAME_S
                                                        REG_SZ,    // CM_DRP_LOCATION_INFORMATION_S
                                                        REG_BINARY,    // CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S
                                                        REG_BINARY,    // CM_DRP_CAPABILITIES_S
                                                        REG_SZ,    // CM_DRP_UI_NUMBER_S
                                                        REG_SZ,    // CM_DRP_UPPERFILTERS_S
                                                        REG_SZ,    // CM_DRP_LOWERFILTERS_S
                                                        REG_SZ,    // CM_DRP_BUSTYPEGUID_S
                                                        REG_BINARY,    // CM_DRP_LEGACYBUSTYPE_S
                                                        REG_BINARY,    // CM_DRP_BUSNUMBER_S
                                                        REG_SZ,    // CM_DRP_ENUMERATOR_NAME_S
                                                        REG_SZ    // CM_DRP_MAX_S
                                                    };

CConfigMgrAPI::CConfigMgrAPI( void )
:
#ifdef NTONLY
    m_hConfigMgrDll( NULL ),
    m_pCM_Connect_MachineA( NULL ),
    m_pCM_Disconnect_Machine( NULL ),
    m_pCM_Locate_DevNode( NULL ),
    m_pCM_Get_Child( NULL ),
    m_pCM_Get_Sibling( NULL ),
    m_pCM_Get_DevNode_Registry_Property( NULL ),
    m_pCM_Get_DevNode_Status( NULL ),
    m_pCM_Get_First_Log_Config( NULL ),
    m_pCM_Get_Next_Res_Des( NULL ),
    m_pCM_Get_Res_Des_Data( NULL ),
    m_pCM_Get_Res_Des_Data_Size( NULL ),
    m_pCM_Free_Log_Conf_Handle( NULL ),
    m_pCM_Free_Res_Des_Handle( NULL ),
    m_pCM_Get_Device_IDA( NULL ),
    m_pCM_Get_Device_ID_Size( NULL ),
    m_pCM_Get_Parent( NULL )
#endif
#ifdef WIN9XONLY
    m_pCim32NetApi(NULL)
/*
    m_pCM16_Locate_DevNode( NULL ),
    m_pCM16_Get_Child( NULL ),
    m_pCM16_Get_Sibling( NULL ),
    m_pCM16_Read_Registry_Value( NULL ),
    m_pCM16_Get_DevNode_Status( NULL ),
    m_pCM16_Get_Device_ID( NULL ),
    m_pCM16_Get_Device_ID_Size( NULL ),
    m_pCM16_Get_First_Log_Conf( NULL ),
    m_pCM16_Get_Next_Res_Des( NULL ),
    m_pCM16_Get_Res_Des_Data_Size( NULL ),
    m_pCM16_Get_Res_Des_Data( NULL ),
    m_pCM16_Get_Bus_Info( NULL ),
    m_pCM16_Get_Parent( NULL ),
*/
#endif

{
#ifdef NTONLY
    {

		m_hConfigMgrDll = LoadLibrary(_T("CFGMGR32.DLL"));

        if ( NULL == m_hConfigMgrDll )
        {
            try
            {
				WCHAR szConfigMgrDllPathStack [ MAX_PATH ] ;
				DWORD t_charSize = GetWindowsDirectory ( szConfigMgrDllPathStack , sizeof ( szConfigMgrDllPathStack ) / sizeof ( WCHAR ) ) ;

				BOOL t_HeapAllocatedPath = FALSE ;
				BOOL t_HeapAllocatedPathCat = FALSE ;
				WCHAR *szConfigMgrDllPath = szConfigMgrDllPathStack ;

				if ( 0 != t_charSize )
				{
					if ( t_charSize > MAX_PATH )
					{
						t_HeapAllocatedPath = TRUE ;
					}
				}

				if ( t_HeapAllocatedPath )
				{
					szConfigMgrDllPath = ( WCHAR * ) new WCHAR [ t_charSize + 1 + ( sizeof ( L"\\system32\\CFGMGR32.DLL" ) / sizeof ( WCHAR ) ) ];
					if ( ! szConfigMgrDllPath )
					{
						::SetLastError ( ERROR_NOT_ENOUGH_MEMORY ) ;
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}

				//
				// scope guard
				//
				// this will create scope variable that makes sure
				// de-allocation is performed based on BOOLEAN
				//
				ON_BLOCK_EXIT_IF ( t_HeapAllocatedPath, deleteArray < WCHAR >, szConfigMgrDllPath ) ;

				if ( t_HeapAllocatedPath )
				{
					//
					// we need to get folder again
					//
					t_charSize = GetWindowsDirectory ( szConfigMgrDllPath , t_charSize + 1 ) ;
				}

				if ( 0 != t_charSize )
				{
					WCHAR * szConfigMgrDllPathOld = szConfigMgrDllPath ;

					if ( FALSE == t_HeapAllocatedPath )
					{
						if ( ( t_charSize + 1 + ( sizeof ( L"\\system32\\CFGMGR32.DLL" ) / sizeof ( WCHAR ) ) ) > MAX_PATH )
						{
							t_HeapAllocatedPathCat = TRUE ;
						}

						if ( t_HeapAllocatedPathCat )
						{
							szConfigMgrDllPath = ( WCHAR * ) new WCHAR [ t_charSize + 1 + ( sizeof ( L"\\system32\\CFGMGR32.DLL" ) / sizeof ( WCHAR ) ) ];
							if ( ! szConfigMgrDllPath )
							{
								::SetLastError ( ERROR_NOT_ENOUGH_MEMORY ) ;
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
					}

					//
					// scope guard
					//
					// this will create scope variable that makes sure
					// de-allocation is performed based on BOOLEAN
					//
					ON_BLOCK_EXIT_IF ( t_HeapAllocatedPathCat, deleteArray < WCHAR >, szConfigMgrDllPath ) ;

					if ( t_HeapAllocatedPathCat )
					{
						StringCchCopyW( szConfigMgrDllPath, t_charSize + 1 , szConfigMgrDllPathOld );
					}

                    StringCchCatW( szConfigMgrDllPath, t_charSize + 1 + ( sizeof ( L"\\system32\\CFGMGR32.DLL" ) / sizeof ( WCHAR ) ), L"\\system32\\CFGMGR32.DLL" );
                    m_hConfigMgrDll = LoadLibrary(szConfigMgrDllPath);
				}
            }
            catch ( ... )
            {
                m_hConfigMgrDll = NULL;
            }
        }

        if ( NULL != m_hConfigMgrDll )
        {
            m_pCM_Connect_MachineA        =    (PCFGMGR32_CM_CONNECT_MACHINEA)        GetProcAddress( m_hConfigMgrDll, "CM_Connect_MachineA" );
            m_pCM_Disconnect_Machine    =    (PCFGMGR32_CM_DISCONNECT_MACHINE)    GetProcAddress( m_hConfigMgrDll, "CM_Disconnect_Machine" );
#ifdef UNICODE
            m_pCM_Locate_DevNode        =    (PCFGMGR32_CM_LOCATE_DEVNODE)    GetProcAddress( m_hConfigMgrDll, "CM_Locate_DevNodeW" );
            m_pCM_Get_DevNode_Registry_Property    =    (PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY)    GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Registry_PropertyW" );
#else
            m_pCM_Get_DevNode_Registry_Property    =    (PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY)    GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Registry_PropertyA" );
            m_pCM_Locate_DevNode        =    (PCFGMGR32_CM_LOCATE_DEVNODE)    GetProcAddress( m_hConfigMgrDll, "CM_Locate_DevNodeA" );
#endif
            m_pCM_Get_Child                =    (PCFGMGR32_CM_GET_CHILD)    GetProcAddress( m_hConfigMgrDll, "CM_Get_Child" );
            m_pCM_Get_Sibling            =    (PCFGMGR32_CM_GET_SIBLING)    GetProcAddress( m_hConfigMgrDll, "CM_Get_Sibling" );
            m_pCM_Get_DevNode_Status    =    (PCFGMGR32_CM_GET_DEVNODE_STATUS)    GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Status" );
            m_pCM_Get_First_Log_Config    =    (PCFGMGR32_CM_GET_FIRST_LOG_CONF)    GetProcAddress( m_hConfigMgrDll, "CM_Get_First_Log_Conf" );
            m_pCM_Get_Next_Res_Des        =    (PCFGMGR32_CM_GET_NEXT_RES_DES)        GetProcAddress( m_hConfigMgrDll, "CM_Get_Next_Res_Des" );
            m_pCM_Get_Res_Des_Data        =    (PCFGMGR32_CM_GET_RES_DES_DATA)        GetProcAddress( m_hConfigMgrDll, "CM_Get_Res_Des_Data" );
            m_pCM_Get_Res_Des_Data_Size    =    (PCFGMGR32_CM_GET_RES_DES_DATA_SIZE)    GetProcAddress( m_hConfigMgrDll, "CM_Get_Res_Des_Data_Size" );
            m_pCM_Free_Log_Conf_Handle    =    (PCFGMGR32_CM_FREE_LOG_CONF_HANDLE)    GetProcAddress( m_hConfigMgrDll, "CM_Free_Log_Conf_Handle" );
            m_pCM_Free_Res_Des_Handle    =    (PCFGMGR32_CM_FREE_RES_DES_HANDLE)    GetProcAddress( m_hConfigMgrDll, "CM_Free_Res_Des_Handle" );
            m_pCM_Get_Device_IDA        =    (PCFGMGR32_CM_GET_DEVICE_IDA)    GetProcAddress( m_hConfigMgrDll, "CM_Get_Device_IDA" );
            m_pCM_Get_Device_ID_Size    =    (PCFGMGR32_CM_GET_DEVICE_ID_SIZE)    GetProcAddress( m_hConfigMgrDll, "CM_Get_Device_ID_Size" );
            m_pCM_Get_Parent            =    (PCFGMGR32_CM_GET_PARENT)            GetProcAddress( m_hConfigMgrDll, "CM_Get_Parent" );
        }
        else
        {
            // this is possible to be neccessary in the future !!!
            // resource manager may start to care about error from load library
            //
            // let resource manager know load failed
            //
            m_bValid = FALSE;
            m_dwCreationError = ::GetLastError ();

            LogErrorMessage(L"Failed to load library cfgmgr32.dll");
        }

    }
#endif
#ifdef WIN9XONLY
    {
        m_pCim32NetApi = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
/*
        if ( NULL != m_hConfigMgrDll )
        {
            m_pCM16_Locate_DevNode            =    (PCIM32THK_CM_LOCATE_DEVNODE)            GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Locate_DevNode" );
            m_pCM16_Get_Child                =    (PCIM32THK_CM_GET_CHILD)                GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Child" );
            m_pCM16_Get_Sibling                =    (PCIM32THK_CM_GET_SIBLING)                GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Sibling" );
            m_pCM16_Read_Registry_Value        =    (PCIM32THK_CM_READ_REGISTRY_VALUE)        GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Read_Registry_Value" );
            m_pCM16_Get_DevNode_Status        =    (PCIM32THK_CM_GET_DEVNODE_STATUS)        GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_DevNode_Status" );
            m_pCM16_Get_Device_ID            =    (PCIM32THK_CM_GET_DEVICE_ID)            GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Device_ID" );
            m_pCM16_Get_Device_ID_Size        =    (PCIM32THK_CM_GET_DEVICE_ID_SIZE)        GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Device_ID_Size" );
            m_pCM16_Get_First_Log_Conf        =    (PCIM32THK_CM_GET_FIRST_LOG_CONF)        GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_First_Log_Conf" );
            m_pCM16_Get_Next_Res_Des        =    (PCIM32THK_CM_GET_NEXT_RES_DES)            GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Next_Res_Des" );
            m_pCM16_Get_Res_Des_Data_Size    =    (PCIM32THK_CM_GET_RES_DES_DATA_SIZE)    GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Res_Des_Data_Size" );
            m_pCM16_Get_Res_Des_Data        =    (PCIM32THK_CM_GET_RES_DES_DATA)            GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Res_Des_Data" );
            m_pCM16_Get_Bus_Info            =    (PCIM32THK_CM_GET_BUS_INFO)                GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Bus_Info" );
            m_pCM16_Get_Parent                =    (PCIM32THK_CM_GET_PARENT)                GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Parent" );
        }
*/
    }
#endif
}

CConfigMgrAPI::~CConfigMgrAPI( void )
{
#ifdef NTONLY
    if ( NULL != m_hConfigMgrDll )
    {
        FreeLibrary( m_hConfigMgrDll );
    }
#endif
#ifdef WIN9XONLY
    if(m_pCim32NetApi != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, m_pCim32NetApi);
        m_pCim32NetApi = NULL;
    }
#endif
}

CONFIGRET CConfigMgrAPI::CM_Connect_MachineA( PCSTR UNCServerName, PHMACHINE phMachine )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    if ( NULL != m_pCM_Connect_MachineA )
    {
        cr = m_pCM_Connect_MachineA( UNCServerName, phMachine );
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Disconnect_Machine( HMACHINE hMachine )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    if ( NULL != m_pCM_Connect_MachineA )
    {
        cr = m_pCM_Disconnect_Machine( hMachine );
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Parent( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Parent )
        {
            cr = m_pCM_Get_Parent( pdnDevInst, DevInst, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Parent( pdnDevInst, DevInst, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Child( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Child )
        {
            cr = m_pCM_Get_Child( pdnDevInst, DevInst, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Child( pdnDevInst, DevInst, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Sibling( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Sibling )
        {
            cr = m_pCM_Get_Sibling( pdnDevInst, DevInst, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Sibling( pdnDevInst, DevInst, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Locate_DevNode( PDEVINST pdnDevInst, TCHAR *pDeviceID, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Locate_DevNode )
        {
            cr = m_pCM_Locate_DevNode( pdnDevInst, pDeviceID, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
#ifndef UNICODE
            cr = m_pCim32NetApi->CIM32THK_CM_Locate_DevNode( pdnDevInst, pDeviceID, ulFlags );
#endif
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_DevNode_Registry_PropertyA( DEVINST dnDevInst, ULONG ulProperty, PULONG pulRegDataType,
                                                    PVOID Buffer, PULONG pulLength, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_DevNode_Registry_Property )
        {
            cr = m_pCM_Get_DevNode_Registry_Property( dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if    (    NULL        !=    m_pCim32NetApi
            &&    CM_DRP_MIN    <=    ulProperty
            &&    CM_DRP_MAX    >    ulProperty )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Read_Registry_Value( dnDevInst, NULL, s_pszRegistryStrings[ulProperty-1], s_pszRegistryValueTypes[ulProperty-1], Buffer, pulLength, 0 );

            // Fake the returned type since we at least had a match
            *pulRegDataType = s_pszRegistryValueTypes[ulProperty-1];
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_DevNode_Status( PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {

        if ( NULL != m_pCM_Get_DevNode_Status )
        {
            cr = m_pCM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevInst, ulFlags );
        }

    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevInst, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVINST dnDevInst, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_First_Log_Config )
        {
            cr = m_pCM_Get_First_Log_Config( plcLogConf, dnDevInst, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_First_Log_Conf( plcLogConf, dnDevInst, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Next_Res_Des )
        {
            cr = m_pCM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Res_Des_Data( RES_DES rdResDes, PVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Res_Des_Data )
        {
            cr = m_pCM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr =m_pCim32NetApi-> CIM32THK_CM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Res_Des_Data_Size( PULONG pulSize, RES_DES rdResDes, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Res_Des_Data_Size )
        {
            cr = m_pCM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Free_Log_Conf_Handle( LOG_CONF lcLogConf )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

    // This function does NOT appear to have a 16-bit implementation or an
    // equivalent thereof.
#ifdef NTONLY
    {
        if ( NULL != m_pCM_Free_Log_Conf_Handle )
        {
            cr = m_pCM_Free_Log_Conf_Handle( lcLogConf );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Free_Res_Des_Handle( RES_DES rdResDes )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

    // This function does NOT appear to have a 16-bit implementation or an
    // equivalent thereof.
#ifdef NTONLY
    {
        if ( NULL != m_pCM_Free_Res_Des_Handle )
        {
            cr = m_pCM_Free_Res_Des_Handle( rdResDes );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Device_IDA( DEVNODE dnDevNode, PCHAR Buffer, ULONG BufferLen, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Device_IDA )
        {
            cr = m_pCM_Get_Device_IDA( dnDevNode, Buffer, BufferLen, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Device_ID( dnDevNode, Buffer, BufferLen, ulFlags );
        }
    }
#endif

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Device_ID_Size( PULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

#ifdef NTONLY
    {
        if ( NULL != m_pCM_Get_Device_ID_Size )
        {
            cr = m_pCM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
        }
    }
#endif
#ifdef WIN9XONLY
    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
        }
    }
#endif

    return cr;
}

#ifdef WIN9XONLY
// This is a 16-bit only function
CONFIGRET CConfigMgrAPI::CM_Get_Bus_Info( DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags )
{
    CONFIGRET    cr = CR_INVALID_POINTER;

    {
        if ( NULL != m_pCim32NetApi )
        {
            cr = m_pCim32NetApi->CIM32THK_CM_Get_Bus_Info( dnDevNode, pbtBusType, pulSizeOfInfo, pInfo, ulFlags );
        }
    }

    return cr;
}

CONFIGRET CConfigMgrAPI::CM_Query_Arbitrator_Free_Data(PVOID pData, ULONG DataLen, DEVINST dnDevInst, RESOURCEID ResourceID, ULONG ulFlags)
{
    if (m_pCim32NetApi)
    {
        return m_pCim32NetApi->CIM32THK_CM_Query_Arbitrator_Free_Data(pData, DataLen, dnDevInst, ResourceID, ulFlags);
    }
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags)
{
    if (m_pCim32NetApi)
    {
        return m_pCim32NetApi->CIM32THK_CM_Delete_Range(ulStartValue, ulEndValue, rlh, ulFlags);
    }
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags)
{
    if (m_pCim32NetApi)
    {
        return m_pCim32NetApi->CIM32THK_CM_First_Range(rlh, pulStart, pulEnd, preElement, ulFlags);
    }
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags)
{
    if (m_pCim32NetApi)
    {
        return m_pCim32NetApi->CIM32THK_CM_Next_Range(preElement, pulStart, pullEnd, ulFlags);
    }
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags)
{
    if (m_pCim32NetApi)
    {
        return m_pCim32NetApi->CIM32THK_CM_Free_Range_List(rlh, ulFlags);
    }
    else
    {
        return CR_INVALID_POINTER;
    }
}

#endif

BOOL CConfigMgrAPI :: IsValid ()
{
#ifdef WIN9XONLY
    return m_pCim32NetApi != NULL;
#endif
#ifdef NTONLY
    return m_hConfigMgrDll != NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ctoken.cpp ===
// Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved 
//
//	Created:	4/21/2000, Kevin Hughes

#include "precomp.h"
#include <vector>
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"

#include "securitydescriptor.h"
#include "CToken.h"

#include <autoptr.h>

///////////////////////////////////////////////////////////////////////////////
//  CToken base class
///////////////////////////////////////////////////////////////////////////////
CToken::CToken()
  :  m_hToken(NULL),
     m_fIsValid(false),
	 m_fClose(true),
     m_dwLastError(ERROR_SUCCESS),
     m_psdDefault(NULL)
{
    ::SetLastError(ERROR_SUCCESS);
}


// Copy constructor
CToken::CToken(
    const CToken &rTok)

  :  m_hToken(NULL),
     m_fIsValid(false),
	 m_fClose(true),
     m_dwLastError(ERROR_SUCCESS),
     m_psdDefault(NULL)
{
	Duplicate(rTok);
}


CToken::~CToken(void)
{
	CleanToken () ;
}

void CToken::CleanToken ()
{
	// Close token handle
	if ( m_fClose )
	{
		if ( m_hToken && INVALID_HANDLE_VALUE != m_hToken )
		{
			::CloseHandle( m_hToken );
		}
	}

    if(m_psdDefault)
    {
        delete m_psdDefault;
        m_psdDefault = NULL;
    }

	// Initialize data 
	m_hToken = NULL;
	m_fIsValid = false;
	m_fClose = true;
	m_dwLastError = ERROR_SUCCESS;
	
}

// tokenType

BOOL CToken::GetTokenType ( TOKEN_TYPE& type ) const
{
	BOOL bResult = FALSE ;
	DWORD dwReturnLength = 0L ;
	bResult = GetTokenInformation	(
										m_hToken ,
										TokenType ,
										&type ,
										sizeof ( TOKEN_TYPE ) ,
										&dwReturnLength
									) ;

	return bResult ;
}

// Duplicate CToken
BOOL CToken::Duplicate	(
							const CToken& tokDup,
							BOOL bReInit,
							DWORD dwDesiredAccess,
							SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
							TOKEN_TYPE type

						)
{
	CleanToken () ;

	// Duplicate token handle
    HANDLE hTmp = NULL;
	BOOL fResult = FALSE;
	
	if ( bReInit )
	{
		fResult = ::DuplicateTokenEx	(
											tokDup.GetTokenHandle(),
											dwDesiredAccess,
											NULL,
											ImpersonationLevel,
											type,
											&hTmp
										);
	}
	else
	{
		DWORD					dwError = ERROR_SUCCESS;
		SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;

		// Determine the length needed for self-relative SD
		DWORD dwLengthNeeded = 0;

		fResult = ::GetKernelObjectSecurity	(
												tokDup.GetTokenHandle(),
												siFlags,
												NULL,
												0,
												&dwLengthNeeded
											);

		dwError = ::GetLastError();

		if( !fResult )
		{
			PSECURITY_DESCRIPTOR pSD = NULL;
			wmilib::auto_buffer < BYTE > pDeleteSD ;

			if ( ERROR_ACCESS_DENIED == dwError )
			{
				#if DBG == 1
				// for testing purpose I will let process break
				::DebugBreak();
				#endif
			}

			if ( ERROR_INSUFFICIENT_BUFFER == dwError )
			{
				pSD = new BYTE[dwLengthNeeded];
				pDeleteSD.reset( reinterpret_cast < BYTE* > ( pSD ) ) ;

				if(pSD)
				{
					// Now obtain security descriptor
					if(::GetKernelObjectSecurity	(
														tokDup.GetTokenHandle(),
														siFlags,
														pSD,
														dwLengthNeeded,
														&dwLengthNeeded
													)
					  )
					{
						dwError = ERROR_SUCCESS;
					}
				}
			}

			if ( ERROR_SUCCESS == dwError )
			{
				SECURITY_ATTRIBUTES t_SecurityAttributes ;
				t_SecurityAttributes.nLength = ( pSD ) ? GetSecurityDescriptorLength ( pSD ) : 0 ;
				t_SecurityAttributes.lpSecurityDescriptor = pSD ;
				t_SecurityAttributes.bInheritHandle = FALSE ;

				fResult = ::DuplicateTokenEx	(
													tokDup.GetTokenHandle() ,
													dwDesiredAccess ,
													( pSD ) ? &t_SecurityAttributes : NULL ,
													ImpersonationLevel ,
													type ,
													&hTmp
												);
			}
		}
	}

	if(!fResult) 
    {
		m_dwLastError = ::GetLastError();
	}
    else
    {
	    m_hToken = hTmp;

		if ( bReInit )
		{
			m_dwLastError = ReinitializeAll();
		}

		m_fIsValid = true;
    }

	return fResult ;
}


CToken& CToken::operator=(
    const CToken& rTok)
{
	Duplicate(rTok);
	return *this;
}


DWORD CToken::ReinitializeAll()
{
	DWORD dwRet = ERROR_SUCCESS;
    
    dwRet = ReinitializeOwnerSid();
	if(dwRet == ERROR_SUCCESS )
	{
        dwRet = ReinitializeDefaultSD();
    }

	if(dwRet == ERROR_SUCCESS )
	{
	    dwRet = RebuildGroupList();
    }

    if(dwRet == ERROR_SUCCESS )
	{
        dwRet = RebuildPrivilegeList();
    }

	return dwRet;
}


DWORD CToken::ReinitializeOwnerSid()
{
	m_dwLastError = ERROR_SUCCESS;
    
    PTOKEN_USER ptokusr = NULL;

    try
    {
        GTI(TokenUser, (void**)&ptokusr);

        if(ptokusr)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                m_sidTokenOwner = CSid(ptokusr->User.Sid);
            }

            delete ptokusr; ptokusr = NULL;
        }
    }
    catch(...)
    {
        if(ptokusr)
        {
            delete ptokusr; ptokusr = NULL;
        }
        throw;
    } 

    return m_dwLastError;
}


DWORD CToken::ReinitializeDefaultSD()
{
	m_dwLastError = ERROR_SUCCESS;
    
    // Clean up default SD
	if(m_psdDefault)
    {
        delete m_psdDefault;
        m_psdDefault = NULL;
    }

    CSid* psidDefOwner = NULL;
    CDACL* pdaclDefault = NULL;
    PTOKEN_OWNER ptokowner = NULL;
    PTOKEN_DEFAULT_DACL pdefdacl = NULL;

	// Get default owner
    try
    {
        GTI(TokenOwner, (void**)&ptokowner);
        if(ptokowner)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {   
                psidDefOwner = new CSid(ptokowner->Owner);
            }
        }
    
        GTI(TokenDefaultDacl, (void**)&pdefdacl);
        if(pdefdacl)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                pdaclDefault = new CDACL;
                m_dwLastError = pdaclDefault->Init(
                    pdefdacl->DefaultDacl);
            }
        }

        if(m_dwLastError == ERROR_SUCCESS)
        {
            m_psdDefault = new CSecurityDescriptor(
                psidDefOwner,
                false,
                NULL,
                false,
                pdaclDefault,
                false,
                false,
                NULL,
                false,
                false);
        }
	
        if(psidDefOwner)
        {
            delete psidDefOwner; psidDefOwner = NULL;
        }
        if(pdaclDefault)
        {
            delete pdaclDefault; pdaclDefault = NULL;
        }
        if(ptokowner)
        {
            delete ptokowner; ptokowner = NULL;
        }
        if(pdefdacl)
        {
            delete pdefdacl; pdefdacl = NULL;
        }
	}
    catch(...)
    {
        if(psidDefOwner)
        {
            delete psidDefOwner; psidDefOwner = NULL;
        }
        if(pdaclDefault)
        {
            delete pdaclDefault; pdaclDefault = NULL;
        }
        if(ptokowner)
        {
            delete ptokowner; ptokowner = NULL;
        }
        if(pdefdacl)
        {
            delete pdefdacl; pdefdacl = NULL;
        }
        throw;
    }
	
	return m_dwLastError;
}



DWORD CToken::RebuildGroupList( void )
{
	m_dwLastError = ERROR_SUCCESS;
    // Release the old list
	m_vecGroupsAndAttributes.clear();

	// Obtain and initialize groups from token
	PTOKEN_GROUPS ptg = NULL;

    try
    {
        GTI(TokenGroups, (void**)&ptg);

        if(ptg)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                for(long m = 0;
                    m < ptg->GroupCount;
                    m++)
                {
                    m_vecGroupsAndAttributes.push_back(
                        CSidAndAttribute(
                            CSid(ptg->Groups[m].Sid),
                            ptg->Groups[m].Attributes));
                }
            }
            delete ptg; ptg = NULL;
        }
    }
    catch(...)
    {
        if(ptg)
        {
            delete ptg; ptg = NULL;
        }
    }

	
	// If we are here, then groups are initialized	
	return m_dwLastError;
}


DWORD CToken::RebuildPrivilegeList()
{
	// Release the old list
	m_vecPrivileges.clear();

	// Obtain and initialize groups from token
	PTOKEN_PRIVILEGES ptp = NULL;
    const int NAME_SIZE = 128;
    BYTE bytePrivilegeName[NAME_SIZE];
    DWORD dwNameSize;

    try
    {
        GTI(TokenPrivileges, (void**)&ptp);

        if(ptp)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                for(long m = 0;
                    m < ptp->PrivilegeCount &&
                        m_dwLastError == ERROR_SUCCESS;
                    m++)
                {
                    dwNameSize = NAME_SIZE;
		            if(::LookupPrivilegeName( 
                        NULL,
						&(ptp->Privileges[m].Luid),
						(WCHAR*) bytePrivilegeName,
						&dwNameSize))
                    {
		                m_vecPrivileges.push_back(Privilege(
                             CHString((LPWSTR) bytePrivilegeName),
                             ptp->Privileges[m].Attributes));
                    }
                    else
                    {
                        m_dwLastError = ::GetLastError();
                    }
                }
            }
            delete ptp; ptp = NULL;
        }
    }
    catch(...)
    {
        if(ptp)
        {
            delete ptp; ptp = NULL;
        }
    }

	// If we are here, then privileges are initialized
	return m_dwLastError;
}


DWORD CToken::GTI(
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID* ppvBuff)
{
	::SetLastError(ERROR_SUCCESS);
    m_dwLastError = ERROR_SUCCESS;
    DWORD dwRetSize = 0;

    if(!::GetTokenInformation(
        m_hToken,
        TokenInformationClass,
        NULL,
        0L,
        &dwRetSize))
    {
        m_dwLastError = ::GetLastError();
    }

    if(m_dwLastError == ERROR_INSUFFICIENT_BUFFER)
    {
        // now get it for real...
        ::SetLastError(ERROR_SUCCESS);
        m_dwLastError = ERROR_SUCCESS;
        *ppvBuff = (PVOID) new BYTE[dwRetSize];
        DWORD dwTmp = dwRetSize;
        if(*ppvBuff)
        {
            if(!::GetTokenInformation(
                m_hToken,
                TokenInformationClass,
                *ppvBuff,
                dwTmp,
                &dwRetSize))
            {
                m_dwLastError = ::GetLastError();
            }
        }
        else
        {
            m_dwLastError = ::GetLastError();  
        }
    }

    return m_dwLastError;
}



bool CToken::GetPrivilege(
    Privilege* privOut,
    long lPos) const
{
    bool fRet = false;
    if(privOut)
    {
        if(lPos >= 0 &&
           lPos < m_vecPrivileges.size())
        {
            *privOut = m_vecPrivileges[lPos];
            fRet = true;
        }
    }
    return fRet;
}


bool CToken::GetGroup(
    CSid* sidOut,
    long lPos) const
{
    bool fRet = false;
    if(sidOut)
    {
        if(lPos >= 0 &&
           lPos < m_vecGroupsAndAttributes.size())
        {
            *sidOut = m_vecGroupsAndAttributes[lPos].m_sid;
            fRet = true;
        }
    }
    return fRet;
}


long CToken::GetPrivCount() const
{
     return m_vecPrivileges.size();
}


long CToken::GetGroupCount() const
{
    
    return m_vecGroupsAndAttributes.size();
}



HANDLE CToken::GetTokenHandle() const
{
	return m_hToken;
}


bool CToken::GetTokenOwner(
    CSid* sidOwner) const
{	
	bool fRet = false;
    if(sidOwner)
    {
        sidOwner = new CSid(m_sidTokenOwner);
        fRet = true;
    }
    return fRet;
}


// NOTE: hands back internal descriptor.
bool CToken::GetDefaultSD(
    CSecurityDescriptor** ppsdDefault)
{
	bool fRet = false;
    
    if(ppsdDefault)
    {
        if(m_psdDefault)
        {
            *ppsdDefault = m_psdDefault;
            fRet = true;
        }
    }
    return fRet;
}


DWORD CToken::SetDefaultSD(
    CSecurityDescriptor& SourceSD)
{
    ::SetLastError(ERROR_SUCCESS);

    // Inject new default info into token
		
	// Set new default owner
	CSid SidOwner;
    CDACL cd;
    SourceSD.GetOwner(SidOwner);

	TOKEN_OWNER to;
	to.Owner = SidOwner.GetPSid();
	BOOL fResult = ::SetTokenInformation( 
        m_hToken,
		TokenOwner,
		&to,
		sizeof(TOKEN_OWNER));

	if(!fResult) 
    {
		m_dwLastError = ::GetLastError();
	}
	
    if(m_dwLastError == ERROR_SUCCESS)
    {
	    // Set new default DACL
	    TOKEN_DEFAULT_DACL tdd;
        
        if(SourceSD.GetDACL(cd))
        {
	        CAccessEntryList cael;
            if(cd.GetMergedACL(cael))
            {
                PACL paclOut = NULL;
                if((m_dwLastError = 
                    cael.FillWin32ACL(paclOut)) == 
                        ERROR_SUCCESS)
                {
                    tdd.DefaultDacl = paclOut;
	                fResult = ::SetTokenInformation( 
                        m_hToken,
			            TokenDefaultDacl,
			            &tdd,
			            sizeof(TOKEN_DEFAULT_DACL));

                    if(fResult)
                    {
                        // Reference new CSD in  member variable
	                    if(m_psdDefault)
                        {
                            delete m_psdDefault; m_psdDefault = NULL;
                        }

                        m_psdDefault = new CSecurityDescriptor(
                            &SidOwner,
                            false,
                            NULL,
                            false,
                            &cd,
                            false,
                            false,
                            NULL,
                            false,
                            false);
                    }
                    else
                    {
                        m_dwLastError = ERROR_SUCCESS;   
                    }
	            }
            }
            else
            {
                m_dwLastError = ERROR_SUCCESS;
            }
        }
        else
        {
            m_dwLastError = ERROR_SUCCESS;
        }
    }
	
	return m_dwLastError;
}


DWORD CToken::EnablePrivilege(
    CHString& strPrivilegeName )
{
	// Check whether privilege exists
	bool fPrivilegeListed = false;
	
    for(long m = 0;
        m < m_vecPrivileges.size();
        m++)
    {
		if(m_vecPrivileges[m].chstrName.CompareNoCase(strPrivilegeName) == 0) 
        {
			fPrivilegeListed = true;
			break;
		}
	}

	if(!fPrivilegeListed ) 
    {
		m_dwLastError = ERROR_INVALID_PARAMETER;
	}
	else
    {
	    LUID luid;
	    BOOL fResult = ::LookupPrivilegeValue( 
            NULL,	// use local computer
			strPrivilegeName,
			&luid);

	    if(!fResult) 
        {
		    m_dwLastError = ::GetLastError();
	    }
		else
        {    
	        TOKEN_PRIVILEGES tpNewState;
	        tpNewState.PrivilegeCount = 1;
	        tpNewState.Privileges[0].Luid = luid;
	        tpNewState.Privileges[0].Attributes = 
                SE_PRIVILEGE_ENABLED;

	        TOKEN_PRIVILEGES tpPreviousState;
	        DWORD dwSizePreviousState = 
                sizeof(TOKEN_PRIVILEGES);

	        fResult = ::AdjustTokenPrivileges(
                m_hToken,
				FALSE,
				&tpNewState,
				sizeof(TOKEN_PRIVILEGES),
				&tpPreviousState,
				&dwSizePreviousState);

	        if(!fResult) 
            {
		        m_dwLastError = ::GetLastError();
	        }
	        else
            {
	            m_dwLastError = RebuildPrivilegeList();
            }
        }
    }

	return m_dwLastError;
}


DWORD CToken::DisablePrivilege(
    CHString& chstrPrivilegeName)
{
	// Check whether privilege exists
	bool fPrivilegeListed = false;
	
    for(long m = 0;
        m < m_vecPrivileges.size();
        m++)
    {
		if(m_vecPrivileges[m].chstrName.CompareNoCase(chstrPrivilegeName) == 0) 
        {
			fPrivilegeListed = true;
			break;
		}
	}

	if(!fPrivilegeListed ) 
    {
		m_dwLastError = ERROR_INVALID_PARAMETER;
	}
	else
    {
	    LUID luid;
	    BOOL fResult = ::LookupPrivilegeValue( 
            NULL,	// use local computer
			chstrPrivilegeName,
			&luid);

	    if(!fResult) 
        {
		    m_dwLastError = ::GetLastError();
	    }
		else
        {    
	        TOKEN_PRIVILEGES tpNewState;
	        tpNewState.PrivilegeCount = 1;
	        tpNewState.Privileges[0].Luid = luid;
	        tpNewState.Privileges[0].Attributes = 
                0;

	        TOKEN_PRIVILEGES tpPreviousState;
	        DWORD dwSizePreviousState = 
                sizeof(TOKEN_PRIVILEGES);

	        fResult = ::AdjustTokenPrivileges(
                m_hToken,
				FALSE,
				&tpNewState,
				sizeof(TOKEN_PRIVILEGES),
				&tpPreviousState,
				&dwSizePreviousState);

	        if(!fResult) 
            {
		        m_dwLastError = ::GetLastError();
	        }
	        else
            {
	            m_dwLastError = RebuildPrivilegeList();
            }
        }
    }

	return m_dwLastError;
}


void CToken::Dump(WCHAR* pszFileName)
{
	/*
	 *	Algorithm:
	 *		1. Dump token owner SID, name, and domain.
	 *		2. Dump all group SIDs with names and domains.
	 *		3. Dump list of privileges with attributes.
	 *		4. Dump default owner.
	 *		5. Dump default DACL.
	 */

	CHString strFileName = pszFileName;

	// If file name is not empty - create the file
	FILE* fp = NULL;
	if(!strFileName.IsEmpty()) 
    {
		fp = _wfopen((LPCWSTR)strFileName, L"a");
	}
    else
    {
        return;
    }

    if(!fp) return;


	// Write to the file
	DWORD dwBytesWritten = 0;
	CHString strCRLF = L"\r\n";
	CHString strDump;

	{
		strDump = L"Token owner: " + m_sidTokenOwner.GetAccountName() + strCRLF;
		fputws(strDump, fp);

		strDump = L"Domain: " + m_sidTokenOwner.GetDomainName() + strCRLF;
		fputws(strDump, fp);

		strDump = L"SID: " + m_sidTokenOwner.GetSidString() + strCRLF + strCRLF;
		fputws(strDump, fp);
	}

	// Dump all groups
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);

	for(long m = 0;
        m < m_vecGroupsAndAttributes.size();
        m++)
    {		
		// Write to the file as well
		{
			strDump = L"Member of this group: " + m_vecGroupsAndAttributes[m].m_sid.GetSidString() + strCRLF;
			fputws(strDump, fp);
			
            strDump = L"\t(" + m_vecGroupsAndAttributes[m].m_sid.GetAccountName() + L" in " + 
							m_vecGroupsAndAttributes[m].m_sid.GetDomainName() + L" domain)" + strCRLF;
			fputws(strDump, fp);
		}	
    }

	// Dump all privileges
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);

	for(m = 0;
        m < m_vecPrivileges.size();
        m++)
    {
		// Write to the file as well
		{
				
			strDump.Format( L"%d", m_vecPrivileges[m].dwAttributes );
			strDump = L"Holds a " + m_vecPrivileges[m].chstrName + L" with attributes: " + strDump + strCRLF;
			fputws(strDump, fp);
		}
	}

	// Dump default information
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);
	{
		strDump = strCRLF + L"Default information:" + strCRLF;
		fputws(strDump, fp);

	}
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);

	fclose(fp);

    if(m_psdDefault)
    {
	    m_psdDefault->DumpDescriptor(pszFileName);
    }
}


// Deletes a member from the access token's
// member list, and applies the change.  
bool CToken::DeleteGroup(
    CSid& sidToDelete)
{
    bool fRet = false;

    // See if the group is in the membership
    // vector...
    bool fFoundIt = false;

    SANDATTRIBUTE_VECTOR::iterator iter;
    for(iter = m_vecGroupsAndAttributes.begin();
        iter != m_vecGroupsAndAttributes.end();
        iter++)
    {
        if(iter->m_sid.GetSidString().CompareNoCase( 
            sidToDelete.GetSidString()) == 0)
        {
            fFoundIt = true;
            break;
        }
    }
    
    if(fFoundIt)
    {
        m_vecGroupsAndAttributes.erase(iter);
        
        // Now need to apply the changes.  To do
        // so, we need to construct a TOKEN_GROUPS
        // structure...
        fRet = ApplyTokenGroups();
    }   

    return fRet;
}

// Adds a member to the specified group to
// the list of token groups.
bool CToken::AddGroup(
    CSid& sidToAdd, 
    DWORD dwAttributes)
{
    bool fRet = false;

    // See if the group is in the membership
    // vector...
    bool fFoundIt = false;

    SANDATTRIBUTE_VECTOR::iterator iter;
    for(iter = m_vecGroupsAndAttributes.begin();
        iter != m_vecGroupsAndAttributes.end();
        iter++)
    {
        if(iter->m_sid.GetSidString().CompareNoCase( 
            sidToAdd.GetSidString()) == 0)
        {
            fFoundIt = true;
            break;
        }
    }
    
    if(!fFoundIt)
    {
        m_vecGroupsAndAttributes.push_back(
            CSidAndAttribute(
                sidToAdd,
                dwAttributes));
        
        // Now need to apply the changes.  To do
        // so, we need to construct a TOKEN_GROUPS
        // structure...
        fRet = ApplyTokenGroups();
    }   

    return fRet;
}


bool CToken::ApplyTokenGroups()
{
    bool fRet = false;
    PTOKEN_GROUPS ptg = NULL;
    try
    {
        ptg = (PTOKEN_GROUPS) new BYTE[sizeof(DWORD) + 
            m_vecGroupsAndAttributes.size() * sizeof(SID_AND_ATTRIBUTES)];
        
        if(ptg)
        {
            ptg->GroupCount = m_vecGroupsAndAttributes.size();
            
            for(long m = 0;
                m < m_vecGroupsAndAttributes.size();
                m++)
            {
                ptg->Groups[m].Sid = 
                    m_vecGroupsAndAttributes[m].m_sid.GetPSid();
                ptg->Groups[m].Attributes = 
                    m_vecGroupsAndAttributes[m].m_dwAttributes;
            }                                                    

            // Now we can alter the groups...
            fRet = ::AdjustTokenGroups(
                m_hToken,
                FALSE,
                ptg,
                0,
                NULL,
                NULL);

            delete ((PBYTE) ptg);
            ptg = NULL;
        }
    }
    catch(...)
    {
        if(ptg)
        {
            delete ((PBYTE) ptg);
            ptg = NULL;
        }
        throw;
    }
    
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
//  CProcessToken class
///////////////////////////////////////////////////////////////////////////////

CProcessToken::CProcessToken	(
									HANDLE hProcess,
									bool fGetHandleOnly,
									DWORD dwDesiredAccess
								)
{
    // Open handle to process access token
    m_dwLastError = ERROR_SUCCESS;
    
    // If they didn't give us a process handle,
    // use the current process.
	if ( NULL == hProcess || INVALID_HANDLE_VALUE == hProcess )
    {
        if(!::OpenProcessToken( 
            GetCurrentProcess(),
		    dwDesiredAccess,
		    &m_hToken ))
        {
            m_dwLastError = ::GetLastError();
        }
    }
    else
    {
        m_hToken = hProcess;
		m_fClose = false ;
    }

    if(!fGetHandleOnly)
    {
	    m_dwLastError = ReinitializeAll();
	}
        
    if(m_dwLastError == ERROR_SUCCESS )
	{
        m_fIsValid = true;
    }
}




///////////////////////////////////////////////////////////////////////////////
//  CThreadToken class
///////////////////////////////////////////////////////////////////////////////

CThreadToken::CThreadToken	(
								HANDLE hThread,
								bool fGetHandleOnly,
								bool fAccessCheckProcess, 
								DWORD dwDesiredAccess
							)
{
    m_dwLastError = ERROR_SUCCESS;

	// If they didn't give us a thread handle,
    // use the current thread.
    if ( NULL == hThread || hThread == INVALID_HANDLE_VALUE )
    {
		// Open thread access token
		HANDLE hToken = NULL;

		if(!::OpenThreadToken(
			GetCurrentThread(),
			dwDesiredAccess,
			fAccessCheckProcess,
			&hToken))
		{
			m_dwLastError = ::GetLastError();
		}
		else
		{
			m_hToken = hToken ;
		}
	}
	else
	{
		m_hToken = hThread ;
		m_fClose = false ;
	}

	if ( ERROR_SUCCESS == m_dwLastError )
	{
        if ( !fGetHandleOnly )
        {
            m_dwLastError = ReinitializeAll();
        }
    }
            
    if(m_dwLastError == ERROR_SUCCESS)
    {
        // If we are here, everything is initialized
	    m_fIsValid = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\cwaitableobject.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CWaitableObject.h -- Pure virtual base class for waitable objects

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#ifndef __CWAITABLEOBJECT_H__
#define __CWAITABLEOBJECT_H__

#include "CGlobal.h"

class CWaitableObject {
    // class has no member data, it's only purpose is to provide
    // a base class for waitable objects which have internal HANDLES
    // and Status...

    // class needs no construtor, since it has no members...

public:
    // get the internal handle...
    // this member function is virtual to assure
    // this function appears in all derived classes
    // and pure (= 0) so that this class cannot be instantiated...
    virtual HANDLE GetHandle(void) const = 0;

    // get the internal object status...
    // this member function is virtual to assure
    // this function appears in all derived classes
    // and pure (= 0) so that this class cannot be instantiated...
    virtual DWORD Status(void) const = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\ctoken.h ===
/*

// Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved
 *
 *	Created:	4/21/2000, Kevin Hughes
 */


#pragma once

class CSidAndAttribute
{
public:
    CSidAndAttribute() {}
    CSidAndAttribute(
        CSid& csidIn,
        DWORD dwAttribIn)
    {
        m_sid = csidIn;
        m_dwAttributes = dwAttribIn;
    }

    virtual ~CSidAndAttribute() {}
    CSid m_sid;
    DWORD m_dwAttributes; 
};


class Privilege
{
public:

    Privilege() : dwAttributes(0) {}
    virtual ~Privilege() {}
    Privilege(
        CHString& strIn,
        DWORD attribsIn)
      : dwAttributes(attribsIn)
    {
        chstrName = strIn;
    }

    CHString chstrName;
	DWORD dwAttributes;
};


typedef std::vector<CSidAndAttribute> SANDATTRIBUTE_VECTOR;
typedef std::vector<Privilege> PRIVILEGE_VECTOR;

//
// forwarding
//
class CSecurityDescriptor;

class CToken
{
public:
    CToken();
    CToken(const CToken& rTok);
    virtual ~CToken();

	void CleanToken () ;

    BOOL Duplicate	(
						const CToken& rTok,
						BOOL bReInit = TRUE,
						DWORD dwDesiredAccess = TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY,
						SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation,
						TOKEN_TYPE type = TokenImpersonation

					) ;

	BOOL GetTokenType ( TOKEN_TYPE& type ) const;
	BOOL IsValidToken ()
	{
		return m_fIsValid ;
	}

    long GetPrivCount() const;
    long GetGroupCount() const;

    bool GetPrivilege(
        Privilege* privOut,
        long lPos) const;

    bool GetGroup(
        CSid* sidOut,
        long lPos) const;

    // Deletes a member from the access token's
    // member list, and applies the change.  
    bool DeleteGroup(
        CSid& sidToDelete);

    // Adds a member to the specified group to
    // the list of token groups.
    bool AddGroup(
        CSid& sidToAdd, 
        DWORD dwAttributes);

    CToken& operator=(const CToken& rv);

    HANDLE GetTokenHandle() const;

    bool GetTokenOwner(
        CSid* sidOwner) const;

    // NOTE: hands back internal descriptor.
    bool GetDefaultSD(
        CSecurityDescriptor** ppsdDefault);

    DWORD SetDefaultSD(
        CSecurityDescriptor& SourceSD);

    DWORD EnablePrivilege(
        CHString& strPrivilegeName);

    DWORD DisablePrivilege(
        CHString& chstrPrivilegeName);

    void Dump(WCHAR* pszFileName);


protected:
    
    DWORD ReinitializeAll();    
    HANDLE m_hToken;
    DWORD m_dwLastError;
    bool m_fIsValid;

private:

    
	DWORD ReinitializeOwnerSid();
	DWORD ReinitializeDefaultSD();
	DWORD RebuildGroupList();
	DWORD RebuildPrivilegeList();
    DWORD GTI(
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        PVOID* ppvBuff);
    bool ApplyTokenGroups();

   
    CSid m_sidTokenOwner;					
	CSecurityDescriptor* m_psdDefault;				// Default security info
	SANDATTRIBUTE_VECTOR m_vecGroupsAndAttributes;	// List of groups and their attributes
	PRIVILEGE_VECTOR m_vecPrivileges;				// List of privileges

protected:

	bool m_fClose;

};



class CProcessToken : public CToken
{
public:
    CProcessToken	(
						HANDLE hProcess = INVALID_HANDLE_VALUE,
						bool fGetHandleOnly = true,
						DWORD dwDesiredAccess = MAXIMUM_ALLOWED
					);
    
    virtual ~CProcessToken() {}

private:

};


class CThreadToken : public CToken
{
public:
    //CThreadToken();

    CThreadToken	(
						HANDLE hThread = INVALID_HANDLE_VALUE,
						bool fGetHandleOnly = true,
						bool fAccessCheckProcess = false, 
						DWORD dwDesiredAccess = MAXIMUM_ALLOWED
			        );

    virtual ~CThreadToken() {}

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dacl.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CDACL.h - header file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CDACL_H__
#define __CDACL_H__





enum DACL_Types
{
    ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE = 0,
    ENUM_ACCESS_DENIED_ACE_TYPE,
    ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE,
    ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE,
    ENUM_ACCESS_ALLOWED_ACE_TYPE,

    ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE,
    ENUM_INH_ACCESS_DENIED_ACE_TYPE,
    ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE,
    ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE,
    ENUM_INH_ACCESS_ALLOWED_ACE_TYPE,
    
    // Keep this the last entry
    NUM_DACL_TYPES
};

#define DACLTYPE short

#define STATUS_EMPTY_DACL 0x10000000
#define STATUS_NULL_DACL  0x20000000



//////////////////////////////////////////////////////////////////
//
//	Class: CDACL
//
//	Class encapsulates a Win32 DACL, by providing public methods
//	for manipulating Access Allowed/Denied entries only.
//
//////////////////////////////////////////////////////////////////

class CDACL
{
	// Constructors and destructor
	public:
		CDACL();
		~CDACL( void );
        
        DWORD Init(PACL	pDACL);

        bool AddDACLEntry( PSID psid, 
                           DACLTYPE DaclType, 
                           DWORD dwAccessMask, 
                           BYTE bAceFlags, 
                           GUID *pguidObjGuid, 
                           GUID *pguidInhObjGuid );

        bool RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwIndex = 0  );
		bool RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid ); 
		
		bool CopyDACL ( CDACL & dacl );
		bool AppendDACL ( CDACL & dacl );

        void Clear();
        bool CreateNullDACL();

        // Override of functions of same name from CAccessEntry
        virtual bool Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
		virtual bool Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );

        DWORD ConfigureDACL( PACL& pDacl );
        BOOL CalculateDACLSize( LPDWORD pdwDaclLength );
        DWORD FillDACL( PACL pDacl );

        bool IsNULLDACL();
        bool IsEmpty();

        // Virtual function for returning all access value (default is GENERIC_ALL)
        virtual DWORD AllAccessMask();

        bool GetMergedACL(CAccessEntryList& a_aclIn);

        void DumpDACL(LPCWSTR wstrFilename = NULL);


    private:

        CAccessEntryList* m_rgDACLSections[NUM_DACL_TYPES];

         // Helper function for splitting aces by their cononical types
        bool SplitIntoCanonicalSections(CAccessEntryList& a_aclIn);

        // Helper to undo the damage done from the previous function!
        bool ReassembleFromCanonicalSections(CAccessEntryList& a_aclIn);

        // And for a real helper, here is one that takes a dacl that
        // might be in any fubar order and creates it afresh!
        bool PutInNT5CanonicalOrder();



        
};












#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dacl.cpp ===
/*****************************************************************************/
/*  Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.cpp - implementation file for CAccessEntry class.
 */

#include "precomp.h"
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::CDACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CDACL::CDACL( void )
{
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        m_rgDACLSections[s] = NULL;
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::~CDACL
//
//	Class destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CDACL::~CDACL( void )
{
    Clear();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::Init
//
//	Initializes the DACL member lists.
//
//	Inputs:
//
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD CDACL::Init(PACL a_pDACL)
{
    DWORD t_dwRes = E_FAIL;
    if(a_pDACL == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    CAccessEntryList t_aclTemp;
    t_dwRes = t_aclTemp.InitFromWin32ACL(a_pDACL);

    if(t_dwRes == ERROR_SUCCESS)
    {
        if(!SplitIntoCanonicalSections(t_aclTemp))
        {
            for(short s = 0; s < NUM_DACL_TYPES; s++)
            {
                delete m_rgDACLSections[s];
                m_rgDACLSections[s] = NULL;
            }
            t_dwRes = ERROR_SUCCESS;
        }
    }
    return t_dwRes;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::AddDACLEntry
//
//	Adds an access allowed entry to the ACL.  By default, these go
//	to the end of the list.
//
//	Inputs:
//				PSID		psid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CDACL::AddDACLEntry( PSID psid, DACLTYPE DaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = true;
    BYTE bACEType;

    // Sid must be valid
	if ( (psid != NULL) && IsValidSid( psid ) )
	{
        switch(DaclType)
        {
            case ENUM_ACCESS_DENIED_ACE_TYPE:
                bACEType = ACCESS_DENIED_ACE_TYPE;
                break;
            case ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_DENIED_OBJECT_ACE_TYPE;
                break;
            case ENUM_ACCESS_ALLOWED_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_ACE_TYPE;
                break;
            case ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
                break;
            case ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_DENIED_ACE_TYPE:
                bACEType = ACCESS_DENIED_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_DENIED_OBJECT_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_ALLOWED_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
                break;
            default:
                fReturn = false;
                break;
        }

        if(fReturn)
        {
            if(m_rgDACLSections[DaclType] == NULL)
            {
                try
                {
                    m_rgDACLSections[DaclType] = new CAccessEntryList;
                }
                catch(...)
                {
                    if(m_rgDACLSections[DaclType] != NULL)
                    {
                        delete m_rgDACLSections[DaclType];
                        m_rgDACLSections[DaclType] = NULL;
                    }
                    throw;
                }
                if(m_rgDACLSections[DaclType] != NULL)
                {
                    fReturn = m_rgDACLSections[DaclType]->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
                }
            }
            else
            {
                fReturn = m_rgDACLSections[DaclType]->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
            }
        }
	}
    else
    {
        fReturn = false;
    }

	return fReturn;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::RemoveDACLEntry
//
//	Removes an access allowed entry from the ACL.
//
//	Inputs:
//				CSID&		sid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CDACL::RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CAccessEntry	ACE( &sid, DaclType, bAceFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask);
	ACLPOSITION		pos;

	if ( m_rgDACLSections[DaclType]->BeginEnum( pos ) )
	{
		ON_BLOCK_EXIT_OBJ ( *m_rgDACLSections [ DaclType ], CAccessEntryList::EndEnum, ByRef ( pos ) ) ;

		// For loop will try to find a matching ACE in the list
	    CAccessEntry*	pACE = NULL;
        try
        {
    	    for (	pACE = m_rgDACLSections[DaclType]->GetNext( pos );
				    NULL != pACE
			    &&	!(ACE == *pACE);
				    pACE = m_rgDACLSections[DaclType]->GetNext( pos ) );

		    // If we got a match, delete the ACE.
		    if ( NULL != pACE )
		    {
			    m_rgDACLSections[DaclType]->Remove( pACE );
			    delete pACE;
			    fReturn = true;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::RemoveDACLEntry
//
//	Removes an access allowed entry from the ACL.
//
//	Inputs:
//				CSID&		sid - PSID
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CDACL::RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	ACLPOSITION		pos;

	if ( m_rgDACLSections[DaclType]->BeginEnum( pos ) )
	{
		ON_BLOCK_EXIT_OBJ ( *m_rgDACLSections [ DaclType ], CAccessEntryList::EndEnum, ByRef ( pos ) ) ;

		// For loop will try to find a matching ACE in the list
		CAccessEntry*	pACE = NULL;
        try
        {
            for (	CAccessEntry*	pACE = m_rgDACLSections[DaclType]->GetNext( pos );
				    NULL != pACE;
				    pACE = m_rgDACLSections[DaclType]->GetNext( pos ) )
		    {

			    CAccessEntry caeTemp(sid, DaclType, bAceFlags, pguidObjGuid, pguidInhObjGuid, pACE->GetAccessMask());
                // If we got a match, delete the ACE.
			    if (*pACE == caeTemp)
			    {
				    m_rgDACLSections[DaclType]->Remove( pACE );
				    fReturn = true;
				    break;
			    }
                delete pACE;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}
	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::RemoveDACLEntry
//
//	Removes an access allowed entry from the ACL.
//
//	Inputs:
//				CSID&		sid - PSID
//				DWORD		dwIndex - Index to remove.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST be dwIndex entry matching CSid.
//
///////////////////////////////////////////////////////////////////

bool CDACL::RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwIndex /*= 0*/ )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CSid			tempsid;
	ACLPOSITION		pos;
	DWORD			dwCtr = 0;

	if ( m_rgDACLSections[DaclType]->BeginEnum( pos ) )
	{
		ON_BLOCK_EXIT_OBJ ( *m_rgDACLSections [ DaclType ], CAccessEntryList::EndEnum, ByRef ( pos ) ) ;

		// For each ACE we find, see if it is an ACCESS_ALLOWED_ACE_TYPE,
		// and if the Sid matches the one passed in.  If it does, increment
		// the counter, then if we're on the right index remove the ACE,
		// delete it and quit.
		CAccessEntry*	pACE = NULL;
        try
        {
            for (	pACE = m_rgDACLSections[DaclType]->GetNext( pos );
				    NULL != pACE;
				    pACE = m_rgDACLSections[DaclType]->GetNext( pos ) )
		    {
			    if ( DaclType == pACE->GetACEType() )
			    {
				    pACE->GetSID( tempsid );

				    if ( sid == tempsid )
				    {
					    if ( dwCtr == dwIndex )
					    {
						    m_rgDACLSections[DaclType]->Remove( pACE );
						    fReturn = true;
						    break;
					    }
					    else
					    {
						    ++dwCtr;
					    }
				    }
                    delete pACE;
			    }
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}
	return fReturn;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CDACL::Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
    bool fReturn = false;

    switch(bACEType)
    {
        case ACCESS_DENIED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        default:
        {
            fReturn = false;
        }
    }
    return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CDACL::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
    bool fReturn = false;

    switch(bACEType)
    {
        case ACCESS_DENIED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        default:
        {
            fReturn = false;
        }
    }

    return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::ConfigureDACL
//
//	Configures a Win32 PACL with DACL information, maintaining
//	proper canonical order.
//
//	Inputs:
//				None.
//
//	Outputs:
//				PACL&			pDacl - Pointer to a DACL.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CDACL::ConfigureDACL( PACL& pDacl )
{
	DWORD		dwReturn		=	ERROR_SUCCESS,
				dwDaclLength	=	0;

	// Since we actually fake a NULL DACL with full control access for everyone.
	// If that's what we have, then we have what we call a NULL DACL, so we
	// shouldn't allocate a PACL.

	if ( !IsNULLDACL() )
	{
		if ( CalculateDACLSize( &dwDaclLength ) )
		{
			if ( 0 != dwDaclLength )
			{
                pDacl = NULL;
                try
                {
				    pDacl = (PACL) malloc( dwDaclLength );

				    if ( NULL != pDacl )
				    {
					    if ( !InitializeAcl( (PACL) pDacl, dwDaclLength, ACL_REVISION ) )
					    {
						    dwReturn = ::GetLastError();
					    }

				    }	// If NULL != pDacl
                }
                catch(...)
                {
                    if(pDacl != NULL)
                    {
                        free(pDacl);
                        pDacl = NULL;
                    }
                    throw;
                }

			}	// If 0 != dwDaclLength
            else // we have an empty dacl
            {
                pDacl = NULL;
                try
                {
                    pDacl = (PACL) malloc( sizeof(ACL) );
                    if ( NULL != pDacl )
				    {
					    if ( !InitializeAcl( (PACL) pDacl, sizeof(ACL), ACL_REVISION ) )
					    {
						    dwReturn = ::GetLastError();
					    }

				    }	// If NULL != pDacl
                }
                catch(...)
                {
                    if(pDacl != NULL)
                    {
                        free(pDacl);
                        pDacl = NULL;
                    }
                    throw;
                }
            }

		}	// If Calcaulate DACL Size
		else
		{
			dwReturn = ERROR_INVALID_PARAMETER;	// One or more of the DACLs is bad
		}

		if ( ERROR_SUCCESS == dwReturn )
		{
			dwReturn = FillDACL( pDacl );
		}

		if ( ERROR_SUCCESS != dwReturn )
		{
			free( pDacl );
			pDacl = NULL;
		}

	}	// IF !IsNULLDACL

	return dwReturn;

}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::CalculateDACLSize
//
//	Obtains the size necessary to populate a DACL.
//
//	Inputs:
//				None.
//
//	Outputs:
//				LPDWORD			pdwDaclLength - Calculated Length.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CDACL::CalculateDACLSize( LPDWORD pdwDaclLength )
{
	BOOL			fReturn			=	TRUE;

	*pdwDaclLength = 0;


    for(short s = 0; s < NUM_DACL_TYPES && fReturn; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            fReturn = m_rgDACLSections[s]->CalculateWin32ACLSize( pdwDaclLength );
        }
    }
	return fReturn;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::FillDACL
//
//	Fills out a DACL, maintaining proper canonical order.
//
//	Inputs:
//				PACL			pDacl - Dacl to fill out.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CDACL::FillDACL( PACL pDacl )
{
	DWORD	dwReturn = E_FAIL;

	// For NT 5, we need to split out Inherited ACEs and add those in after the
	// current ones (which override).  The real trick here, is that the canonical
	// order of Access Denied, Access Denied Object, Access Allowed, Access Allowed Compound, Access Allowed Object,
    // Inherited Access Denied, Inherrited Access Denied Object, Inherited Access Allowed, Inherrited Access Allowed Compound,
    // and Inherrited Access Allowed Object must be maintained.

	// For prior versions, the only canonical order is Access Denied followed
	// by Access Allowed.

    // Create a working dacl
    CAccessEntryList t_daclCombined;

    ReassembleFromCanonicalSections(t_daclCombined);
    dwReturn = t_daclCombined.FillWin32ACL(pDacl);

	return dwReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::SplitIntoCanonicalSections
//
//	Splits a DACL by into its canonical parts.
//
//	Inputs:     accessentrylist to split up.  Results stored with
//              this CDACL.
//
//
//	Returns:
//				None.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////

bool CDACL::SplitIntoCanonicalSections
(
    CAccessEntryList& a_aclIn
)
{
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            delete m_rgDACLSections[s];
            m_rgDACLSections[s] = NULL;
        }
    }


    CAccessEntryList t_aclTemp;
    bool fRet = false;

    fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_ACE_TYPE, false);
    if(!t_aclTemp.IsEmpty())
    {
        try
        {
            m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] = new CAccessEntryList;
        }
        catch(...)
        {
            if(m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] != NULL)
            {
                delete m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE];
                m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] = NULL;
            }
            throw;
        }

        m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE]->Copy(t_aclTemp);
        t_aclTemp.Clear();
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_OBJECT_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]!= NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_COMPOUND_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_OBJECT_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_OBJECT_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_COMPOUND_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_OBJECT_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::ReassembleFromCanonicalSections
//
//	Reassembles a DACL by from its canonical parts.
//
//  Inputs: reference to accessentrylist that gets built up.

//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////

bool CDACL::ReassembleFromCanonicalSections
(
    CAccessEntryList& a_aclIn
)
{
    bool fRet = true;

    // and reassemble a new one (we rely on the fact that the enumeration
    // was layed out in the proper order) ...
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            fRet = a_aclIn.AppendList(*m_rgDACLSections[s]);
        }
    }

    return fRet;
}


bool CDACL::PutInNT5CanonicalOrder()
{
    bool t_fRet = false;
    CAccessEntryList t_ael;

    if(SplitIntoCanonicalSections(t_ael))
    {
        t_fRet = ReassembleFromCanonicalSections(t_ael);
    }
    return t_fRet;
}

bool CDACL::GetMergedACL
(
    CAccessEntryList& a_aclIn
)
{
    return ReassembleFromCanonicalSections(a_aclIn);
}


void CDACL::Clear()
{
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            delete m_rgDACLSections[s];
            m_rgDACLSections[s] = NULL;
        }
    }
}

bool CDACL::CopyDACL ( CDACL& dacl )
{
	bool fRet = true;

    Clear();

    for(short s = 0; s < NUM_DACL_TYPES && fRet; s++)
    {
        if(dacl.m_rgDACLSections[s] != NULL)
        {
            try
            {
                m_rgDACLSections[s] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[s] != NULL)
                {
                    delete m_rgDACLSections[s];
                    m_rgDACLSections[s] = NULL;
                }
                throw;
            }
            if(m_rgDACLSections[s] != NULL)
            {
                fRet = m_rgDACLSections[s]->Copy(*(dacl.m_rgDACLSections[s]));

            }
            else
            {
                fRet = false;
            }
        }
    }
    return fRet;
}

bool CDACL::AppendDACL ( CDACL& dacl )
{
	bool fRet = true;

    for(short s = 0; s < NUM_DACL_TYPES && fRet; s++)
    {
        if(dacl.m_rgDACLSections[s] != NULL)
        {
            if(m_rgDACLSections[s] == NULL)
            {
                try
                {
                    m_rgDACLSections[s] = new CAccessEntryList;
                }
                catch(...)
                {
                    if(m_rgDACLSections[s] != NULL)
                    {
                        delete m_rgDACLSections[s];
                        m_rgDACLSections[s] = NULL;
                    }
                    throw;
                }
            }

            if(m_rgDACLSections[s] != NULL)
            {
                fRet = m_rgDACLSections[s]->AppendList(*(dacl.m_rgDACLSections[s]));

            }
            else
            {
                fRet = false;
            }
        }
    }
    return fRet;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::IsNULLDACL
//
//	Checks our DACL Lists to see if we have a NULL DACL.  Which
//  means that all our lists are NULL, except for the
//  ACCESS_ALLOWED_ACE_TYPE list, which will have exactly one entry
//  in it - namely, an ACE for Everyone.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, a NULL DACL is the same as "Everyone" has Full Control,
//	so if a single Access Allowed entry exists that meets these
//	criteria, we consider ourselves to be NULL.
//
///////////////////////////////////////////////////////////////////

bool CDACL::IsNULLDACL()
{
	bool fReturn = false;

    // We have a NULL DACL if all the elements of our DACL array
    // are NULL
	if (m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] == NULL &&
		m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] == NULL  &&
        m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] == NULL &&
		m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] == NULL)
	{
		if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
		{
			// There can be only one.
			if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->NumEntries() == 1)
			{
				CSid			sid(_T("Everyone"));
				CAccessEntry	ace;

				// Get the entry and check that it is "Everyone" with
				// Full Control and no flags
				if (m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->GetAt( 0, ace ) )
				{
					CSid	aceSID;

					ace.GetSID( aceSID );
					fReturn = (		sid == aceSID
								&&	ace.GetAccessMask() == AllAccessMask()
								&&	ace.GetACEFlags() == 0 );
				}
			}	// IF only one entry
		}
	}	// If we had entries in other lists, no go.

	return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::IsEmpty
//
//	Checks if our various lists are empty.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				bool   true if we have at least one entry in at
//                     least one of our lists.
//
//	Comments:
//
//
///////////////////////////////////////////////////////////////////

bool CDACL::IsEmpty()
{
    bool fIsEmpty = true;
    for(short s = 0; s < NUM_DACL_TYPES && fIsEmpty; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            fIsEmpty = m_rgDACLSections[s]->IsEmpty();
        }
    }
    return fIsEmpty;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::CreateNullDacl
//
//	NULLs out our DACL Lists except for the ACCESS_ALLOWED_ACE_TYPE
//  list, which it clears, then enters an Everybody ace into.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, an empty DACL is different from a NULL DACL, in that
//	empty means nobody has access and NULL means everyone has
//	full control.
//
///////////////////////////////////////////////////////////////////

bool CDACL::CreateNullDACL()
{
	bool fReturn = false;

	// Clear out our DACLs first...
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            delete m_rgDACLSections[s];
            m_rgDACLSections[s] = NULL;
        }
    }

    // then allocate an ACCESS_ALLOWED_ACE_TYPE dacl...
    try
    {
        m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = new CAccessEntryList;
    }
    catch(...)
    {
        if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
        {
            delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE];
            m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = NULL;
        }
        throw;
    }

    // then fake a null dacl by adding an Everyone entry...
	if (m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
	{
		CSid	sid( _T("Everyone") );
        if(sid.IsOK() && sid.IsValid())
        {
		    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->AppendNoDup(sid.GetPSid(),
                                                                                  ACCESS_ALLOWED_ACE_TYPE,
                                                                                  CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                                                                  AllAccessMask(),
                                                                                  NULL,
                                                                                  NULL,
                                                                                  false,
                                                                                  false);
        }
	}

	return fReturn;

}


DWORD CDACL::AllAccessMask()
{
	return GENERIC_ALL;
    //return 0x01FFFFFF;
}


void CDACL::DumpDACL(LPCWSTR wstrFilename)
{
    CAccessEntryList aelCombo;

    Output(L"DACL contents follow...", wstrFilename);
    if(ReassembleFromCanonicalSections(aelCombo))
    {
        aelCombo.DumpAccessEntryList(wstrFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\devdesc.h ===
/////////////////////////////////////////////////////////////////////////

//

//  cfgmgrdevice.h    

//  

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    1/20/98		davwoh		Created
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __DEVICEDESC_H__
#define __DEVICEDESC_H__


class 
__declspec(uuid("571D3188-D45D-11d2-B35E-00104BC97924"))
CDeviceMemoryDescriptor: public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CDeviceMemoryDescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CDeviceMemoryDescriptor( DWORD dwResourceId, MEM_DES& memDes, CConfigMgrDevice* pOwnerDevice );
	CDeviceMemoryDescriptor( const CDeviceMemoryDescriptor& mem );
	~CDeviceMemoryDescriptor();

	DWORDLONG GetBaseAddress( void );
	DWORDLONG GetEndAddress( void );
	DWORD GetFlags( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CDeviceMemoryDescriptor, __uuidof(CDeviceMemoryDescriptor));

inline DWORDLONG CDeviceMemoryDescriptor::GetBaseAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PMEM_DES) m_pbResourceDescriptor)->MD_Alloc_Base : 0 );
}

inline DWORDLONG CDeviceMemoryDescriptor::GetEndAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PMEM_DES) m_pbResourceDescriptor)->MD_Alloc_End : 0 );
}

inline DWORD CDeviceMemoryDescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PMEM_DES) m_pbResourceDescriptor)->MD_Flags : 0 );
}

// A collection of DeviceMemory Port Descriptors
class CDeviceMemoryCollection : public TRefPtr<CDeviceMemoryDescriptor>
{
public:

	// Construction/Destruction
	CDeviceMemoryCollection();
	~CDeviceMemoryCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CDeviceMemoryCollection& operator = ( const CDeviceMemoryCollection& srcCollection );

};

inline const CDeviceMemoryCollection& CDeviceMemoryCollection::operator = ( const CDeviceMemoryCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllcommon.h ===
//=================================================================

//

// DllCommon.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

STDAPI CommonGetClassObject (

    REFIID riid,
    PPVOID ppv,
    LPCWSTR wszProviderName,
    LONG &lCount
);

STDAPI CommonCanUnloadNow (LPCWSTR wszProviderName, LONG &lCount);
BOOL STDAPICALLTYPE CommonProcessAttach(LPCWSTR wszProviderName, LONG &lCount, HINSTANCE hInstDLL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllcommon.cpp ===
//=================================================================

//

// DllCommon.cpp

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#include "DllCommon.h"

extern HMODULE ghModule ;

//***************************************************************************
//
//  CommonGetClassObject
//
//  Given an IID, PPVOID, Provider name, and a long ref, perform
//  the common tasks for a framework prover to get a class object
//
//***************************************************************************

STDAPI CommonGetClassObject (

    REFIID riid,
    PPVOID ppv,
    LPCWSTR wszProviderName,
    LONG &lCount
)
{
    HRESULT hr = S_OK;
    CWbemGlueFactory *pObj = NULL;

    try
    {
        LogMessage2( L"%s -> DllGetClassObject", wszProviderName );

        pObj = new CWbemGlueFactory (&lCount) ;

        if (NULL != pObj)
        {
            hr = pObj->QueryInterface(riid, ppv);

            if (FAILED(hr))
            {
                delete pObj;
                pObj = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
        if ( pObj != NULL )
        {
            delete pObj;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CommonGetClassObject
//
//  Given a Provider name, and a long ref, perform
//  the common tasks for a framework prover to determine whether it is ready
//  to unload
//
//***************************************************************************

STDAPI CommonCanUnloadNow (LPCWSTR wszProviderName, LONG &lCount)
{
    SCODE sc = S_FALSE;

    try
    {
        if (CWbemProviderGlue :: FrameworkLogoffDLL ( wszProviderName, &lCount ))
        {
            sc = S_OK;
            LogMessage2( L"%s  -> Dll CAN Unload",  wszProviderName);
        }
        else
        {
            LogMessage2( L"%s  -> Dll can NOT Unload", wszProviderName );
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
//  CommonCommonProcessAttach
//
//  Given a Provider name, a long ref, and the HINSTANCE passed to DLLMAIN, 
//  perform the common tasks loading a provider.
//
//  Note that this routine uses the extern ghModule assumed to be defined
//  by the caller.
//
//***************************************************************************

BOOL STDAPICALLTYPE CommonProcessAttach(LPCWSTR wszProviderName, LONG &lCount, HINSTANCE hInstDLL)
{
    BOOL bRet = TRUE;
    try
    {
        LogMessage( L"DLL_PROCESS_ATTACH" );
        ghModule = hInstDLL ;

        // Initialize once for each new process.
        // Return FALSE to fail DLL load.

        bRet = CWbemProviderGlue::FrameworkLoginDLL ( wszProviderName, &lCount ) ;
        if (!DisableThreadLibraryCalls(hInstDLL))
        {
            LogErrorMessage( L"DisableThreadLibraryCalls failed" );
        }
    }
    catch ( ... )
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\devdesc.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  devdesc.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    1/20/98		davwoh		Created
//
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <assertbreak.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "devdesc.h"
////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::CDeviceMemoryDescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryDescriptor::CDeviceMemoryDescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::CDeviceMemoryDescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				MEM_DES					memDes - Device Memory Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryDescriptor::CDeviceMemoryDescriptor(	DWORD				dwResourceId,
													MEM_DES&			memDes,
													CConfigMgrDevice*	pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &memDes, sizeof(MEM_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_Mem == GetResourceType() );
}

// Copy Constructor
CDeviceMemoryDescriptor::CDeviceMemoryDescriptor( const CDeviceMemoryDescriptor& mem )
: CResourceDescriptor( mem )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::~CDeviceMemoryDescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryDescriptor::~CDeviceMemoryDescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::GetString
//
//	Returns a string representation of the associated IO Port Address.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////
void *CDeviceMemoryDescriptor::GetResource()
{

	if ( NULL != m_pbResourceDescriptor ){
		// Cast to an IO Resource Descriptor, and place it's IO address values
		// in the string.
		PMEM_DES	pMEM = (PMEM_DES) m_pbResourceDescriptor;
        return pMEM;
	}

	return NULL;
}

//
//	Constructor and Destructor for the IO Port Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryCollection::CDeviceMemoryCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryCollection::CDeviceMemoryCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryCollection::~CDeviceMemoryCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryCollection::~CDeviceMemoryCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllmain.h ===
//***************************************************************************

//

//  MAINDLL.H

// 

//  Module: WBEM Framework Instance provider 

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

HRESULT RegisterServer(TCHAR *a_pName, REFGUID a_rguid ) ;
HRESULT UnregisterServer( REFGUID a_rguid ) ;

extern HMODULE ghModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllunreg.cpp ===
//=================================================================

//

// DllUnreg.cpp

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
extern HMODULE ghModule ;

//***************************************************************************
//
//  UnregisterServer
//
//  Given a clsid, remove the com registration
//
//***************************************************************************

HRESULT UnregisterServer( REFGUID a_rguid )
{
    WCHAR wcID[128];
    WCHAR szCLSID[128];
    WCHAR szProviderCLSIDAppID[128];
    HKEY  hKey;

    // Create the path using the CLSID

    StringFromGUID2( a_rguid, wcID, 128);
    StringCchCopyW(szCLSID, LENGTH_OF(szCLSID),TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    StringCchCopyW(szProviderCLSIDAppID,LENGTH_OF(szProviderCLSIDAppID), TEXT("SOFTWARE\\CLASSES\\APPID\\"));

    StringCchCatW(szCLSID, LENGTH_OF(szCLSID),wcID);
    StringCchCatW(szProviderCLSIDAppID,LENGTH_OF(szProviderCLSIDAppID), wcID);

    DWORD dwRet ;

    //Delete entries under APPID

    dwRet = RegDeleteKeyW(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        dwRet = RegDeleteKey(hKey, L"InProcServer32" );
        dwRet = RegDeleteKey(hKey, L"LocalServer32");
        CloseHandle(hKey);
    }

    dwRet = RegDeleteKeyW(HKEY_LOCAL_MACHINE, szCLSID);

    return NOERROR;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore ()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( ! GetVersionEx ( & os ) )
    {
        return FALSE;           // should never happen
    }

    return os.dwMajorVersion >= 4;
}

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue (

    wchar_t *pszKey,
    wchar_t *pszSubkey,
    wchar_t *pszValueName,
    wchar_t *pszValue
)
{
    HKEY        hKey;
    WCHAR       szKey[256];

    StringCchCopyW(szKey,LENGTH_OF(szKey),pszKey);

    if (NULL != pszSubkey)
    {
        StringCchCatW(szKey,LENGTH_OF(szKey), _T("\\"));
        StringCchCatW(szKey,LENGTH_OF(szKey), pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyExW(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueExW(hKey, (LPCTSTR)pszValueName, 0, REG_SZ, (BYTE *)(LPCTSTR)pszValue
            , (wcslen(pszValue)+1)*sizeof(WCHAR)))
            return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}

//***************************************************************************
//
//  RegisterServer
//
//  Given a clsid and a description, perform the com registration
//
//***************************************************************************

HRESULT RegisterServer (

    WCHAR *a_pName,
    REFGUID a_rguid
)
{
    WCHAR      wcID[128];
    WCHAR      szCLSID[128];
    WCHAR      szModule[MAX_PATH + 1];
    WCHAR * pName = _T("WBEM Framework Instance Provider");
    WCHAR * pModel;
    HKEY hKey1;

    szModule[MAX_PATH] = 0;
    GetModuleFileName(ghModule, szModule,  MAX_PATH);

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = L"Both" ;
    else
        pModel = L"Apartment" ;

    // Create the path.

    StringFromGUID2(a_rguid, wcID, 128);
    StringCchCopyW(szCLSID,LENGTH_OF(szCLSID), TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    StringCchCatW(szCLSID,LENGTH_OF(szCLSID), wcID);

#ifdef LOCALSERVER

    WCHAR szProviderCLSIDAppID[128];
    StringCchCopyW(szProviderCLSIDAppID,LENGTH_OF(szProviderCLSIDAppID),TEXT("SOFTWARE\\CLASSES\\APPID\\"));
    StringCchCatW(szProviderCLSIDAppID,LENGTH_OF(szProviderCLSIDAppID),wcID);

    if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_pName ))
        return SELFREG_E_CLASS;
#endif

    // Create entries under CLSID

    RegCreateKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);

    RegSetValueExW(hKey1, NULL, 0, REG_SZ, (BYTE *)a_pName, (lstrlen(a_pName)+1) *
        sizeof(WCHAR));


#ifdef LOCALSERVER

    if (FALSE ==SetKeyAndValue(szCLSID, _T("LocalServer32"), NULL,szModule))
        return SELFREG_E_CLASS;

    if (FALSE ==SetKeyAndValue(szCLSID, _T("LocalServer32"),_T("ThreadingModel"), pModel))
        return SELFREG_E_CLASS;
#else

    HKEY hKey2 ;
    RegCreateKey(hKey1, _T("InprocServer32"), &hKey2);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule,
        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ,
        (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    CloseHandle(hKey2);

#endif

    CloseHandle(hKey1);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllunreg.h ===
//=================================================================

//

// DllUnreg.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

HRESULT UnregisterServer( REFGUID a_rguid );
HRESULT RegisterServer (WCHAR *a_pName, REFGUID a_rguid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllutils.cpp ===
//=================================================================

//

// DllUtils.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include <assertbreak.h>
#include <lockwrap.h>
#include <lmerr.h>

#include <CCriticalSec.h>
#include <CAutoLock.h>
#include "dllmain.h"

#ifdef WIN9XONLY
#include <win32thk.h>
#endif

#include <CRegCls.h>
#include <delayimp.h>

#define UNRECOGNIZED_VARIANT_TYPE FALSE

DWORD   g_dwMajorVersion,
        g_dwMinorVersion,
        g_dwBuildNumber;

CCriticalSec g_CSFlakyFileVersionAPI;

// There is a problem with loading Cim32Net.dll over and over, so this code
// makes sure we only load it once, then unloads it at exit.
// these are used with GetCim32NetHandle

#ifdef WIN9XONLY
HoldSingleCim32NetPtr::HoldSingleCim32NetPtr()
{
}

// Initialize the static members
HINSTANCE HoldSingleCim32NetPtr::m_spCim32NetApiHandle = NULL;
CCritSec HoldSingleCim32NetPtr::m_csCim32Net;

HoldSingleCim32NetPtr::~HoldSingleCim32NetPtr()
{
//    FreeCim32NetApiPtr();
}

void HoldSingleCim32NetPtr::FreeCim32NetApiPtr()
{
    CLockWrapper Cim32NetLock( m_csCim32Net ) ;
	if (m_spCim32NetApiHandle)
    {
        FreeLibrary ( m_spCim32NetApiHandle );
        m_spCim32NetApiHandle = NULL;
    }
}

CCim32NetApi* HoldSingleCim32NetPtr::GetCim32NetApiPtr()
{
    CCim32NetApi* pNewCim32NetApi = NULL ;
	{
        // Avoid contention on static
        CLockWrapper Cim32NetLock( m_csCim32Net ) ;

        // Check for race condition
        if (m_spCim32NetApiHandle == NULL)
        {
            m_spCim32NetApiHandle = LoadLibrary ( "Cim32Net.dll" ) ;
        }

        if (m_spCim32NetApiHandle != NULL)
        {
		    pNewCim32NetApi = (CCim32NetApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidCim32NetApi, NULL);
        }
        else
        {
            LogErrorMessage2(L"Failed to loadlibrary Cim32Net.dll (0x%x)", GetLastError());
        }
	}

    return pNewCim32NetApi;
}

HoldSingleCim32NetPtr g_GlobalInstOfHoldSingleCim32NetPtr;


#endif




class CInitDllUtilsData
{
public:
    CInitDllUtilsData();
};

CInitDllUtilsData::CInitDllUtilsData()
{
	OSVERSIONINFO version = { sizeof(version) };

	GetVersionEx((LPOSVERSIONINFO) &version);

    g_dwMajorVersion = version.dwMajorVersion;
    g_dwMinorVersion = version.dwMinorVersion;
    g_dwBuildNumber = version.dwBuildNumber;
}

// So we can cache OS info automatically.
static CInitDllUtilsData dllUtilsData;

#ifdef NTONLY
// sets a status object with one single missing privilege
void WINAPI SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege)
{
	SAFEARRAY *psaPrivilegesReqd, *psaPrivilegesNotHeld;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;
	psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
	psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);

    if (psaPrivilegesReqd && psaPrivilegesNotHeld)
    {
        try
        {
            long index = 0;
            bstr_t privilege(pPrivilege);
            if(SUCCEEDED(SafeArrayPutElement(psaPrivilegesReqd, &index, (void*)(BSTR)privilege)))
            if(SUCCEEDED(SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void*)(BSTR)privilege))) 
            {
                CWbemProviderGlue::SetStatusObject(pContext, IDS_CimWin32Namespace,
                    L"Required privilege not enabled", WBEM_E_FAILED, psaPrivilegesNotHeld, psaPrivilegesReqd);
            }
        }
        catch ( ... )
        {
            SafeArrayDestroy(psaPrivilegesNotHeld);
            SafeArrayDestroy(psaPrivilegesReqd);
            throw ;
        }

        SafeArrayDestroy(psaPrivilegesNotHeld);
        SafeArrayDestroy(psaPrivilegesReqd);
    }
    else
    {
        if (psaPrivilegesNotHeld)
            SafeArrayDestroy(psaPrivilegesNotHeld);
        if (psaPrivilegesReqd)
            SafeArrayDestroy(psaPrivilegesReqd);

        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

}
#endif

DWORD WINAPI GetPlatformBuildNumber(void)
{
	return g_dwBuildNumber;
}

// 3 for NT 3.51
// 4 for NT 4.0, W95 & W98
DWORD WINAPI GetPlatformMajorVersion(void)
{
	return g_dwMajorVersion;
}

// 0 for W95, 10 for 98
DWORD WINAPI GetPlatformMinorVersion(void)
{
	return g_dwMajorVersion;
}

#ifdef WIN9XONLY
// returns TRUE iff the current OS is Win 98+
// false for NT or Win 95
bool WINAPI IsWin95(void)
{
	return g_dwMinorVersion == 0;
}

bool WINAPI IsWin98(void)
{
	return g_dwMinorVersion >= 10;
}

bool WINAPI IsMillennium(void)
{
	return g_dwMinorVersion >= 90;
}
#endif

#ifdef NTONLY
bool WINAPI IsWinNT52(void)
{
	return (g_dwMajorVersion >= 5 && g_dwMinorVersion == 2);
}

bool WINAPI IsWinNT51(void)
{
	return (g_dwMajorVersion >= 5 && g_dwMinorVersion == 1);
}

bool WINAPI IsWinNT5(void)
{
	return g_dwMajorVersion >= 5;
}

bool WINAPI IsWinNT4(void)
{
	return g_dwMajorVersion == 4;
}

bool WINAPI IsWinNT351(void)
{
	return g_dwMajorVersion	== 3 && g_dwMinorVersion	== 51;
}
#endif

/////////////////////////////////////////////////////////////////////
void WINAPI LogEnumValueError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey, LPCWSTR szId )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_REGISTRY_ENUM_VALUE_FOR_KEY, szId, szKey);
		LogErrorMessageEx(gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
void WINAPI LogOpenRegistryError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_OPEN_REGISTRY, szKey);

		LogErrorMessageEx(gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
// left in for hysterical purposes
// prefer to use LogMessage macro in BrodCast.h
//void LogError( char * szFile, DWORD dwLine, char * szKey )
//{
//	LogErrorMessageEx(szKey, szFile, dwLine);
//}
/////////////////////////////////////////////////////////////////////
void WINAPI LogLastError( LPCTSTR szFile, DWORD dwLine )
{
	if (IsErrorLoggingEnabled())
	{
		DWORD duhWord = GetLastError();
		CHString gazotta;
		gazotta.Format(IDS_GETLASTERROR, duhWord, duhWord);

		LogErrorMessageEx(gazotta, TOBSTRT(szFile), dwLine);
    }
}

///////////////////////////////////////////////////////////////////////
BOOL WINAPI GetValue( CRegistry & Reg,
               LPCWSTR szKey,
               LPCWSTR ValueName,
               CHString * pchsValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

	if( !bRet )
        LogEnumValueError(_T2(__FILE__), __LINE__, szKey, ValueName);

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL WINAPI GetValue( CRegistry & Reg,
               LPCWSTR szKey,
               LPCWSTR ValueName,
               DWORD * dwValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *dwValueBuffer) == ERROR_SUCCESS);

	if( !bRet )
        LogEnumValueError(_T2(__FILE__),__LINE__, TOBSTRT(szKey), TOBSTRT(ValueName));

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL WINAPI OpenAndGetValue( CRegistry & Reg,
                      LPCWSTR szKey,
                      LPCWSTR ValueName,
                      CHString * pchsValueBuffer )
{
	BOOL bRet = ( Reg.OpenLocalMachineKeyAndReadValue( szKey, ValueName, *pchsValueBuffer )== ERROR_SUCCESS);

	if( !bRet )
        LogEnumValueError(_T2(__FILE__),__LINE__, szKey, ValueName);

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL WINAPI GetBinaryValue( CRegistry & Reg, LPCWSTR szKey,
                     LPCWSTR ValueName, CHString * pchsValueBuffer )
{
    BOOL bRet = ( Reg.GetCurrentBinaryKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

    if( !bRet )
        (LogEnumValueError(_T2(__FILE__),__LINE__, szKey, ValueName));

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParms
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *
 *  INPUTS      : Pointer to a DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(DEVICEPARMS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    // While the docs say failure will set carry, experience shows
    // this isn't true.  So, if carry is clear, and ax is zero, we'll
    // assume that things are ok.
    if (reg.reg_EAX == 0)
        return TRUE;

    // If they didn't change the value, we'll assume that they followed
    // the spec and are correctly setting carry.
    if (reg.reg_EAX == 0x440d)
        return TRUE;

    // Otherwise, assume they are incorrectly setting carry, and have returned
    // a failure code.
    return FALSE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParmsFat32
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *                for Fat32 drives.
 *
 *  INPUTS      : Pointer to a EA_DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI GetDeviceParmsFat32(PEA_DEVICEPARAMETERS  pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x4860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(EA_DEVICEPARAMETERS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetDriveMapInfo
 *
 *  DESCRIPTION : Gets logical to physical mapping info
 *
 *  INPUTS      : Pointer to a DRIVE_MAP_INFO struct to receive the data
 *                Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

   reg.reg_EAX = 0x440d;      /* IOCTL for block devices */
   reg.reg_EBX = nDrive;      /* zero-based drive ID     */
   reg.reg_ECX = 0x086f;      /* Get Drive Map Info */
   reg.reg_EDX = (DWORD) pDriveMapInfo;

   // zero the struct
   memset(pDriveMapInfo, 0, sizeof(DRIVE_MAP_INFO));

   // Set the length byte
   pDriveMapInfo->btAllocationLength = sizeof(DRIVE_MAP_INFO);

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Get_ExtFreeSpace
 *
 *  DESCRIPTION : Gets detailed info about a partition
 *
 *  INPUTS      : Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *                Pointer to ExtGetDskFreSpcStruct
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));
   char szDrive[4];

   szDrive[0] = btDriveName;
   szDrive[1] = ':';
   szDrive[2] = '\\';
   szDrive[3] = '\0';

   reg.reg_EAX = 0x7303;							// Get_ExtFreeSpace
   reg.reg_ECX = sizeof(ExtGetDskFreSpcStruc);		// Size of the structure sent in
   reg.reg_EDI = (DWORD)pstExtGetDskFreSpcStruc;	// Structure
   reg.reg_EDX = (DWORD)szDrive;					// Drive to get info for

   // zero the struct
   memset(pstExtGetDskFreSpcStruc, 0, sizeof(ExtGetDskFreSpcStruc));

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_DRIVEINFO))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : VWIN32IOCTL
 *
 *  DESCRIPTION : Calls IOControl against the vwin32 vxd
 *
 *  INPUTS      : Pointer to DEVIOCTL_REGISTERS structure
 *                IOControl call number.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall)
{

    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

    SmartCloseHandle hDevice = CreateFile(_T("\\\\.\\VWIN32"), 0, 0, 0, OPEN_EXISTING,
        FILE_FLAG_DELETE_ON_CLOSE, 0);

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    else
    {
        fResult = DeviceIoControl(hDevice, dwCall, preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
    }

    if (!fResult)
    {
        return FALSE;
    }

    return TRUE;
}
#endif

CHString WINAPI GetFileTypeDescription(LPCTSTR szExtension)
{
   CRegistry RegInfo;
   CHString sTemp, sType(szExtension);

   if (RegInfo.Open(HKEY_CLASSES_ROOT, TOBSTRT(szExtension), KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue(L"", sTemp);

      if (RegInfo.Open(HKEY_CLASSES_ROOT, sTemp, KEY_READ) == ERROR_SUCCESS) {
         RegInfo.GetCurrentKeyValue(L"", sType);
      }
   }

   return sType;
}

void WINAPI ConfigStatusToCimStatus ( DWORD a_Status , CHString &a_StringStatus )
{
	if( a_Status & DN_ROOT_ENUMERATED  ||
		a_Status & DN_DRIVER_LOADED ||
		a_Status & DN_ENUM_LOADED ||
		a_Status & DN_STARTED )
	{
		a_StringStatus = IDS_STATUS_OK;
	}

		// we don't care about these:
		// DN_MANUAL,DN_NOT_FIRST_TIME,DN_HARDWARE_ENUM,DN_FILTERED
		// DN_DISABLEABLE, DN_REMOVABLE,DN_MF_PARENT,DN_MF_CHILD
	    // DN_NEED_TO_ENUM, DN_LIAR,DN_HAS_MARK

	if( a_Status & DN_MOVED ||
		a_Status & DN_WILL_BE_REMOVED)
	{
		a_StringStatus = IDS_STATUS_Degraded;
	}

	if( a_Status & DN_HAS_PROBLEM ||
		a_Status & DN_PRIVATE_PROBLEM)
	{
		a_StringStatus = IDS_STATUS_Error;
	}
}

#ifdef NTONLY
///////////////////////////////////////////////////////////////////
//
// Define the severity codes
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error

//
// Define the severity codes
//
//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
void WINAPI TranslateNTStatus( DWORD dwStatus, CHString & chsValue)
{

	switch((dwStatus & SEV_MASK) >> 30){

		case STATUS_SEVERITY_WARNING:
			chsValue = IDS_STATUS_Degraded;
			break;

		case STATUS_SEVERITY_SUCCESS:
			chsValue = IDS_STATUS_OK;
			break;

		case STATUS_SEVERITY_ERROR:
			chsValue = IDS_STATUS_Error;
			break;

		case STATUS_SEVERITY_INFORMATIONAL:
			chsValue = IDS_STATUS_OK;
			break;

		default:
			chsValue = IDS_STATUS_Unknown;
	}
}
#endif

//
#ifdef NTONLY
bool WINAPI GetServiceStatus( CHString a_chsService,  CHString &a_chsStatus )
{
	bool		t_bRet = false ;
	SC_HANDLE	t_hDBHandle	= NULL ;
	SC_HANDLE	t_hSvcHandle	= NULL ;

	try
	{
		if( t_hDBHandle = OpenSCManager( NULL, NULL, GENERIC_READ ) )
		{
			t_bRet = true ;

			if( t_hSvcHandle = OpenService (
				t_hDBHandle,
				a_chsService,
				SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE ) )
			{
				SERVICE_STATUS t_StatusInfo ;
				if ( ControlService( t_hSvcHandle, SERVICE_CONTROL_INTERROGATE, &t_StatusInfo ) )
				{
					switch( t_StatusInfo.dwCurrentState )
					{
						case SERVICE_STOPPED:
						{
							a_chsStatus = L"Degraded" ;
						}
						break ;

						case SERVICE_START_PENDING:
						{
							a_chsStatus = L"Starting" ;
						}
						break ;

						case SERVICE_STOP_PENDING:
						{
							a_chsStatus = L"Stopping" ;
						}
						break ;

						case SERVICE_RUNNING:
						case SERVICE_PAUSE_PENDING:
						{
							a_chsStatus = L"OK" ;
						}
						break ;

						case SERVICE_PAUSED:
						case SERVICE_CONTINUE_PENDING:
						{
							a_chsStatus = L"Degraded" ;
						}
						break ;
					}
				}
				else
				{
					a_chsStatus = L"Unknown" ;
				}

				CloseServiceHandle( t_hSvcHandle ) ;
				t_hSvcHandle = NULL ;
			}
			else
			{
				a_chsStatus = L"Unknown" ;
			}

			CloseServiceHandle( t_hDBHandle ) ;
			t_hDBHandle = NULL ;
		}
	}
	catch( ... )
	{
		if( t_hSvcHandle )
		{
			CloseServiceHandle( t_hSvcHandle ) ;
		}

		if( t_hDBHandle )
		{
			CloseServiceHandle( t_hDBHandle ) ;
		}

		throw ;
	}
	return t_bRet ;
}
#endif

//
bool WINAPI GetFileInfoBlock(LPCTSTR szFile, LPVOID *pInfo)
{
	BOOL    fRet = false;
	DWORD   dwTemp,
	        dwBlockSize;
    LPVOID pInfoTemp = NULL;

    if(pInfo != NULL)
    {
        try
        {
			CAutoLock cs(g_CSFlakyFileVersionAPI);
            dwBlockSize = GetFileVersionInfoSize((LPTSTR) szFile, &dwTemp);
	        if(dwBlockSize)
            {
		        pInfoTemp = (LPVOID) new BYTE[dwBlockSize + 4];
		        if(pInfoTemp != NULL)
                {
    			    memset( pInfoTemp, NULL, dwBlockSize + 4);
			        if (GetFileVersionInfo((LPTSTR) szFile, 0, dwBlockSize, pInfoTemp))
                    {
				        *pInfo = pInfoTemp;
                        fRet = true;
			        }
		        }
                else
                {
                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }
	        }
        }
        catch(...)
        {
            // We don't need to do anything else, just need to protect ourselves
            // from the flaky version.dll calls.
        }
    }
	return fRet;
}


bool WINAPI GetVarFromInfoBlock(LPVOID pInfo, LPCTSTR szVar, CHString &strValue)
{
	bool    fRet = false;

	try
    {
		if(pInfo != NULL)
        {
			WORD wLang = 0;
            WORD wCodePage = 0;
            UINT len;
            if(!GetVersionLanguage(pInfo, &wLang, &wCodePage) )
			{
				// on failure: default to English
				// this returns a pointer to an array of WORDs
				WORD *pArray;
				if (VerQueryValue(pInfo, _T("\\VarFileInfo\\Translation"), (void **)(&pArray), &len))
				{
					len = len / sizeof(WORD);

					// find the english one...
					for (int i = 0; i < len; i += 2)
					{
						if( pArray[i] == 0x0409 )
                        {
							wLang	  = pArray[i];
							wCodePage = pArray[i + 1];
							break;
						}
					}
				}
			}

			TCHAR *pMfg;
            TCHAR szTemp[256];
			StringCchPrintf(szTemp,LENGTH_OF(szTemp), _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, szVar);

			if( VerQueryValue(pInfo, szTemp, (void **)(&pMfg), &len))
            {
                strValue = pMfg;
				fRet = true;
			}
	    }
    }
    catch(...)
    {
        // We don't need to do anything else, just need to protect ourselves
        // from the flaky version.dll calls.
    }

	return fRet;
}



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:		BOOL GetVersionLanguage(void *vpInfo,
									WORD *wpLang,
									WORD *wpCodePage);
 Description:	This function extracts the language and codepage out of a passed GetFileVersionInfo()
				result. Consideration is given to variation in the layout.
 Arguments:		vpInfo, wpLang, wpCodePage
 Returns:		Boolean
 Inputs:
 Outputs:
 Caveats:
 Courtesy of:	SMS, Nick Dyer
 Raid:
 History:		a-peterc  30-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

BOOL WINAPI GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage)
{
	BOOL bRet = FALSE;

	*wpLang = 0;
	*wpCodePage = 0;

	if ( vpInfo )
	{
		VERHEAD* pVerInfo = NULL;
		pVerInfo = (VERHEAD*) vpInfo;

		BYTE* ptr = NULL;
		ptr = (BYTE*) &pVerInfo->vsf;
		ptr = ptr + pVerInfo->wValLen;

		if ( pVerInfo->wType == 0 || pVerInfo->wType == 1 )
		{
			StringFileInfo* pStringFileInfo = NULL;
			pStringFileInfo = (StringFileInfo*) ptr;

			if ( pStringFileInfo->wValueLength == 0 )
			{
				if ( wcscmp(L"StringFileInfo",pStringFileInfo->szKey) == 0 )
				{
					// OK! were aligned properly
					StringTable* pStringTable = NULL;
					pStringTable = (StringTable*) &pStringFileInfo->Children;

					if ( pStringTable->wValueLength == 0 )
					{
						swscanf(pStringTable->szKey, L"%4x%4x", wpLang, wpCodePage);

						if ( *wpLang && *wpCodePage )
						{
							bRet = TRUE;
						}
					}
				}
			}
		}
		else
		{
			ptr = ptr+4;

			if ( strcmp("StringFileInfo",reinterpret_cast < char* > (ptr) ) == 0 )
			{
				// OK! were aligned properly
				ptr = ptr+20;
				sscanf(reinterpret_cast < char* > (ptr), "%4x%4x", wpLang, wpCodePage);

				if ( *wpLang && *wpCodePage )
				{
					bRet = TRUE;
				}
			}
		}
	}

	return (bRet);
}

///////////////////////////////////////////////////////////////////

bool WINAPI GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg)
{
    LPVOID lpv = NULL;
    bool fRet = false;
    try
    {
        if(GetFileInfoBlock(szFile, &lpv) && (lpv != NULL))
        {
            fRet = GetVarFromInfoBlock(lpv, _T("CompanyName"), strMfg);
            delete lpv;
            lpv = NULL;
        }
    }
    catch(...)
    {
        if(lpv != NULL)
        {
            delete lpv;
            lpv = NULL;
        }
        throw;
    }
    return fRet;
}

bool WINAPI GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion)
{
    LPVOID lpv = NULL;
    bool fRet = false;
    try
    {
        if(GetFileInfoBlock(szFile, &lpv) && (lpv != NULL))
        {
            fRet = GetVarFromInfoBlock(lpv, _T("ProductVersion"), strVersion);
            delete lpv;
            lpv = NULL;
        }
    }
    catch(...)
    {
        if(lpv != NULL)
        {
            delete lpv;
            lpv = NULL;
        }
        throw;
    }
    return fRet;
}


void WINAPI ReplaceString(CHString &str, LPCWSTR szFind, LPCWSTR szReplace)
{
    int iWhere,
        nLen = lstrlenW(szFind);

    while ((iWhere = str.Find(szFind)) != -1)
    {
        str.Format(
            L"%s%s%s",
            (LPCWSTR) str.Left(iWhere),
            szReplace,
            (LPCWSTR) str.Mid(iWhere + nLen));
    }
}

#ifdef NTONLY
BOOL WINAPI GetServiceFileName(LPCTSTR szService, CHString &strFileName)
{
    SmartCloseServiceHandle   hSCManager,
                hService;
    TCHAR       szBuffer[2048];
    QUERY_SERVICE_CONFIG
                *pConfig = (QUERY_SERVICE_CONFIG *) szBuffer;
    DWORD       dwNeeded;
    BOOL        bRet = FALSE;

    hSCManager =
        OpenSCManager(
            NULL,
            NULL,
            STANDARD_RIGHTS_REQUIRED);

    if (!hSCManager)
        return FALSE;

    hService =
        OpenService(
        hSCManager,
        szService,
        SERVICE_QUERY_CONFIG);

    if (hService)
    {
        if (QueryServiceConfig(
            hService,
            pConfig,
            sizeof(szBuffer),
            &dwNeeded))
        {
            strFileName = pConfig->lpBinaryPathName;

            // Now fix up the path so that it has a drive letter.

            strFileName.MakeUpper();

            // If the filename is using \SYSTEMROOT\, replace it with %SystemRoot%.
            if (strFileName.Find(_T("\\SYSTEMROOT\\")) == 0)
                ReplaceString(strFileName, _T("\\SYSTEMROOT\\"), _T("%SystemRoot%\\"));
            // If the filename doesn't start with a replacement string, and if it
            // doesn't have a drive letter, assume it should start with
            // %SystemRoot%.
            else if (strFileName.GetLength() >= 2 &&
                strFileName[0] != '%' && strFileName[1] != ':')
            {
                CHString strTemp;

                strTemp.Format(_T("%%SystemRoot%%\\%s"), (LPCTSTR) strFileName);
                strFileName = strTemp;
            }

            TCHAR szOut[MAX_PATH * 2];

            ExpandEnvironmentStrings(strFileName, szOut, sizeof(szOut) / sizeof(TCHAR));
            strFileName = szOut;

            bRet = TRUE;
        }
    }

    return bRet;
}
#endif

///////////////////////////////////////////////////////////////////
// Performs a case insensitive compare (such as is required for keys)
// on two variants and returns true if they are the same type and
// the same value, else false.  Note that arrays, VT_NULL, and
// embedded objects will assert, and return false.
///////////////////////////////////////////////////////////////////
bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2)
{

   if (v1->vt == v2->vt)
   {
      switch (v1->vt)
      {
          case VT_BOOL: return (v1->boolVal == v2->boolVal);
          case VT_UI1:  return (v1->bVal == v2->bVal);
          case VT_I2:   return (v1->iVal == v2->iVal);
          case VT_I4:   return (v1->lVal == v2->lVal);
          case VT_R4:   return (v1->fltVal == v2->fltVal);
          case VT_R8:   return (v1->dblVal == v2->dblVal);
          case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
          default:
             ASSERT_BREAK(UNRECOGNIZED_VARIANT_TYPE);
      }
   }

   return false;
}

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WINAPI WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;

	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PRINTER_NAME:
		case ERROR_BAD_USERNAME:
		case NERR_NetNameNotFound:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}

void WINAPI SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance)
{
    CHString	strDeviceID;
    DWORD		dwStatus,
        dwProblem;

    if (pDevice->GetDeviceID(strDeviceID))
        pInstance->SetCHString(IDS_PNPDeviceID, strDeviceID);

    if (pDevice->GetStatus(&dwStatus, &dwProblem))
        pInstance->SetDWORD(IDS_ConfigManagerErrorCode, dwProblem);

    pInstance->SetDWORD(IDS_ConfigManagerUserConfig,
        pDevice->IsUsingForcedConfig());
}

#ifdef NTONLY
BOOL WINAPI EnablePrivilegeOnCurrentThread(LPCTSTR szPriv)
{
    BOOL                bRet = FALSE;
    HANDLE              hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token. 
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES |
        TOKEN_QUERY, FALSE, &hToken))
    {

        {
            bLookup = LookupPrivilegeValue(NULL, szPriv, &tkp.Privileges[0].Luid);
        }
        if (bLookup)
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            bRet = AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
                        (PTOKEN_PRIVILEGES) NULL, 0);
            dwLastError = GetLastError();
        }

        CloseHandle(hToken);
    }
	else
	{
		dwLastError = ::GetLastError();
	}

    // We have to check GetLastError() because AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return bRet && dwLastError == ERROR_SUCCESS;
}
#endif

// Takes a pnp id and returns a bios unit number
// To avoid frequent load/unload of a library, the pGetWin9XBiosUnit parameter comes from:
//                     HINSTANCE hInst =  LoadLibrary("cim32net.dll");
//                     pGetWin9XBiosUnit = (fnGetWin9XBiosUnit)GetProcAddress(hInst, "GetWin9XBiosUnit");
#ifdef WIN9XONLY
BYTE WINAPI GetBiosUnitNumberFromPNPID(CHString strDeviceID)
{
    CHString sTemp;
    DRIVE_MAP_INFO stDMI;
    CRegistry Reg1;

    BYTE btBiosUnit = -1;

    // Open the associated registry key
    if (Reg1.Open(HKEY_LOCAL_MACHINE, _T("enum\\") + strDeviceID, KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {

        // Get a drive letter for this pnp id
        if ((Reg1.GetCurrentKeyValue(L"CurrentDriveLetterAssignment", sTemp) != ERROR_SUCCESS) ||
            (sTemp.GetLength() == 0)) {
            // No drive letters, let's try one more thing.  On memphis sp1, this call will also
            // get us a unit number.
            CCim32NetApi* t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
            if (t_pCim32Net != NULL)
            {
#ifndef UNICODE // This function only takes a LPSTR, and only works on 9x anyway.
                btBiosUnit = t_pCim32Net->GetWin9XBiosUnit(TOBSTRT(strDeviceID));
                CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net);
                t_pCim32Net = NULL;
#endif
            }
        }
        else
        {
            if (GetDriveMapInfo(&stDMI, toupper(sTemp[0]) - 'A' + 1))
            {
                btBiosUnit = stDMI.btInt13Unit;
            }
        }
    }

    return btBiosUnit;
}
#endif

HRESULT WINAPI GetHKUserNames(CHStringList &list)
{
	HRESULT hres;

	// Empty the list.
	list.clear();

#ifdef NTONLY
	{
		// Enum the profiles from the registry.
		CRegistry	regProfileList;
		CHString	strProfile;
		DWORD		dwErr;

		// Open the ProfileList key so we know which profiles to load up.
		if ((dwErr = regProfileList.OpenAndEnumerateSubKeys(
			HKEY_LOCAL_MACHINE,
			IDS_RegNTProfileList,
			KEY_READ)) == ERROR_SUCCESS)
		{
			for (int i = 0; regProfileList.GetCurrentSubKeyName(strProfile) ==
				ERROR_SUCCESS; i++)
			{
				list.push_back(strProfile);
				regProfileList.NextSubKey();
			}
		}

		// Add the .DEFAULT name.
		list.push_back(_T(".DEFAULT"));

		hres = WinErrorToWBEMhResult(dwErr);
	}
#endif
#ifdef WIN9XONLY
	{
		DWORD	dwErr = ERROR_SUCCESS;
#ifdef _DEBUG
		DWORD	dwSize = 10,
#else
		DWORD	dwSize = 1024,
#endif
				dwBytesRead;
		TCHAR	*szBuff = NULL;

		// Keep looping until we read the entire section.
		// You know your buffer wasn't big enough if the returned number
		// of bytes == (size passed in - 2).
		do
		{
			if (szBuff)
			{
				delete [] szBuff;

				dwSize *= 2;
			}

			szBuff = new TCHAR [dwSize];

			// Out of memory.  Get out of loop.
			if (!szBuff)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            try
            {
			    dwBytesRead =
				    GetPrivateProfileString(
					    _T("Password Lists"),
					    NULL,
					    _T(""),
					    szBuff,
					    dwSize / sizeof(TCHAR),
					    _T("system.ini"));
            }
            catch ( ... )
            {
                delete [] szBuff;
                throw;
            }

		} while (dwBytesRead >= dwSize - 2);

		if (szBuff)
		{
            try
            {
			    // Loop through the list of names.  Each is null-terminated, and the
			    // list is terminated with a double null.
			    TCHAR *pszCurrent = szBuff;

			    while (*pszCurrent)
			    {
				    list.push_back(pszCurrent);

				    pszCurrent += lstrlen(pszCurrent) + 1;
			    }

			    hres = WBEM_S_NO_ERROR;
            }
            catch ( ... )
            {
                delete [] szBuff;
                throw;
            }

			// Free the buffer.
			delete [] szBuff;

			// Add the .DEFAULT name.
			list.push_back(_T(".DEFAULT"));
		}
		else
			// Failed to malloc, so set error code.
			hres = WBEM_E_OUT_OF_MEMORY;
	}
#endif

	return hres;
}


VOID WINAPI EscapeBackslashes(CHString& chstrIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID WINAPI EscapeQuotes(CHString& chstrIn,
                  CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\"'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext);
        // Escape the quote:
        chstrOut += _T("\\\"");
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\"'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID WINAPI RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrOut = chstrBuildString;
}

CHString WINAPI RemoveDoubleBackslashes(const CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    return chstrBuildString;
}

#ifdef NTONLY
// helper for StrToSID
// takes a string, converts to a SID_IDENTIFIER_AUTHORITY
// returns false if not a valid SID_IDENTIFIER_AUTHORITY
// contents of identifierAuthority are unrelieable on failure
bool WINAPI StrToIdentifierAuthority(const CHString& str, SID_IDENTIFIER_AUTHORITY& identifierAuthority)
{
    bool bRet = false;
    memset(&identifierAuthority, '\0', sizeof(SID_IDENTIFIER_AUTHORITY));

    DWORD duhWord;
    WCHAR* p = NULL;
    CHString localStr(str);

    // per KB article Q13132, if identifier authority is greater than 2**32, it's in hex
    if ((localStr[0] == '0') && ((localStr[1] == 'x') || (localStr[1] == 'X')))
    // if it looks hexidecimalish...
    {
        // going to parse this out backwards, chpping two chars off the end at a time
        // first, whack off the 0x
        localStr = localStr.Mid(2);

        CHString token;
        int nValue =5;

        bRet = true;
        while (bRet && localStr.GetLength() && (nValue > 0))
        {
            token = localStr.Right(2);
            localStr = localStr.Left(localStr.GetLength() -2);
            duhWord = wcstoul(token, &p, 16);

            // if strtoul succeeds, the pointer is moved
            if (p != (LPCTSTR)token)
                identifierAuthority.Value[nValue--] = (BYTE)duhWord;
            else
                bRet = false;
        }
    }
    else
    // it looks decimalish
    {
        duhWord = wcstoul(localStr, &p, 10);

        if (p != (LPCTSTR)localStr)
        // conversion succeeded
        {
            bRet = true;
            identifierAuthority.Value[5] = LOBYTE(LOWORD(duhWord));
            identifierAuthority.Value[4] = HIBYTE(LOWORD(duhWord));
            identifierAuthority.Value[3] = LOBYTE(HIWORD(duhWord));
            identifierAuthority.Value[2] = HIBYTE(HIWORD(duhWord));
        }
    }

    return bRet;
}

// for input of the form AAA-BBB-CCC
// will return AAA in token
// and BBB-CCC in str
bool WINAPI WhackToken(CHString& str, CHString& token)
{
	bool bRet = false;
	if (bRet = !str.IsEmpty())
	{
		int index;
		index = str.Find('-');

		if (index == -1)
		{
			// all that's left is the token, we're done
			token = str;
			str.Empty();
		}
		else
		{
			token = str.Left(index);
			str = str.Mid(index+1);
		}
	}
	return bRet;
}

// a string representation of a SID is assumed to be:
// S-#-####-####-####-####-####-####
// we will enforce only the S ourselves,
// The version is not checked
// everything else will be handed off to the OS
// caller must free the SID returned
PSID WINAPI StrToSID(const CHString& sid)
{
	PSID pSid = NULL;
	if (!sid.IsEmpty() && ((sid[0] == 'S')||(sid[0] == 's')) && (sid[1] == '-'))
	{
		// get a local copy we can play with
		// we'll parse this puppy the easy way
		// by slicing off each token as we find it
		// slow but sure
		// start by slicing off the "S-"
		CHString str(sid.Mid(2));
		CHString token;

		SID_IDENTIFIER_AUTHORITY identifierAuthority = {0,0,0,0,0,0};
		BYTE nSubAuthorityCount =0;  // count of subauthorities
		DWORD dwSubAuthority[8]   = {0,0,0,0,0,0,0,0};    // subauthorities

		// skip version
		WhackToken(str, token);
		// Grab Authority
		if (WhackToken(str, token))
		{
            DWORD duhWord;
			WCHAR* p = NULL;
			bool bDoIt = false;

			if (StrToIdentifierAuthority(token, identifierAuthority))
			// conversion succeeded
			{
				bDoIt = true;

				// now fill up the subauthorities
				while (bDoIt && WhackToken(str, token))
				{
					p = NULL;
					duhWord = wcstoul(token, &p, 10);

					if (p != (LPCTSTR)token)
					{
						dwSubAuthority[nSubAuthorityCount] = duhWord;
						bDoIt = (++nSubAuthorityCount <= 8);
					}
					else
						bDoIt = false;
				} // end while WhackToken

				if(bDoIt)
                {
					AllocateAndInitializeSid(&identifierAuthority,
					   						  nSubAuthorityCount,
											  dwSubAuthority[0],
											  dwSubAuthority[1],
											  dwSubAuthority[2],
											  dwSubAuthority[3],
											  dwSubAuthority[4],
											  dwSubAuthority[5],
											  dwSubAuthority[6],
											  dwSubAuthority[7],
											  &pSid);
                }
			}
		}
	}
	return pSid;
}
#endif // NTONLY defined


CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FILETIME *pFileTime)
{
    CHString strDate,
             strRootPath;

    // UNC path?
    if (szFilename[0] == '\\' && szFilename[1] == '\\')
    {
        LPTSTR szSlash = _tcschr(&szFilename[2], '\\');

        // If szSlash, we're sitting on 3rd slash of \\server\share\myfile
        if (szSlash)
        {
            szSlash = _tcschr(szSlash + 1, '\\');

            // If no 4th slash, there's no filename.
            if (szSlash)
            {
                strRootPath = szFilename;
                strRootPath =
                    strRootPath.Left(szSlash - szFilename + 1);
            }
        }
    }
    // Drive path?
    else if (szFilename[1] == ':')
    {
        strRootPath = szFilename;
        strRootPath = strRootPath.Left(3);
    }

    if (!strRootPath.IsEmpty())
    {
        TCHAR szBuffer[MAX_PATH];
        BOOL  bNTFS = FALSE;

        if (GetVolumeInformation(
                TOBSTRT(strRootPath),
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                szBuffer,
                sizeof(szBuffer) / sizeof(TCHAR)) &&
            !lstrcmpi(szBuffer, _T("NTFS")))
        {
            bNTFS = TRUE;
        }

        strDate = GetDateTimeViaFilenameFiletime(bNTFS, pFileTime);
    }

    return strDate;
}

CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FT_ENUM ftWhich)
{
    WIN32_FIND_DATA finddata;
    SmartFindClose  hFind = FindFirstFile(szFilename, &finddata);
    CHString        strDate;

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FILETIME *pFileTime = NULL;

        switch(ftWhich)
        {
            case FT_CREATION_DATE:
                pFileTime = &finddata.ftCreationTime;
                break;

            case FT_ACCESSED_DATE:
                pFileTime = &finddata.ftLastAccessTime;
                break;

            case FT_MODIFIED_DATE:
                pFileTime = &finddata.ftLastWriteTime;
                break;

            default:
                // Caller must send in a proper enum value.
                ASSERT_BREAK(FALSE);
                break;
        }

        if (pFileTime)
            strDate = GetDateTimeViaFilenameFiletime(szFilename, pFileTime);
    }

    return strDate;
}

CHString WINAPI GetDateTimeViaFilenameFiletime(BOOL bNTFS, FILETIME *pFileTime)
{
    WBEMTime wbemTime(*pFileTime);
             // This is just used as a wrapper.  It avoids a try/catch block.
    bstr_t   bstrDate(bNTFS ? wbemTime.GetDMTF() : wbemTime.GetDMTFNonNtfs(), false);
    CHString strRet = (LPWSTR) bstrDate;

    return strRet;
}

// Used to validate a numbered device ID is OK.
// Example: ValidateNumberedDeviceID("VideoController7", "VideoController", pdwWhich)
//          returns TRUE, pdwWhich = 7.
// Example: ValidateNumberedDeviceID("BadDeviceID", "VideoController", pdwWhich)
//          returns FALSE, pdwWhich unchanged
BOOL WINAPI ValidateNumberedDeviceID(LPCWSTR szDeviceID, LPCWSTR szTag, DWORD *pdwWhich)
{
    BOOL bRet = FALSE;
    int  nTagLen = wcslen(szTag);

    if (wcslen(szDeviceID) > nTagLen)
    {
        CHString strDeviceID;
        DWORD    dwWhich = _wtoi(&szDeviceID[nTagLen]);

        strDeviceID.Format(L"%s%d", szTag, dwWhich);

        if (!_wcsicmp(szDeviceID, strDeviceID))
        {
            bRet = TRUE;
            *pdwWhich = dwWhich;
        }
    }

    return bRet;
}

// Critical sections used by various
CCritSec g_csPrinter;
CCritSec g_csSystemName;
#ifdef WIN9XONLY
CCritSec g_csVXD;
#endif

#define STR_BLK_SIZE 256
#define CHAR_FUDGE 1    // one WCHAR unused is good enough
BOOL LoadStringW(CHString &sString, UINT nID)
{
    // try fixed buffer first (to avoid wasting space in the heap)
    WCHAR szTemp[ STR_BLK_SIZE ];

    int nLen = LoadStringW(nID, szTemp, STR_BLK_SIZE);
    
    if (STR_BLK_SIZE - nLen > CHAR_FUDGE)
    {
        sString = szTemp;
    }
    else
    {
        // try buffer size of 512, then larger size until entire string is retrieved
        int nSize = STR_BLK_SIZE;

        do
        {
            nSize += STR_BLK_SIZE;
            nLen = LoadStringW(nID, sString.GetBuffer(nSize-1), nSize);

        } 
        while (nSize - nLen <= CHAR_FUDGE);

        sString.ReleaseBuffer();
    }

    return nLen > 0;
}

void Format(CHString &sString, UINT nFormatID, ...)
{
    va_list argList;
    va_start(argList, nFormatID);

    CHString strFormat;
    
    LoadStringW(strFormat, nFormatID);

    sString.FormatV(strFormat, argList);
    va_end(argList);
}

void FormatMessageW(CHString &sString, UINT nFormatID, ...)
{
    // get format string from string table
    CHString strFormat;
    
    LoadStringW(strFormat, nFormatID);

    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, nFormatID);

#ifdef NTONLY
    LPWSTR lpszTemp;

    if (::FormatMessageW(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPCWSTR) strFormat, 
        0, 
        0, 
        (LPWSTR) &lpszTemp, 
        0, 
        &argList) == 0 || lpszTemp == NULL)
    {
        // Should throw memory exception here.  Now we do.
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
    else
    {
        // assign lpszTemp into the resulting string and free lpszTemp
        sString = lpszTemp;
        LocalFree(lpszTemp);
        va_end(argList);
    }
#else
    #error Not written for win9x
#endif
}

int LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
    int nLen = 0;

#ifdef NTONLY
    nLen = ::LoadStringW(ghModule, nID, lpszBuf, nMaxBuf);
    if (nLen == 0)
    {
        lpszBuf[0] = '\0';
    }
#else
    #error Not written for win9x
#endif

    return nLen; // excluding terminator
}

bool WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep) 
{
    // We might have thrown as a result of the
    // delay load library mechanism.  There are
    // two types of such exceptions - those
    // generated because the dll could not be
    // loaded, and thos generated because the
    // proc address of the function referred to
    // could not be found.  We want to log an
    // error message in either case.
    bool fRet = false;
    if(pep &&
        pep->ExceptionRecord)
    {
        // If this is a Delay-load problem, ExceptionInformation[0] points 
        // to a DelayLoadInfo structure that has detailed error info
        PDelayLoadInfo pdli = PDelayLoadInfo(
            pep->ExceptionRecord->ExceptionInformation[0]);
        
        if(pdli)
        {
            switch(pep->ExceptionRecord->ExceptionCode) 
            {
                case VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND):
                {
                    // The DLL module was not found at runtime
                    LogErrorMessage2(L"Dll not found: %s", pdli->szDll);
                    fRet = true; 
                    break;
                }
                case VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND):
                {
                    // The DLL module was found but it doesn't contain the function
                    if(pdli->dlp.fImportByName) 
                    {
                        LogErrorMessage3(
                            L"Function %s was not found in %s",
                            pdli->dlp.szProcName, 
                            pdli->szDll);
                    } 
                    else 
                    {
                        LogErrorMessage3(
                            L"Function ordinal %d was not found in %s",
                            pdli->dlp.dwOrdinal, 
                            pdli->szDll);
                    }
                    fRet = true;
                    break; 
                }
            }
        }
    }
    return fRet;
}


// This is here in common because
// at least the classes Pagefile and
// PageFileSetting use it, perhaps
// more in the future.
#ifdef NTONLY
HRESULT CreatePageFile(
    LPCWSTR wstrPageFileName,
    const LARGE_INTEGER liInitial,
    const LARGE_INTEGER liMaximum,
    const CInstance& Instance)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    UNICODE_STRING ustrFileName = { 0 };
    NTSTATUS status = STATUS_SUCCESS;
    
    if(!EnablePrivilegeOnCurrentThread(SE_CREATE_PAGEFILE_NAME))
    {
        SetSinglePrivilegeStatusObject(
            Instance.GetMethodContext(), 
            SE_CREATE_PAGEFILE_NAME);
        hr = WBEM_E_ACCESS_DENIED;
    }

    
    if(SUCCEEDED(hr))
    {
        if(!::RtlDosPathNameToNtPathName_U(
            wstrPageFileName, 
            &ustrFileName, 
            NULL, 
            NULL) && ustrFileName.Buffer) 
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    
    try
    {
        if(SUCCEEDED(hr))
        {
            LARGE_INTEGER liInit;
            LARGE_INTEGER liMax;
        
            liInit.QuadPart = liInitial.QuadPart * 1024 * 1024;
            liMax.QuadPart = liMaximum.QuadPart * 1024 * 1024;

            if(!NT_SUCCESS(
                status = ::NtCreatePagingFile(
                    &ustrFileName,
                    &liInit,
                    &liMax,
                    0)))
            {
                if (STATUS_INVALID_PARAMETER_2 == status)
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                else
                    hr = WinErrorToWBEMhResult(RtlNtStatusToDosError(status));
            }
        }

    
        RtlFreeUnicodeString(&ustrFileName);
        ustrFileName.Buffer = NULL;
     
    }
    catch(...)
    {
        RtlFreeUnicodeString(&ustrFileName);
        ustrFileName.Buffer = NULL;
        throw;
    }

    return hr;
}
#endif


// Useful for obtaining the localized versions
// of "All Users" and "Default User".
#if NTONLY >= 5
bool GetAllUsersName(CHString& chstrAllUsersName)
{
    bool fRet = false;
    CRegistry reg;
    CHString chstrTemp;

    DWORD dwRet = reg.Open(
		HKEY_LOCAL_MACHINE,
		L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
		KEY_READ);

    if(dwRet == ERROR_SUCCESS)
    {
        if(reg.GetCurrentKeyValue(
            L"AllUsersProfile", 
            chstrTemp) == ERROR_SUCCESS)
        {
            chstrAllUsersName = chstrTemp.SpanExcluding(L".");
            fRet = true;
        }
    }
    if(!fRet)
    {
        chstrAllUsersName = L"";
    }

    return fRet;
}
#endif

#if NTONLY >= 5
bool GetDefaultUsersName(CHString& chstrDefaultUsersName)
{
    bool fRet = false;
    CRegistry reg;
    CHString chstrTemp;

    DWORD dwRet = reg.Open(
		HKEY_LOCAL_MACHINE,
		L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
		KEY_READ);

    if(dwRet == ERROR_SUCCESS)
    {
        if(reg.GetCurrentKeyValue(
            L"DefaultUserProfile", 
            chstrTemp) == ERROR_SUCCESS)
        {
            chstrDefaultUsersName = chstrTemp.SpanExcluding(L".");
            fRet = true;
        }
    }
    if(!fRet)
    {
        chstrDefaultUsersName = L"";
    }

    return fRet;
}
#endif


#if NTONLY >= 5
bool GetCommonStartup(CHString& chstrCommonStartup)
{
    bool fRet = false;
    CRegistry reg;
    CHString chstrTemp;

    DWORD dwRet = reg.Open(
		HKEY_LOCAL_MACHINE,
		L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		KEY_READ);

    if(dwRet == ERROR_SUCCESS)
    {
        if(reg.GetCurrentKeyValue(
            L"Common Startup", 
            chstrTemp) == ERROR_SUCCESS)
        {
            int iPos = chstrTemp.ReverseFind(L'\\');
            if(iPos != -1)
            {
                chstrCommonStartup = chstrTemp.Mid(iPos+1);
                fRet = true;
            }
        }
    }
    if(!fRet)
    {
        chstrCommonStartup = L"";
    }

    return fRet;
}
#endif

BOOL GetLocalizedNTAuthorityString(
    CHString& chstrNT_AUTHORITY)
{
    BOOL fRet = false;
    SID_IDENTIFIER_AUTHORITY siaNTSidAuthority = SECURITY_NT_AUTHORITY;
    CSid csidAccountSid;
    
    if(GetSysAccountNameAndDomain(
        &siaNTSidAuthority, 
        csidAccountSid, 
        1, 
        SECURITY_NETWORK_SERVICE_RID))
    {
        chstrNT_AUTHORITY = csidAccountSid.GetDomainName();
        fRet = TRUE;
    }

    return fRet;
}

BOOL GetLocalizedBuiltInString(
    CHString& chstrBuiltIn)
{
    BOOL fRet = false;
    SID_IDENTIFIER_AUTHORITY siaNTSidAuthority = SECURITY_NT_AUTHORITY;
    CSid csidAccountSid;
    
    if(GetSysAccountNameAndDomain(
        &siaNTSidAuthority, 
        csidAccountSid, 
        1, 
        SECURITY_BUILTIN_DOMAIN_RID))
    {
        chstrBuiltIn = csidAccountSid.GetDomainName();
        fRet = TRUE;
    }

    return fRet;
}

BOOL GetSysAccountNameAndDomain(
    PSID_IDENTIFIER_AUTHORITY a_pAuthority,
    CSid& a_accountsid,
    BYTE  a_saCount /*=0*/,
    DWORD a_dwSubAuthority1 /*=0*/,
    DWORD a_dwSubAuthority2 /*=0*/  )
{
	BOOL t_fReturn = FALSE;
	PSID t_psid = NULL;

	if ( AllocateAndInitializeSid(	a_pAuthority,
									a_saCount,
									a_dwSubAuthority1,
									a_dwSubAuthority2,
									0,
									0,
									0,
									0,
									0,
									0,
									&t_psid ) )
	{
	    try
	    {
			CSid t_sid( t_psid ) ;

			// The SID may be valid in this case, however the Lookup may have failed
			if ( t_sid.IsValid() && t_sid.IsOK() )
			{
				a_accountsid = t_sid;
				t_fReturn = TRUE;
			}

	    }
	    catch( ... )
	    {
		    if( t_psid )
		    {
			    FreeSid( t_psid ) ;
		    }
		    throw ;
	    }

		// Cleanup the sid
		FreeSid( t_psid ) ;
	}

	return t_fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllwrapperbase.cpp ===
//=================================================================

//

// DllWrapperBase.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "DllWrapperBase.h"
#include <..\..\framework\provexpt\include\provexpt.h>






/******************************************************************************
 * Constructor
 ******************************************************************************/
CDllWrapperBase::CDllWrapperBase(LPCTSTR a_tstrWrappedDllName)
 : m_tstrWrappedDllName(a_tstrWrappedDllName),
   m_hDll(NULL)
{

}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CDllWrapperBase::~CDllWrapperBase()
{
    if(m_hDll != NULL)
	{
	    FreeLibrary(m_hDll);
	}
}


/******************************************************************************
 * Initialization function to load the dll, obtain function addresses, and
 * check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 ******************************************************************************/
// bool CDllWrapperBase::Init()
// << PURE VIRTUAL FUNCTION -> DERIVED CLASSES MUST OVERLOAD.



/******************************************************************************
 * Helper for loading the dll that hides the implementation.  Returns true
 * if we succeeded in obtaining a handle to the dll.
 ******************************************************************************/
bool CDllWrapperBase::LoadLibrary()
{
    bool t_fRet = false;
    if(m_hDll != NULL)
    {
        FreeLibrary(m_hDll);
    }
    if((m_hDll = ::LoadLibrary(m_tstrWrappedDllName)) != NULL)
    {
        t_fRet = true;
    }
    else
    {
		// this is possible to be neccessary in the future !!!
		// resource manager may start to care about error from load library
		//
		// let resource manager know load failed
		//
		m_bValid = FALSE;
		m_dwCreationError = ::GetLastError ();

        LogErrorMessage2(L"Failed to load library: %s", m_tstrWrappedDllName);
    }

    return t_fRet;
}


/******************************************************************************
 * Helper for getting proc addresses that hides the implementation.
 ******************************************************************************/
FARPROC CDllWrapperBase::GetProcAddress(LPCSTR a_strProcName)
{
    FARPROC t_fpProc = NULL;
    if(m_hDll != NULL)
    {
        t_fpProc = ::GetProcAddress(m_hDll, a_strProcName);
    }
    return t_fpProc;
}

/******************************************************************************
 * Helper for retrieving the version of the dll wrapped by this class.
 ******************************************************************************/
BOOL CDllWrapperBase::GetDllVersion(CHString& a_chstrVersion)
{
    return (GetVarFromVersionInfo(
             m_tstrWrappedDllName,   // Name of file to get ver info about
             _T("ProductVersion"),   // String identifying resource of interest
             a_chstrVersion));       // Buffer to hold version string
}


/******************************************************************************
 * Member functions wrapping Kernel32 api functions. Add new functions here
 * as required.
 ******************************************************************************/

// << Section empty in base class only. >>


/******************************************************************************
 * Private parts.
 ******************************************************************************/
BOOL CDllWrapperBase::GetVarFromVersionInfo
(
    LPCTSTR a_szFile,
    LPCTSTR a_szVar,
    CHString &a_strValue
)
{
	BOOL    t_fRc = FALSE;
	DWORD   t_dwTemp;
    DWORD   t_dwBlockSize = 0L;
	LPVOID  t_pInfo = NULL;

	// Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        t_dwBlockSize = ::GetFileVersionInfoSize((LPTSTR) a_szFile, &t_dwTemp);

	    if (t_dwBlockSize)
        {
		    t_pInfo = (LPVOID) new BYTE[t_dwBlockSize + 4];

			if ( !t_pInfo )
           	{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			UINT t_len;

			memset( t_pInfo, NULL, t_dwBlockSize + 4);

			if (::GetFileVersionInfo((LPTSTR) a_szFile, 0, t_dwBlockSize, t_pInfo))
            {
				WORD wLang = 0;
				WORD wCodePage = 0;
				if(!GetVersionLanguage(t_pInfo, &wLang, &wCodePage) )
				{
					// on failure: default to English

					// this returns a pointer to an array of WORDs
					WORD *pArray;
                    bool fGotTranslation = false;

					fGotTranslation = ::VerQueryValue(
                        t_pInfo, _T("\\VarFileInfo\\Translation"),
                        (void **)(&pArray), 
                        &t_len);
                    
                    if(fGotTranslation)
					{
						t_len = t_len / sizeof(WORD);

						// find the english one...
						for (int i = 0; i < t_len; i += 2)
						{
							if( pArray[i] == 0x0409 )	{
								wLang	  = pArray[i];
								wCodePage = pArray[i + 1];
								break;
							}
						}
					}
				}

				TCHAR   *pMfg, szTemp[256];
                StringCchPrintf(szTemp,LENGTH_OF(szTemp), _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, a_szVar);
                bool fGotCodePageInfo = false;

                fGotCodePageInfo = ::VerQueryValue(
                    t_pInfo, 
                    szTemp, (void **)
                    (&pMfg), 
                    &t_len);

                if(fGotCodePageInfo)
                {
                    a_strValue = pMfg;
					t_fRc = TRUE;
				}
			}

			delete t_pInfo;
			t_pInfo = NULL ;
	    }

    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo()); 
        if (t_pInfo)
		{
			delete t_pInfo ;
		}
        t_fRc = FALSE;   
    }
    catch(...)
    {
        if (t_pInfo)
		{
			delete t_pInfo ;
		}
		throw ;
    }

    return t_fRc;
}


BOOL CDllWrapperBase::GetVersionLanguage
(
    void *a_vpInfo,
    WORD *a_wpLang,
    WORD *a_wpCodePage
)
{
    WORD *t_wpTemp;
    WORD t_wLength;
    WCHAR *t_wcpTemp;
    char *t_cpTemp;
    BOOL t_bRet = FALSE;

    t_wpTemp = (WORD *) a_vpInfo;
    t_cpTemp = (char *) a_vpInfo;

    t_wpTemp++; // jump past buffer length.
    t_wLength = *t_wpTemp;  // capture value length.
    t_wpTemp++; // skip past value length to what should be type code in new format
    if (*t_wpTemp == 0 || *t_wpTemp == 1) // new format expect unicode strings.
    {
		t_cpTemp = t_cpTemp + 38 + t_wLength + 8;
		t_wcpTemp = (WCHAR *) t_cpTemp;
        if (wcscmp(L"StringFileInfo", t_wcpTemp) == 0) // OK! were aligned properly.
        {
			t_bRet = TRUE;

			t_cpTemp += 30; // skip over "StringFileInfo"
			while ((DWORD_PTR) t_cpTemp % 4 > 0) // 32 bit align
				t_cpTemp++;

			t_cpTemp += 6; // skip over length and type fields.

			t_wcpTemp = (WCHAR *) t_cpTemp;
			swscanf(t_wcpTemp, L"%4x%4x", a_wpLang, a_wpCodePage);
        }
    }
    else  // old format, expect single byte character strings.
    {
        t_cpTemp += 20 + t_wLength + 4;
        if (strcmp("StringFileInfo", t_cpTemp) == 0) // OK! were aligned properly.
        {
			t_bRet = TRUE;

			t_cpTemp += 20; // skip over length fields.
			sscanf(t_cpTemp, "%4x%4x", a_wpLang, a_wpCodePage);
        }
    }
	return (t_bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllwrappercreatorreg.h ===
//=================================================================
//
// DllWrapperCreatorReg.h
//
// Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "ResourceManager.h"
#include <ProvExce.h>

//
// resource management failures
//
extern BOOL bAddInstanceCreatorFailure ;

/******************************************************************************
 * Register this class with the CResourceManager. 
 *****************************************************************************/
 
template<class a_T, const GUID* a_pguidT, const TCHAR* a_ptstrDllName>
class CDllApiWraprCreatrReg 
{
public:
	CDllApiWraprCreatrReg()
    {
		try
		{
			BOOL bNonFailure = 
	        CResourceManager::sm_TheResourceManager.AddInstanceCreator(*a_pguidT, ApiWraprCreatrFn);

			if ( FALSE == bNonFailure )
			{
				bAddInstanceCreatorFailure = TRUE ;
			}
		}
		catch ( CHeap_Exception& e_HE )
		{
			bAddInstanceCreatorFailure = TRUE ;
		}
    }

	~CDllApiWraprCreatrReg(){}

	static CResource* ApiWraprCreatrFn
    (
        PVOID pData
    )
    {
        a_T* t_pT = NULL ;
		
		if( !(t_pT = (a_T*) new a_T(a_ptstrDllName) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

        try
		{
			if( t_pT->Init() )
            {
                return t_pT ;
            }
            else
            {
				delete t_pT ;
                return NULL ;
            }
        }
        catch( ... )
	    {
       		delete t_pT ;
			throw ; 
	    }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllwrapperbase.h ===
//=================================================================

//

// DllWrapperBase.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_DLLWRAPPERBASE_H_
#define	_DLLWRAPPERBASE_H_


#include "ResourceManager.h"
#include "TimedDllResource.h"



/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

 // << section empty in base class only>>


/******************************************************************************
 * Wrapper class to load/unload, for registration with ResourceManager. 
 ******************************************************************************/
class CDllWrapperBase : public CTimedDllResource
{
private:
    // Member variables (function pointers) pointing to dll procs.
    // Add new functions here as required.
    
    BOOL GetVarFromVersionInfo(LPCTSTR a_szFile, 
                               LPCTSTR a_szVar, 
                               CHString &a_strValue);

    BOOL GetVersionLanguage(void *a_vpInfo, WORD *a_wpLang, WORD *a_wpCodePage);

    HINSTANCE m_hDll;                // handle to the dll this class wraps
    LPCTSTR m_tstrWrappedDllName;    // name of dll this class wraps

protected:
    
    // Handy wrapers to simplify calls and hide m_hDll...
    bool LoadLibrary();
    FARPROC GetProcAddress(LPCSTR a_strProcName);

public:

    // Constructor and destructor:
    CDllWrapperBase(LPCTSTR a_chstrWrappedDllName);
    ~CDllWrapperBase();

    // Initialization function to check function pointers. Requires derived
    // class implementation.
    virtual bool Init() = 0;

    // Helper for retrieving the version.
    BOOL GetDllVersion(CHString& a_chstrVersion);

        
      
    
    // Member functions wrapping dll procs.
    // Add new functions here as required:
    
    // << section empty in base class only >>
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dllutils.h ===
//=================================================================

//

// DllUtils.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _DLL_UTILS_H_
#define _DLL_UTILS_H_

#define UNRECOGNIZED_VARIANT_TYPE FALSE

#include "DllWrapperBase.h"

#ifdef WIN9XONLY
    #include "Cim32NetApi.h"
#endif

#include "sid.h"
#include <list>

#ifdef UNICODE
#define W2A(w, a, cb)     lstrcpynW ( a, w, cb / sizeof ( WCHAR ) )
#define TOBSTRT(x)        x
#else
#define W2A(w, a, cb)     WideCharToMultiByte(                              \
                                               CP_ACP,                      \
                                               0,                           \
                                               w,                           \
                                               -1,                          \
                                               a,                           \
                                               cb,                          \
                                               NULL,                        \
                                               NULL)
#define TOBSTRT(x)        _bstr_t(x)
#endif

#define VWIN32_DIOC_DOS_IOCTL 1
#define VWIN32_DIOC_DOS_INT13 4
#define VWIN32_DIOC_DOS_DRIVEINFO 6

#define CARRY_FLAG  0x1

#define MAXITOA 18
#define MAXI64TOA 33

// In theory, this is defined in winnt.h, but not in our current one
#ifndef FILE_ATTRIBUTE_ENCRYPTED
#define FILE_ATTRIBUTE_ENCRYPTED        0x00000040 
#endif

typedef std::list<CHString> CHStringList;
typedef std::list<CHString>::iterator CHStringList_Iterator;

// To Get Cim32NetApi

#ifdef WIN9XONLY
CCim32NetApi* WINAPI GetCim32NetApiPtr();
void WINAPI FreeCim32NetApiPtr();
#endif

// platform identification
DWORD WINAPI GetPlatformMajorVersion(void);
DWORD WINAPI GetPlatformMinorVersion(void);
DWORD WINAPI GetPlatformBuildNumber(void);
#ifdef WIN9XONLY
bool WINAPI IsWin95(void);
bool WINAPI IsWin98(void);
bool WINAPI IsMillennium(void);
#endif
#ifdef NTONLY
bool WINAPI IsWinNT52(void);
bool WINAPI IsWinNT51(void);
bool WINAPI IsWinNT5(void);
bool WINAPI IsWinNT351(void);  
bool WINAPI IsWinNT4(void);    
#endif

// error logging
void WINAPI LogEnumValueError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey, LPCWSTR szId );
void WINAPI LogOpenRegistryError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey );
void WINAPI LogError( LPCTSTR szFile, DWORD dwLine, LPCTSTR szKey );
void WINAPI LogLastError( LPCTSTR szFile, DWORD dwLine );

class CConfigMgrDevice;
class CInstance;

void WINAPI SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance);

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WINAPI WinErrorToWBEMhResult(LONG error);

#pragma pack(push, 1)
typedef struct _DEVIOCTL_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

typedef struct  BPB { /* */
   WORD wBytesPerSector;      // Bytes per sector
   BYTE btSectorsPerCluster;  // Sectors per cluster
   WORD wReservedSectors;     // Number of reserved sectors
   BYTE btNumFats;            // Number of FATs
   WORD wEntriesInRoot;       // Number of root-directory entries
   WORD wTotalSectors;        // Total number of sectors
   BYTE btMediaIdByte;        // Media descriptor
   WORD wSectorsPerFat;       // Number of sectors per FAT
   WORD wSectorsPerTrack;     // Number of sectors per track
   WORD wHeads;               // Number of heads
   DWORD dwHiddenSecs;        // Number of hidden sectors
   DWORD dwSectorsPerTrack;   // Number of sectors if wTotalSectors == 0
} BPB, *PBPB;

typedef struct _DEVICEPARMS {
   BYTE btSpecialFunctions;   // Special functions
   BYTE btDeviceType;         // Device type
   WORD wDeviceAttribs;       // Device attributes
   WORD wCylinders;           // Number of cylinders
   BYTE btMediaType;          // Media type
                        // Beginning of BIOS parameter block (BPB)
   BPB stBPB;
   BYTE  reserved[6];       //
} DEVICEPARMS, *PDEVICEPARMS;

typedef struct _A_BF_BPB {
    BPB stBPB;

    USHORT A_BF_BPB_BigSectorsPerFat;   /* BigFAT Fat sectors        */
    USHORT A_BF_BPB_BigSectorsPerFatHi; /* High word of BigFAT Fat sectrs  */
    USHORT A_BF_BPB_ExtFlags;           /* Other flags           */
    USHORT A_BF_BPB_FS_Version;         /* File system version       */
    USHORT A_BF_BPB_RootDirStrtClus;    /* Starting cluster of root directory */
    USHORT A_BF_BPB_RootDirStrtClusHi;  
    USHORT A_BF_BPB_FSInfoSec;          /* Sector number in the reserved   */
                                        /* area where the BIGFATBOOTFSINFO */
                                        /* structure is. If this is >=     */
                                        /* oldBPB.BPB_ReservedSectors or   */
                                        /* == 0 there is no FSInfoSec      */
    USHORT A_BF_BPB_BkUpBootSec;        /* Sector number in the reserved   */
                                        /* area where there is a backup    */
                                        /* copy of all of the boot sectors */
                                        /* If this is >=           */
                                        /* oldBPB.BPB_ReservedSectors or   */
                                        /* == 0 there is no backup copy.   */
    USHORT A_BF_BPB_Reserved[6];        /* Reserved for future expansion   */
} A_BF_BPB, *PA_BF_BPB;

#define MAX_SECTORS_IN_TRACK        128 // MAXIMUM SECTORS ON A DISK.

typedef struct A_SECTORTABLE  {
    WORD ST_SECTORNUMBER;
    WORD ST_SECTORSIZE;
} A_SECTORTABLE;

typedef struct _EA_DEVICEPARAMETERS {
    BYTE btSpecialFunctions;   // Special functions
    BYTE btDeviceType;         // Device type
    WORD wDeviceAttribs;       // Device attributes
    WORD dwCylinders;         // Number of cylinders
    BYTE btMediaType;          // Media type
    A_BF_BPB stBPB32;           // Fat32 Bios parameter block
    BYTE RESERVED1[32];
    WORD EDP_TRACKTABLEENTRIES;
    A_SECTORTABLE stSectorTable[MAX_SECTORS_IN_TRACK];
} EA_DEVICEPARAMETERS, *PEA_DEVICEPARAMETERS;

typedef struct _DRIVE_MAP_INFO {
   BYTE btAllocationLength;
   BYTE btInfoLength;
   BYTE btFlags;
   BYTE btInt13Unit;
   DWORD dwAssociatedDriveMap;
   __int64 i64PartitionStartRBA;
} DRIVE_MAP_INFO, *PDRIVE_MAP_INFO;

typedef struct _ExtGetDskFreSpcStruc {
    WORD Size;                      // Size of structure (out)
    WORD Level;                     // Level (must be zero)
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD AvailableClusters;
    DWORD TotalClusters;
    DWORD AvailablePhysSectors;
    DWORD TotalPhysSectors;
    DWORD AvailableAllocationUnits;
    DWORD TotalAllocationUnits;
    DWORD Rsvd1;
    DWORD Rsvd2;
} ExtGetDskFreSpcStruc, *pExtGetDskFreSpcStruc;

#pragma pack(pop)


BOOL LoadStringW(CHString &sString, UINT nID);
void Format(CHString &sString, UINT nFormatID, ...);
void FormatMessageW(CHString &sString, UINT nFormatID, ...);
int LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf);


#ifdef WIN9XONLY
BOOL WINAPI GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive);
BOOL WINAPI GetDeviceParmsFat32(PEA_DEVICEPARAMETERS  pstDeviceParms, UINT nDrive);
BOOL WINAPI GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive);
BOOL WINAPI VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall);
BYTE WINAPI GetBiosUnitNumberFromPNPID(CHString strDeviceID);
#endif

#ifdef NTONLY
void WINAPI TranslateNTStatus( DWORD dwStatus, CHString & chsValue);
BOOL WINAPI GetServiceFileName(LPCTSTR szService, CHString &strFileName);
bool WINAPI GetServiceStatus( CHString a_chsService,  CHString &a_chsStatus ) ;
#endif

void WINAPI ConfigStatusToCimStatus ( DWORD a_Status , CHString &a_StringStatus ) ;

CHString WINAPI GetFileTypeDescription(LPCTSTR szExtension);
bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);

bool WINAPI GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg);
bool WINAPI GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion);

BOOL WINAPI EnablePrivilegeOnCurrentThread(LPCTSTR szPriv);

bool WINAPI GetFileInfoBlock(LPCTSTR szFile, LPVOID *pInfo);
bool WINAPI GetVarFromInfoBlock(LPVOID pInfo, LPCTSTR szVar, CHString &strValue);
BOOL WINAPI GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage);

BOOL WINAPI Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc);

HRESULT WINAPI GetHKUserNames(CHStringList &list);  

VOID WINAPI EscapeBackslashes(CHString& chstrIn, CHString& chstrOut);
VOID WINAPI EscapeQuotes(CHString& chstrIn, CHString& chstrOut);
VOID WINAPI RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut);
CHString WINAPI RemoveDoubleBackslashes(const CHString& chstrIn);

void WINAPI SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege);

bool WINAPI StrToIdentifierAuthority(const CHString& str, SID_IDENTIFIER_AUTHORITY& identifierAuthority);
bool WINAPI WhackToken(CHString& str, CHString& token);
PSID WINAPI StrToSID(const CHString& str);

#ifdef WIN9XONLY
class HoldSingleCim32NetPtr
{
public:
    HoldSingleCim32NetPtr();
    ~HoldSingleCim32NetPtr();
    static void WINAPI FreeCim32NetApiPtr();
    static CCim32NetApi* WINAPI GetCim32NetApiPtr();
private:
    static CCritSec m_csCim32Net;
    static HINSTANCE m_spCim32NetApiHandle ; 
};
#endif



// Used to get WBEM time from a filename.  We need this because FAT and NTFS 
// work differently.
enum FT_ENUM
{
    FT_CREATION_DATE,
    FT_MODIFIED_DATE,
    FT_ACCESSED_DATE
};

CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FILETIME *pFileTime);
CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FT_ENUM ftWhich);
CHString WINAPI GetDateTimeViaFilenameFiletime(BOOL bNTFS, FILETIME *pFileTime);


// Used to validate a numbered device ID is OK.
// Example: ValidateNumberedDeviceID("VideoController7", "VideoController", pdwWhich)
//          returns TRUE, pdwWhich = 7.
// Example: ValidateNumberedDeviceID("BadDeviceID", "VideoController", pdwWhich)
//          returns FALSE, pdwWhich unchanged
BOOL WINAPI ValidateNumberedDeviceID(LPCWSTR szDeviceID, LPCWSTR szTag, DWORD *pdwWhich);


// Critical sections used by various classes.
extern CCritSec g_csPrinter;
extern CCritSec g_csSystemName;
#ifdef WIN9XONLY
extern CCritSec g_csVXD;
#endif

bool WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep); 


#ifdef NTONLY
HRESULT CreatePageFile(
    LPCWSTR wstrPageFileName,
    const LARGE_INTEGER liInitial,
    const LARGE_INTEGER liMaximum,
    const CInstance& Instance);
#endif



#if NTONLY >= 5
bool GetAllUsersName(CHString& chstrAllUsersName);
bool GetDefaultUsersName(CHString& chstrDefaultUsersName);
bool GetCommonStartup(CHString& chstrCommonStartup);
#endif

BOOL GetLocalizedNTAuthorityString(
    CHString& chstrNT_AUTHORITY);

BOOL GetLocalizedBuiltInString(
    CHString& chstrBuiltIn);

BOOL GetSysAccountNameAndDomain(
    PSID_IDENTIFIER_AUTHORITY a_pAuthority,
    CSid& a_accountsid,
    BYTE  a_saCount = 0,
    DWORD a_dwSubAuthority1 = 0,
    DWORD a_dwSubAuthority2 = 0);

// neccessary structures for GetFileVersionInfo
#include <pshpack4.h>

typedef struct tag_StringTable { 
	WORD	wLength; 
	WORD	wValueLength; 
	WORD	wType; 
	WCHAR	szKey[8]; 
} StringTable; 

typedef struct tag_StringFileInfo { 
	WORD		wLength; 
	WORD		wValueLength; 
	WORD		wType; 
	WCHAR		szKey[ sizeof("StringFileInfo") ]; 
	StringTable	Children; 
} StringFileInfo ; 

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dmadesc.cpp ===
//=================================================================

//

// DmaDesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "dmadesc.h"

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::CDMADescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMADescriptor::CDMADescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::CDMADescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				DMA_DES					dmaDes - DMA Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMADescriptor::CDMADescriptor(	DWORD				dwResourceId,
							    DMA_DES&				dmaDes,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &dmaDes, sizeof(DMA_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_DMA == GetResourceType() );
}

// Copy Constructor
CDMADescriptor::CDMADescriptor( const CDMADescriptor& dma )
: CResourceDescriptor( dma )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::~CDMADescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMADescriptor::~CDMADescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::GetResource
//
//	Returns a string representation of the associated Device Memory
//	Address.
//
//	Inputs:		None.
//
//	Outputs:	CString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////

void *CDMADescriptor::GetResource()
{

	if ( NULL != m_pbResourceDescriptor ){
		// Cast to a DMA Descriptor, and place it's channel value in the
		// string

		PDMA_DES	pDMA = (PDMA_DES) m_pbResourceDescriptor;
        return pDMA;
	}

	return NULL;
}

//
//	Constructor and Destructor for the DMA Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMACollection::CDMACollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMACollection::CDMACollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMACollection::~CDMACollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMACollection::~CDMACollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\dmadesc.h ===
//=================================================================

//

// dmadesc.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __DMADESC_H__
#define __DMADESC_H__

class 
__declspec(uuid("571D3186-D45D-11d2-B35E-00104BC97924"))
CDMADescriptor : public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CDMADescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CDMADescriptor(	DWORD dwResourceId, DMA_DES& dmaDes, CConfigMgrDevice* pOwnerDevice );
	CDMADescriptor(	const CDMADescriptor& dma );
	~CDMADescriptor();

	DWORD GetFlags( void );
	ULONG GetChannel( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CDMADescriptor, __uuidof(CDMADescriptor));

inline DWORD CDMADescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PDMA_DES) m_pbResourceDescriptor)->DD_Flags : 0 );
}

inline DWORD CDMADescriptor::GetChannel( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PDMA_DES) m_pbResourceDescriptor)->DD_Alloc_Chan : 0 );
}

// A collection of DMA Descriptors
class CDMACollection : public TRefPtr<CDMADescriptor>
{
public:

	// Construction/Destruction
	CDMACollection();
	~CDMACollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CDMACollection& operator = ( const CDMACollection& srcCollection );

};

inline const CDMACollection& CDMACollection::operator = ( const CDMACollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\eventprovider.cpp ===
//=================================================================

//

// EventProvider.cpp -- Generic class for eventing

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "FactoryRouter.h"
#include "EventProvider.h"


extern CFactoryRouterData g_FactoryRouterData;
//=================================================================
//
// CEventProvider
//
// abstract base for providing eventing services 
//
//
//=================================================================
//
CEventProvider::CEventProvider() :

m_ReferenceCount( 0 )
{
	g_FactoryRouterData.AddLock();
}

//
CEventProvider::~CEventProvider()
{
    // m_pHandler is a smartptr and will self destruct
    // m_pClass is a smartptr and will self destruct
	g_FactoryRouterData.ReleaseLock();
}

//
STDMETHODIMP_( ULONG ) CEventProvider::AddRef()
{
LogMessage2(L"*************CEventProvider AddRef: %ld",m_ReferenceCount+1 );
	return InterlockedIncrement( &m_ReferenceCount ) ;
}

//
STDMETHODIMP_(ULONG) CEventProvider::Release()
{
LogMessage2(L"*************CEventProvider AddRef: %ld",m_ReferenceCount-1 );
	LONG t_ref = InterlockedDecrement( &m_ReferenceCount );

	try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage2(L"CEventProvider::Release, count is (approx) %d", m_ReferenceCount);
        }
    }
    catch ( ... )
    {
    }

	if ( t_ref == 0 )
	{

	   try
       {
			LogMessage(L"CFactoryRouter Ref Count = 0");
       }
       catch ( ... )
       {
	   }
       OnFinalRelease();
	}
	else if (t_ref > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
		LogErrorMessage(L"Duplicate CFactoryRouter Release()");
    }

	return t_ref ;
}

//
STDMETHODIMP CEventProvider::QueryInterface( 
											 
REFIID a_riid,
LPVOID FAR *a_ppvObj
)
{
    if( IsEqualIID( a_riid, IID_IUnknown ) )
    {
        *a_ppvObj = static_cast<IWbemProviderInit *>(this) ;
    }
	else if( IsEqualIID( a_riid, IID_IWbemProviderInit ) )
    {
        *a_ppvObj = static_cast<IWbemProviderInit *>(this) ;
    }
	else if( IsEqualIID( a_riid, IID_IWbemEventProvider ) )
    {
        *a_ppvObj = static_cast<IWbemEventProvider *>(this) ;
    }	
    else
    {
		*a_ppvObj = NULL ;        

        return E_NOINTERFACE ;
    }

	AddRef() ;
	return NOERROR ;
}

//
STDMETHODIMP CEventProvider::Initialize(

LPWSTR					a_wszUser,
long					a_lFlags, 
LPWSTR					a_wszNamespace,
LPWSTR					a_wszLocale, 
IWbemServices			*a_pNamespace, 
IWbemContext			*a_pCtx,
IWbemProviderInitSink	*a_pSink 
)
{
	
    IWbemClassObjectPtr t_pClass ;

    bstr_t bstrClassName(GetClassName(), false);

    HRESULT t_hRes = a_pNamespace->GetObject(	bstrClassName,
												0,
												a_pCtx, 
												&t_pClass,
												NULL ) ;
	
	// ptr initialization routines
	SetClass( t_pClass ) ;

	return a_pSink->SetStatus( t_hRes, 0 ) ;
    
}

//
STDMETHODIMP CEventProvider::ProvideEvents(

IWbemObjectSink __RPC_FAR *a_pSink,
long a_lFlags 
)
{
  	SetHandler( a_pSink ) ;

	// notify instance
	ProvideEvents() ;

	return S_OK ;
}

//
void CEventProvider::SetClass(

IWbemClassObject __RPC_FAR *a_pClass
) 
{ 
    CInCritSec ics( &m_cs ) ;

    m_pClass = a_pClass ; 
}

//
IWbemClassObject __RPC_FAR * CEventProvider::GetClass()
{

    CInCritSec ics(&m_cs ) ;

    IWbemClassObject __RPC_FAR *t_pClass ;    
    m_pClass->AddRef() ;
    t_pClass = m_pClass ;
    return t_pClass ;
}

//
void CEventProvider::SetHandler(

IWbemObjectSink __RPC_FAR *a_pHandler 
) 
{ 
    CInCritSec ics(&m_cs ) ;
    
    m_pHandler = a_pHandler ; 
}

//
IWbemObjectSink __RPC_FAR * CEventProvider::GetHandler()
{
    IWbemObjectSink __RPC_FAR *t_pHandler ;

    CInCritSec ics(&m_cs );

    m_pHandler->AddRef();
    t_pHandler = m_pHandler ;
    return t_pHandler ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\eventprovider.h ===
//=================================================================

//

// EventProvider.h -- Generic class for eventing

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _EVENT_PROVIDER_H
#define _EVENT_PROVIDER_H

//
class CEventProvider : 
	public IWbemProviderInit,
	public IWbemEventProvider 
{
	private:

		long m_ReferenceCount ;	

		IWbemObjectSinkPtr			m_pHandler ;
		IWbemClassObjectPtr			m_pClass ;
		CCritSec			m_cs ;		

		// sink management
		void SetHandler( IWbemObjectSink __RPC_FAR *a_pHandler ) ;
		
		// class management
		void SetClass( IWbemClassObject __RPC_FAR *a_pClass ) ;

	protected:
	public:

		CEventProvider() ;
		~CEventProvider() ;

		STDMETHOD(QueryInterface)( REFIID a_riid, void **a_ppv ) ;
		STDMETHODIMP_( ULONG ) AddRef() ;
		STDMETHODIMP_( ULONG ) Release() ;
      
        STDMETHOD(ProvideEvents)(	IWbemObjectSink __RPC_FAR *a_pSink,
									long a_lFlags ) ;

		STDMETHOD (Initialize)(	LPWSTR					a_wszUser, 
								long					a_lFlags, 
								LPWSTR					a_wszNamespace,
								LPWSTR					a_wszLocale,
								IWbemServices			*a_pNamespace, 
								IWbemContext			*a_pCtx,
								IWbemProviderInitSink	*a_pSink ) ;
		
		
		// sink retrieval
		IWbemObjectSink __RPC_FAR * GetHandler() ;

		// class retrieval
		IWbemClassObject __RPC_FAR * GetClass() ;
		IWbemClassObject __RPC_FAR * GetInstance() ;

		// implementor must supply the class name
		virtual BSTR GetClassName() = 0 ;

        // implementor must supply this function.  Normally, it will be
        // one line: delete this;
        virtual void OnFinalRelease() = 0;

		// notification to begin eventing 
		virtual void ProvideEvents() = 0 ;
};

#endif // _EVENT_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\fileattributes.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// File attributes helper class.




#include <precomp.h>
#include <assertbreak.h>

class CFileAttributes
{
    public:

        CFileAttributes(
            LPCWSTR wstrFileName,
            bool fAutoRevert = true)
          :
          m_fAutoRevert(fAutoRevert),
          m_dwOldFileAttributes(static_cast<DWORD>(-1L))
        {
            m_chstrFileName = wstrFileName;
            if(m_fAutoRevert)
            {
                m_dwOldFileAttributes = ::GetFileAttributes(m_chstrFileName);
            }
        }

        CFileAttributes(const CFileAttributes& cfa)
        {
            m_chstrFileName = cfa.m_chstrFileName;
            m_fAutoRevert = cfa.m_fAutoRevert;
            m_dwOldFileAttributes = cfa.m_dwOldFileAttributes;   
        }

        virtual ~CFileAttributes() 
        {
            if(m_fAutoRevert)
            {
                if(!ResetAttributes())
                {
                    ASSERT_BREAK(0);
                    LogErrorMessage2(
                        L"Could not reset file attributes on file %s",
                        m_chstrFileName);
                }
            }
        }

        DWORD GetAttributes(DWORD* pdw)
        {
            DWORD dwRet = ERROR_SUCCESS;
            DWORD dwTemp = ::GetFileAttributes(m_chstrFileName);
            
            if(pdw)
            {
                *pdw = 0L;
                if(dwTemp != -1L)
                {
                    *pdw = dwTemp;
                }
                else
                {
                    dwRet = ::GetLastError();
                }
            }
            else
            {
                dwRet = ERROR_INVALID_PARAMETER;
            }
                   
            return dwRet;
        }

        DWORD SetAttributes(DWORD dwAttributes)
        {
            DWORD dwRet = E_FAIL;
            DWORD dwTemp = ::GetFileAttributes(m_chstrFileName);

            if(dwTemp != -1L)
            {
                m_dwOldFileAttributes = dwTemp;
                if(::SetFileAttributes(
                    m_chstrFileName,
                    dwAttributes))
                {
                    dwRet = ERROR_SUCCESS;
                }
                else
                {
                    dwRet = ::GetLastError();
                }
            }
            else
            {
                dwRet = ::GetLastError();
            }
                   
            return dwRet;
        }

        BOOL ResetAttributes()
        {
            BOOL fResult = FALSE;
            if(m_dwOldFileAttributes != static_cast<DWORD>(-1L))
            {
                fResult = ::SetFileAttributes(
                m_chstrFileName,
                m_dwOldFileAttributes);
            }
            return fResult;
        }


    private:

        CHString m_chstrFileName;
        bool m_fAutoRevert;
        DWORD m_dwOldFileAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\factoryrouter.h ===
//=================================================================

//

// FactoryRouter.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _WMI_FACTORY_ROUTER_H
#define _WMI_FACTORY_ROUTER_H

#include <cautolock.h>
//=================================================================================
//  This is the router factory
//=================================================================================
class CFactoryRouter :	public IClassFactory
{
	private:
		DWORD		m_Register;
		GUID		m_ClsId; 
		CHString	m_sDescription;

	public:

		CFactoryRouter ( REFGUID a_rClsId, LPCWSTR a_pClassName ) ;
		~CFactoryRouter () ;

		//IUnknown members
		STDMETHODIMP QueryInterface( REFIID , LPVOID FAR * ) ;
		STDMETHODIMP_( ULONG ) AddRef() ;
		STDMETHODIMP_( ULONG ) Release() ;
		
		//IClassFactory members
		STDMETHODIMP CreateInstance( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
		STDMETHODIMP LockServer( BOOL ) ;
	
		static void ClsToString( CHString &a_chsClsId, REFGUID a_rClsId ) ;

		REFGUID GetClsId();
		LPCWSTR GetClassDescription();
		DWORD	GetRegister();
		void	SetRegister( DWORD a_dwRegister );

		// pure virtuals
		virtual IUnknown * CreateInstance (	REFIID a_riid ,	LPVOID FAR *a_ppvObject	) = 0 ;
};
//=================================================================================
//  There is only one global instance of this class to manage all of the data
//  from the CFactoryRouter guys
//=================================================================================
class CFactoryRouterData
{
	private:
		typedef std::map<CHString, CFactoryRouter*> Factory_Map ;
		Factory_Map	mg_oFactoryMap ;
		CCriticalSec m_cs;
		LONG s_LocksInProgress ;
		LONG s_ObjectsInProgress ;
		long m_ReferenceCount ;

	public:
		CFactoryRouterData();
		~CFactoryRouterData();

		void AddToMap( REFGUID a_rClsId, CFactoryRouter * pFactory ) ;  
		void AddLock();
		void ReleaseLock();
		STDMETHODIMP_( ULONG ) AddRef() ;
		STDMETHODIMP_( ULONG ) Release() ;


		// dll level interfaces
		BOOL DllCanUnloadNow() ;
		HRESULT DllGetClassObject( REFCLSID rclsid, REFIID riid, PPVOID ppv ) ;
		HRESULT DllRegisterServer() ;
		HRESULT DllUnregisterServer() ;
		HRESULT InitComServer() ;
		HRESULT UninitComServer() ;
};



#endif // _WMI_FACTORY_ROUTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\common\factoryrouter.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FactoryRouter.cpp -- Generic Com Class factory class
//
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "dllmain.h"
#include "cautolock.h"

using namespace std;
#include "FactoryRouter.h"
#define DUPLICATE_RELEASE FALSE

extern CFactoryRouterData g_FactoryRouterData;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************************
// Utility functions
//*************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ClsToString( CHString &a_chsClsId, REFGUID a_rClsId ) 
{
	WCHAR wcID[128] ;
	StringFromGUID2( a_rClsId, wcID, 128 ) ;

	a_chsClsId = wcID ;

	a_chsClsId.MakeUpper() ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************************
//  The CFactoryRouter Class
//*************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouter::CFactoryRouter(REFGUID	a_rClsId, LPCWSTR a_pClassName):m_Register( 0 )
{
	m_ClsId = a_rClsId ; 
	m_sDescription = a_pClassName ;
	g_FactoryRouterData.AddToMap( a_rClsId,this ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouter::~CFactoryRouter()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CFactoryRouter::AddRef()
{	
	return g_FactoryRouterData.AddRef();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CFactoryRouter::Release()
{
	ULONG nRet = g_FactoryRouterData.Release();
	if ( nRet == 0 )
	{
		try
		{
			LogMessage(L"CFactoryRouter Ref Count = 0");
		}
		catch ( ... )
		{
		}
//	    delete this;  Can't delete this, because these hang around the whole time the dll is loaded
//      the ptr to this factory is deleted upon dll being detached		
	}
	else if (nRet > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
		LogErrorMessage(L"Duplicate CFactoryRouter Release()");
    }
	return nRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CFactoryRouter::QueryInterface( REFIID a_riid, PPVOID a_ppv )
{
    *a_ppv = NULL ;

    if ( IID_IUnknown == a_riid || IID_IClassFactory == a_riid )
	{
        *a_ppv = this ;
    }
    
    if ( NULL != *a_ppv )    
    {
        AddRef() ;
        return NOERROR ;
    }
    return ResultFromScode( E_NOINTERFACE ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CFactoryRouter::LockSer